{
    "glance/api/authorization.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "             raise exception.Forbidden(message"
            },
            "1": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "                                       % self.image.image_id)"
            },
            "2": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image_member):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    def save(self, image_member, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         if (self.context.is_admin or"
            },
            "6": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "                 self.context.owner == image_member.member_id):"
            },
            "7": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.member_repo.save(image_member)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            self.member_repo.save(image_member, from_state=from_state)"
            },
            "9": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         else:"
            },
            "10": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             message = _(\"You cannot update image member %s\")"
            },
            "11": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             raise exception.Forbidden(message % image_member.member_id)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "from glance import i18n",
            "",
            "_ = i18n._",
            "",
            "",
            "def is_image_mutable(context, image):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if image.owner is None or context.owner is None:",
            "        return False",
            "",
            "    return image.owner == context.owner",
            "",
            "",
            "def proxy_image(context, image):",
            "    if is_image_mutable(context, image):",
            "        return ImageProxy(image, context)",
            "    else:",
            "        return ImmutableImageProxy(image, context)",
            "",
            "",
            "def is_member_mutable(context, member):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return member.member_id == context.owner",
            "",
            "",
            "def proxy_member(context, member):",
            "    if is_member_mutable(context, member):",
            "        return member",
            "    else:",
            "        return ImmutableMemberProxy(member)",
            "",
            "",
            "def is_task_mutable(context, task):",
            "    \"\"\"Return True if the task is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return task.owner == context.owner",
            "",
            "",
            "def is_task_stub_mutable(context, task_stub):",
            "    \"\"\"Return True if the task stub is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return task_stub.owner == context.owner",
            "",
            "",
            "def proxy_task(context, task):",
            "    if is_task_mutable(context, task):",
            "        return task",
            "    else:",
            "        return ImmutableTaskProxy(task)",
            "",
            "",
            "def proxy_task_stub(context, task_stub):",
            "    if is_task_stub_mutable(context, task_stub):",
            "        return task_stub",
            "    else:",
            "        return ImmutableTaskStubProxy(task_stub)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context):",
            "        self.context = context",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        image = self.image_repo.get(image_id)",
            "        return proxy_image(self.context, image)",
            "",
            "    def list(self, *args, **kwargs):",
            "        images = self.image_repo.list(*args, **kwargs)",
            "        return [proxy_image(self.context, i) for i in images]",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, image, context):",
            "        self.member_repo = member_repo",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageMemberRepoProxy, self).__init__(member_repo)",
            "",
            "    def get(self, member_id):",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner or",
            "                self.context.owner == member_id):",
            "            member = self.member_repo.get(member_id)",
            "            return proxy_member(self.context, member)",
            "        else:",
            "            message = _(\"You cannot get image member for %s\")",
            "            raise exception.Forbidden(message % member_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        members = self.member_repo.list(*args, **kwargs)",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner):",
            "            return [proxy_member(self.context, m) for m in members]",
            "        for member in members:",
            "            if member.member_id == self.context.owner:",
            "                return [proxy_member(self.context, member)]",
            "        message = _(\"You cannot get image member for %s\")",
            "        raise exception.Forbidden(message % self.image.image_id)",
            "",
            "    def remove(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.remove(image_member)",
            "        else:",
            "            message = _(\"You cannot delete image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def add(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.add(image_member)",
            "        else:",
            "            message = _(\"You cannot add image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def save(self, image_member):",
            "        if (self.context.is_admin or",
            "                self.context.owner == image_member.member_id):",
            "            self.member_repo.save(image_member)",
            "        else:",
            "            message = _(\"You cannot update image member %s\")",
            "            raise exception.Forbidden(message % image_member.member_id)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        kwargs = {'context': self.context}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create images \"",
            "                            \"owned by '%s'.\")",
            "                raise exception.Forbidden(message % owner)",
            "",
            "        return super(ImageFactoryProxy, self).new_image(owner=owner, **kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(object):",
            "",
            "    def __init__(self, image_member_factory, context):",
            "        self.image_member_factory = image_member_factory",
            "        self.context = context",
            "",
            "    def new_image_member(self, image, member_id):",
            "        owner = image.owner",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create image members \"",
            "                            \"for the image.\")",
            "                raise exception.Forbidden(message)",
            "",
            "        if image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "",
            "        return self.image_member_factory.new_image_member(image, member_id)",
            "",
            "",
            "def _immutable_attr(target, attr, proxy=None):",
            "",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        if proxy is not None:",
            "            value = proxy(value)",
            "        return value",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        resource = getattr(self, 'resource_name', 'resource')",
            "        message = _(\"You are not permitted to modify '%(attr)s' on this \"",
            "                    \"%(resource)s.\")",
            "        raise exception.Forbidden(message % {'attr': attr,",
            "                                             'resource': resource})",
            "",
            "    return property(get_attr, forbidden, forbidden)",
            "",
            "",
            "class ImmutableLocations(list):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify locations \"",
            "                    \"for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def __deepcopy__(self, memo):",
            "        return ImmutableLocations(copy.deepcopy(list(self), memo))",
            "",
            "    append = forbidden",
            "    extend = forbidden",
            "    insert = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    reverse = forbidden",
            "    sort = forbidden",
            "    __delitem__ = forbidden",
            "    __delslice__ = forbidden",
            "    __iadd__ = forbidden",
            "    __imul__ = forbidden",
            "    __setitem__ = forbidden",
            "    __setslice__ = forbidden",
            "",
            "",
            "class ImmutableProperties(dict):",
            "    def forbidden_key(self, key, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify '%s' on this image.\")",
            "        raise exception.Forbidden(message % key)",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    __delitem__ = forbidden_key",
            "    __setitem__ = forbidden_key",
            "    pop = forbidden",
            "    popitem = forbidden",
            "    setdefault = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableTags(set):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify tags on this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    add = forbidden",
            "    clear = forbidden",
            "    difference_update = forbidden",
            "    intersection_update = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    symmetric_difference_update = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableImageProxy(object):",
            "    def __init__(self, base, context):",
            "        self.base = base",
            "        self.context = context",
            "        self.resource_name = 'image'",
            "",
            "    name = _immutable_attr('base', 'name')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    name = _immutable_attr('base', 'name')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "    visibility = _immutable_attr('base', 'visibility')",
            "    min_disk = _immutable_attr('base', 'min_disk')",
            "    min_ram = _immutable_attr('base', 'min_ram')",
            "    protected = _immutable_attr('base', 'protected')",
            "    locations = _immutable_attr('base', 'locations', proxy=ImmutableLocations)",
            "    checksum = _immutable_attr('base', 'checksum')",
            "    owner = _immutable_attr('base', 'owner')",
            "    disk_format = _immutable_attr('base', 'disk_format')",
            "    container_format = _immutable_attr('base', 'container_format')",
            "    size = _immutable_attr('base', 'size')",
            "    virtual_size = _immutable_attr('base', 'virtual_size')",
            "    extra_properties = _immutable_attr('base', 'extra_properties',",
            "                                       proxy=ImmutableProperties)",
            "    tags = _immutable_attr('base', 'tags', proxy=ImmutableTags)",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = self.base.get_member_repo()",
            "        return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        return self.base.get_data(*args, **kwargs)",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to upload data for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableMemberProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'image member'",
            "",
            "    id = _immutable_attr('base', 'id')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    member_id = _immutable_attr('base', 'member_id')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "",
            "class ImmutableTaskProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'task'",
            "",
            "    task_id = _immutable_attr('base', 'task_id')",
            "    type = _immutable_attr('base', 'type')",
            "    status = _immutable_attr('base', 'status')",
            "    owner = _immutable_attr('base', 'owner')",
            "    expires_at = _immutable_attr('base', 'expires_at')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "    input = _immutable_attr('base', 'input')",
            "    message = _immutable_attr('base', 'message')",
            "    result = _immutable_attr('base', 'result')",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "    def begin_processing(self):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def succeed(self, result):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def fail(self, message):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableTaskStubProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'task stub'",
            "",
            "    task_id = _immutable_attr('base', 'task_id')",
            "    type = _immutable_attr('base', 'type')",
            "    status = _immutable_attr('base', 'status')",
            "    owner = _immutable_attr('base', 'owner')",
            "    expires_at = _immutable_attr('base', 'expires_at')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context):",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        if self.image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "        else:",
            "            member_repo = self.image.get_member_repo(**kwargs)",
            "            return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task):",
            "        self.task = task",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy)",
            "",
            "    def new_task(self, **kwargs):",
            "        owner = kwargs.get('owner', self.context.owner)",
            "",
            "        # NOTE(nikhil): Unlike Images, Tasks are expected to have owner.",
            "        # We currently do not allow even admins to set the owner to None.",
            "        if owner is not None and (owner == self.context.owner",
            "                                  or self.context.is_admin):",
            "            return super(TaskFactoryProxy, self).new_task(**kwargs)",
            "        else:",
            "            message = _(\"You are not permitted to create this task with \"",
            "                        \"owner as: %s\")",
            "            raise exception.Forbidden(message % owner)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        super(TaskRepoProxy, self).__init__(task_repo)",
            "",
            "    def get(self, task_id):",
            "        task = self.task_repo.get(task_id)",
            "        return proxy_task(self.context, task)",
            "",
            "",
            "class TaskStubRepoProxy(glance.domain.proxy.TaskStubRepo):",
            "",
            "    def __init__(self, task_stub_repo, context):",
            "        self.task_stub_repo = task_stub_repo",
            "        self.context = context",
            "        super(TaskStubRepoProxy, self).__init__(task_stub_repo)",
            "",
            "    def list(self, *args, **kwargs):",
            "        task_stubs = self.task_stub_repo.list(*args, **kwargs)",
            "        return [proxy_task_stub(self.context, t) for t in task_stubs]",
            "",
            "",
            "# Metadef Namespace classes",
            "def is_namespace_mutable(context, namespace):",
            "    \"\"\"Return True if the namespace is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return namespace.owner == context.owner",
            "",
            "",
            "def proxy_namespace(context, namespace):",
            "    if is_namespace_mutable(context, namespace):",
            "        return namespace",
            "    else:",
            "        return ImmutableMetadefNamespaceProxy(namespace)",
            "",
            "",
            "class ImmutableMetadefNamespaceProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'namespace'",
            "",
            "    namespace_id = _immutable_attr('base', 'namespace_id')",
            "    namespace = _immutable_attr('base', 'namespace')",
            "    display_name = _immutable_attr('base', 'display_name')",
            "    description = _immutable_attr('base', 'description')",
            "    owner = _immutable_attr('base', 'owner')",
            "    visibility = _immutable_attr('base', 'visibility')",
            "    protected = _immutable_attr('base', 'protected')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this namespace.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this namespace.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefNamespaceProxy(glance.domain.proxy.MetadefNamespace):",
            "",
            "    def __init__(self, namespace):",
            "        self.namespace_input = namespace",
            "        super(MetadefNamespaceProxy, self).__init__(namespace)",
            "",
            "",
            "class MetadefNamespaceFactoryProxy(",
            "        glance.domain.proxy.MetadefNamespaceFactory):",
            "",
            "    def __init__(self, meta_namespace_factory, context):",
            "        self.meta_namespace_factory = meta_namespace_factory",
            "        self.context = context",
            "        super(MetadefNamespaceFactoryProxy, self).__init__(",
            "            meta_namespace_factory,",
            "            meta_namespace_proxy_class=MetadefNamespaceProxy)",
            "",
            "    def new_namespace(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create namespace \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefNamespaceFactoryProxy, self).new_namespace(",
            "            owner=owner, **kwargs)",
            "",
            "",
            "class MetadefNamespaceRepoProxy(glance.domain.proxy.MetadefNamespaceRepo):",
            "",
            "    def __init__(self, namespace_repo, context):",
            "        self.namespace_repo = namespace_repo",
            "        self.context = context",
            "        super(MetadefNamespaceRepoProxy, self).__init__(namespace_repo)",
            "",
            "    def get(self, namespace):",
            "        namespace_obj = self.namespace_repo.get(namespace)",
            "        return proxy_namespace(self.context, namespace_obj)",
            "",
            "    def list(self, *args, **kwargs):",
            "        namespaces = self.namespace_repo.list(*args, **kwargs)",
            "        return [proxy_namespace(self.context, namespace) for",
            "                namespace in namespaces]",
            "",
            "",
            "# Metadef Object classes",
            "def is_object_mutable(context, object):",
            "    \"\"\"Return True if the object is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return object.namespace.owner == context.owner",
            "",
            "",
            "def proxy_object(context, object):",
            "    if is_object_mutable(context, object):",
            "        return object",
            "    else:",
            "        return ImmutableMetadefObjectProxy(object)",
            "",
            "",
            "class ImmutableMetadefObjectProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'object'",
            "",
            "    object_id = _immutable_attr('base', 'object_id')",
            "    name = _immutable_attr('base', 'name')",
            "    required = _immutable_attr('base', 'required')",
            "    description = _immutable_attr('base', 'description')",
            "    properties = _immutable_attr('base', 'properties')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this object.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this object.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefObjectProxy(glance.domain.proxy.MetadefObject):",
            "",
            "    def __init__(self, meta_object):",
            "        self.meta_object = meta_object",
            "        super(MetadefObjectProxy, self).__init__(meta_object)",
            "",
            "",
            "class MetadefObjectFactoryProxy(glance.domain.proxy.MetadefObjectFactory):",
            "",
            "    def __init__(self, meta_object_factory, context):",
            "        self.meta_object_factory = meta_object_factory",
            "        self.context = context",
            "        super(MetadefObjectFactoryProxy, self).__init__(",
            "            meta_object_factory,",
            "            meta_object_proxy_class=MetadefObjectProxy)",
            "",
            "    def new_object(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create object \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefObjectFactoryProxy, self).new_object(**kwargs)",
            "",
            "",
            "class MetadefObjectRepoProxy(glance.domain.proxy.MetadefObjectRepo):",
            "",
            "    def __init__(self, object_repo, context):",
            "        self.object_repo = object_repo",
            "        self.context = context",
            "        super(MetadefObjectRepoProxy, self).__init__(object_repo)",
            "",
            "    def get(self, namespace, object_name):",
            "        meta_object = self.object_repo.get(namespace, object_name)",
            "        return proxy_object(self.context, meta_object)",
            "",
            "    def list(self, *args, **kwargs):",
            "        objects = self.object_repo.list(*args, **kwargs)",
            "        return [proxy_object(self.context, meta_object) for",
            "                meta_object in objects]",
            "",
            "",
            "# Metadef ResourceType classes",
            "def is_meta_resource_type_mutable(context, meta_resource_type):",
            "    \"\"\"Return True if the meta_resource_type is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    # (lakshmiS): resource type can exist without an association with",
            "    # namespace and resource type cannot be created/update/deleted directly(",
            "    # they have to be associated/de-associated from namespace)",
            "    if meta_resource_type.namespace:",
            "        return meta_resource_type.namespace.owner == context.owner",
            "    else:",
            "        return False",
            "",
            "",
            "def proxy_meta_resource_type(context, meta_resource_type):",
            "    if is_meta_resource_type_mutable(context, meta_resource_type):",
            "        return meta_resource_type",
            "    else:",
            "        return ImmutableMetadefResourceTypeProxy(meta_resource_type)",
            "",
            "",
            "class ImmutableMetadefResourceTypeProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'meta_resource_type'",
            "",
            "    namespace = _immutable_attr('base', 'namespace')",
            "    name = _immutable_attr('base', 'name')",
            "    prefix = _immutable_attr('base', 'prefix')",
            "    properties_target = _immutable_attr('base', 'properties_target')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this meta_resource_type.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefResourceTypeProxy(glance.domain.proxy.MetadefResourceType):",
            "",
            "    def __init__(self, meta_resource_type):",
            "        self.meta_resource_type = meta_resource_type",
            "        super(MetadefResourceTypeProxy, self).__init__(meta_resource_type)",
            "",
            "",
            "class MetadefResourceTypeFactoryProxy(",
            "        glance.domain.proxy.MetadefResourceTypeFactory):",
            "",
            "    def __init__(self, resource_type_factory, context):",
            "        self.meta_resource_type_factory = resource_type_factory",
            "        self.context = context",
            "        super(MetadefResourceTypeFactoryProxy, self).__init__(",
            "            resource_type_factory,",
            "            resource_type_proxy_class=MetadefResourceTypeProxy)",
            "",
            "    def new_resource_type(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create resource_type \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefResourceTypeFactoryProxy, self).new_resource_type(",
            "            **kwargs)",
            "",
            "",
            "class MetadefResourceTypeRepoProxy(",
            "        glance.domain.proxy.MetadefResourceTypeRepo):",
            "",
            "    def __init__(self, meta_resource_type_repo, context):",
            "        self.meta_resource_type_repo = meta_resource_type_repo",
            "        self.context = context",
            "        super(MetadefResourceTypeRepoProxy, self).__init__(",
            "            meta_resource_type_repo)",
            "",
            "    def list(self, *args, **kwargs):",
            "        meta_resource_types = self.meta_resource_type_repo.list(",
            "            *args, **kwargs)",
            "        return [proxy_meta_resource_type(self.context, meta_resource_type) for",
            "                meta_resource_type in meta_resource_types]",
            "",
            "    def get(self, *args, **kwargs):",
            "        meta_resource_type = self.meta_resource_type_repo.get(*args, **kwargs)",
            "        return proxy_meta_resource_type(self.context, meta_resource_type)",
            "",
            "",
            "# Metadef namespace properties classes",
            "def is_namespace_property_mutable(context, namespace_property):",
            "    \"\"\"Return True if the object is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return namespace_property.namespace.owner == context.owner",
            "",
            "",
            "def proxy_namespace_property(context, namespace_property):",
            "    if is_namespace_property_mutable(context, namespace_property):",
            "        return namespace_property",
            "    else:",
            "        return ImmutableMetadefPropertyProxy(namespace_property)",
            "",
            "",
            "class ImmutableMetadefPropertyProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'namespace_property'",
            "",
            "    property_id = _immutable_attr('base', 'property_id')",
            "    name = _immutable_attr('base', 'name')",
            "    schema = _immutable_attr('base', 'schema')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this property.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this property.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefPropertyProxy(glance.domain.proxy.MetadefProperty):",
            "",
            "    def __init__(self, namespace_property):",
            "        self.meta_object = namespace_property",
            "        super(MetadefPropertyProxy, self).__init__(namespace_property)",
            "",
            "",
            "class MetadefPropertyFactoryProxy(glance.domain.proxy.MetadefPropertyFactory):",
            "",
            "    def __init__(self, namespace_property_factory, context):",
            "        self.meta_object_factory = namespace_property_factory",
            "        self.context = context",
            "        super(MetadefPropertyFactoryProxy, self).__init__(",
            "            namespace_property_factory,",
            "            property_proxy_class=MetadefPropertyProxy)",
            "",
            "    def new_namespace_property(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create property \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefPropertyFactoryProxy, self).new_namespace_property(",
            "            **kwargs)",
            "",
            "",
            "class MetadefPropertyRepoProxy(glance.domain.proxy.MetadefPropertyRepo):",
            "",
            "    def __init__(self, namespace_property_repo, context):",
            "        self.namespace_property_repo = namespace_property_repo",
            "        self.context = context",
            "        super(MetadefPropertyRepoProxy, self).__init__(namespace_property_repo)",
            "",
            "    def get(self, namespace, object_name):",
            "        namespace_property = self.namespace_property_repo.get(namespace,",
            "                                                              object_name)",
            "        return proxy_namespace_property(self.context, namespace_property)",
            "",
            "    def list(self, *args, **kwargs):",
            "        namespace_properties = self.namespace_property_repo.list(",
            "            *args, **kwargs)",
            "        return [proxy_namespace_property(self.context, namespace_property) for",
            "                namespace_property in namespace_properties]",
            "",
            "",
            "# Metadef Tag classes",
            "def is_tag_mutable(context, tag):",
            "    \"\"\"Return True if the tag is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return tag.namespace.owner == context.owner",
            "",
            "",
            "def proxy_tag(context, tag):",
            "    if is_tag_mutable(context, tag):",
            "        return tag",
            "    else:",
            "        return ImmutableMetadefTagProxy(tag)",
            "",
            "",
            "class ImmutableMetadefTagProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'tag'",
            "",
            "    tag_id = _immutable_attr('base', 'tag_id')",
            "    name = _immutable_attr('base', 'name')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this tag.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this tag.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefTagProxy(glance.domain.proxy.MetadefTag):",
            "",
            "    def __init__(self, meta_tag):",
            "        super(MetadefTagProxy, self).__init__(meta_tag)",
            "",
            "",
            "class MetadefTagFactoryProxy(glance.domain.proxy.MetadefTagFactory):",
            "",
            "    def __init__(self, meta_tag_factory, context):",
            "        self.meta_tag_factory = meta_tag_factory",
            "        self.context = context",
            "        super(MetadefTagFactoryProxy, self).__init__(",
            "            meta_tag_factory,",
            "            meta_tag_proxy_class=MetadefTagProxy)",
            "",
            "    def new_tag(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "        if not self.context.is_admin:",
            "            if owner is None:",
            "                message = _(\"Owner must be specified to create a tag.\")",
            "                raise exception.Forbidden(message)",
            "            elif owner != self.context.owner:",
            "                message = _(\"You are not permitted to create a tag\"",
            "                            \" in the namespace owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefTagFactoryProxy, self).new_tag(**kwargs)",
            "",
            "",
            "class MetadefTagRepoProxy(glance.domain.proxy.MetadefTagRepo):",
            "",
            "    def __init__(self, tag_repo, context):",
            "        self.tag_repo = tag_repo",
            "        self.context = context",
            "        super(MetadefTagRepoProxy, self).__init__(tag_repo)",
            "",
            "    def get(self, namespace, tag_name):",
            "        meta_tag = self.tag_repo.get(namespace, tag_name)",
            "        return proxy_tag(self.context, meta_tag)",
            "",
            "    def list(self, *args, **kwargs):",
            "        tags = self.tag_repo.list(*args, **kwargs)",
            "        return [proxy_tag(self.context, meta_tag) for",
            "                meta_tag in tags]"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "from glance import i18n",
            "",
            "_ = i18n._",
            "",
            "",
            "def is_image_mutable(context, image):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if image.owner is None or context.owner is None:",
            "        return False",
            "",
            "    return image.owner == context.owner",
            "",
            "",
            "def proxy_image(context, image):",
            "    if is_image_mutable(context, image):",
            "        return ImageProxy(image, context)",
            "    else:",
            "        return ImmutableImageProxy(image, context)",
            "",
            "",
            "def is_member_mutable(context, member):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return member.member_id == context.owner",
            "",
            "",
            "def proxy_member(context, member):",
            "    if is_member_mutable(context, member):",
            "        return member",
            "    else:",
            "        return ImmutableMemberProxy(member)",
            "",
            "",
            "def is_task_mutable(context, task):",
            "    \"\"\"Return True if the task is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return task.owner == context.owner",
            "",
            "",
            "def is_task_stub_mutable(context, task_stub):",
            "    \"\"\"Return True if the task stub is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return task_stub.owner == context.owner",
            "",
            "",
            "def proxy_task(context, task):",
            "    if is_task_mutable(context, task):",
            "        return task",
            "    else:",
            "        return ImmutableTaskProxy(task)",
            "",
            "",
            "def proxy_task_stub(context, task_stub):",
            "    if is_task_stub_mutable(context, task_stub):",
            "        return task_stub",
            "    else:",
            "        return ImmutableTaskStubProxy(task_stub)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context):",
            "        self.context = context",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        image = self.image_repo.get(image_id)",
            "        return proxy_image(self.context, image)",
            "",
            "    def list(self, *args, **kwargs):",
            "        images = self.image_repo.list(*args, **kwargs)",
            "        return [proxy_image(self.context, i) for i in images]",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, image, context):",
            "        self.member_repo = member_repo",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageMemberRepoProxy, self).__init__(member_repo)",
            "",
            "    def get(self, member_id):",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner or",
            "                self.context.owner == member_id):",
            "            member = self.member_repo.get(member_id)",
            "            return proxy_member(self.context, member)",
            "        else:",
            "            message = _(\"You cannot get image member for %s\")",
            "            raise exception.Forbidden(message % member_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        members = self.member_repo.list(*args, **kwargs)",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner):",
            "            return [proxy_member(self.context, m) for m in members]",
            "        for member in members:",
            "            if member.member_id == self.context.owner:",
            "                return [proxy_member(self.context, member)]",
            "        message = _(\"You cannot get image member for %s\")",
            "        raise exception.Forbidden(message % self.image.image_id)",
            "",
            "    def remove(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.remove(image_member)",
            "        else:",
            "            message = _(\"You cannot delete image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def add(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.add(image_member)",
            "        else:",
            "            message = _(\"You cannot add image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def save(self, image_member, from_state=None):",
            "        if (self.context.is_admin or",
            "                self.context.owner == image_member.member_id):",
            "            self.member_repo.save(image_member, from_state=from_state)",
            "        else:",
            "            message = _(\"You cannot update image member %s\")",
            "            raise exception.Forbidden(message % image_member.member_id)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        kwargs = {'context': self.context}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create images \"",
            "                            \"owned by '%s'.\")",
            "                raise exception.Forbidden(message % owner)",
            "",
            "        return super(ImageFactoryProxy, self).new_image(owner=owner, **kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(object):",
            "",
            "    def __init__(self, image_member_factory, context):",
            "        self.image_member_factory = image_member_factory",
            "        self.context = context",
            "",
            "    def new_image_member(self, image, member_id):",
            "        owner = image.owner",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create image members \"",
            "                            \"for the image.\")",
            "                raise exception.Forbidden(message)",
            "",
            "        if image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "",
            "        return self.image_member_factory.new_image_member(image, member_id)",
            "",
            "",
            "def _immutable_attr(target, attr, proxy=None):",
            "",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        if proxy is not None:",
            "            value = proxy(value)",
            "        return value",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        resource = getattr(self, 'resource_name', 'resource')",
            "        message = _(\"You are not permitted to modify '%(attr)s' on this \"",
            "                    \"%(resource)s.\")",
            "        raise exception.Forbidden(message % {'attr': attr,",
            "                                             'resource': resource})",
            "",
            "    return property(get_attr, forbidden, forbidden)",
            "",
            "",
            "class ImmutableLocations(list):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify locations \"",
            "                    \"for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def __deepcopy__(self, memo):",
            "        return ImmutableLocations(copy.deepcopy(list(self), memo))",
            "",
            "    append = forbidden",
            "    extend = forbidden",
            "    insert = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    reverse = forbidden",
            "    sort = forbidden",
            "    __delitem__ = forbidden",
            "    __delslice__ = forbidden",
            "    __iadd__ = forbidden",
            "    __imul__ = forbidden",
            "    __setitem__ = forbidden",
            "    __setslice__ = forbidden",
            "",
            "",
            "class ImmutableProperties(dict):",
            "    def forbidden_key(self, key, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify '%s' on this image.\")",
            "        raise exception.Forbidden(message % key)",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    __delitem__ = forbidden_key",
            "    __setitem__ = forbidden_key",
            "    pop = forbidden",
            "    popitem = forbidden",
            "    setdefault = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableTags(set):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify tags on this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    add = forbidden",
            "    clear = forbidden",
            "    difference_update = forbidden",
            "    intersection_update = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    symmetric_difference_update = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableImageProxy(object):",
            "    def __init__(self, base, context):",
            "        self.base = base",
            "        self.context = context",
            "        self.resource_name = 'image'",
            "",
            "    name = _immutable_attr('base', 'name')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    name = _immutable_attr('base', 'name')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "    visibility = _immutable_attr('base', 'visibility')",
            "    min_disk = _immutable_attr('base', 'min_disk')",
            "    min_ram = _immutable_attr('base', 'min_ram')",
            "    protected = _immutable_attr('base', 'protected')",
            "    locations = _immutable_attr('base', 'locations', proxy=ImmutableLocations)",
            "    checksum = _immutable_attr('base', 'checksum')",
            "    owner = _immutable_attr('base', 'owner')",
            "    disk_format = _immutable_attr('base', 'disk_format')",
            "    container_format = _immutable_attr('base', 'container_format')",
            "    size = _immutable_attr('base', 'size')",
            "    virtual_size = _immutable_attr('base', 'virtual_size')",
            "    extra_properties = _immutable_attr('base', 'extra_properties',",
            "                                       proxy=ImmutableProperties)",
            "    tags = _immutable_attr('base', 'tags', proxy=ImmutableTags)",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = self.base.get_member_repo()",
            "        return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        return self.base.get_data(*args, **kwargs)",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to upload data for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableMemberProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'image member'",
            "",
            "    id = _immutable_attr('base', 'id')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    member_id = _immutable_attr('base', 'member_id')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "",
            "class ImmutableTaskProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'task'",
            "",
            "    task_id = _immutable_attr('base', 'task_id')",
            "    type = _immutable_attr('base', 'type')",
            "    status = _immutable_attr('base', 'status')",
            "    owner = _immutable_attr('base', 'owner')",
            "    expires_at = _immutable_attr('base', 'expires_at')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "    input = _immutable_attr('base', 'input')",
            "    message = _immutable_attr('base', 'message')",
            "    result = _immutable_attr('base', 'result')",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "    def begin_processing(self):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def succeed(self, result):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def fail(self, message):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableTaskStubProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'task stub'",
            "",
            "    task_id = _immutable_attr('base', 'task_id')",
            "    type = _immutable_attr('base', 'type')",
            "    status = _immutable_attr('base', 'status')",
            "    owner = _immutable_attr('base', 'owner')",
            "    expires_at = _immutable_attr('base', 'expires_at')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context):",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        if self.image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "        else:",
            "            member_repo = self.image.get_member_repo(**kwargs)",
            "            return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task):",
            "        self.task = task",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy)",
            "",
            "    def new_task(self, **kwargs):",
            "        owner = kwargs.get('owner', self.context.owner)",
            "",
            "        # NOTE(nikhil): Unlike Images, Tasks are expected to have owner.",
            "        # We currently do not allow even admins to set the owner to None.",
            "        if owner is not None and (owner == self.context.owner",
            "                                  or self.context.is_admin):",
            "            return super(TaskFactoryProxy, self).new_task(**kwargs)",
            "        else:",
            "            message = _(\"You are not permitted to create this task with \"",
            "                        \"owner as: %s\")",
            "            raise exception.Forbidden(message % owner)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        super(TaskRepoProxy, self).__init__(task_repo)",
            "",
            "    def get(self, task_id):",
            "        task = self.task_repo.get(task_id)",
            "        return proxy_task(self.context, task)",
            "",
            "",
            "class TaskStubRepoProxy(glance.domain.proxy.TaskStubRepo):",
            "",
            "    def __init__(self, task_stub_repo, context):",
            "        self.task_stub_repo = task_stub_repo",
            "        self.context = context",
            "        super(TaskStubRepoProxy, self).__init__(task_stub_repo)",
            "",
            "    def list(self, *args, **kwargs):",
            "        task_stubs = self.task_stub_repo.list(*args, **kwargs)",
            "        return [proxy_task_stub(self.context, t) for t in task_stubs]",
            "",
            "",
            "# Metadef Namespace classes",
            "def is_namespace_mutable(context, namespace):",
            "    \"\"\"Return True if the namespace is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return namespace.owner == context.owner",
            "",
            "",
            "def proxy_namespace(context, namespace):",
            "    if is_namespace_mutable(context, namespace):",
            "        return namespace",
            "    else:",
            "        return ImmutableMetadefNamespaceProxy(namespace)",
            "",
            "",
            "class ImmutableMetadefNamespaceProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'namespace'",
            "",
            "    namespace_id = _immutable_attr('base', 'namespace_id')",
            "    namespace = _immutable_attr('base', 'namespace')",
            "    display_name = _immutable_attr('base', 'display_name')",
            "    description = _immutable_attr('base', 'description')",
            "    owner = _immutable_attr('base', 'owner')",
            "    visibility = _immutable_attr('base', 'visibility')",
            "    protected = _immutable_attr('base', 'protected')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this namespace.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this namespace.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefNamespaceProxy(glance.domain.proxy.MetadefNamespace):",
            "",
            "    def __init__(self, namespace):",
            "        self.namespace_input = namespace",
            "        super(MetadefNamespaceProxy, self).__init__(namespace)",
            "",
            "",
            "class MetadefNamespaceFactoryProxy(",
            "        glance.domain.proxy.MetadefNamespaceFactory):",
            "",
            "    def __init__(self, meta_namespace_factory, context):",
            "        self.meta_namespace_factory = meta_namespace_factory",
            "        self.context = context",
            "        super(MetadefNamespaceFactoryProxy, self).__init__(",
            "            meta_namespace_factory,",
            "            meta_namespace_proxy_class=MetadefNamespaceProxy)",
            "",
            "    def new_namespace(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create namespace \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefNamespaceFactoryProxy, self).new_namespace(",
            "            owner=owner, **kwargs)",
            "",
            "",
            "class MetadefNamespaceRepoProxy(glance.domain.proxy.MetadefNamespaceRepo):",
            "",
            "    def __init__(self, namespace_repo, context):",
            "        self.namespace_repo = namespace_repo",
            "        self.context = context",
            "        super(MetadefNamespaceRepoProxy, self).__init__(namespace_repo)",
            "",
            "    def get(self, namespace):",
            "        namespace_obj = self.namespace_repo.get(namespace)",
            "        return proxy_namespace(self.context, namespace_obj)",
            "",
            "    def list(self, *args, **kwargs):",
            "        namespaces = self.namespace_repo.list(*args, **kwargs)",
            "        return [proxy_namespace(self.context, namespace) for",
            "                namespace in namespaces]",
            "",
            "",
            "# Metadef Object classes",
            "def is_object_mutable(context, object):",
            "    \"\"\"Return True if the object is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return object.namespace.owner == context.owner",
            "",
            "",
            "def proxy_object(context, object):",
            "    if is_object_mutable(context, object):",
            "        return object",
            "    else:",
            "        return ImmutableMetadefObjectProxy(object)",
            "",
            "",
            "class ImmutableMetadefObjectProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'object'",
            "",
            "    object_id = _immutable_attr('base', 'object_id')",
            "    name = _immutable_attr('base', 'name')",
            "    required = _immutable_attr('base', 'required')",
            "    description = _immutable_attr('base', 'description')",
            "    properties = _immutable_attr('base', 'properties')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this object.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this object.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefObjectProxy(glance.domain.proxy.MetadefObject):",
            "",
            "    def __init__(self, meta_object):",
            "        self.meta_object = meta_object",
            "        super(MetadefObjectProxy, self).__init__(meta_object)",
            "",
            "",
            "class MetadefObjectFactoryProxy(glance.domain.proxy.MetadefObjectFactory):",
            "",
            "    def __init__(self, meta_object_factory, context):",
            "        self.meta_object_factory = meta_object_factory",
            "        self.context = context",
            "        super(MetadefObjectFactoryProxy, self).__init__(",
            "            meta_object_factory,",
            "            meta_object_proxy_class=MetadefObjectProxy)",
            "",
            "    def new_object(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create object \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefObjectFactoryProxy, self).new_object(**kwargs)",
            "",
            "",
            "class MetadefObjectRepoProxy(glance.domain.proxy.MetadefObjectRepo):",
            "",
            "    def __init__(self, object_repo, context):",
            "        self.object_repo = object_repo",
            "        self.context = context",
            "        super(MetadefObjectRepoProxy, self).__init__(object_repo)",
            "",
            "    def get(self, namespace, object_name):",
            "        meta_object = self.object_repo.get(namespace, object_name)",
            "        return proxy_object(self.context, meta_object)",
            "",
            "    def list(self, *args, **kwargs):",
            "        objects = self.object_repo.list(*args, **kwargs)",
            "        return [proxy_object(self.context, meta_object) for",
            "                meta_object in objects]",
            "",
            "",
            "# Metadef ResourceType classes",
            "def is_meta_resource_type_mutable(context, meta_resource_type):",
            "    \"\"\"Return True if the meta_resource_type is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    # (lakshmiS): resource type can exist without an association with",
            "    # namespace and resource type cannot be created/update/deleted directly(",
            "    # they have to be associated/de-associated from namespace)",
            "    if meta_resource_type.namespace:",
            "        return meta_resource_type.namespace.owner == context.owner",
            "    else:",
            "        return False",
            "",
            "",
            "def proxy_meta_resource_type(context, meta_resource_type):",
            "    if is_meta_resource_type_mutable(context, meta_resource_type):",
            "        return meta_resource_type",
            "    else:",
            "        return ImmutableMetadefResourceTypeProxy(meta_resource_type)",
            "",
            "",
            "class ImmutableMetadefResourceTypeProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'meta_resource_type'",
            "",
            "    namespace = _immutable_attr('base', 'namespace')",
            "    name = _immutable_attr('base', 'name')",
            "    prefix = _immutable_attr('base', 'prefix')",
            "    properties_target = _immutable_attr('base', 'properties_target')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this meta_resource_type.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefResourceTypeProxy(glance.domain.proxy.MetadefResourceType):",
            "",
            "    def __init__(self, meta_resource_type):",
            "        self.meta_resource_type = meta_resource_type",
            "        super(MetadefResourceTypeProxy, self).__init__(meta_resource_type)",
            "",
            "",
            "class MetadefResourceTypeFactoryProxy(",
            "        glance.domain.proxy.MetadefResourceTypeFactory):",
            "",
            "    def __init__(self, resource_type_factory, context):",
            "        self.meta_resource_type_factory = resource_type_factory",
            "        self.context = context",
            "        super(MetadefResourceTypeFactoryProxy, self).__init__(",
            "            resource_type_factory,",
            "            resource_type_proxy_class=MetadefResourceTypeProxy)",
            "",
            "    def new_resource_type(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create resource_type \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefResourceTypeFactoryProxy, self).new_resource_type(",
            "            **kwargs)",
            "",
            "",
            "class MetadefResourceTypeRepoProxy(",
            "        glance.domain.proxy.MetadefResourceTypeRepo):",
            "",
            "    def __init__(self, meta_resource_type_repo, context):",
            "        self.meta_resource_type_repo = meta_resource_type_repo",
            "        self.context = context",
            "        super(MetadefResourceTypeRepoProxy, self).__init__(",
            "            meta_resource_type_repo)",
            "",
            "    def list(self, *args, **kwargs):",
            "        meta_resource_types = self.meta_resource_type_repo.list(",
            "            *args, **kwargs)",
            "        return [proxy_meta_resource_type(self.context, meta_resource_type) for",
            "                meta_resource_type in meta_resource_types]",
            "",
            "    def get(self, *args, **kwargs):",
            "        meta_resource_type = self.meta_resource_type_repo.get(*args, **kwargs)",
            "        return proxy_meta_resource_type(self.context, meta_resource_type)",
            "",
            "",
            "# Metadef namespace properties classes",
            "def is_namespace_property_mutable(context, namespace_property):",
            "    \"\"\"Return True if the object is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return namespace_property.namespace.owner == context.owner",
            "",
            "",
            "def proxy_namespace_property(context, namespace_property):",
            "    if is_namespace_property_mutable(context, namespace_property):",
            "        return namespace_property",
            "    else:",
            "        return ImmutableMetadefPropertyProxy(namespace_property)",
            "",
            "",
            "class ImmutableMetadefPropertyProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'namespace_property'",
            "",
            "    property_id = _immutable_attr('base', 'property_id')",
            "    name = _immutable_attr('base', 'name')",
            "    schema = _immutable_attr('base', 'schema')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this property.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this property.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefPropertyProxy(glance.domain.proxy.MetadefProperty):",
            "",
            "    def __init__(self, namespace_property):",
            "        self.meta_object = namespace_property",
            "        super(MetadefPropertyProxy, self).__init__(namespace_property)",
            "",
            "",
            "class MetadefPropertyFactoryProxy(glance.domain.proxy.MetadefPropertyFactory):",
            "",
            "    def __init__(self, namespace_property_factory, context):",
            "        self.meta_object_factory = namespace_property_factory",
            "        self.context = context",
            "        super(MetadefPropertyFactoryProxy, self).__init__(",
            "            namespace_property_factory,",
            "            property_proxy_class=MetadefPropertyProxy)",
            "",
            "    def new_namespace_property(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create property \"",
            "                            \"owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefPropertyFactoryProxy, self).new_namespace_property(",
            "            **kwargs)",
            "",
            "",
            "class MetadefPropertyRepoProxy(glance.domain.proxy.MetadefPropertyRepo):",
            "",
            "    def __init__(self, namespace_property_repo, context):",
            "        self.namespace_property_repo = namespace_property_repo",
            "        self.context = context",
            "        super(MetadefPropertyRepoProxy, self).__init__(namespace_property_repo)",
            "",
            "    def get(self, namespace, object_name):",
            "        namespace_property = self.namespace_property_repo.get(namespace,",
            "                                                              object_name)",
            "        return proxy_namespace_property(self.context, namespace_property)",
            "",
            "    def list(self, *args, **kwargs):",
            "        namespace_properties = self.namespace_property_repo.list(",
            "            *args, **kwargs)",
            "        return [proxy_namespace_property(self.context, namespace_property) for",
            "                namespace_property in namespace_properties]",
            "",
            "",
            "# Metadef Tag classes",
            "def is_tag_mutable(context, tag):",
            "    \"\"\"Return True if the tag is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return tag.namespace.owner == context.owner",
            "",
            "",
            "def proxy_tag(context, tag):",
            "    if is_tag_mutable(context, tag):",
            "        return tag",
            "    else:",
            "        return ImmutableMetadefTagProxy(tag)",
            "",
            "",
            "class ImmutableMetadefTagProxy(object):",
            "",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'tag'",
            "",
            "    tag_id = _immutable_attr('base', 'tag_id')",
            "    name = _immutable_attr('base', 'name')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this tag.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def save(self):",
            "        message = _(\"You are not permitted to update this tag.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class MetadefTagProxy(glance.domain.proxy.MetadefTag):",
            "",
            "    def __init__(self, meta_tag):",
            "        super(MetadefTagProxy, self).__init__(meta_tag)",
            "",
            "",
            "class MetadefTagFactoryProxy(glance.domain.proxy.MetadefTagFactory):",
            "",
            "    def __init__(self, meta_tag_factory, context):",
            "        self.meta_tag_factory = meta_tag_factory",
            "        self.context = context",
            "        super(MetadefTagFactoryProxy, self).__init__(",
            "            meta_tag_factory,",
            "            meta_tag_proxy_class=MetadefTagProxy)",
            "",
            "    def new_tag(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "        if not self.context.is_admin:",
            "            if owner is None:",
            "                message = _(\"Owner must be specified to create a tag.\")",
            "                raise exception.Forbidden(message)",
            "            elif owner != self.context.owner:",
            "                message = _(\"You are not permitted to create a tag\"",
            "                            \" in the namespace owned by '%s'\")",
            "                raise exception.Forbidden(message % (owner))",
            "",
            "        return super(MetadefTagFactoryProxy, self).new_tag(**kwargs)",
            "",
            "",
            "class MetadefTagRepoProxy(glance.domain.proxy.MetadefTagRepo):",
            "",
            "    def __init__(self, tag_repo, context):",
            "        self.tag_repo = tag_repo",
            "        self.context = context",
            "        super(MetadefTagRepoProxy, self).__init__(tag_repo)",
            "",
            "    def get(self, namespace, tag_name):",
            "        meta_tag = self.tag_repo.get(namespace, tag_name)",
            "        return proxy_tag(self.context, meta_tag)",
            "",
            "    def list(self, *args, **kwargs):",
            "        tags = self.tag_repo.list(*args, **kwargs)",
            "        return [proxy_tag(self.context, meta_tag) for",
            "                meta_tag in tags]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "164": [
                "ImageMemberRepoProxy",
                "save"
            ],
            "167": [
                "ImageMemberRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/api/policy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         self.policy.enforce(self.context, 'get_images', {})"
            },
            "1": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         return super(ImageRepoProxy, self).list(*args, **kwargs)"
            },
            "2": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self.policy.enforce(self.context, 'modify_image', {})"
            },
            "6": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return super(ImageRepoProxy, self).save(image)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        return super(ImageRepoProxy, self).save(image, from_state=from_state)"
            },
            "8": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     def add(self, image):"
            },
            "10": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         self.policy.enforce(self.context, 'add_image', {})"
            },
            "11": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         self.policy.enforce(self.context, 'get_member', {})"
            },
            "12": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         return self.member_repo.get(member_id)"
            },
            "13": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, member):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+    def save(self, member, from_state=None):"
            },
            "16": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         self.policy.enforce(self.context, 'modify_member', {})"
            },
            "17": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.member_repo.save(member)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        self.member_repo.save(member, from_state=from_state)"
            },
            "19": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "     def list(self, *args, **kwargs):"
            },
            "21": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         self.policy.enforce(self.context, 'get_members', {})"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2011 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Policy Engine For Glance\"\"\"",
            "",
            "import copy",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "from glance.openstack.common import policy",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "CONF = cfg.CONF",
            "",
            "DEFAULT_RULES = {",
            "    'context_is_admin': policy.RoleCheck('role', 'admin'),",
            "    'default': policy.TrueCheck(),",
            "    'manage_image_cache': policy.RoleCheck('role', 'admin'),",
            "}",
            "",
            "_ = i18n._",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "",
            "",
            "class Enforcer(policy.Enforcer):",
            "    \"\"\"Responsible for loading and enforcing rules\"\"\"",
            "",
            "    def __init__(self):",
            "        if CONF.find_file(CONF.policy_file):",
            "            kwargs = dict(rules=None, use_conf=True)",
            "        else:",
            "            kwargs = dict(rules=DEFAULT_RULES, use_conf=False)",
            "        super(Enforcer, self).__init__(overwrite=False, **kwargs)",
            "",
            "    def add_rules(self, rules):",
            "        \"\"\"Add new rules to the Rules object\"\"\"",
            "        self.set_rules(rules, overwrite=False, use_conf=self.use_conf)",
            "",
            "    def enforce(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param target: Dictionary representing the object of the action.",
            "           :raises: `glance.common.exception.Forbidden`",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        credentials = {",
            "            'roles': context.roles,",
            "            'user': context.user,",
            "            'tenant': context.tenant,",
            "        }",
            "        return super(Enforcer, self).enforce(action, target, credentials,",
            "                                             do_raise=True,",
            "                                             exc=exception.Forbidden,",
            "                                             action=action)",
            "",
            "    def check(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param target: Dictionary representing the object of the action.",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        credentials = {",
            "            'roles': context.roles,",
            "            'user': context.user,",
            "            'tenant': context.tenant,",
            "        }",
            "        return super(Enforcer, self).enforce(action, target, credentials)",
            "",
            "    def check_is_admin(self, context):",
            "        \"\"\"Check if the given context is associated with an admin role,",
            "           as defined via the 'context_is_admin' RBAC rule.",
            "",
            "           :param context: Glance request context",
            "           :returns: A non-False value if context role is admin.",
            "        \"\"\"",
            "        return self.check(context, 'context_is_admin', context.to_dict())",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, policy):",
            "        self.context = context",
            "        self.policy = policy",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        self.policy.enforce(self.context, 'get_image', {})",
            "        return super(ImageRepoProxy, self).get(image_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_images', {})",
            "        return super(ImageRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, image):",
            "        self.policy.enforce(self.context, 'modify_image', {})",
            "        return super(ImageRepoProxy, self).save(image)",
            "",
            "    def add(self, image):",
            "        self.policy.enforce(self.context, 'add_image', {})",
            "        return super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, policy):",
            "        self.image = image",
            "        self.context = context",
            "        self.policy = policy",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    @property",
            "    def visibility(self):",
            "        return self.image.visibility",
            "",
            "    @visibility.setter",
            "    def visibility(self, value):",
            "        if value == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        self.image.visibility = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return ImageLocationsProxy(self.image.locations,",
            "                                   self.context, self.policy)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        if not isinstance(value, (list, ImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "        self.policy.enforce(self.context, 'set_image_location', {})",
            "        new_locations = list(value)",
            "        if (set([loc['url'] for loc in self.image.locations]) -",
            "                set([loc['url'] for loc in new_locations])):",
            "            self.policy.enforce(self.context, 'delete_image_location', {})",
            "        self.image.locations = new_locations",
            "",
            "    def delete(self):",
            "        self.policy.enforce(self.context, 'delete_image', {})",
            "        return self.image.delete()",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        target = ImageTarget(self.image)",
            "        self.policy.enforce(self.context, 'download_image',",
            "                            target=target)",
            "        return self.image.get_data(*args, **kwargs)",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'upload_image', {})",
            "        return self.image.set_data(*args, **kwargs)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        member_repo = self.image.get_member_repo(**kwargs)",
            "        return ImageMemberRepoProxy(member_repo, self.context, self.policy)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context, policy):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        if kwargs.get('visibility') == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, policy):",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs={'context': context, 'policy': policy})",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, context, policy):",
            "        self.member_repo = member_repo",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def add(self, member):",
            "        self.policy.enforce(self.context, 'add_member', {})",
            "        self.member_repo.add(member)",
            "",
            "    def get(self, member_id):",
            "        self.policy.enforce(self.context, 'get_member', {})",
            "        return self.member_repo.get(member_id)",
            "",
            "    def save(self, member):",
            "        self.policy.enforce(self.context, 'modify_member', {})",
            "        self.member_repo.save(member)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_members', {})",
            "        return self.member_repo.list(*args, **kwargs)",
            "",
            "    def remove(self, member):",
            "        self.policy.enforce(self.context, 'delete_member', {})",
            "        self.member_repo.remove(member)",
            "",
            "",
            "class ImageLocationsProxy(object):",
            "",
            "    __hash__ = None",
            "",
            "    def __init__(self, locations, context, policy):",
            "        self.locations = locations",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.locations, self.context, self.policy)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        return type(self)(copy.deepcopy(self.locations, memo),",
            "                          self.context, self.policy)",
            "",
            "    def _get_checker(action, func_name):",
            "        def _checker(self, *args, **kwargs):",
            "            self.policy.enforce(self.context, action, {})",
            "            assert hasattr(self.locations, func_name)",
            "            method = getattr(self.locations, func_name)",
            "            return method(*args, **kwargs)",
            "        return _checker",
            "",
            "    count = _get_checker('get_image_location', 'count')",
            "    index = _get_checker('get_image_location', 'index')",
            "    __getitem__ = _get_checker('get_image_location', '__getitem__')",
            "    __contains__ = _get_checker('get_image_location', '__contains__')",
            "    __len__ = _get_checker('get_image_location', '__len__')",
            "    __cast = _get_checker('get_image_location', '__cast')",
            "    __cmp__ = _get_checker('get_image_location', '__cmp__')",
            "    __iter__ = _get_checker('get_image_location', '__iter__')",
            "",
            "    append = _get_checker('set_image_location', 'append')",
            "    extend = _get_checker('set_image_location', 'extend')",
            "    insert = _get_checker('set_image_location', 'insert')",
            "    reverse = _get_checker('set_image_location', 'reverse')",
            "    __iadd__ = _get_checker('set_image_location', '__iadd__')",
            "    __setitem__ = _get_checker('set_image_location', '__setitem__')",
            "",
            "    pop = _get_checker('delete_image_location', 'pop')",
            "    remove = _get_checker('delete_image_location', 'remove')",
            "    __delitem__ = _get_checker('delete_image_location', '__delitem__')",
            "    __delslice__ = _get_checker('delete_image_location', '__delslice__')",
            "",
            "    del _get_checker",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, policy):",
            "        self.task = task",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "",
            "class TaskStubProxy(glance.domain.proxy.TaskStub):",
            "",
            "    def __init__(self, task_stub, context, policy):",
            "        self.task_stub = task_stub",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskStubProxy, self).__init__(task_stub)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, task_policy):",
            "        self.context = context",
            "        self.policy = task_policy",
            "        self.task_repo = task_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskRepoProxy,",
            "              self).__init__(task_repo,",
            "                             task_proxy_class=TaskProxy,",
            "                             task_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, task_id):",
            "        self.policy.enforce(self.context, 'get_task', {})",
            "        return super(TaskRepoProxy, self).get(task_id)",
            "",
            "    def add(self, task):",
            "        self.policy.enforce(self.context, 'add_task', {})",
            "        super(TaskRepoProxy, self).add(task)",
            "",
            "    def save(self, task):",
            "        self.policy.enforce(self.context, 'modify_task', {})",
            "        super(TaskRepoProxy, self).save(task)",
            "",
            "",
            "class TaskStubRepoProxy(glance.domain.proxy.TaskStubRepo):",
            "",
            "    def __init__(self, task_stub_repo, context, task_policy):",
            "        self.context = context",
            "        self.policy = task_policy",
            "        self.task_stub_repo = task_stub_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskStubRepoProxy,",
            "              self).__init__(task_stub_repo,",
            "                             task_stub_proxy_class=TaskStubProxy,",
            "                             task_stub_proxy_kwargs=proxy_kwargs)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_tasks', {})",
            "        return super(TaskStubRepoProxy, self).list(*args, **kwargs)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context, policy):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "class ImageTarget(object):",
            "",
            "    def __init__(self, image):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param image: Image object",
            "        \"\"\"",
            "        self.image = image",
            "",
            "    def __getitem__(self, key):",
            "        \"\"\"",
            "        Returns the value of 'key' from the image if image has that attribute",
            "        else tries to retrieve value from the extra_properties of image.",
            "",
            "        :param key: value to retrieve",
            "        \"\"\"",
            "        # Need to change the key 'id' to 'image_id' as Image object has",
            "        # attribute as 'image_id' in case of V2.",
            "        if key == 'id':",
            "            key = 'image_id'",
            "",
            "        if hasattr(self.image, key):",
            "            return getattr(self.image, key)",
            "        else:",
            "            return self.image.extra_properties[key]",
            "",
            "",
            "# Metadef Namespace classes",
            "class MetadefNamespaceProxy(glance.domain.proxy.MetadefNamespace):",
            "",
            "    def __init__(self, namespace, context, policy):",
            "        self.namespace_input = namespace",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefNamespaceProxy, self).__init__(namespace)",
            "",
            "",
            "class MetadefNamespaceRepoProxy(glance.domain.proxy.MetadefNamespaceRepo):",
            "",
            "    def __init__(self, namespace_repo, context, namespace_policy):",
            "        self.context = context",
            "        self.policy = namespace_policy",
            "        self.namespace_repo = namespace_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefNamespaceRepoProxy,",
            "              self).__init__(namespace_repo,",
            "                             namespace_proxy_class=MetadefNamespaceProxy,",
            "                             namespace_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace):",
            "        self.policy.enforce(self.context, 'get_metadef_namespace', {})",
            "        return super(MetadefNamespaceRepoProxy, self).get(namespace)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_namespaces', {})",
            "        return super(MetadefNamespaceRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, namespace):",
            "        self.policy.enforce(self.context, 'modify_metadef_namespace', {})",
            "        return super(MetadefNamespaceRepoProxy, self).save(namespace)",
            "",
            "    def add(self, namespace):",
            "        self.policy.enforce(self.context, 'add_metadef_namespace', {})",
            "        return super(MetadefNamespaceRepoProxy, self).add(namespace)",
            "",
            "",
            "class MetadefNamespaceFactoryProxy(",
            "        glance.domain.proxy.MetadefNamespaceFactory):",
            "",
            "    def __init__(self, meta_namespace_factory, context, policy):",
            "        self.meta_namespace_factory = meta_namespace_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefNamespaceFactoryProxy, self).__init__(",
            "            meta_namespace_factory,",
            "            meta_namespace_proxy_class=MetadefNamespaceProxy,",
            "            meta_namespace_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef Object classes",
            "class MetadefObjectProxy(glance.domain.proxy.MetadefObject):",
            "",
            "    def __init__(self, meta_object, context, policy):",
            "        self.meta_object = meta_object",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefObjectProxy, self).__init__(meta_object)",
            "",
            "",
            "class MetadefObjectRepoProxy(glance.domain.proxy.MetadefObjectRepo):",
            "",
            "    def __init__(self, object_repo, context, object_policy):",
            "        self.context = context",
            "        self.policy = object_policy",
            "        self.object_repo = object_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefObjectRepoProxy,",
            "              self).__init__(object_repo,",
            "                             object_proxy_class=MetadefObjectProxy,",
            "                             object_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace, object_name):",
            "        self.policy.enforce(self.context, 'get_metadef_object', {})",
            "        return super(MetadefObjectRepoProxy, self).get(namespace, object_name)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_objects', {})",
            "        return super(MetadefObjectRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, meta_object):",
            "        self.policy.enforce(self.context, 'modify_metadef_object', {})",
            "        return super(MetadefObjectRepoProxy, self).save(meta_object)",
            "",
            "    def add(self, meta_object):",
            "        self.policy.enforce(self.context, 'add_metadef_object', {})",
            "        return super(MetadefObjectRepoProxy, self).add(meta_object)",
            "",
            "",
            "class MetadefObjectFactoryProxy(glance.domain.proxy.MetadefObjectFactory):",
            "",
            "    def __init__(self, meta_object_factory, context, policy):",
            "        self.meta_object_factory = meta_object_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefObjectFactoryProxy, self).__init__(",
            "            meta_object_factory,",
            "            meta_object_proxy_class=MetadefObjectProxy,",
            "            meta_object_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef ResourceType classes",
            "class MetadefResourceTypeProxy(glance.domain.proxy.MetadefResourceType):",
            "",
            "    def __init__(self, meta_resource_type, context, policy):",
            "        self.meta_resource_type = meta_resource_type",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefResourceTypeProxy, self).__init__(meta_resource_type)",
            "",
            "",
            "class MetadefResourceTypeRepoProxy(",
            "        glance.domain.proxy.MetadefResourceTypeRepo):",
            "",
            "    def __init__(self, resource_type_repo, context, resource_type_policy):",
            "        self.context = context",
            "        self.policy = resource_type_policy",
            "        self.resource_type_repo = resource_type_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefResourceTypeRepoProxy, self).__init__(",
            "            resource_type_repo,",
            "            resource_type_proxy_class=MetadefResourceTypeProxy,",
            "            resource_type_proxy_kwargs=proxy_kwargs)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'list_metadef_resource_types', {})",
            "        return super(MetadefResourceTypeRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def get(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_resource_type', {})",
            "        return super(MetadefResourceTypeRepoProxy, self).get(*args, **kwargs)",
            "",
            "    def add(self, resource_type):",
            "        self.policy.enforce(self.context,",
            "                            'add_metadef_resource_type_association', {})",
            "        return super(MetadefResourceTypeRepoProxy, self).add(resource_type)",
            "",
            "",
            "class MetadefResourceTypeFactoryProxy(",
            "        glance.domain.proxy.MetadefResourceTypeFactory):",
            "",
            "    def __init__(self, resource_type_factory, context, policy):",
            "        self.resource_type_factory = resource_type_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefResourceTypeFactoryProxy, self).__init__(",
            "            resource_type_factory,",
            "            resource_type_proxy_class=MetadefResourceTypeProxy,",
            "            resource_type_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef namespace properties classes",
            "class MetadefPropertyProxy(glance.domain.proxy.MetadefProperty):",
            "",
            "    def __init__(self, namespace_property, context, policy):",
            "        self.namespace_property = namespace_property",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefPropertyProxy, self).__init__(namespace_property)",
            "",
            "",
            "class MetadefPropertyRepoProxy(glance.domain.proxy.MetadefPropertyRepo):",
            "",
            "    def __init__(self, property_repo, context, object_policy):",
            "        self.context = context",
            "        self.policy = object_policy",
            "        self.property_repo = property_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefPropertyRepoProxy, self).__init__(",
            "            property_repo,",
            "            property_proxy_class=MetadefPropertyProxy,",
            "            property_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace, property_name):",
            "        self.policy.enforce(self.context, 'get_metadef_property', {})",
            "        return super(MetadefPropertyRepoProxy, self).get(namespace,",
            "                                                         property_name)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_properties', {})",
            "        return super(MetadefPropertyRepoProxy, self).list(",
            "            *args, **kwargs)",
            "",
            "    def save(self, namespace_property):",
            "        self.policy.enforce(self.context, 'modify_metadef_property', {})",
            "        return super(MetadefPropertyRepoProxy, self).save(",
            "            namespace_property)",
            "",
            "    def add(self, namespace_property):",
            "        self.policy.enforce(self.context, 'add_metadef_property', {})",
            "        return super(MetadefPropertyRepoProxy, self).add(",
            "            namespace_property)",
            "",
            "",
            "class MetadefPropertyFactoryProxy(glance.domain.proxy.MetadefPropertyFactory):",
            "",
            "    def __init__(self, namespace_property_factory, context, policy):",
            "        self.namespace_property_factory = namespace_property_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefPropertyFactoryProxy, self).__init__(",
            "            namespace_property_factory,",
            "            property_proxy_class=MetadefPropertyProxy,",
            "            property_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef Tag classes",
            "class MetadefTagProxy(glance.domain.proxy.MetadefTag):",
            "",
            "    def __init__(self, meta_tag, context, policy):",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefTagProxy, self).__init__(meta_tag)",
            "",
            "",
            "class MetadefTagRepoProxy(glance.domain.proxy.MetadefTagRepo):",
            "",
            "    def __init__(self, tag_repo, context, tag_policy):",
            "        self.context = context",
            "        self.policy = tag_policy",
            "        self.tag_repo = tag_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefTagRepoProxy,",
            "              self).__init__(tag_repo,",
            "                             tag_proxy_class=MetadefTagProxy,",
            "                             tag_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace, tag_name):",
            "        self.policy.enforce(self.context, 'get_metadef_tag', {})",
            "        return super(MetadefTagRepoProxy, self).get(namespace, tag_name)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_tags', {})",
            "        return super(MetadefTagRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, meta_tag):",
            "        self.policy.enforce(self.context, 'modify_metadef_tag', {})",
            "        return super(MetadefTagRepoProxy, self).save(meta_tag)",
            "",
            "    def add(self, meta_tag):",
            "        self.policy.enforce(self.context, 'add_metadef_tag', {})",
            "        return super(MetadefTagRepoProxy, self).add(meta_tag)",
            "",
            "    def add_tags(self, meta_tags):",
            "        self.policy.enforce(self.context, 'add_metadef_tags', {})",
            "        return super(MetadefTagRepoProxy, self).add_tags(meta_tags)",
            "",
            "",
            "class MetadefTagFactoryProxy(glance.domain.proxy.MetadefTagFactory):",
            "",
            "    def __init__(self, meta_tag_factory, context, policy):",
            "        self.meta_tag_factory = meta_tag_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefTagFactoryProxy, self).__init__(",
            "            meta_tag_factory,",
            "            meta_tag_proxy_class=MetadefTagProxy,",
            "            meta_tag_proxy_kwargs=proxy_kwargs)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2011 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Policy Engine For Glance\"\"\"",
            "",
            "import copy",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "from glance.openstack.common import policy",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "CONF = cfg.CONF",
            "",
            "DEFAULT_RULES = {",
            "    'context_is_admin': policy.RoleCheck('role', 'admin'),",
            "    'default': policy.TrueCheck(),",
            "    'manage_image_cache': policy.RoleCheck('role', 'admin'),",
            "}",
            "",
            "_ = i18n._",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "",
            "",
            "class Enforcer(policy.Enforcer):",
            "    \"\"\"Responsible for loading and enforcing rules\"\"\"",
            "",
            "    def __init__(self):",
            "        if CONF.find_file(CONF.policy_file):",
            "            kwargs = dict(rules=None, use_conf=True)",
            "        else:",
            "            kwargs = dict(rules=DEFAULT_RULES, use_conf=False)",
            "        super(Enforcer, self).__init__(overwrite=False, **kwargs)",
            "",
            "    def add_rules(self, rules):",
            "        \"\"\"Add new rules to the Rules object\"\"\"",
            "        self.set_rules(rules, overwrite=False, use_conf=self.use_conf)",
            "",
            "    def enforce(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param target: Dictionary representing the object of the action.",
            "           :raises: `glance.common.exception.Forbidden`",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        credentials = {",
            "            'roles': context.roles,",
            "            'user': context.user,",
            "            'tenant': context.tenant,",
            "        }",
            "        return super(Enforcer, self).enforce(action, target, credentials,",
            "                                             do_raise=True,",
            "                                             exc=exception.Forbidden,",
            "                                             action=action)",
            "",
            "    def check(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param target: Dictionary representing the object of the action.",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        credentials = {",
            "            'roles': context.roles,",
            "            'user': context.user,",
            "            'tenant': context.tenant,",
            "        }",
            "        return super(Enforcer, self).enforce(action, target, credentials)",
            "",
            "    def check_is_admin(self, context):",
            "        \"\"\"Check if the given context is associated with an admin role,",
            "           as defined via the 'context_is_admin' RBAC rule.",
            "",
            "           :param context: Glance request context",
            "           :returns: A non-False value if context role is admin.",
            "        \"\"\"",
            "        return self.check(context, 'context_is_admin', context.to_dict())",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, policy):",
            "        self.context = context",
            "        self.policy = policy",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        self.policy.enforce(self.context, 'get_image', {})",
            "        return super(ImageRepoProxy, self).get(image_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_images', {})",
            "        return super(ImageRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, image, from_state=None):",
            "        self.policy.enforce(self.context, 'modify_image', {})",
            "        return super(ImageRepoProxy, self).save(image, from_state=from_state)",
            "",
            "    def add(self, image):",
            "        self.policy.enforce(self.context, 'add_image', {})",
            "        return super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, policy):",
            "        self.image = image",
            "        self.context = context",
            "        self.policy = policy",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    @property",
            "    def visibility(self):",
            "        return self.image.visibility",
            "",
            "    @visibility.setter",
            "    def visibility(self, value):",
            "        if value == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        self.image.visibility = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return ImageLocationsProxy(self.image.locations,",
            "                                   self.context, self.policy)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        if not isinstance(value, (list, ImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "        self.policy.enforce(self.context, 'set_image_location', {})",
            "        new_locations = list(value)",
            "        if (set([loc['url'] for loc in self.image.locations]) -",
            "                set([loc['url'] for loc in new_locations])):",
            "            self.policy.enforce(self.context, 'delete_image_location', {})",
            "        self.image.locations = new_locations",
            "",
            "    def delete(self):",
            "        self.policy.enforce(self.context, 'delete_image', {})",
            "        return self.image.delete()",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        target = ImageTarget(self.image)",
            "        self.policy.enforce(self.context, 'download_image',",
            "                            target=target)",
            "        return self.image.get_data(*args, **kwargs)",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'upload_image', {})",
            "        return self.image.set_data(*args, **kwargs)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        member_repo = self.image.get_member_repo(**kwargs)",
            "        return ImageMemberRepoProxy(member_repo, self.context, self.policy)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context, policy):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        if kwargs.get('visibility') == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, policy):",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs={'context': context, 'policy': policy})",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, context, policy):",
            "        self.member_repo = member_repo",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def add(self, member):",
            "        self.policy.enforce(self.context, 'add_member', {})",
            "        self.member_repo.add(member)",
            "",
            "    def get(self, member_id):",
            "        self.policy.enforce(self.context, 'get_member', {})",
            "        return self.member_repo.get(member_id)",
            "",
            "    def save(self, member, from_state=None):",
            "        self.policy.enforce(self.context, 'modify_member', {})",
            "        self.member_repo.save(member, from_state=from_state)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_members', {})",
            "        return self.member_repo.list(*args, **kwargs)",
            "",
            "    def remove(self, member):",
            "        self.policy.enforce(self.context, 'delete_member', {})",
            "        self.member_repo.remove(member)",
            "",
            "",
            "class ImageLocationsProxy(object):",
            "",
            "    __hash__ = None",
            "",
            "    def __init__(self, locations, context, policy):",
            "        self.locations = locations",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.locations, self.context, self.policy)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        return type(self)(copy.deepcopy(self.locations, memo),",
            "                          self.context, self.policy)",
            "",
            "    def _get_checker(action, func_name):",
            "        def _checker(self, *args, **kwargs):",
            "            self.policy.enforce(self.context, action, {})",
            "            assert hasattr(self.locations, func_name)",
            "            method = getattr(self.locations, func_name)",
            "            return method(*args, **kwargs)",
            "        return _checker",
            "",
            "    count = _get_checker('get_image_location', 'count')",
            "    index = _get_checker('get_image_location', 'index')",
            "    __getitem__ = _get_checker('get_image_location', '__getitem__')",
            "    __contains__ = _get_checker('get_image_location', '__contains__')",
            "    __len__ = _get_checker('get_image_location', '__len__')",
            "    __cast = _get_checker('get_image_location', '__cast')",
            "    __cmp__ = _get_checker('get_image_location', '__cmp__')",
            "    __iter__ = _get_checker('get_image_location', '__iter__')",
            "",
            "    append = _get_checker('set_image_location', 'append')",
            "    extend = _get_checker('set_image_location', 'extend')",
            "    insert = _get_checker('set_image_location', 'insert')",
            "    reverse = _get_checker('set_image_location', 'reverse')",
            "    __iadd__ = _get_checker('set_image_location', '__iadd__')",
            "    __setitem__ = _get_checker('set_image_location', '__setitem__')",
            "",
            "    pop = _get_checker('delete_image_location', 'pop')",
            "    remove = _get_checker('delete_image_location', 'remove')",
            "    __delitem__ = _get_checker('delete_image_location', '__delitem__')",
            "    __delslice__ = _get_checker('delete_image_location', '__delslice__')",
            "",
            "    del _get_checker",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, policy):",
            "        self.task = task",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "",
            "class TaskStubProxy(glance.domain.proxy.TaskStub):",
            "",
            "    def __init__(self, task_stub, context, policy):",
            "        self.task_stub = task_stub",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskStubProxy, self).__init__(task_stub)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, task_policy):",
            "        self.context = context",
            "        self.policy = task_policy",
            "        self.task_repo = task_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskRepoProxy,",
            "              self).__init__(task_repo,",
            "                             task_proxy_class=TaskProxy,",
            "                             task_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, task_id):",
            "        self.policy.enforce(self.context, 'get_task', {})",
            "        return super(TaskRepoProxy, self).get(task_id)",
            "",
            "    def add(self, task):",
            "        self.policy.enforce(self.context, 'add_task', {})",
            "        super(TaskRepoProxy, self).add(task)",
            "",
            "    def save(self, task):",
            "        self.policy.enforce(self.context, 'modify_task', {})",
            "        super(TaskRepoProxy, self).save(task)",
            "",
            "",
            "class TaskStubRepoProxy(glance.domain.proxy.TaskStubRepo):",
            "",
            "    def __init__(self, task_stub_repo, context, task_policy):",
            "        self.context = context",
            "        self.policy = task_policy",
            "        self.task_stub_repo = task_stub_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskStubRepoProxy,",
            "              self).__init__(task_stub_repo,",
            "                             task_stub_proxy_class=TaskStubProxy,",
            "                             task_stub_proxy_kwargs=proxy_kwargs)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_tasks', {})",
            "        return super(TaskStubRepoProxy, self).list(*args, **kwargs)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context, policy):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "class ImageTarget(object):",
            "",
            "    def __init__(self, image):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param image: Image object",
            "        \"\"\"",
            "        self.image = image",
            "",
            "    def __getitem__(self, key):",
            "        \"\"\"",
            "        Returns the value of 'key' from the image if image has that attribute",
            "        else tries to retrieve value from the extra_properties of image.",
            "",
            "        :param key: value to retrieve",
            "        \"\"\"",
            "        # Need to change the key 'id' to 'image_id' as Image object has",
            "        # attribute as 'image_id' in case of V2.",
            "        if key == 'id':",
            "            key = 'image_id'",
            "",
            "        if hasattr(self.image, key):",
            "            return getattr(self.image, key)",
            "        else:",
            "            return self.image.extra_properties[key]",
            "",
            "",
            "# Metadef Namespace classes",
            "class MetadefNamespaceProxy(glance.domain.proxy.MetadefNamespace):",
            "",
            "    def __init__(self, namespace, context, policy):",
            "        self.namespace_input = namespace",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefNamespaceProxy, self).__init__(namespace)",
            "",
            "",
            "class MetadefNamespaceRepoProxy(glance.domain.proxy.MetadefNamespaceRepo):",
            "",
            "    def __init__(self, namespace_repo, context, namespace_policy):",
            "        self.context = context",
            "        self.policy = namespace_policy",
            "        self.namespace_repo = namespace_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefNamespaceRepoProxy,",
            "              self).__init__(namespace_repo,",
            "                             namespace_proxy_class=MetadefNamespaceProxy,",
            "                             namespace_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace):",
            "        self.policy.enforce(self.context, 'get_metadef_namespace', {})",
            "        return super(MetadefNamespaceRepoProxy, self).get(namespace)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_namespaces', {})",
            "        return super(MetadefNamespaceRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, namespace):",
            "        self.policy.enforce(self.context, 'modify_metadef_namespace', {})",
            "        return super(MetadefNamespaceRepoProxy, self).save(namespace)",
            "",
            "    def add(self, namespace):",
            "        self.policy.enforce(self.context, 'add_metadef_namespace', {})",
            "        return super(MetadefNamespaceRepoProxy, self).add(namespace)",
            "",
            "",
            "class MetadefNamespaceFactoryProxy(",
            "        glance.domain.proxy.MetadefNamespaceFactory):",
            "",
            "    def __init__(self, meta_namespace_factory, context, policy):",
            "        self.meta_namespace_factory = meta_namespace_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefNamespaceFactoryProxy, self).__init__(",
            "            meta_namespace_factory,",
            "            meta_namespace_proxy_class=MetadefNamespaceProxy,",
            "            meta_namespace_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef Object classes",
            "class MetadefObjectProxy(glance.domain.proxy.MetadefObject):",
            "",
            "    def __init__(self, meta_object, context, policy):",
            "        self.meta_object = meta_object",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefObjectProxy, self).__init__(meta_object)",
            "",
            "",
            "class MetadefObjectRepoProxy(glance.domain.proxy.MetadefObjectRepo):",
            "",
            "    def __init__(self, object_repo, context, object_policy):",
            "        self.context = context",
            "        self.policy = object_policy",
            "        self.object_repo = object_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefObjectRepoProxy,",
            "              self).__init__(object_repo,",
            "                             object_proxy_class=MetadefObjectProxy,",
            "                             object_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace, object_name):",
            "        self.policy.enforce(self.context, 'get_metadef_object', {})",
            "        return super(MetadefObjectRepoProxy, self).get(namespace, object_name)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_objects', {})",
            "        return super(MetadefObjectRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, meta_object):",
            "        self.policy.enforce(self.context, 'modify_metadef_object', {})",
            "        return super(MetadefObjectRepoProxy, self).save(meta_object)",
            "",
            "    def add(self, meta_object):",
            "        self.policy.enforce(self.context, 'add_metadef_object', {})",
            "        return super(MetadefObjectRepoProxy, self).add(meta_object)",
            "",
            "",
            "class MetadefObjectFactoryProxy(glance.domain.proxy.MetadefObjectFactory):",
            "",
            "    def __init__(self, meta_object_factory, context, policy):",
            "        self.meta_object_factory = meta_object_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefObjectFactoryProxy, self).__init__(",
            "            meta_object_factory,",
            "            meta_object_proxy_class=MetadefObjectProxy,",
            "            meta_object_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef ResourceType classes",
            "class MetadefResourceTypeProxy(glance.domain.proxy.MetadefResourceType):",
            "",
            "    def __init__(self, meta_resource_type, context, policy):",
            "        self.meta_resource_type = meta_resource_type",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefResourceTypeProxy, self).__init__(meta_resource_type)",
            "",
            "",
            "class MetadefResourceTypeRepoProxy(",
            "        glance.domain.proxy.MetadefResourceTypeRepo):",
            "",
            "    def __init__(self, resource_type_repo, context, resource_type_policy):",
            "        self.context = context",
            "        self.policy = resource_type_policy",
            "        self.resource_type_repo = resource_type_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefResourceTypeRepoProxy, self).__init__(",
            "            resource_type_repo,",
            "            resource_type_proxy_class=MetadefResourceTypeProxy,",
            "            resource_type_proxy_kwargs=proxy_kwargs)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'list_metadef_resource_types', {})",
            "        return super(MetadefResourceTypeRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def get(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_resource_type', {})",
            "        return super(MetadefResourceTypeRepoProxy, self).get(*args, **kwargs)",
            "",
            "    def add(self, resource_type):",
            "        self.policy.enforce(self.context,",
            "                            'add_metadef_resource_type_association', {})",
            "        return super(MetadefResourceTypeRepoProxy, self).add(resource_type)",
            "",
            "",
            "class MetadefResourceTypeFactoryProxy(",
            "        glance.domain.proxy.MetadefResourceTypeFactory):",
            "",
            "    def __init__(self, resource_type_factory, context, policy):",
            "        self.resource_type_factory = resource_type_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefResourceTypeFactoryProxy, self).__init__(",
            "            resource_type_factory,",
            "            resource_type_proxy_class=MetadefResourceTypeProxy,",
            "            resource_type_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef namespace properties classes",
            "class MetadefPropertyProxy(glance.domain.proxy.MetadefProperty):",
            "",
            "    def __init__(self, namespace_property, context, policy):",
            "        self.namespace_property = namespace_property",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefPropertyProxy, self).__init__(namespace_property)",
            "",
            "",
            "class MetadefPropertyRepoProxy(glance.domain.proxy.MetadefPropertyRepo):",
            "",
            "    def __init__(self, property_repo, context, object_policy):",
            "        self.context = context",
            "        self.policy = object_policy",
            "        self.property_repo = property_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefPropertyRepoProxy, self).__init__(",
            "            property_repo,",
            "            property_proxy_class=MetadefPropertyProxy,",
            "            property_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace, property_name):",
            "        self.policy.enforce(self.context, 'get_metadef_property', {})",
            "        return super(MetadefPropertyRepoProxy, self).get(namespace,",
            "                                                         property_name)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_properties', {})",
            "        return super(MetadefPropertyRepoProxy, self).list(",
            "            *args, **kwargs)",
            "",
            "    def save(self, namespace_property):",
            "        self.policy.enforce(self.context, 'modify_metadef_property', {})",
            "        return super(MetadefPropertyRepoProxy, self).save(",
            "            namespace_property)",
            "",
            "    def add(self, namespace_property):",
            "        self.policy.enforce(self.context, 'add_metadef_property', {})",
            "        return super(MetadefPropertyRepoProxy, self).add(",
            "            namespace_property)",
            "",
            "",
            "class MetadefPropertyFactoryProxy(glance.domain.proxy.MetadefPropertyFactory):",
            "",
            "    def __init__(self, namespace_property_factory, context, policy):",
            "        self.namespace_property_factory = namespace_property_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefPropertyFactoryProxy, self).__init__(",
            "            namespace_property_factory,",
            "            property_proxy_class=MetadefPropertyProxy,",
            "            property_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "# Metadef Tag classes",
            "class MetadefTagProxy(glance.domain.proxy.MetadefTag):",
            "",
            "    def __init__(self, meta_tag, context, policy):",
            "        self.context = context",
            "        self.policy = policy",
            "        super(MetadefTagProxy, self).__init__(meta_tag)",
            "",
            "",
            "class MetadefTagRepoProxy(glance.domain.proxy.MetadefTagRepo):",
            "",
            "    def __init__(self, tag_repo, context, tag_policy):",
            "        self.context = context",
            "        self.policy = tag_policy",
            "        self.tag_repo = tag_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefTagRepoProxy,",
            "              self).__init__(tag_repo,",
            "                             tag_proxy_class=MetadefTagProxy,",
            "                             tag_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, namespace, tag_name):",
            "        self.policy.enforce(self.context, 'get_metadef_tag', {})",
            "        return super(MetadefTagRepoProxy, self).get(namespace, tag_name)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_metadef_tags', {})",
            "        return super(MetadefTagRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, meta_tag):",
            "        self.policy.enforce(self.context, 'modify_metadef_tag', {})",
            "        return super(MetadefTagRepoProxy, self).save(meta_tag)",
            "",
            "    def add(self, meta_tag):",
            "        self.policy.enforce(self.context, 'add_metadef_tag', {})",
            "        return super(MetadefTagRepoProxy, self).add(meta_tag)",
            "",
            "    def add_tags(self, meta_tags):",
            "        self.policy.enforce(self.context, 'add_metadef_tags', {})",
            "        return super(MetadefTagRepoProxy, self).add_tags(meta_tags)",
            "",
            "",
            "class MetadefTagFactoryProxy(glance.domain.proxy.MetadefTagFactory):",
            "",
            "    def __init__(self, meta_tag_factory, context, policy):",
            "        self.meta_tag_factory = meta_tag_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(MetadefTagFactoryProxy, self).__init__(",
            "            meta_tag_factory,",
            "            meta_tag_proxy_class=MetadefTagProxy,",
            "            meta_tag_proxy_kwargs=proxy_kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "121": [
                "ImageRepoProxy",
                "save"
            ],
            "123": [
                "ImageRepoProxy",
                "save"
            ],
            "224": [
                "ImageMemberRepoProxy",
                "save"
            ],
            "226": [
                "ImageMemberRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/api/v1/upload_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         update_data = {'checksum': checksum,"
            },
            "1": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "                        'size': size}"
            },
            "2": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         try:"
            },
            "3": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            image_meta = registry.update_image_metadata(req.context,"
            },
            "4": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                        image_id,"
            },
            "5": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                        update_data,"
            },
            "6": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                        from_state='saving')"
            },
            "7": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "8": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except exception.NotFound as e:"
            },
            "9": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = _(\"Image %s could not be found after upload. The image may\""
            },
            "10": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \" have been deleted during the upload.\") % image_id"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            try:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                state = 'saving'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                image_meta = registry.update_image_metadata(req.context,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+                                                            image_id,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+                                                            update_data,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+                                                            from_state=state)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            except exception.Duplicate:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+                image = registry.get_image_metadata(req.context, image_id)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+                if image['status'] == 'deleted':"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+                    raise exception.NotFound()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                else:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                    raise"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        except exception.NotFound:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            msg = _LI(\"Image %s could not be found after upload. The image may\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                      \" have been deleted during the upload.\") % image_id"
            },
            "26": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             LOG.info(msg)"
            },
            "27": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             # NOTE(jculp): we need to clean up the datastore if an image"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import glance_store as store_api",
            "from oslo.config import cfg",
            "from oslo.utils import excutils",
            "import webob.exc",
            "",
            "from glance.common import exception",
            "from glance.common import store_utils",
            "from glance.common import utils",
            "import glance.db",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "import glance.registry.client.v1.api as registry",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "_ = i18n._",
            "_LE = i18n._LE",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "",
            "",
            "def initiate_deletion(req, location_data, id):",
            "    \"\"\"",
            "    Deletes image data from the location of backend store.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param location_data: Location to the image data in a data store",
            "    :param id: Opaque image identifier",
            "    \"\"\"",
            "    store_utils.delete_image_location_from_backend(req.context,",
            "                                                   id, location_data)",
            "",
            "",
            "def _kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Marks the image status to `killed`.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    # TODO(dosaboy): http://docs.openstack.org/developer/glance/statuses.html",
            "    # needs updating to reflect the fact that queued->killed and saving->killed",
            "    # are both allowed.",
            "    registry.update_image_metadata(req.context, image_id,",
            "                                   {'status': 'killed'},",
            "                                   from_state=from_state)",
            "",
            "",
            "def safe_kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Mark image killed without raising exceptions if it fails.",
            "",
            "    Since _kill is meant to be called from exceptions handlers, it should",
            "    not raise itself, rather it should just log its error.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    try:",
            "        _kill(req, image_id, from_state)",
            "    except Exception:",
            "        LOG.exception(_LE(\"Unable to kill image %(id)s: \") % {'id': image_id})",
            "",
            "",
            "def upload_data_to_store(req, image_meta, image_data, store, notifier):",
            "    \"\"\"",
            "    Upload image data to specified store.",
            "",
            "    Upload image data to the store and cleans up on error.",
            "    \"\"\"",
            "    image_id = image_meta['id']",
            "",
            "    db_api = glance.db.get_api()",
            "    image_size = image_meta.get('size')",
            "",
            "    try:",
            "        remaining = glance.api.common.check_quota(",
            "            req.context, image_size, db_api, image_id=image_id)",
            "        if remaining is not None:",
            "            image_data = utils.LimitingReader(image_data, remaining)",
            "",
            "        (uri,",
            "         size,",
            "         checksum,",
            "         location_metadata) = store_api.store_add_to_backend(",
            "             image_meta['id'],",
            "             utils.CooperativeReader(image_data),",
            "             image_meta['size'],",
            "             store,",
            "             context=req.context)",
            "",
            "        location_data = {'url': uri,",
            "                         'metadata': location_metadata,",
            "                         'status': 'active'}",
            "",
            "        try:",
            "            # recheck the quota in case there were simultaneous uploads that",
            "            # did not provide the size",
            "            glance.api.common.check_quota(",
            "                req.context, size, db_api, image_id=image_id)",
            "        except exception.StorageQuotaFull:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.info(_LI('Cleaning up %s after exceeding '",
            "                             'the quota') % image_id)",
            "                store_utils.safe_delete_from_backend(",
            "                    req.context, image_meta['id'], location_data)",
            "",
            "        def _kill_mismatched(image_meta, attr, actual):",
            "            supplied = image_meta.get(attr)",
            "            if supplied and supplied != actual:",
            "                msg = (_(\"Supplied %(attr)s (%(supplied)s) and \"",
            "                         \"%(attr)s generated from uploaded image \"",
            "                         \"(%(actual)s) did not match. Setting image \"",
            "                         \"status to 'killed'.\") % {'attr': attr,",
            "                                                   'supplied': supplied,",
            "                                                   'actual': actual})",
            "                LOG.error(msg)",
            "                safe_kill(req, image_id, 'saving')",
            "                initiate_deletion(req, location_data, image_id)",
            "                raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                               content_type=\"text/plain\",",
            "                                               request=req)",
            "",
            "        # Verify any supplied size/checksum value matches size/checksum",
            "        # returned from store when adding image",
            "        _kill_mismatched(image_meta, 'size', size)",
            "        _kill_mismatched(image_meta, 'checksum', checksum)",
            "",
            "        # Update the database with the checksum returned",
            "        # from the backend store",
            "        LOG.debug(\"Updating image %(image_id)s data. \"",
            "                  \"Checksum set to %(checksum)s, size set \"",
            "                  \"to %(size)d\", {'image_id': image_id,",
            "                                  'checksum': checksum,",
            "                                  'size': size})",
            "        update_data = {'checksum': checksum,",
            "                       'size': size}",
            "        try:",
            "            image_meta = registry.update_image_metadata(req.context,",
            "                                                        image_id,",
            "                                                        update_data,",
            "                                                        from_state='saving')",
            "",
            "        except exception.NotFound as e:",
            "            msg = _(\"Image %s could not be found after upload. The image may\"",
            "                    \" have been deleted during the upload.\") % image_id",
            "            LOG.info(msg)",
            "",
            "            # NOTE(jculp): we need to clean up the datastore if an image",
            "            # resource is deleted while the image data is being uploaded",
            "            #",
            "            # We get \"location_data\" from above call to store.add(), any",
            "            # exceptions that occur there handle this same issue internally,",
            "            # Since this is store-agnostic, should apply to all stores.",
            "            initiate_deletion(req, location_data, image_id)",
            "            raise webob.exc.HTTPPreconditionFailed(explanation=msg,",
            "                                                   request=req,",
            "                                                   content_type='text/plain')",
            "",
            "    except store_api.StoreAddDisabled:",
            "        msg = _(\"Error in store configuration. Adding images to store \"",
            "                \"is disabled.\")",
            "        LOG.exception(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPGone(explanation=msg, request=req,",
            "                                 content_type='text/plain')",
            "",
            "    except exception.Duplicate as e:",
            "        msg = (_(\"Attempt to upload duplicate image: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.warn(msg)",
            "        # NOTE(dosaboy): do not delete the image since it is likely that this",
            "        # conflict is a result of another concurrent upload that will be",
            "        # successful.",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPConflict(explanation=msg,",
            "                                     request=req,",
            "                                     content_type=\"text/plain\")",
            "",
            "    except exception.Forbidden as e:",
            "        msg = (_(\"Forbidden upload attempt: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPForbidden(explanation=msg,",
            "                                      request=req,",
            "                                      content_type=\"text/plain\")",
            "",
            "    except store_api.StorageFull as e:",
            "        msg = (_(\"Image storage media is full: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except store_api.StorageWriteDenied as e:",
            "        msg = (_(\"Insufficient permissions on image storage media: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                               request=req,",
            "                                               content_type='text/plain')",
            "",
            "    except exception.ImageSizeLimitExceeded as e:",
            "        msg = (_(\"Denying attempt to upload image larger than %d bytes.\")",
            "               % CONF.image_size_cap)",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except exception.StorageQuotaFull as e:",
            "        msg = (_(\"Denying attempt to upload image because it exceeds the .\"",
            "                 \"quota: %s\") % utils.exception_to_str(e))",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except webob.exc.HTTPError:",
            "        # NOTE(bcwaldon): Ideally, we would just call 'raise' here,",
            "        # but something in the above function calls is affecting the",
            "        # exception context and we must explicitly re-raise the",
            "        # caught exception.",
            "        msg = _LE(\"Received HTTP error while uploading image %s\") % image_id",
            "        notifier.error('image.upload', msg)",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.exception(msg)",
            "            safe_kill(req, image_id, 'saving')",
            "",
            "    except (ValueError, IOError) as e:",
            "        msg = _(\"Client disconnected before sending all data to backend\")",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                       content_type=\"text/plain\",",
            "                                       request=req)",
            "",
            "    except Exception as e:",
            "        msg = _(\"Failed to upload image %s\") % image_id",
            "        LOG.exception(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPInternalServerError(explanation=msg,",
            "                                                request=req,",
            "                                                content_type='text/plain')",
            "",
            "    return image_meta, location_data"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import glance_store as store_api",
            "from oslo.config import cfg",
            "from oslo.utils import excutils",
            "import webob.exc",
            "",
            "from glance.common import exception",
            "from glance.common import store_utils",
            "from glance.common import utils",
            "import glance.db",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "import glance.registry.client.v1.api as registry",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "_ = i18n._",
            "_LE = i18n._LE",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "",
            "",
            "def initiate_deletion(req, location_data, id):",
            "    \"\"\"",
            "    Deletes image data from the location of backend store.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param location_data: Location to the image data in a data store",
            "    :param id: Opaque image identifier",
            "    \"\"\"",
            "    store_utils.delete_image_location_from_backend(req.context,",
            "                                                   id, location_data)",
            "",
            "",
            "def _kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Marks the image status to `killed`.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    # TODO(dosaboy): http://docs.openstack.org/developer/glance/statuses.html",
            "    # needs updating to reflect the fact that queued->killed and saving->killed",
            "    # are both allowed.",
            "    registry.update_image_metadata(req.context, image_id,",
            "                                   {'status': 'killed'},",
            "                                   from_state=from_state)",
            "",
            "",
            "def safe_kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Mark image killed without raising exceptions if it fails.",
            "",
            "    Since _kill is meant to be called from exceptions handlers, it should",
            "    not raise itself, rather it should just log its error.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    try:",
            "        _kill(req, image_id, from_state)",
            "    except Exception:",
            "        LOG.exception(_LE(\"Unable to kill image %(id)s: \") % {'id': image_id})",
            "",
            "",
            "def upload_data_to_store(req, image_meta, image_data, store, notifier):",
            "    \"\"\"",
            "    Upload image data to specified store.",
            "",
            "    Upload image data to the store and cleans up on error.",
            "    \"\"\"",
            "    image_id = image_meta['id']",
            "",
            "    db_api = glance.db.get_api()",
            "    image_size = image_meta.get('size')",
            "",
            "    try:",
            "        remaining = glance.api.common.check_quota(",
            "            req.context, image_size, db_api, image_id=image_id)",
            "        if remaining is not None:",
            "            image_data = utils.LimitingReader(image_data, remaining)",
            "",
            "        (uri,",
            "         size,",
            "         checksum,",
            "         location_metadata) = store_api.store_add_to_backend(",
            "             image_meta['id'],",
            "             utils.CooperativeReader(image_data),",
            "             image_meta['size'],",
            "             store,",
            "             context=req.context)",
            "",
            "        location_data = {'url': uri,",
            "                         'metadata': location_metadata,",
            "                         'status': 'active'}",
            "",
            "        try:",
            "            # recheck the quota in case there were simultaneous uploads that",
            "            # did not provide the size",
            "            glance.api.common.check_quota(",
            "                req.context, size, db_api, image_id=image_id)",
            "        except exception.StorageQuotaFull:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.info(_LI('Cleaning up %s after exceeding '",
            "                             'the quota') % image_id)",
            "                store_utils.safe_delete_from_backend(",
            "                    req.context, image_meta['id'], location_data)",
            "",
            "        def _kill_mismatched(image_meta, attr, actual):",
            "            supplied = image_meta.get(attr)",
            "            if supplied and supplied != actual:",
            "                msg = (_(\"Supplied %(attr)s (%(supplied)s) and \"",
            "                         \"%(attr)s generated from uploaded image \"",
            "                         \"(%(actual)s) did not match. Setting image \"",
            "                         \"status to 'killed'.\") % {'attr': attr,",
            "                                                   'supplied': supplied,",
            "                                                   'actual': actual})",
            "                LOG.error(msg)",
            "                safe_kill(req, image_id, 'saving')",
            "                initiate_deletion(req, location_data, image_id)",
            "                raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                               content_type=\"text/plain\",",
            "                                               request=req)",
            "",
            "        # Verify any supplied size/checksum value matches size/checksum",
            "        # returned from store when adding image",
            "        _kill_mismatched(image_meta, 'size', size)",
            "        _kill_mismatched(image_meta, 'checksum', checksum)",
            "",
            "        # Update the database with the checksum returned",
            "        # from the backend store",
            "        LOG.debug(\"Updating image %(image_id)s data. \"",
            "                  \"Checksum set to %(checksum)s, size set \"",
            "                  \"to %(size)d\", {'image_id': image_id,",
            "                                  'checksum': checksum,",
            "                                  'size': size})",
            "        update_data = {'checksum': checksum,",
            "                       'size': size}",
            "        try:",
            "            try:",
            "                state = 'saving'",
            "                image_meta = registry.update_image_metadata(req.context,",
            "                                                            image_id,",
            "                                                            update_data,",
            "                                                            from_state=state)",
            "            except exception.Duplicate:",
            "                image = registry.get_image_metadata(req.context, image_id)",
            "                if image['status'] == 'deleted':",
            "                    raise exception.NotFound()",
            "                else:",
            "                    raise",
            "        except exception.NotFound:",
            "            msg = _LI(\"Image %s could not be found after upload. The image may\"",
            "                      \" have been deleted during the upload.\") % image_id",
            "            LOG.info(msg)",
            "",
            "            # NOTE(jculp): we need to clean up the datastore if an image",
            "            # resource is deleted while the image data is being uploaded",
            "            #",
            "            # We get \"location_data\" from above call to store.add(), any",
            "            # exceptions that occur there handle this same issue internally,",
            "            # Since this is store-agnostic, should apply to all stores.",
            "            initiate_deletion(req, location_data, image_id)",
            "            raise webob.exc.HTTPPreconditionFailed(explanation=msg,",
            "                                                   request=req,",
            "                                                   content_type='text/plain')",
            "",
            "    except store_api.StoreAddDisabled:",
            "        msg = _(\"Error in store configuration. Adding images to store \"",
            "                \"is disabled.\")",
            "        LOG.exception(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPGone(explanation=msg, request=req,",
            "                                 content_type='text/plain')",
            "",
            "    except exception.Duplicate as e:",
            "        msg = (_(\"Attempt to upload duplicate image: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.warn(msg)",
            "        # NOTE(dosaboy): do not delete the image since it is likely that this",
            "        # conflict is a result of another concurrent upload that will be",
            "        # successful.",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPConflict(explanation=msg,",
            "                                     request=req,",
            "                                     content_type=\"text/plain\")",
            "",
            "    except exception.Forbidden as e:",
            "        msg = (_(\"Forbidden upload attempt: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPForbidden(explanation=msg,",
            "                                      request=req,",
            "                                      content_type=\"text/plain\")",
            "",
            "    except store_api.StorageFull as e:",
            "        msg = (_(\"Image storage media is full: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except store_api.StorageWriteDenied as e:",
            "        msg = (_(\"Insufficient permissions on image storage media: %s\") %",
            "               utils.exception_to_str(e))",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                               request=req,",
            "                                               content_type='text/plain')",
            "",
            "    except exception.ImageSizeLimitExceeded as e:",
            "        msg = (_(\"Denying attempt to upload image larger than %d bytes.\")",
            "               % CONF.image_size_cap)",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except exception.StorageQuotaFull as e:",
            "        msg = (_(\"Denying attempt to upload image because it exceeds the .\"",
            "                 \"quota: %s\") % utils.exception_to_str(e))",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except webob.exc.HTTPError:",
            "        # NOTE(bcwaldon): Ideally, we would just call 'raise' here,",
            "        # but something in the above function calls is affecting the",
            "        # exception context and we must explicitly re-raise the",
            "        # caught exception.",
            "        msg = _LE(\"Received HTTP error while uploading image %s\") % image_id",
            "        notifier.error('image.upload', msg)",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.exception(msg)",
            "            safe_kill(req, image_id, 'saving')",
            "",
            "    except (ValueError, IOError) as e:",
            "        msg = _(\"Client disconnected before sending all data to backend\")",
            "        LOG.warn(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                       content_type=\"text/plain\",",
            "                                       request=req)",
            "",
            "    except Exception as e:",
            "        msg = _(\"Failed to upload image %s\") % image_id",
            "        LOG.exception(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPInternalServerError(explanation=msg,",
            "                                                request=req,",
            "                                                content_type='text/plain')",
            "",
            "    return image_meta, location_data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "156": [
                "upload_data_to_store"
            ],
            "157": [
                "upload_data_to_store"
            ],
            "158": [
                "upload_data_to_store"
            ],
            "159": [
                "upload_data_to_store"
            ],
            "160": [
                "upload_data_to_store"
            ],
            "161": [
                "upload_data_to_store"
            ],
            "162": [
                "upload_data_to_store"
            ],
            "163": [
                "upload_data_to_store"
            ]
        },
        "addLocation": []
    },
    "glance/api/v2/image_data.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "             try:"
            },
            "1": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "                 image_repo.save(image)"
            },
            "2": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "                 image.set_data(data, size)"
            },
            "3": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                image_repo.save(image)"
            },
            "4": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except exception.NotFound as e:"
            },
            "5": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = (_(\"Image %(id)s could not be found after upload.\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                image_repo.save(image, from_state='saving')"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            except (exception.NotFound, exception.Conflict):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                msg = (_(\"Image %s could not be found after upload. \""
            },
            "9": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "                          \"The image may have been deleted during the \""
            },
            "10": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                         \"upload: %(error)s Cleaning up the chunks \""
            },
            "11": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                         \"uploaded\") %"
            },
            "12": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       {'id': image_id,"
            },
            "13": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        'error': utils.exception_to_str(e)})"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                         \"upload, cleaning up the chunks uploaded.\") %"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                       image_id)"
            },
            "16": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "                 LOG.warn(msg)"
            },
            "17": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "                 # NOTE(sridevi): Cleaning up the uploaded chunks."
            },
            "18": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "                 try:"
            },
            "19": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "             raise webob.exc.HTTPServiceUnavailable(explanation=msg,"
            },
            "20": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "                                                    request=req)"
            },
            "21": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        except webob.exc.HTTPGone as e:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            with excutils.save_and_reraise_exception():"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                LOG.error(_LE(\"Failed to upload image data due to HTTP error\"))"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         except webob.exc.HTTPError as e:"
            },
            "27": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             with excutils.save_and_reraise_exception():"
            },
            "28": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                 LOG.error(_LE(\"Failed to upload image data due to HTTP error\"))"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import glance_store",
            "from oslo.utils import excutils",
            "import webob.exc",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "from glance.common import utils",
            "from glance.common import wsgi",
            "import glance.db",
            "import glance.gateway",
            "from glance import i18n",
            "import glance.notifier",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "_ = i18n._",
            "_LE = i18n._LE",
            "",
            "",
            "class ImageDataController(object):",
            "    def __init__(self, db_api=None, store_api=None,",
            "                 policy_enforcer=None, notifier=None,",
            "                 gateway=None):",
            "        if gateway is None:",
            "            db_api = db_api or glance.db.get_api()",
            "            store_api = store_api or glance_store",
            "            policy = policy_enforcer or glance.api.policy.Enforcer()",
            "            notifier = notifier or glance.notifier.Notifier()",
            "            gateway = glance.gateway.Gateway(db_api, store_api,",
            "                                             notifier, policy)",
            "        self.gateway = gateway",
            "",
            "    def _restore(self, image_repo, image):",
            "        \"\"\"",
            "        Restore the image to queued status.",
            "",
            "        :param image_repo: The instance of ImageRepo",
            "        :param image: The image will be restored",
            "        \"\"\"",
            "        try:",
            "            if image_repo and image:",
            "                image.status = 'queued'",
            "                image_repo.save(image)",
            "        except Exception as e:",
            "            msg = (_LE(\"Unable to restore image %(image_id)s: %(e)s\") %",
            "                   {'image_id': image.image_id,",
            "                    'e': utils.exception_to_str(e)})",
            "            LOG.exception(msg)",
            "",
            "    @utils.mutating",
            "    def upload(self, req, image_id, data, size):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        image = None",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            image.status = 'saving'",
            "            try:",
            "                image_repo.save(image)",
            "                image.set_data(data, size)",
            "                image_repo.save(image)",
            "            except exception.NotFound as e:",
            "                msg = (_(\"Image %(id)s could not be found after upload.\"",
            "                         \"The image may have been deleted during the \"",
            "                         \"upload: %(error)s Cleaning up the chunks \"",
            "                         \"uploaded\") %",
            "                       {'id': image_id,",
            "                        'error': utils.exception_to_str(e)})",
            "                LOG.warn(msg)",
            "                # NOTE(sridevi): Cleaning up the uploaded chunks.",
            "                try:",
            "                    image.delete()",
            "                except exception.NotFound:",
            "                    # NOTE(sridevi): Ignore this exception",
            "                    pass",
            "                raise webob.exc.HTTPGone(explanation=msg,",
            "                                         request=req,",
            "                                         content_type='text/plain')",
            "",
            "        except ValueError as e:",
            "            LOG.debug(\"Cannot save data for image %(id)s: %(e)s\",",
            "                      {'id': image_id, 'e': utils.exception_to_str(e)})",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPBadRequest(",
            "                explanation=utils.exception_to_str(e))",
            "",
            "        except glance_store.StoreAddDisabled:",
            "            msg = _(\"Error in store configuration. Adding images to store \"",
            "                    \"is disabled.\")",
            "            LOG.exception(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPGone(explanation=msg, request=req,",
            "                                     content_type='text/plain')",
            "",
            "        except exception.InvalidImageStatusTransition as e:",
            "            msg = utils.exception_to_str(e)",
            "            LOG.exception(msg)",
            "            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)",
            "",
            "        except exception.Forbidden as e:",
            "            msg = (\"Not allowed to upload image data for image %s\" %",
            "                   image_id)",
            "            LOG.debug(msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg, request=req)",
            "",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "",
            "        except glance_store.StorageFull as e:",
            "            msg = _(\"Image storage media \"",
            "                    \"is full: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.StorageQuotaFull as e:",
            "            msg = _(\"Image exceeds the storage \"",
            "                    \"quota: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.ImageSizeLimitExceeded as e:",
            "            msg = _(\"The incoming image is \"",
            "                    \"too large: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except glance_store.StorageWriteDenied as e:",
            "            msg = _(\"Insufficient permissions on image \"",
            "                    \"storage media: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                                   request=req)",
            "",
            "        except webob.exc.HTTPError as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_LE(\"Failed to upload image data due to HTTP error\"))",
            "                self._restore(image_repo, image)",
            "",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE(\"Failed to upload image data due to \"",
            "                                  \"internal error\"))",
            "                self._restore(image_repo, image)",
            "",
            "    def download(self, req, image_id):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            if not image.locations:",
            "                raise exception.ImageDataNotFound()",
            "        except exception.ImageDataNotFound as e:",
            "            raise webob.exc.HTTPNoContent(explanation=e.msg)",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "",
            "        return image",
            "",
            "",
            "class RequestDeserializer(wsgi.JSONRequestDeserializer):",
            "",
            "    def upload(self, request):",
            "        try:",
            "            request.get_content_type(('application/octet-stream',))",
            "        except exception.InvalidContentType as e:",
            "            raise webob.exc.HTTPUnsupportedMediaType(explanation=e.msg)",
            "",
            "        image_size = request.content_length or None",
            "        return {'size': image_size, 'data': request.body_file}",
            "",
            "",
            "class ResponseSerializer(wsgi.JSONResponseSerializer):",
            "",
            "    def download(self, response, image):",
            "        offset, chunk_size = 0, None",
            "        range_val = response.request.get_content_range()",
            "",
            "        if range_val:",
            "            # NOTE(flaper87): if not present, both, start",
            "            # and stop, will be None.",
            "            if range_val.start is not None:",
            "                offset = range_val.start",
            "",
            "            if range_val.stop is not None:",
            "                chunk_size = range_val.stop - offset",
            "",
            "        response.headers['Content-Type'] = 'application/octet-stream'",
            "",
            "        try:",
            "            # NOTE(markwash): filesystem store (and maybe others?) cause a",
            "            # problem with the caching middleware if they are not wrapped in",
            "            # an iterator very strange",
            "            response.app_iter = iter(image.get_data(offset=offset,",
            "                                                    chunk_size=chunk_size))",
            "        except glance_store.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "        # NOTE(saschpe): \"response.app_iter = ...\" currently resets Content-MD5",
            "        # (https://github.com/Pylons/webob/issues/86), so it should be set",
            "        # afterwards for the time being.",
            "        if image.checksum:",
            "            response.headers['Content-MD5'] = image.checksum",
            "        # NOTE(markwash): \"response.app_iter = ...\" also erroneously resets the",
            "        # content-length",
            "        response.headers['Content-Length'] = str(image.size)",
            "",
            "    def upload(self, response, result):",
            "        response.status_int = 204",
            "",
            "",
            "def create_resource():",
            "    \"\"\"Image data resource factory method\"\"\"",
            "    deserializer = RequestDeserializer()",
            "    serializer = ResponseSerializer()",
            "    controller = ImageDataController()",
            "    return wsgi.Resource(controller, deserializer, serializer)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import glance_store",
            "from oslo.utils import excutils",
            "import webob.exc",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "from glance.common import utils",
            "from glance.common import wsgi",
            "import glance.db",
            "import glance.gateway",
            "from glance import i18n",
            "import glance.notifier",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "_ = i18n._",
            "_LE = i18n._LE",
            "",
            "",
            "class ImageDataController(object):",
            "    def __init__(self, db_api=None, store_api=None,",
            "                 policy_enforcer=None, notifier=None,",
            "                 gateway=None):",
            "        if gateway is None:",
            "            db_api = db_api or glance.db.get_api()",
            "            store_api = store_api or glance_store",
            "            policy = policy_enforcer or glance.api.policy.Enforcer()",
            "            notifier = notifier or glance.notifier.Notifier()",
            "            gateway = glance.gateway.Gateway(db_api, store_api,",
            "                                             notifier, policy)",
            "        self.gateway = gateway",
            "",
            "    def _restore(self, image_repo, image):",
            "        \"\"\"",
            "        Restore the image to queued status.",
            "",
            "        :param image_repo: The instance of ImageRepo",
            "        :param image: The image will be restored",
            "        \"\"\"",
            "        try:",
            "            if image_repo and image:",
            "                image.status = 'queued'",
            "                image_repo.save(image)",
            "        except Exception as e:",
            "            msg = (_LE(\"Unable to restore image %(image_id)s: %(e)s\") %",
            "                   {'image_id': image.image_id,",
            "                    'e': utils.exception_to_str(e)})",
            "            LOG.exception(msg)",
            "",
            "    @utils.mutating",
            "    def upload(self, req, image_id, data, size):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        image = None",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            image.status = 'saving'",
            "            try:",
            "                image_repo.save(image)",
            "                image.set_data(data, size)",
            "                image_repo.save(image, from_state='saving')",
            "            except (exception.NotFound, exception.Conflict):",
            "                msg = (_(\"Image %s could not be found after upload. \"",
            "                         \"The image may have been deleted during the \"",
            "                         \"upload, cleaning up the chunks uploaded.\") %",
            "                       image_id)",
            "                LOG.warn(msg)",
            "                # NOTE(sridevi): Cleaning up the uploaded chunks.",
            "                try:",
            "                    image.delete()",
            "                except exception.NotFound:",
            "                    # NOTE(sridevi): Ignore this exception",
            "                    pass",
            "                raise webob.exc.HTTPGone(explanation=msg,",
            "                                         request=req,",
            "                                         content_type='text/plain')",
            "",
            "        except ValueError as e:",
            "            LOG.debug(\"Cannot save data for image %(id)s: %(e)s\",",
            "                      {'id': image_id, 'e': utils.exception_to_str(e)})",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPBadRequest(",
            "                explanation=utils.exception_to_str(e))",
            "",
            "        except glance_store.StoreAddDisabled:",
            "            msg = _(\"Error in store configuration. Adding images to store \"",
            "                    \"is disabled.\")",
            "            LOG.exception(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPGone(explanation=msg, request=req,",
            "                                     content_type='text/plain')",
            "",
            "        except exception.InvalidImageStatusTransition as e:",
            "            msg = utils.exception_to_str(e)",
            "            LOG.exception(msg)",
            "            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)",
            "",
            "        except exception.Forbidden as e:",
            "            msg = (\"Not allowed to upload image data for image %s\" %",
            "                   image_id)",
            "            LOG.debug(msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg, request=req)",
            "",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "",
            "        except glance_store.StorageFull as e:",
            "            msg = _(\"Image storage media \"",
            "                    \"is full: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.StorageQuotaFull as e:",
            "            msg = _(\"Image exceeds the storage \"",
            "                    \"quota: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.ImageSizeLimitExceeded as e:",
            "            msg = _(\"The incoming image is \"",
            "                    \"too large: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except glance_store.StorageWriteDenied as e:",
            "            msg = _(\"Insufficient permissions on image \"",
            "                    \"storage media: %s\") % utils.exception_to_str(e)",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                                   request=req)",
            "",
            "        except webob.exc.HTTPGone as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_LE(\"Failed to upload image data due to HTTP error\"))",
            "",
            "        except webob.exc.HTTPError as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_LE(\"Failed to upload image data due to HTTP error\"))",
            "                self._restore(image_repo, image)",
            "",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE(\"Failed to upload image data due to \"",
            "                                  \"internal error\"))",
            "                self._restore(image_repo, image)",
            "",
            "    def download(self, req, image_id):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            if not image.locations:",
            "                raise exception.ImageDataNotFound()",
            "        except exception.ImageDataNotFound as e:",
            "            raise webob.exc.HTTPNoContent(explanation=e.msg)",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "",
            "        return image",
            "",
            "",
            "class RequestDeserializer(wsgi.JSONRequestDeserializer):",
            "",
            "    def upload(self, request):",
            "        try:",
            "            request.get_content_type(('application/octet-stream',))",
            "        except exception.InvalidContentType as e:",
            "            raise webob.exc.HTTPUnsupportedMediaType(explanation=e.msg)",
            "",
            "        image_size = request.content_length or None",
            "        return {'size': image_size, 'data': request.body_file}",
            "",
            "",
            "class ResponseSerializer(wsgi.JSONResponseSerializer):",
            "",
            "    def download(self, response, image):",
            "        offset, chunk_size = 0, None",
            "        range_val = response.request.get_content_range()",
            "",
            "        if range_val:",
            "            # NOTE(flaper87): if not present, both, start",
            "            # and stop, will be None.",
            "            if range_val.start is not None:",
            "                offset = range_val.start",
            "",
            "            if range_val.stop is not None:",
            "                chunk_size = range_val.stop - offset",
            "",
            "        response.headers['Content-Type'] = 'application/octet-stream'",
            "",
            "        try:",
            "            # NOTE(markwash): filesystem store (and maybe others?) cause a",
            "            # problem with the caching middleware if they are not wrapped in",
            "            # an iterator very strange",
            "            response.app_iter = iter(image.get_data(offset=offset,",
            "                                                    chunk_size=chunk_size))",
            "        except glance_store.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "        # NOTE(saschpe): \"response.app_iter = ...\" currently resets Content-MD5",
            "        # (https://github.com/Pylons/webob/issues/86), so it should be set",
            "        # afterwards for the time being.",
            "        if image.checksum:",
            "            response.headers['Content-MD5'] = image.checksum",
            "        # NOTE(markwash): \"response.app_iter = ...\" also erroneously resets the",
            "        # content-length",
            "        response.headers['Content-Length'] = str(image.size)",
            "",
            "    def upload(self, response, result):",
            "        response.status_int = 204",
            "",
            "",
            "def create_resource():",
            "    \"\"\"Image data resource factory method\"\"\"",
            "    deserializer = RequestDeserializer()",
            "    serializer = ResponseSerializer()",
            "    controller = ImageDataController()",
            "    return wsgi.Resource(controller, deserializer, serializer)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "75": [
                "ImageDataController",
                "upload"
            ],
            "76": [
                "ImageDataController",
                "upload"
            ],
            "77": [
                "ImageDataController",
                "upload"
            ],
            "79": [
                "ImageDataController",
                "upload"
            ],
            "80": [
                "ImageDataController",
                "upload"
            ],
            "81": [
                "ImageDataController",
                "upload"
            ],
            "82": [
                "ImageDataController",
                "upload"
            ]
        },
        "addLocation": []
    },
    "glance/db/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         image.created_at = new_values['created_at']"
            },
            "1": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         image.updated_at = new_values['updated_at']"
            },
            "2": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "         image_values = self._format_image_to_db(image)"
            },
            "6": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         if image_values['size'] > CONF.image_size_cap:"
            },
            "7": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "             raise exception.ImageSizeLimitExceeded"
            },
            "8": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         try:"
            },
            "9": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "             new_values = self.db_api.image_update(self.context,"
            },
            "10": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "                                                   image.image_id,"
            },
            "11": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "                                                   image_values,"
            },
            "12": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                  purge_props=True)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+                                                  purge_props=True,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+                                                  from_state=from_state)"
            },
            "15": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         except (exception.NotFound, exception.Forbidden):"
            },
            "16": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "             msg = _(\"No image found with ID %s\") % image.image_id"
            },
            "17": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             raise exception.NotFound(msg)"
            },
            "18": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "             msg = _(\"The specified member %s could not be found\")"
            },
            "19": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "             raise exception.NotFound(msg % image_member.id)"
            },
            "20": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 270,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image_member):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+    def save(self, image_member, from_state=None):"
            },
            "23": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "         image_member_values = self._format_image_member_to_db(image_member)"
            },
            "24": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "         try:"
            },
            "25": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "             new_values = self.db_api.image_member_update(self.context,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2010-2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "from oslo.utils import importutils",
            "from wsme.rest import json",
            "",
            "from glance.api.v2.model.metadef_property_type import PropertyType",
            "from glance.common import crypt",
            "from glance.common import exception",
            "from glance.common import location_strategy",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance import i18n",
            "",
            "_ = i18n._",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_size_cap', 'glance.common.config')",
            "CONF.import_opt('metadata_encryption_key', 'glance.common.config')",
            "",
            "",
            "def get_api():",
            "    api = importutils.import_module(CONF.data_api)",
            "    if hasattr(api, 'configure'):",
            "        api.configure()",
            "    return api",
            "",
            "",
            "def unwrap(db_api):",
            "    return db_api",
            "",
            "",
            "# attributes common to all models",
            "BASE_MODEL_ATTRS = set(['id', 'created_at', 'updated_at', 'deleted_at',",
            "                        'deleted'])",
            "",
            "",
            "IMAGE_ATTRS = BASE_MODEL_ATTRS | set(['name', 'status', 'size', 'virtual_size',",
            "                                      'disk_format', 'container_format',",
            "                                      'min_disk', 'min_ram', 'is_public',",
            "                                      'locations', 'checksum', 'owner',",
            "                                      'protected'])",
            "",
            "",
            "class ImageRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get(self, image_id):",
            "        try:",
            "            db_api_image = dict(self.db_api.image_get(self.context, image_id))",
            "            assert not db_api_image['deleted']",
            "        except (exception.NotFound, exception.Forbidden, AssertionError):",
            "            msg = _(\"No image found with ID %s\") % image_id",
            "            raise exception.NotFound(msg)",
            "        tags = self.db_api.image_tag_get_all(self.context, image_id)",
            "        image = self._format_image_from_db(db_api_image, tags)",
            "        return ImageProxy(image, self.context, self.db_api)",
            "",
            "    def list(self, marker=None, limit=None, sort_key=['created_at'],",
            "             sort_dir='desc', filters=None, member_status='accepted'):",
            "        db_api_images = self.db_api.image_get_all(",
            "            self.context, filters=filters, marker=marker, limit=limit,",
            "            sort_key=sort_key, sort_dir=sort_dir,",
            "            member_status=member_status, return_tag=True)",
            "        images = []",
            "        for db_api_image in db_api_images:",
            "            db_image = dict(db_api_image)",
            "            image = self._format_image_from_db(db_image, db_image['tags'])",
            "            images.append(image)",
            "        return images",
            "",
            "    def _format_image_from_db(self, db_image, db_tags):",
            "        visibility = 'public' if db_image['is_public'] else 'private'",
            "        properties = {}",
            "        for prop in db_image.pop('properties'):",
            "            # NOTE(markwash) db api requires us to filter deleted",
            "            if not prop['deleted']:",
            "                properties[prop['name']] = prop['value']",
            "        locations = [loc for loc in db_image['locations']",
            "                     if loc['status'] == 'active']",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            for l in locations:",
            "                l['url'] = crypt.urlsafe_decrypt(key, l['url'])",
            "        return glance.domain.Image(",
            "            image_id=db_image['id'],",
            "            name=db_image['name'],",
            "            status=db_image['status'],",
            "            created_at=db_image['created_at'],",
            "            updated_at=db_image['updated_at'],",
            "            visibility=visibility,",
            "            min_disk=db_image['min_disk'],",
            "            min_ram=db_image['min_ram'],",
            "            protected=db_image['protected'],",
            "            locations=location_strategy.get_ordered_locations(locations),",
            "            checksum=db_image['checksum'],",
            "            owner=db_image['owner'],",
            "            disk_format=db_image['disk_format'],",
            "            container_format=db_image['container_format'],",
            "            size=db_image['size'],",
            "            virtual_size=db_image['virtual_size'],",
            "            extra_properties=properties,",
            "            tags=db_tags",
            "        )",
            "",
            "    def _format_image_to_db(self, image):",
            "        locations = image.locations",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for loc in locations:",
            "                url = crypt.urlsafe_encrypt(key, loc['url'])",
            "                ld.append({'url': url, 'metadata': loc['metadata'],",
            "                           'status': loc['status'],",
            "                           # NOTE(zhiyan): New location has no ID field.",
            "                           'id': loc.get('id')})",
            "            locations = ld",
            "        return {",
            "            'id': image.image_id,",
            "            'name': image.name,",
            "            'status': image.status,",
            "            'created_at': image.created_at,",
            "            'min_disk': image.min_disk,",
            "            'min_ram': image.min_ram,",
            "            'protected': image.protected,",
            "            'locations': locations,",
            "            'checksum': image.checksum,",
            "            'owner': image.owner,",
            "            'disk_format': image.disk_format,",
            "            'container_format': image.container_format,",
            "            'size': image.size,",
            "            'virtual_size': image.virtual_size,",
            "            'is_public': image.visibility == 'public',",
            "            'properties': dict(image.extra_properties),",
            "        }",
            "",
            "    def add(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        # the updated_at value is not set in the _format_image_to_db",
            "        # function since it is specific to image create",
            "        image_values['updated_at'] = image.updated_at",
            "        new_values = self.db_api.image_create(self.context, image_values)",
            "        self.db_api.image_tag_set_all(self.context,",
            "                                      image.image_id, image.tags)",
            "        image.created_at = new_values['created_at']",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def save(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        try:",
            "            new_values = self.db_api.image_update(self.context,",
            "                                                  image.image_id,",
            "                                                  image_values,",
            "                                                  purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        self.db_api.image_tag_set_all(self.context, image.image_id,",
            "                                      image.tags)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def remove(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        try:",
            "            self.db_api.image_update(self.context, image.image_id,",
            "                                     image_values, purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        # NOTE(markwash): don't update tags?",
            "        new_values = self.db_api.image_destroy(self.context, image.image_id)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = ImageMemberRepo(self.context, self.db_api,",
            "                                      self.image)",
            "        return member_repo",
            "",
            "",
            "class ImageMemberRepo(object):",
            "",
            "    def __init__(self, context, db_api, image):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "",
            "    def _format_image_member_from_db(self, db_image_member):",
            "        return glance.domain.ImageMembership(",
            "            id=db_image_member['id'],",
            "            image_id=db_image_member['image_id'],",
            "            member_id=db_image_member['member'],",
            "            status=db_image_member['status'],",
            "            created_at=db_image_member['created_at'],",
            "            updated_at=db_image_member['updated_at']",
            "        )",
            "",
            "    def _format_image_member_to_db(self, image_member):",
            "        image_member = {'image_id': self.image.image_id,",
            "                        'member': image_member.member_id,",
            "                        'status': image_member.status,",
            "                        'created_at': image_member.created_at}",
            "        return image_member",
            "",
            "    def list(self):",
            "        db_members = self.db_api.image_member_find(",
            "            self.context, image_id=self.image.image_id)",
            "        image_members = []",
            "        for db_member in db_members:",
            "            image_members.append(self._format_image_member_from_db(db_member))",
            "        return image_members",
            "",
            "    def add(self, image_member):",
            "        try:",
            "            self.get(image_member.member_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('The target member %(member_id)s is already '",
            "                    'associated with image %(image_id)s.') % {",
            "                        'member_id': image_member.member_id,",
            "                        'image_id': self.image.image_id}",
            "            raise exception.Duplicate(msg)",
            "",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        new_values = self.db_api.image_member_create(self.context,",
            "                                                     image_member_values)",
            "        image_member.created_at = new_values['created_at']",
            "        image_member.updated_at = new_values['updated_at']",
            "        image_member.id = new_values['id']",
            "",
            "    def remove(self, image_member):",
            "        try:",
            "            self.db_api.image_member_delete(self.context, image_member.id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified member %s could not be found\")",
            "            raise exception.NotFound(msg % image_member.id)",
            "",
            "    def save(self, image_member):",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        try:",
            "            new_values = self.db_api.image_member_update(self.context,",
            "                                                         image_member.id,",
            "                                                         image_member_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "        image_member.updated_at = new_values['updated_at']",
            "",
            "    def get(self, member_id):",
            "        try:",
            "            db_api_image_member = self.db_api.image_member_find(",
            "                self.context,",
            "                self.image.image_id,",
            "                member_id)",
            "            if not db_api_image_member:",
            "                raise exception.NotFound()",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "",
            "        image_member = self._format_image_member_from_db(",
            "            db_api_image_member[0])",
            "        return image_member",
            "",
            "",
            "class TaskRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def _format_task_from_db(self, db_task):",
            "        return glance.domain.Task(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "            task_input=db_task['input'],",
            "            result=db_task['result'],",
            "            message=db_task['message'],",
            "        )",
            "",
            "    def _format_task_stub_from_db(self, db_task):",
            "        return glance.domain.TaskStub(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "        )",
            "",
            "    def _format_task_to_db(self, task):",
            "        task = {'id': task.task_id,",
            "                'type': task.type,",
            "                'status': task.status,",
            "                'input': task.task_input,",
            "                'result': task.result,",
            "                'owner': task.owner,",
            "                'message': task.message,",
            "                'expires_at': task.expires_at,",
            "                'created_at': task.created_at,",
            "                'updated_at': task.updated_at,",
            "                }",
            "        return task",
            "",
            "    def get(self, task_id):",
            "        try:",
            "            db_api_task = self.db_api.task_get(self.context, task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task_id",
            "            raise exception.NotFound(msg)",
            "        return self._format_task_from_db(db_api_task)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        db_api_tasks = self.db_api.task_get_all(self.context,",
            "                                                filters=filters,",
            "                                                marker=marker,",
            "                                                limit=limit,",
            "                                                sort_key=sort_key,",
            "                                                sort_dir=sort_dir)",
            "        return [self._format_task_stub_from_db(task) for task in db_api_tasks]",
            "",
            "    def save(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            updated_values = self.db_api.task_update(self.context,",
            "                                                     task.task_id,",
            "                                                     task_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def add(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        updated_values = self.db_api.task_create(self.context, task_values)",
            "        task.created_at = updated_values['created_at']",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def remove(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            self.db_api.task_update(self.context, task.task_id, task_values)",
            "            updated_values = self.db_api.task_delete(self.context,",
            "                                                     task.task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "        task.deleted_at = updated_values['deleted_at']",
            "",
            "",
            "class MetadefNamespaceRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def _format_namespace_from_db(self, namespace_obj):",
            "        return glance.domain.MetadefNamespace(",
            "            namespace_id=namespace_obj['id'],",
            "            namespace=namespace_obj['namespace'],",
            "            display_name=namespace_obj['display_name'],",
            "            description=namespace_obj['description'],",
            "            owner=namespace_obj['owner'],",
            "            visibility=namespace_obj['visibility'],",
            "            protected=namespace_obj['protected'],",
            "            created_at=namespace_obj['created_at'],",
            "            updated_at=namespace_obj['updated_at']",
            "        )",
            "",
            "    def _format_namespace_to_db(self, namespace_obj):",
            "        namespace = {",
            "            'namespace': namespace_obj.namespace,",
            "            'display_name': namespace_obj.display_name,",
            "            'description': namespace_obj.description,",
            "            'visibility': namespace_obj.visibility,",
            "            'protected': namespace_obj.protected,",
            "            'owner': namespace_obj.owner",
            "        }",
            "        return namespace",
            "",
            "    def add(self, namespace):",
            "        self.db_api.metadef_namespace_create(",
            "            self.context,",
            "            self._format_namespace_to_db(namespace)",
            "        )",
            "",
            "    def get(self, namespace):",
            "        try:",
            "            db_api_namespace = self.db_api.metadef_namespace_get(",
            "                self.context, namespace)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find namespace %s') % namespace",
            "            raise exception.NotFound(msg)",
            "        return self._format_namespace_from_db(db_api_namespace)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        db_namespaces = self.db_api.metadef_namespace_get_all(",
            "            self.context,",
            "            marker=marker,",
            "            limit=limit,",
            "            sort_key=sort_key,",
            "            sort_dir=sort_dir,",
            "            filters=filters",
            "        )",
            "        return [self._format_namespace_from_db(namespace_obj)",
            "                for namespace_obj in db_namespaces]",
            "",
            "    def remove(self, namespace):",
            "        try:",
            "            self.db_api.metadef_namespace_delete(self.context,",
            "                                                 namespace.namespace)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def remove_objects(self, namespace):",
            "        try:",
            "            self.db_api.metadef_object_delete_namespace_content(",
            "                self.context,",
            "                namespace.namespace",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def remove_properties(self, namespace):",
            "        try:",
            "            self.db_api.metadef_property_delete_namespace_content(",
            "                self.context,",
            "                namespace.namespace",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def remove_tags(self, namespace):",
            "        try:",
            "            self.db_api.metadef_tag_delete_namespace_content(",
            "                self.context,",
            "                namespace.namespace",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def object_count(self, namespace_name):",
            "        return self.db_api.metadef_object_count(",
            "            self.context,",
            "            namespace_name",
            "        )",
            "",
            "    def property_count(self, namespace_name):",
            "        return self.db_api.metadef_property_count(",
            "            self.context,",
            "            namespace_name",
            "        )",
            "",
            "    def save(self, namespace):",
            "        try:",
            "            self.db_api.metadef_namespace_update(",
            "                self.context, namespace.namespace_id,",
            "                self._format_namespace_to_db(namespace)",
            "            )",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return namespace",
            "",
            "",
            "class MetadefObjectRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_metadef_object_from_db(self, metadata_object,",
            "                                       namespace_entity):",
            "        required_str = metadata_object['required']",
            "        required_list = required_str.split(\",\") if required_str else []",
            "",
            "        # Convert the persisted json schema to a dict of PropertyTypes",
            "        property_types = {}",
            "        json_props = metadata_object['json_schema']",
            "        for id in json_props:",
            "            property_types[id] = json.fromjson(PropertyType, json_props[id])",
            "",
            "        return glance.domain.MetadefObject(",
            "            namespace=namespace_entity,",
            "            object_id=metadata_object['id'],",
            "            name=metadata_object['name'],",
            "            required=required_list,",
            "            description=metadata_object['description'],",
            "            properties=property_types,",
            "            created_at=metadata_object['created_at'],",
            "            updated_at=metadata_object['updated_at']",
            "        )",
            "",
            "    def _format_metadef_object_to_db(self, metadata_object):",
            "",
            "        required_str = (\",\".join(metadata_object.required) if",
            "                        metadata_object.required else None)",
            "",
            "        # Convert the model PropertyTypes dict to a JSON string",
            "        properties = metadata_object.properties",
            "        db_schema = {}",
            "        if properties:",
            "            for k, v in properties.items():",
            "                json_data = json.tojson(PropertyType, v)",
            "                db_schema[k] = json_data",
            "",
            "        db_metadata_object = {",
            "            'name': metadata_object.name,",
            "            'required': required_str,",
            "            'description': metadata_object.description,",
            "            'json_schema': db_schema",
            "        }",
            "        return db_metadata_object",
            "",
            "    def add(self, metadata_object):",
            "        self.db_api.metadef_object_create(",
            "            self.context,",
            "            metadata_object.namespace,",
            "            self._format_metadef_object_to_db(metadata_object)",
            "        )",
            "",
            "    def get(self, namespace, object_name):",
            "        try:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_metadata_object = self.db_api.metadef_object_get(",
            "                self.context,",
            "                namespace,",
            "                object_name)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find metadata object %s') % object_name",
            "            raise exception.NotFound(msg)",
            "        return self._format_metadef_object_from_db(db_metadata_object,",
            "                                                   namespace_entity)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        namespace = filters['namespace']",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "        db_metadata_objects = self.db_api.metadef_object_get_all(",
            "            self.context, namespace)",
            "        return [self._format_metadef_object_from_db(metadata_object,",
            "                                                    namespace_entity)",
            "                for metadata_object in db_metadata_objects]",
            "",
            "    def remove(self, metadata_object):",
            "        try:",
            "            self.db_api.metadef_object_delete(",
            "                self.context,",
            "                metadata_object.namespace.namespace,",
            "                metadata_object.name",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified metadata object %s could not be found\")",
            "            raise exception.NotFound(msg % metadata_object.name)",
            "",
            "    def save(self, metadata_object):",
            "        try:",
            "            self.db_api.metadef_object_update(",
            "                self.context, metadata_object.namespace.namespace,",
            "                metadata_object.object_id,",
            "                self._format_metadef_object_to_db(metadata_object))",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return metadata_object",
            "",
            "",
            "class MetadefResourceTypeRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_resource_type_from_db(self, resource_type, namespace):",
            "        return glance.domain.MetadefResourceType(",
            "            namespace=namespace,",
            "            name=resource_type['name'],",
            "            prefix=resource_type['prefix'],",
            "            properties_target=resource_type['properties_target'],",
            "            created_at=resource_type['created_at'],",
            "            updated_at=resource_type['updated_at']",
            "        )",
            "",
            "    def _format_resource_type_to_db(self, resource_type):",
            "        db_resource_type = {",
            "            'name': resource_type.name,",
            "            'prefix': resource_type.prefix,",
            "            'properties_target': resource_type.properties_target",
            "        }",
            "        return db_resource_type",
            "",
            "    def add(self, resource_type):",
            "        self.db_api.metadef_resource_type_association_create(",
            "            self.context, resource_type.namespace,",
            "            self._format_resource_type_to_db(resource_type)",
            "        )",
            "",
            "    def get(self, resource_type, namespace):",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "        db_resource_type = (",
            "            self.db_api.",
            "            metadef_resource_type_association_get(",
            "                self.context,",
            "                namespace,",
            "                resource_type",
            "            )",
            "        )",
            "        return self._format_resource_type_from_db(db_resource_type,",
            "                                                  namespace_entity)",
            "",
            "    def list(self, filters=None):",
            "        namespace = filters['namespace']",
            "        if namespace:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_resource_types = (",
            "                self.db_api.",
            "                metadef_resource_type_association_get_all_by_namespace(",
            "                    self.context,",
            "                    namespace",
            "                )",
            "            )",
            "            return [self._format_resource_type_from_db(resource_type,",
            "                                                       namespace_entity)",
            "                    for resource_type in db_resource_types]",
            "        else:",
            "            db_resource_types = (",
            "                self.db_api.",
            "                metadef_resource_type_get_all(self.context)",
            "            )",
            "            return [glance.domain.MetadefResourceType(",
            "                namespace=None,",
            "                name=resource_type['name'],",
            "                prefix=None,",
            "                properties_target=None,",
            "                created_at=resource_type['created_at'],",
            "                updated_at=resource_type['updated_at']",
            "            ) for resource_type in db_resource_types]",
            "",
            "    def remove(self, resource_type):",
            "        try:",
            "            self.db_api.metadef_resource_type_association_delete(",
            "                self.context, resource_type.namespace.namespace,",
            "                resource_type.name)",
            "",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified resource type %s could not be found \")",
            "            raise exception.NotFound(msg % resource_type.name)",
            "",
            "",
            "class MetadefPropertyRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_metadef_property_from_db(",
            "            self,",
            "            property,",
            "            namespace_entity):",
            "",
            "        return glance.domain.MetadefProperty(",
            "            namespace=namespace_entity,",
            "            property_id=property['id'],",
            "            name=property['name'],",
            "            schema=property['json_schema']",
            "        )",
            "",
            "    def _format_metadef_property_to_db(self, property):",
            "",
            "        db_metadata_object = {",
            "            'name': property.name,",
            "            'json_schema': property.schema",
            "        }",
            "        return db_metadata_object",
            "",
            "    def add(self, property):",
            "        self.db_api.metadef_property_create(",
            "            self.context,",
            "            property.namespace,",
            "            self._format_metadef_property_to_db(property)",
            "        )",
            "",
            "    def get(self, namespace, property_name):",
            "        try:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_property_type = self.db_api.metadef_property_get(",
            "                self.context,",
            "                namespace,",
            "                property_name",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find property %s') % property_name",
            "            raise exception.NotFound(msg)",
            "        return self._format_metadef_property_from_db(",
            "            db_property_type, namespace_entity)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        namespace = filters['namespace']",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "",
            "        db_properties = self.db_api.metadef_property_get_all(",
            "            self.context, namespace)",
            "        return (",
            "            [self._format_metadef_property_from_db(",
            "                property, namespace_entity) for property in db_properties]",
            "        )",
            "",
            "    def remove(self, property):",
            "        try:",
            "            self.db_api.metadef_property_delete(",
            "                self.context, property.namespace.namespace, property.name)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified property %s could not be found\")",
            "            raise exception.NotFound(msg % property.name)",
            "",
            "    def save(self, property):",
            "        try:",
            "            self.db_api.metadef_property_update(",
            "                self.context, property.namespace.namespace,",
            "                property.property_id,",
            "                self._format_metadef_property_to_db(property)",
            "            )",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return property",
            "",
            "",
            "class MetadefTagRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_metadef_tag_from_db(self, metadata_tag,",
            "                                    namespace_entity):",
            "        return glance.domain.MetadefTag(",
            "            namespace=namespace_entity,",
            "            tag_id=metadata_tag['id'],",
            "            name=metadata_tag['name'],",
            "            created_at=metadata_tag['created_at'],",
            "            updated_at=metadata_tag['updated_at']",
            "        )",
            "",
            "    def _format_metadef_tag_to_db(self, metadata_tag):",
            "        db_metadata_tag = {",
            "            'name': metadata_tag.name",
            "        }",
            "        return db_metadata_tag",
            "",
            "    def add(self, metadata_tag):",
            "        self.db_api.metadef_tag_create(",
            "            self.context,",
            "            metadata_tag.namespace,",
            "            self._format_metadef_tag_to_db(metadata_tag)",
            "        )",
            "",
            "    def add_tags(self, metadata_tags):",
            "        tag_list = []",
            "        namespace = None",
            "        for metadata_tag in metadata_tags:",
            "            tag_list.append(self._format_metadef_tag_to_db(metadata_tag))",
            "            if namespace is None:",
            "                namespace = metadata_tag.namespace",
            "",
            "        self.db_api.metadef_tag_create_tags(",
            "            self.context, namespace, tag_list)",
            "",
            "    def get(self, namespace, name):",
            "        try:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_metadata_tag = self.db_api.metadef_tag_get(",
            "                self.context,",
            "                namespace,",
            "                name)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find metadata tag %s') % name",
            "            raise exception.NotFound(msg)",
            "        return self._format_metadef_tag_from_db(db_metadata_tag,",
            "                                                namespace_entity)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        namespace = filters['namespace']",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "",
            "        db_metadata_tag = self.db_api.metadef_tag_get_all(",
            "            self.context, namespace, filters, marker, limit, sort_key,",
            "            sort_dir)",
            "",
            "        return [self._format_metadef_tag_from_db(metadata_tag,",
            "                                                 namespace_entity)",
            "                for metadata_tag in db_metadata_tag]",
            "",
            "    def remove(self, metadata_tag):",
            "        try:",
            "            self.db_api.metadef_tag_delete(",
            "                self.context,",
            "                metadata_tag.namespace.namespace,",
            "                metadata_tag.name",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified metadata tag %s could not be found\")",
            "            raise exception.NotFound(msg % metadata_tag.name)",
            "",
            "    def save(self, metadata_tag):",
            "        try:",
            "            self.db_api.metadef_tag_update(",
            "                self.context, metadata_tag.namespace.namespace,",
            "                metadata_tag.tag_id,",
            "                self._format_metadef_tag_to_db(metadata_tag))",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return metadata_tag"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2010-2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "from oslo.utils import importutils",
            "from wsme.rest import json",
            "",
            "from glance.api.v2.model.metadef_property_type import PropertyType",
            "from glance.common import crypt",
            "from glance.common import exception",
            "from glance.common import location_strategy",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance import i18n",
            "",
            "_ = i18n._",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_size_cap', 'glance.common.config')",
            "CONF.import_opt('metadata_encryption_key', 'glance.common.config')",
            "",
            "",
            "def get_api():",
            "    api = importutils.import_module(CONF.data_api)",
            "    if hasattr(api, 'configure'):",
            "        api.configure()",
            "    return api",
            "",
            "",
            "def unwrap(db_api):",
            "    return db_api",
            "",
            "",
            "# attributes common to all models",
            "BASE_MODEL_ATTRS = set(['id', 'created_at', 'updated_at', 'deleted_at',",
            "                        'deleted'])",
            "",
            "",
            "IMAGE_ATTRS = BASE_MODEL_ATTRS | set(['name', 'status', 'size', 'virtual_size',",
            "                                      'disk_format', 'container_format',",
            "                                      'min_disk', 'min_ram', 'is_public',",
            "                                      'locations', 'checksum', 'owner',",
            "                                      'protected'])",
            "",
            "",
            "class ImageRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get(self, image_id):",
            "        try:",
            "            db_api_image = dict(self.db_api.image_get(self.context, image_id))",
            "            assert not db_api_image['deleted']",
            "        except (exception.NotFound, exception.Forbidden, AssertionError):",
            "            msg = _(\"No image found with ID %s\") % image_id",
            "            raise exception.NotFound(msg)",
            "        tags = self.db_api.image_tag_get_all(self.context, image_id)",
            "        image = self._format_image_from_db(db_api_image, tags)",
            "        return ImageProxy(image, self.context, self.db_api)",
            "",
            "    def list(self, marker=None, limit=None, sort_key=['created_at'],",
            "             sort_dir='desc', filters=None, member_status='accepted'):",
            "        db_api_images = self.db_api.image_get_all(",
            "            self.context, filters=filters, marker=marker, limit=limit,",
            "            sort_key=sort_key, sort_dir=sort_dir,",
            "            member_status=member_status, return_tag=True)",
            "        images = []",
            "        for db_api_image in db_api_images:",
            "            db_image = dict(db_api_image)",
            "            image = self._format_image_from_db(db_image, db_image['tags'])",
            "            images.append(image)",
            "        return images",
            "",
            "    def _format_image_from_db(self, db_image, db_tags):",
            "        visibility = 'public' if db_image['is_public'] else 'private'",
            "        properties = {}",
            "        for prop in db_image.pop('properties'):",
            "            # NOTE(markwash) db api requires us to filter deleted",
            "            if not prop['deleted']:",
            "                properties[prop['name']] = prop['value']",
            "        locations = [loc for loc in db_image['locations']",
            "                     if loc['status'] == 'active']",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            for l in locations:",
            "                l['url'] = crypt.urlsafe_decrypt(key, l['url'])",
            "        return glance.domain.Image(",
            "            image_id=db_image['id'],",
            "            name=db_image['name'],",
            "            status=db_image['status'],",
            "            created_at=db_image['created_at'],",
            "            updated_at=db_image['updated_at'],",
            "            visibility=visibility,",
            "            min_disk=db_image['min_disk'],",
            "            min_ram=db_image['min_ram'],",
            "            protected=db_image['protected'],",
            "            locations=location_strategy.get_ordered_locations(locations),",
            "            checksum=db_image['checksum'],",
            "            owner=db_image['owner'],",
            "            disk_format=db_image['disk_format'],",
            "            container_format=db_image['container_format'],",
            "            size=db_image['size'],",
            "            virtual_size=db_image['virtual_size'],",
            "            extra_properties=properties,",
            "            tags=db_tags",
            "        )",
            "",
            "    def _format_image_to_db(self, image):",
            "        locations = image.locations",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for loc in locations:",
            "                url = crypt.urlsafe_encrypt(key, loc['url'])",
            "                ld.append({'url': url, 'metadata': loc['metadata'],",
            "                           'status': loc['status'],",
            "                           # NOTE(zhiyan): New location has no ID field.",
            "                           'id': loc.get('id')})",
            "            locations = ld",
            "        return {",
            "            'id': image.image_id,",
            "            'name': image.name,",
            "            'status': image.status,",
            "            'created_at': image.created_at,",
            "            'min_disk': image.min_disk,",
            "            'min_ram': image.min_ram,",
            "            'protected': image.protected,",
            "            'locations': locations,",
            "            'checksum': image.checksum,",
            "            'owner': image.owner,",
            "            'disk_format': image.disk_format,",
            "            'container_format': image.container_format,",
            "            'size': image.size,",
            "            'virtual_size': image.virtual_size,",
            "            'is_public': image.visibility == 'public',",
            "            'properties': dict(image.extra_properties),",
            "        }",
            "",
            "    def add(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        # the updated_at value is not set in the _format_image_to_db",
            "        # function since it is specific to image create",
            "        image_values['updated_at'] = image.updated_at",
            "        new_values = self.db_api.image_create(self.context, image_values)",
            "        self.db_api.image_tag_set_all(self.context,",
            "                                      image.image_id, image.tags)",
            "        image.created_at = new_values['created_at']",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def save(self, image, from_state=None):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        try:",
            "            new_values = self.db_api.image_update(self.context,",
            "                                                  image.image_id,",
            "                                                  image_values,",
            "                                                  purge_props=True,",
            "                                                  from_state=from_state)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        self.db_api.image_tag_set_all(self.context, image.image_id,",
            "                                      image.tags)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def remove(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        try:",
            "            self.db_api.image_update(self.context, image.image_id,",
            "                                     image_values, purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        # NOTE(markwash): don't update tags?",
            "        new_values = self.db_api.image_destroy(self.context, image.image_id)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = ImageMemberRepo(self.context, self.db_api,",
            "                                      self.image)",
            "        return member_repo",
            "",
            "",
            "class ImageMemberRepo(object):",
            "",
            "    def __init__(self, context, db_api, image):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "",
            "    def _format_image_member_from_db(self, db_image_member):",
            "        return glance.domain.ImageMembership(",
            "            id=db_image_member['id'],",
            "            image_id=db_image_member['image_id'],",
            "            member_id=db_image_member['member'],",
            "            status=db_image_member['status'],",
            "            created_at=db_image_member['created_at'],",
            "            updated_at=db_image_member['updated_at']",
            "        )",
            "",
            "    def _format_image_member_to_db(self, image_member):",
            "        image_member = {'image_id': self.image.image_id,",
            "                        'member': image_member.member_id,",
            "                        'status': image_member.status,",
            "                        'created_at': image_member.created_at}",
            "        return image_member",
            "",
            "    def list(self):",
            "        db_members = self.db_api.image_member_find(",
            "            self.context, image_id=self.image.image_id)",
            "        image_members = []",
            "        for db_member in db_members:",
            "            image_members.append(self._format_image_member_from_db(db_member))",
            "        return image_members",
            "",
            "    def add(self, image_member):",
            "        try:",
            "            self.get(image_member.member_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('The target member %(member_id)s is already '",
            "                    'associated with image %(image_id)s.') % {",
            "                        'member_id': image_member.member_id,",
            "                        'image_id': self.image.image_id}",
            "            raise exception.Duplicate(msg)",
            "",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        new_values = self.db_api.image_member_create(self.context,",
            "                                                     image_member_values)",
            "        image_member.created_at = new_values['created_at']",
            "        image_member.updated_at = new_values['updated_at']",
            "        image_member.id = new_values['id']",
            "",
            "    def remove(self, image_member):",
            "        try:",
            "            self.db_api.image_member_delete(self.context, image_member.id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified member %s could not be found\")",
            "            raise exception.NotFound(msg % image_member.id)",
            "",
            "    def save(self, image_member, from_state=None):",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        try:",
            "            new_values = self.db_api.image_member_update(self.context,",
            "                                                         image_member.id,",
            "                                                         image_member_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "        image_member.updated_at = new_values['updated_at']",
            "",
            "    def get(self, member_id):",
            "        try:",
            "            db_api_image_member = self.db_api.image_member_find(",
            "                self.context,",
            "                self.image.image_id,",
            "                member_id)",
            "            if not db_api_image_member:",
            "                raise exception.NotFound()",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "",
            "        image_member = self._format_image_member_from_db(",
            "            db_api_image_member[0])",
            "        return image_member",
            "",
            "",
            "class TaskRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def _format_task_from_db(self, db_task):",
            "        return glance.domain.Task(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "            task_input=db_task['input'],",
            "            result=db_task['result'],",
            "            message=db_task['message'],",
            "        )",
            "",
            "    def _format_task_stub_from_db(self, db_task):",
            "        return glance.domain.TaskStub(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "        )",
            "",
            "    def _format_task_to_db(self, task):",
            "        task = {'id': task.task_id,",
            "                'type': task.type,",
            "                'status': task.status,",
            "                'input': task.task_input,",
            "                'result': task.result,",
            "                'owner': task.owner,",
            "                'message': task.message,",
            "                'expires_at': task.expires_at,",
            "                'created_at': task.created_at,",
            "                'updated_at': task.updated_at,",
            "                }",
            "        return task",
            "",
            "    def get(self, task_id):",
            "        try:",
            "            db_api_task = self.db_api.task_get(self.context, task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task_id",
            "            raise exception.NotFound(msg)",
            "        return self._format_task_from_db(db_api_task)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        db_api_tasks = self.db_api.task_get_all(self.context,",
            "                                                filters=filters,",
            "                                                marker=marker,",
            "                                                limit=limit,",
            "                                                sort_key=sort_key,",
            "                                                sort_dir=sort_dir)",
            "        return [self._format_task_stub_from_db(task) for task in db_api_tasks]",
            "",
            "    def save(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            updated_values = self.db_api.task_update(self.context,",
            "                                                     task.task_id,",
            "                                                     task_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def add(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        updated_values = self.db_api.task_create(self.context, task_values)",
            "        task.created_at = updated_values['created_at']",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def remove(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            self.db_api.task_update(self.context, task.task_id, task_values)",
            "            updated_values = self.db_api.task_delete(self.context,",
            "                                                     task.task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "        task.deleted_at = updated_values['deleted_at']",
            "",
            "",
            "class MetadefNamespaceRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def _format_namespace_from_db(self, namespace_obj):",
            "        return glance.domain.MetadefNamespace(",
            "            namespace_id=namespace_obj['id'],",
            "            namespace=namespace_obj['namespace'],",
            "            display_name=namespace_obj['display_name'],",
            "            description=namespace_obj['description'],",
            "            owner=namespace_obj['owner'],",
            "            visibility=namespace_obj['visibility'],",
            "            protected=namespace_obj['protected'],",
            "            created_at=namespace_obj['created_at'],",
            "            updated_at=namespace_obj['updated_at']",
            "        )",
            "",
            "    def _format_namespace_to_db(self, namespace_obj):",
            "        namespace = {",
            "            'namespace': namespace_obj.namespace,",
            "            'display_name': namespace_obj.display_name,",
            "            'description': namespace_obj.description,",
            "            'visibility': namespace_obj.visibility,",
            "            'protected': namespace_obj.protected,",
            "            'owner': namespace_obj.owner",
            "        }",
            "        return namespace",
            "",
            "    def add(self, namespace):",
            "        self.db_api.metadef_namespace_create(",
            "            self.context,",
            "            self._format_namespace_to_db(namespace)",
            "        )",
            "",
            "    def get(self, namespace):",
            "        try:",
            "            db_api_namespace = self.db_api.metadef_namespace_get(",
            "                self.context, namespace)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find namespace %s') % namespace",
            "            raise exception.NotFound(msg)",
            "        return self._format_namespace_from_db(db_api_namespace)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        db_namespaces = self.db_api.metadef_namespace_get_all(",
            "            self.context,",
            "            marker=marker,",
            "            limit=limit,",
            "            sort_key=sort_key,",
            "            sort_dir=sort_dir,",
            "            filters=filters",
            "        )",
            "        return [self._format_namespace_from_db(namespace_obj)",
            "                for namespace_obj in db_namespaces]",
            "",
            "    def remove(self, namespace):",
            "        try:",
            "            self.db_api.metadef_namespace_delete(self.context,",
            "                                                 namespace.namespace)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def remove_objects(self, namespace):",
            "        try:",
            "            self.db_api.metadef_object_delete_namespace_content(",
            "                self.context,",
            "                namespace.namespace",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def remove_properties(self, namespace):",
            "        try:",
            "            self.db_api.metadef_property_delete_namespace_content(",
            "                self.context,",
            "                namespace.namespace",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def remove_tags(self, namespace):",
            "        try:",
            "            self.db_api.metadef_tag_delete_namespace_content(",
            "                self.context,",
            "                namespace.namespace",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified namespace %s could not be found\")",
            "            raise exception.NotFound(msg % namespace.namespace)",
            "",
            "    def object_count(self, namespace_name):",
            "        return self.db_api.metadef_object_count(",
            "            self.context,",
            "            namespace_name",
            "        )",
            "",
            "    def property_count(self, namespace_name):",
            "        return self.db_api.metadef_property_count(",
            "            self.context,",
            "            namespace_name",
            "        )",
            "",
            "    def save(self, namespace):",
            "        try:",
            "            self.db_api.metadef_namespace_update(",
            "                self.context, namespace.namespace_id,",
            "                self._format_namespace_to_db(namespace)",
            "            )",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return namespace",
            "",
            "",
            "class MetadefObjectRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_metadef_object_from_db(self, metadata_object,",
            "                                       namespace_entity):",
            "        required_str = metadata_object['required']",
            "        required_list = required_str.split(\",\") if required_str else []",
            "",
            "        # Convert the persisted json schema to a dict of PropertyTypes",
            "        property_types = {}",
            "        json_props = metadata_object['json_schema']",
            "        for id in json_props:",
            "            property_types[id] = json.fromjson(PropertyType, json_props[id])",
            "",
            "        return glance.domain.MetadefObject(",
            "            namespace=namespace_entity,",
            "            object_id=metadata_object['id'],",
            "            name=metadata_object['name'],",
            "            required=required_list,",
            "            description=metadata_object['description'],",
            "            properties=property_types,",
            "            created_at=metadata_object['created_at'],",
            "            updated_at=metadata_object['updated_at']",
            "        )",
            "",
            "    def _format_metadef_object_to_db(self, metadata_object):",
            "",
            "        required_str = (\",\".join(metadata_object.required) if",
            "                        metadata_object.required else None)",
            "",
            "        # Convert the model PropertyTypes dict to a JSON string",
            "        properties = metadata_object.properties",
            "        db_schema = {}",
            "        if properties:",
            "            for k, v in properties.items():",
            "                json_data = json.tojson(PropertyType, v)",
            "                db_schema[k] = json_data",
            "",
            "        db_metadata_object = {",
            "            'name': metadata_object.name,",
            "            'required': required_str,",
            "            'description': metadata_object.description,",
            "            'json_schema': db_schema",
            "        }",
            "        return db_metadata_object",
            "",
            "    def add(self, metadata_object):",
            "        self.db_api.metadef_object_create(",
            "            self.context,",
            "            metadata_object.namespace,",
            "            self._format_metadef_object_to_db(metadata_object)",
            "        )",
            "",
            "    def get(self, namespace, object_name):",
            "        try:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_metadata_object = self.db_api.metadef_object_get(",
            "                self.context,",
            "                namespace,",
            "                object_name)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find metadata object %s') % object_name",
            "            raise exception.NotFound(msg)",
            "        return self._format_metadef_object_from_db(db_metadata_object,",
            "                                                   namespace_entity)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        namespace = filters['namespace']",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "        db_metadata_objects = self.db_api.metadef_object_get_all(",
            "            self.context, namespace)",
            "        return [self._format_metadef_object_from_db(metadata_object,",
            "                                                    namespace_entity)",
            "                for metadata_object in db_metadata_objects]",
            "",
            "    def remove(self, metadata_object):",
            "        try:",
            "            self.db_api.metadef_object_delete(",
            "                self.context,",
            "                metadata_object.namespace.namespace,",
            "                metadata_object.name",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified metadata object %s could not be found\")",
            "            raise exception.NotFound(msg % metadata_object.name)",
            "",
            "    def save(self, metadata_object):",
            "        try:",
            "            self.db_api.metadef_object_update(",
            "                self.context, metadata_object.namespace.namespace,",
            "                metadata_object.object_id,",
            "                self._format_metadef_object_to_db(metadata_object))",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return metadata_object",
            "",
            "",
            "class MetadefResourceTypeRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_resource_type_from_db(self, resource_type, namespace):",
            "        return glance.domain.MetadefResourceType(",
            "            namespace=namespace,",
            "            name=resource_type['name'],",
            "            prefix=resource_type['prefix'],",
            "            properties_target=resource_type['properties_target'],",
            "            created_at=resource_type['created_at'],",
            "            updated_at=resource_type['updated_at']",
            "        )",
            "",
            "    def _format_resource_type_to_db(self, resource_type):",
            "        db_resource_type = {",
            "            'name': resource_type.name,",
            "            'prefix': resource_type.prefix,",
            "            'properties_target': resource_type.properties_target",
            "        }",
            "        return db_resource_type",
            "",
            "    def add(self, resource_type):",
            "        self.db_api.metadef_resource_type_association_create(",
            "            self.context, resource_type.namespace,",
            "            self._format_resource_type_to_db(resource_type)",
            "        )",
            "",
            "    def get(self, resource_type, namespace):",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "        db_resource_type = (",
            "            self.db_api.",
            "            metadef_resource_type_association_get(",
            "                self.context,",
            "                namespace,",
            "                resource_type",
            "            )",
            "        )",
            "        return self._format_resource_type_from_db(db_resource_type,",
            "                                                  namespace_entity)",
            "",
            "    def list(self, filters=None):",
            "        namespace = filters['namespace']",
            "        if namespace:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_resource_types = (",
            "                self.db_api.",
            "                metadef_resource_type_association_get_all_by_namespace(",
            "                    self.context,",
            "                    namespace",
            "                )",
            "            )",
            "            return [self._format_resource_type_from_db(resource_type,",
            "                                                       namespace_entity)",
            "                    for resource_type in db_resource_types]",
            "        else:",
            "            db_resource_types = (",
            "                self.db_api.",
            "                metadef_resource_type_get_all(self.context)",
            "            )",
            "            return [glance.domain.MetadefResourceType(",
            "                namespace=None,",
            "                name=resource_type['name'],",
            "                prefix=None,",
            "                properties_target=None,",
            "                created_at=resource_type['created_at'],",
            "                updated_at=resource_type['updated_at']",
            "            ) for resource_type in db_resource_types]",
            "",
            "    def remove(self, resource_type):",
            "        try:",
            "            self.db_api.metadef_resource_type_association_delete(",
            "                self.context, resource_type.namespace.namespace,",
            "                resource_type.name)",
            "",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified resource type %s could not be found \")",
            "            raise exception.NotFound(msg % resource_type.name)",
            "",
            "",
            "class MetadefPropertyRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_metadef_property_from_db(",
            "            self,",
            "            property,",
            "            namespace_entity):",
            "",
            "        return glance.domain.MetadefProperty(",
            "            namespace=namespace_entity,",
            "            property_id=property['id'],",
            "            name=property['name'],",
            "            schema=property['json_schema']",
            "        )",
            "",
            "    def _format_metadef_property_to_db(self, property):",
            "",
            "        db_metadata_object = {",
            "            'name': property.name,",
            "            'json_schema': property.schema",
            "        }",
            "        return db_metadata_object",
            "",
            "    def add(self, property):",
            "        self.db_api.metadef_property_create(",
            "            self.context,",
            "            property.namespace,",
            "            self._format_metadef_property_to_db(property)",
            "        )",
            "",
            "    def get(self, namespace, property_name):",
            "        try:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_property_type = self.db_api.metadef_property_get(",
            "                self.context,",
            "                namespace,",
            "                property_name",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find property %s') % property_name",
            "            raise exception.NotFound(msg)",
            "        return self._format_metadef_property_from_db(",
            "            db_property_type, namespace_entity)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        namespace = filters['namespace']",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "",
            "        db_properties = self.db_api.metadef_property_get_all(",
            "            self.context, namespace)",
            "        return (",
            "            [self._format_metadef_property_from_db(",
            "                property, namespace_entity) for property in db_properties]",
            "        )",
            "",
            "    def remove(self, property):",
            "        try:",
            "            self.db_api.metadef_property_delete(",
            "                self.context, property.namespace.namespace, property.name)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified property %s could not be found\")",
            "            raise exception.NotFound(msg % property.name)",
            "",
            "    def save(self, property):",
            "        try:",
            "            self.db_api.metadef_property_update(",
            "                self.context, property.namespace.namespace,",
            "                property.property_id,",
            "                self._format_metadef_property_to_db(property)",
            "            )",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return property",
            "",
            "",
            "class MetadefTagRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.meta_namespace_repo = MetadefNamespaceRepo(context, db_api)",
            "",
            "    def _format_metadef_tag_from_db(self, metadata_tag,",
            "                                    namespace_entity):",
            "        return glance.domain.MetadefTag(",
            "            namespace=namespace_entity,",
            "            tag_id=metadata_tag['id'],",
            "            name=metadata_tag['name'],",
            "            created_at=metadata_tag['created_at'],",
            "            updated_at=metadata_tag['updated_at']",
            "        )",
            "",
            "    def _format_metadef_tag_to_db(self, metadata_tag):",
            "        db_metadata_tag = {",
            "            'name': metadata_tag.name",
            "        }",
            "        return db_metadata_tag",
            "",
            "    def add(self, metadata_tag):",
            "        self.db_api.metadef_tag_create(",
            "            self.context,",
            "            metadata_tag.namespace,",
            "            self._format_metadef_tag_to_db(metadata_tag)",
            "        )",
            "",
            "    def add_tags(self, metadata_tags):",
            "        tag_list = []",
            "        namespace = None",
            "        for metadata_tag in metadata_tags:",
            "            tag_list.append(self._format_metadef_tag_to_db(metadata_tag))",
            "            if namespace is None:",
            "                namespace = metadata_tag.namespace",
            "",
            "        self.db_api.metadef_tag_create_tags(",
            "            self.context, namespace, tag_list)",
            "",
            "    def get(self, namespace, name):",
            "        try:",
            "            namespace_entity = self.meta_namespace_repo.get(namespace)",
            "            db_metadata_tag = self.db_api.metadef_tag_get(",
            "                self.context,",
            "                namespace,",
            "                name)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find metadata tag %s') % name",
            "            raise exception.NotFound(msg)",
            "        return self._format_metadef_tag_from_db(db_metadata_tag,",
            "                                                namespace_entity)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None):",
            "        namespace = filters['namespace']",
            "        namespace_entity = self.meta_namespace_repo.get(namespace)",
            "",
            "        db_metadata_tag = self.db_api.metadef_tag_get_all(",
            "            self.context, namespace, filters, marker, limit, sort_key,",
            "            sort_dir)",
            "",
            "        return [self._format_metadef_tag_from_db(metadata_tag,",
            "                                                 namespace_entity)",
            "                for metadata_tag in db_metadata_tag]",
            "",
            "    def remove(self, metadata_tag):",
            "        try:",
            "            self.db_api.metadef_tag_delete(",
            "                self.context,",
            "                metadata_tag.namespace.namespace,",
            "                metadata_tag.name",
            "            )",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified metadata tag %s could not be found\")",
            "            raise exception.NotFound(msg % metadata_tag.name)",
            "",
            "    def save(self, metadata_tag):",
            "        try:",
            "            self.db_api.metadef_tag_update(",
            "                self.context, metadata_tag.namespace.namespace,",
            "                metadata_tag.tag_id,",
            "                self._format_metadef_tag_to_db(metadata_tag))",
            "        except exception.NotFound as e:",
            "            raise exception.NotFound(explanation=e.msg)",
            "        return metadata_tag"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "169": [
                "ImageRepo",
                "save"
            ],
            "177": [
                "ImageRepo",
                "save"
            ],
            "270": [
                "ImageMemberRepo",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/domain/proxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         result = self.base.add(base_item)"
            },
            "1": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         return self.helper.proxy(result)"
            },
            "2": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, item):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    def save(self, item, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         base_item = self.helper.unproxy(item)"
            },
            "6": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        result = self.base.save(base_item)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        result = self.base.save(base_item, from_state=from_state)"
            },
            "8": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         return self.helper.proxy(result)"
            },
            "9": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def remove(self, item):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "",
            "def _proxy(target, attr):",
            "    def get_attr(self):",
            "        return getattr(getattr(self, target), attr)",
            "",
            "    def set_attr(self, value):",
            "        return setattr(getattr(self, target), attr, value)",
            "",
            "    def del_attr(self):",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class Helper(object):",
            "    def __init__(self, proxy_class=None, proxy_kwargs=None):",
            "        self.proxy_class = proxy_class",
            "        self.proxy_kwargs = proxy_kwargs or {}",
            "",
            "    def proxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return self.proxy_class(obj, **self.proxy_kwargs)",
            "",
            "    def unproxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return obj.base",
            "",
            "",
            "class TaskRepo(object):",
            "    def __init__(self, base,",
            "                 task_proxy_class=None, task_proxy_kwargs=None):",
            "        self.base = base",
            "        self.task_proxy_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "",
            "    def get(self, task_id):",
            "        task = self.base.get(task_id)",
            "        return self.task_proxy_helper.proxy(task)",
            "",
            "    def add(self, task):",
            "        self.base.add(self.task_proxy_helper.unproxy(task))",
            "",
            "    def save(self, task):",
            "        self.base.save(self.task_proxy_helper.unproxy(task))",
            "",
            "    def remove(self, task):",
            "        base_task = self.task_proxy_helper.unproxy(task)",
            "        self.base.remove(base_task)",
            "",
            "",
            "class TaskStubRepo(object):",
            "    def __init__(self, base, task_stub_proxy_class=None,",
            "                 task_stub_proxy_kwargs=None):",
            "        self.base = base",
            "        self.task_stub_proxy_helper = Helper(task_stub_proxy_class,",
            "                                             task_stub_proxy_kwargs)",
            "",
            "    def list(self, *args, **kwargs):",
            "        tasks = self.base.list(*args, **kwargs)",
            "        return [self.task_stub_proxy_helper.proxy(task) for task in tasks]",
            "",
            "",
            "class Repo(object):",
            "    def __init__(self, base, item_proxy_class=None, item_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(item_proxy_class, item_proxy_kwargs)",
            "",
            "    def get(self, item_id):",
            "        return self.helper.proxy(self.base.get(item_id))",
            "",
            "    def list(self, *args, **kwargs):",
            "        items = self.base.list(*args, **kwargs)",
            "        return [self.helper.proxy(item) for item in items]",
            "",
            "    def add(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.add(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "    def remove(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "",
            "class ImageFactory(object):",
            "    def __init__(self, base, proxy_class=None, proxy_kwargs=None):",
            "        self.helper = Helper(proxy_class, proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_image(self, **kwargs):",
            "        return self.helper.proxy(self.base.new_image(**kwargs))",
            "",
            "",
            "class ImageMembershipFactory(object):",
            "    def __init__(self, base, image_proxy_class=None, image_proxy_kwargs=None,",
            "                 member_proxy_class=None, member_proxy_kwargs=None):",
            "        self.base = base",
            "        self.image_helper = Helper(image_proxy_class, image_proxy_kwargs)",
            "        self.member_helper = Helper(member_proxy_class, member_proxy_kwargs)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        base_image = self.image_helper.unproxy(image)",
            "        member = self.base.new_image_member(base_image, member_id)",
            "        return self.member_helper.proxy(member)",
            "",
            "",
            "class Image(object):",
            "    def __init__(self, base, member_repo_proxy_class=None,",
            "                 member_repo_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(member_repo_proxy_class,",
            "                             member_repo_proxy_kwargs)",
            "",
            "    name = _proxy('base', 'name')",
            "    image_id = _proxy('base', 'image_id')",
            "    status = _proxy('base', 'status')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "    visibility = _proxy('base', 'visibility')",
            "    min_disk = _proxy('base', 'min_disk')",
            "    min_ram = _proxy('base', 'min_ram')",
            "    protected = _proxy('base', 'protected')",
            "    locations = _proxy('base', 'locations')",
            "    checksum = _proxy('base', 'checksum')",
            "    owner = _proxy('base', 'owner')",
            "    disk_format = _proxy('base', 'disk_format')",
            "    container_format = _proxy('base', 'container_format')",
            "    size = _proxy('base', 'size')",
            "    virtual_size = _proxy('base', 'virtual_size')",
            "    extra_properties = _proxy('base', 'extra_properties')",
            "    tags = _proxy('base', 'tags')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "    def set_data(self, data, size=None):",
            "        self.base.set_data(data, size)",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        return self.base.get_data(*args, **kwargs)",
            "",
            "    def get_member_repo(self):",
            "        return self.helper.proxy(self.base.get_member_repo())",
            "",
            "",
            "class Task(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    type = _proxy('base', 'type')",
            "    status = _proxy('base', 'status')",
            "    owner = _proxy('base', 'owner')",
            "    expires_at = _proxy('base', 'expires_at')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "    task_input = _proxy('base', 'task_input')",
            "    result = _proxy('base', 'result')",
            "    message = _proxy('base', 'message')",
            "",
            "    def begin_processing(self):",
            "        self.base.begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.base.succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.base.fail(message)",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "",
            "class TaskStub(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    type = _proxy('base', 'type')",
            "    status = _proxy('base', 'status')",
            "    owner = _proxy('base', 'owner')",
            "    expires_at = _proxy('base', 'expires_at')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "",
            "class TaskFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 task_proxy_class=None,",
            "                 task_proxy_kwargs=None):",
            "        self.task_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_task(self, **kwargs):",
            "        t = self.base.new_task(**kwargs)",
            "        return self.task_helper.proxy(t)",
            "",
            "",
            "# Metadef Namespace classes",
            "class MetadefNamespaceRepo(object):",
            "    def __init__(self, base,",
            "                 namespace_proxy_class=None, namespace_proxy_kwargs=None):",
            "        self.base = base",
            "        self.namespace_proxy_helper = Helper(namespace_proxy_class,",
            "                                             namespace_proxy_kwargs)",
            "",
            "    def get(self, namespace):",
            "        namespace_obj = self.base.get(namespace)",
            "        return self.namespace_proxy_helper.proxy(namespace_obj)",
            "",
            "    def add(self, namespace):",
            "        self.base.add(self.namespace_proxy_helper.unproxy(namespace))",
            "",
            "    def list(self, *args, **kwargs):",
            "        namespaces = self.base.list(*args, **kwargs)",
            "        return [self.namespace_proxy_helper.proxy(namespace) for namespace",
            "                in namespaces]",
            "",
            "    def remove(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def remove_objects(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove_objects(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def remove_properties(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove_properties(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def remove_tags(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove_tags(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefNamespace(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    namespace_id = _proxy('base', 'namespace_id')",
            "    namespace = _proxy('base', 'namespace')",
            "    display_name = _proxy('base', 'display_name')",
            "    description = _proxy('base', 'description')",
            "    owner = _proxy('base', 'owner')",
            "    visibility = _proxy('base', 'visibility')",
            "    protected = _proxy('base', 'protected')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefNamespaceFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 meta_namespace_proxy_class=None,",
            "                 meta_namespace_proxy_kwargs=None):",
            "        self.meta_namespace_helper = Helper(meta_namespace_proxy_class,",
            "                                            meta_namespace_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_namespace(self, **kwargs):",
            "        t = self.base.new_namespace(**kwargs)",
            "        return self.meta_namespace_helper.proxy(t)",
            "",
            "",
            "# Metadef object classes",
            "class MetadefObjectRepo(object):",
            "    def __init__(self, base,",
            "                 object_proxy_class=None, object_proxy_kwargs=None):",
            "        self.base = base",
            "        self.object_proxy_helper = Helper(object_proxy_class,",
            "                                          object_proxy_kwargs)",
            "",
            "    def get(self, namespace, object_name):",
            "        meta_object = self.base.get(namespace, object_name)",
            "        return self.object_proxy_helper.proxy(meta_object)",
            "",
            "    def add(self, meta_object):",
            "        self.base.add(self.object_proxy_helper.unproxy(meta_object))",
            "",
            "    def list(self, *args, **kwargs):",
            "        objects = self.base.list(*args, **kwargs)",
            "        return [self.object_proxy_helper.proxy(meta_object) for meta_object",
            "                in objects]",
            "",
            "    def remove(self, item):",
            "        base_item = self.object_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.object_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.object_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.object_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefObject(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "    namespace = _proxy('base', 'namespace')",
            "    object_id = _proxy('base', 'object_id')",
            "    name = _proxy('base', 'name')",
            "    required = _proxy('base', 'required')",
            "    description = _proxy('base', 'description')",
            "    properties = _proxy('base', 'properties')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefObjectFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 meta_object_proxy_class=None,",
            "                 meta_object_proxy_kwargs=None):",
            "        self.meta_object_helper = Helper(meta_object_proxy_class,",
            "                                         meta_object_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_object(self, **kwargs):",
            "        t = self.base.new_object(**kwargs)",
            "        return self.meta_object_helper.proxy(t)",
            "",
            "",
            "# Metadef ResourceType classes",
            "class MetadefResourceTypeRepo(object):",
            "    def __init__(self, base, resource_type_proxy_class=None,",
            "                 resource_type_proxy_kwargs=None):",
            "        self.base = base",
            "        self.resource_type_proxy_helper = Helper(resource_type_proxy_class,",
            "                                                 resource_type_proxy_kwargs)",
            "",
            "    def add(self, meta_resource_type):",
            "        self.base.add(self.resource_type_proxy_helper.unproxy(",
            "            meta_resource_type))",
            "",
            "    def get(self, *args, **kwargs):",
            "        resource_type = self.base.get(*args, **kwargs)",
            "        return self.resource_type_proxy_helper.proxy(resource_type)",
            "",
            "    def list(self, *args, **kwargs):",
            "        resource_types = self.base.list(*args, **kwargs)",
            "        return [self.resource_type_proxy_helper.proxy(resource_type)",
            "                for resource_type in resource_types]",
            "",
            "    def remove(self, item):",
            "        base_item = self.resource_type_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.resource_type_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefResourceType(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "    namespace = _proxy('base', 'namespace')",
            "    name = _proxy('base', 'name')",
            "    prefix = _proxy('base', 'prefix')",
            "    properties_target = _proxy('base', 'properties_target')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefResourceTypeFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 resource_type_proxy_class=None,",
            "                 resource_type_proxy_kwargs=None):",
            "        self.resource_type_helper = Helper(resource_type_proxy_class,",
            "                                           resource_type_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_resource_type(self, **kwargs):",
            "        t = self.base.new_resource_type(**kwargs)",
            "        return self.resource_type_helper.proxy(t)",
            "",
            "",
            "# Metadef namespace property classes",
            "class MetadefPropertyRepo(object):",
            "    def __init__(self, base,",
            "                 property_proxy_class=None, property_proxy_kwargs=None):",
            "        self.base = base",
            "        self.property_proxy_helper = Helper(property_proxy_class,",
            "                                            property_proxy_kwargs)",
            "",
            "    def get(self, namespace, property_name):",
            "        property = self.base.get(namespace, property_name)",
            "        return self.property_proxy_helper.proxy(property)",
            "",
            "    def add(self, property):",
            "        self.base.add(self.property_proxy_helper.unproxy(property))",
            "",
            "    def list(self, *args, **kwargs):",
            "        properties = self.base.list(*args, **kwargs)",
            "        return [self.property_proxy_helper.proxy(property) for property",
            "                in properties]",
            "",
            "    def remove(self, item):",
            "        base_item = self.property_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.property_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.property_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.property_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefProperty(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "    namespace = _proxy('base', 'namespace')",
            "    property_id = _proxy('base', 'property_id')",
            "    name = _proxy('base', 'name')",
            "    schema = _proxy('base', 'schema')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefPropertyFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 property_proxy_class=None,",
            "                 property_proxy_kwargs=None):",
            "        self.meta_object_helper = Helper(property_proxy_class,",
            "                                         property_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_namespace_property(self, **kwargs):",
            "        t = self.base.new_namespace_property(**kwargs)",
            "        return self.meta_object_helper.proxy(t)",
            "",
            "",
            "# Metadef tag classes",
            "class MetadefTagRepo(object):",
            "    def __init__(self, base,",
            "                 tag_proxy_class=None, tag_proxy_kwargs=None):",
            "        self.base = base",
            "        self.tag_proxy_helper = Helper(tag_proxy_class,",
            "                                       tag_proxy_kwargs)",
            "",
            "    def get(self, namespace, name):",
            "        meta_tag = self.base.get(namespace, name)",
            "        return self.tag_proxy_helper.proxy(meta_tag)",
            "",
            "    def add(self, meta_tag):",
            "        self.base.add(self.tag_proxy_helper.unproxy(meta_tag))",
            "",
            "    def add_tags(self, meta_tags):",
            "        tags_list = []",
            "        for meta_tag in meta_tags:",
            "            tags_list.append(self.tag_proxy_helper.unproxy(meta_tag))",
            "        self.base.add_tags(tags_list)",
            "",
            "    def list(self, *args, **kwargs):",
            "        tags = self.base.list(*args, **kwargs)",
            "        return [self.tag_proxy_helper.proxy(meta_tag) for meta_tag",
            "                in tags]",
            "",
            "    def remove(self, item):",
            "        base_item = self.tag_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.tag_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.tag_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.tag_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefTag(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    namespace = _proxy('base', 'namespace')",
            "    tag_id = _proxy('base', 'tag_id')",
            "    name = _proxy('base', 'name')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefTagFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 meta_tag_proxy_class=None,",
            "                 meta_tag_proxy_kwargs=None):",
            "        self.meta_tag_helper = Helper(meta_tag_proxy_class,",
            "                                      meta_tag_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_tag(self, **kwargs):",
            "        t = self.base.new_tag(**kwargs)",
            "        return self.meta_tag_helper.proxy(t)"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "",
            "def _proxy(target, attr):",
            "    def get_attr(self):",
            "        return getattr(getattr(self, target), attr)",
            "",
            "    def set_attr(self, value):",
            "        return setattr(getattr(self, target), attr, value)",
            "",
            "    def del_attr(self):",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class Helper(object):",
            "    def __init__(self, proxy_class=None, proxy_kwargs=None):",
            "        self.proxy_class = proxy_class",
            "        self.proxy_kwargs = proxy_kwargs or {}",
            "",
            "    def proxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return self.proxy_class(obj, **self.proxy_kwargs)",
            "",
            "    def unproxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return obj.base",
            "",
            "",
            "class TaskRepo(object):",
            "    def __init__(self, base,",
            "                 task_proxy_class=None, task_proxy_kwargs=None):",
            "        self.base = base",
            "        self.task_proxy_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "",
            "    def get(self, task_id):",
            "        task = self.base.get(task_id)",
            "        return self.task_proxy_helper.proxy(task)",
            "",
            "    def add(self, task):",
            "        self.base.add(self.task_proxy_helper.unproxy(task))",
            "",
            "    def save(self, task):",
            "        self.base.save(self.task_proxy_helper.unproxy(task))",
            "",
            "    def remove(self, task):",
            "        base_task = self.task_proxy_helper.unproxy(task)",
            "        self.base.remove(base_task)",
            "",
            "",
            "class TaskStubRepo(object):",
            "    def __init__(self, base, task_stub_proxy_class=None,",
            "                 task_stub_proxy_kwargs=None):",
            "        self.base = base",
            "        self.task_stub_proxy_helper = Helper(task_stub_proxy_class,",
            "                                             task_stub_proxy_kwargs)",
            "",
            "    def list(self, *args, **kwargs):",
            "        tasks = self.base.list(*args, **kwargs)",
            "        return [self.task_stub_proxy_helper.proxy(task) for task in tasks]",
            "",
            "",
            "class Repo(object):",
            "    def __init__(self, base, item_proxy_class=None, item_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(item_proxy_class, item_proxy_kwargs)",
            "",
            "    def get(self, item_id):",
            "        return self.helper.proxy(self.base.get(item_id))",
            "",
            "    def list(self, *args, **kwargs):",
            "        items = self.base.list(*args, **kwargs)",
            "        return [self.helper.proxy(item) for item in items]",
            "",
            "    def add(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.add(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "    def save(self, item, from_state=None):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.save(base_item, from_state=from_state)",
            "        return self.helper.proxy(result)",
            "",
            "    def remove(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "",
            "class ImageFactory(object):",
            "    def __init__(self, base, proxy_class=None, proxy_kwargs=None):",
            "        self.helper = Helper(proxy_class, proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_image(self, **kwargs):",
            "        return self.helper.proxy(self.base.new_image(**kwargs))",
            "",
            "",
            "class ImageMembershipFactory(object):",
            "    def __init__(self, base, image_proxy_class=None, image_proxy_kwargs=None,",
            "                 member_proxy_class=None, member_proxy_kwargs=None):",
            "        self.base = base",
            "        self.image_helper = Helper(image_proxy_class, image_proxy_kwargs)",
            "        self.member_helper = Helper(member_proxy_class, member_proxy_kwargs)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        base_image = self.image_helper.unproxy(image)",
            "        member = self.base.new_image_member(base_image, member_id)",
            "        return self.member_helper.proxy(member)",
            "",
            "",
            "class Image(object):",
            "    def __init__(self, base, member_repo_proxy_class=None,",
            "                 member_repo_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(member_repo_proxy_class,",
            "                             member_repo_proxy_kwargs)",
            "",
            "    name = _proxy('base', 'name')",
            "    image_id = _proxy('base', 'image_id')",
            "    status = _proxy('base', 'status')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "    visibility = _proxy('base', 'visibility')",
            "    min_disk = _proxy('base', 'min_disk')",
            "    min_ram = _proxy('base', 'min_ram')",
            "    protected = _proxy('base', 'protected')",
            "    locations = _proxy('base', 'locations')",
            "    checksum = _proxy('base', 'checksum')",
            "    owner = _proxy('base', 'owner')",
            "    disk_format = _proxy('base', 'disk_format')",
            "    container_format = _proxy('base', 'container_format')",
            "    size = _proxy('base', 'size')",
            "    virtual_size = _proxy('base', 'virtual_size')",
            "    extra_properties = _proxy('base', 'extra_properties')",
            "    tags = _proxy('base', 'tags')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "    def set_data(self, data, size=None):",
            "        self.base.set_data(data, size)",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        return self.base.get_data(*args, **kwargs)",
            "",
            "    def get_member_repo(self):",
            "        return self.helper.proxy(self.base.get_member_repo())",
            "",
            "",
            "class Task(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    type = _proxy('base', 'type')",
            "    status = _proxy('base', 'status')",
            "    owner = _proxy('base', 'owner')",
            "    expires_at = _proxy('base', 'expires_at')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "    task_input = _proxy('base', 'task_input')",
            "    result = _proxy('base', 'result')",
            "    message = _proxy('base', 'message')",
            "",
            "    def begin_processing(self):",
            "        self.base.begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.base.succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.base.fail(message)",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "",
            "class TaskStub(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    type = _proxy('base', 'type')",
            "    status = _proxy('base', 'status')",
            "    owner = _proxy('base', 'owner')",
            "    expires_at = _proxy('base', 'expires_at')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "",
            "class TaskFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 task_proxy_class=None,",
            "                 task_proxy_kwargs=None):",
            "        self.task_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_task(self, **kwargs):",
            "        t = self.base.new_task(**kwargs)",
            "        return self.task_helper.proxy(t)",
            "",
            "",
            "# Metadef Namespace classes",
            "class MetadefNamespaceRepo(object):",
            "    def __init__(self, base,",
            "                 namespace_proxy_class=None, namespace_proxy_kwargs=None):",
            "        self.base = base",
            "        self.namespace_proxy_helper = Helper(namespace_proxy_class,",
            "                                             namespace_proxy_kwargs)",
            "",
            "    def get(self, namespace):",
            "        namespace_obj = self.base.get(namespace)",
            "        return self.namespace_proxy_helper.proxy(namespace_obj)",
            "",
            "    def add(self, namespace):",
            "        self.base.add(self.namespace_proxy_helper.unproxy(namespace))",
            "",
            "    def list(self, *args, **kwargs):",
            "        namespaces = self.base.list(*args, **kwargs)",
            "        return [self.namespace_proxy_helper.proxy(namespace) for namespace",
            "                in namespaces]",
            "",
            "    def remove(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def remove_objects(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove_objects(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def remove_properties(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove_properties(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def remove_tags(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.remove_tags(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.namespace_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.namespace_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefNamespace(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    namespace_id = _proxy('base', 'namespace_id')",
            "    namespace = _proxy('base', 'namespace')",
            "    display_name = _proxy('base', 'display_name')",
            "    description = _proxy('base', 'description')",
            "    owner = _proxy('base', 'owner')",
            "    visibility = _proxy('base', 'visibility')",
            "    protected = _proxy('base', 'protected')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefNamespaceFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 meta_namespace_proxy_class=None,",
            "                 meta_namespace_proxy_kwargs=None):",
            "        self.meta_namespace_helper = Helper(meta_namespace_proxy_class,",
            "                                            meta_namespace_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_namespace(self, **kwargs):",
            "        t = self.base.new_namespace(**kwargs)",
            "        return self.meta_namespace_helper.proxy(t)",
            "",
            "",
            "# Metadef object classes",
            "class MetadefObjectRepo(object):",
            "    def __init__(self, base,",
            "                 object_proxy_class=None, object_proxy_kwargs=None):",
            "        self.base = base",
            "        self.object_proxy_helper = Helper(object_proxy_class,",
            "                                          object_proxy_kwargs)",
            "",
            "    def get(self, namespace, object_name):",
            "        meta_object = self.base.get(namespace, object_name)",
            "        return self.object_proxy_helper.proxy(meta_object)",
            "",
            "    def add(self, meta_object):",
            "        self.base.add(self.object_proxy_helper.unproxy(meta_object))",
            "",
            "    def list(self, *args, **kwargs):",
            "        objects = self.base.list(*args, **kwargs)",
            "        return [self.object_proxy_helper.proxy(meta_object) for meta_object",
            "                in objects]",
            "",
            "    def remove(self, item):",
            "        base_item = self.object_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.object_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.object_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.object_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefObject(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "    namespace = _proxy('base', 'namespace')",
            "    object_id = _proxy('base', 'object_id')",
            "    name = _proxy('base', 'name')",
            "    required = _proxy('base', 'required')",
            "    description = _proxy('base', 'description')",
            "    properties = _proxy('base', 'properties')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefObjectFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 meta_object_proxy_class=None,",
            "                 meta_object_proxy_kwargs=None):",
            "        self.meta_object_helper = Helper(meta_object_proxy_class,",
            "                                         meta_object_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_object(self, **kwargs):",
            "        t = self.base.new_object(**kwargs)",
            "        return self.meta_object_helper.proxy(t)",
            "",
            "",
            "# Metadef ResourceType classes",
            "class MetadefResourceTypeRepo(object):",
            "    def __init__(self, base, resource_type_proxy_class=None,",
            "                 resource_type_proxy_kwargs=None):",
            "        self.base = base",
            "        self.resource_type_proxy_helper = Helper(resource_type_proxy_class,",
            "                                                 resource_type_proxy_kwargs)",
            "",
            "    def add(self, meta_resource_type):",
            "        self.base.add(self.resource_type_proxy_helper.unproxy(",
            "            meta_resource_type))",
            "",
            "    def get(self, *args, **kwargs):",
            "        resource_type = self.base.get(*args, **kwargs)",
            "        return self.resource_type_proxy_helper.proxy(resource_type)",
            "",
            "    def list(self, *args, **kwargs):",
            "        resource_types = self.base.list(*args, **kwargs)",
            "        return [self.resource_type_proxy_helper.proxy(resource_type)",
            "                for resource_type in resource_types]",
            "",
            "    def remove(self, item):",
            "        base_item = self.resource_type_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.resource_type_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefResourceType(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "    namespace = _proxy('base', 'namespace')",
            "    name = _proxy('base', 'name')",
            "    prefix = _proxy('base', 'prefix')",
            "    properties_target = _proxy('base', 'properties_target')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefResourceTypeFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 resource_type_proxy_class=None,",
            "                 resource_type_proxy_kwargs=None):",
            "        self.resource_type_helper = Helper(resource_type_proxy_class,",
            "                                           resource_type_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_resource_type(self, **kwargs):",
            "        t = self.base.new_resource_type(**kwargs)",
            "        return self.resource_type_helper.proxy(t)",
            "",
            "",
            "# Metadef namespace property classes",
            "class MetadefPropertyRepo(object):",
            "    def __init__(self, base,",
            "                 property_proxy_class=None, property_proxy_kwargs=None):",
            "        self.base = base",
            "        self.property_proxy_helper = Helper(property_proxy_class,",
            "                                            property_proxy_kwargs)",
            "",
            "    def get(self, namespace, property_name):",
            "        property = self.base.get(namespace, property_name)",
            "        return self.property_proxy_helper.proxy(property)",
            "",
            "    def add(self, property):",
            "        self.base.add(self.property_proxy_helper.unproxy(property))",
            "",
            "    def list(self, *args, **kwargs):",
            "        properties = self.base.list(*args, **kwargs)",
            "        return [self.property_proxy_helper.proxy(property) for property",
            "                in properties]",
            "",
            "    def remove(self, item):",
            "        base_item = self.property_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.property_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.property_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.property_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefProperty(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "    namespace = _proxy('base', 'namespace')",
            "    property_id = _proxy('base', 'property_id')",
            "    name = _proxy('base', 'name')",
            "    schema = _proxy('base', 'schema')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefPropertyFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 property_proxy_class=None,",
            "                 property_proxy_kwargs=None):",
            "        self.meta_object_helper = Helper(property_proxy_class,",
            "                                         property_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_namespace_property(self, **kwargs):",
            "        t = self.base.new_namespace_property(**kwargs)",
            "        return self.meta_object_helper.proxy(t)",
            "",
            "",
            "# Metadef tag classes",
            "class MetadefTagRepo(object):",
            "    def __init__(self, base,",
            "                 tag_proxy_class=None, tag_proxy_kwargs=None):",
            "        self.base = base",
            "        self.tag_proxy_helper = Helper(tag_proxy_class,",
            "                                       tag_proxy_kwargs)",
            "",
            "    def get(self, namespace, name):",
            "        meta_tag = self.base.get(namespace, name)",
            "        return self.tag_proxy_helper.proxy(meta_tag)",
            "",
            "    def add(self, meta_tag):",
            "        self.base.add(self.tag_proxy_helper.unproxy(meta_tag))",
            "",
            "    def add_tags(self, meta_tags):",
            "        tags_list = []",
            "        for meta_tag in meta_tags:",
            "            tags_list.append(self.tag_proxy_helper.unproxy(meta_tag))",
            "        self.base.add_tags(tags_list)",
            "",
            "    def list(self, *args, **kwargs):",
            "        tags = self.base.list(*args, **kwargs)",
            "        return [self.tag_proxy_helper.proxy(meta_tag) for meta_tag",
            "                in tags]",
            "",
            "    def remove(self, item):",
            "        base_item = self.tag_proxy_helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.tag_proxy_helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.tag_proxy_helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.tag_proxy_helper.proxy(result)",
            "",
            "",
            "class MetadefTag(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    namespace = _proxy('base', 'namespace')",
            "    tag_id = _proxy('base', 'tag_id')",
            "    name = _proxy('base', 'name')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "",
            "class MetadefTagFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 meta_tag_proxy_class=None,",
            "                 meta_tag_proxy_kwargs=None):",
            "        self.meta_tag_helper = Helper(meta_tag_proxy_class,",
            "                                      meta_tag_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_tag(self, **kwargs):",
            "        t = self.base.new_tag(**kwargs)",
            "        return self.meta_tag_helper.proxy(t)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "97": [
                "Repo",
                "save"
            ],
            "99": [
                "Repo",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/location.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         self._set_acls(image)"
            },
            "1": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         return result"
            },
            "2": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        result = super(ImageRepoProxy, self).save(image)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        result = super(ImageRepoProxy, self).save(image, from_state=from_state)"
            },
            "7": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         self._set_acls(image)"
            },
            "8": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         return result"
            },
            "9": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "",
            "import glance_store as store",
            "from oslo.config import cfg",
            "from oslo.utils import excutils",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "_ = i18n._",
            "_LE = i18n._LE",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api, store_utils):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(location['url'], public=public,",
            "                                    read_tenants=member_ids,",
            "                                    context=self.context)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image):",
            "        result = super(ImageRepoProxy, self).save(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, store_utils, uri):",
            "    \"\"\"Check if an image location is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param store_utils: store utils module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "",
            "    is_ok = True",
            "    try:",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = (store_utils.validate_external_location(uri) and",
            "                 store_api.get_size_from_backend(uri, context=context) > 0)",
            "    except (store.UnknownScheme, store.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        reason = _('Invalid location')",
            "        raise exception.BadStoreUri(message=reason)",
            "",
            "",
            "def _check_image_location(context, store_api, store_utils, location):",
            "    _check_location_uri(context, store_api, store_utils, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = store.get_size_from_backend(",
            "                location['url'], context=context)",
            "",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "def _count_duplicated_locations(locations, new):",
            "    \"\"\"",
            "    To calculate the count of duplicated locations for new one.",
            "",
            "    :param locations: The exiting image location set",
            "    :param new: The new image location",
            "    :returns: The count of duplicated locations",
            "    \"\"\"",
            "",
            "    ret = 0",
            "    for loc in locations:",
            "        if (loc['url'] == new['url'] and loc['metadata'] == new['metadata']):",
            "            ret += 1",
            "    return ret",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api, store_utils):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        self.store_utils = store_utils",
            "        proxy_kwargs = {'context': context, 'store_api': store_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for loc in locations:",
            "            _check_image_location(self.context,",
            "                                  self.store_api,",
            "                                  self.store_utils,",
            "                                  loc)",
            "            loc['status'] = 'active'",
            "            if _count_duplicated_locations(locations, loc) > 1:",
            "                raise exception.DuplicateLocation(location=loc['url'])",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api,",
            "                              self.image_proxy.store_utils,",
            "                              location)",
            "        location['status'] = 'active'",
            "        if _count_duplicated_locations(self.value, location) > 0:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            self.image_proxy.store_utils.delete_image_location_from_backend(",
            "                self.image_proxy.context,",
            "                self.image_proxy.image.image_id,",
            "                location)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                self.value.insert(i, location)",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api,",
            "                              self.image_proxy.store_utils,",
            "                              location)",
            "        location['status'] = 'active'",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        self.image_proxy.store_utils.delete_image_location_from_backend(",
            "            self.image_proxy.context,",
            "            self.image_proxy.image.image_id,",
            "            location)",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            self.image_proxy.store_utils.delete_image_location_from_backend(",
            "                self.image_proxy.context,",
            "                self.image_proxy.image.image_id,",
            "                location)",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            reason = _('Invalid locations')",
            "            raise exception.BadStoreUri(message=reason)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context,",
            "                                      self.store_api,",
            "                                      self.store_utils,",
            "                                      location)",
            "                location['status'] = 'active'",
            "                if _count_duplicated_locations(value, location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            self.store_utils.delete_image_location_from_backend(",
            "                self.context,",
            "                self.image.image_id,",
            "                value[0])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api, store_utils):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        self.store_utils = store_utils",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_utils.delete_image_location_from_backend(",
            "                    self.context,",
            "                    self.image.image_id,",
            "                    location)",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            CONF,",
            "            self.image.image_id,",
            "            utils.LimitingReader(utils.CooperativeReader(data),",
            "                                 CONF.image_size_cap),",
            "            size,",
            "            context=self.context)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta,",
            "                                 'status': 'active'}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self, offset=0, chunk_size=None):",
            "        if not self.image.locations:",
            "            raise store.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(",
            "                    loc['url'],",
            "                    offset=offset,",
            "                    chunk_size=chunk_size,",
            "                    context=self.context)",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': utils.exception_to_str(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_LE('Glance tried all active locations to get data for '",
            "                      'image %s but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(location['url'], public=public,",
            "                                        read_tenants=member_ids,",
            "                                        context=self.context)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "afterPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "",
            "import glance_store as store",
            "from oslo.config import cfg",
            "from oslo.utils import excutils",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "_ = i18n._",
            "_LE = i18n._LE",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api, store_utils):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(location['url'], public=public,",
            "                                    read_tenants=member_ids,",
            "                                    context=self.context)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image, from_state=None):",
            "        result = super(ImageRepoProxy, self).save(image, from_state=from_state)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, store_utils, uri):",
            "    \"\"\"Check if an image location is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param store_utils: store utils module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "",
            "    is_ok = True",
            "    try:",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = (store_utils.validate_external_location(uri) and",
            "                 store_api.get_size_from_backend(uri, context=context) > 0)",
            "    except (store.UnknownScheme, store.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        reason = _('Invalid location')",
            "        raise exception.BadStoreUri(message=reason)",
            "",
            "",
            "def _check_image_location(context, store_api, store_utils, location):",
            "    _check_location_uri(context, store_api, store_utils, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = store.get_size_from_backend(",
            "                location['url'], context=context)",
            "",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "def _count_duplicated_locations(locations, new):",
            "    \"\"\"",
            "    To calculate the count of duplicated locations for new one.",
            "",
            "    :param locations: The exiting image location set",
            "    :param new: The new image location",
            "    :returns: The count of duplicated locations",
            "    \"\"\"",
            "",
            "    ret = 0",
            "    for loc in locations:",
            "        if (loc['url'] == new['url'] and loc['metadata'] == new['metadata']):",
            "            ret += 1",
            "    return ret",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api, store_utils):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        self.store_utils = store_utils",
            "        proxy_kwargs = {'context': context, 'store_api': store_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for loc in locations:",
            "            _check_image_location(self.context,",
            "                                  self.store_api,",
            "                                  self.store_utils,",
            "                                  loc)",
            "            loc['status'] = 'active'",
            "            if _count_duplicated_locations(locations, loc) > 1:",
            "                raise exception.DuplicateLocation(location=loc['url'])",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api,",
            "                              self.image_proxy.store_utils,",
            "                              location)",
            "        location['status'] = 'active'",
            "        if _count_duplicated_locations(self.value, location) > 0:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            self.image_proxy.store_utils.delete_image_location_from_backend(",
            "                self.image_proxy.context,",
            "                self.image_proxy.image.image_id,",
            "                location)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                self.value.insert(i, location)",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api,",
            "                              self.image_proxy.store_utils,",
            "                              location)",
            "        location['status'] = 'active'",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        self.image_proxy.store_utils.delete_image_location_from_backend(",
            "            self.image_proxy.context,",
            "            self.image_proxy.image.image_id,",
            "            location)",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            self.image_proxy.store_utils.delete_image_location_from_backend(",
            "                self.image_proxy.context,",
            "                self.image_proxy.image.image_id,",
            "                location)",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            reason = _('Invalid locations')",
            "            raise exception.BadStoreUri(message=reason)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context,",
            "                                      self.store_api,",
            "                                      self.store_utils,",
            "                                      location)",
            "                location['status'] = 'active'",
            "                if _count_duplicated_locations(value, location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            self.store_utils.delete_image_location_from_backend(",
            "                self.context,",
            "                self.image.image_id,",
            "                value[0])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api, store_utils):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        self.store_utils = store_utils",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_utils.delete_image_location_from_backend(",
            "                    self.context,",
            "                    self.image.image_id,",
            "                    location)",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            CONF,",
            "            self.image.image_id,",
            "            utils.LimitingReader(utils.CooperativeReader(data),",
            "                                 CONF.image_size_cap),",
            "            size,",
            "            context=self.context)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta,",
            "                                 'status': 'active'}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self, offset=0, chunk_size=None):",
            "        if not self.image.locations:",
            "            raise store.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(",
            "                    loc['url'],",
            "                    offset=offset,",
            "                    chunk_size=chunk_size,",
            "                    context=self.context)",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': utils.exception_to_str(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_LE('Glance tried all active locations to get data for '",
            "                      'image %s but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(location['url'], public=public,",
            "                                        read_tenants=member_ids,",
            "                                        context=self.context)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "64": [
                "ImageRepoProxy",
                "save"
            ],
            "65": [
                "ImageRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/notifier.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "                                              item_proxy_class=ImageProxy,"
            },
            "1": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "                                              item_proxy_kwargs=proxy_kwargs)"
            },
            "2": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super(ImageRepoProxy, self).save(image)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        super(ImageRepoProxy, self).save(image, from_state=from_state)"
            },
            "7": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         self.notifier.info('image.update',"
            },
            "8": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                            format_image_notification(image))"
            },
            "9": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2011, OpenStack Foundation",
            "# Copyright 2012, Red Hat, Inc.",
            "# Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import glance_store",
            "from oslo.config import cfg",
            "from oslo import messaging",
            "from oslo.utils import excutils",
            "from oslo.utils import timeutils",
            "import webob",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "",
            "_ = i18n._",
            "",
            "notifier_opts = [",
            "    cfg.StrOpt('default_publisher_id', default=\"image.localhost\",",
            "               help='Default publisher_id for outgoing notifications.'),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(notifier_opts)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "_ALIASES = {",
            "    'glance.openstack.common.rpc.impl_kombu': 'rabbit',",
            "    'glance.openstack.common.rpc.impl_qpid': 'qpid',",
            "    'glance.openstack.common.rpc.impl_zmq': 'zmq',",
            "}",
            "",
            "",
            "def get_transport():",
            "    return messaging.get_transport(CONF, aliases=_ALIASES)",
            "",
            "",
            "class Notifier(object):",
            "    \"\"\"Uses a notification strategy to send out messages about events.\"\"\"",
            "",
            "    def __init__(self):",
            "        publisher_id = CONF.default_publisher_id",
            "        self._transport = get_transport()",
            "        self._notifier = messaging.Notifier(self._transport,",
            "                                            publisher_id=publisher_id)",
            "",
            "    def warn(self, event_type, payload):",
            "        self._notifier.warn({}, event_type, payload)",
            "",
            "    def info(self, event_type, payload):",
            "        self._notifier.info({}, event_type, payload)",
            "",
            "    def error(self, event_type, payload):",
            "        self._notifier.error({}, event_type, payload)",
            "",
            "",
            "def format_image_notification(image):",
            "    \"\"\"",
            "    Given a glance.domain.Image object, return a dictionary of relevant",
            "    notification information. We purposely do not include 'location'",
            "    as it may contain credentials.",
            "    \"\"\"",
            "    return {",
            "        'id': image.image_id,",
            "        'name': image.name,",
            "        'status': image.status,",
            "        'created_at': timeutils.isotime(image.created_at),",
            "        'updated_at': timeutils.isotime(image.updated_at),",
            "        'min_disk': image.min_disk,",
            "        'min_ram': image.min_ram,",
            "        'protected': image.protected,",
            "        'checksum': image.checksum,",
            "        'owner': image.owner,",
            "        'disk_format': image.disk_format,",
            "        'container_format': image.container_format,",
            "        'size': image.size,",
            "        'is_public': image.visibility == 'public',",
            "        'properties': dict(image.extra_properties),",
            "        'tags': list(image.tags),",
            "        'deleted': False,",
            "        'deleted_at': None,",
            "    }",
            "",
            "",
            "def format_task_notification(task):",
            "    # NOTE(nikhil): input is not passed to the notifier payload as it may",
            "    # contain sensitive info.",
            "    return {'id': task.task_id,",
            "            'type': task.type,",
            "            'status': task.status,",
            "            'result': None,",
            "            'owner': task.owner,",
            "            'message': None,",
            "            'expires_at': timeutils.isotime(task.expires_at),",
            "            'created_at': timeutils.isotime(task.created_at),",
            "            'updated_at': timeutils.isotime(task.updated_at),",
            "            'deleted': False,",
            "            'deleted_at': None,",
            "            }",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, notifier):",
            "        self.image_repo = image_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def save(self, image):",
            "        super(ImageRepoProxy, self).save(image)",
            "        self.notifier.info('image.update',",
            "                           format_image_notification(image))",
            "",
            "    def add(self, image):",
            "        super(ImageRepoProxy, self).add(image)",
            "        self.notifier.info('image.create',",
            "                           format_image_notification(image))",
            "",
            "    def remove(self, image):",
            "        super(ImageRepoProxy, self).remove(image)",
            "        payload = format_image_notification(image)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('image.delete', payload)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, notifier):",
            "        self.image = image",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def _format_image_send(self, bytes_sent):",
            "        return {",
            "            'bytes_sent': bytes_sent,",
            "            'image_id': self.image.image_id,",
            "            'owner_id': self.image.owner,",
            "            'receiver_tenant_id': self.context.tenant,",
            "            'receiver_user_id': self.context.user,",
            "        }",
            "",
            "    def _get_chunk_data_iterator(self, data, chunk_size=None):",
            "        sent = 0",
            "        for chunk in data:",
            "            yield chunk",
            "            sent += len(chunk)",
            "",
            "        if sent != (chunk_size or self.image.size):",
            "            notify = self.notifier.error",
            "        else:",
            "            notify = self.notifier.info",
            "",
            "        try:",
            "            notify('image.send',",
            "                   self._format_image_send(sent))",
            "        except Exception as err:",
            "            msg = (_(\"An error occurred during image.send\"",
            "                     \" notification: %(err)s\") % {'err': err})",
            "            LOG.error(msg)",
            "",
            "    def get_data(self, offset=0, chunk_size=None):",
            "        # Due to the need of evaluating subsequent proxies, this one",
            "        # should return a generator, the call should be done before",
            "        # generator creation",
            "        data = self.image.get_data(offset=offset, chunk_size=chunk_size)",
            "        return self._get_chunk_data_iterator(data, chunk_size=chunk_size)",
            "",
            "    def set_data(self, data, size=None):",
            "        payload = format_image_notification(self.image)",
            "        self.notifier.info('image.prepare', payload)",
            "        try:",
            "            self.image.set_data(data, size)",
            "        except glance_store.StorageFull as e:",
            "            msg = (_(\"Image storage media is full: %s\") %",
            "                   utils.exception_to_str(e))",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg)",
            "        except glance_store.StorageWriteDenied as e:",
            "            msg = (_(\"Insufficient permissions on image storage media: %s\")",
            "                   % utils.exception_to_str(e))",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg)",
            "        except ValueError as e:",
            "            msg = (_(\"Cannot save data for image %(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPBadRequest(",
            "                explanation=utils.exception_to_str(e))",
            "        except exception.Duplicate as e:",
            "            msg = (_(\"Unable to upload duplicate image data for image\"",
            "                     \"%(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPConflict(explanation=msg)",
            "        except exception.Forbidden as e:",
            "            msg = (_(\"Not allowed to upload image data for image %(image_id)s:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg)",
            "        except exception.NotFound as e:",
            "            msg = (_(\"Image %(image_id)s could not be found after upload.\"",
            "                     \" The image may have been deleted during the upload:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPNotFound(explanation=utils.exception_to_str(e))",
            "        except webob.exc.HTTPError as e:",
            "            with excutils.save_and_reraise_exception():",
            "                msg = (_(\"Failed to upload image data for image %(image_id)s\"",
            "                         \" due to HTTP error: %(error)s\") %",
            "                       {'image_id': self.image.image_id,",
            "                        'error': utils.exception_to_str(e)})",
            "                self.notifier.error('image.upload', msg)",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                msg = (_(\"Failed to upload image data for image %(image_id)s \"",
            "                         \"due to internal error: %(error)s\") %",
            "                       {'image_id': self.image.image_id,",
            "                        'error': utils.exception_to_str(e)})",
            "                self.notifier.error('image.upload', msg)",
            "        else:",
            "            payload = format_image_notification(self.image)",
            "            self.notifier.info('image.upload', payload)",
            "            self.notifier.info('image.activate', payload)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, notifier):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(TaskRepoProxy, self).__init__(task_repo,",
            "                                            task_proxy_class=TaskProxy,",
            "                                            task_proxy_kwargs=proxy_kwargs)",
            "",
            "    def add(self, task):",
            "        self.notifier.info('task.create',",
            "                           format_task_notification(task))",
            "        super(TaskRepoProxy, self).add(task)",
            "",
            "    def remove(self, task):",
            "        payload = format_task_notification(task)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('task.delete', payload)",
            "        super(TaskRepoProxy, self).remove(task)",
            "",
            "",
            "class TaskStubRepoProxy(glance.domain.proxy.TaskStubRepo):",
            "",
            "    def __init__(self, task_stub_repo, context, notifier):",
            "        self.task_stub_repo = task_stub_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(TaskStubRepoProxy, self).__init__(",
            "            task_stub_repo,",
            "            task_stub_proxy_class=TaskStubProxy,",
            "            task_stub_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "    def __init__(self, task_factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=kwargs)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, notifier):",
            "        self.task = task",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "    def begin_processing(self):",
            "        self.notifier.info(",
            "            'task.processing',",
            "            format_task_notification(self.task)",
            "        )",
            "        return super(TaskProxy, self).begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.notifier.info('task.success',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.notifier.info('task.failure',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).fail(message)",
            "",
            "    def run(self, executor):",
            "        self.notifier.info('task.run',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).run(executor)",
            "",
            "",
            "class TaskStubProxy(glance.domain.proxy.TaskStub):",
            "",
            "    def __init__(self, task, context, notifier):",
            "        self.task = task",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskStubProxy, self).__init__(task)"
        ],
        "afterPatchFile": [
            "# Copyright 2011, OpenStack Foundation",
            "# Copyright 2012, Red Hat, Inc.",
            "# Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import glance_store",
            "from oslo.config import cfg",
            "from oslo import messaging",
            "from oslo.utils import excutils",
            "from oslo.utils import timeutils",
            "import webob",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "",
            "_ = i18n._",
            "",
            "notifier_opts = [",
            "    cfg.StrOpt('default_publisher_id', default=\"image.localhost\",",
            "               help='Default publisher_id for outgoing notifications.'),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(notifier_opts)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "_ALIASES = {",
            "    'glance.openstack.common.rpc.impl_kombu': 'rabbit',",
            "    'glance.openstack.common.rpc.impl_qpid': 'qpid',",
            "    'glance.openstack.common.rpc.impl_zmq': 'zmq',",
            "}",
            "",
            "",
            "def get_transport():",
            "    return messaging.get_transport(CONF, aliases=_ALIASES)",
            "",
            "",
            "class Notifier(object):",
            "    \"\"\"Uses a notification strategy to send out messages about events.\"\"\"",
            "",
            "    def __init__(self):",
            "        publisher_id = CONF.default_publisher_id",
            "        self._transport = get_transport()",
            "        self._notifier = messaging.Notifier(self._transport,",
            "                                            publisher_id=publisher_id)",
            "",
            "    def warn(self, event_type, payload):",
            "        self._notifier.warn({}, event_type, payload)",
            "",
            "    def info(self, event_type, payload):",
            "        self._notifier.info({}, event_type, payload)",
            "",
            "    def error(self, event_type, payload):",
            "        self._notifier.error({}, event_type, payload)",
            "",
            "",
            "def format_image_notification(image):",
            "    \"\"\"",
            "    Given a glance.domain.Image object, return a dictionary of relevant",
            "    notification information. We purposely do not include 'location'",
            "    as it may contain credentials.",
            "    \"\"\"",
            "    return {",
            "        'id': image.image_id,",
            "        'name': image.name,",
            "        'status': image.status,",
            "        'created_at': timeutils.isotime(image.created_at),",
            "        'updated_at': timeutils.isotime(image.updated_at),",
            "        'min_disk': image.min_disk,",
            "        'min_ram': image.min_ram,",
            "        'protected': image.protected,",
            "        'checksum': image.checksum,",
            "        'owner': image.owner,",
            "        'disk_format': image.disk_format,",
            "        'container_format': image.container_format,",
            "        'size': image.size,",
            "        'is_public': image.visibility == 'public',",
            "        'properties': dict(image.extra_properties),",
            "        'tags': list(image.tags),",
            "        'deleted': False,",
            "        'deleted_at': None,",
            "    }",
            "",
            "",
            "def format_task_notification(task):",
            "    # NOTE(nikhil): input is not passed to the notifier payload as it may",
            "    # contain sensitive info.",
            "    return {'id': task.task_id,",
            "            'type': task.type,",
            "            'status': task.status,",
            "            'result': None,",
            "            'owner': task.owner,",
            "            'message': None,",
            "            'expires_at': timeutils.isotime(task.expires_at),",
            "            'created_at': timeutils.isotime(task.created_at),",
            "            'updated_at': timeutils.isotime(task.updated_at),",
            "            'deleted': False,",
            "            'deleted_at': None,",
            "            }",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, notifier):",
            "        self.image_repo = image_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def save(self, image, from_state=None):",
            "        super(ImageRepoProxy, self).save(image, from_state=from_state)",
            "        self.notifier.info('image.update',",
            "                           format_image_notification(image))",
            "",
            "    def add(self, image):",
            "        super(ImageRepoProxy, self).add(image)",
            "        self.notifier.info('image.create',",
            "                           format_image_notification(image))",
            "",
            "    def remove(self, image):",
            "        super(ImageRepoProxy, self).remove(image)",
            "        payload = format_image_notification(image)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('image.delete', payload)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, notifier):",
            "        self.image = image",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def _format_image_send(self, bytes_sent):",
            "        return {",
            "            'bytes_sent': bytes_sent,",
            "            'image_id': self.image.image_id,",
            "            'owner_id': self.image.owner,",
            "            'receiver_tenant_id': self.context.tenant,",
            "            'receiver_user_id': self.context.user,",
            "        }",
            "",
            "    def _get_chunk_data_iterator(self, data, chunk_size=None):",
            "        sent = 0",
            "        for chunk in data:",
            "            yield chunk",
            "            sent += len(chunk)",
            "",
            "        if sent != (chunk_size or self.image.size):",
            "            notify = self.notifier.error",
            "        else:",
            "            notify = self.notifier.info",
            "",
            "        try:",
            "            notify('image.send',",
            "                   self._format_image_send(sent))",
            "        except Exception as err:",
            "            msg = (_(\"An error occurred during image.send\"",
            "                     \" notification: %(err)s\") % {'err': err})",
            "            LOG.error(msg)",
            "",
            "    def get_data(self, offset=0, chunk_size=None):",
            "        # Due to the need of evaluating subsequent proxies, this one",
            "        # should return a generator, the call should be done before",
            "        # generator creation",
            "        data = self.image.get_data(offset=offset, chunk_size=chunk_size)",
            "        return self._get_chunk_data_iterator(data, chunk_size=chunk_size)",
            "",
            "    def set_data(self, data, size=None):",
            "        payload = format_image_notification(self.image)",
            "        self.notifier.info('image.prepare', payload)",
            "        try:",
            "            self.image.set_data(data, size)",
            "        except glance_store.StorageFull as e:",
            "            msg = (_(\"Image storage media is full: %s\") %",
            "                   utils.exception_to_str(e))",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg)",
            "        except glance_store.StorageWriteDenied as e:",
            "            msg = (_(\"Insufficient permissions on image storage media: %s\")",
            "                   % utils.exception_to_str(e))",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg)",
            "        except ValueError as e:",
            "            msg = (_(\"Cannot save data for image %(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPBadRequest(",
            "                explanation=utils.exception_to_str(e))",
            "        except exception.Duplicate as e:",
            "            msg = (_(\"Unable to upload duplicate image data for image\"",
            "                     \"%(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPConflict(explanation=msg)",
            "        except exception.Forbidden as e:",
            "            msg = (_(\"Not allowed to upload image data for image %(image_id)s:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg)",
            "        except exception.NotFound as e:",
            "            msg = (_(\"Image %(image_id)s could not be found after upload.\"",
            "                     \" The image may have been deleted during the upload:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': utils.exception_to_str(e)})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPNotFound(explanation=utils.exception_to_str(e))",
            "        except webob.exc.HTTPError as e:",
            "            with excutils.save_and_reraise_exception():",
            "                msg = (_(\"Failed to upload image data for image %(image_id)s\"",
            "                         \" due to HTTP error: %(error)s\") %",
            "                       {'image_id': self.image.image_id,",
            "                        'error': utils.exception_to_str(e)})",
            "                self.notifier.error('image.upload', msg)",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                msg = (_(\"Failed to upload image data for image %(image_id)s \"",
            "                         \"due to internal error: %(error)s\") %",
            "                       {'image_id': self.image.image_id,",
            "                        'error': utils.exception_to_str(e)})",
            "                self.notifier.error('image.upload', msg)",
            "        else:",
            "            payload = format_image_notification(self.image)",
            "            self.notifier.info('image.upload', payload)",
            "            self.notifier.info('image.activate', payload)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, notifier):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(TaskRepoProxy, self).__init__(task_repo,",
            "                                            task_proxy_class=TaskProxy,",
            "                                            task_proxy_kwargs=proxy_kwargs)",
            "",
            "    def add(self, task):",
            "        self.notifier.info('task.create',",
            "                           format_task_notification(task))",
            "        super(TaskRepoProxy, self).add(task)",
            "",
            "    def remove(self, task):",
            "        payload = format_task_notification(task)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('task.delete', payload)",
            "        super(TaskRepoProxy, self).remove(task)",
            "",
            "",
            "class TaskStubRepoProxy(glance.domain.proxy.TaskStubRepo):",
            "",
            "    def __init__(self, task_stub_repo, context, notifier):",
            "        self.task_stub_repo = task_stub_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(TaskStubRepoProxy, self).__init__(",
            "            task_stub_repo,",
            "            task_stub_proxy_class=TaskStubProxy,",
            "            task_stub_proxy_kwargs=proxy_kwargs)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "    def __init__(self, task_factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=kwargs)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, notifier):",
            "        self.task = task",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "    def begin_processing(self):",
            "        self.notifier.info(",
            "            'task.processing',",
            "            format_task_notification(self.task)",
            "        )",
            "        return super(TaskProxy, self).begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.notifier.info('task.success',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.notifier.info('task.failure',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).fail(message)",
            "",
            "    def run(self, executor):",
            "        self.notifier.info('task.run',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).run(executor)",
            "",
            "",
            "class TaskStubProxy(glance.domain.proxy.TaskStub):",
            "",
            "    def __init__(self, task, context, notifier):",
            "        self.task = task",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskStubProxy, self).__init__(task)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "128": [
                "ImageRepoProxy",
                "save"
            ],
            "129": [
                "ImageRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/quota/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "             LOG.debug(six.text_type(exc))"
            },
            "1": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "             raise exc"
            },
            "2": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         if image.added_new_properties():"
            },
            "6": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             self._enforce_image_property_quota(len(image.extra_properties))"
            },
            "7": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return super(ImageRepoProxy, self).save(image)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        return super(ImageRepoProxy, self).save(image, from_state=from_state)"
            },
            "9": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     def add(self, image):"
            },
            "11": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         self._enforce_image_property_quota(len(image.extra_properties))"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "import glance_store as store",
            "from oslo.config import cfg",
            "from oslo.utils import excutils",
            "import six",
            "",
            "import glance.api.common",
            "import glance.common.exception as exception",
            "from glance.common import utils",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "_ = i18n._",
            "_LI = i18n._LI",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_member_quota', 'glance.common.config')",
            "CONF.import_opt('image_property_quota', 'glance.common.config')",
            "CONF.import_opt('image_tag_quota', 'glance.common.config')",
            "",
            "",
            "def _enforce_image_tag_quota(tags):",
            "    if CONF.image_tag_quota < 0:",
            "        # If value is negative, allow unlimited number of tags",
            "        return",
            "",
            "    if not tags:",
            "        return",
            "",
            "    if len(tags) > CONF.image_tag_quota:",
            "        raise exception.ImageTagLimitExceeded(attempted=len(tags),",
            "                                              maximum=CONF.image_tag_quota)",
            "",
            "",
            "def _calc_required_size(context, image, locations):",
            "    required_size = None",
            "    if image.size:",
            "        required_size = image.size * len(locations)",
            "    else:",
            "        for location in locations:",
            "            size_from_backend = None",
            "            try:",
            "                size_from_backend = store.get_size_from_backend(",
            "                    location['url'], context=context)",
            "            except (store.UnknownScheme, store.NotFound):",
            "                pass",
            "            if size_from_backend:",
            "                required_size = size_from_backend * len(locations)",
            "                break",
            "    return required_size",
            "",
            "",
            "def _enforce_image_location_quota(image, locations, is_setter=False):",
            "    if CONF.image_location_quota < 0:",
            "        # If value is negative, allow unlimited number of locations",
            "        return",
            "",
            "    attempted = len(image.locations) + len(locations)",
            "    attempted = attempted if not is_setter else len(locations)",
            "    maximum = CONF.image_location_quota",
            "    if attempted > maximum:",
            "        raise exception.ImageLocationLimitExceeded(attempted=attempted,",
            "                                                   maximum=maximum)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, db_api, store_utils):",
            "        self.image_repo = image_repo",
            "        self.db_api = db_api",
            "        proxy_kwargs = {'context': context, 'db_api': db_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _enforce_image_property_quota(self, attempted):",
            "        if CONF.image_property_quota < 0:",
            "            # If value is negative, allow unlimited number of properties",
            "            return",
            "",
            "        maximum = CONF.image_property_quota",
            "        if attempted > maximum:",
            "            kwargs = {'attempted': attempted, 'maximum': maximum}",
            "            exc = exception.ImagePropertyLimitExceeded(**kwargs)",
            "            LOG.debug(six.text_type(exc))",
            "            raise exc",
            "",
            "    def save(self, image):",
            "        if image.added_new_properties():",
            "            self._enforce_image_property_quota(len(image.extra_properties))",
            "        return super(ImageRepoProxy, self).save(image)",
            "",
            "    def add(self, image):",
            "        self._enforce_image_property_quota(len(image.extra_properties))",
            "        return super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, db_api, store_utils):",
            "        proxy_kwargs = {'context': context, 'db_api': db_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        tags = kwargs.pop('tags', set([]))",
            "        _enforce_image_tag_quota(tags)",
            "        return super(ImageFactoryProxy, self).new_image(tags=tags, **kwargs)",
            "",
            "",
            "class QuotaImageTagsProxy(object):",
            "",
            "    def __init__(self, orig_set):",
            "        if orig_set is None:",
            "            orig_set = set([])",
            "        self.tags = orig_set",
            "",
            "    def add(self, item):",
            "        self.tags.add(item)",
            "        _enforce_image_tag_quota(self.tags)",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.tags.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.tags.__contains__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.tags == other",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.tags.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.tags.__len__(*args, **kwargs)",
            "",
            "    def __getattr__(self, name):",
            "        return getattr(self.tags, name)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, db_api, store_utils):",
            "        self.db_api = db_api",
            "        self.context = context",
            "        proxy_kwargs = {'context': context, 'db_api': db_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _enforce_image_member_quota(self, image):",
            "        if CONF.image_member_quota < 0:",
            "            # If value is negative, allow unlimited number of members",
            "            return",
            "",
            "        current_member_count = self.db_api.image_member_count(self.context,",
            "                                                              image.image_id)",
            "        attempted = current_member_count + 1",
            "        maximum = CONF.image_member_quota",
            "        if attempted > maximum:",
            "            raise exception.ImageMemberLimitExceeded(attempted=attempted,",
            "                                                     maximum=maximum)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self._enforce_image_member_quota(image)",
            "        return super(ImageMemberFactoryProxy, self).new_image_member(image,",
            "                                                                     member_id)",
            "",
            "",
            "class QuotaImageLocationsProxy(object):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.locations = image.locations",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.locations.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.locations.__contains__(*args, **kwargs)",
            "",
            "    def __delitem__(self, *args, **kwargs):",
            "        return self.locations.__delitem__(*args, **kwargs)",
            "",
            "    def __delslice__(self, *args, **kwargs):",
            "        return self.locations.__delslice__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.locations == other",
            "",
            "    def __getitem__(self, *args, **kwargs):",
            "        return self.locations.__getitem__(*args, **kwargs)",
            "",
            "    def __iadd__(self, other):",
            "        if not hasattr(other, '__iter__'):",
            "            raise TypeError()",
            "        self._check_user_storage_quota(other)",
            "        return self.locations.__iadd__(other)",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.locations.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.locations.__len__(*args, **kwargs)",
            "",
            "    def __setitem__(self, key, value):",
            "        return self.locations.__setitem__(key, value)",
            "",
            "    def count(self, *args, **kwargs):",
            "        return self.locations.count(*args, **kwargs)",
            "",
            "    def index(self, *args, **kwargs):",
            "        return self.locations.index(*args, **kwargs)",
            "",
            "    def pop(self, *args, **kwargs):",
            "        return self.locations.pop(*args, **kwargs)",
            "",
            "    def remove(self, *args, **kwargs):",
            "        return self.locations.remove(*args, **kwargs)",
            "",
            "    def reverse(self, *args, **kwargs):",
            "        return self.locations.reverse(*args, **kwargs)",
            "",
            "    def _check_user_storage_quota(self, locations):",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            locations)",
            "        glance.api.common.check_quota(self.context,",
            "                                      required_size,",
            "                                      self.db_api)",
            "        _enforce_image_location_quota(self.image, locations)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        self.image.locations = copy.deepcopy(self.locations, memo)",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def append(self, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.append(object)",
            "",
            "    def insert(self, index, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.insert(index, object)",
            "",
            "    def extend(self, iter):",
            "        self._check_user_storage_quota(iter)",
            "        return self.locations.extend(iter)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api, store_utils):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.store_utils = store_utils",
            "        super(ImageProxy, self).__init__(image)",
            "        self.orig_props = set(image.extra_properties.keys())",
            "",
            "    def set_data(self, data, size=None):",
            "        remaining = glance.api.common.check_quota(",
            "            self.context, size, self.db_api, image_id=self.image.image_id)",
            "        if remaining is not None:",
            "            # NOTE(jbresnah) we are trying to enforce a quota, put a limit",
            "            # reader on the data",
            "            data = utils.LimitingReader(data, remaining)",
            "        try:",
            "            self.image.set_data(data, size=size)",
            "        except exception.ImageSizeLimitExceeded:",
            "            raise exception.StorageQuotaFull(image_size=size,",
            "                                             remaining=remaining)",
            "",
            "        # NOTE(jbresnah) If two uploads happen at the same time and neither",
            "        # properly sets the size attribute[1] then there is a race condition",
            "        # that will allow for the quota to be broken[2].  Thus we must recheck",
            "        # the quota after the upload and thus after we know the size.",
            "        #",
            "        # Also, when an upload doesn't set the size properly then the call to",
            "        # check_quota above returns None and so utils.LimitingReader is not",
            "        # used above. Hence the store (e.g.  filesystem store) may have to",
            "        # download the entire file before knowing the actual file size.  Here",
            "        # also we need to check for the quota again after the image has been",
            "        # downloaded to the store.",
            "        #",
            "        # [1] For e.g. when using chunked transfers the 'Content-Length'",
            "        #     header is not set.",
            "        # [2] For e.g.:",
            "        #       - Upload 1 does not exceed quota but upload 2 exceeds quota.",
            "        #         Both uploads are to different locations",
            "        #       - Upload 2 completes before upload 1 and writes image.size.",
            "        #       - Immediately, upload 1 completes and (over)writes image.size",
            "        #         with the smaller size.",
            "        #       - Now, to glance, image has not exceeded quota but, in",
            "        #         reality, the quota has been exceeded.",
            "",
            "        try:",
            "            glance.api.common.check_quota(",
            "                self.context, self.image.size, self.db_api,",
            "                image_id=self.image.image_id)",
            "        except exception.StorageQuotaFull:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.info(_LI('Cleaning up %s after exceeding the quota.')",
            "                         % self.image.image_id)",
            "                self.store_utils.safe_delete_from_backend(",
            "                    self.context, self.image.image_id, self.image.locations[0])",
            "",
            "    @property",
            "    def tags(self):",
            "        return QuotaImageTagsProxy(self.image.tags)",
            "",
            "    @tags.setter",
            "    def tags(self, value):",
            "        _enforce_image_tag_quota(value)",
            "        self.image.tags = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return QuotaImageLocationsProxy(self.image,",
            "                                        self.context,",
            "                                        self.db_api)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        _enforce_image_location_quota(self.image, value, is_setter=True)",
            "",
            "        if not isinstance(value, (list, QuotaImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            value)",
            "",
            "        glance.api.common.check_quota(",
            "            self.context, required_size, self.db_api,",
            "            image_id=self.image.image_id)",
            "        self.image.locations = value",
            "",
            "    def added_new_properties(self):",
            "        current_props = set(self.image.extra_properties.keys())",
            "        return bool(current_props.difference(self.orig_props))"
        ],
        "afterPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "import glance_store as store",
            "from oslo.config import cfg",
            "from oslo.utils import excutils",
            "import six",
            "",
            "import glance.api.common",
            "import glance.common.exception as exception",
            "from glance.common import utils",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance import i18n",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "_ = i18n._",
            "_LI = i18n._LI",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_member_quota', 'glance.common.config')",
            "CONF.import_opt('image_property_quota', 'glance.common.config')",
            "CONF.import_opt('image_tag_quota', 'glance.common.config')",
            "",
            "",
            "def _enforce_image_tag_quota(tags):",
            "    if CONF.image_tag_quota < 0:",
            "        # If value is negative, allow unlimited number of tags",
            "        return",
            "",
            "    if not tags:",
            "        return",
            "",
            "    if len(tags) > CONF.image_tag_quota:",
            "        raise exception.ImageTagLimitExceeded(attempted=len(tags),",
            "                                              maximum=CONF.image_tag_quota)",
            "",
            "",
            "def _calc_required_size(context, image, locations):",
            "    required_size = None",
            "    if image.size:",
            "        required_size = image.size * len(locations)",
            "    else:",
            "        for location in locations:",
            "            size_from_backend = None",
            "            try:",
            "                size_from_backend = store.get_size_from_backend(",
            "                    location['url'], context=context)",
            "            except (store.UnknownScheme, store.NotFound):",
            "                pass",
            "            if size_from_backend:",
            "                required_size = size_from_backend * len(locations)",
            "                break",
            "    return required_size",
            "",
            "",
            "def _enforce_image_location_quota(image, locations, is_setter=False):",
            "    if CONF.image_location_quota < 0:",
            "        # If value is negative, allow unlimited number of locations",
            "        return",
            "",
            "    attempted = len(image.locations) + len(locations)",
            "    attempted = attempted if not is_setter else len(locations)",
            "    maximum = CONF.image_location_quota",
            "    if attempted > maximum:",
            "        raise exception.ImageLocationLimitExceeded(attempted=attempted,",
            "                                                   maximum=maximum)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, db_api, store_utils):",
            "        self.image_repo = image_repo",
            "        self.db_api = db_api",
            "        proxy_kwargs = {'context': context, 'db_api': db_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _enforce_image_property_quota(self, attempted):",
            "        if CONF.image_property_quota < 0:",
            "            # If value is negative, allow unlimited number of properties",
            "            return",
            "",
            "        maximum = CONF.image_property_quota",
            "        if attempted > maximum:",
            "            kwargs = {'attempted': attempted, 'maximum': maximum}",
            "            exc = exception.ImagePropertyLimitExceeded(**kwargs)",
            "            LOG.debug(six.text_type(exc))",
            "            raise exc",
            "",
            "    def save(self, image, from_state=None):",
            "        if image.added_new_properties():",
            "            self._enforce_image_property_quota(len(image.extra_properties))",
            "        return super(ImageRepoProxy, self).save(image, from_state=from_state)",
            "",
            "    def add(self, image):",
            "        self._enforce_image_property_quota(len(image.extra_properties))",
            "        return super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, db_api, store_utils):",
            "        proxy_kwargs = {'context': context, 'db_api': db_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        tags = kwargs.pop('tags', set([]))",
            "        _enforce_image_tag_quota(tags)",
            "        return super(ImageFactoryProxy, self).new_image(tags=tags, **kwargs)",
            "",
            "",
            "class QuotaImageTagsProxy(object):",
            "",
            "    def __init__(self, orig_set):",
            "        if orig_set is None:",
            "            orig_set = set([])",
            "        self.tags = orig_set",
            "",
            "    def add(self, item):",
            "        self.tags.add(item)",
            "        _enforce_image_tag_quota(self.tags)",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.tags.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.tags.__contains__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.tags == other",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.tags.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.tags.__len__(*args, **kwargs)",
            "",
            "    def __getattr__(self, name):",
            "        return getattr(self.tags, name)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, db_api, store_utils):",
            "        self.db_api = db_api",
            "        self.context = context",
            "        proxy_kwargs = {'context': context, 'db_api': db_api,",
            "                        'store_utils': store_utils}",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _enforce_image_member_quota(self, image):",
            "        if CONF.image_member_quota < 0:",
            "            # If value is negative, allow unlimited number of members",
            "            return",
            "",
            "        current_member_count = self.db_api.image_member_count(self.context,",
            "                                                              image.image_id)",
            "        attempted = current_member_count + 1",
            "        maximum = CONF.image_member_quota",
            "        if attempted > maximum:",
            "            raise exception.ImageMemberLimitExceeded(attempted=attempted,",
            "                                                     maximum=maximum)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self._enforce_image_member_quota(image)",
            "        return super(ImageMemberFactoryProxy, self).new_image_member(image,",
            "                                                                     member_id)",
            "",
            "",
            "class QuotaImageLocationsProxy(object):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.locations = image.locations",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.locations.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.locations.__contains__(*args, **kwargs)",
            "",
            "    def __delitem__(self, *args, **kwargs):",
            "        return self.locations.__delitem__(*args, **kwargs)",
            "",
            "    def __delslice__(self, *args, **kwargs):",
            "        return self.locations.__delslice__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.locations == other",
            "",
            "    def __getitem__(self, *args, **kwargs):",
            "        return self.locations.__getitem__(*args, **kwargs)",
            "",
            "    def __iadd__(self, other):",
            "        if not hasattr(other, '__iter__'):",
            "            raise TypeError()",
            "        self._check_user_storage_quota(other)",
            "        return self.locations.__iadd__(other)",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.locations.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.locations.__len__(*args, **kwargs)",
            "",
            "    def __setitem__(self, key, value):",
            "        return self.locations.__setitem__(key, value)",
            "",
            "    def count(self, *args, **kwargs):",
            "        return self.locations.count(*args, **kwargs)",
            "",
            "    def index(self, *args, **kwargs):",
            "        return self.locations.index(*args, **kwargs)",
            "",
            "    def pop(self, *args, **kwargs):",
            "        return self.locations.pop(*args, **kwargs)",
            "",
            "    def remove(self, *args, **kwargs):",
            "        return self.locations.remove(*args, **kwargs)",
            "",
            "    def reverse(self, *args, **kwargs):",
            "        return self.locations.reverse(*args, **kwargs)",
            "",
            "    def _check_user_storage_quota(self, locations):",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            locations)",
            "        glance.api.common.check_quota(self.context,",
            "                                      required_size,",
            "                                      self.db_api)",
            "        _enforce_image_location_quota(self.image, locations)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        self.image.locations = copy.deepcopy(self.locations, memo)",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def append(self, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.append(object)",
            "",
            "    def insert(self, index, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.insert(index, object)",
            "",
            "    def extend(self, iter):",
            "        self._check_user_storage_quota(iter)",
            "        return self.locations.extend(iter)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api, store_utils):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.store_utils = store_utils",
            "        super(ImageProxy, self).__init__(image)",
            "        self.orig_props = set(image.extra_properties.keys())",
            "",
            "    def set_data(self, data, size=None):",
            "        remaining = glance.api.common.check_quota(",
            "            self.context, size, self.db_api, image_id=self.image.image_id)",
            "        if remaining is not None:",
            "            # NOTE(jbresnah) we are trying to enforce a quota, put a limit",
            "            # reader on the data",
            "            data = utils.LimitingReader(data, remaining)",
            "        try:",
            "            self.image.set_data(data, size=size)",
            "        except exception.ImageSizeLimitExceeded:",
            "            raise exception.StorageQuotaFull(image_size=size,",
            "                                             remaining=remaining)",
            "",
            "        # NOTE(jbresnah) If two uploads happen at the same time and neither",
            "        # properly sets the size attribute[1] then there is a race condition",
            "        # that will allow for the quota to be broken[2].  Thus we must recheck",
            "        # the quota after the upload and thus after we know the size.",
            "        #",
            "        # Also, when an upload doesn't set the size properly then the call to",
            "        # check_quota above returns None and so utils.LimitingReader is not",
            "        # used above. Hence the store (e.g.  filesystem store) may have to",
            "        # download the entire file before knowing the actual file size.  Here",
            "        # also we need to check for the quota again after the image has been",
            "        # downloaded to the store.",
            "        #",
            "        # [1] For e.g. when using chunked transfers the 'Content-Length'",
            "        #     header is not set.",
            "        # [2] For e.g.:",
            "        #       - Upload 1 does not exceed quota but upload 2 exceeds quota.",
            "        #         Both uploads are to different locations",
            "        #       - Upload 2 completes before upload 1 and writes image.size.",
            "        #       - Immediately, upload 1 completes and (over)writes image.size",
            "        #         with the smaller size.",
            "        #       - Now, to glance, image has not exceeded quota but, in",
            "        #         reality, the quota has been exceeded.",
            "",
            "        try:",
            "            glance.api.common.check_quota(",
            "                self.context, self.image.size, self.db_api,",
            "                image_id=self.image.image_id)",
            "        except exception.StorageQuotaFull:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.info(_LI('Cleaning up %s after exceeding the quota.')",
            "                         % self.image.image_id)",
            "                self.store_utils.safe_delete_from_backend(",
            "                    self.context, self.image.image_id, self.image.locations[0])",
            "",
            "    @property",
            "    def tags(self):",
            "        return QuotaImageTagsProxy(self.image.tags)",
            "",
            "    @tags.setter",
            "    def tags(self, value):",
            "        _enforce_image_tag_quota(value)",
            "        self.image.tags = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return QuotaImageLocationsProxy(self.image,",
            "                                        self.context,",
            "                                        self.db_api)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        _enforce_image_location_quota(self.image, value, is_setter=True)",
            "",
            "        if not isinstance(value, (list, QuotaImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            value)",
            "",
            "        glance.api.common.check_quota(",
            "            self.context, required_size, self.db_api,",
            "            image_id=self.image.image_id)",
            "        self.image.locations = value",
            "",
            "    def added_new_properties(self):",
            "        current_props = set(self.image.extra_properties.keys())",
            "        return bool(current_props.difference(self.orig_props))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "107": [
                "ImageRepoProxy",
                "save"
            ],
            "110": [
                "ImageRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_domain_proxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         self._test_method('add', 'snuff', 'enough')"
            },
            "1": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     def test_save(self):"
            },
            "3": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._test_method('save', 'snuff', 'enough')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        self._test_method('save', 'snuff', 'enough', from_state=None)"
            },
            "5": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     def test_remove(self):"
            },
            "7": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         self._test_method('add', None, 'flying')"
            },
            "8": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "             self.assertEqual(tuple(), results[i].args)"
            },
            "9": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "             self.assertEqual({'a': 1}, results[i].kwargs)"
            },
            "10": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _test_method_with_proxied_argument(self, name, result):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    def _test_method_with_proxied_argument(self, name, result, **kwargs):"
            },
            "13": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         self.fake_repo.result = result"
            },
            "14": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         item = FakeProxy('snoop')"
            },
            "15": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         method = getattr(self.proxy_repo, name)"
            },
            "16": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         proxy_result = method(item)"
            },
            "17": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         self.assertEqual(('snoop',), self.fake_repo.args)"
            },
            "19": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual({}, self.fake_repo.kwargs)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        self.assertEqual(kwargs, self.fake_repo.kwargs)"
            },
            "21": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         if result is None:"
            },
            "23": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             self.assertIsNone(proxy_result)"
            },
            "24": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         self._test_method_with_proxied_argument('add', None)"
            },
            "25": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     def test_save(self):"
            },
            "27": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._test_method_with_proxied_argument('save', 'dog')"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        self._test_method_with_proxied_argument('save', 'dog',"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                                                from_state=None)"
            },
            "30": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     def test_save_with_no_result(self):"
            },
            "32": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._test_method_with_proxied_argument('save', None)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        self._test_method_with_proxied_argument('save', None,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                                                from_state=None)"
            },
            "35": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     def test_remove(self):"
            },
            "37": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         self._test_method_with_proxied_argument('remove', 'dog')"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation.",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from six.moves import xrange",
            "",
            "from glance.domain import proxy",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "",
            "",
            "class FakeProxy(object):",
            "    def __init__(self, base, *args, **kwargs):",
            "        self.base = base",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "",
            "",
            "class FakeRepo(object):",
            "    def __init__(self, result=None):",
            "        self.args = None",
            "        self.kwargs = None",
            "        self.result = result",
            "",
            "    def fake_method(self, *args, **kwargs):",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "    get = fake_method",
            "    list = fake_method",
            "    add = fake_method",
            "    save = fake_method",
            "    remove = fake_method",
            "",
            "",
            "class TestProxyRepoPlain(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoPlain, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo)",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertEqual(base_result, proxy_result)",
            "        self.assertEqual(args, self.fake_repo.args)",
            "        self.assertEqual(kwargs, self.fake_repo.kwargs)",
            "",
            "    def test_get(self):",
            "        self._test_method('get', 'snarf', 'abcd')",
            "",
            "    def test_list(self):",
            "        self._test_method('list', ['sniff', 'snarf'], 2, filter='^sn')",
            "",
            "    def test_add(self):",
            "        self._test_method('add', 'snuff', 'enough')",
            "",
            "    def test_save(self):",
            "        self._test_method('save', 'snuff', 'enough')",
            "",
            "    def test_remove(self):",
            "        self._test_method('add', None, 'flying')",
            "",
            "",
            "class TestProxyRepoWrapping(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoWrapping, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo,",
            "                                     item_proxy_class=FakeProxy,",
            "                                     item_proxy_kwargs={'a': 1})",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertIsInstance(proxy_result, FakeProxy)",
            "        self.assertEqual(base_result, proxy_result.base)",
            "        self.assertEqual(0, len(proxy_result.args))",
            "        self.assertEqual({'a': 1}, proxy_result.kwargs)",
            "        self.assertEqual(args, self.fake_repo.args)",
            "        self.assertEqual(kwargs, self.fake_repo.kwargs)",
            "",
            "    def test_get(self):",
            "        self.fake_repo.result = 'snarf'",
            "        result = self.proxy_repo.get('some-id')",
            "        self.assertIsInstance(result, FakeProxy)",
            "        self.assertEqual(('some-id',), self.fake_repo.args)",
            "        self.assertEqual({}, self.fake_repo.kwargs)",
            "        self.assertEqual('snarf', result.base)",
            "        self.assertEqual(tuple(), result.args)",
            "        self.assertEqual({'a': 1}, result.kwargs)",
            "",
            "    def test_list(self):",
            "        self.fake_repo.result = ['scratch', 'sniff']",
            "        results = self.proxy_repo.list(2, prefix='s')",
            "        self.assertEqual((2,), self.fake_repo.args)",
            "        self.assertEqual({'prefix': 's'}, self.fake_repo.kwargs)",
            "        self.assertEqual(2, len(results))",
            "        for i in xrange(2):",
            "            self.assertIsInstance(results[i], FakeProxy)",
            "            self.assertEqual(self.fake_repo.result[i], results[i].base)",
            "            self.assertEqual(tuple(), results[i].args)",
            "            self.assertEqual({'a': 1}, results[i].kwargs)",
            "",
            "    def _test_method_with_proxied_argument(self, name, result):",
            "        self.fake_repo.result = result",
            "        item = FakeProxy('snoop')",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(item)",
            "",
            "        self.assertEqual(('snoop',), self.fake_repo.args)",
            "        self.assertEqual({}, self.fake_repo.kwargs)",
            "",
            "        if result is None:",
            "            self.assertIsNone(proxy_result)",
            "        else:",
            "            self.assertIsInstance(proxy_result, FakeProxy)",
            "            self.assertEqual(result, proxy_result.base)",
            "            self.assertEqual(tuple(), proxy_result.args)",
            "            self.assertEqual({'a': 1}, proxy_result.kwargs)",
            "",
            "    def test_add(self):",
            "        self._test_method_with_proxied_argument('add', 'dog')",
            "",
            "    def test_add_with_no_result(self):",
            "        self._test_method_with_proxied_argument('add', None)",
            "",
            "    def test_save(self):",
            "        self._test_method_with_proxied_argument('save', 'dog')",
            "",
            "    def test_save_with_no_result(self):",
            "        self._test_method_with_proxied_argument('save', None)",
            "",
            "    def test_remove(self):",
            "        self._test_method_with_proxied_argument('remove', 'dog')",
            "",
            "    def test_remove_with_no_result(self):",
            "        self._test_method_with_proxied_argument('remove', None)",
            "",
            "",
            "class FakeImageFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.kwargs = None",
            "",
            "    def new_image(self, **kwargs):",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "",
            "class TestImageFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.factory = FakeImageFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory)",
            "        self.factory.result = 'eddard'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertEqual('eddard', image)",
            "        self.assertEqual({'a': 1, 'b': 'two'}, self.factory.kwargs)",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory,",
            "                                           proxy_class=FakeProxy,",
            "                                           proxy_kwargs={'dog': 'bark'})",
            "        self.factory.result = 'stark'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertIsInstance(image, FakeProxy)",
            "        self.assertEqual('stark', image.base)",
            "        self.assertEqual({'a': 1, 'b': 'two'}, self.factory.kwargs)",
            "",
            "",
            "class FakeImageMembershipFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.image = None",
            "        self.member_id = None",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self.image = image",
            "        self.member_id = member_id",
            "        return self.result",
            "",
            "",
            "class TestImageMembershipFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMembershipFactory, self).setUp()",
            "        self.factory = FakeImageMembershipFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(self.factory)",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertEqual('tyrion', membership)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "    def test_proxy_wrapped_membership(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'a': 1})",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual('tyrion', membership.base)",
            "        self.assertEqual({'a': 1}, membership.kwargs)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "    def test_proxy_wrapped_image(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, image_proxy_class=FakeProxy)",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertEqual('tyrion', membership)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "    def test_proxy_both_wrapped(self):",
            "        class FakeProxy2(FakeProxy):",
            "            pass",
            "",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory,",
            "            member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'b': 2},",
            "            image_proxy_class=FakeProxy2)",
            "",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy2('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual('tyrion', membership.base)",
            "        self.assertEqual({'b': 2}, membership.kwargs)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "",
            "class FakeImage(object):",
            "    def __init__(self, result=None):",
            "        self.result = result",
            "",
            "    def get_member_repo(self):",
            "        return self.result",
            "",
            "",
            "class TestImage(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImage, self).setUp()",
            "        self.image = FakeImage()",
            "",
            "    def test_normal_member_repo(self):",
            "        proxy_image = proxy.Image(self.image)",
            "        self.image.result = 'mormont'",
            "        self.assertEqual('mormont', proxy_image.get_member_repo())",
            "",
            "    def test_proxied_member_repo(self):",
            "        proxy_image = proxy.Image(self.image,",
            "                                  member_repo_proxy_class=FakeProxy,",
            "                                  member_repo_proxy_kwargs={'a': 10})",
            "        self.image.result = 'corn'",
            "        member_repo = proxy_image.get_member_repo()",
            "        self.assertIsInstance(member_repo, FakeProxy)",
            "        self.assertEqual('corn', member_repo.base)",
            "",
            "",
            "class TestTaskFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestTaskFactory, self).setUp()",
            "        self.factory = mock.Mock()",
            "        self.fake_type = 'import'",
            "        self.fake_owner = \"owner\"",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.TaskFactory(self.factory)",
            "",
            "        proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.TaskFactory(",
            "            self.factory,",
            "            task_proxy_class=FakeProxy,",
            "            task_proxy_kwargs={'dog': 'bark'})",
            "",
            "        self.factory.new_task.return_value = 'fake_task'",
            "",
            "        task = proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "        self.assertIsInstance(task, FakeProxy)",
            "        self.assertEqual('fake_task', task.base)"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation.",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from six.moves import xrange",
            "",
            "from glance.domain import proxy",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "",
            "",
            "class FakeProxy(object):",
            "    def __init__(self, base, *args, **kwargs):",
            "        self.base = base",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "",
            "",
            "class FakeRepo(object):",
            "    def __init__(self, result=None):",
            "        self.args = None",
            "        self.kwargs = None",
            "        self.result = result",
            "",
            "    def fake_method(self, *args, **kwargs):",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "    get = fake_method",
            "    list = fake_method",
            "    add = fake_method",
            "    save = fake_method",
            "    remove = fake_method",
            "",
            "",
            "class TestProxyRepoPlain(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoPlain, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo)",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertEqual(base_result, proxy_result)",
            "        self.assertEqual(args, self.fake_repo.args)",
            "        self.assertEqual(kwargs, self.fake_repo.kwargs)",
            "",
            "    def test_get(self):",
            "        self._test_method('get', 'snarf', 'abcd')",
            "",
            "    def test_list(self):",
            "        self._test_method('list', ['sniff', 'snarf'], 2, filter='^sn')",
            "",
            "    def test_add(self):",
            "        self._test_method('add', 'snuff', 'enough')",
            "",
            "    def test_save(self):",
            "        self._test_method('save', 'snuff', 'enough', from_state=None)",
            "",
            "    def test_remove(self):",
            "        self._test_method('add', None, 'flying')",
            "",
            "",
            "class TestProxyRepoWrapping(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoWrapping, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo,",
            "                                     item_proxy_class=FakeProxy,",
            "                                     item_proxy_kwargs={'a': 1})",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertIsInstance(proxy_result, FakeProxy)",
            "        self.assertEqual(base_result, proxy_result.base)",
            "        self.assertEqual(0, len(proxy_result.args))",
            "        self.assertEqual({'a': 1}, proxy_result.kwargs)",
            "        self.assertEqual(args, self.fake_repo.args)",
            "        self.assertEqual(kwargs, self.fake_repo.kwargs)",
            "",
            "    def test_get(self):",
            "        self.fake_repo.result = 'snarf'",
            "        result = self.proxy_repo.get('some-id')",
            "        self.assertIsInstance(result, FakeProxy)",
            "        self.assertEqual(('some-id',), self.fake_repo.args)",
            "        self.assertEqual({}, self.fake_repo.kwargs)",
            "        self.assertEqual('snarf', result.base)",
            "        self.assertEqual(tuple(), result.args)",
            "        self.assertEqual({'a': 1}, result.kwargs)",
            "",
            "    def test_list(self):",
            "        self.fake_repo.result = ['scratch', 'sniff']",
            "        results = self.proxy_repo.list(2, prefix='s')",
            "        self.assertEqual((2,), self.fake_repo.args)",
            "        self.assertEqual({'prefix': 's'}, self.fake_repo.kwargs)",
            "        self.assertEqual(2, len(results))",
            "        for i in xrange(2):",
            "            self.assertIsInstance(results[i], FakeProxy)",
            "            self.assertEqual(self.fake_repo.result[i], results[i].base)",
            "            self.assertEqual(tuple(), results[i].args)",
            "            self.assertEqual({'a': 1}, results[i].kwargs)",
            "",
            "    def _test_method_with_proxied_argument(self, name, result, **kwargs):",
            "        self.fake_repo.result = result",
            "        item = FakeProxy('snoop')",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(item)",
            "",
            "        self.assertEqual(('snoop',), self.fake_repo.args)",
            "        self.assertEqual(kwargs, self.fake_repo.kwargs)",
            "",
            "        if result is None:",
            "            self.assertIsNone(proxy_result)",
            "        else:",
            "            self.assertIsInstance(proxy_result, FakeProxy)",
            "            self.assertEqual(result, proxy_result.base)",
            "            self.assertEqual(tuple(), proxy_result.args)",
            "            self.assertEqual({'a': 1}, proxy_result.kwargs)",
            "",
            "    def test_add(self):",
            "        self._test_method_with_proxied_argument('add', 'dog')",
            "",
            "    def test_add_with_no_result(self):",
            "        self._test_method_with_proxied_argument('add', None)",
            "",
            "    def test_save(self):",
            "        self._test_method_with_proxied_argument('save', 'dog',",
            "                                                from_state=None)",
            "",
            "    def test_save_with_no_result(self):",
            "        self._test_method_with_proxied_argument('save', None,",
            "                                                from_state=None)",
            "",
            "    def test_remove(self):",
            "        self._test_method_with_proxied_argument('remove', 'dog')",
            "",
            "    def test_remove_with_no_result(self):",
            "        self._test_method_with_proxied_argument('remove', None)",
            "",
            "",
            "class FakeImageFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.kwargs = None",
            "",
            "    def new_image(self, **kwargs):",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "",
            "class TestImageFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.factory = FakeImageFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory)",
            "        self.factory.result = 'eddard'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertEqual('eddard', image)",
            "        self.assertEqual({'a': 1, 'b': 'two'}, self.factory.kwargs)",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory,",
            "                                           proxy_class=FakeProxy,",
            "                                           proxy_kwargs={'dog': 'bark'})",
            "        self.factory.result = 'stark'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertIsInstance(image, FakeProxy)",
            "        self.assertEqual('stark', image.base)",
            "        self.assertEqual({'a': 1, 'b': 'two'}, self.factory.kwargs)",
            "",
            "",
            "class FakeImageMembershipFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.image = None",
            "        self.member_id = None",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self.image = image",
            "        self.member_id = member_id",
            "        return self.result",
            "",
            "",
            "class TestImageMembershipFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMembershipFactory, self).setUp()",
            "        self.factory = FakeImageMembershipFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(self.factory)",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertEqual('tyrion', membership)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "    def test_proxy_wrapped_membership(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'a': 1})",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual('tyrion', membership.base)",
            "        self.assertEqual({'a': 1}, membership.kwargs)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "    def test_proxy_wrapped_image(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, image_proxy_class=FakeProxy)",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertEqual('tyrion', membership)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "    def test_proxy_both_wrapped(self):",
            "        class FakeProxy2(FakeProxy):",
            "            pass",
            "",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory,",
            "            member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'b': 2},",
            "            image_proxy_class=FakeProxy2)",
            "",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy2('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual('tyrion', membership.base)",
            "        self.assertEqual({'b': 2}, membership.kwargs)",
            "        self.assertEqual('jaime', self.factory.image)",
            "        self.assertEqual('cersei', self.factory.member_id)",
            "",
            "",
            "class FakeImage(object):",
            "    def __init__(self, result=None):",
            "        self.result = result",
            "",
            "    def get_member_repo(self):",
            "        return self.result",
            "",
            "",
            "class TestImage(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImage, self).setUp()",
            "        self.image = FakeImage()",
            "",
            "    def test_normal_member_repo(self):",
            "        proxy_image = proxy.Image(self.image)",
            "        self.image.result = 'mormont'",
            "        self.assertEqual('mormont', proxy_image.get_member_repo())",
            "",
            "    def test_proxied_member_repo(self):",
            "        proxy_image = proxy.Image(self.image,",
            "                                  member_repo_proxy_class=FakeProxy,",
            "                                  member_repo_proxy_kwargs={'a': 10})",
            "        self.image.result = 'corn'",
            "        member_repo = proxy_image.get_member_repo()",
            "        self.assertIsInstance(member_repo, FakeProxy)",
            "        self.assertEqual('corn', member_repo.base)",
            "",
            "",
            "class TestTaskFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestTaskFactory, self).setUp()",
            "        self.factory = mock.Mock()",
            "        self.fake_type = 'import'",
            "        self.fake_owner = \"owner\"",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.TaskFactory(self.factory)",
            "",
            "        proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.TaskFactory(",
            "            self.factory,",
            "            task_proxy_class=FakeProxy,",
            "            task_proxy_kwargs={'dog': 'bark'})",
            "",
            "        self.factory.new_task.return_value = 'fake_task'",
            "",
            "        task = proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "        self.assertIsInstance(task, FakeProxy)",
            "        self.assertEqual('fake_task', task.base)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "77": [
                "TestProxyRepoPlain",
                "test_save"
            ],
            "124": [
                "TestProxyRepoWrapping",
                "_test_method_with_proxied_argument"
            ],
            "131": [
                "TestProxyRepoWrapping",
                "_test_method_with_proxied_argument"
            ],
            "148": [
                "TestProxyRepoWrapping",
                "test_save"
            ],
            "151": [
                "TestProxyRepoWrapping",
                "test_save_with_no_result"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_policy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     def get(self, *args, **kwargs):"
            },
            "1": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         return 'member_repo_get'"
            },
            "2": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image_member):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    def save(self, image_member, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         image_member.output = 'member_repo_save'"
            },
            "6": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     def list(self, *args, **kwargs):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os.path",
            "",
            "import mock",
            "import oslo.config.cfg",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "import glance.context",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def get(self, *args, **kwargs):",
            "        return 'image_from_get'",
            "",
            "    def save(self, *args, **kwargs):",
            "        return 'image_from_save'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'image_from_add'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return ['image_from_list_0', 'image_from_list_1']",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id=None, visibility='private',",
            "                 container_format='bear', disk_format='raw',",
            "                 status='active', extra_properties=None):",
            "",
            "        if extra_properties is None:",
            "            extra_properties = {}",
            "",
            "        self.image_id = image_id",
            "        self.visibility = visibility",
            "        self.container_format = container_format",
            "        self.disk_format = disk_format",
            "        self.status = status",
            "        self.extra_properties = extra_properties",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        self.visibility = visibility",
            "        return 'new_image'",
            "",
            "",
            "class MemberRepoStub(object):",
            "    def add(self, image_member):",
            "        image_member.output = 'member_repo_add'",
            "",
            "    def get(self, *args, **kwargs):",
            "        return 'member_repo_get'",
            "",
            "    def save(self, image_member):",
            "        image_member.output = 'member_repo_save'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return 'member_repo_list'",
            "",
            "    def remove(self, image_member):",
            "        image_member.output = 'member_repo_remove'",
            "",
            "",
            "class ImageMembershipStub(object):",
            "    def __init__(self, output=None):",
            "        self.output = output",
            "",
            "",
            "class TaskRepoStub(object):",
            "    def get(self, *args, **kwargs):",
            "        return 'task_from_get'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'task_from_add'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return ['task_from_list_0', 'task_from_list_1']",
            "",
            "",
            "class TaskStub(object):",
            "    def __init__(self, task_id):",
            "        self.task_id = task_id",
            "        self.status = 'pending'",
            "",
            "    def run(self, executor):",
            "        self.status = 'processing'",
            "",
            "",
            "class TaskFactoryStub(object):",
            "    def new_task(self, *args):",
            "        return 'new_task'",
            "",
            "",
            "class TestPolicyEnforcer(base.IsolatedUnitTest):",
            "    def test_policy_file_default_rules_default_location(self):",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_rules_default_location(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_location(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_check(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertEqual(False, enforcer.check(context, 'get_image', {}))",
            "",
            "",
            "class TestPolicyEnforcerNoFile(base.IsolatedUnitTest):",
            "    def test_policy_file_specified_but_not_found(self):",
            "        \"\"\"Missing defined policy file should result in a default ruleset\"\"\"",
            "        self.config(policy_file='gobble.gobble')",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "    def test_policy_file_default_not_found(self):",
            "        \"\"\"Missing default policy file should result in a default ruleset\"\"\"",
            "        def fake_find_file(self, name):",
            "            return None",
            "",
            "        self.stubs.Set(oslo.config.cfg.ConfigOpts, 'find_file',",
            "                       fake_find_file)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "",
            "class TestImagePolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_factory_stub = ImageFactoryStub()",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        super(TestImagePolicy, self).setUp()",
            "",
            "    def test_publicize_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden,",
            "                          setattr, image, 'visibility', 'public')",
            "        self.assertEqual('private', image.visibility)",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_publicize_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.visibility = 'public'",
            "        self.assertEqual('public', image.visibility)",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_delete_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.delete)",
            "        self.assertEqual('active', image.status)",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_delete_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.delete()",
            "        self.assertEqual('deleted', image.status)",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_get_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.get, UUID1)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        output = image_repo.get(UUID1)",
            "        self.assertIsInstance(output, glance.api.policy.ImageProxy)",
            "        self.assertEqual('image_from_get', output.image)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_images_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.list)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_get_images_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        images = image_repo.list()",
            "        for i, image in enumerate(images):",
            "            self.assertIsInstance(image, glance.api.policy.ImageProxy)",
            "            self.assertEqual('image_from_list_%d' % i, image.image)",
            "            self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_modify_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.save, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_modify_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.save(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_add_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.add, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_add_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.add(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_new_image_visibility(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_factory.new_image,",
            "                          visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_new_image_visibility_public_allowed(self):",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        image_factory.new_image(visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_image_get_data_policy_enforced_with_target(self):",
            "        extra_properties = {",
            "            'test_key': 'test_4321'",
            "        }",
            "        image_stub = ImageStub(UUID1, extra_properties=extra_properties)",
            "        image = glance.api.policy.ImageProxy(image_stub, {}, self.policy)",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        glance.api.policy.ImageTarget = mock.Mock()",
            "        target = glance.api.policy.ImageTarget(image)",
            "",
            "        self.assertRaises(exception.Forbidden, image.get_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"download_image\",",
            "                                                    target=target)",
            "",
            "    def test_image_set_data(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.set_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"upload_image\", {})",
            "",
            "",
            "class TestMemberPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        self.member_repo = glance.api.policy.ImageMemberRepoProxy(",
            "            MemberRepoStub(), {}, self.policy)",
            "        super(TestMemberPolicy, self).setUp()",
            "",
            "    def test_add_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.add, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_add_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.add(image_member)",
            "        self.assertEqual('member_repo_add', image_member.output)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_get_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.get, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_get_member_allowed(self):",
            "        output = self.member_repo.get('')",
            "        self.assertEqual('member_repo_get', output)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_modify_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.save, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_modify_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.save(image_member)",
            "        self.assertEqual('member_repo_save', image_member.output)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_get_members_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.list, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_get_members_allowed(self):",
            "        output = self.member_repo.list('')",
            "        self.assertEqual('member_repo_list', output)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_delete_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.remove, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "    def test_delete_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.remove(image_member)",
            "        self.assertEqual('member_repo_remove', image_member.output)",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "",
            "class TestTaskPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.task_stub = TaskStub(UUID1)",
            "        self.task_repo_stub = TaskRepoStub()",
            "        self.task_factory_stub = TaskFactoryStub()",
            "        self.policy = unit_test_utils.FakePolicyEnforcer()",
            "        super(TestTaskPolicy, self).setUp()",
            "",
            "    def test_get_task_not_allowed(self):",
            "        rules = {\"get_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden,",
            "                          task_repo.get,",
            "                          UUID1)",
            "",
            "    def test_get_task_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = task_repo.get(UUID1)",
            "        self.assertIsInstance(task, glance.api.policy.TaskProxy)",
            "        self.assertEqual('task_from_get', task.task)",
            "",
            "    def test_get_tasks_not_allowed(self):",
            "        rules = {\"get_tasks\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskStubRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden, task_repo.list)",
            "",
            "    def test_get_tasks_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskStubRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        tasks = task_repo.list()",
            "        for i, task in enumerate(tasks):",
            "            self.assertIsInstance(task, glance.api.policy.TaskStubProxy)",
            "            self.assertEqual('task_from_list_%d' % i, task.task_stub)",
            "",
            "    def test_add_task_not_allowed(self):",
            "        rules = {\"add_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, task_repo.add, task)",
            "",
            "    def test_add_task_allowed(self):",
            "        rules = {\"add_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        task_repo.add(task)",
            "",
            "",
            "class TestContextPolicyEnforcer(base.IsolatedUnitTest):",
            "    def _do_test_policy_influence_context_admin(self,",
            "                                                policy_admin_role,",
            "                                                context_role,",
            "                                                context_is_admin,",
            "                                                admin_expected):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {'context_is_admin': 'role:%s' % policy_admin_role}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[context_role],",
            "                                                is_admin=context_is_admin,",
            "                                                policy_enforcer=enforcer)",
            "        self.assertEqual(admin_expected, context.is_admin)",
            "",
            "    def test_context_admin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     False,",
            "                                                     True)",
            "",
            "    def test_context_admin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     False,",
            "                                                     False)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os.path",
            "",
            "import mock",
            "import oslo.config.cfg",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "import glance.context",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def get(self, *args, **kwargs):",
            "        return 'image_from_get'",
            "",
            "    def save(self, *args, **kwargs):",
            "        return 'image_from_save'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'image_from_add'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return ['image_from_list_0', 'image_from_list_1']",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id=None, visibility='private',",
            "                 container_format='bear', disk_format='raw',",
            "                 status='active', extra_properties=None):",
            "",
            "        if extra_properties is None:",
            "            extra_properties = {}",
            "",
            "        self.image_id = image_id",
            "        self.visibility = visibility",
            "        self.container_format = container_format",
            "        self.disk_format = disk_format",
            "        self.status = status",
            "        self.extra_properties = extra_properties",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        self.visibility = visibility",
            "        return 'new_image'",
            "",
            "",
            "class MemberRepoStub(object):",
            "    def add(self, image_member):",
            "        image_member.output = 'member_repo_add'",
            "",
            "    def get(self, *args, **kwargs):",
            "        return 'member_repo_get'",
            "",
            "    def save(self, image_member, from_state=None):",
            "        image_member.output = 'member_repo_save'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return 'member_repo_list'",
            "",
            "    def remove(self, image_member):",
            "        image_member.output = 'member_repo_remove'",
            "",
            "",
            "class ImageMembershipStub(object):",
            "    def __init__(self, output=None):",
            "        self.output = output",
            "",
            "",
            "class TaskRepoStub(object):",
            "    def get(self, *args, **kwargs):",
            "        return 'task_from_get'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'task_from_add'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return ['task_from_list_0', 'task_from_list_1']",
            "",
            "",
            "class TaskStub(object):",
            "    def __init__(self, task_id):",
            "        self.task_id = task_id",
            "        self.status = 'pending'",
            "",
            "    def run(self, executor):",
            "        self.status = 'processing'",
            "",
            "",
            "class TaskFactoryStub(object):",
            "    def new_task(self, *args):",
            "        return 'new_task'",
            "",
            "",
            "class TestPolicyEnforcer(base.IsolatedUnitTest):",
            "    def test_policy_file_default_rules_default_location(self):",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_rules_default_location(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_location(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_check(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertEqual(False, enforcer.check(context, 'get_image', {}))",
            "",
            "",
            "class TestPolicyEnforcerNoFile(base.IsolatedUnitTest):",
            "    def test_policy_file_specified_but_not_found(self):",
            "        \"\"\"Missing defined policy file should result in a default ruleset\"\"\"",
            "        self.config(policy_file='gobble.gobble')",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "    def test_policy_file_default_not_found(self):",
            "        \"\"\"Missing default policy file should result in a default ruleset\"\"\"",
            "        def fake_find_file(self, name):",
            "            return None",
            "",
            "        self.stubs.Set(oslo.config.cfg.ConfigOpts, 'find_file',",
            "                       fake_find_file)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "",
            "class TestImagePolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_factory_stub = ImageFactoryStub()",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        super(TestImagePolicy, self).setUp()",
            "",
            "    def test_publicize_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden,",
            "                          setattr, image, 'visibility', 'public')",
            "        self.assertEqual('private', image.visibility)",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_publicize_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.visibility = 'public'",
            "        self.assertEqual('public', image.visibility)",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_delete_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.delete)",
            "        self.assertEqual('active', image.status)",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_delete_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.delete()",
            "        self.assertEqual('deleted', image.status)",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_get_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.get, UUID1)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        output = image_repo.get(UUID1)",
            "        self.assertIsInstance(output, glance.api.policy.ImageProxy)",
            "        self.assertEqual('image_from_get', output.image)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_images_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.list)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_get_images_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        images = image_repo.list()",
            "        for i, image in enumerate(images):",
            "            self.assertIsInstance(image, glance.api.policy.ImageProxy)",
            "            self.assertEqual('image_from_list_%d' % i, image.image)",
            "            self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_modify_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.save, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_modify_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.save(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_add_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.add, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_add_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.add(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_new_image_visibility(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_factory.new_image,",
            "                          visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_new_image_visibility_public_allowed(self):",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        image_factory.new_image(visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_image_get_data_policy_enforced_with_target(self):",
            "        extra_properties = {",
            "            'test_key': 'test_4321'",
            "        }",
            "        image_stub = ImageStub(UUID1, extra_properties=extra_properties)",
            "        image = glance.api.policy.ImageProxy(image_stub, {}, self.policy)",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        glance.api.policy.ImageTarget = mock.Mock()",
            "        target = glance.api.policy.ImageTarget(image)",
            "",
            "        self.assertRaises(exception.Forbidden, image.get_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"download_image\",",
            "                                                    target=target)",
            "",
            "    def test_image_set_data(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.set_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"upload_image\", {})",
            "",
            "",
            "class TestMemberPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        self.member_repo = glance.api.policy.ImageMemberRepoProxy(",
            "            MemberRepoStub(), {}, self.policy)",
            "        super(TestMemberPolicy, self).setUp()",
            "",
            "    def test_add_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.add, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_add_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.add(image_member)",
            "        self.assertEqual('member_repo_add', image_member.output)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_get_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.get, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_get_member_allowed(self):",
            "        output = self.member_repo.get('')",
            "        self.assertEqual('member_repo_get', output)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_modify_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.save, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_modify_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.save(image_member)",
            "        self.assertEqual('member_repo_save', image_member.output)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_get_members_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.list, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_get_members_allowed(self):",
            "        output = self.member_repo.list('')",
            "        self.assertEqual('member_repo_list', output)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_delete_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.remove, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "    def test_delete_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.remove(image_member)",
            "        self.assertEqual('member_repo_remove', image_member.output)",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "",
            "class TestTaskPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.task_stub = TaskStub(UUID1)",
            "        self.task_repo_stub = TaskRepoStub()",
            "        self.task_factory_stub = TaskFactoryStub()",
            "        self.policy = unit_test_utils.FakePolicyEnforcer()",
            "        super(TestTaskPolicy, self).setUp()",
            "",
            "    def test_get_task_not_allowed(self):",
            "        rules = {\"get_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden,",
            "                          task_repo.get,",
            "                          UUID1)",
            "",
            "    def test_get_task_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = task_repo.get(UUID1)",
            "        self.assertIsInstance(task, glance.api.policy.TaskProxy)",
            "        self.assertEqual('task_from_get', task.task)",
            "",
            "    def test_get_tasks_not_allowed(self):",
            "        rules = {\"get_tasks\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskStubRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden, task_repo.list)",
            "",
            "    def test_get_tasks_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskStubRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        tasks = task_repo.list()",
            "        for i, task in enumerate(tasks):",
            "            self.assertIsInstance(task, glance.api.policy.TaskStubProxy)",
            "            self.assertEqual('task_from_list_%d' % i, task.task_stub)",
            "",
            "    def test_add_task_not_allowed(self):",
            "        rules = {\"add_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, task_repo.add, task)",
            "",
            "    def test_add_task_allowed(self):",
            "        rules = {\"add_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        task_repo.add(task)",
            "",
            "",
            "class TestContextPolicyEnforcer(base.IsolatedUnitTest):",
            "    def _do_test_policy_influence_context_admin(self,",
            "                                                policy_admin_role,",
            "                                                context_role,",
            "                                                context_is_admin,",
            "                                                admin_expected):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {'context_is_admin': 'role:%s' % policy_admin_role}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[context_role],",
            "                                                is_admin=context_is_admin,",
            "                                                policy_enforcer=enforcer)",
            "        self.assertEqual(admin_expected, context.is_admin)",
            "",
            "    def test_context_admin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     False,",
            "                                                     True)",
            "",
            "    def test_context_admin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     False,",
            "                                                     False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "81": [
                "MemberRepoStub",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_quota.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "         self.image.extra_properties = {'foo': 'bar'}"
            },
            "1": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "2": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 368,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo_mock.save.assert_called_once_with(self.base_image)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+        self.image_repo_mock.save.assert_called_once_with(self.base_image,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+                                                          from_state=None)"
            },
            "6": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 371,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "     def test_save_image_too_many_image_properties(self):"
            },
            "8": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         self.config(image_property_quota=1)"
            },
            "9": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "         self.image.extra_properties = {'foo': 'bar'}"
            },
            "10": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "11": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 385,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo_mock.save.assert_called_once_with(self.base_image)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+        self.image_repo_mock.save.assert_called_once_with(self.base_image,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+                                                          from_state=None)"
            },
            "15": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 388,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "     def test_add_image_with_image_property(self):"
            },
            "17": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "         self.config(image_property_quota=1)"
            },
            "18": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "         self.config(image_property_quota=1)"
            },
            "19": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "         self.image.extra_properties = {'foo': 'frob', 'spam': 'eggs'}"
            },
            "20": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 425,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "21": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo_mock.save.assert_called_once_with(self.base_image)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+        self.image_repo_mock.save.assert_called_once_with(self.base_image,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+                                                          from_state=None)"
            },
            "24": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 428,
                "PatchRowcode": "         self.assertEqual('frob', self.base_image.extra_properties['foo'])"
            },
            "25": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 429,
                "PatchRowcode": "         self.assertEqual('eggs', self.base_image.extra_properties['spam'])"
            },
            "26": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 430,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "         self.config(image_property_quota=1)"
            },
            "28": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "         del self.image.extra_properties['foo']"
            },
            "29": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "30": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo_mock.save.assert_called_once_with(self.base_image)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+        self.image_repo_mock.save.assert_called_once_with(self.base_image,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+                                                          from_state=None)"
            },
            "33": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "         self.assertNotIn('foo', self.base_image.extra_properties)"
            },
            "34": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "         self.assertEqual('ham', self.base_image.extra_properties['spam'])"
            },
            "35": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 440,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "         del self.image.extra_properties['frob']"
            },
            "37": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "         del self.image.extra_properties['lorem']"
            },
            "38": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 458,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "39": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        call_args = mock.call(self.base_image)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+        call_args = mock.call(self.base_image, from_state=None)"
            },
            "41": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 460,
                "PatchRowcode": "         self.assertEqual(call_args, self.image_repo_mock.save.call_args)"
            },
            "42": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "         self.assertEqual('bar', self.base_image.extra_properties['foo'])"
            },
            "43": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "         self.assertEqual('ham', self.base_image.extra_properties['spam'])"
            },
            "44": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 475,
                "PatchRowcode": "         self.config(image_property_quota=1)"
            },
            "45": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 476,
                "PatchRowcode": "         del self.image.extra_properties['foo']"
            },
            "46": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": 477,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "47": {
                "beforePatchRowNumber": 474,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo_mock.save.assert_called_once_with(self.base_image)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        self.image_repo_mock.save.assert_called_once_with(self.base_image,"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+                                                          from_state=None)"
            },
            "50": {
                "beforePatchRowNumber": 475,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "         self.assertNotIn('foo', self.base_image.extra_properties)"
            },
            "51": {
                "beforePatchRowNumber": 476,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "         self.assertEqual('ham', self.base_image.extra_properties['spam'])"
            },
            "52": {
                "beforePatchRowNumber": 477,
                "afterPatchRowNumber": 482,
                "PatchRowcode": "         self.assertEqual('baz', self.base_image.extra_properties['frob'])"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import uuid",
            "",
            "import mock",
            "from mock import patch",
            "from oslo.utils import units",
            "import six",
            "",
            "from glance.common import exception",
            "from glance.common import store_utils",
            "import glance.quota",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class FakeContext(object):",
            "    owner = 'someone'",
            "    is_admin = False",
            "",
            "",
            "class FakeImage(object):",
            "    size = None",
            "    image_id = 'someid'",
            "    locations = [{'url': 'file:///not/a/path', 'metadata': {}}]",
            "    tags = set([])",
            "",
            "    def set_data(self, data, size=None):",
            "        self.size = 0",
            "        for d in data:",
            "            self.size += len(d)",
            "",
            "    def __init__(self, **kwargs):",
            "        self.extra_properties = kwargs.get('extra_properties', {})",
            "",
            "",
            "class TestImageQuota(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageQuota, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(TestImageQuota, self).tearDown()",
            "",
            "    def _get_image(self, location_count=1, image_size=10):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'xyz'",
            "        base_image.size = image_size",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        locations = []",
            "        for i in range(location_count):",
            "            locations.append({'url': 'file:///g/there/it/is%d' % i,",
            "                              'metadata': {}, 'status': 'active'})",
            "        image_values = {'id': 'xyz', 'owner': context.owner,",
            "                        'status': 'active', 'size': image_size,",
            "                        'locations': locations}",
            "        db_api.image_create(context, image_values)",
            "        return image",
            "",
            "    def test_quota_allowed(self):",
            "        quota = 10",
            "        self.config(user_storage_quota=str(quota))",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        data = '*' * quota",
            "        base_image.set_data(data, size=None)",
            "        image.set_data(data)",
            "        self.assertEqual(quota, base_image.size)",
            "",
            "    def _test_quota_allowed_unit(self, data_length, config_quota):",
            "        self.config(user_storage_quota=config_quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        data = '*' * data_length",
            "        base_image.set_data(data, size=None)",
            "        image.set_data(data)",
            "        self.assertEqual(data_length, base_image.size)",
            "",
            "    def test_quota_allowed_unit_b(self):",
            "        self._test_quota_allowed_unit(10, '10B')",
            "",
            "    def test_quota_allowed_unit_kb(self):",
            "        self._test_quota_allowed_unit(10, '1KB')",
            "",
            "    def test_quota_allowed_unit_mb(self):",
            "        self._test_quota_allowed_unit(10, '1MB')",
            "",
            "    def test_quota_allowed_unit_gb(self):",
            "        self._test_quota_allowed_unit(10, '1GB')",
            "",
            "    def test_quota_allowed_unit_tb(self):",
            "        self._test_quota_allowed_unit(10, '1TB')",
            "",
            "    def _quota_exceeded_size(self, quota, data,",
            "                             deleted=True, size=None):",
            "        self.config(user_storage_quota=quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "",
            "        if deleted:",
            "            with patch.object(store_utils, 'safe_delete_from_backend'):",
            "                store_utils.safe_delete_from_backend(",
            "                    context,",
            "                    image.image_id,",
            "                    base_image.locations[0])",
            "",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.set_data,",
            "                          data,",
            "                          size=size)",
            "",
            "    def test_quota_exceeded_no_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        # NOTE(jbresnah) When the image size is None it means that it is",
            "        # not known.  In this case the only time we will raise an",
            "        # exception is when there is no room left at all, thus we know",
            "        # it will not fit.",
            "        # That's why 'get_remaining_quota' is mocked with return_value = 0.",
            "        with patch.object(glance.api.common, 'get_remaining_quota',",
            "                          return_value=0):",
            "            self._quota_exceeded_size(str(quota), data)",
            "",
            "    def test_quota_exceeded_with_right_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(str(quota), data, size=len(data),",
            "                                  deleted=False)",
            "",
            "    def test_quota_exceeded_with_right_size_b(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size('10B', data, size=len(data),",
            "                                  deleted=False)",
            "",
            "    def test_quota_exceeded_with_right_size_kb(self):",
            "        quota = units.Ki",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size('1KB', data, size=len(data),",
            "                                  deleted=False)",
            "",
            "    def test_quota_exceeded_with_lie_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(str(quota), data, deleted=False,",
            "                                  size=quota - 1)",
            "",
            "    def test_append_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.append(new_location)",
            "        pre_add_locations.append(new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_insert_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.insert(0, new_location)",
            "        pre_add_locations.insert(0, new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_extend_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.extend([new_location])",
            "        pre_add_locations.extend([new_location])",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_iadd_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations += [new_location]",
            "        pre_add_locations += [new_location]",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_set_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        image.locations = [new_location]",
            "        self.assertEqual(image.locations, [new_location])",
            "",
            "    def _make_image_with_quota(self, image_size=10, location_count=2):",
            "        quota = image_size * location_count",
            "        self.config(user_storage_quota=str(quota))",
            "        return self._get_image(image_size=image_size,",
            "                               location_count=location_count)",
            "",
            "    def test_exceed_append_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.append,",
            "                          {'url': 'file:///a/path', 'metadata': {},",
            "                           'status': 'active'})",
            "",
            "    def test_exceed_insert_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.insert,",
            "                          0,",
            "                          {'url': 'file:///a/path', 'metadata': {},",
            "                           'status': 'active'})",
            "",
            "    def test_exceed_extend_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.extend,",
            "                          [{'url': 'file:///a/path', 'metadata': {},",
            "                            'status': 'active'}])",
            "",
            "    def test_set_location_under(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        image.locations = [{'url': 'file:///a/path', 'metadata': {},",
            "                            'status': 'active'}]",
            "",
            "    def test_set_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations = [{'url': 'file:///a/path', 'metadata': {},",
            "                                'status': 'active'},",
            "                               {'url': 'file:///a/path2', 'metadata': {},",
            "                                'status': 'active'}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_iadd_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations += [{'url': 'file:///a/path', 'metadata': {},",
            "                                 'status': 'active'}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_append_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.append({'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_insert_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.insert(0,",
            "                               {'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_set_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations = [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertEqual([{'url': 'file:///fake.img.tar.gz', 'metadata': {}}],",
            "                         image.locations)",
            "",
            "    def test_iadd_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations += [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "",
            "class TestImagePropertyQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImagePropertyQuotas, self).setUp()",
            "        self.base_image = FakeImage()",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_mock.add.return_value = self.base_image",
            "        self.image_repo_mock.save.return_value = self.base_image",
            "",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_save_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image)",
            "",
            "    def test_save_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.save, self.image)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", six.text_type(exc))",
            "",
            "    def test_save_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image)",
            "",
            "    def test_add_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "    def test_add_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.add, self.image)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", six.text_type(exc))",
            "",
            "    def test_add_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "    def _quota_exceed_setup(self):",
            "        self.config(image_property_quota=2)",
            "        self.base_image.extra_properties = {'foo': 'bar', 'spam': 'ham'}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "    def test_modify_image_properties_when_quota_exceeded(self):",
            "        self._quota_exceed_setup()",
            "        self.config(image_property_quota=1)",
            "        self.image.extra_properties = {'foo': 'frob', 'spam': 'eggs'}",
            "        self.image_repo_proxy.save(self.image)",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image)",
            "        self.assertEqual('frob', self.base_image.extra_properties['foo'])",
            "        self.assertEqual('eggs', self.base_image.extra_properties['spam'])",
            "",
            "    def test_delete_image_properties_when_quota_exceeded(self):",
            "        self._quota_exceed_setup()",
            "        self.config(image_property_quota=1)",
            "        del self.image.extra_properties['foo']",
            "        self.image_repo_proxy.save(self.image)",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image)",
            "        self.assertNotIn('foo', self.base_image.extra_properties)",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "",
            "    def test_invalid_quota_config_parameter(self):",
            "        self.config(user_storage_quota='foo')",
            "        location = {\"url\": \"file:///fake.img.tar.gz\", \"metadata\": {}}",
            "        self.assertRaises(exception.InvalidOptionValue,",
            "                          self.image.locations.append, location)",
            "",
            "    def test_exceed_quota_during_patch_operation(self):",
            "        self._quota_exceed_setup()",
            "        self.image.extra_properties['frob'] = 'baz'",
            "        self.image.extra_properties['lorem'] = 'ipsum'",
            "        self.assertEqual('bar', self.base_image.extra_properties['foo'])",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "        self.assertEqual('baz', self.base_image.extra_properties['frob'])",
            "        self.assertEqual('ipsum', self.base_image.extra_properties['lorem'])",
            "",
            "        del self.image.extra_properties['frob']",
            "        del self.image.extra_properties['lorem']",
            "        self.image_repo_proxy.save(self.image)",
            "        call_args = mock.call(self.base_image)",
            "        self.assertEqual(call_args, self.image_repo_mock.save.call_args)",
            "        self.assertEqual('bar', self.base_image.extra_properties['foo'])",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "        self.assertNotIn('frob', self.base_image.extra_properties)",
            "        self.assertNotIn('lorem', self.base_image.extra_properties)",
            "",
            "    def test_quota_exceeded_after_delete_image_properties(self):",
            "        self.config(image_property_quota=3)",
            "        self.base_image.extra_properties = {'foo': 'bar',",
            "                                            'spam': 'ham',",
            "                                            'frob': 'baz'}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "        self.config(image_property_quota=1)",
            "        del self.image.extra_properties['foo']",
            "        self.image_repo_proxy.save(self.image)",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image)",
            "        self.assertNotIn('foo', self.base_image.extra_properties)",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "        self.assertEqual('baz', self.base_image.extra_properties['frob'])",
            "",
            "",
            "class TestImageTagQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageTagQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.tags = set([])",
            "        self.base_image.extra_properties = {}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_replace_too_many_image_tags(self):",
            "        self.config(image_tag_quota=0)",
            "",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                setattr, self.image, 'tags', ['foo', 'bar'])",
            "        self.assertIn('Attempted: 2, Maximum: 0', six.text_type(exc))",
            "        self.assertEqual(0, len(self.image.tags))",
            "",
            "    def test_replace_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_add_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_add_too_many_image_tags(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                self.image.tags.add, 'bar')",
            "        self.assertIn('Attempted: 2, Maximum: 1', six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_remove_image_tag_while_over_quota(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(1, len(self.image.tags))",
            "        self.config(image_tag_quota=0)",
            "        self.image.tags.remove('foo')",
            "        self.assertEqual(0, len(self.image.tags))",
            "",
            "",
            "class TestQuotaImageTagsProxy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestQuotaImageTagsProxy, self).setUp()",
            "",
            "    def test_add(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        proxy.add('foo')",
            "        self.assertIn('foo', proxy)",
            "",
            "    def test_add_too_many_tags(self):",
            "        self.config(image_tag_quota=0)",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                proxy.add, 'bar')",
            "        self.assertIn('Attempted: 1, Maximum: 0', six.text_type(exc))",
            "",
            "    def test_equals(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        self.assertEqual(set([]), proxy)",
            "",
            "    def test_contains(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo']))",
            "        self.assertIn('foo', proxy)",
            "",
            "    def test_len(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo',",
            "                                                      'bar',",
            "                                                      'baz',",
            "                                                      'niz']))",
            "        self.assertEqual(4, len(proxy))",
            "",
            "    def test_iter(self):",
            "        items = set(['foo', 'bar', 'baz', 'niz'])",
            "        proxy = glance.quota.QuotaImageTagsProxy(items.copy())",
            "        self.assertEqual(4, len(items))",
            "        for item in proxy:",
            "            items.remove(item)",
            "        self.assertEqual(0, len(items))",
            "",
            "",
            "class TestImageMemberQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMemberQuotas, self).setUp()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        context = FakeContext()",
            "        self.image = mock.Mock()",
            "        self.base_image_member_factory = mock.Mock()",
            "        self.image_member_factory = glance.quota.ImageMemberFactoryProxy(",
            "            self.base_image_member_factory, context,",
            "            db_api, store)",
            "",
            "    def test_new_image_member(self):",
            "        self.config(image_member_quota=1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        nim = self.base_image_member_factory.new_image_member",
            "        nim .assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_unlimited_members(self):",
            "        self.config(image_member_quota=-1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        nim = self.base_image_member_factory.new_image_member",
            "        nim.assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_too_many_members(self):",
            "        self.config(image_member_quota=0)",
            "",
            "        self.assertRaises(exception.ImageMemberLimitExceeded,",
            "                          self.image_member_factory.new_image_member,",
            "                          self.image, 'fake_id')",
            "",
            "",
            "class TestImageLocationQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageLocationQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.locations = []",
            "        self.base_image.size = 1",
            "        self.base_image.extra_properties = {}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}",
            "                                 }]",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_replace_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        locations = [",
            "            {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake3.img.tar.gz\", \"metadata\": {}}",
            "        ]",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                setattr, self.image, 'locations', locations)",
            "        self.assertIn('Attempted: 3, Maximum: 1', six.text_type(exc))",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_replace_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_add_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        location = {\"url\": \"file:///fake.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location)",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_add_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        location2 = {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}}",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                self.image.locations.append, location2)",
            "        self.assertIn('Attempted: 2, Maximum: 1', six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_remove_image_location_while_over_quota(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(1, len(self.image.locations))",
            "        self.config(image_location_quota=0)",
            "        self.image.locations.remove(location1)",
            "        self.assertEqual(0, len(self.image.locations))"
        ],
        "afterPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import uuid",
            "",
            "import mock",
            "from mock import patch",
            "from oslo.utils import units",
            "import six",
            "",
            "from glance.common import exception",
            "from glance.common import store_utils",
            "import glance.quota",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class FakeContext(object):",
            "    owner = 'someone'",
            "    is_admin = False",
            "",
            "",
            "class FakeImage(object):",
            "    size = None",
            "    image_id = 'someid'",
            "    locations = [{'url': 'file:///not/a/path', 'metadata': {}}]",
            "    tags = set([])",
            "",
            "    def set_data(self, data, size=None):",
            "        self.size = 0",
            "        for d in data:",
            "            self.size += len(d)",
            "",
            "    def __init__(self, **kwargs):",
            "        self.extra_properties = kwargs.get('extra_properties', {})",
            "",
            "",
            "class TestImageQuota(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageQuota, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(TestImageQuota, self).tearDown()",
            "",
            "    def _get_image(self, location_count=1, image_size=10):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'xyz'",
            "        base_image.size = image_size",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        locations = []",
            "        for i in range(location_count):",
            "            locations.append({'url': 'file:///g/there/it/is%d' % i,",
            "                              'metadata': {}, 'status': 'active'})",
            "        image_values = {'id': 'xyz', 'owner': context.owner,",
            "                        'status': 'active', 'size': image_size,",
            "                        'locations': locations}",
            "        db_api.image_create(context, image_values)",
            "        return image",
            "",
            "    def test_quota_allowed(self):",
            "        quota = 10",
            "        self.config(user_storage_quota=str(quota))",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        data = '*' * quota",
            "        base_image.set_data(data, size=None)",
            "        image.set_data(data)",
            "        self.assertEqual(quota, base_image.size)",
            "",
            "    def _test_quota_allowed_unit(self, data_length, config_quota):",
            "        self.config(user_storage_quota=config_quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        data = '*' * data_length",
            "        base_image.set_data(data, size=None)",
            "        image.set_data(data)",
            "        self.assertEqual(data_length, base_image.size)",
            "",
            "    def test_quota_allowed_unit_b(self):",
            "        self._test_quota_allowed_unit(10, '10B')",
            "",
            "    def test_quota_allowed_unit_kb(self):",
            "        self._test_quota_allowed_unit(10, '1KB')",
            "",
            "    def test_quota_allowed_unit_mb(self):",
            "        self._test_quota_allowed_unit(10, '1MB')",
            "",
            "    def test_quota_allowed_unit_gb(self):",
            "        self._test_quota_allowed_unit(10, '1GB')",
            "",
            "    def test_quota_allowed_unit_tb(self):",
            "        self._test_quota_allowed_unit(10, '1TB')",
            "",
            "    def _quota_exceeded_size(self, quota, data,",
            "                             deleted=True, size=None):",
            "        self.config(user_storage_quota=quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "",
            "        if deleted:",
            "            with patch.object(store_utils, 'safe_delete_from_backend'):",
            "                store_utils.safe_delete_from_backend(",
            "                    context,",
            "                    image.image_id,",
            "                    base_image.locations[0])",
            "",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.set_data,",
            "                          data,",
            "                          size=size)",
            "",
            "    def test_quota_exceeded_no_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        # NOTE(jbresnah) When the image size is None it means that it is",
            "        # not known.  In this case the only time we will raise an",
            "        # exception is when there is no room left at all, thus we know",
            "        # it will not fit.",
            "        # That's why 'get_remaining_quota' is mocked with return_value = 0.",
            "        with patch.object(glance.api.common, 'get_remaining_quota',",
            "                          return_value=0):",
            "            self._quota_exceeded_size(str(quota), data)",
            "",
            "    def test_quota_exceeded_with_right_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(str(quota), data, size=len(data),",
            "                                  deleted=False)",
            "",
            "    def test_quota_exceeded_with_right_size_b(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size('10B', data, size=len(data),",
            "                                  deleted=False)",
            "",
            "    def test_quota_exceeded_with_right_size_kb(self):",
            "        quota = units.Ki",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size('1KB', data, size=len(data),",
            "                                  deleted=False)",
            "",
            "    def test_quota_exceeded_with_lie_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(str(quota), data, deleted=False,",
            "                                  size=quota - 1)",
            "",
            "    def test_append_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.append(new_location)",
            "        pre_add_locations.append(new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_insert_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.insert(0, new_location)",
            "        pre_add_locations.insert(0, new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_extend_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.extend([new_location])",
            "        pre_add_locations.extend([new_location])",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_iadd_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations += [new_location]",
            "        pre_add_locations += [new_location]",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_set_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {},",
            "                        'status': 'active'}",
            "        image = self._get_image()",
            "        image.locations = [new_location]",
            "        self.assertEqual(image.locations, [new_location])",
            "",
            "    def _make_image_with_quota(self, image_size=10, location_count=2):",
            "        quota = image_size * location_count",
            "        self.config(user_storage_quota=str(quota))",
            "        return self._get_image(image_size=image_size,",
            "                               location_count=location_count)",
            "",
            "    def test_exceed_append_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.append,",
            "                          {'url': 'file:///a/path', 'metadata': {},",
            "                           'status': 'active'})",
            "",
            "    def test_exceed_insert_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.insert,",
            "                          0,",
            "                          {'url': 'file:///a/path', 'metadata': {},",
            "                           'status': 'active'})",
            "",
            "    def test_exceed_extend_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.extend,",
            "                          [{'url': 'file:///a/path', 'metadata': {},",
            "                            'status': 'active'}])",
            "",
            "    def test_set_location_under(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        image.locations = [{'url': 'file:///a/path', 'metadata': {},",
            "                            'status': 'active'}]",
            "",
            "    def test_set_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations = [{'url': 'file:///a/path', 'metadata': {},",
            "                                'status': 'active'},",
            "                               {'url': 'file:///a/path2', 'metadata': {},",
            "                                'status': 'active'}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_iadd_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations += [{'url': 'file:///a/path', 'metadata': {},",
            "                                 'status': 'active'}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_append_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.append({'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_insert_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.insert(0,",
            "                               {'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_set_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations = [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertEqual([{'url': 'file:///fake.img.tar.gz', 'metadata': {}}],",
            "                         image.locations)",
            "",
            "    def test_iadd_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api, store)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(store_api, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations += [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "",
            "class TestImagePropertyQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImagePropertyQuotas, self).setUp()",
            "        self.base_image = FakeImage()",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_mock.add.return_value = self.base_image",
            "        self.image_repo_mock.save.return_value = self.base_image",
            "",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_save_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image,",
            "                                                          from_state=None)",
            "",
            "    def test_save_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.save, self.image)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", six.text_type(exc))",
            "",
            "    def test_save_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image,",
            "                                                          from_state=None)",
            "",
            "    def test_add_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "    def test_add_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.add, self.image)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", six.text_type(exc))",
            "",
            "    def test_add_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "    def _quota_exceed_setup(self):",
            "        self.config(image_property_quota=2)",
            "        self.base_image.extra_properties = {'foo': 'bar', 'spam': 'ham'}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "    def test_modify_image_properties_when_quota_exceeded(self):",
            "        self._quota_exceed_setup()",
            "        self.config(image_property_quota=1)",
            "        self.image.extra_properties = {'foo': 'frob', 'spam': 'eggs'}",
            "        self.image_repo_proxy.save(self.image)",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image,",
            "                                                          from_state=None)",
            "        self.assertEqual('frob', self.base_image.extra_properties['foo'])",
            "        self.assertEqual('eggs', self.base_image.extra_properties['spam'])",
            "",
            "    def test_delete_image_properties_when_quota_exceeded(self):",
            "        self._quota_exceed_setup()",
            "        self.config(image_property_quota=1)",
            "        del self.image.extra_properties['foo']",
            "        self.image_repo_proxy.save(self.image)",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image,",
            "                                                          from_state=None)",
            "        self.assertNotIn('foo', self.base_image.extra_properties)",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "",
            "    def test_invalid_quota_config_parameter(self):",
            "        self.config(user_storage_quota='foo')",
            "        location = {\"url\": \"file:///fake.img.tar.gz\", \"metadata\": {}}",
            "        self.assertRaises(exception.InvalidOptionValue,",
            "                          self.image.locations.append, location)",
            "",
            "    def test_exceed_quota_during_patch_operation(self):",
            "        self._quota_exceed_setup()",
            "        self.image.extra_properties['frob'] = 'baz'",
            "        self.image.extra_properties['lorem'] = 'ipsum'",
            "        self.assertEqual('bar', self.base_image.extra_properties['foo'])",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "        self.assertEqual('baz', self.base_image.extra_properties['frob'])",
            "        self.assertEqual('ipsum', self.base_image.extra_properties['lorem'])",
            "",
            "        del self.image.extra_properties['frob']",
            "        del self.image.extra_properties['lorem']",
            "        self.image_repo_proxy.save(self.image)",
            "        call_args = mock.call(self.base_image, from_state=None)",
            "        self.assertEqual(call_args, self.image_repo_mock.save.call_args)",
            "        self.assertEqual('bar', self.base_image.extra_properties['foo'])",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "        self.assertNotIn('frob', self.base_image.extra_properties)",
            "        self.assertNotIn('lorem', self.base_image.extra_properties)",
            "",
            "    def test_quota_exceeded_after_delete_image_properties(self):",
            "        self.config(image_property_quota=3)",
            "        self.base_image.extra_properties = {'foo': 'bar',",
            "                                            'spam': 'ham',",
            "                                            'frob': 'baz'}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "        self.config(image_property_quota=1)",
            "        del self.image.extra_properties['foo']",
            "        self.image_repo_proxy.save(self.image)",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image,",
            "                                                          from_state=None)",
            "        self.assertNotIn('foo', self.base_image.extra_properties)",
            "        self.assertEqual('ham', self.base_image.extra_properties['spam'])",
            "        self.assertEqual('baz', self.base_image.extra_properties['frob'])",
            "",
            "",
            "class TestImageTagQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageTagQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.tags = set([])",
            "        self.base_image.extra_properties = {}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_replace_too_many_image_tags(self):",
            "        self.config(image_tag_quota=0)",
            "",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                setattr, self.image, 'tags', ['foo', 'bar'])",
            "        self.assertIn('Attempted: 2, Maximum: 0', six.text_type(exc))",
            "        self.assertEqual(0, len(self.image.tags))",
            "",
            "    def test_replace_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_add_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_add_too_many_image_tags(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                self.image.tags.add, 'bar')",
            "        self.assertIn('Attempted: 2, Maximum: 1', six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(1, len(self.image.tags))",
            "",
            "    def test_remove_image_tag_while_over_quota(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(1, len(self.image.tags))",
            "        self.config(image_tag_quota=0)",
            "        self.image.tags.remove('foo')",
            "        self.assertEqual(0, len(self.image.tags))",
            "",
            "",
            "class TestQuotaImageTagsProxy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestQuotaImageTagsProxy, self).setUp()",
            "",
            "    def test_add(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        proxy.add('foo')",
            "        self.assertIn('foo', proxy)",
            "",
            "    def test_add_too_many_tags(self):",
            "        self.config(image_tag_quota=0)",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                proxy.add, 'bar')",
            "        self.assertIn('Attempted: 1, Maximum: 0', six.text_type(exc))",
            "",
            "    def test_equals(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        self.assertEqual(set([]), proxy)",
            "",
            "    def test_contains(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo']))",
            "        self.assertIn('foo', proxy)",
            "",
            "    def test_len(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo',",
            "                                                      'bar',",
            "                                                      'baz',",
            "                                                      'niz']))",
            "        self.assertEqual(4, len(proxy))",
            "",
            "    def test_iter(self):",
            "        items = set(['foo', 'bar', 'baz', 'niz'])",
            "        proxy = glance.quota.QuotaImageTagsProxy(items.copy())",
            "        self.assertEqual(4, len(items))",
            "        for item in proxy:",
            "            items.remove(item)",
            "        self.assertEqual(0, len(items))",
            "",
            "",
            "class TestImageMemberQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMemberQuotas, self).setUp()",
            "        db_api = unit_test_utils.FakeDB()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store = unit_test_utils.FakeStoreUtils(store_api)",
            "        context = FakeContext()",
            "        self.image = mock.Mock()",
            "        self.base_image_member_factory = mock.Mock()",
            "        self.image_member_factory = glance.quota.ImageMemberFactoryProxy(",
            "            self.base_image_member_factory, context,",
            "            db_api, store)",
            "",
            "    def test_new_image_member(self):",
            "        self.config(image_member_quota=1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        nim = self.base_image_member_factory.new_image_member",
            "        nim .assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_unlimited_members(self):",
            "        self.config(image_member_quota=-1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        nim = self.base_image_member_factory.new_image_member",
            "        nim.assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_too_many_members(self):",
            "        self.config(image_member_quota=0)",
            "",
            "        self.assertRaises(exception.ImageMemberLimitExceeded,",
            "                          self.image_member_factory.new_image_member,",
            "                          self.image, 'fake_id')",
            "",
            "",
            "class TestImageLocationQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageLocationQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.locations = []",
            "        self.base_image.size = 1",
            "        self.base_image.extra_properties = {}",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}",
            "                                 }]",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_replace_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        locations = [",
            "            {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake3.img.tar.gz\", \"metadata\": {}}",
            "        ]",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                setattr, self.image, 'locations', locations)",
            "        self.assertIn('Attempted: 3, Maximum: 1', six.text_type(exc))",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_replace_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_add_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        location = {\"url\": \"file:///fake.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location)",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_add_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        location2 = {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}}",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                self.image.locations.append, location2)",
            "        self.assertIn('Attempted: 2, Maximum: 1', six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(1, len(self.image.locations))",
            "",
            "    def test_remove_image_location_while_over_quota(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(1, len(self.image.locations))",
            "        self.config(image_location_quota=0)",
            "        self.image.locations.remove(location1)",
            "        self.assertEqual(0, len(self.image.locations))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "369": [
                "TestImagePropertyQuotas",
                "test_save_image_with_image_property"
            ],
            "385": [
                "TestImagePropertyQuotas",
                "test_save_image_unlimited_image_properties"
            ],
            "424": [
                "TestImagePropertyQuotas",
                "test_modify_image_properties_when_quota_exceeded"
            ],
            "433": [
                "TestImagePropertyQuotas",
                "test_delete_image_properties_when_quota_exceeded"
            ],
            "455": [
                "TestImagePropertyQuotas",
                "test_exceed_quota_during_patch_operation"
            ],
            "474": [
                "TestImagePropertyQuotas",
                "test_quota_exceeded_after_delete_image_properties"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_store_image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     def add(self, image):"
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         return image"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         return image"
            },
            "6": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import glance_store",
            "import mox",
            "",
            "from glance.common import exception",
            "import glance.location",
            "from glance.tests.unit import base as unit_test_base",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils",
            "",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "TENANT3 = '228c6da5-29cd-4d67-9457-ed632e083fc0'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def add(self, image):",
            "        return image",
            "",
            "    def save(self, image):",
            "        return image",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, status=None, locations=None,",
            "                 visibility=None):",
            "        self.image_id = image_id",
            "        self.status = status",
            "        self.locations = locations or []",
            "        self.visibility = visibility",
            "        self.size = 1",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "    def get_member_repo(self):",
            "        return FakeMemberRepo(self, [TENANT1, TENANT2])",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        return ImageStub(image_id, visibility=visibility, **other_args)",
            "",
            "",
            "class FakeMemberRepo(object):",
            "    def __init__(self, image, tenants=None):",
            "        self.image = image",
            "        self.factory = glance.domain.ImageMemberFactory()",
            "        self.tenants = tenants or []",
            "",
            "    def list(self, *args, **kwargs):",
            "        return [self.factory.new_image_member(self.image, tenant)",
            "                for tenant in self.tenants]",
            "",
            "    def add(self, member):",
            "        self.tenants.append(member.member_id)",
            "",
            "    def remove(self, member):",
            "        self.tenants.remove(member.member_id)",
            "",
            "",
            "class TestStoreImage(utils.BaseTestCase):",
            "    def setUp(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}, 'status': 'active'}]",
            "        self.image_stub = ImageStub(UUID1, 'active', locations)",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        self.store_utils = unit_test_utils.FakeStoreUtils(self.store_api)",
            "        super(TestStoreImage, self).setUp()",
            "",
            "    def test_image_delete(self):",
            "        image = glance.location.ImageProxy(self.image_stub, {},",
            "                                           self.store_api, self.store_utils)",
            "        location = image.locations[0]",
            "        self.assertEqual('active', image.status)",
            "        self.store_api.get_from_backend(location['url'], context={})",
            "        image.delete()",
            "        self.assertEqual('deleted', image.status)",
            "        self.assertRaises(glance_store.NotFound,",
            "                          self.store_api.get_from_backend, location['url'], {})",
            "",
            "    def test_image_get_data(self):",
            "        image = glance.location.ImageProxy(self.image_stub, {},",
            "                                           self.store_api, self.store_utils)",
            "        self.assertEqual('XXX', image.get_data())",
            "",
            "    def test_image_get_data_from_second_location(self):",
            "        def fake_get_from_backend(self, location, offset=0,",
            "                                  chunk_size=None, context=None):",
            "            if UUID1 in location:",
            "                raise Exception('not allow download from %s' % location)",
            "            else:",
            "                return self.data[location]",
            "",
            "        image1 = glance.location.ImageProxy(self.image_stub, {},",
            "                                            self.store_api, self.store_utils)",
            "        self.assertEqual('XXX', image1.get_data())",
            "        # Multiple location support",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image2, image_stub2) = self._add_image(context, UUID2, 'ZZZ', 3)",
            "        location_data = image2.locations[0]",
            "        image1.locations.append(location_data)",
            "        self.assertEqual(2, len(image1.locations))",
            "        self.assertEqual(UUID2, location_data['url'])",
            "",
            "        self.stubs.Set(unit_test_utils.FakeStoreAPI, 'get_from_backend',",
            "                       fake_get_from_backend)",
            "        # This time, image1.get_data() returns the data wrapped in a",
            "        # LimitingReader|CooperativeReader pipeline, so peeking under",
            "        # the hood of those objects to get at the underlying string.",
            "        self.assertEqual('ZZZ', image1.get_data().data.fd)",
            "",
            "        image1.locations.pop(0)",
            "        self.assertEqual(1, len(image1.locations))",
            "        image2.delete()",
            "",
            "    def test_image_set_data(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           self.store_api, self.store_utils)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(4, image.size)",
            "        # NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(UUID2, image.locations[0]['url'])",
            "        self.assertEqual('Z', image.checksum)",
            "        self.assertEqual('active', image.status)",
            "",
            "    def test_image_set_data_location_metadata(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        loc_meta = {'key': 'value5032'}",
            "        store_api = unit_test_utils.FakeStoreAPI(store_metadata=loc_meta)",
            "        store_utils = unit_test_utils.FakeStoreUtils(store_api)",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           store_api, store_utils)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(4, image.size)",
            "        location_data = image.locations[0]",
            "        self.assertEqual(UUID2, location_data['url'])",
            "        self.assertEqual(loc_meta, location_data['metadata'])",
            "        self.assertEqual('Z', image.checksum)",
            "        self.assertEqual('active', image.status)",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(glance_store.NotFound,",
            "                          self.store_api.get_from_backend,",
            "                          image.locations[0]['url'], {})",
            "",
            "    def test_image_set_data_unknown_size(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           self.store_api, self.store_utils)",
            "        image.set_data('YYYY', None)",
            "        self.assertEqual(4, image.size)",
            "        # NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(UUID2, image.locations[0]['url'])",
            "        self.assertEqual('Z', image.checksum)",
            "        self.assertEqual('active', image.status)",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(glance_store.NotFound,",
            "                          self.store_api.get_from_backend,",
            "                          image.locations[0]['url'], context={})",
            "",
            "    def _add_image(self, context, image_id, data, len):",
            "        image_stub = ImageStub(image_id, status='queued', locations=[])",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           self.store_api, self.store_utils)",
            "        image.set_data(data, len)",
            "        self.assertEqual(len, image.size)",
            "        # NOTE(markwash): FakeStore returns image_id for location",
            "        location = {'url': image_id, 'metadata': {}, 'status': 'active'}",
            "        self.assertEqual([location], image.locations)",
            "        self.assertEqual([location], image_stub.locations)",
            "        self.assertEqual('active', image.status)",
            "        return (image, image_stub)",
            "",
            "    def test_image_change_append_invalid_location_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_append_invalid_location_metatdata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        # Using only one test rule here is enough to make sure",
            "        # 'store.check_location_metadata()' can be triggered",
            "        # in Location proxy layer. Complete test rule for",
            "        # 'store.check_location_metadata()' testing please",
            "        # check below cases within 'TestStoreMetaDataChecker'.",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_append_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual([location2, location3], image_stub1.locations)",
            "        self.assertEqual([location2, location3], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_pop_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual([location2, location3], image_stub1.locations)",
            "        self.assertEqual([location2, location3], image1.locations)",
            "",
            "        image1.locations.pop()",
            "",
            "        self.assertEqual([location2], image_stub1.locations)",
            "        self.assertEqual([location2], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_extend_invalid_locations_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_invalid_locations_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.extend([location3])",
            "",
            "        self.assertEqual([location2, location3], image_stub1.locations)",
            "        self.assertEqual([location2, location3], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_remove_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "        image1.locations.remove(location2)",
            "",
            "        self.assertEqual([location3], image_stub1.locations)",
            "        self.assertEqual([location3], image1.locations)",
            "        self.assertRaises(ValueError,",
            "                          image1.locations.remove, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_delete_location(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        del image1.locations[0]",
            "",
            "        self.assertEqual([], image_stub1.locations)",
            "        self.assertEqual(0, len(image1.locations))",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "",
            "    def test_image_change_insert_invalid_location_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_invalid_location_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.insert(0, location3)",
            "",
            "        self.assertEqual([location3, location2], image_stub1.locations)",
            "        self.assertEqual([location3, location2], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_delete_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "        del image1.locations[0:100]",
            "",
            "        self.assertEqual([], image_stub1.locations)",
            "        self.assertEqual(0, len(image1.locations))",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location2)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image2.locations.insert, 0, location3)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub1 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image1 = glance.location.ImageProxy(image_stub1, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.__iadd__, [location_bad])",
            "        self.assertEqual([], image_stub1.locations)",
            "        self.assertEqual([], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_metadata(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        image_stub2 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image2 = glance.location.ImageProxy(image_stub2, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location_bad = {'url': UUID2, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image2.locations.__iadd__, [location_bad])",
            "        self.assertEqual([], image_stub2.locations)",
            "        self.assertEqual([], image2.locations)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual([location2, location3], image_stub3.locations)",
            "        self.assertEqual([location2, location3], image3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(1, image_stub3.locations.index(location3))",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_by_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(1, image_stub3.locations.index(location3))",
            "        self.assertEqual(location2, image_stub3.locations[0])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_checking_location_exists(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertIn(location3, image_stub3.locations)",
            "        self.assertNotIn(location_bad, image_stub3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_reverse_locations_order(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "        image3.locations += [location2, location3]",
            "",
            "        image_stub3.locations.reverse()",
            "",
            "        self.assertEqual([location3, location2], image_stub3.locations)",
            "        self.assertEqual([location3, location2], image3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "",
            "class TestStoreImageRepo(utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestStoreImageRepo, self).setUp()",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        store_utils = unit_test_utils.FakeStoreUtils(self.store_api)",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image = glance.location.ImageProxy(self.image_stub, {},",
            "                                                self.store_api, store_utils)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_repo = glance.location.ImageRepoProxy(self.image_repo_stub,",
            "                                                         {}, self.store_api,",
            "                                                         store_utils)",
            "",
            "    def test_add_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {},",
            "                                      'status': 'active'},",
            "                                     {'url': 'bar', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertTrue(self.store_api.acls['foo']['public'])",
            "        self.assertEqual([], self.store_api.acls['foo']['read'])",
            "        self.assertEqual([], self.store_api.acls['foo']['write'])",
            "        self.assertTrue(self.store_api.acls['bar']['public'])",
            "        self.assertEqual([], self.store_api.acls['bar']['read'])",
            "        self.assertEqual([], self.store_api.acls['bar']['write'])",
            "",
            "    def test_add_ignores_acls_if_no_locations(self):",
            "        self.image_stub.locations = []",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertEqual(0, len(self.store_api.acls))",
            "",
            "    def test_save_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('foo', self.store_api.acls)",
            "",
            "    def test_add_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.add(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT1, TENANT2], acls['read'])",
            "",
            "    def test_save_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT1, TENANT2], acls['read'])",
            "",
            "    def test_member_addition_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT3, None, None, status='accepted')",
            "        member_repo.add(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT1, TENANT2, TENANT3], acls['read'])",
            "",
            "    def test_member_removal_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT1, None, None, status='accepted')",
            "        member_repo.remove(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT2], acls['read'])",
            "",
            "",
            "class TestImageFactory(unit_test_base.StoreClearingUnitTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store_utils = unit_test_utils.FakeStoreUtils(store_api)",
            "        self.image_factory = glance.location.ImageFactoryProxy(",
            "            ImageFactoryStub(),",
            "            glance.context.RequestContext(user=USER1),",
            "            store_api,",
            "            store_utils)",
            "",
            "    def test_new_image(self):",
            "        image = self.image_factory.new_image()",
            "        self.assertIsNone(image.image_id)",
            "        self.assertIsNone(image.status)",
            "        self.assertEqual('private', image.visibility)",
            "        self.assertEqual([], image.locations)",
            "",
            "    def test_new_image_with_location(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        image = self.image_factory.new_image(locations=locations)",
            "        self.assertEqual(locations, image.locations)",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          self.image_factory.new_image,",
            "                          locations=[location_bad])",
            "",
            "",
            "class TestStoreMetaDataChecker(utils.BaseTestCase):",
            "",
            "    def test_empty(self):",
            "        glance_store.check_location_metadata({})",
            "",
            "    def test_unicode(self):",
            "        m = {'key': u'somevalue'}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_unicode_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_simple_bad(self):",
            "        m = {'key1': object()}",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_list_bad(self):",
            "        m = {'key1': [u'somevalue', object()]}",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_nested_dict_bad(self):",
            "        inner = {'key1': u'somevalue', 'key2': object()}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.check_location_metadata,",
            "                          m)",
            "",
            "",
            "class TestStoreAddToBackend(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestStoreAddToBackend, self).setUp()",
            "        self.image_id = \"animage\"",
            "        self.data = \"dataandstuff\"",
            "        self.size = len(self.data)",
            "        self.location = \"file:///ab/cde/fgh\"",
            "        self.checksum = \"md5\"",
            "        self.mox = mox.Mox()",
            "",
            "    def tearDown(self):",
            "        super(TestStoreAddToBackend, self).tearDown()",
            "        self.mox.UnsetStubs()",
            "",
            "    def _bad_metadata(self, in_metadata):",
            "        mstore = self.mox.CreateMockAnything()",
            "        mstore.add(self.image_id, mox.IgnoreArg(),",
            "                   self.size, context=None).AndReturn(",
            "                       (self.location, self.size, self.checksum, in_metadata))",
            "        mstore.__str__ = lambda: \"hello\"",
            "        mstore.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          mstore)",
            "        self.mox.VerifyAll()",
            "",
            "    def _good_metadata(self, in_metadata):",
            "",
            "        mstore = self.mox.CreateMockAnything()",
            "        mstore.add(self.image_id, mox.IgnoreArg(),",
            "                   self.size, context=None).AndReturn(",
            "                       (self.location, self.size, self.checksum, in_metadata))",
            "",
            "        self.mox.ReplayAll()",
            "        (location,",
            "         size,",
            "         checksum,",
            "         metadata) = glance_store.store_add_to_backend(self.image_id,",
            "                                                       self.data,",
            "                                                       self.size,",
            "                                                       mstore)",
            "        self.mox.VerifyAll()",
            "        self.assertEqual(self.location, location)",
            "        self.assertEqual(self.size, size)",
            "        self.assertEqual(self.checksum, checksum)",
            "        self.assertEqual(in_metadata, metadata)",
            "",
            "    def test_empty(self):",
            "        metadata = {}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_string(self):",
            "        metadata = {'key': u'somevalue'}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._good_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_bad_top_level_nonunicode(self):",
            "        metadata = {'key': 'a string'}",
            "        self._bad_metadata(metadata)",
            "",
            "    def test_bad_nonunicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue',",
            "                 'k3': [1, object()]}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._bad_metadata(m)",
            "",
            "    def test_bad_metadata_not_dict(self):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(),",
            "                  self.size, context=None).AndReturn(",
            "                      (self.location, self.size, self.checksum, []))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import glance_store",
            "import mox",
            "",
            "from glance.common import exception",
            "import glance.location",
            "from glance.tests.unit import base as unit_test_base",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils",
            "",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "TENANT3 = '228c6da5-29cd-4d67-9457-ed632e083fc0'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def add(self, image):",
            "        return image",
            "",
            "    def save(self, image, from_state=None):",
            "        return image",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, status=None, locations=None,",
            "                 visibility=None):",
            "        self.image_id = image_id",
            "        self.status = status",
            "        self.locations = locations or []",
            "        self.visibility = visibility",
            "        self.size = 1",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "    def get_member_repo(self):",
            "        return FakeMemberRepo(self, [TENANT1, TENANT2])",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        return ImageStub(image_id, visibility=visibility, **other_args)",
            "",
            "",
            "class FakeMemberRepo(object):",
            "    def __init__(self, image, tenants=None):",
            "        self.image = image",
            "        self.factory = glance.domain.ImageMemberFactory()",
            "        self.tenants = tenants or []",
            "",
            "    def list(self, *args, **kwargs):",
            "        return [self.factory.new_image_member(self.image, tenant)",
            "                for tenant in self.tenants]",
            "",
            "    def add(self, member):",
            "        self.tenants.append(member.member_id)",
            "",
            "    def remove(self, member):",
            "        self.tenants.remove(member.member_id)",
            "",
            "",
            "class TestStoreImage(utils.BaseTestCase):",
            "    def setUp(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}, 'status': 'active'}]",
            "        self.image_stub = ImageStub(UUID1, 'active', locations)",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        self.store_utils = unit_test_utils.FakeStoreUtils(self.store_api)",
            "        super(TestStoreImage, self).setUp()",
            "",
            "    def test_image_delete(self):",
            "        image = glance.location.ImageProxy(self.image_stub, {},",
            "                                           self.store_api, self.store_utils)",
            "        location = image.locations[0]",
            "        self.assertEqual('active', image.status)",
            "        self.store_api.get_from_backend(location['url'], context={})",
            "        image.delete()",
            "        self.assertEqual('deleted', image.status)",
            "        self.assertRaises(glance_store.NotFound,",
            "                          self.store_api.get_from_backend, location['url'], {})",
            "",
            "    def test_image_get_data(self):",
            "        image = glance.location.ImageProxy(self.image_stub, {},",
            "                                           self.store_api, self.store_utils)",
            "        self.assertEqual('XXX', image.get_data())",
            "",
            "    def test_image_get_data_from_second_location(self):",
            "        def fake_get_from_backend(self, location, offset=0,",
            "                                  chunk_size=None, context=None):",
            "            if UUID1 in location:",
            "                raise Exception('not allow download from %s' % location)",
            "            else:",
            "                return self.data[location]",
            "",
            "        image1 = glance.location.ImageProxy(self.image_stub, {},",
            "                                            self.store_api, self.store_utils)",
            "        self.assertEqual('XXX', image1.get_data())",
            "        # Multiple location support",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image2, image_stub2) = self._add_image(context, UUID2, 'ZZZ', 3)",
            "        location_data = image2.locations[0]",
            "        image1.locations.append(location_data)",
            "        self.assertEqual(2, len(image1.locations))",
            "        self.assertEqual(UUID2, location_data['url'])",
            "",
            "        self.stubs.Set(unit_test_utils.FakeStoreAPI, 'get_from_backend',",
            "                       fake_get_from_backend)",
            "        # This time, image1.get_data() returns the data wrapped in a",
            "        # LimitingReader|CooperativeReader pipeline, so peeking under",
            "        # the hood of those objects to get at the underlying string.",
            "        self.assertEqual('ZZZ', image1.get_data().data.fd)",
            "",
            "        image1.locations.pop(0)",
            "        self.assertEqual(1, len(image1.locations))",
            "        image2.delete()",
            "",
            "    def test_image_set_data(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           self.store_api, self.store_utils)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(4, image.size)",
            "        # NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(UUID2, image.locations[0]['url'])",
            "        self.assertEqual('Z', image.checksum)",
            "        self.assertEqual('active', image.status)",
            "",
            "    def test_image_set_data_location_metadata(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        loc_meta = {'key': 'value5032'}",
            "        store_api = unit_test_utils.FakeStoreAPI(store_metadata=loc_meta)",
            "        store_utils = unit_test_utils.FakeStoreUtils(store_api)",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           store_api, store_utils)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(4, image.size)",
            "        location_data = image.locations[0]",
            "        self.assertEqual(UUID2, location_data['url'])",
            "        self.assertEqual(loc_meta, location_data['metadata'])",
            "        self.assertEqual('Z', image.checksum)",
            "        self.assertEqual('active', image.status)",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(glance_store.NotFound,",
            "                          self.store_api.get_from_backend,",
            "                          image.locations[0]['url'], {})",
            "",
            "    def test_image_set_data_unknown_size(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           self.store_api, self.store_utils)",
            "        image.set_data('YYYY', None)",
            "        self.assertEqual(4, image.size)",
            "        # NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(UUID2, image.locations[0]['url'])",
            "        self.assertEqual('Z', image.checksum)",
            "        self.assertEqual('active', image.status)",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(glance_store.NotFound,",
            "                          self.store_api.get_from_backend,",
            "                          image.locations[0]['url'], context={})",
            "",
            "    def _add_image(self, context, image_id, data, len):",
            "        image_stub = ImageStub(image_id, status='queued', locations=[])",
            "        image = glance.location.ImageProxy(image_stub, context,",
            "                                           self.store_api, self.store_utils)",
            "        image.set_data(data, len)",
            "        self.assertEqual(len, image.size)",
            "        # NOTE(markwash): FakeStore returns image_id for location",
            "        location = {'url': image_id, 'metadata': {}, 'status': 'active'}",
            "        self.assertEqual([location], image.locations)",
            "        self.assertEqual([location], image_stub.locations)",
            "        self.assertEqual('active', image.status)",
            "        return (image, image_stub)",
            "",
            "    def test_image_change_append_invalid_location_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_append_invalid_location_metatdata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        # Using only one test rule here is enough to make sure",
            "        # 'store.check_location_metadata()' can be triggered",
            "        # in Location proxy layer. Complete test rule for",
            "        # 'store.check_location_metadata()' testing please",
            "        # check below cases within 'TestStoreMetaDataChecker'.",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_append_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual([location2, location3], image_stub1.locations)",
            "        self.assertEqual([location2, location3], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_pop_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual([location2, location3], image_stub1.locations)",
            "        self.assertEqual([location2, location3], image1.locations)",
            "",
            "        image1.locations.pop()",
            "",
            "        self.assertEqual([location2], image_stub1.locations)",
            "        self.assertEqual([location2], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_extend_invalid_locations_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_invalid_locations_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.extend([location3])",
            "",
            "        self.assertEqual([location2, location3], image_stub1.locations)",
            "        self.assertEqual([location2, location3], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_remove_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "        image1.locations.remove(location2)",
            "",
            "        self.assertEqual([location3], image_stub1.locations)",
            "        self.assertEqual([location3], image1.locations)",
            "        self.assertRaises(ValueError,",
            "                          image1.locations.remove, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_delete_location(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        del image1.locations[0]",
            "",
            "        self.assertEqual([], image_stub1.locations)",
            "        self.assertEqual(0, len(image1.locations))",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "",
            "    def test_image_change_insert_invalid_location_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_invalid_location_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}, 'status': 'active'}",
            "        location3 = {'url': UUID3, 'metadata': {}, 'status': 'active'}",
            "",
            "        image1.locations.insert(0, location3)",
            "",
            "        self.assertEqual([location3, location2], image_stub1.locations)",
            "        self.assertEqual([location3, location2], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_delete_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "        del image1.locations[0:100]",
            "",
            "        self.assertEqual([], image_stub1.locations)",
            "        self.assertEqual(0, len(image1.locations))",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location2)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image2.locations.insert, 0, location3)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_uri(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub1 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image1 = glance.location.ImageProxy(image_stub1, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.__iadd__, [location_bad])",
            "        self.assertEqual([], image_stub1.locations)",
            "        self.assertEqual([], image1.locations)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_metadata(self):",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        image_stub2 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image2 = glance.location.ImageProxy(image_stub2, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location_bad = {'url': UUID2, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          image2.locations.__iadd__, [location_bad])",
            "        self.assertEqual([], image_stub2.locations)",
            "        self.assertEqual([], image2.locations)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual([location2, location3], image_stub3.locations)",
            "        self.assertEqual([location2, location3], image3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(1, image_stub3.locations.index(location3))",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_by_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(1, image_stub3.locations.index(location3))",
            "        self.assertEqual(location2, image_stub3.locations[0])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_checking_location_exists(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertIn(location3, image_stub3.locations)",
            "        self.assertNotIn(location_bad, image_stub3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_reverse_locations_order(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.location.ImageProxy(image_stub3, context,",
            "                                            self.store_api, self.store_utils)",
            "        image3.locations += [location2, location3]",
            "",
            "        image_stub3.locations.reverse()",
            "",
            "        self.assertEqual([location3, location2], image_stub3.locations)",
            "        self.assertEqual([location3, location2], image3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(2, len(self.store_api.data.keys()))",
            "        self.assertNotIn(UUID2, self.store_api.data.keys())",
            "        self.assertNotIn(UUID3, self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "",
            "class TestStoreImageRepo(utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestStoreImageRepo, self).setUp()",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        store_utils = unit_test_utils.FakeStoreUtils(self.store_api)",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image = glance.location.ImageProxy(self.image_stub, {},",
            "                                                self.store_api, store_utils)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_repo = glance.location.ImageRepoProxy(self.image_repo_stub,",
            "                                                         {}, self.store_api,",
            "                                                         store_utils)",
            "",
            "    def test_add_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {},",
            "                                      'status': 'active'},",
            "                                     {'url': 'bar', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertTrue(self.store_api.acls['foo']['public'])",
            "        self.assertEqual([], self.store_api.acls['foo']['read'])",
            "        self.assertEqual([], self.store_api.acls['foo']['write'])",
            "        self.assertTrue(self.store_api.acls['bar']['public'])",
            "        self.assertEqual([], self.store_api.acls['bar']['read'])",
            "        self.assertEqual([], self.store_api.acls['bar']['write'])",
            "",
            "    def test_add_ignores_acls_if_no_locations(self):",
            "        self.image_stub.locations = []",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertEqual(0, len(self.store_api.acls))",
            "",
            "    def test_save_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('foo', self.store_api.acls)",
            "",
            "    def test_add_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.add(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT1, TENANT2], acls['read'])",
            "",
            "    def test_save_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT1, TENANT2], acls['read'])",
            "",
            "    def test_member_addition_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT3, None, None, status='accepted')",
            "        member_repo.add(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT1, TENANT2, TENANT3], acls['read'])",
            "",
            "    def test_member_removal_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {},",
            "                                      'status': 'active'}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT1, None, None, status='accepted')",
            "        member_repo.remove(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual([], acls['write'])",
            "        self.assertEqual([TENANT2], acls['read'])",
            "",
            "",
            "class TestImageFactory(unit_test_base.StoreClearingUnitTest):",
            "",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        store_api = unit_test_utils.FakeStoreAPI()",
            "        store_utils = unit_test_utils.FakeStoreUtils(store_api)",
            "        self.image_factory = glance.location.ImageFactoryProxy(",
            "            ImageFactoryStub(),",
            "            glance.context.RequestContext(user=USER1),",
            "            store_api,",
            "            store_utils)",
            "",
            "    def test_new_image(self):",
            "        image = self.image_factory.new_image()",
            "        self.assertIsNone(image.image_id)",
            "        self.assertIsNone(image.status)",
            "        self.assertEqual('private', image.visibility)",
            "        self.assertEqual([], image.locations)",
            "",
            "    def test_new_image_with_location(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        image = self.image_factory.new_image(locations=locations)",
            "        self.assertEqual(locations, image.locations)",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          self.image_factory.new_image,",
            "                          locations=[location_bad])",
            "",
            "",
            "class TestStoreMetaDataChecker(utils.BaseTestCase):",
            "",
            "    def test_empty(self):",
            "        glance_store.check_location_metadata({})",
            "",
            "    def test_unicode(self):",
            "        m = {'key': u'somevalue'}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_unicode_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        glance_store.check_location_metadata(m)",
            "",
            "    def test_simple_bad(self):",
            "        m = {'key1': object()}",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_list_bad(self):",
            "        m = {'key1': [u'somevalue', object()]}",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_nested_dict_bad(self):",
            "        inner = {'key1': u'somevalue', 'key2': object()}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.check_location_metadata,",
            "                          m)",
            "",
            "",
            "class TestStoreAddToBackend(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestStoreAddToBackend, self).setUp()",
            "        self.image_id = \"animage\"",
            "        self.data = \"dataandstuff\"",
            "        self.size = len(self.data)",
            "        self.location = \"file:///ab/cde/fgh\"",
            "        self.checksum = \"md5\"",
            "        self.mox = mox.Mox()",
            "",
            "    def tearDown(self):",
            "        super(TestStoreAddToBackend, self).tearDown()",
            "        self.mox.UnsetStubs()",
            "",
            "    def _bad_metadata(self, in_metadata):",
            "        mstore = self.mox.CreateMockAnything()",
            "        mstore.add(self.image_id, mox.IgnoreArg(),",
            "                   self.size, context=None).AndReturn(",
            "                       (self.location, self.size, self.checksum, in_metadata))",
            "        mstore.__str__ = lambda: \"hello\"",
            "        mstore.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          mstore)",
            "        self.mox.VerifyAll()",
            "",
            "    def _good_metadata(self, in_metadata):",
            "",
            "        mstore = self.mox.CreateMockAnything()",
            "        mstore.add(self.image_id, mox.IgnoreArg(),",
            "                   self.size, context=None).AndReturn(",
            "                       (self.location, self.size, self.checksum, in_metadata))",
            "",
            "        self.mox.ReplayAll()",
            "        (location,",
            "         size,",
            "         checksum,",
            "         metadata) = glance_store.store_add_to_backend(self.image_id,",
            "                                                       self.data,",
            "                                                       self.size,",
            "                                                       mstore)",
            "        self.mox.VerifyAll()",
            "        self.assertEqual(self.location, location)",
            "        self.assertEqual(self.size, size)",
            "        self.assertEqual(self.checksum, checksum)",
            "        self.assertEqual(in_metadata, metadata)",
            "",
            "    def test_empty(self):",
            "        metadata = {}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_string(self):",
            "        metadata = {'key': u'somevalue'}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._good_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_bad_top_level_nonunicode(self):",
            "        metadata = {'key': 'a string'}",
            "        self._bad_metadata(metadata)",
            "",
            "    def test_bad_nonunicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue',",
            "                 'k3': [1, object()]}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._bad_metadata(m)",
            "",
            "    def test_bad_metadata_not_dict(self):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(),",
            "                  self.size, context=None).AndReturn(",
            "                      (self.location, self.size, self.checksum, []))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance_store.BackendException,",
            "                          glance_store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "38": [
                "ImageRepoStub",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/v1/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1741,
                "afterPatchRowNumber": 1741,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 1742,
                "afterPatchRowNumber": 1742,
                "PatchRowcode": "         self.assertEqual(1, mock_store_add_to_backend.call_count)"
            },
            "2": {
                "beforePatchRowNumber": 1743,
                "afterPatchRowNumber": 1743,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 1744,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_delete_during_image_upload(self):"
            },
            "4": {
                "beforePatchRowNumber": 1745,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = unit_test_utils.get_fake_request()"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1744,
                "PatchRowcode": "+    def _check_delete_during_image_upload(self, is_admin=False):"
            },
            "6": {
                "beforePatchRowNumber": 1746,
                "afterPatchRowNumber": 1745,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 1747,
                "afterPatchRowNumber": 1746,
                "PatchRowcode": "         fixture_headers = {'x-image-meta-store': 'file',"
            },
            "8": {
                "beforePatchRowNumber": 1748,
                "afterPatchRowNumber": 1747,
                "PatchRowcode": "                            'x-image-meta-disk-format': 'vhd',"
            },
            "9": {
                "beforePatchRowNumber": 1749,
                "afterPatchRowNumber": 1748,
                "PatchRowcode": "                            'x-image-meta-container-format': 'ovf',"
            },
            "10": {
                "beforePatchRowNumber": 1750,
                "afterPatchRowNumber": 1749,
                "PatchRowcode": "                            'x-image-meta-name': 'fake image #3',"
            },
            "11": {
                "beforePatchRowNumber": 1751,
                "afterPatchRowNumber": 1750,
                "PatchRowcode": "                            'x-image-meta-property-key1': 'value1'}"
            },
            "12": {
                "beforePatchRowNumber": 1752,
                "afterPatchRowNumber": 1751,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 1753,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = webob.Request.blank(\"/images\")"
            },
            "14": {
                "beforePatchRowNumber": 1754,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req.method = 'POST'"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1752,
                "PatchRowcode": "+        req = unit_test_utils.get_fake_request(path=\"/images\","
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1753,
                "PatchRowcode": "+                                               is_admin=is_admin)"
            },
            "17": {
                "beforePatchRowNumber": 1755,
                "afterPatchRowNumber": 1754,
                "PatchRowcode": "         for k, v in six.iteritems(fixture_headers):"
            },
            "18": {
                "beforePatchRowNumber": 1756,
                "afterPatchRowNumber": 1755,
                "PatchRowcode": "             req.headers[k] = v"
            },
            "19": {
                "beforePatchRowNumber": 1757,
                "afterPatchRowNumber": 1756,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 1776,
                "afterPatchRowNumber": 1775,
                "PatchRowcode": "                        mock_initiate_deletion)"
            },
            "21": {
                "beforePatchRowNumber": 1777,
                "afterPatchRowNumber": 1776,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 1778,
                "afterPatchRowNumber": 1777,
                "PatchRowcode": "         orig_update_image_metadata = registry.update_image_metadata"
            },
            "23": {
                "beforePatchRowNumber": 1779,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ctlr = glance.api.v1.controller.BaseController"
            },
            "24": {
                "beforePatchRowNumber": 1780,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        orig_get_image_meta_or_404 = ctlr.get_image_meta_or_404"
            },
            "25": {
                "beforePatchRowNumber": 1781,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 1782,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        def mock_update_image_metadata(*args, **kwargs):"
            },
            "27": {
                "beforePatchRowNumber": 1783,
                "afterPatchRowNumber": 1778,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 1784,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if args[2].get('status', None) == 'deleted':"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1779,
                "PatchRowcode": "+        data = \"somedata\""
            },
            "30": {
                "beforePatchRowNumber": 1785,
                "afterPatchRowNumber": 1780,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 1786,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # One shot."
            },
            "32": {
                "beforePatchRowNumber": 1787,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                def mock_get_image_meta_or_404(*args, **kwargs):"
            },
            "33": {
                "beforePatchRowNumber": 1788,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ret = orig_get_image_meta_or_404(*args, **kwargs)"
            },
            "34": {
                "beforePatchRowNumber": 1789,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ret['status'] = 'queued'"
            },
            "35": {
                "beforePatchRowNumber": 1790,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    self.stubs.Set(ctlr, 'get_image_meta_or_404',"
            },
            "36": {
                "beforePatchRowNumber": 1791,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   orig_get_image_meta_or_404)"
            },
            "37": {
                "beforePatchRowNumber": 1792,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return ret"
            },
            "38": {
                "beforePatchRowNumber": 1793,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 1794,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.stubs.Set(ctlr, 'get_image_meta_or_404',"
            },
            "40": {
                "beforePatchRowNumber": 1795,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                               mock_get_image_meta_or_404)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1781,
                "PatchRowcode": "+        def mock_update_image_metadata(*args, **kwargs):"
            },
            "42": {
                "beforePatchRowNumber": 1796,
                "afterPatchRowNumber": 1782,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 1797,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req = webob.Request.blank(\"/images/%s\" % image_id)"
            },
            "44": {
                "beforePatchRowNumber": 1798,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req.method = 'PUT'"
            },
            "45": {
                "beforePatchRowNumber": 1799,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req.headers['Content-Type'] = 'application/octet-stream'"
            },
            "46": {
                "beforePatchRowNumber": 1800,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req.body = \"somedata\""
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1783,
                "PatchRowcode": "+            if args[2].get('size', None) == len(data):"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1784,
                "PatchRowcode": "+                path = \"/images/%s\" % image_id"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1785,
                "PatchRowcode": "+                req = unit_test_utils.get_fake_request(path=path,"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1786,
                "PatchRowcode": "+                                                       method='DELETE',"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1787,
                "PatchRowcode": "+                                                       is_admin=is_admin)"
            },
            "52": {
                "beforePatchRowNumber": 1801,
                "afterPatchRowNumber": 1788,
                "PatchRowcode": "                 res = req.get_response(self.api)"
            },
            "53": {
                "beforePatchRowNumber": 1802,
                "afterPatchRowNumber": 1789,
                "PatchRowcode": "                 self.assertEqual(200, res.status_int)"
            },
            "54": {
                "beforePatchRowNumber": 1803,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.assertFalse(res.location)"
            },
            "55": {
                "beforePatchRowNumber": 1804,
                "afterPatchRowNumber": 1790,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 1805,
                "afterPatchRowNumber": 1791,
                "PatchRowcode": "                 self.stubs.Set(registry, 'update_image_metadata',"
            },
            "57": {
                "beforePatchRowNumber": 1806,
                "afterPatchRowNumber": 1792,
                "PatchRowcode": "                                orig_update_image_metadata)"
            },
            "58": {
                "beforePatchRowNumber": 1810,
                "afterPatchRowNumber": 1796,
                "PatchRowcode": "         self.stubs.Set(registry, 'update_image_metadata',"
            },
            "59": {
                "beforePatchRowNumber": 1811,
                "afterPatchRowNumber": 1797,
                "PatchRowcode": "                        mock_update_image_metadata)"
            },
            "60": {
                "beforePatchRowNumber": 1812,
                "afterPatchRowNumber": 1798,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 1813,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = webob.Request.blank(\"/images/%s\" % image_id)"
            },
            "62": {
                "beforePatchRowNumber": 1814,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req.method = 'DELETE'"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1799,
                "PatchRowcode": "+        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1800,
                "PatchRowcode": "+                                               method='PUT')"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1801,
                "PatchRowcode": "+        req.headers['Content-Type'] = 'application/octet-stream'"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1802,
                "PatchRowcode": "+        req.body = data"
            },
            "67": {
                "beforePatchRowNumber": 1815,
                "afterPatchRowNumber": 1803,
                "PatchRowcode": "         res = req.get_response(self.api)"
            },
            "68": {
                "beforePatchRowNumber": 1816,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(200, res.status_int)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1804,
                "PatchRowcode": "+        self.assertEqual(412, res.status_int)"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1805,
                "PatchRowcode": "+        self.assertFalse(res.location)"
            },
            "71": {
                "beforePatchRowNumber": 1817,
                "afterPatchRowNumber": 1806,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 1818,
                "afterPatchRowNumber": 1807,
                "PatchRowcode": "         self.assertTrue(called['initiate_deletion'])"
            },
            "73": {
                "beforePatchRowNumber": 1819,
                "afterPatchRowNumber": 1808,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 1820,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = webob.Request.blank(\"/images/%s\" % image_id)"
            },
            "75": {
                "beforePatchRowNumber": 1821,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req.method = 'HEAD'"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1809,
                "PatchRowcode": "+        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1810,
                "PatchRowcode": "+                                               method='HEAD',"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1811,
                "PatchRowcode": "+                                               is_admin=True)"
            },
            "79": {
                "beforePatchRowNumber": 1822,
                "afterPatchRowNumber": 1812,
                "PatchRowcode": "         res = req.get_response(self.api)"
            },
            "80": {
                "beforePatchRowNumber": 1823,
                "afterPatchRowNumber": 1813,
                "PatchRowcode": "         self.assertEqual(200, res.status_int)"
            },
            "81": {
                "beforePatchRowNumber": 1824,
                "afterPatchRowNumber": 1814,
                "PatchRowcode": "         self.assertEqual('True', res.headers['x-image-meta-deleted'])"
            },
            "82": {
                "beforePatchRowNumber": 1825,
                "afterPatchRowNumber": 1815,
                "PatchRowcode": "         self.assertEqual('deleted', res.headers['x-image-meta-status'])"
            },
            "83": {
                "beforePatchRowNumber": 1826,
                "afterPatchRowNumber": 1816,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1817,
                "PatchRowcode": "+    def test_delete_during_image_upload_by_normal_user(self):"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1818,
                "PatchRowcode": "+        self._check_delete_during_image_upload(is_admin=False)"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1819,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1820,
                "PatchRowcode": "+    def test_delete_during_image_upload_by_admin(self):"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1821,
                "PatchRowcode": "+        self._check_delete_during_image_upload(is_admin=True)"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1822,
                "PatchRowcode": "+"
            },
            "90": {
                "beforePatchRowNumber": 1827,
                "afterPatchRowNumber": 1823,
                "PatchRowcode": "     def test_disable_purge_props(self):"
            },
            "91": {
                "beforePatchRowNumber": 1828,
                "afterPatchRowNumber": 1824,
                "PatchRowcode": "         \"\"\""
            },
            "92": {
                "beforePatchRowNumber": 1829,
                "afterPatchRowNumber": 1825,
                "PatchRowcode": "         Test the special x-glance-registry-purge-props header controls"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import contextlib",
            "import copy",
            "import datetime",
            "import hashlib",
            "import uuid",
            "",
            "import glance_store as store",
            "import mock",
            "from oslo.config import cfg",
            "from oslo.serialization import jsonutils",
            "from oslo.utils import timeutils",
            "import routes",
            "import six",
            "import webob",
            "",
            "import glance.api",
            "import glance.api.common",
            "from glance.api.v1 import router",
            "from glance.api.v1 import upload_utils",
            "import glance.common.config",
            "from glance.common import exception",
            "import glance.context",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.db.sqlalchemy import models as db_models",
            "import glance.registry.client.v1.api as registry",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "_gen_uuid = lambda: str(uuid.uuid4())",
            "",
            "UUID1 = _gen_uuid()",
            "UUID2 = _gen_uuid()",
            "",
            "",
            "class TestGlanceAPI(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestGlanceAPI, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        self.FIXTURES = [",
            "            {'id': UUID1,",
            "             'name': 'fake image #1',",
            "             'status': 'active',",
            "             'disk_format': 'ami',",
            "             'container_format': 'ami',",
            "             'is_public': False,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': None,",
            "             'size': 13,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID1),",
            "                            'metadata': {}, 'status': 'active'}],",
            "             'properties': {'type': 'kernel'}},",
            "            {'id': UUID2,",
            "             'name': 'fake image #2',",
            "             'status': 'active',",
            "             'disk_format': 'vhd',",
            "             'container_format': 'ovf',",
            "             'is_public': True,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': 'abc123',",
            "             'size': 19,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID2),",
            "                            'metadata': {}, 'status': 'active'}],",
            "             'properties': {}}]",
            "        self.context = glance.context.RequestContext(is_admin=True)",
            "        db_api.get_engine()",
            "        self.destroy_fixtures()",
            "        self.create_fixtures()",
            "        # Used to store/track image status changes for post-analysis",
            "        self.image_status = []",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestGlanceAPI, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def create_fixtures(self):",
            "        for fixture in self.FIXTURES:",
            "            db_api.image_create(self.context, fixture)",
            "            # We write a fake image file to the filesystem",
            "            with open(\"%s/%s\" % (self.test_dir, fixture['id']), 'wb') as image:",
            "                image.write(\"chunk00000remainder\")",
            "                image.flush()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _do_test_defaulted_format(self, format_key, format_value):",
            "        fixture_headers = {'x-image-meta-name': 'defaulted',",
            "                           'x-image-meta-location': 'http://localhost:0/image',",
            "                           format_key: format_value}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "            res_body = jsonutils.loads(res.body)['image']",
            "            self.assertEqual(format_value, res_body['disk_format'])",
            "            self.assertEqual(format_value, res_body['container_format'])",
            "",
            "    def test_defaulted_amazon_format(self):",
            "        for key in ('x-image-meta-disk-format',",
            "                    'x-image-meta-container-format'):",
            "            for value in ('aki', 'ari', 'ami'):",
            "                self._do_test_defaulted_format(key, value)",
            "",
            "    def test_bad_min_disk_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-disk': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_min_disk_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-disk'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_min_ram_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-ram': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_min_ram_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-ram'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_disk_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'invalid',",
            "            'x-image-meta-container-format': 'ami',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid disk format', res.body)",
            "",
            "    def test_configured_disk_format_good(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'foo',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "",
            "    def test_configured_disk_format_bad(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'bar',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid disk format', res.body)",
            "",
            "    def test_configured_container_format_good(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'foo',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "",
            "    def test_configured_container_format_bad(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'bar',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_container_and_disk_amazon_format_differs(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'aki',",
            "            'x-image-meta-container-format': 'ami'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        expected = (\"Invalid mix of disk and container formats. \"",
            "                    \"When setting a disk or container format to one of \"",
            "                    \"'aki', 'ari', or 'ami', \"",
            "                    \"the container and disk formats must match.\")",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn(expected, res.body)",
            "",
            "    def test_create_with_location_no_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(400, res.status_int)",
            "            self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_create_with_bad_store_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Required store bad is invalid', res.body)",
            "",
            "    def test_create_with_location_get_store_or_400_raises_exception(self):",
            "        location = 'bad+scheme://localhost:0/image.qcow2'",
            "        scheme = 'bad+scheme'",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': location,",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        ctlr = glance.api.v1.images.Controller",
            "",
            "        with contextlib.nested(",
            "                mock.patch.object(ctlr, '_external_source',",
            "                                  return_value=location),",
            "                mock.patch.object(store,",
            "                                  'get_store_from_location',",
            "                                  return_value=scheme)",
            "        ) as (",
            "            mock_external_source,",
            "            mock_get_store_from_location",
            "        ):",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(400, res.status_int)",
            "            self.assertEqual(1, mock_external_source.call_count)",
            "            self.assertEqual(1, mock_get_store_from_location.call_count)",
            "            self.assertIn('Store for scheme %s not found' % scheme, res.body)",
            "",
            "    def test_create_with_location_unknown_scheme(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'bad+scheme://localhost:0/image.qcow2',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('External source are not supported', res.body)",
            "",
            "    def test_create_with_location_bad_store_uri(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'file',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid location', res.body)",
            "",
            "    def test_create_image_with_too_many_properties(self):",
            "        self.config(image_property_quota=1)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images', method='POST')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(413, output.status_int)",
            "",
            "    def test_bad_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'invalid',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_bad_image_size(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        def exec_bad_size_test(bad_size, expected_substr):",
            "            fixture_headers['x-image-meta-size'] = bad_size",
            "            req = webob.Request.blank(\"/images\",",
            "                                      method='POST',",
            "                                      headers=fixture_headers)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(400, res.status_int)",
            "            self.assertIn(expected_substr, res.body)",
            "",
            "        expected = \"Cannot convert image size 'invalid' to an integer.\"",
            "        exec_bad_size_test('invalid', expected)",
            "        expected = \"Image size must be >= 0 ('-10' specified).\"",
            "        exec_bad_size_test(-10, expected)",
            "",
            "    def test_bad_image_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'X' * 256,",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_no_location_no_image_as_body(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://localhost:0/images/123'",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        # Once the location is set, the image should be activated",
            "        # see LP Bug #939484",
            "        self.assertEqual('active', res_body['status'])",
            "        self.assertNotIn('location', res_body)  # location never shown",
            "",
            "    def test_add_image_no_location_no_content_type(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1,",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_size_header_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=str(quota))",
            "        fixture_headers = {'x-image-meta-size': quota + 1,",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-container_format': 'bare',",
            "                           'x-image-meta-disk_format': 'qcow2',",
            "                           'content-type': 'application/octet-stream',",
            "                           }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        req.body = 'X' * (quota + 1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_image_size_data_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=str(quota))",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_image_size_data_exceed_quota_readd(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=str(quota))",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "        used_size = sum([f['size'] for f in self.FIXTURES])",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota - used_size)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "    def _add_check_no_url_info(self):",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertNotIn('locations', res_body)",
            "        self.assertNotIn('direct_url', res_body)",
            "        image_id = res_body['id']",
            "",
            "        # HEAD empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertNotIn('x-image-meta-locations', res.headers)",
            "        self.assertNotIn('x-image-meta-direct_url', res.headers)",
            "",
            "    def test_add_check_no_url_info_ml(self):",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_direct_url(self):",
            "        self.config(show_image_direct_url=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_on(self):",
            "        self.config(show_image_direct_url=True)",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_off(self):",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_image_zero_size(self):",
            "        \"\"\"Tests creating an active image with explicitly zero size\"\"\"",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # GET empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(0, len(res.body))",
            "",
            "    def _do_test_add_image_attribute_mismatch(self, attributes):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "        }",
            "        fixture_headers.update(attributes)",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"XXXX\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_checksum_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_checksum_and_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_bad_store(self):",
            "        \"\"\"Tests raises BadRequest for invalid store header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'bad',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_basic_file_store(self):",
            "        \"\"\"Tests to add a basic image in the file store\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        # Test that the Location: header is set to the URI to",
            "        # edit the newly-created image, as required by APP.",
            "        # See LP Bug #719825",
            "        self.assertTrue('location' in res.headers,",
            "                        \"'location' not in response headers.\\n\"",
            "                        \"res.headerlist = %r\" % res.headerlist)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertIn('/images/%s' % res_body['id'], res.headers['location'])",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are NOT able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://example.com/images/123'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_unauthorized(self):",
            "        rules = {\"add_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_publicize_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_publicize_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "    def test_add_copy_from_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_copy_from_image_authorized_upload_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "    def test_add_copy_from_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from copy-from and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_location_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from location and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_location_with_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as size:",
            "            size.return_value = 2",
            "",
            "            for k, v in six.iteritems(fixture_headers):",
            "                req.headers[k] = v",
            "",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 409)",
            "",
            "    def test_add_location_with_invalid_location_on_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_location_with_invalid_location_on_restricted_sources(self):",
            "        \"\"\"Tests creates an image from location and restricted sources\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'file:///etc/passwd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'swift+config://xxx',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_with_location(self):",
            "        \"\"\"Tests creates an image from copy-from and location\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_with_restricted_sources(self):",
            "        \"\"\"Tests creates an image from copy-from with restricted sources\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'file:///etc/passwd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'swift+config://xxx',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized_with_body(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_data_upload_bad_store_uri(self):",
            "        fixture_headers = {'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.headers['x-image-meta-location'] = 'http://'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid location', res.body)",
            "",
            "    def test_update_data_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['transfer-encoding'] = 'chunked'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_copy_from_unauthorized(self):",
            "        rules = {\"upload_image\": '@', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def _do_test_post_image_content_missing_format(self, missing):",
            "        \"\"\"Tests creation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_post_image_content_missing_disk_format(self):",
            "        \"\"\"Tests creation of an image with missing disk format\"\"\"",
            "        self._do_test_post_image_content_missing_format('disk_format')",
            "",
            "    def test_post_image_content_missing_container_type(self):",
            "        \"\"\"Tests creation of an image with missing container format\"\"\"",
            "        self._do_test_post_image_content_missing_format('container_format')",
            "",
            "    def _do_test_put_image_content_missing_format(self, missing):",
            "        \"\"\"Tests delayed activation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_put_image_content_missing_disk_format(self):",
            "        \"\"\"Tests delayed activation of image with missing disk format\"\"\"",
            "        self._do_test_put_image_content_missing_format('disk_format')",
            "",
            "    def test_put_image_content_missing_container_type(self):",
            "        \"\"\"Tests delayed activation of image with missing container format\"\"\"",
            "        self._do_test_put_image_content_missing_format('container_format')",
            "",
            "    def test_update_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to update a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        fixture = {'name': 'test_del_img'}",
            "        req = webob.Request.blank('/images/%s' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "        self.assertIn('Forbidden to update deleted image', res.body)",
            "",
            "    def test_delete_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to delete a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the status is 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "        msg = \"Image %s not found.\" % UUID2",
            "        self.assertIn(msg, res.body)",
            "",
            "        # Verify the status is still 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "    def test_image_status_when_delete_fails(self):",
            "        \"\"\"",
            "        Tests that the image status set to active if deletion of image fails.",
            "        \"\"\"",
            "",
            "        fs = store.get_store_from_scheme('file')",
            "",
            "        with mock.patch.object(fs, 'delete') as mock_fsstore_delete:",
            "            mock_fsstore_delete.side_effect = exception.Forbidden()",
            "",
            "            # trigger the v1 delete api",
            "            req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(403, res.status_int)",
            "            self.assertTrue('Forbidden to delete image' in res.body)",
            "",
            "            # check image metadata is still there with active state",
            "            req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "            req.method = 'HEAD'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "            self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_pending_delete_image(self):",
            "        \"\"\"",
            "        Tests that correct response returned when deleting",
            "        a pending_delete image",
            "        \"\"\"",
            "        # First deletion",
            "        self.config(delayed_delete=True, scrubber_datadir='/tmp/scrubber')",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the status is 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "        # Second deletion",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "        self.assertIn('Forbidden to delete a pending_delete image', res.body)",
            "",
            "        # Verify the status is still 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_to_image_status_saving(self):",
            "        \"\"\"Test image upload conflict.",
            "",
            "        If an image is uploaded before an existing upload to the same image",
            "        completes, the original upload should succeed and the conflicting",
            "        one should fail and any data be deleted.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'some-foo-image'}",
            "",
            "        # create an image but don't upload yet.",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        orig_get_image_metadata = registry.get_image_metadata",
            "        orig_image_get = db_api._image_get",
            "        orig_image_update = db_api._image_update",
            "        orig_initiate_deletion = upload_utils.initiate_deletion",
            "",
            "        # this will be used to track what is called and their order.",
            "        call_sequence = []",
            "        # use this to determine if we are within a db session i.e. atomic",
            "        # operation, that is setting our active state.",
            "        test_status = {'activate_session_started': False}",
            "        # We want first status check to be 'queued' so we get past the first",
            "        # guard.",
            "        test_status['queued_guard_passed'] = False",
            "",
            "        state_changes = []",
            "",
            "        def mock_image_update(context, values, image_id, purge_props=False,",
            "                              from_state=None):",
            "",
            "            status = values.get('status')",
            "            if status:",
            "                state_changes.append(status)",
            "                if status == 'active':",
            "                    # We only expect this state to be entered once.",
            "                    if test_status['activate_session_started']:",
            "                        raise Exception(\"target session already started\")",
            "",
            "                    test_status['activate_session_started'] = True",
            "                    call_sequence.append('update_active')",
            "",
            "                else:",
            "                    call_sequence.append('update')",
            "",
            "            return orig_image_update(context, values, image_id,",
            "                                     purge_props=purge_props,",
            "                                     from_state=from_state)",
            "",
            "        def mock_image_get(*args, **kwargs):",
            "            \"\"\"Force status to 'saving' if not within activate db session.",
            "",
            "            If we are in the activate db session we return 'active' which we",
            "            then expect to cause exception.Conflict to be raised since this",
            "            indicates that another upload has succeeded.",
            "            \"\"\"",
            "            image = orig_image_get(*args, **kwargs)",
            "            if test_status['activate_session_started']:",
            "                call_sequence.append('image_get_active')",
            "                setattr(image, 'status', 'active')",
            "            else:",
            "                setattr(image, 'status', 'saving')",
            "",
            "            return image",
            "",
            "        def mock_get_image_metadata(*args, **kwargs):",
            "            \"\"\"Force image status sequence.",
            "            \"\"\"",
            "            call_sequence.append('get_image_meta')",
            "            meta = orig_get_image_metadata(*args, **kwargs)",
            "            if not test_status['queued_guard_passed']:",
            "                meta['status'] = 'queued'",
            "                test_status['queued_guard_passed'] = True",
            "",
            "            return meta",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            call_sequence.append('init_del')",
            "            orig_initiate_deletion(*args, **kwargs)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "",
            "        with mock.patch.object(",
            "                upload_utils, 'initiate_deletion') as mock_init_del:",
            "            mock_init_del.side_effect = mock_initiate_deletion",
            "            with mock.patch.object(",
            "                    registry, 'get_image_metadata') as mock_get_meta:",
            "                mock_get_meta.side_effect = mock_get_image_metadata",
            "                with mock.patch.object(db_api, '_image_get') as mock_db_get:",
            "                    mock_db_get.side_effect = mock_image_get",
            "                    with mock.patch.object(",
            "                            db_api, '_image_update') as mock_db_update:",
            "                        mock_db_update.side_effect = mock_image_update",
            "",
            "                        # Expect a 409 Conflict.",
            "                        res = req.get_response(self.api)",
            "                        self.assertEqual(409, res.status_int)",
            "",
            "                        # Check expected call sequence",
            "                        self.assertEqual(['get_image_meta', 'get_image_meta',",
            "                                          'update', 'update_active',",
            "                                          'image_get_active',",
            "                                          'init_del'],",
            "                                         call_sequence)",
            "",
            "                        self.assertTrue(mock_get_meta.called)",
            "                        self.assertTrue(mock_db_get.called)",
            "                        self.assertTrue(mock_db_update.called)",
            "",
            "                        # Ensure cleanup occured.",
            "                        self.assertEqual(1, mock_init_del.call_count)",
            "",
            "                        self.assertEqual(state_changes, ['saving', 'active'])",
            "",
            "    def test_register_and_upload(self):",
            "        \"\"\"",
            "        Test that the process of registering an image with",
            "        some metadata, then uploading an image file with some",
            "        more metadata doesn't mark the original metadata deleted",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertIn('status', res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertIn('properties', res_body)",
            "        self.assertIn('key1', res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now upload the image file along with some more",
            "        # metadata and verify original metadata properties",
            "        # are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the status is 'queued'",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertTrue('x-image-meta-property-key1' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_image_raises_store_disabled(self):",
            "        \"\"\"Test that uploading an image file returns HTTTP 410 response\"\"\"",
            "        # create image",
            "        fs = store.get_store_from_scheme('file')",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertIn('status', res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now upload the image file",
            "        with mock.patch.object(fs, 'add') as mock_fsstore_add:",
            "            mock_fsstore_add.side_effect = store.StoreAddDisabled",
            "            req = webob.Request.blank(\"/images/%s\" % image_id)",
            "            req.method = 'PUT'",
            "            req.headers['Content-Type'] = 'application/octet-stream'",
            "            req.body = \"chunk00000remainder\"",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(410, res.status_int)",
            "            self._verify_image_status(image_id, 'killed')",
            "",
            "    def _get_image_status(self, image_id):",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        return req.get_response(self.api)",
            "",
            "    def _verify_image_status(self, image_id, status, check_deleted=False,",
            "                             use_cached=False):",
            "        if not use_cached:",
            "            res = self._get_image_status(image_id)",
            "        else:",
            "            res = self.image_status.pop(0)",
            "",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(status, res.headers['x-image-meta-status'])",
            "        self.assertEqual(str(check_deleted),",
            "                         res.headers['x-image-meta-deleted'])",
            "",
            "    def _upload_safe_kill_common(self, mocks):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        self.image_id = res_body['id']",
            "        self.assertTrue('/images/%s' %",
            "                        self.image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        for m in mocks:",
            "            m['mock'].side_effect = m['side_effect']",
            "",
            "        # Now upload the image file along with some more metadata and",
            "        # verify original metadata properties are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        # We expect 500 since an exception occured during upload.",
            "        self.assertEqual(500, res.status_int)",
            "",
            "    @mock.patch('glance_store.store_add_to_backend')",
            "    def test_upload_safe_kill(self, mock_store_add_to_backend):",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"Trigger mid-upload failure by raising an exception.\"\"\"",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "            # Raise an exception to emulate failed upload.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'killed'",
            "        self._verify_image_status(self.image_id, 'saving', use_cached=True)",
            "        self._verify_image_status(self.image_id, 'killed')",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    @mock.patch('glance_store.store_add_to_backend')",
            "    def test_upload_safe_kill_deleted(self, mock_store_add_to_backend):",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router_api,",
            "                                                 is_admin=True)",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"We now delete the image, assert status is 'deleted' then",
            "            raise an exception to emulate a failed upload. This will be caught",
            "            by upload_data_to_store() which will then try to set status to",
            "            'killed' which will be ignored since the image has been deleted.",
            "            \"\"\"",
            "            # expect 'saving'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "            # expect 'deleted'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            # Raise an exception to make the upload fail.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'deleted' -> 'deleted'",
            "        self._verify_image_status(self.image_id, 'saving', check_deleted=False,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True)",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    def test_delete_during_image_upload(self):",
            "        req = unit_test_utils.get_fake_request()",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        called = {'initiate_deletion': False}",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            called['initiate_deletion'] = True",
            "",
            "        self.stubs.Set(glance.api.v1.upload_utils, 'initiate_deletion',",
            "                       mock_initiate_deletion)",
            "",
            "        orig_update_image_metadata = registry.update_image_metadata",
            "        ctlr = glance.api.v1.controller.BaseController",
            "        orig_get_image_meta_or_404 = ctlr.get_image_meta_or_404",
            "",
            "        def mock_update_image_metadata(*args, **kwargs):",
            "",
            "            if args[2].get('status', None) == 'deleted':",
            "",
            "                # One shot.",
            "                def mock_get_image_meta_or_404(*args, **kwargs):",
            "                    ret = orig_get_image_meta_or_404(*args, **kwargs)",
            "                    ret['status'] = 'queued'",
            "                    self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                                   orig_get_image_meta_or_404)",
            "                    return ret",
            "",
            "                self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                               mock_get_image_meta_or_404)",
            "",
            "                req = webob.Request.blank(\"/images/%s\" % image_id)",
            "                req.method = 'PUT'",
            "                req.headers['Content-Type'] = 'application/octet-stream'",
            "                req.body = \"somedata\"",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "                self.assertFalse(res.location)",
            "",
            "                self.stubs.Set(registry, 'update_image_metadata',",
            "                               orig_update_image_metadata)",
            "",
            "            return orig_update_image_metadata(*args, **kwargs)",
            "",
            "        self.stubs.Set(registry, 'update_image_metadata',",
            "                       mock_update_image_metadata)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        self.assertTrue(called['initiate_deletion'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_disable_purge_props(self):",
            "        \"\"\"",
            "        Test the special x-glance-registry-purge-props header controls",
            "        the purge property behaviour of the registry.",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertIn('status', res_body)",
            "        self.assertEqual('active', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertIn('properties', res_body)",
            "        self.assertIn('key1', res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now update the image, setting new properties without",
            "        # passing the x-glance-registry-purge-props header and",
            "        # verify that original properties are marked deleted.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the original property no longer in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertFalse('x-image-meta-property-key1' in res.headers,",
            "                         \"Found property in headers that was not expected. \"",
            "                         \"Got headers: %r\" % res.headers)",
            "",
            "        # Now update the image, setting new properties and",
            "        # passing the x-glance-registry-purge-props header with",
            "        # a value of \"false\" and verify that second property",
            "        # still appears in headers.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key3'] = 'value3'",
            "        req.headers['x-glance-registry-purge-props'] = 'false'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the second and third property in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertTrue('x-image-meta-property-key3' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "",
            "    def test_publicize_image_unauthorized(self):",
            "        \"\"\"Create a non-public image then fail to make public\"\"\"",
            "        rules = {\"add_image\": '@', \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'false',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-is-public'] = 'true'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1}",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_update_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        fixture_headers = {'content-type': 'application/octet-stream'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_update_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        # Create new image that has no data",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.headers['x-image-meta-name'] = 'something'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        res = req.get_response(self.api)",
            "        image_id = jsonutils.loads(res.body)['image']['id']",
            "",
            "        fixture_headers = {",
            "            'content-type': 'application/octet-stream',",
            "            'transfer-encoding': 'chunked',",
            "        }",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_update_non_existing_image(self):",
            "        self.config(image_size_cap=100)",
            "",
            "        req = webob.Request.blank(\"images/%s\" % _gen_uuid)",
            "        req.method = 'PUT'",
            "        req.body = 'test'",
            "        req.headers['x-image-meta-name'] = 'test'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        req.headers['x-image-meta-is_public'] = 'False'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_update_public_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-name'] = 'updated public image'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "    def test_add_image_wrong_content_type(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-st',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_get_index_sort_name_asc(self):",
            "        \"\"\"",
            "        Tests that the /images registry API returns list of",
            "        public images sorted alphabetically by name in",
            "        ascending order.",
            "        \"\"\"",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'asdf',",
            "                         'size': 19,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'xyz',",
            "                         'size': 20,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        req = webob.Request.blank('/images?sort_key=name&sort_dir=asc')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "",
            "        images = res_dict['images']",
            "        self.assertEqual(3, len(images))",
            "        self.assertEqual(UUID3, images[0]['id'])",
            "        self.assertEqual(UUID2, images[1]['id'])",
            "        self.assertEqual(UUID4, images[2]['id'])",
            "",
            "    def test_get_details_filter_changes_since(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns list of",
            "        public images that have a size less than or equal to size_max",
            "        \"\"\"",
            "        dt1 = timeutils.utcnow() - datetime.timedelta(1)",
            "        iso1 = timeutils.isotime(dt1)",
            "",
            "        date_only1 = dt1.strftime('%Y-%m-%d')",
            "        date_only2 = dt1.strftime('%Y%m%d')",
            "        date_only3 = dt1.strftime('%Y-%m%d')",
            "",
            "        dt2 = timeutils.utcnow() + datetime.timedelta(1)",
            "        iso2 = timeutils.isotime(dt2)",
            "",
            "        image_ts = timeutils.utcnow() + datetime.timedelta(2)",
            "        hour_before = image_ts.strftime('%Y-%m-%dT%H:%M:%S%%2B01:00')",
            "        hour_after = image_ts.strftime('%Y-%m-%dT%H:%M:%S-01:00')",
            "",
            "        dt4 = timeutils.utcnow() + datetime.timedelta(3)",
            "        iso4 = timeutils.isotime(dt4)",
            "",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'fake image #3',",
            "                         'size': 18,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "        db_api.image_destroy(self.context, UUID3)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'fake image #4',",
            "                         'size': 20,",
            "                         'checksum': None,",
            "                         'created_at': image_ts,",
            "                         'updated_at': image_ts}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Check a standard list, 4 images in db (2 deleted)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(2, len(images))",
            "        self.assertEqual(UUID4, images[0]['id'])",
            "        self.assertEqual(UUID2, images[1]['id'])",
            "",
            "        # Expect 3 images (1 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(3, len(images))",
            "        self.assertEqual(UUID4, images[0]['id'])",
            "        self.assertEqual(UUID3, images[1]['id'])  # deleted",
            "        self.assertEqual(UUID2, images[2]['id'])",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(UUID4, images[0]['id'])",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_before)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_after)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso4)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        for param in [date_only1, date_only2, date_only3]:",
            "            # Expect 3 images (1 deleted)",
            "            req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                      param)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "            res_dict = jsonutils.loads(res.body)",
            "            images = res_dict['images']",
            "            self.assertEqual(3, len(images))",
            "            self.assertEqual(images[0]['id'], UUID4)",
            "            self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "            self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Bad request (empty changes-since param)",
            "        req = webob.Request.blank('/images/detail?changes-since=')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_get_images_bad_urls(self):",
            "        \"\"\"Check that routes collections are not on (LP bug 1185828)\"\"\"",
            "        req = webob.Request.blank('/images/detail.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "        req = webob.Request.blank('/images.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/new')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members.xxx\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_get_index_filter_on_user_defined_properties(self):",
            "        \"\"\"Check that image filtering works on user-defined properties\"\"\"",
            "",
            "        image1_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'i386'}",
            "        extra_fixture = {'id': image1_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'image-extra-1',",
            "                         'size': 18, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        image2_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'x86_64', 'foo': 'bar'}",
            "        extra_fixture = {'id': image2_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'image-extra-2',",
            "                         'size': 20, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Test index with filter containing one user-defined property.",
            "        # Filter is 'property-distro=ubuntu'.",
            "        # Verify both image1 and image2 are returned",
            "        req = webob.Request.blank('/images?property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(2, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # non-existent value. Filter is 'property-distro=fedora'.",
            "        # Verify neither images are returned",
            "        req = webob.Request.blank('/images?property-distro=fedora')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=i386'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=x86_64'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property.",
            "        # Filter is 'property-foo=bar'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-foo=bar')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property but",
            "        # .value is non-existent. Filter is 'property-foo=baz'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=baz')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=x86_64&property-distro=ubuntu'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=i386&property-distro=ubuntu'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=ubuntu'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=random'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=random')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-boo=far&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-boo=far&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-foo=bar&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=bar&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "    def test_get_images_detailed_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_get_images_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_store_location_not_revealed(self):",
            "        \"\"\"",
            "        Test that the internal store location is NOT revealed",
            "        through the API server",
            "        \"\"\"",
            "        # Check index and details...",
            "        for url in ('/images', '/images/detail'):",
            "            req = webob.Request.blank(url)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "            res_dict = jsonutils.loads(res.body)",
            "",
            "            images = res_dict['images']",
            "            num_locations = sum([1 for record in images",
            "                                if 'location' in record.keys()])",
            "            self.assertEqual(0, num_locations, images)",
            "",
            "        # Check GET",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertNotIn('X-Image-Meta-Location', res.headers)",
            "",
            "        # Check HEAD",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertNotIn('X-Image-Meta-Location', res.headers)",
            "",
            "        # Check PUT",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.body = res.body",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_body = jsonutils.loads(res.body)",
            "        self.assertNotIn('location', res_body['image'])",
            "",
            "        # Check POST",
            "        req = webob.Request.blank(\"/images\")",
            "        headers = {'x-image-meta-location': 'http://localhost',",
            "                   'x-image-meta-disk-format': 'vhd',",
            "                   'x-image-meta-container-format': 'ovf',",
            "                   'x-image-meta-name': 'fake image #3'}",
            "        for k, v in six.iteritems(headers):",
            "            req.headers[k] = v",
            "        req.method = 'POST'",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as size:",
            "            size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "            res_body = jsonutils.loads(res.body)",
            "            self.assertNotIn('location', res_body['image'])",
            "",
            "    def test_image_is_checksummed(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual(image_checksum, res_body['checksum'],",
            "                         \"Mismatched checksum. Expected %s, got %s\" %",
            "                         (image_checksum, res_body['checksum']))",
            "",
            "    def test_etag_equals_checksum_header(self):",
            "        \"\"\"Test that the ETag header matches the x-image-meta-checksum\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        image = jsonutils.loads(res.body)['image']",
            "",
            "        # HEAD the image and check the ETag equals the checksum header...",
            "        expected_headers = {'x-image-meta-checksum': image_checksum,",
            "                            'etag': image_checksum}",
            "        req = webob.Request.blank(\"/images/%s\" % image['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        for key in expected_headers.keys():",
            "            self.assertTrue(key in res.headers,",
            "                            \"required header '%s' missing from \"",
            "                            \"returned headers\" % key)",
            "        for key, value in six.iteritems(expected_headers):",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_bad_checksum_prevents_image_creation(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        image_contents = \"chunk00000remainder\"",
            "        bad_checksum = hashlib.md5(\"invalid\").hexdigest()",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-checksum': bad_checksum,",
            "                           'x-image-meta-is-public': 'true'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        # Test that only one image was returned (that already exists)",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "",
            "    def test_image_meta(self):",
            "        \"\"\"Test for HEAD /images/<ID>\"\"\"",
            "        expected_headers = {'x-image-meta-id': UUID2,",
            "                            'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertFalse(res.location)",
            "",
            "        for key, value in six.iteritems(expected_headers):",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_image_meta_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_basic(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertFalse(res.location)",
            "        self.assertEqual('application/octet-stream', res.content_type)",
            "        self.assertEqual('chunk00000remainder', res.body)",
            "",
            "    def test_show_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_show_image_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_unauthorized_download(self):",
            "        rules = {\"download_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_restricted_download_for_core_property(self):",
            "        rules = {",
            "            \"restricted\":",
            "            \"not ('1024M':%(min_ram)s and role:_member_)\",",
            "            \"download_image\": \"role:admin or rule:restricted\"",
            "        }",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.headers['X-Auth-Token'] = 'user:tenant:_member_'",
            "        req.headers['min_ram'] = '1024M'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_restricted_download_for_custom_property(self):",
            "        rules = {",
            "            \"restricted\":",
            "            \"not ('test_1234'==%(x_test_key)s and role:_member_)\",",
            "            \"download_image\": \"role:admin or rule:restricted\"",
            "        }",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.headers['X-Auth-Token'] = 'user:tenant:_member_'",
            "        req.headers['x_test_key'] = 'test_1234'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_delete_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertFalse(res.location)",
            "        self.assertEqual('', res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int, res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_delete_not_allowed(self):",
            "        # Verify we can get the image data",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.headers['X-Auth-Token'] = 'user:tenant:'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(19, len(res.body))",
            "",
            "        # Verify we cannot delete the image",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "        # Verify the image data is still there",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(19, len(res.body))",
            "",
            "    def test_delete_queued_image(self):",
            "        \"\"\"Delete an image in a queued state",
            "",
            "        Bug #747799 demonstrated that trying to DELETE an image",
            "        that had had its save process killed manually results in failure",
            "        because the location attribute is None.",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_queued_image_delayed_delete(self):",
            "        \"\"\"Delete an image in a queued state when delayed_delete is on",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        self.config(delayed_delete=True)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_protected_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-protected': 'True'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_delete_image_unauthorized(self):",
            "        rules = {\"delete_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_head_details(self):",
            "        req = webob.Request.blank('/images/detail')",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(405, res.status_int)",
            "        self.assertEqual('GET', res.headers.get('Allow'))",
            "        self.assertEqual(('GET',), res.allow)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "    def test_get_details_invalid_marker(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns a 400",
            "        when an invalid marker is provided",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/detail?marker=%s' % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_get_image_members(self):",
            "        \"\"\"",
            "        Tests members listing for existing images",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(0, num_members)",
            "",
            "    def test_get_image_members_allowed_by_policy(self):",
            "        rules = {\"get_members\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(0, num_members)",
            "",
            "    def test_get_image_members_forbidden_by_policy(self):",
            "        rules = {\"get_members\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_get_image_members_not_existing(self):",
            "        \"\"\"",
            "        Tests proper exception is raised if attempt to get members of",
            "        non-existing image",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_add_member_positive(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_get_member_images(self):",
            "        \"\"\"",
            "        Tests image listing for members",
            "        \"\"\"",
            "        req = webob.Request.blank('/shared-images/pattieblack')",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['shared_images'])",
            "        self.assertEqual(0, num_members)",
            "",
            "    def test_replace_members(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(401, res.status_int)",
            "",
            "    def test_active_image_immutable_props_for_user(self):",
            "        \"\"\"",
            "        Tests user cannot update immutable props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in six.iteritems(fixture_header):",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "                orig_value = res.headers[k]",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(403, res.status_int)",
            "                prop = k[len('x-image-meta-'):]",
            "                self.assertNotEqual(res.body.find(\"Forbidden to modify '%s' \"",
            "                                                  \"of active \"",
            "                                                  \"image\" % prop), -1)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "                self.assertEqual(orig_value, res.headers[k])",
            "",
            "    def test_props_of_active_image_mutable_for_admin(self):",
            "        \"\"\"",
            "        Tests admin can update 'immutable' props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in six.iteritems(fixture_header):",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "                self.assertEqual(v, res.headers[k])",
            "",
            "    def test_replace_members_non_existing_image(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_replace_members_bad_request(self):",
            "        \"\"\"",
            "        Tests replacing image members raises bad request if body is wrong",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_replace_members_positive(self):",
            "        \"\"\"",
            "        Tests replacing image members",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "",
            "        fixture = [dict(member_id='pattieblack', can_share=False)]",
            "        # Replace",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_replace_members_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_replace_members_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_add_member_unauthorized(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(401, res.status_int)",
            "",
            "    def test_add_member_non_existing_image(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_add_member_with_body(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        fixture = dict(can_share=True)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_add_member_overlimit(self):",
            "        self.config(image_member_quota=0)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_member_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_add_member_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_add_member_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_get_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests members listing for deleted image raises 404.",
            "        \"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_delete_member_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests deleting members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_update_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests update members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_replace_members_of_image(self):",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        self.assertEqual(1, len(memb_list))",
            "",
            "    def test_replace_members_of_image_overlimit(self):",
            "        # Set image_member_quota to 1",
            "        self.config(image_member_quota=1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        # PUT an original member entry",
            "        fixture = [{'member_id': 'baz', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        # GET original image member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        original_members = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(1, len(original_members))",
            "",
            "        # PUT 2 image members to replace existing (overlimit)",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "        # GET member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Assert the member list was not changed",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(original_members, memb_list)",
            "",
            "    def test_replace_members_of_image_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(fixture, memb_list)",
            "",
            "    def test_create_member_to_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests adding members to deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_delete_member(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(401, res.status_int)",
            "",
            "    def test_delete_member_on_non_existing_image(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_delete_non_exist_member(self):",
            "        \"\"\"",
            "        Test deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/test_user' % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_delete_image_member(self):",
            "        test_rserver = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_rserver, is_admin=True)",
            "",
            "        # Add member to image:",
            "        fixture = dict(can_share=True)",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        # Delete member",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.headers['X-Auth-Token'] = 'test1:test1:'",
            "        req.method = 'DELETE'",
            "        req.content_type = 'application/json'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "        self.assertIn('Forbidden', res.body)",
            "",
            "    def test_delete_member_allowed_by_policy(self):",
            "        rules = {\"delete_member\": '@', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_delete_member_forbidden_by_policy(self):",
            "        rules = {\"delete_member\": '!', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "",
            "class TestImageSerializer(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestImageSerializer, self).setUp()",
            "        self.receiving_user = 'fake_user'",
            "        self.receiving_tenant = 2",
            "        self.context = glance.context.RequestContext(",
            "            is_admin=True,",
            "            user=self.receiving_user,",
            "            tenant=self.receiving_tenant)",
            "        self.serializer = glance.api.v1.images.ImageSerializer()",
            "",
            "        def image_iter():",
            "            for x in ['chunk', '678911234', '56789']:",
            "                yield x",
            "",
            "        self.FIXTURE = {",
            "            'image_iterator': image_iter(),",
            "            'image_meta': {",
            "                'id': UUID2,",
            "                'name': 'fake image #2',",
            "                'status': 'active',",
            "                'disk_format': 'vhd',",
            "                'container_format': 'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': _gen_uuid(),",
            "                'location': \"file:///tmp/glance-tests/2\",",
            "                'properties': {},",
            "            }",
            "        }",
            "",
            "    def test_meta(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, self.FIXTURE)",
            "        for key, value in six.iteritems(exp_headers):",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "    def test_meta_utf8(self):",
            "        # We get unicode strings from JSON, and therefore all strings in the",
            "        # metadata will actually be unicode when handled internally. But we",
            "        # want to output utf-8.",
            "        FIXTURE = {",
            "            'image_meta': {",
            "                'id': six.text_type(UUID2),",
            "                'name': u'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                'status': u'active',",
            "                'disk_format': u'vhd',",
            "                'container_format': u'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': u'06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': six.text_type(_gen_uuid()),",
            "                'location': u\"file:///tmp/glance-tests/2\",",
            "                'properties': {",
            "                    u'prop_\u00e9\u00e9': u'\u00e7a marche',",
            "                    u'prop_\u00e7\u00e9': u'\u00e7\u00e9',",
            "                }",
            "            }",
            "        }",
            "        exp_headers = {'x-image-meta-id': UUID2.encode('utf-8'),",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                       'x-image-meta-size': '19',  # str, not int",
            "                       'x-image-meta-name': 'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                       'x-image-meta-property-prop_\u00e9\u00e9': '\u00e7a marche',",
            "                       'x-image-meta-property-prop_\u00e7\u00e9': u'\u00e7\u00e9'.encode('utf-8')}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, FIXTURE)",
            "        self.assertNotEqual(type(FIXTURE['image_meta']['name']),",
            "                            type(response.headers['x-image-meta-name']))",
            "        self.assertEqual(FIXTURE['image_meta']['name'],",
            "                         response.headers['x-image-meta-name'].decode('utf-8'))",
            "        for key, value in six.iteritems(exp_headers):",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        FIXTURE['image_meta']['properties'][u'prop_bad'] = '\u00e7\u00e9'",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          self.serializer.meta, response, FIXTURE)",
            "",
            "    def test_show(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.show(response, self.FIXTURE)",
            "        for key, value in six.iteritems(exp_headers):",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        self.assertEqual('chunk67891123456789', response.body)",
            "",
            "    def test_show_notify(self):",
            "        \"\"\"Make sure an eventlet posthook for notify_image_sent is added.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        response.request.environ['eventlet.posthooks'] = []",
            "",
            "        self.serializer.show(response, self.FIXTURE)",
            "",
            "        # just make sure the app_iter is called",
            "        for chunk in response.app_iter:",
            "            pass",
            "",
            "        self.assertNotEqual(response.request.environ['eventlet.posthooks'], [])",
            "",
            "    def test_image_send_notification(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 19,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_info(_event_type, _payload):",
            "            self.assertEqual(expected_payload, _payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'info', fake_info)",
            "",
            "        glance.api.common.image_send_notification(19, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_image_send_notification_error(self):",
            "        \"\"\"Ensure image.send notification is sent on error.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 17,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_error(_event_type, _payload):",
            "            self.assertEqual(expected_payload, _payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'error', fake_error)",
            "",
            "        # expected and actually sent bytes differ",
            "        glance.api.common.image_send_notification(17, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_redact_location(self):",
            "        \"\"\"Ensure location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123', 'location': 'http://localhost'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(redacted_image_meta, tmp_image_meta)",
            "",
            "    def test_noop_redact_location(self):",
            "        \"\"\"Check no-op location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(redacted_image_meta, tmp_image_meta)",
            "        self.assertEqual(redacted_image_meta, image_meta)",
            "",
            "",
            "class TestFilterValidator(base.IsolatedUnitTest):",
            "    def test_filter_validator(self):",
            "        self.assertFalse(glance.api.v1.filters.validate('size_max', -1))",
            "        self.assertTrue(glance.api.v1.filters.validate('size_max', 1))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'True'))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'FALSE'))",
            "        self.assertFalse(glance.api.v1.filters.validate('protected', '-1'))",
            "",
            "",
            "class TestAPIProtectedProps(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        # turn on property protections",
            "        self.set_property_protections()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props=None):",
            "        if props is None:",
            "            props = {}",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_prop_protection_with_create_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('bar', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_permitted_policy_config(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_create_prop_policy': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('bar',",
            "                         res_body['properties']['spl_create_prop_policy'])",
            "",
            "    def test_prop_protection_with_create_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify unpermitted role",
            "        'fake_member' can *not* create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        another_request.get_response(self.api)",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_show_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual('bar',",
            "                         res2.headers['x-image-meta-property-x_owner_foo'])",
            "",
            "    def test_prop_protection_with_show_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_get_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual('bar',",
            "                         res2.headers['x-image-meta-property-x_owner_foo'])",
            "",
            "    def test_prop_protection_with_get_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_detail_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual('bar', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_detail_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual('bar', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('baz', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'admin' can update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_default_policy': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_default_policy': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('baz', res_body['properties']['spl_default_policy'])",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_update_without_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be updated without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_only_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_only_prop': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_only_prop\", output.body)",
            "",
            "    def test_prop_protection_update_noop(self):",
            "        \"\"\"",
            "        Test protected property update is allowed as long as the user has read",
            "        access and the value is unchanged",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_read_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_prop': 'foo'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('foo', res_body['properties']['spl_read_prop'])",
            "        self.assertEqual(200, output.status_int)",
            "",
            "    def test_prop_protection_with_delete_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual({}, res_body['properties'])",
            "",
            "    def test_prop_protection_with_delete_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual({}, res_body['properties'])",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual('bar',",
            "                         output.headers['x-image-meta-property-x_owner_foo'])",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_delete(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without delete permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': 'foo'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_prop\", output.body)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            'foo', output.headers['x-image-meta-property-spl_update_prop'])",
            "",
            "    def test_read_protected_props_leak_with_update(self):",
            "        \"\"\"",
            "        Verify when updating props that ones we don't have read permission for",
            "        are not disclosed",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': '0',",
            "             'x-image-meta-property-foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_prop': '1',",
            "                   'X-Glance-Registry-Purge-Props': 'False'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('1', res_body['properties']['spl_update_prop'])",
            "        self.assertNotIn('foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/updatable by member.  Verify member can successfully update",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "             'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('baz', res_body['properties']['x_owner_foo'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/updatable by admin, but",
            "        also readable by spl_role.  The other is readable/updatable by",
            "        spl_role.  Verify spl_role can successfully update their property but",
            "        not the admin owned one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_update_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "",
            "        # verify spl_role can update it's prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '1',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('1', res_body['properties']['spl_read_only_prop'])",
            "        self.assertEqual('1', res_body['properties']['spl_update_prop'])",
            "",
            "        # verify spl_role can not update admin controlled prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '2',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_delete_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/deletable by member.  Verify member can successfully delete",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "                'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertNotIn('x_owner_foo', res_body['properties'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_delete_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/deletable by admin, but",
            "        also readable by spl_role.  The other is readable/deletable by",
            "        spl_role.  Verify spl_role is forbidden to purge_props in this scenario",
            "        without retaining the readable prop.",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_delete_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_create_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is creatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('1', res_body['properties']['x_all_permitted'])",
            "",
            "    def test_read_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is readable by an unknown",
            "        role",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_all_permitted': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            '1', output.headers['x-image-meta-property-x_all_permitted'])",
            "",
            "    def test_update_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is updatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('2', res_body['properties']['x_all_permitted'])",
            "",
            "    def test_delete_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is deletable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual({}, res_body['properties'])",
            "",
            "    def test_create_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is creatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        # also check admin can not create",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_permitted_admin': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_read_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is readable by no one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_none_read': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "        # also check admin can not read",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "",
            "    def test_update_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is updatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_update': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        # also check admin can't update property",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_delete_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is deletable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_delete': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        # also check admin can't delete",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "",
            "class TestAPIPropertyQuotas(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIPropertyQuotas, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props=None):",
            "        if props is None:",
            "            props = {}",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_update_image_with_too_many_properties(self):",
            "        \"\"\"",
            "        Ensure that updating image properties enforces the quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(413, output.status_int)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", output.text)",
            "",
            "    def test_update_image_with_too_many_properties_without_purge_props(self):",
            "        \"\"\"",
            "        Ensure that updating image properties counts existing image propertys",
            "        when enforcing property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(413, output.status_int)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", output.text)",
            "",
            "    def test_update_properties_without_purge_props_overwrite_value(self):",
            "        \"\"\"",
            "        Ensure that updating image properties does not count against image",
            "        property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=2)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted_create': '3',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('1', res_body['properties']['x_all_permitted'])",
            "        self.assertEqual('3', res_body['properties']['x_all_permitted_create'])"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import contextlib",
            "import copy",
            "import datetime",
            "import hashlib",
            "import uuid",
            "",
            "import glance_store as store",
            "import mock",
            "from oslo.config import cfg",
            "from oslo.serialization import jsonutils",
            "from oslo.utils import timeutils",
            "import routes",
            "import six",
            "import webob",
            "",
            "import glance.api",
            "import glance.api.common",
            "from glance.api.v1 import router",
            "from glance.api.v1 import upload_utils",
            "import glance.common.config",
            "from glance.common import exception",
            "import glance.context",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.db.sqlalchemy import models as db_models",
            "import glance.registry.client.v1.api as registry",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "_gen_uuid = lambda: str(uuid.uuid4())",
            "",
            "UUID1 = _gen_uuid()",
            "UUID2 = _gen_uuid()",
            "",
            "",
            "class TestGlanceAPI(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestGlanceAPI, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        self.FIXTURES = [",
            "            {'id': UUID1,",
            "             'name': 'fake image #1',",
            "             'status': 'active',",
            "             'disk_format': 'ami',",
            "             'container_format': 'ami',",
            "             'is_public': False,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': None,",
            "             'size': 13,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID1),",
            "                            'metadata': {}, 'status': 'active'}],",
            "             'properties': {'type': 'kernel'}},",
            "            {'id': UUID2,",
            "             'name': 'fake image #2',",
            "             'status': 'active',",
            "             'disk_format': 'vhd',",
            "             'container_format': 'ovf',",
            "             'is_public': True,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': 'abc123',",
            "             'size': 19,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID2),",
            "                            'metadata': {}, 'status': 'active'}],",
            "             'properties': {}}]",
            "        self.context = glance.context.RequestContext(is_admin=True)",
            "        db_api.get_engine()",
            "        self.destroy_fixtures()",
            "        self.create_fixtures()",
            "        # Used to store/track image status changes for post-analysis",
            "        self.image_status = []",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestGlanceAPI, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def create_fixtures(self):",
            "        for fixture in self.FIXTURES:",
            "            db_api.image_create(self.context, fixture)",
            "            # We write a fake image file to the filesystem",
            "            with open(\"%s/%s\" % (self.test_dir, fixture['id']), 'wb') as image:",
            "                image.write(\"chunk00000remainder\")",
            "                image.flush()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _do_test_defaulted_format(self, format_key, format_value):",
            "        fixture_headers = {'x-image-meta-name': 'defaulted',",
            "                           'x-image-meta-location': 'http://localhost:0/image',",
            "                           format_key: format_value}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "            res_body = jsonutils.loads(res.body)['image']",
            "            self.assertEqual(format_value, res_body['disk_format'])",
            "            self.assertEqual(format_value, res_body['container_format'])",
            "",
            "    def test_defaulted_amazon_format(self):",
            "        for key in ('x-image-meta-disk-format',",
            "                    'x-image-meta-container-format'):",
            "            for value in ('aki', 'ari', 'ami'):",
            "                self._do_test_defaulted_format(key, value)",
            "",
            "    def test_bad_min_disk_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-disk': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_min_disk_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-disk'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_min_ram_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-ram': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_min_ram_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-ram'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid value', res.body)",
            "",
            "    def test_bad_disk_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'invalid',",
            "            'x-image-meta-container-format': 'ami',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid disk format', res.body)",
            "",
            "    def test_configured_disk_format_good(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'foo',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "",
            "    def test_configured_disk_format_bad(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'bar',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid disk format', res.body)",
            "",
            "    def test_configured_container_format_good(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'foo',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "",
            "    def test_configured_container_format_bad(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'bar',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_container_and_disk_amazon_format_differs(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'aki',",
            "            'x-image-meta-container-format': 'ami'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        expected = (\"Invalid mix of disk and container formats. \"",
            "                    \"When setting a disk or container format to one of \"",
            "                    \"'aki', 'ari', or 'ami', \"",
            "                    \"the container and disk formats must match.\")",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn(expected, res.body)",
            "",
            "    def test_create_with_location_no_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(400, res.status_int)",
            "            self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_create_with_bad_store_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Required store bad is invalid', res.body)",
            "",
            "    def test_create_with_location_get_store_or_400_raises_exception(self):",
            "        location = 'bad+scheme://localhost:0/image.qcow2'",
            "        scheme = 'bad+scheme'",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': location,",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        ctlr = glance.api.v1.images.Controller",
            "",
            "        with contextlib.nested(",
            "                mock.patch.object(ctlr, '_external_source',",
            "                                  return_value=location),",
            "                mock.patch.object(store,",
            "                                  'get_store_from_location',",
            "                                  return_value=scheme)",
            "        ) as (",
            "            mock_external_source,",
            "            mock_get_store_from_location",
            "        ):",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(400, res.status_int)",
            "            self.assertEqual(1, mock_external_source.call_count)",
            "            self.assertEqual(1, mock_get_store_from_location.call_count)",
            "            self.assertIn('Store for scheme %s not found' % scheme, res.body)",
            "",
            "    def test_create_with_location_unknown_scheme(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'bad+scheme://localhost:0/image.qcow2',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('External source are not supported', res.body)",
            "",
            "    def test_create_with_location_bad_store_uri(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'file',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid location', res.body)",
            "",
            "    def test_create_image_with_too_many_properties(self):",
            "        self.config(image_property_quota=1)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images', method='POST')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(413, output.status_int)",
            "",
            "    def test_bad_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'invalid',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_bad_image_size(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        def exec_bad_size_test(bad_size, expected_substr):",
            "            fixture_headers['x-image-meta-size'] = bad_size",
            "            req = webob.Request.blank(\"/images\",",
            "                                      method='POST',",
            "                                      headers=fixture_headers)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(400, res.status_int)",
            "            self.assertIn(expected_substr, res.body)",
            "",
            "        expected = \"Cannot convert image size 'invalid' to an integer.\"",
            "        exec_bad_size_test('invalid', expected)",
            "        expected = \"Image size must be >= 0 ('-10' specified).\"",
            "        exec_bad_size_test(-10, expected)",
            "",
            "    def test_bad_image_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'X' * 256,",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_no_location_no_image_as_body(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://localhost:0/images/123'",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        # Once the location is set, the image should be activated",
            "        # see LP Bug #939484",
            "        self.assertEqual('active', res_body['status'])",
            "        self.assertNotIn('location', res_body)  # location never shown",
            "",
            "    def test_add_image_no_location_no_content_type(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1,",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_size_header_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=str(quota))",
            "        fixture_headers = {'x-image-meta-size': quota + 1,",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-container_format': 'bare',",
            "                           'x-image-meta-disk_format': 'qcow2',",
            "                           'content-type': 'application/octet-stream',",
            "                           }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        req.body = 'X' * (quota + 1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_image_size_data_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=str(quota))",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_image_size_data_exceed_quota_readd(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=str(quota))",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "        used_size = sum([f['size'] for f in self.FIXTURES])",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota - used_size)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "    def _add_check_no_url_info(self):",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertNotIn('locations', res_body)",
            "        self.assertNotIn('direct_url', res_body)",
            "        image_id = res_body['id']",
            "",
            "        # HEAD empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertNotIn('x-image-meta-locations', res.headers)",
            "        self.assertNotIn('x-image-meta-direct_url', res.headers)",
            "",
            "    def test_add_check_no_url_info_ml(self):",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_direct_url(self):",
            "        self.config(show_image_direct_url=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_on(self):",
            "        self.config(show_image_direct_url=True)",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_off(self):",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_image_zero_size(self):",
            "        \"\"\"Tests creating an active image with explicitly zero size\"\"\"",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # GET empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(0, len(res.body))",
            "",
            "    def _do_test_add_image_attribute_mismatch(self, attributes):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "        }",
            "        fixture_headers.update(attributes)",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"XXXX\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_checksum_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_checksum_and_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_bad_store(self):",
            "        \"\"\"Tests raises BadRequest for invalid store header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'bad',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_basic_file_store(self):",
            "        \"\"\"Tests to add a basic image in the file store\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        # Test that the Location: header is set to the URI to",
            "        # edit the newly-created image, as required by APP.",
            "        # See LP Bug #719825",
            "        self.assertTrue('location' in res.headers,",
            "                        \"'location' not in response headers.\\n\"",
            "                        \"res.headerlist = %r\" % res.headerlist)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertIn('/images/%s' % res_body['id'], res.headers['location'])",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are NOT able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://example.com/images/123'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_image_unauthorized(self):",
            "        rules = {\"add_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_publicize_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_publicize_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "    def test_add_copy_from_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_add_copy_from_image_authorized_upload_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "    def test_add_copy_from_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from copy-from and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_location_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from location and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_location_with_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as size:",
            "            size.return_value = 2",
            "",
            "            for k, v in six.iteritems(fixture_headers):",
            "                req.headers[k] = v",
            "",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 409)",
            "",
            "    def test_add_location_with_invalid_location_on_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_location_with_invalid_location_on_restricted_sources(self):",
            "        \"\"\"Tests creates an image from location and restricted sources\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'file:///etc/passwd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'swift+config://xxx',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_with_location(self):",
            "        \"\"\"Tests creates an image from copy-from and location\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_with_restricted_sources(self):",
            "        \"\"\"Tests creates an image from copy-from with restricted sources\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'file:///etc/passwd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'swift+config://xxx',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized_with_body(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_data_upload_bad_store_uri(self):",
            "        fixture_headers = {'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.headers['x-image-meta-location'] = 'http://'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "        self.assertIn('Invalid location', res.body)",
            "",
            "    def test_update_data_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['transfer-encoding'] = 'chunked'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_copy_from_unauthorized(self):",
            "        rules = {\"upload_image\": '@', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def _do_test_post_image_content_missing_format(self, missing):",
            "        \"\"\"Tests creation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_post_image_content_missing_disk_format(self):",
            "        \"\"\"Tests creation of an image with missing disk format\"\"\"",
            "        self._do_test_post_image_content_missing_format('disk_format')",
            "",
            "    def test_post_image_content_missing_container_type(self):",
            "        \"\"\"Tests creation of an image with missing container format\"\"\"",
            "        self._do_test_post_image_content_missing_format('container_format')",
            "",
            "    def _do_test_put_image_content_missing_format(self, missing):",
            "        \"\"\"Tests delayed activation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_put_image_content_missing_disk_format(self):",
            "        \"\"\"Tests delayed activation of image with missing disk format\"\"\"",
            "        self._do_test_put_image_content_missing_format('disk_format')",
            "",
            "    def test_put_image_content_missing_container_type(self):",
            "        \"\"\"Tests delayed activation of image with missing container format\"\"\"",
            "        self._do_test_put_image_content_missing_format('container_format')",
            "",
            "    def test_update_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to update a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        fixture = {'name': 'test_del_img'}",
            "        req = webob.Request.blank('/images/%s' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "        self.assertIn('Forbidden to update deleted image', res.body)",
            "",
            "    def test_delete_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to delete a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the status is 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "        msg = \"Image %s not found.\" % UUID2",
            "        self.assertIn(msg, res.body)",
            "",
            "        # Verify the status is still 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "    def test_image_status_when_delete_fails(self):",
            "        \"\"\"",
            "        Tests that the image status set to active if deletion of image fails.",
            "        \"\"\"",
            "",
            "        fs = store.get_store_from_scheme('file')",
            "",
            "        with mock.patch.object(fs, 'delete') as mock_fsstore_delete:",
            "            mock_fsstore_delete.side_effect = exception.Forbidden()",
            "",
            "            # trigger the v1 delete api",
            "            req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(403, res.status_int)",
            "            self.assertTrue('Forbidden to delete image' in res.body)",
            "",
            "            # check image metadata is still there with active state",
            "            req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "            req.method = 'HEAD'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "            self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_pending_delete_image(self):",
            "        \"\"\"",
            "        Tests that correct response returned when deleting",
            "        a pending_delete image",
            "        \"\"\"",
            "        # First deletion",
            "        self.config(delayed_delete=True, scrubber_datadir='/tmp/scrubber')",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the status is 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "        # Second deletion",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "        self.assertIn('Forbidden to delete a pending_delete image', res.body)",
            "",
            "        # Verify the status is still 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_to_image_status_saving(self):",
            "        \"\"\"Test image upload conflict.",
            "",
            "        If an image is uploaded before an existing upload to the same image",
            "        completes, the original upload should succeed and the conflicting",
            "        one should fail and any data be deleted.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'some-foo-image'}",
            "",
            "        # create an image but don't upload yet.",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        orig_get_image_metadata = registry.get_image_metadata",
            "        orig_image_get = db_api._image_get",
            "        orig_image_update = db_api._image_update",
            "        orig_initiate_deletion = upload_utils.initiate_deletion",
            "",
            "        # this will be used to track what is called and their order.",
            "        call_sequence = []",
            "        # use this to determine if we are within a db session i.e. atomic",
            "        # operation, that is setting our active state.",
            "        test_status = {'activate_session_started': False}",
            "        # We want first status check to be 'queued' so we get past the first",
            "        # guard.",
            "        test_status['queued_guard_passed'] = False",
            "",
            "        state_changes = []",
            "",
            "        def mock_image_update(context, values, image_id, purge_props=False,",
            "                              from_state=None):",
            "",
            "            status = values.get('status')",
            "            if status:",
            "                state_changes.append(status)",
            "                if status == 'active':",
            "                    # We only expect this state to be entered once.",
            "                    if test_status['activate_session_started']:",
            "                        raise Exception(\"target session already started\")",
            "",
            "                    test_status['activate_session_started'] = True",
            "                    call_sequence.append('update_active')",
            "",
            "                else:",
            "                    call_sequence.append('update')",
            "",
            "            return orig_image_update(context, values, image_id,",
            "                                     purge_props=purge_props,",
            "                                     from_state=from_state)",
            "",
            "        def mock_image_get(*args, **kwargs):",
            "            \"\"\"Force status to 'saving' if not within activate db session.",
            "",
            "            If we are in the activate db session we return 'active' which we",
            "            then expect to cause exception.Conflict to be raised since this",
            "            indicates that another upload has succeeded.",
            "            \"\"\"",
            "            image = orig_image_get(*args, **kwargs)",
            "            if test_status['activate_session_started']:",
            "                call_sequence.append('image_get_active')",
            "                setattr(image, 'status', 'active')",
            "            else:",
            "                setattr(image, 'status', 'saving')",
            "",
            "            return image",
            "",
            "        def mock_get_image_metadata(*args, **kwargs):",
            "            \"\"\"Force image status sequence.",
            "            \"\"\"",
            "            call_sequence.append('get_image_meta')",
            "            meta = orig_get_image_metadata(*args, **kwargs)",
            "            if not test_status['queued_guard_passed']:",
            "                meta['status'] = 'queued'",
            "                test_status['queued_guard_passed'] = True",
            "",
            "            return meta",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            call_sequence.append('init_del')",
            "            orig_initiate_deletion(*args, **kwargs)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "",
            "        with mock.patch.object(",
            "                upload_utils, 'initiate_deletion') as mock_init_del:",
            "            mock_init_del.side_effect = mock_initiate_deletion",
            "            with mock.patch.object(",
            "                    registry, 'get_image_metadata') as mock_get_meta:",
            "                mock_get_meta.side_effect = mock_get_image_metadata",
            "                with mock.patch.object(db_api, '_image_get') as mock_db_get:",
            "                    mock_db_get.side_effect = mock_image_get",
            "                    with mock.patch.object(",
            "                            db_api, '_image_update') as mock_db_update:",
            "                        mock_db_update.side_effect = mock_image_update",
            "",
            "                        # Expect a 409 Conflict.",
            "                        res = req.get_response(self.api)",
            "                        self.assertEqual(409, res.status_int)",
            "",
            "                        # Check expected call sequence",
            "                        self.assertEqual(['get_image_meta', 'get_image_meta',",
            "                                          'update', 'update_active',",
            "                                          'image_get_active',",
            "                                          'init_del'],",
            "                                         call_sequence)",
            "",
            "                        self.assertTrue(mock_get_meta.called)",
            "                        self.assertTrue(mock_db_get.called)",
            "                        self.assertTrue(mock_db_update.called)",
            "",
            "                        # Ensure cleanup occured.",
            "                        self.assertEqual(1, mock_init_del.call_count)",
            "",
            "                        self.assertEqual(state_changes, ['saving', 'active'])",
            "",
            "    def test_register_and_upload(self):",
            "        \"\"\"",
            "        Test that the process of registering an image with",
            "        some metadata, then uploading an image file with some",
            "        more metadata doesn't mark the original metadata deleted",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertIn('status', res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertIn('properties', res_body)",
            "        self.assertIn('key1', res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now upload the image file along with some more",
            "        # metadata and verify original metadata properties",
            "        # are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the status is 'queued'",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertTrue('x-image-meta-property-key1' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_image_raises_store_disabled(self):",
            "        \"\"\"Test that uploading an image file returns HTTTP 410 response\"\"\"",
            "        # create image",
            "        fs = store.get_store_from_scheme('file')",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertIn('status', res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now upload the image file",
            "        with mock.patch.object(fs, 'add') as mock_fsstore_add:",
            "            mock_fsstore_add.side_effect = store.StoreAddDisabled",
            "            req = webob.Request.blank(\"/images/%s\" % image_id)",
            "            req.method = 'PUT'",
            "            req.headers['Content-Type'] = 'application/octet-stream'",
            "            req.body = \"chunk00000remainder\"",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(410, res.status_int)",
            "            self._verify_image_status(image_id, 'killed')",
            "",
            "    def _get_image_status(self, image_id):",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        return req.get_response(self.api)",
            "",
            "    def _verify_image_status(self, image_id, status, check_deleted=False,",
            "                             use_cached=False):",
            "        if not use_cached:",
            "            res = self._get_image_status(image_id)",
            "        else:",
            "            res = self.image_status.pop(0)",
            "",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(status, res.headers['x-image-meta-status'])",
            "        self.assertEqual(str(check_deleted),",
            "                         res.headers['x-image-meta-deleted'])",
            "",
            "    def _upload_safe_kill_common(self, mocks):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        self.image_id = res_body['id']",
            "        self.assertTrue('/images/%s' %",
            "                        self.image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        for m in mocks:",
            "            m['mock'].side_effect = m['side_effect']",
            "",
            "        # Now upload the image file along with some more metadata and",
            "        # verify original metadata properties are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        # We expect 500 since an exception occured during upload.",
            "        self.assertEqual(500, res.status_int)",
            "",
            "    @mock.patch('glance_store.store_add_to_backend')",
            "    def test_upload_safe_kill(self, mock_store_add_to_backend):",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"Trigger mid-upload failure by raising an exception.\"\"\"",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "            # Raise an exception to emulate failed upload.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'killed'",
            "        self._verify_image_status(self.image_id, 'saving', use_cached=True)",
            "        self._verify_image_status(self.image_id, 'killed')",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    @mock.patch('glance_store.store_add_to_backend')",
            "    def test_upload_safe_kill_deleted(self, mock_store_add_to_backend):",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router_api,",
            "                                                 is_admin=True)",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"We now delete the image, assert status is 'deleted' then",
            "            raise an exception to emulate a failed upload. This will be caught",
            "            by upload_data_to_store() which will then try to set status to",
            "            'killed' which will be ignored since the image has been deleted.",
            "            \"\"\"",
            "            # expect 'saving'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "            # expect 'deleted'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            # Raise an exception to make the upload fail.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'deleted' -> 'deleted'",
            "        self._verify_image_status(self.image_id, 'saving', check_deleted=False,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True)",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    def _check_delete_during_image_upload(self, is_admin=False):",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = unit_test_utils.get_fake_request(path=\"/images\",",
            "                                               is_admin=is_admin)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        called = {'initiate_deletion': False}",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            called['initiate_deletion'] = True",
            "",
            "        self.stubs.Set(glance.api.v1.upload_utils, 'initiate_deletion',",
            "                       mock_initiate_deletion)",
            "",
            "        orig_update_image_metadata = registry.update_image_metadata",
            "",
            "        data = \"somedata\"",
            "",
            "        def mock_update_image_metadata(*args, **kwargs):",
            "",
            "            if args[2].get('size', None) == len(data):",
            "                path = \"/images/%s\" % image_id",
            "                req = unit_test_utils.get_fake_request(path=path,",
            "                                                       method='DELETE',",
            "                                                       is_admin=is_admin)",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "",
            "                self.stubs.Set(registry, 'update_image_metadata',",
            "                               orig_update_image_metadata)",
            "",
            "            return orig_update_image_metadata(*args, **kwargs)",
            "",
            "        self.stubs.Set(registry, 'update_image_metadata',",
            "                       mock_update_image_metadata)",
            "",
            "        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,",
            "                                               method='PUT')",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = data",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(412, res.status_int)",
            "        self.assertFalse(res.location)",
            "",
            "        self.assertTrue(called['initiate_deletion'])",
            "",
            "        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,",
            "                                               method='HEAD',",
            "                                               is_admin=True)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_during_image_upload_by_normal_user(self):",
            "        self._check_delete_during_image_upload(is_admin=False)",
            "",
            "    def test_delete_during_image_upload_by_admin(self):",
            "        self._check_delete_during_image_upload(is_admin=True)",
            "",
            "    def test_disable_purge_props(self):",
            "        \"\"\"",
            "        Test the special x-glance-registry-purge-props header controls",
            "        the purge property behaviour of the registry.",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertIn('id', res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertIn('/images/%s' % image_id, res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertIn('status', res_body)",
            "        self.assertEqual('active', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertIn('properties', res_body)",
            "        self.assertIn('key1', res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now update the image, setting new properties without",
            "        # passing the x-glance-registry-purge-props header and",
            "        # verify that original properties are marked deleted.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the original property no longer in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertFalse('x-image-meta-property-key1' in res.headers,",
            "                         \"Found property in headers that was not expected. \"",
            "                         \"Got headers: %r\" % res.headers)",
            "",
            "        # Now update the image, setting new properties and",
            "        # passing the x-glance-registry-purge-props header with",
            "        # a value of \"false\" and verify that second property",
            "        # still appears in headers.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key3'] = 'value3'",
            "        req.headers['x-glance-registry-purge-props'] = 'false'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Verify the second and third property in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertTrue('x-image-meta-property-key3' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "",
            "    def test_publicize_image_unauthorized(self):",
            "        \"\"\"Create a non-public image then fail to make public\"\"\"",
            "        rules = {\"add_image\": '@', \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'false',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-is-public'] = 'true'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_update_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1}",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_update_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        fixture_headers = {'content-type': 'application/octet-stream'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_update_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        # Create new image that has no data",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.headers['x-image-meta-name'] = 'something'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        res = req.get_response(self.api)",
            "        image_id = jsonutils.loads(res.body)['image']['id']",
            "",
            "        fixture_headers = {",
            "            'content-type': 'application/octet-stream',",
            "            'transfer-encoding': 'chunked',",
            "        }",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_update_non_existing_image(self):",
            "        self.config(image_size_cap=100)",
            "",
            "        req = webob.Request.blank(\"images/%s\" % _gen_uuid)",
            "        req.method = 'PUT'",
            "        req.body = 'test'",
            "        req.headers['x-image-meta-name'] = 'test'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        req.headers['x-image-meta-is_public'] = 'False'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_update_public_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-name'] = 'updated public image'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "    def test_add_image_wrong_content_type(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-st',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_get_index_sort_name_asc(self):",
            "        \"\"\"",
            "        Tests that the /images registry API returns list of",
            "        public images sorted alphabetically by name in",
            "        ascending order.",
            "        \"\"\"",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'asdf',",
            "                         'size': 19,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'xyz',",
            "                         'size': 20,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        req = webob.Request.blank('/images?sort_key=name&sort_dir=asc')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "",
            "        images = res_dict['images']",
            "        self.assertEqual(3, len(images))",
            "        self.assertEqual(UUID3, images[0]['id'])",
            "        self.assertEqual(UUID2, images[1]['id'])",
            "        self.assertEqual(UUID4, images[2]['id'])",
            "",
            "    def test_get_details_filter_changes_since(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns list of",
            "        public images that have a size less than or equal to size_max",
            "        \"\"\"",
            "        dt1 = timeutils.utcnow() - datetime.timedelta(1)",
            "        iso1 = timeutils.isotime(dt1)",
            "",
            "        date_only1 = dt1.strftime('%Y-%m-%d')",
            "        date_only2 = dt1.strftime('%Y%m%d')",
            "        date_only3 = dt1.strftime('%Y-%m%d')",
            "",
            "        dt2 = timeutils.utcnow() + datetime.timedelta(1)",
            "        iso2 = timeutils.isotime(dt2)",
            "",
            "        image_ts = timeutils.utcnow() + datetime.timedelta(2)",
            "        hour_before = image_ts.strftime('%Y-%m-%dT%H:%M:%S%%2B01:00')",
            "        hour_after = image_ts.strftime('%Y-%m-%dT%H:%M:%S-01:00')",
            "",
            "        dt4 = timeutils.utcnow() + datetime.timedelta(3)",
            "        iso4 = timeutils.isotime(dt4)",
            "",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'fake image #3',",
            "                         'size': 18,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "        db_api.image_destroy(self.context, UUID3)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'fake image #4',",
            "                         'size': 20,",
            "                         'checksum': None,",
            "                         'created_at': image_ts,",
            "                         'updated_at': image_ts}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Check a standard list, 4 images in db (2 deleted)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(2, len(images))",
            "        self.assertEqual(UUID4, images[0]['id'])",
            "        self.assertEqual(UUID2, images[1]['id'])",
            "",
            "        # Expect 3 images (1 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(3, len(images))",
            "        self.assertEqual(UUID4, images[0]['id'])",
            "        self.assertEqual(UUID3, images[1]['id'])  # deleted",
            "        self.assertEqual(UUID2, images[2]['id'])",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(UUID4, images[0]['id'])",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_before)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_after)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso4)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        for param in [date_only1, date_only2, date_only3]:",
            "            # Expect 3 images (1 deleted)",
            "            req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                      param)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "            res_dict = jsonutils.loads(res.body)",
            "            images = res_dict['images']",
            "            self.assertEqual(3, len(images))",
            "            self.assertEqual(images[0]['id'], UUID4)",
            "            self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "            self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Bad request (empty changes-since param)",
            "        req = webob.Request.blank('/images/detail?changes-since=')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_get_images_bad_urls(self):",
            "        \"\"\"Check that routes collections are not on (LP bug 1185828)\"\"\"",
            "        req = webob.Request.blank('/images/detail.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "        req = webob.Request.blank('/images.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/new')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members.xxx\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_get_index_filter_on_user_defined_properties(self):",
            "        \"\"\"Check that image filtering works on user-defined properties\"\"\"",
            "",
            "        image1_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'i386'}",
            "        extra_fixture = {'id': image1_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'image-extra-1',",
            "                         'size': 18, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        image2_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'x86_64', 'foo': 'bar'}",
            "        extra_fixture = {'id': image2_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'image-extra-2',",
            "                         'size': 20, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Test index with filter containing one user-defined property.",
            "        # Filter is 'property-distro=ubuntu'.",
            "        # Verify both image1 and image2 are returned",
            "        req = webob.Request.blank('/images?property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(2, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # non-existent value. Filter is 'property-distro=fedora'.",
            "        # Verify neither images are returned",
            "        req = webob.Request.blank('/images?property-distro=fedora')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=i386'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=x86_64'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property.",
            "        # Filter is 'property-foo=bar'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-foo=bar')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property but",
            "        # .value is non-existent. Filter is 'property-foo=baz'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=baz')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=x86_64&property-distro=ubuntu'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=i386&property-distro=ubuntu'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=ubuntu'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=random'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=random')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-boo=far&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-boo=far&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-foo=bar&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=bar&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(0, len(images))",
            "",
            "    def test_get_images_detailed_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_get_images_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_store_location_not_revealed(self):",
            "        \"\"\"",
            "        Test that the internal store location is NOT revealed",
            "        through the API server",
            "        \"\"\"",
            "        # Check index and details...",
            "        for url in ('/images', '/images/detail'):",
            "            req = webob.Request.blank(url)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "            res_dict = jsonutils.loads(res.body)",
            "",
            "            images = res_dict['images']",
            "            num_locations = sum([1 for record in images",
            "                                if 'location' in record.keys()])",
            "            self.assertEqual(0, num_locations, images)",
            "",
            "        # Check GET",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertNotIn('X-Image-Meta-Location', res.headers)",
            "",
            "        # Check HEAD",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertNotIn('X-Image-Meta-Location', res.headers)",
            "",
            "        # Check PUT",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.body = res.body",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        res_body = jsonutils.loads(res.body)",
            "        self.assertNotIn('location', res_body['image'])",
            "",
            "        # Check POST",
            "        req = webob.Request.blank(\"/images\")",
            "        headers = {'x-image-meta-location': 'http://localhost',",
            "                   'x-image-meta-disk-format': 'vhd',",
            "                   'x-image-meta-container-format': 'ovf',",
            "                   'x-image-meta-name': 'fake image #3'}",
            "        for k, v in six.iteritems(headers):",
            "            req.headers[k] = v",
            "        req.method = 'POST'",
            "",
            "        http = store.get_store_from_scheme('http')",
            "",
            "        with mock.patch.object(http, 'get_size') as size:",
            "            size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(201, res.status_int)",
            "            res_body = jsonutils.loads(res.body)",
            "            self.assertNotIn('location', res_body['image'])",
            "",
            "    def test_image_is_checksummed(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual(image_checksum, res_body['checksum'],",
            "                         \"Mismatched checksum. Expected %s, got %s\" %",
            "                         (image_checksum, res_body['checksum']))",
            "",
            "    def test_etag_equals_checksum_header(self):",
            "        \"\"\"Test that the ETag header matches the x-image-meta-checksum\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        image = jsonutils.loads(res.body)['image']",
            "",
            "        # HEAD the image and check the ETag equals the checksum header...",
            "        expected_headers = {'x-image-meta-checksum': image_checksum,",
            "                            'etag': image_checksum}",
            "        req = webob.Request.blank(\"/images/%s\" % image['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        for key in expected_headers.keys():",
            "            self.assertTrue(key in res.headers,",
            "                            \"required header '%s' missing from \"",
            "                            \"returned headers\" % key)",
            "        for key, value in six.iteritems(expected_headers):",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_bad_checksum_prevents_image_creation(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        image_contents = \"chunk00000remainder\"",
            "        bad_checksum = hashlib.md5(\"invalid\").hexdigest()",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-checksum': bad_checksum,",
            "                           'x-image-meta-is-public': 'true'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        # Test that only one image was returned (that already exists)",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(1, len(images))",
            "",
            "    def test_image_meta(self):",
            "        \"\"\"Test for HEAD /images/<ID>\"\"\"",
            "        expected_headers = {'x-image-meta-id': UUID2,",
            "                            'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertFalse(res.location)",
            "",
            "        for key, value in six.iteritems(expected_headers):",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_image_meta_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_basic(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertFalse(res.location)",
            "        self.assertEqual('application/octet-stream', res.content_type)",
            "        self.assertEqual('chunk00000remainder', res.body)",
            "",
            "    def test_show_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_show_image_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_unauthorized_download(self):",
            "        rules = {\"download_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_restricted_download_for_core_property(self):",
            "        rules = {",
            "            \"restricted\":",
            "            \"not ('1024M':%(min_ram)s and role:_member_)\",",
            "            \"download_image\": \"role:admin or rule:restricted\"",
            "        }",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.headers['X-Auth-Token'] = 'user:tenant:_member_'",
            "        req.headers['min_ram'] = '1024M'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_show_image_restricted_download_for_custom_property(self):",
            "        rules = {",
            "            \"restricted\":",
            "            \"not ('test_1234'==%(x_test_key)s and role:_member_)\",",
            "            \"download_image\": \"role:admin or rule:restricted\"",
            "        }",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.headers['X-Auth-Token'] = 'user:tenant:_member_'",
            "        req.headers['x_test_key'] = 'test_1234'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_delete_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertFalse(res.location)",
            "        self.assertEqual('', res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int, res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_delete_not_allowed(self):",
            "        # Verify we can get the image data",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.headers['X-Auth-Token'] = 'user:tenant:'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(19, len(res.body))",
            "",
            "        # Verify we cannot delete the image",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "        # Verify the image data is still there",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(19, len(res.body))",
            "",
            "    def test_delete_queued_image(self):",
            "        \"\"\"Delete an image in a queued state",
            "",
            "        Bug #747799 demonstrated that trying to DELETE an image",
            "        that had had its save process killed manually results in failure",
            "        because the location attribute is None.",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_queued_image_delayed_delete(self):",
            "        \"\"\"Delete an image in a queued state when delayed_delete is on",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        self.config(delayed_delete=True)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual('True', res.headers['x-image-meta-deleted'])",
            "        self.assertEqual('deleted', res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_protected_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-protected': 'True'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_delete_image_unauthorized(self):",
            "        rules = {\"delete_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(403, res.status_int)",
            "",
            "    def test_head_details(self):",
            "        req = webob.Request.blank('/images/detail')",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(405, res.status_int)",
            "        self.assertEqual('GET', res.headers.get('Allow'))",
            "        self.assertEqual(('GET',), res.allow)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "    def test_get_details_invalid_marker(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns a 400",
            "        when an invalid marker is provided",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/detail?marker=%s' % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_get_image_members(self):",
            "        \"\"\"",
            "        Tests members listing for existing images",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(0, num_members)",
            "",
            "    def test_get_image_members_allowed_by_policy(self):",
            "        rules = {\"get_members\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(0, num_members)",
            "",
            "    def test_get_image_members_forbidden_by_policy(self):",
            "        rules = {\"get_members\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_get_image_members_not_existing(self):",
            "        \"\"\"",
            "        Tests proper exception is raised if attempt to get members of",
            "        non-existing image",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_add_member_positive(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_get_member_images(self):",
            "        \"\"\"",
            "        Tests image listing for members",
            "        \"\"\"",
            "        req = webob.Request.blank('/shared-images/pattieblack')",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['shared_images'])",
            "        self.assertEqual(0, num_members)",
            "",
            "    def test_replace_members(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(401, res.status_int)",
            "",
            "    def test_active_image_immutable_props_for_user(self):",
            "        \"\"\"",
            "        Tests user cannot update immutable props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in six.iteritems(fixture_header):",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "                orig_value = res.headers[k]",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(403, res.status_int)",
            "                prop = k[len('x-image-meta-'):]",
            "                self.assertNotEqual(res.body.find(\"Forbidden to modify '%s' \"",
            "                                                  \"of active \"",
            "                                                  \"image\" % prop), -1)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "                self.assertEqual(orig_value, res.headers[k])",
            "",
            "    def test_props_of_active_image_mutable_for_admin(self):",
            "        \"\"\"",
            "        Tests admin can update 'immutable' props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in six.iteritems(fixture_header):",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "                self.assertEqual(v, res.headers[k])",
            "",
            "    def test_replace_members_non_existing_image(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_replace_members_bad_request(self):",
            "        \"\"\"",
            "        Tests replacing image members raises bad request if body is wrong",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_replace_members_positive(self):",
            "        \"\"\"",
            "        Tests replacing image members",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "",
            "        fixture = [dict(member_id='pattieblack', can_share=False)]",
            "        # Replace",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_replace_members_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_replace_members_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_add_member_unauthorized(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(401, res.status_int)",
            "",
            "    def test_add_member_non_existing_image(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_add_member_with_body(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        fixture = dict(can_share=True)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_add_member_overlimit(self):",
            "        self.config(image_member_quota=0)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "    def test_add_member_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "    def test_add_member_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "    def test_add_member_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_get_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests members listing for deleted image raises 404.",
            "        \"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_delete_member_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests deleting members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_update_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests update members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_replace_members_of_image(self):",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        self.assertEqual(1, len(memb_list))",
            "",
            "    def test_replace_members_of_image_overlimit(self):",
            "        # Set image_member_quota to 1",
            "        self.config(image_member_quota=1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        # PUT an original member entry",
            "        fixture = [{'member_id': 'baz', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        # GET original image member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "        original_members = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(1, len(original_members))",
            "",
            "        # PUT 2 image members to replace existing (overlimit)",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(413, res.status_int)",
            "",
            "        # GET member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        # Assert the member list was not changed",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(original_members, memb_list)",
            "",
            "    def test_replace_members_of_image_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(fixture, memb_list)",
            "",
            "    def test_create_member_to_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests adding members to deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(200, res.status_int)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNotFound.code, res.status_int)",
            "        self.assertIn(",
            "            'Image with identifier %s has been deleted.' % UUID2, res.body)",
            "",
            "    def test_delete_member(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(401, res.status_int)",
            "",
            "    def test_delete_member_on_non_existing_image(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_delete_non_exist_member(self):",
            "        \"\"\"",
            "        Test deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/test_user' % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(api)",
            "        self.assertEqual(404, res.status_int)",
            "",
            "    def test_delete_image_member(self):",
            "        test_rserver = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_rserver, is_admin=True)",
            "",
            "        # Add member to image:",
            "        fixture = dict(can_share=True)",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(204, res.status_int)",
            "",
            "        # Delete member",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.headers['X-Auth-Token'] = 'test1:test1:'",
            "        req.method = 'DELETE'",
            "        req.content_type = 'application/json'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(404, res.status_int)",
            "        self.assertIn('Forbidden', res.body)",
            "",
            "    def test_delete_member_allowed_by_policy(self):",
            "        rules = {\"delete_member\": '@', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "",
            "    def test_delete_member_forbidden_by_policy(self):",
            "        rules = {\"delete_member\": '!', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPNoContent.code, res.status_int)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, res.status_int)",
            "",
            "",
            "class TestImageSerializer(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestImageSerializer, self).setUp()",
            "        self.receiving_user = 'fake_user'",
            "        self.receiving_tenant = 2",
            "        self.context = glance.context.RequestContext(",
            "            is_admin=True,",
            "            user=self.receiving_user,",
            "            tenant=self.receiving_tenant)",
            "        self.serializer = glance.api.v1.images.ImageSerializer()",
            "",
            "        def image_iter():",
            "            for x in ['chunk', '678911234', '56789']:",
            "                yield x",
            "",
            "        self.FIXTURE = {",
            "            'image_iterator': image_iter(),",
            "            'image_meta': {",
            "                'id': UUID2,",
            "                'name': 'fake image #2',",
            "                'status': 'active',",
            "                'disk_format': 'vhd',",
            "                'container_format': 'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': _gen_uuid(),",
            "                'location': \"file:///tmp/glance-tests/2\",",
            "                'properties': {},",
            "            }",
            "        }",
            "",
            "    def test_meta(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, self.FIXTURE)",
            "        for key, value in six.iteritems(exp_headers):",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "    def test_meta_utf8(self):",
            "        # We get unicode strings from JSON, and therefore all strings in the",
            "        # metadata will actually be unicode when handled internally. But we",
            "        # want to output utf-8.",
            "        FIXTURE = {",
            "            'image_meta': {",
            "                'id': six.text_type(UUID2),",
            "                'name': u'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                'status': u'active',",
            "                'disk_format': u'vhd',",
            "                'container_format': u'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': u'06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': six.text_type(_gen_uuid()),",
            "                'location': u\"file:///tmp/glance-tests/2\",",
            "                'properties': {",
            "                    u'prop_\u00e9\u00e9': u'\u00e7a marche',",
            "                    u'prop_\u00e7\u00e9': u'\u00e7\u00e9',",
            "                }",
            "            }",
            "        }",
            "        exp_headers = {'x-image-meta-id': UUID2.encode('utf-8'),",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                       'x-image-meta-size': '19',  # str, not int",
            "                       'x-image-meta-name': 'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                       'x-image-meta-property-prop_\u00e9\u00e9': '\u00e7a marche',",
            "                       'x-image-meta-property-prop_\u00e7\u00e9': u'\u00e7\u00e9'.encode('utf-8')}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, FIXTURE)",
            "        self.assertNotEqual(type(FIXTURE['image_meta']['name']),",
            "                            type(response.headers['x-image-meta-name']))",
            "        self.assertEqual(FIXTURE['image_meta']['name'],",
            "                         response.headers['x-image-meta-name'].decode('utf-8'))",
            "        for key, value in six.iteritems(exp_headers):",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        FIXTURE['image_meta']['properties'][u'prop_bad'] = '\u00e7\u00e9'",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          self.serializer.meta, response, FIXTURE)",
            "",
            "    def test_show(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.show(response, self.FIXTURE)",
            "        for key, value in six.iteritems(exp_headers):",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        self.assertEqual('chunk67891123456789', response.body)",
            "",
            "    def test_show_notify(self):",
            "        \"\"\"Make sure an eventlet posthook for notify_image_sent is added.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        response.request.environ['eventlet.posthooks'] = []",
            "",
            "        self.serializer.show(response, self.FIXTURE)",
            "",
            "        # just make sure the app_iter is called",
            "        for chunk in response.app_iter:",
            "            pass",
            "",
            "        self.assertNotEqual(response.request.environ['eventlet.posthooks'], [])",
            "",
            "    def test_image_send_notification(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 19,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_info(_event_type, _payload):",
            "            self.assertEqual(expected_payload, _payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'info', fake_info)",
            "",
            "        glance.api.common.image_send_notification(19, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_image_send_notification_error(self):",
            "        \"\"\"Ensure image.send notification is sent on error.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 17,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_error(_event_type, _payload):",
            "            self.assertEqual(expected_payload, _payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'error', fake_error)",
            "",
            "        # expected and actually sent bytes differ",
            "        glance.api.common.image_send_notification(17, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_redact_location(self):",
            "        \"\"\"Ensure location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123', 'location': 'http://localhost'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(redacted_image_meta, tmp_image_meta)",
            "",
            "    def test_noop_redact_location(self):",
            "        \"\"\"Check no-op location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(redacted_image_meta, tmp_image_meta)",
            "        self.assertEqual(redacted_image_meta, image_meta)",
            "",
            "",
            "class TestFilterValidator(base.IsolatedUnitTest):",
            "    def test_filter_validator(self):",
            "        self.assertFalse(glance.api.v1.filters.validate('size_max', -1))",
            "        self.assertTrue(glance.api.v1.filters.validate('size_max', 1))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'True'))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'FALSE'))",
            "        self.assertFalse(glance.api.v1.filters.validate('protected', '-1'))",
            "",
            "",
            "class TestAPIProtectedProps(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        # turn on property protections",
            "        self.set_property_protections()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props=None):",
            "        if props is None:",
            "            props = {}",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_prop_protection_with_create_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('bar', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_permitted_policy_config(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_create_prop_policy': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('bar',",
            "                         res_body['properties']['spl_create_prop_policy'])",
            "",
            "    def test_prop_protection_with_create_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify unpermitted role",
            "        'fake_member' can *not* create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        another_request.get_response(self.api)",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_show_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual('bar',",
            "                         res2.headers['x-image-meta-property-x_owner_foo'])",
            "",
            "    def test_prop_protection_with_show_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_get_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual('bar',",
            "                         res2.headers['x-image-meta-property-x_owner_foo'])",
            "",
            "    def test_prop_protection_with_get_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_detail_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual('bar', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_detail_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual('bar', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('baz', res_body['properties']['x_owner_foo'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'admin' can update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_default_policy': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_default_policy': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('baz', res_body['properties']['spl_default_policy'])",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_update_without_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be updated without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_only_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_only_prop': 'bar'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(webob.exc.HTTPForbidden.code, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_only_prop\", output.body)",
            "",
            "    def test_prop_protection_update_noop(self):",
            "        \"\"\"",
            "        Test protected property update is allowed as long as the user has read",
            "        access and the value is unchanged",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_read_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_prop': 'foo'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('foo', res_body['properties']['spl_read_prop'])",
            "        self.assertEqual(200, output.status_int)",
            "",
            "    def test_prop_protection_with_delete_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual({}, res_body['properties'])",
            "",
            "    def test_prop_protection_with_delete_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual({}, res_body['properties'])",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual('bar',",
            "                         output.headers['x-image-meta-property-x_owner_foo'])",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_delete(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without delete permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': 'foo'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_prop\", output.body)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            'foo', output.headers['x-image-meta-property-spl_update_prop'])",
            "",
            "    def test_read_protected_props_leak_with_update(self):",
            "        \"\"\"",
            "        Verify when updating props that ones we don't have read permission for",
            "        are not disclosed",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': '0',",
            "             'x-image-meta-property-foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_prop': '1',",
            "                   'X-Glance-Registry-Purge-Props': 'False'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('1', res_body['properties']['spl_update_prop'])",
            "        self.assertNotIn('foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/updatable by member.  Verify member can successfully update",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "             'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('baz', res_body['properties']['x_owner_foo'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/updatable by admin, but",
            "        also readable by spl_role.  The other is readable/updatable by",
            "        spl_role.  Verify spl_role can successfully update their property but",
            "        not the admin owned one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_update_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "",
            "        # verify spl_role can update it's prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '1',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('1', res_body['properties']['spl_read_only_prop'])",
            "        self.assertEqual('1', res_body['properties']['spl_update_prop'])",
            "",
            "        # verify spl_role can not update admin controlled prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '2',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_delete_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/deletable by member.  Verify member can successfully delete",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "                'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertNotIn('x_owner_foo', res_body['properties'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_delete_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/deletable by admin, but",
            "        also readable by spl_role.  The other is readable/deletable by",
            "        spl_role.  Verify spl_role is forbidden to purge_props in this scenario",
            "        without retaining the readable prop.",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_delete_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_create_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is creatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('1', res_body['properties']['x_all_permitted'])",
            "",
            "    def test_read_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is readable by an unknown",
            "        role",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_all_permitted': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            '1', output.headers['x-image-meta-property-x_all_permitted'])",
            "",
            "    def test_update_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is updatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('2', res_body['properties']['x_all_permitted'])",
            "",
            "    def test_delete_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is deletable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual({}, res_body['properties'])",
            "",
            "    def test_create_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is creatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        # also check admin can not create",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_permitted_admin': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_read_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is readable by no one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_none_read': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "        # also check admin can not read",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(200, output.status_int)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "",
            "    def test_update_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is updatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_update': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        # also check admin can't update property",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "    def test_delete_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is deletable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_delete': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "        # also check admin can't delete",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(403, output.status_int)",
            "",
            "",
            "class TestAPIPropertyQuotas(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIPropertyQuotas, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props=None):",
            "        if props is None:",
            "            props = {}",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_update_image_with_too_many_properties(self):",
            "        \"\"\"",
            "        Ensure that updating image properties enforces the quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(413, output.status_int)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", output.text)",
            "",
            "    def test_update_image_with_too_many_properties_without_purge_props(self):",
            "        \"\"\"",
            "        Ensure that updating image properties counts existing image propertys",
            "        when enforcing property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(413, output.status_int)",
            "        self.assertIn(\"Attempted: 2, Maximum: 1\", output.text)",
            "",
            "    def test_update_properties_without_purge_props_overwrite_value(self):",
            "        \"\"\"",
            "        Ensure that updating image properties does not count against image",
            "        property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=2)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in six.iteritems(headers):",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted_create': '3',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in six.iteritems(headers):",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(200, output.status_int)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual('1', res_body['properties']['x_all_permitted'])",
            "        self.assertEqual('3', res_body['properties']['x_all_permitted_create'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1744": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1745": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1753": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1754": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1779": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1780": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1781": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1782": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1784": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1786": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1787": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1788": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1789": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1790": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1791": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1792": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1793": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1794": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1795": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1797": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1798": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1799": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1800": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1803": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1813": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1814": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1816": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1820": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1821": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ]
        },
        "addLocation": []
    }
}