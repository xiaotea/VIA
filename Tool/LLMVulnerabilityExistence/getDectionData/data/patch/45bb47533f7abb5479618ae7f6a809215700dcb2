{
    "asteval/asteval.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " import time"
            },
            "1": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " from sys import exc_info, stderr, stdout"
            },
            "2": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .astutils import (HAS_NUMPY, UNSAFE_ATTRS, UNSAFE_ATTRS_DTYPES,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+from .astutils import (HAS_NUMPY,"
            },
            "5": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "                        ExceptionHolder, ReturnedNone, Empty, make_symbol_table,"
            },
            "6": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       numpy, op2func, valid_symbol_name, Procedure)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                       numpy, op2func, safe_getattr, safe_format, valid_symbol_name, Procedure)"
            },
            "8": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " ALL_NODES = ['arg', 'assert', 'assign', 'attribute', 'augassign', 'binop',"
            },
            "10": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "              'boolop', 'break', 'bytes', 'call', 'compare', 'constant',"
            },
            "11": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": 513,
                "PatchRowcode": "         fmt = '{__fstring__}'"
            },
            "12": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "         if node.format_spec is not None:"
            },
            "13": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 515,
                "PatchRowcode": "             fmt = f'{{__fstring__:{self.run(node.format_spec)}}}'"
            },
            "14": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return fmt.format(__fstring__=val)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 516,
                "PatchRowcode": "+        return safe_format(fmt, self.raise_exception, node, __fstring__=val)"
            },
            "16": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 517,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 518,
                "PatchRowcode": "     def _getsym(self, node):"
            },
            "18": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 519,
                "PatchRowcode": "         val = self.symtable.get(node.id, ReturnedNone)"
            },
            "19": {
                "beforePatchRowNumber": 573,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "         sym = self.run(node.value)"
            },
            "20": {
                "beforePatchRowNumber": 574,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "         if ctx == ast.Del:"
            },
            "21": {
                "beforePatchRowNumber": 575,
                "afterPatchRowNumber": 575,
                "PatchRowcode": "             return delattr(sym, node.attr)"
            },
            "22": {
                "beforePatchRowNumber": 576,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        #"
            },
            "23": {
                "beforePatchRowNumber": 577,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        unsafe = (node.attr in UNSAFE_ATTRS or"
            },
            "24": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                 (node.attr.startswith('__') and node.attr.endswith('__')))"
            },
            "25": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not unsafe:"
            },
            "26": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for dtype, attrlist in UNSAFE_ATTRS_DTYPES.items():"
            },
            "27": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                unsafe = isinstance(sym, dtype) and node.attr in attrlist"
            },
            "28": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if unsafe:"
            },
            "29": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    break"
            },
            "30": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if unsafe:"
            },
            "31": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = f\"no safe attribute '{node.attr}' for {repr(sym)}\""
            },
            "32": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.raise_exception(node, exc=AttributeError, msg=msg)"
            },
            "33": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "34": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            try:"
            },
            "35": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return getattr(sym, node.attr)"
            },
            "36": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except AttributeError:"
            },
            "37": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                pass"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+        "
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 577,
                "PatchRowcode": "+        return safe_getattr(sym, node.attr, self.raise_exception, node)"
            },
            "40": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 578,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 579,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "     def on_assign(self, node):    # ('targets', 'value')"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "\"\"\"",
            "Safe(ish) evaluation of minimal Python code using Python's ast module.",
            "",
            "This module provides an Interpreter class that compiles a restricted set of",
            "Python expressions and statements to Python's AST representation, and then",
            "executes that representation using values held in a symbol table.",
            "",
            "The symbol table is a simple dictionary, giving a flat namespace.  This comes",
            "pre-loaded with many functions from Python's builtin and math module.  If numpy",
            "is installed, many numpy functions are also included.  Additional symbols can",
            "be added when an Interpreter is created, but the user of that interpreter will",
            "not be able to import additional modules.",
            "",
            "Expressions, including loops, conditionals, and function definitions can be",
            "compiled into ast node and then evaluated later, using the current values",
            "in the symbol table.",
            "",
            "The result is a restricted, simplified version of Python meant for numerical",
            "calculations that is somewhat safer than 'eval' because many unsafe operations",
            "(such as 'eval') are simply not allowed, and others (such as 'import') are",
            "disabled by default, but can be explicitly enabled.",
            "",
            "Many parts of Python syntax are supported, including:",
            "     for loops, while loops, if-then-elif-else conditionals, with,",
            "     try-except-finally",
            "     function definitions with def",
            "     advanced slicing:    a[::-1], array[-3:, :, ::2]",
            "     if-expressions:      out = one_thing if TEST else other",
            "     list, dict, and set comprehension",
            "",
            "The following Python syntax elements are not supported:",
            "     Import, Exec, Lambda, Class, Global, Generators,",
            "     Yield, Decorators",
            "",
            "In addition, while many builtin functions are supported, several builtin",
            "functions that are considered unsafe are missing ('eval', 'exec', and",
            "'getattr' for example) are missing.",
            "\"\"\"",
            "import ast",
            "import sys",
            "import copy",
            "import inspect",
            "import time",
            "from sys import exc_info, stderr, stdout",
            "",
            "from .astutils import (HAS_NUMPY, UNSAFE_ATTRS, UNSAFE_ATTRS_DTYPES,",
            "                       ExceptionHolder, ReturnedNone, Empty, make_symbol_table,",
            "                       numpy, op2func, valid_symbol_name, Procedure)",
            "",
            "ALL_NODES = ['arg', 'assert', 'assign', 'attribute', 'augassign', 'binop',",
            "             'boolop', 'break', 'bytes', 'call', 'compare', 'constant',",
            "             'continue', 'delete', 'dict', 'dictcomp', 'ellipsis',",
            "             'excepthandler', 'expr', 'extslice', 'for', 'functiondef', 'if',",
            "             'ifexp', 'import', 'importfrom', 'index', 'interrupt', 'list',",
            "             'listcomp', 'module', 'name', 'nameconstant', 'num', 'pass',",
            "             'raise', 'repr', 'return', 'set', 'setcomp', 'slice', 'str',",
            "             'subscript', 'try', 'tuple', 'unaryop', 'while', 'with',",
            "             'formattedvalue', 'joinedstr']",
            "",
            "",
            "MINIMAL_CONFIG = {'import': False, 'importfrom': False}",
            "DEFAULT_CONFIG = {'import': False, 'importfrom': False}",
            "",
            "for _tnode in ('assert', 'augassign', 'delete', 'if', 'ifexp', 'for',",
            "             'formattedvalue', 'functiondef', 'print', 'raise', 'listcomp',",
            "             'dictcomp', 'setcomp', 'try', 'while', 'with'):",
            "    MINIMAL_CONFIG[_tnode] = False",
            "    DEFAULT_CONFIG[_tnode] = True",
            "",
            "class Interpreter:",
            "    \"\"\"create an asteval Interpreter: a restricted, simplified interpreter",
            "    of mathematical expressions using Python syntax.",
            "",
            "    Parameters",
            "    ----------",
            "    symtable : dict or `None`",
            "        dictionary or SymbolTable to use as symbol table (if `None`, one will be created).",
            "    nested_symtable : bool, optional",
            "        whether to use a new-style nested symbol table instead of a plain dict [False]",
            "    user_symbols : dict or `None`",
            "        dictionary of user-defined symbols to add to symbol table.",
            "    writer : file-like or `None`",
            "        callable file-like object where standard output will be sent.",
            "    err_writer : file-like or `None`",
            "        callable file-like object where standard error will be sent.",
            "    use_numpy : bool",
            "        whether to use functions from numpy.",
            "    max_statement_length : int",
            "        maximum length of expression allowed [50,000 characters]",
            "    readonly_symbols : iterable or `None`",
            "        symbols that the user can not assign to",
            "    builtins_readonly : bool",
            "        whether to blacklist all symbols that are in the initial symtable",
            "    minimal : bool",
            "        create a minimal interpreter: disable many nodes (see Note 1).",
            "    config : dict",
            "        dictionay listing which nodes to support (see note 2))",
            "",
            "    Notes",
            "    -----",
            "    1. setting `minimal=True` is equivalent to setting a config with the following",
            "       nodes disabled: ('import', 'importfrom', 'if', 'for', 'while', 'try', 'with',",
            "       'functiondef', 'ifexp', 'listcomp', 'dictcomp', 'setcomp', 'augassign',",
            "       'assert', 'delete', 'raise', 'print')",
            "    2. by default 'import' and 'importfrom' are disabled, though they can be enabled.",
            "    \"\"\"",
            "    def __init__(self, symtable=None, nested_symtable=False,",
            "                 user_symbols=None, writer=None, err_writer=None,",
            "                 use_numpy=True, max_statement_length=50000,",
            "                 minimal=False, readonly_symbols=None,",
            "                 builtins_readonly=False, config=None, **kws):",
            "",
            "        self.config = copy.copy(MINIMAL_CONFIG if minimal else DEFAULT_CONFIG)",
            "        if config is not None:",
            "            self.config.update(config)",
            "        self.config['nested_symtable'] = nested_symtable",
            "",
            "        if user_symbols is None:",
            "            user_symbols = {}",
            "            if 'usersyms' in kws:",
            "                user_symbols = kws.pop('usersyms') # back compat, changed July, 2023, v 0.9.4",
            "",
            "        if len(kws) > 0:",
            "            for key, val in kws.items():",
            "                if key.startswith('no_'):",
            "                    node = key[3:]",
            "                    if node in ALL_NODES:",
            "                        self.config[node] = not val",
            "                elif key.startswith('with_'):",
            "                    node = key[5:]",
            "                    if node in ALL_NODES:",
            "                        self.config[node] = val",
            "",
            "        self.writer = writer or stdout",
            "        self.err_writer = err_writer or stderr",
            "        self.max_statement_length = max(1, min(1.e8, max_statement_length))",
            "",
            "        self.use_numpy = HAS_NUMPY and use_numpy",
            "        if symtable is None:",
            "            symtable = make_symbol_table(nested=nested_symtable,",
            "                                         use_numpy=self.use_numpy, **user_symbols)",
            "",
            "        symtable['print'] = self._printer",
            "        self.symtable = symtable",
            "        self._interrupt = None",
            "        self.error = []",
            "        self.error_msg = None",
            "        self.expr = None",
            "        self.retval = None",
            "        self._calldepth = 0",
            "        self.lineno = 0",
            "        self.start_time = time.time()",
            "",
            "        self.node_handlers = {}",
            "        for node in ALL_NODES:",
            "            handler = self.unimplemented",
            "            if self.config.get(node, True):",
            "                handler = getattr(self, f\"on_{node}\", self.unimplemented)",
            "            self.node_handlers[node] = handler",
            "",
            "        # to rationalize try/except try/finally",
            "        if 'try' in self.node_handlers:",
            "            self.node_handlers['tryexcept'] = self.node_handlers['try']",
            "            self.node_handlers['tryfinally'] = self.node_handlers['try']",
            "",
            "        if readonly_symbols is None:",
            "            self.readonly_symbols = set()",
            "        else:",
            "            self.readonly_symbols = set(readonly_symbols)",
            "",
            "        if builtins_readonly:",
            "            self.readonly_symbols |= set(self.symtable)",
            "",
            "        self.no_deepcopy = [key for key, val in symtable.items()",
            "                            if (callable(val)",
            "                                or inspect.ismodule(val)",
            "                                or 'numpy.lib.index_tricks' in repr(type(val)))]",
            "",
            "    def remove_nodehandler(self, node):",
            "        \"\"\"remove support for a node",
            "        returns current node handler, so that it",
            "        might be re-added with add_nodehandler()",
            "        \"\"\"",
            "        out = None",
            "        if node in self.node_handlers:",
            "            out = self.node_handlers.pop(node)",
            "        return out",
            "",
            "    def set_nodehandler(self, node, handler=None):",
            "        \"\"\"set node handler or use current built-in default\"\"\"",
            "        if handler is None:",
            "            handler = getattr(self, f\"on_{node}\", self.unimplemented)",
            "        self.node_handlers[node] = handler",
            "        return handler",
            "",
            "    def user_defined_symbols(self):",
            "        \"\"\"Return a set of symbols that have been added to symtable after",
            "        construction.",
            "",
            "        I.e., the symbols from self.symtable that are not in",
            "        self.no_deepcopy.",
            "",
            "        Returns",
            "        -------",
            "        unique_symbols : set",
            "            symbols in symtable that are not in self.no_deepcopy",
            "",
            "        \"\"\"",
            "        sym_in_current = set(self.symtable.keys())",
            "        sym_from_construction = set(self.no_deepcopy)",
            "        unique_symbols = sym_in_current.difference(sym_from_construction)",
            "        return unique_symbols",
            "",
            "    def unimplemented(self, node):",
            "        \"\"\"Unimplemented nodes.\"\"\"",
            "        msg = f\"{node.__class__.__name__} not supported\"",
            "        self.raise_exception(node, exc=NotImplementedError, msg=msg)",
            "",
            "    def raise_exception(self, node, exc=None, msg='', expr=None, lineno=None):",
            "        \"\"\"Add an exception.\"\"\"",
            "        if expr is not None:",
            "            self.expr = expr",
            "        msg = str(msg)",
            "        err = ExceptionHolder(node, exc=exc, msg=msg, expr=self.expr, lineno=lineno)",
            "        self._interrupt = ast.Raise()",
            "",
            "        self.error.append(err)",
            "        if self.error_msg is None:",
            "            self.error_msg = msg",
            "        elif len(msg) > 0:",
            "            pass",
            "            # if err.exc is not None:",
            "            #     self.error_msg = f\"{err.exc.__name__}: {msg}\"",
            "        if exc is None:",
            "            exc = self.error[-1].exc",
            "            if exc is None and len(self.error) > 0:",
            "                while exc is None and len(self.error) > 0:",
            "                    err = self.error.pop()",
            "                    exc = err.exc",
            "        if exc is None:",
            "            exc = Exception",
            "        if len(err.msg) == 0 and len(self.error_msg) == 0 and len(self.error) > 1:",
            "            err = self.error.pop(-1)",
            "            raise err.exc(err.msg)",
            "        else:",
            "            if len(err.msg) == 0:",
            "                err.msg = self.error_msg",
            "            raise exc(self.error_msg)",
            "",
            "    # main entry point for Ast node evaluation",
            "    #  parse:  text of statements -> ast",
            "    #  run:    ast -> result",
            "    #  eval:   string statement -> result = run(parse(statement))",
            "    def parse(self, text):",
            "        \"\"\"Parse statement/expression to Ast representation.\"\"\"",
            "        if len(text) > self.max_statement_length:",
            "            msg = f'length of text exceeds {self.max_statement_length:d} characters'",
            "            self.raise_exception(None, exc=RuntimeError, expr=msg)",
            "        self.expr = text",
            "        try:",
            "            out = ast.parse(text)",
            "        except SyntaxError:",
            "            self.raise_exception(None, exc=SyntaxError, expr=text)",
            "        except:",
            "            self.raise_exception(None, exc=RuntimeError, expr=text)",
            "",
            "        return out",
            "",
            "    def run(self, node, expr=None, lineno=None, with_raise=True):",
            "        \"\"\"Execute parsed Ast representation for an expression.\"\"\"",
            "        # Note: keep the 'node is None' test: internal code here may run",
            "        #    run(None) and expect a None in return.",
            "        if isinstance(node, str):",
            "            return self.eval(node, raise_errors=with_raise)",
            "",
            "        out = None",
            "        if len(self.error) > 0:",
            "            return out",
            "        if self.retval is not None:",
            "            return self.retval",
            "        if isinstance(self._interrupt, (ast.Break, ast.Continue)):",
            "            return self._interrupt",
            "        if node is None:",
            "            return out",
            "",
            "        if lineno is not None:",
            "            self.lineno = lineno",
            "        if expr is not None:",
            "            self.expr = expr",
            "",
            "        # get handler for this node:",
            "        #   on_xxx with handle nodes of type 'xxx', etc",
            "        try:",
            "            handler = self.node_handlers[node.__class__.__name__.lower()]",
            "        except KeyError:",
            "            self.raise_exception(None, exc=NotImplementedError, expr=self.expr)",
            "",
            "        # run the handler:  this will likely generate",
            "        # recursive calls into this run method.",
            "        try:",
            "            ret = handler(node)",
            "            if isinstance(ret, enumerate):",
            "                ret = list(ret)",
            "            return ret",
            "        except:",
            "            if with_raise and self.expr is not None:",
            "                self.raise_exception(node, expr=self.expr)",
            "",
            "        # avoid too many repeated error messages (yes, this needs to be \"2\")",
            "        if len(self.error) > 2:",
            "            self._remove_duplicate_errors()",
            "",
            "        return None",
            "",
            "    def _remove_duplicate_errors(self):",
            "        \"\"\"remove duplicate exceptions\"\"\"",
            "        error = [self.error[0]]",
            "        for err in self.error[1:]:",
            "            lerr = error[-1]",
            "            if err.exc != lerr.exc or err.expr != lerr.expr or err.msg !=  lerr.msg:",
            "                if isinstance(err.msg, str) and len(err.msg) > 0:",
            "                    error.append(err)",
            "        self.error = error",
            "",
            "    def __call__(self, expr, **kw):",
            "        \"\"\"Call class instance as function.\"\"\"",
            "        return self.eval(expr, **kw)",
            "",
            "    def eval(self, expr, lineno=0, show_errors=True, raise_errors=False):",
            "        \"\"\"Evaluate a single statement.\"\"\"",
            "        self.lineno = lineno",
            "        self.error = []",
            "        self.error_msg = None",
            "        self.start_time = time.time()",
            "        if isinstance(expr, str):",
            "            try:",
            "                node = self.parse(expr)",
            "            except Exception:",
            "                errmsg = exc_info()[1]",
            "                if len(self.error) > 0:",
            "                    lerr = self.error[-1]",
            "                    errmsg = lerr.get_error()[1]",
            "                    if raise_errors:",
            "                        raise lerr.exc(errmsg)",
            "                if show_errors:",
            "                    print(errmsg, file=self.err_writer)",
            "                return None",
            "        else:",
            "            node = expr",
            "        try:",
            "            return self.run(node, expr=expr, lineno=lineno, with_raise=raise_errors)",
            "        except Exception:",
            "            if show_errors and not raise_errors:",
            "                errmsg = exc_info()[1]",
            "                if len(self.error) > 0:",
            "                    errmsg = self.error[-1].get_error()[1]",
            "                print(errmsg, file=self.err_writer)",
            "        if raise_errors and len(self.error) > 0:",
            "            self._remove_duplicate_errors()",
            "            err = self.error[-1]",
            "            raise err.exc(err.get_error()[1])",
            "        return None",
            "",
            "    @staticmethod",
            "    def dump(node, **kw):",
            "        \"\"\"Simple ast dumper.\"\"\"",
            "        return ast.dump(node, **kw)",
            "",
            "    # handlers for ast components",
            "    def on_expr(self, node):",
            "        \"\"\"Expression.\"\"\"",
            "        return self.run(node.value)  # ('value',)",
            "",
            "    # imports",
            "    def on_import(self, node):    # ('names',)",
            "        \"simple import\"",
            "        for tnode in node.names:",
            "            self.import_module(tnode.name, tnode.asname)",
            "",
            "    def on_importfrom(self, node):    # ('module', 'names', 'level')",
            "        \"import/from\"",
            "        fromlist, asname = [], []",
            "        for tnode in node.names:",
            "            fromlist.append(tnode.name)",
            "            asname.append(tnode.asname)",
            "        self.import_module(node.module, asname, fromlist=fromlist)",
            "",
            "    def import_module(self, name, asname, fromlist=None):",
            "        \"\"\"import a python module, installing it into the symbol table.",
            "        options:",
            "          name       name of module to import 'foo' in 'import foo'",
            "          asname     alias for imported name(s)",
            "                          'bar' in 'import foo as bar'",
            "                       or",
            "                          ['s','t'] in 'from foo import x as s, y as t'",
            "          fromlist   list of symbols to import with 'from-import'",
            "                         ['x','y'] in 'from foo import x, y'",
            "        \"\"\"",
            "        # find module in sys.modules or import to it",
            "        if name in sys.modules:",
            "            thismod = sys.modules[name]",
            "        else:",
            "            try:",
            "                __import__(name)",
            "                thismod = sys.modules[name]",
            "            except:",
            "                self.raise_exception(None, exc=ImportError, msg='Import Error')",
            "",
            "        if fromlist is None:",
            "            if asname is not None:",
            "                self.symtable[asname] = sys.modules[name]",
            "            else:",
            "                mparts = []",
            "                parts = name.split('.')",
            "                while len(parts) > 0:",
            "                    mparts.append(parts.pop(0))",
            "                    modname = '.'.join(mparts)",
            "                    inname = name if (len(parts) == 0) else modname",
            "                    self.symtable[inname] = sys.modules[modname]",
            "        else: #  import-from construct",
            "            if asname is None:",
            "                asname = [None]*len(fromlist)",
            "            for sym, alias in zip(fromlist, asname):",
            "                if alias is None:",
            "                    alias = sym",
            "                self.symtable[alias] = getattr(thismod, sym)",
            "",
            "    def on_index(self, node):",
            "        \"\"\"Index.\"\"\"",
            "        return self.run(node.value)  # ('value',)",
            "",
            "    def on_return(self, node):  # ('value',)",
            "        \"\"\"Return statement: look for None, return special sentinel.\"\"\"",
            "        if self._calldepth == 0:",
            "            raise SyntaxError('cannot return at top level')",
            "        self.retval = self.run(node.value)",
            "        if self.retval is None:",
            "            self.retval = ReturnedNone",
            "",
            "    def on_repr(self, node):",
            "        \"\"\"Repr.\"\"\"",
            "        return repr(self.run(node.value))  # ('value',)",
            "",
            "    def on_module(self, node):    # ():('body',)",
            "        \"\"\"Module def.\"\"\"",
            "        out = None",
            "        for tnode in node.body:",
            "            out = self.run(tnode)",
            "        return out",
            "",
            "    def on_expression(self, node):",
            "        \"basic expression\"",
            "        return self.on_module(node)  # ():('body',)",
            "",
            "    def on_pass(self, node):",
            "        \"\"\"Pass statement.\"\"\"",
            "        return None  # ()",
            "",
            "    # for break and continue: set the instance variable _interrupt",
            "    def on_interrupt(self, node):    # ()",
            "        \"\"\"Interrupt handler.\"\"\"",
            "        self._interrupt = node",
            "        return node",
            "",
            "    def on_break(self, node):",
            "        \"\"\"Break.\"\"\"",
            "        return self.on_interrupt(node)",
            "",
            "    def on_continue(self, node):",
            "        \"\"\"Continue.\"\"\"",
            "        return self.on_interrupt(node)",
            "",
            "    def on_assert(self, node):    # ('test', 'msg')",
            "        \"\"\"Assert statement.\"\"\"",
            "        if not self.run(node.test):",
            "            msg = node.msg.value if node.msg else \"\"",
            "            # msg = node.msg.s if node.msg else \"\"",
            "            self.raise_exception(node, exc=AssertionError, msg=msg)",
            "        return True",
            "",
            "    def on_list(self, node):    # ('elt', 'ctx')",
            "        \"\"\"List.\"\"\"",
            "        return [self.run(e) for e in node.elts]",
            "",
            "    def on_tuple(self, node):    # ('elts', 'ctx')",
            "        \"\"\"Tuple.\"\"\"",
            "        return tuple(self.on_list(node))",
            "",
            "    def on_set(self, node):    # ('elts')",
            "        \"\"\"Set.\"\"\"",
            "        return set([self.run(k) for k in node.elts])",
            "",
            "    def on_dict(self, node):    # ('keys', 'values')",
            "        \"\"\"Dictionary.\"\"\"",
            "        return {self.run(k): self.run(v) for k, v in",
            "                zip(node.keys, node.values)}",
            "",
            "    def on_constant(self, node):   # ('value', 'kind')",
            "        \"\"\"Return constant value.\"\"\"",
            "        return node.value",
            "",
            "    def on_joinedstr(self, node):  # ('values',)",
            "        \"join strings, used in f-strings\"",
            "        return ''.join([self.run(k) for k in node.values])",
            "",
            "    def on_formattedvalue(self, node): # ('value', 'conversion', 'format_spec')",
            "        \"formatting used in f-strings\"",
            "        val = self.run(node.value)",
            "        fstring_converters = {115: str, 114: repr, 97: ascii}",
            "        if node.conversion in fstring_converters:",
            "            val = fstring_converters[node.conversion](val)",
            "        fmt = '{__fstring__}'",
            "        if node.format_spec is not None:",
            "            fmt = f'{{__fstring__:{self.run(node.format_spec)}}}'",
            "        return fmt.format(__fstring__=val)",
            "",
            "    def _getsym(self, node):",
            "        val = self.symtable.get(node.id, ReturnedNone)",
            "        if isinstance(val, Empty):",
            "            msg = f\"name '{node.id}' is not defined\"",
            "            self.raise_exception(node, exc=NameError, msg=msg)",
            "        return val",
            "",
            "    def on_name(self, node):    # ('id', 'ctx')",
            "        \"\"\"Name node.\"\"\"",
            "        ctx = node.ctx.__class__",
            "        if ctx in (ast.Param, ast.Del):",
            "            return str(node.id)",
            "        return self._getsym(node)",
            "",
            "    def node_assign(self, node, val):",
            "        \"\"\"Assign a value (not the node.value object) to a node.",
            "",
            "        This is used by on_assign, but also by for, list comprehension,",
            "        etc.",
            "",
            "        \"\"\"",
            "        if node.__class__ == ast.Name:",
            "            if (not valid_symbol_name(node.id) or",
            "                    node.id in self.readonly_symbols):",
            "                errmsg = f\"invalid symbol name (reserved word?) {node.id}\"",
            "                self.raise_exception(node, exc=NameError, msg=errmsg)",
            "            self.symtable[node.id] = val",
            "            if node.id in self.no_deepcopy:",
            "                self.no_deepcopy.remove(node.id)",
            "",
            "        elif node.__class__ == ast.Attribute:",
            "            if node.ctx.__class__ == ast.Load:",
            "                msg = f\"cannot assign to attribute {node.attr}\"",
            "                self.raise_exception(node, exc=AttributeError, msg=msg)",
            "",
            "            setattr(self.run(node.value), node.attr, val)",
            "",
            "        elif node.__class__ == ast.Subscript:",
            "            self.run(node.value)[self.run(node.slice)] = val",
            "",
            "        elif node.__class__ in (ast.Tuple, ast.List):",
            "            if len(val) == len(node.elts):",
            "                for telem, tval in zip(node.elts, val):",
            "                    self.node_assign(telem, tval)",
            "            else:",
            "                raise ValueError('too many values to unpack')",
            "",
            "    def on_attribute(self, node):    # ('value', 'attr', 'ctx')",
            "        \"\"\"Extract attribute.\"\"\"",
            "",
            "        ctx = node.ctx.__class__",
            "        if ctx == ast.Store:",
            "            msg = \"attribute for storage: shouldn't be here!\"",
            "            self.raise_exception(node, exc=RuntimeError, msg=msg)",
            "",
            "        sym = self.run(node.value)",
            "        if ctx == ast.Del:",
            "            return delattr(sym, node.attr)",
            "        #",
            "        unsafe = (node.attr in UNSAFE_ATTRS or",
            "                 (node.attr.startswith('__') and node.attr.endswith('__')))",
            "        if not unsafe:",
            "            for dtype, attrlist in UNSAFE_ATTRS_DTYPES.items():",
            "                unsafe = isinstance(sym, dtype) and node.attr in attrlist",
            "                if unsafe:",
            "                    break",
            "        if unsafe:",
            "            msg = f\"no safe attribute '{node.attr}' for {repr(sym)}\"",
            "            self.raise_exception(node, exc=AttributeError, msg=msg)",
            "        else:",
            "            try:",
            "                return getattr(sym, node.attr)",
            "            except AttributeError:",
            "                pass",
            "",
            "",
            "    def on_assign(self, node):    # ('targets', 'value')",
            "        \"\"\"Simple assignment.\"\"\"",
            "        val = self.run(node.value)",
            "        for tnode in node.targets:",
            "            self.node_assign(tnode, val)",
            "",
            "    def on_augassign(self, node):    # ('target', 'op', 'value')",
            "        \"\"\"Augmented assign.\"\"\"",
            "        return self.on_assign(ast.Assign(targets=[node.target],",
            "                                         value=ast.BinOp(left=node.target,",
            "                                                         op=node.op,",
            "                                                         right=node.value)))",
            "",
            "    def on_slice(self, node):    # ():('lower', 'upper', 'step')",
            "        \"\"\"Simple slice.\"\"\"",
            "        return slice(self.run(node.lower),",
            "                     self.run(node.upper),",
            "                     self.run(node.step))",
            "",
            "    def on_extslice(self, node):    # ():('dims',)",
            "        \"\"\"Extended slice.\"\"\"",
            "        return tuple([self.run(tnode) for tnode in node.dims])",
            "",
            "    def on_subscript(self, node): # ('value', 'slice', 'ctx')",
            "        \"\"\"Subscript handling\"\"\"",
            "        return self.run(node.value)[self.run(node.slice)]",
            "",
            "",
            "    def on_delete(self, node):    # ('targets',)",
            "        \"\"\"Delete statement.\"\"\"",
            "        for tnode in node.targets:",
            "            if tnode.ctx.__class__ != ast.Del:",
            "                break",
            "            children = []",
            "            while tnode.__class__ == ast.Attribute:",
            "                children.append(tnode.attr)",
            "                tnode = tnode.value",
            "            if (tnode.__class__ == ast.Name and",
            "                    tnode.id not in self.readonly_symbols):",
            "                children.append(tnode.id)",
            "                children.reverse()",
            "                self.symtable.pop('.'.join(children))",
            "            elif tnode.__class__ == ast.Subscript:",
            "                nslice = self.run(tnode.slice)",
            "                children = []",
            "                tnode = tnode.value",
            "                while tnode.__class__ == ast.Attribute:",
            "                    children.append(tnode.attr)",
            "                    tnode = tnode.value",
            "                if (tnode.__class__ == ast.Name and not",
            "                    tnode.id in self.readonly_symbols):",
            "                    children.append(tnode.id)",
            "                    children.reverse()",
            "                    sname = '.'.join(children)",
            "                    val = self.run(sname)",
            "                    del val[nslice]",
            "                    if len(children) == 1:",
            "                        self.symtable[sname] = val",
            "                    else:",
            "                        child = self.symtable[children[0]]",
            "                        for cname in children[1:-1]:",
            "                            child = child[cname]",
            "                        setattr(child, children[-1], val)",
            "",
            "    def on_unaryop(self, node):    # ('op', 'operand')",
            "        \"\"\"Unary operator.\"\"\"",
            "        return op2func(node.op)(self.run(node.operand))",
            "",
            "    def on_binop(self, node):    # ('left', 'op', 'right')",
            "        \"\"\"Binary operator.\"\"\"",
            "        return op2func(node.op)(self.run(node.left),",
            "                                self.run(node.right))",
            "",
            "    def on_boolop(self, node):    # ('op', 'values')",
            "        \"\"\"Boolean operator.\"\"\"",
            "        val = self.run(node.values[0])",
            "        is_and = ast.And == node.op.__class__",
            "        if (is_and and val) or (not is_and and not val):",
            "            for nodeval in node.values[1:]:",
            "                val = op2func(node.op)(val, self.run(nodeval))",
            "                if (is_and and not val) or (not is_and and val):",
            "                    break",
            "        return val",
            "",
            "    def on_compare(self, node):  # ('left', 'ops', 'comparators')",
            "        \"\"\"comparison operators, including chained comparisons (a<b<c)\"\"\"",
            "        lval = self.run(node.left)",
            "        results = []",
            "        multi = len(node.ops) > 1",
            "        for oper, rnode in zip(node.ops, node.comparators):",
            "            rval = self.run(rnode)",
            "            ret = op2func(oper)(lval, rval)",
            "            if multi:",
            "                results.append(ret)",
            "                if not all(results):",
            "                    return False",
            "                lval = rval",
            "        if multi:",
            "            ret = all(results)",
            "        return ret",
            "",
            "    def _printer(self, *out, **kws):",
            "        \"\"\"Generic print function.\"\"\"",
            "        if self.config.get('print', True):",
            "            flush = kws.pop('flush', True)",
            "            fileh = kws.pop('file', self.writer)",
            "            sep = kws.pop('sep', ' ')",
            "            end = kws.pop('sep', '\\n')",
            "            print(*out, file=fileh, sep=sep, end=end)",
            "            if flush:",
            "                fileh.flush()",
            "",
            "    def on_if(self, node):    # ('test', 'body', 'orelse')",
            "        \"\"\"Regular if-then-else statement.\"\"\"",
            "        block = node.body",
            "        if not self.run(node.test):",
            "            block = node.orelse",
            "        for tnode in block:",
            "            self.run(tnode)",
            "",
            "    def on_ifexp(self, node):    # ('test', 'body', 'orelse')",
            "        \"\"\"If expressions.\"\"\"",
            "        expr = node.orelse",
            "        if self.run(node.test):",
            "            expr = node.body",
            "        return self.run(expr)",
            "",
            "    def on_while(self, node):    # ('test', 'body', 'orelse')",
            "        \"\"\"While blocks.\"\"\"",
            "        while self.run(node.test):",
            "            self._interrupt = None",
            "            for tnode in node.body:",
            "                self.run(tnode)",
            "                if self._interrupt is not None:",
            "                    break",
            "            if isinstance(self._interrupt, ast.Break):",
            "                break",
            "        else:",
            "            for tnode in node.orelse:",
            "                self.run(tnode)",
            "        self._interrupt = None",
            "",
            "    def on_for(self, node):    # ('target', 'iter', 'body', 'orelse')",
            "        \"\"\"For blocks.\"\"\"",
            "        for val in self.run(node.iter):",
            "            self.node_assign(node.target, val)",
            "            self._interrupt = None",
            "            for tnode in node.body:",
            "                self.run(tnode)",
            "                if self._interrupt is not None:",
            "                    break",
            "            if isinstance(self._interrupt, ast.Break):",
            "                break",
            "        else:",
            "            for tnode in node.orelse:",
            "                self.run(tnode)",
            "        self._interrupt = None",
            "",
            "    def on_with(self, node):    # ('items', 'body', 'type_comment')",
            "        \"\"\"with blocks.\"\"\"",
            "        contexts = []",
            "        for item in node.items:",
            "            ctx = self.run(item.context_expr)",
            "            contexts.append(ctx)",
            "            if hasattr(ctx, '__enter__'):",
            "                result = ctx.__enter__()",
            "                if item.optional_vars is not None:",
            "                    self.node_assign(item.optional_vars, result)",
            "            else:",
            "                msg = \"object does not support the context manager protocol\"",
            "                raise TypeError(f\"'{type(ctx)}' {msg}\")",
            "        for bnode in node.body:",
            "            self.run(bnode)",
            "            if self._interrupt is not None:",
            "                break",
            "",
            "        for ctx in contexts:",
            "            if hasattr(ctx, '__exit__'):",
            "                ctx.__exit__()",
            "",
            "    def _comp_save_syms(self, node):",
            "        \"\"\"find and save symbols that will be used in a comprehension\"\"\"",
            "        saved_syms = {}",
            "        for tnode in node.generators:",
            "            if tnode.target.__class__ == ast.Name:",
            "                if (not valid_symbol_name(tnode.target.id) or",
            "                    tnode.target.id in self.readonly_symbols):",
            "                    errmsg = f\"invalid symbol name (reserved word?) {tnode.target.id}\"",
            "                    self.raise_exception(tnode.target, exc=NameError, msg=errmsg)",
            "                if tnode.target.id in self.symtable:",
            "                    saved_syms[tnode.target.id] = copy.deepcopy(self._getsym(tnode.target))",
            "",
            "            elif tnode.target.__class__ == ast.Tuple:",
            "                for tval in tnode.target.elts:",
            "                    if tval.id in self.symtable:",
            "                        saved_syms[tval.id] = copy.deepcopy(self._getsym(tval))",
            "        return saved_syms",
            "",
            "",
            "    def do_generator(self, gnodes, node, out):",
            "        \"\"\"general purpose generator \"\"\"",
            "        gnode = gnodes[0]",
            "        nametype = True",
            "        target = None",
            "        if gnode.target.__class__ == ast.Name:",
            "            if (not valid_symbol_name(gnode.target.id) or",
            "                gnode.target.id in self.readonly_symbols):",
            "                errmsg = f\"invalid symbol name (reserved word?) {gnode.target.id}\"",
            "                self.raise_exception(gnode.target, exc=NameError, msg=errmsg)",
            "            target = gnode.target.id",
            "        elif gnode.target.__class__ == ast.Tuple:",
            "            nametype = False",
            "            target = tuple([gval.id for gval in gnode.target.elts])",
            "",
            "        for val in self.run(gnode.iter):",
            "            if nametype and target is not None:",
            "                self.symtable[target] = val",
            "            else:",
            "                for telem, tval in zip(target, val):",
            "                    self.symtable[telem] = tval",
            "            add = True",
            "            for cond in gnode.ifs:",
            "                add = add and self.run(cond)",
            "                if not add:",
            "                    break",
            "            if add:",
            "                if len(gnodes) > 1:",
            "                    self.do_generator(gnodes[1:], node, out)",
            "                elif isinstance(out, list):",
            "                    out.append(self.run(node.elt))",
            "                elif isinstance(out, dict):",
            "                    out[self.run(node.key)] = self.run(node.value)",
            "",
            "    def on_listcomp(self, node):",
            "        \"\"\"List comprehension v2\"\"\"",
            "        saved_syms = self._comp_save_syms(node)",
            "",
            "        out = []",
            "        self.do_generator(node.generators, node, out)",
            "        for name, val in saved_syms.items():",
            "            self.symtable[name] = val",
            "        return out",
            "",
            "    def on_setcomp(self, node):",
            "        \"\"\"Set comprehension\"\"\"",
            "        return set(self.on_listcomp(node))",
            "",
            "    def on_dictcomp(self, node):",
            "        \"\"\"Dict comprehension v2\"\"\"",
            "        saved_syms = self._comp_save_syms(node)",
            "",
            "        out = {}",
            "        self.do_generator(node.generators, node, out)",
            "        for name, val in saved_syms.items():",
            "            self.symtable[name] = val",
            "        return out",
            "",
            "    def on_excepthandler(self, node):  # ('type', 'name', 'body')",
            "        \"\"\"Exception handler...\"\"\"",
            "        return (self.run(node.type), node.name, node.body)",
            "",
            "    def on_try(self, node):    # ('body', 'handlers', 'orelse', 'finalbody')",
            "        \"\"\"Try/except/else/finally blocks.\"\"\"",
            "        no_errors = True",
            "        for tnode in node.body:",
            "            self.run(tnode, with_raise=False)",
            "            no_errors = no_errors and len(self.error) == 0",
            "            if len(self.error) > 0:",
            "                e_type, e_value, _ = self.error[-1].exc_info",
            "                for hnd in node.handlers:",
            "                    htype = None",
            "                    if hnd.type is not None:",
            "                        htype = __builtins__.get(hnd.type.id, None)",
            "                    if htype is None or isinstance(e_type(), htype):",
            "                        self.error = []",
            "                        if hnd.name is not None:",
            "                            self.symtable[hnd.name] = e_value",
            "                        for tline in hnd.body:",
            "                            self.run(tline)",
            "                        break",
            "                break",
            "        if no_errors and hasattr(node, 'orelse'):",
            "            for tnode in node.orelse:",
            "                self.run(tnode)",
            "",
            "        if hasattr(node, 'finalbody'):",
            "            for tnode in node.finalbody:",
            "                self.run(tnode)",
            "",
            "    def on_raise(self, node):    # ('type', 'inst', 'tback')",
            "        \"\"\"Raise statement: note difference for python 2 and 3.\"\"\"",
            "        excnode = node.exc",
            "        msgnode = node.cause",
            "        out = self.run(excnode)",
            "        msg = ' '.join(out.args)",
            "        msg2 = self.run(msgnode)",
            "        if msg2 not in (None, 'None'):",
            "            msg = f\"{msg:s}: {msg2:s}\"",
            "        self.raise_exception(None, exc=out.__class__, msg=msg, expr='')",
            "",
            "    def on_call(self, node):",
            "        \"\"\"Function execution.\"\"\"",
            "        func = self.run(node.func)",
            "        if not hasattr(func, '__call__') and not isinstance(func, type):",
            "            msg = f\"'{func}' is not callable!!\"",
            "            self.raise_exception(node, exc=TypeError, msg=msg)",
            "        args = [self.run(targ) for targ in node.args]",
            "        starargs = getattr(node, 'starargs', None)",
            "        if starargs is not None:",
            "            args = args + self.run(starargs)",
            "",
            "        keywords = {}",
            "        if func == print:",
            "            keywords['file'] = self.writer",
            "        for key in node.keywords:",
            "            if not isinstance(key, ast.keyword):",
            "                msg = f\"keyword error in function call '{func}'\"",
            "                self.raise_exception(node, msg=msg)",
            "            if key.arg is None:",
            "                keywords.update(self.run(key.value))",
            "            elif key.arg in keywords:",
            "                self.raise_exception(node, exc=SyntaxError,",
            "                                     msg=f\"keyword argument repeated: {key.arg}\")",
            "            else:",
            "                keywords[key.arg] = self.run(key.value)",
            "",
            "        kwargs = getattr(node, 'kwargs', None)",
            "        if kwargs is not None:",
            "            keywords.update(self.run(kwargs))",
            "",
            "        if isinstance(func, Procedure):",
            "            self._calldepth += 1",
            "        try:",
            "            out = func(*args, **keywords)",
            "        except Exception as ex:",
            "            out = None",
            "            func_name = getattr(func, '__name__', str(func))",
            "            msg = f\"Error running function '{func_name}' with args '{args}'\"",
            "            msg = f\"{msg} and kwargs {keywords}: {ex}\"",
            "            self.raise_exception(node, msg=msg)",
            "        finally:",
            "            if isinstance(func, Procedure):",
            "                self._calldepth -= 1",
            "        return out",
            "",
            "    def on_arg(self, node):    # ('test', 'msg')",
            "        \"\"\"Arg for function definitions.\"\"\"",
            "        return node.arg",
            "",
            "    def on_functiondef(self, node):",
            "        \"\"\"Define procedures.\"\"\"",
            "        # ('name', 'args', 'body', 'decorator_list')",
            "        if node.decorator_list:",
            "            raise Warning(\"decorated procedures not supported!\")",
            "        kwargs = []",
            "",
            "        if (not valid_symbol_name(node.name) or",
            "                node.name in self.readonly_symbols):",
            "            errmsg = f\"invalid function name (reserved word?) {node.name}\"",
            "            self.raise_exception(node, exc=NameError, msg=errmsg)",
            "",
            "        offset = len(node.args.args) - len(node.args.defaults)",
            "        for idef, defnode in enumerate(node.args.defaults):",
            "            defval = self.run(defnode)",
            "            keyval = self.run(node.args.args[idef+offset])",
            "            kwargs.append((keyval, defval))",
            "",
            "        args = [tnode.arg for tnode in node.args.args[:offset]]",
            "        doc = None",
            "        nb0 = node.body[0]",
            "        if isinstance(nb0, ast.Expr) and isinstance(nb0.value, ast.Constant):",
            "            doc = nb0.value",
            "        varkws = node.args.kwarg",
            "        vararg = node.args.vararg",
            "        if isinstance(vararg, ast.arg):",
            "            vararg = vararg.arg",
            "        if isinstance(varkws, ast.arg):",
            "            varkws = varkws.arg",
            "        self.symtable[node.name] = Procedure(node.name, self, doc=doc,",
            "                                             lineno=self.lineno,",
            "                                             body=node.body,",
            "                                             args=args, kwargs=kwargs,",
            "                                             vararg=vararg, varkws=varkws)",
            "        if node.name in self.no_deepcopy:",
            "            self.no_deepcopy.remove(node.name)"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "\"\"\"",
            "Safe(ish) evaluation of minimal Python code using Python's ast module.",
            "",
            "This module provides an Interpreter class that compiles a restricted set of",
            "Python expressions and statements to Python's AST representation, and then",
            "executes that representation using values held in a symbol table.",
            "",
            "The symbol table is a simple dictionary, giving a flat namespace.  This comes",
            "pre-loaded with many functions from Python's builtin and math module.  If numpy",
            "is installed, many numpy functions are also included.  Additional symbols can",
            "be added when an Interpreter is created, but the user of that interpreter will",
            "not be able to import additional modules.",
            "",
            "Expressions, including loops, conditionals, and function definitions can be",
            "compiled into ast node and then evaluated later, using the current values",
            "in the symbol table.",
            "",
            "The result is a restricted, simplified version of Python meant for numerical",
            "calculations that is somewhat safer than 'eval' because many unsafe operations",
            "(such as 'eval') are simply not allowed, and others (such as 'import') are",
            "disabled by default, but can be explicitly enabled.",
            "",
            "Many parts of Python syntax are supported, including:",
            "     for loops, while loops, if-then-elif-else conditionals, with,",
            "     try-except-finally",
            "     function definitions with def",
            "     advanced slicing:    a[::-1], array[-3:, :, ::2]",
            "     if-expressions:      out = one_thing if TEST else other",
            "     list, dict, and set comprehension",
            "",
            "The following Python syntax elements are not supported:",
            "     Import, Exec, Lambda, Class, Global, Generators,",
            "     Yield, Decorators",
            "",
            "In addition, while many builtin functions are supported, several builtin",
            "functions that are considered unsafe are missing ('eval', 'exec', and",
            "'getattr' for example) are missing.",
            "\"\"\"",
            "import ast",
            "import sys",
            "import copy",
            "import inspect",
            "import time",
            "from sys import exc_info, stderr, stdout",
            "",
            "from .astutils import (HAS_NUMPY,",
            "                       ExceptionHolder, ReturnedNone, Empty, make_symbol_table,",
            "                       numpy, op2func, safe_getattr, safe_format, valid_symbol_name, Procedure)",
            "",
            "ALL_NODES = ['arg', 'assert', 'assign', 'attribute', 'augassign', 'binop',",
            "             'boolop', 'break', 'bytes', 'call', 'compare', 'constant',",
            "             'continue', 'delete', 'dict', 'dictcomp', 'ellipsis',",
            "             'excepthandler', 'expr', 'extslice', 'for', 'functiondef', 'if',",
            "             'ifexp', 'import', 'importfrom', 'index', 'interrupt', 'list',",
            "             'listcomp', 'module', 'name', 'nameconstant', 'num', 'pass',",
            "             'raise', 'repr', 'return', 'set', 'setcomp', 'slice', 'str',",
            "             'subscript', 'try', 'tuple', 'unaryop', 'while', 'with',",
            "             'formattedvalue', 'joinedstr']",
            "",
            "",
            "MINIMAL_CONFIG = {'import': False, 'importfrom': False}",
            "DEFAULT_CONFIG = {'import': False, 'importfrom': False}",
            "",
            "for _tnode in ('assert', 'augassign', 'delete', 'if', 'ifexp', 'for',",
            "             'formattedvalue', 'functiondef', 'print', 'raise', 'listcomp',",
            "             'dictcomp', 'setcomp', 'try', 'while', 'with'):",
            "    MINIMAL_CONFIG[_tnode] = False",
            "    DEFAULT_CONFIG[_tnode] = True",
            "",
            "class Interpreter:",
            "    \"\"\"create an asteval Interpreter: a restricted, simplified interpreter",
            "    of mathematical expressions using Python syntax.",
            "",
            "    Parameters",
            "    ----------",
            "    symtable : dict or `None`",
            "        dictionary or SymbolTable to use as symbol table (if `None`, one will be created).",
            "    nested_symtable : bool, optional",
            "        whether to use a new-style nested symbol table instead of a plain dict [False]",
            "    user_symbols : dict or `None`",
            "        dictionary of user-defined symbols to add to symbol table.",
            "    writer : file-like or `None`",
            "        callable file-like object where standard output will be sent.",
            "    err_writer : file-like or `None`",
            "        callable file-like object where standard error will be sent.",
            "    use_numpy : bool",
            "        whether to use functions from numpy.",
            "    max_statement_length : int",
            "        maximum length of expression allowed [50,000 characters]",
            "    readonly_symbols : iterable or `None`",
            "        symbols that the user can not assign to",
            "    builtins_readonly : bool",
            "        whether to blacklist all symbols that are in the initial symtable",
            "    minimal : bool",
            "        create a minimal interpreter: disable many nodes (see Note 1).",
            "    config : dict",
            "        dictionay listing which nodes to support (see note 2))",
            "",
            "    Notes",
            "    -----",
            "    1. setting `minimal=True` is equivalent to setting a config with the following",
            "       nodes disabled: ('import', 'importfrom', 'if', 'for', 'while', 'try', 'with',",
            "       'functiondef', 'ifexp', 'listcomp', 'dictcomp', 'setcomp', 'augassign',",
            "       'assert', 'delete', 'raise', 'print')",
            "    2. by default 'import' and 'importfrom' are disabled, though they can be enabled.",
            "    \"\"\"",
            "    def __init__(self, symtable=None, nested_symtable=False,",
            "                 user_symbols=None, writer=None, err_writer=None,",
            "                 use_numpy=True, max_statement_length=50000,",
            "                 minimal=False, readonly_symbols=None,",
            "                 builtins_readonly=False, config=None, **kws):",
            "",
            "        self.config = copy.copy(MINIMAL_CONFIG if minimal else DEFAULT_CONFIG)",
            "        if config is not None:",
            "            self.config.update(config)",
            "        self.config['nested_symtable'] = nested_symtable",
            "",
            "        if user_symbols is None:",
            "            user_symbols = {}",
            "            if 'usersyms' in kws:",
            "                user_symbols = kws.pop('usersyms') # back compat, changed July, 2023, v 0.9.4",
            "",
            "        if len(kws) > 0:",
            "            for key, val in kws.items():",
            "                if key.startswith('no_'):",
            "                    node = key[3:]",
            "                    if node in ALL_NODES:",
            "                        self.config[node] = not val",
            "                elif key.startswith('with_'):",
            "                    node = key[5:]",
            "                    if node in ALL_NODES:",
            "                        self.config[node] = val",
            "",
            "        self.writer = writer or stdout",
            "        self.err_writer = err_writer or stderr",
            "        self.max_statement_length = max(1, min(1.e8, max_statement_length))",
            "",
            "        self.use_numpy = HAS_NUMPY and use_numpy",
            "        if symtable is None:",
            "            symtable = make_symbol_table(nested=nested_symtable,",
            "                                         use_numpy=self.use_numpy, **user_symbols)",
            "",
            "        symtable['print'] = self._printer",
            "        self.symtable = symtable",
            "        self._interrupt = None",
            "        self.error = []",
            "        self.error_msg = None",
            "        self.expr = None",
            "        self.retval = None",
            "        self._calldepth = 0",
            "        self.lineno = 0",
            "        self.start_time = time.time()",
            "",
            "        self.node_handlers = {}",
            "        for node in ALL_NODES:",
            "            handler = self.unimplemented",
            "            if self.config.get(node, True):",
            "                handler = getattr(self, f\"on_{node}\", self.unimplemented)",
            "            self.node_handlers[node] = handler",
            "",
            "        # to rationalize try/except try/finally",
            "        if 'try' in self.node_handlers:",
            "            self.node_handlers['tryexcept'] = self.node_handlers['try']",
            "            self.node_handlers['tryfinally'] = self.node_handlers['try']",
            "",
            "        if readonly_symbols is None:",
            "            self.readonly_symbols = set()",
            "        else:",
            "            self.readonly_symbols = set(readonly_symbols)",
            "",
            "        if builtins_readonly:",
            "            self.readonly_symbols |= set(self.symtable)",
            "",
            "        self.no_deepcopy = [key for key, val in symtable.items()",
            "                            if (callable(val)",
            "                                or inspect.ismodule(val)",
            "                                or 'numpy.lib.index_tricks' in repr(type(val)))]",
            "",
            "    def remove_nodehandler(self, node):",
            "        \"\"\"remove support for a node",
            "        returns current node handler, so that it",
            "        might be re-added with add_nodehandler()",
            "        \"\"\"",
            "        out = None",
            "        if node in self.node_handlers:",
            "            out = self.node_handlers.pop(node)",
            "        return out",
            "",
            "    def set_nodehandler(self, node, handler=None):",
            "        \"\"\"set node handler or use current built-in default\"\"\"",
            "        if handler is None:",
            "            handler = getattr(self, f\"on_{node}\", self.unimplemented)",
            "        self.node_handlers[node] = handler",
            "        return handler",
            "",
            "    def user_defined_symbols(self):",
            "        \"\"\"Return a set of symbols that have been added to symtable after",
            "        construction.",
            "",
            "        I.e., the symbols from self.symtable that are not in",
            "        self.no_deepcopy.",
            "",
            "        Returns",
            "        -------",
            "        unique_symbols : set",
            "            symbols in symtable that are not in self.no_deepcopy",
            "",
            "        \"\"\"",
            "        sym_in_current = set(self.symtable.keys())",
            "        sym_from_construction = set(self.no_deepcopy)",
            "        unique_symbols = sym_in_current.difference(sym_from_construction)",
            "        return unique_symbols",
            "",
            "    def unimplemented(self, node):",
            "        \"\"\"Unimplemented nodes.\"\"\"",
            "        msg = f\"{node.__class__.__name__} not supported\"",
            "        self.raise_exception(node, exc=NotImplementedError, msg=msg)",
            "",
            "    def raise_exception(self, node, exc=None, msg='', expr=None, lineno=None):",
            "        \"\"\"Add an exception.\"\"\"",
            "        if expr is not None:",
            "            self.expr = expr",
            "        msg = str(msg)",
            "        err = ExceptionHolder(node, exc=exc, msg=msg, expr=self.expr, lineno=lineno)",
            "        self._interrupt = ast.Raise()",
            "",
            "        self.error.append(err)",
            "        if self.error_msg is None:",
            "            self.error_msg = msg",
            "        elif len(msg) > 0:",
            "            pass",
            "            # if err.exc is not None:",
            "            #     self.error_msg = f\"{err.exc.__name__}: {msg}\"",
            "        if exc is None:",
            "            exc = self.error[-1].exc",
            "            if exc is None and len(self.error) > 0:",
            "                while exc is None and len(self.error) > 0:",
            "                    err = self.error.pop()",
            "                    exc = err.exc",
            "        if exc is None:",
            "            exc = Exception",
            "        if len(err.msg) == 0 and len(self.error_msg) == 0 and len(self.error) > 1:",
            "            err = self.error.pop(-1)",
            "            raise err.exc(err.msg)",
            "        else:",
            "            if len(err.msg) == 0:",
            "                err.msg = self.error_msg",
            "            raise exc(self.error_msg)",
            "",
            "    # main entry point for Ast node evaluation",
            "    #  parse:  text of statements -> ast",
            "    #  run:    ast -> result",
            "    #  eval:   string statement -> result = run(parse(statement))",
            "    def parse(self, text):",
            "        \"\"\"Parse statement/expression to Ast representation.\"\"\"",
            "        if len(text) > self.max_statement_length:",
            "            msg = f'length of text exceeds {self.max_statement_length:d} characters'",
            "            self.raise_exception(None, exc=RuntimeError, expr=msg)",
            "        self.expr = text",
            "        try:",
            "            out = ast.parse(text)",
            "        except SyntaxError:",
            "            self.raise_exception(None, exc=SyntaxError, expr=text)",
            "        except:",
            "            self.raise_exception(None, exc=RuntimeError, expr=text)",
            "",
            "        return out",
            "",
            "    def run(self, node, expr=None, lineno=None, with_raise=True):",
            "        \"\"\"Execute parsed Ast representation for an expression.\"\"\"",
            "        # Note: keep the 'node is None' test: internal code here may run",
            "        #    run(None) and expect a None in return.",
            "        if isinstance(node, str):",
            "            return self.eval(node, raise_errors=with_raise)",
            "",
            "        out = None",
            "        if len(self.error) > 0:",
            "            return out",
            "        if self.retval is not None:",
            "            return self.retval",
            "        if isinstance(self._interrupt, (ast.Break, ast.Continue)):",
            "            return self._interrupt",
            "        if node is None:",
            "            return out",
            "",
            "        if lineno is not None:",
            "            self.lineno = lineno",
            "        if expr is not None:",
            "            self.expr = expr",
            "",
            "        # get handler for this node:",
            "        #   on_xxx with handle nodes of type 'xxx', etc",
            "        try:",
            "            handler = self.node_handlers[node.__class__.__name__.lower()]",
            "        except KeyError:",
            "            self.raise_exception(None, exc=NotImplementedError, expr=self.expr)",
            "",
            "        # run the handler:  this will likely generate",
            "        # recursive calls into this run method.",
            "        try:",
            "            ret = handler(node)",
            "            if isinstance(ret, enumerate):",
            "                ret = list(ret)",
            "            return ret",
            "        except:",
            "            if with_raise and self.expr is not None:",
            "                self.raise_exception(node, expr=self.expr)",
            "",
            "        # avoid too many repeated error messages (yes, this needs to be \"2\")",
            "        if len(self.error) > 2:",
            "            self._remove_duplicate_errors()",
            "",
            "        return None",
            "",
            "    def _remove_duplicate_errors(self):",
            "        \"\"\"remove duplicate exceptions\"\"\"",
            "        error = [self.error[0]]",
            "        for err in self.error[1:]:",
            "            lerr = error[-1]",
            "            if err.exc != lerr.exc or err.expr != lerr.expr or err.msg !=  lerr.msg:",
            "                if isinstance(err.msg, str) and len(err.msg) > 0:",
            "                    error.append(err)",
            "        self.error = error",
            "",
            "    def __call__(self, expr, **kw):",
            "        \"\"\"Call class instance as function.\"\"\"",
            "        return self.eval(expr, **kw)",
            "",
            "    def eval(self, expr, lineno=0, show_errors=True, raise_errors=False):",
            "        \"\"\"Evaluate a single statement.\"\"\"",
            "        self.lineno = lineno",
            "        self.error = []",
            "        self.error_msg = None",
            "        self.start_time = time.time()",
            "        if isinstance(expr, str):",
            "            try:",
            "                node = self.parse(expr)",
            "            except Exception:",
            "                errmsg = exc_info()[1]",
            "                if len(self.error) > 0:",
            "                    lerr = self.error[-1]",
            "                    errmsg = lerr.get_error()[1]",
            "                    if raise_errors:",
            "                        raise lerr.exc(errmsg)",
            "                if show_errors:",
            "                    print(errmsg, file=self.err_writer)",
            "                return None",
            "        else:",
            "            node = expr",
            "        try:",
            "            return self.run(node, expr=expr, lineno=lineno, with_raise=raise_errors)",
            "        except Exception:",
            "            if show_errors and not raise_errors:",
            "                errmsg = exc_info()[1]",
            "                if len(self.error) > 0:",
            "                    errmsg = self.error[-1].get_error()[1]",
            "                print(errmsg, file=self.err_writer)",
            "        if raise_errors and len(self.error) > 0:",
            "            self._remove_duplicate_errors()",
            "            err = self.error[-1]",
            "            raise err.exc(err.get_error()[1])",
            "        return None",
            "",
            "    @staticmethod",
            "    def dump(node, **kw):",
            "        \"\"\"Simple ast dumper.\"\"\"",
            "        return ast.dump(node, **kw)",
            "",
            "    # handlers for ast components",
            "    def on_expr(self, node):",
            "        \"\"\"Expression.\"\"\"",
            "        return self.run(node.value)  # ('value',)",
            "",
            "    # imports",
            "    def on_import(self, node):    # ('names',)",
            "        \"simple import\"",
            "        for tnode in node.names:",
            "            self.import_module(tnode.name, tnode.asname)",
            "",
            "    def on_importfrom(self, node):    # ('module', 'names', 'level')",
            "        \"import/from\"",
            "        fromlist, asname = [], []",
            "        for tnode in node.names:",
            "            fromlist.append(tnode.name)",
            "            asname.append(tnode.asname)",
            "        self.import_module(node.module, asname, fromlist=fromlist)",
            "",
            "    def import_module(self, name, asname, fromlist=None):",
            "        \"\"\"import a python module, installing it into the symbol table.",
            "        options:",
            "          name       name of module to import 'foo' in 'import foo'",
            "          asname     alias for imported name(s)",
            "                          'bar' in 'import foo as bar'",
            "                       or",
            "                          ['s','t'] in 'from foo import x as s, y as t'",
            "          fromlist   list of symbols to import with 'from-import'",
            "                         ['x','y'] in 'from foo import x, y'",
            "        \"\"\"",
            "        # find module in sys.modules or import to it",
            "        if name in sys.modules:",
            "            thismod = sys.modules[name]",
            "        else:",
            "            try:",
            "                __import__(name)",
            "                thismod = sys.modules[name]",
            "            except:",
            "                self.raise_exception(None, exc=ImportError, msg='Import Error')",
            "",
            "        if fromlist is None:",
            "            if asname is not None:",
            "                self.symtable[asname] = sys.modules[name]",
            "            else:",
            "                mparts = []",
            "                parts = name.split('.')",
            "                while len(parts) > 0:",
            "                    mparts.append(parts.pop(0))",
            "                    modname = '.'.join(mparts)",
            "                    inname = name if (len(parts) == 0) else modname",
            "                    self.symtable[inname] = sys.modules[modname]",
            "        else: #  import-from construct",
            "            if asname is None:",
            "                asname = [None]*len(fromlist)",
            "            for sym, alias in zip(fromlist, asname):",
            "                if alias is None:",
            "                    alias = sym",
            "                self.symtable[alias] = getattr(thismod, sym)",
            "",
            "    def on_index(self, node):",
            "        \"\"\"Index.\"\"\"",
            "        return self.run(node.value)  # ('value',)",
            "",
            "    def on_return(self, node):  # ('value',)",
            "        \"\"\"Return statement: look for None, return special sentinel.\"\"\"",
            "        if self._calldepth == 0:",
            "            raise SyntaxError('cannot return at top level')",
            "        self.retval = self.run(node.value)",
            "        if self.retval is None:",
            "            self.retval = ReturnedNone",
            "",
            "    def on_repr(self, node):",
            "        \"\"\"Repr.\"\"\"",
            "        return repr(self.run(node.value))  # ('value',)",
            "",
            "    def on_module(self, node):    # ():('body',)",
            "        \"\"\"Module def.\"\"\"",
            "        out = None",
            "        for tnode in node.body:",
            "            out = self.run(tnode)",
            "        return out",
            "",
            "    def on_expression(self, node):",
            "        \"basic expression\"",
            "        return self.on_module(node)  # ():('body',)",
            "",
            "    def on_pass(self, node):",
            "        \"\"\"Pass statement.\"\"\"",
            "        return None  # ()",
            "",
            "    # for break and continue: set the instance variable _interrupt",
            "    def on_interrupt(self, node):    # ()",
            "        \"\"\"Interrupt handler.\"\"\"",
            "        self._interrupt = node",
            "        return node",
            "",
            "    def on_break(self, node):",
            "        \"\"\"Break.\"\"\"",
            "        return self.on_interrupt(node)",
            "",
            "    def on_continue(self, node):",
            "        \"\"\"Continue.\"\"\"",
            "        return self.on_interrupt(node)",
            "",
            "    def on_assert(self, node):    # ('test', 'msg')",
            "        \"\"\"Assert statement.\"\"\"",
            "        if not self.run(node.test):",
            "            msg = node.msg.value if node.msg else \"\"",
            "            # msg = node.msg.s if node.msg else \"\"",
            "            self.raise_exception(node, exc=AssertionError, msg=msg)",
            "        return True",
            "",
            "    def on_list(self, node):    # ('elt', 'ctx')",
            "        \"\"\"List.\"\"\"",
            "        return [self.run(e) for e in node.elts]",
            "",
            "    def on_tuple(self, node):    # ('elts', 'ctx')",
            "        \"\"\"Tuple.\"\"\"",
            "        return tuple(self.on_list(node))",
            "",
            "    def on_set(self, node):    # ('elts')",
            "        \"\"\"Set.\"\"\"",
            "        return set([self.run(k) for k in node.elts])",
            "",
            "    def on_dict(self, node):    # ('keys', 'values')",
            "        \"\"\"Dictionary.\"\"\"",
            "        return {self.run(k): self.run(v) for k, v in",
            "                zip(node.keys, node.values)}",
            "",
            "    def on_constant(self, node):   # ('value', 'kind')",
            "        \"\"\"Return constant value.\"\"\"",
            "        return node.value",
            "",
            "    def on_joinedstr(self, node):  # ('values',)",
            "        \"join strings, used in f-strings\"",
            "        return ''.join([self.run(k) for k in node.values])",
            "",
            "    def on_formattedvalue(self, node): # ('value', 'conversion', 'format_spec')",
            "        \"formatting used in f-strings\"",
            "        val = self.run(node.value)",
            "        fstring_converters = {115: str, 114: repr, 97: ascii}",
            "        if node.conversion in fstring_converters:",
            "            val = fstring_converters[node.conversion](val)",
            "        fmt = '{__fstring__}'",
            "        if node.format_spec is not None:",
            "            fmt = f'{{__fstring__:{self.run(node.format_spec)}}}'",
            "        return safe_format(fmt, self.raise_exception, node, __fstring__=val)",
            "",
            "    def _getsym(self, node):",
            "        val = self.symtable.get(node.id, ReturnedNone)",
            "        if isinstance(val, Empty):",
            "            msg = f\"name '{node.id}' is not defined\"",
            "            self.raise_exception(node, exc=NameError, msg=msg)",
            "        return val",
            "",
            "    def on_name(self, node):    # ('id', 'ctx')",
            "        \"\"\"Name node.\"\"\"",
            "        ctx = node.ctx.__class__",
            "        if ctx in (ast.Param, ast.Del):",
            "            return str(node.id)",
            "        return self._getsym(node)",
            "",
            "    def node_assign(self, node, val):",
            "        \"\"\"Assign a value (not the node.value object) to a node.",
            "",
            "        This is used by on_assign, but also by for, list comprehension,",
            "        etc.",
            "",
            "        \"\"\"",
            "        if node.__class__ == ast.Name:",
            "            if (not valid_symbol_name(node.id) or",
            "                    node.id in self.readonly_symbols):",
            "                errmsg = f\"invalid symbol name (reserved word?) {node.id}\"",
            "                self.raise_exception(node, exc=NameError, msg=errmsg)",
            "            self.symtable[node.id] = val",
            "            if node.id in self.no_deepcopy:",
            "                self.no_deepcopy.remove(node.id)",
            "",
            "        elif node.__class__ == ast.Attribute:",
            "            if node.ctx.__class__ == ast.Load:",
            "                msg = f\"cannot assign to attribute {node.attr}\"",
            "                self.raise_exception(node, exc=AttributeError, msg=msg)",
            "",
            "            setattr(self.run(node.value), node.attr, val)",
            "",
            "        elif node.__class__ == ast.Subscript:",
            "            self.run(node.value)[self.run(node.slice)] = val",
            "",
            "        elif node.__class__ in (ast.Tuple, ast.List):",
            "            if len(val) == len(node.elts):",
            "                for telem, tval in zip(node.elts, val):",
            "                    self.node_assign(telem, tval)",
            "            else:",
            "                raise ValueError('too many values to unpack')",
            "",
            "    def on_attribute(self, node):    # ('value', 'attr', 'ctx')",
            "        \"\"\"Extract attribute.\"\"\"",
            "",
            "        ctx = node.ctx.__class__",
            "        if ctx == ast.Store:",
            "            msg = \"attribute for storage: shouldn't be here!\"",
            "            self.raise_exception(node, exc=RuntimeError, msg=msg)",
            "",
            "        sym = self.run(node.value)",
            "        if ctx == ast.Del:",
            "            return delattr(sym, node.attr)",
            "        ",
            "        return safe_getattr(sym, node.attr, self.raise_exception, node)",
            "",
            "",
            "    def on_assign(self, node):    # ('targets', 'value')",
            "        \"\"\"Simple assignment.\"\"\"",
            "        val = self.run(node.value)",
            "        for tnode in node.targets:",
            "            self.node_assign(tnode, val)",
            "",
            "    def on_augassign(self, node):    # ('target', 'op', 'value')",
            "        \"\"\"Augmented assign.\"\"\"",
            "        return self.on_assign(ast.Assign(targets=[node.target],",
            "                                         value=ast.BinOp(left=node.target,",
            "                                                         op=node.op,",
            "                                                         right=node.value)))",
            "",
            "    def on_slice(self, node):    # ():('lower', 'upper', 'step')",
            "        \"\"\"Simple slice.\"\"\"",
            "        return slice(self.run(node.lower),",
            "                     self.run(node.upper),",
            "                     self.run(node.step))",
            "",
            "    def on_extslice(self, node):    # ():('dims',)",
            "        \"\"\"Extended slice.\"\"\"",
            "        return tuple([self.run(tnode) for tnode in node.dims])",
            "",
            "    def on_subscript(self, node): # ('value', 'slice', 'ctx')",
            "        \"\"\"Subscript handling\"\"\"",
            "        return self.run(node.value)[self.run(node.slice)]",
            "",
            "",
            "    def on_delete(self, node):    # ('targets',)",
            "        \"\"\"Delete statement.\"\"\"",
            "        for tnode in node.targets:",
            "            if tnode.ctx.__class__ != ast.Del:",
            "                break",
            "            children = []",
            "            while tnode.__class__ == ast.Attribute:",
            "                children.append(tnode.attr)",
            "                tnode = tnode.value",
            "            if (tnode.__class__ == ast.Name and",
            "                    tnode.id not in self.readonly_symbols):",
            "                children.append(tnode.id)",
            "                children.reverse()",
            "                self.symtable.pop('.'.join(children))",
            "            elif tnode.__class__ == ast.Subscript:",
            "                nslice = self.run(tnode.slice)",
            "                children = []",
            "                tnode = tnode.value",
            "                while tnode.__class__ == ast.Attribute:",
            "                    children.append(tnode.attr)",
            "                    tnode = tnode.value",
            "                if (tnode.__class__ == ast.Name and not",
            "                    tnode.id in self.readonly_symbols):",
            "                    children.append(tnode.id)",
            "                    children.reverse()",
            "                    sname = '.'.join(children)",
            "                    val = self.run(sname)",
            "                    del val[nslice]",
            "                    if len(children) == 1:",
            "                        self.symtable[sname] = val",
            "                    else:",
            "                        child = self.symtable[children[0]]",
            "                        for cname in children[1:-1]:",
            "                            child = child[cname]",
            "                        setattr(child, children[-1], val)",
            "",
            "    def on_unaryop(self, node):    # ('op', 'operand')",
            "        \"\"\"Unary operator.\"\"\"",
            "        return op2func(node.op)(self.run(node.operand))",
            "",
            "    def on_binop(self, node):    # ('left', 'op', 'right')",
            "        \"\"\"Binary operator.\"\"\"",
            "        return op2func(node.op)(self.run(node.left),",
            "                                self.run(node.right))",
            "",
            "    def on_boolop(self, node):    # ('op', 'values')",
            "        \"\"\"Boolean operator.\"\"\"",
            "        val = self.run(node.values[0])",
            "        is_and = ast.And == node.op.__class__",
            "        if (is_and and val) or (not is_and and not val):",
            "            for nodeval in node.values[1:]:",
            "                val = op2func(node.op)(val, self.run(nodeval))",
            "                if (is_and and not val) or (not is_and and val):",
            "                    break",
            "        return val",
            "",
            "    def on_compare(self, node):  # ('left', 'ops', 'comparators')",
            "        \"\"\"comparison operators, including chained comparisons (a<b<c)\"\"\"",
            "        lval = self.run(node.left)",
            "        results = []",
            "        multi = len(node.ops) > 1",
            "        for oper, rnode in zip(node.ops, node.comparators):",
            "            rval = self.run(rnode)",
            "            ret = op2func(oper)(lval, rval)",
            "            if multi:",
            "                results.append(ret)",
            "                if not all(results):",
            "                    return False",
            "                lval = rval",
            "        if multi:",
            "            ret = all(results)",
            "        return ret",
            "",
            "    def _printer(self, *out, **kws):",
            "        \"\"\"Generic print function.\"\"\"",
            "        if self.config.get('print', True):",
            "            flush = kws.pop('flush', True)",
            "            fileh = kws.pop('file', self.writer)",
            "            sep = kws.pop('sep', ' ')",
            "            end = kws.pop('sep', '\\n')",
            "            print(*out, file=fileh, sep=sep, end=end)",
            "            if flush:",
            "                fileh.flush()",
            "",
            "    def on_if(self, node):    # ('test', 'body', 'orelse')",
            "        \"\"\"Regular if-then-else statement.\"\"\"",
            "        block = node.body",
            "        if not self.run(node.test):",
            "            block = node.orelse",
            "        for tnode in block:",
            "            self.run(tnode)",
            "",
            "    def on_ifexp(self, node):    # ('test', 'body', 'orelse')",
            "        \"\"\"If expressions.\"\"\"",
            "        expr = node.orelse",
            "        if self.run(node.test):",
            "            expr = node.body",
            "        return self.run(expr)",
            "",
            "    def on_while(self, node):    # ('test', 'body', 'orelse')",
            "        \"\"\"While blocks.\"\"\"",
            "        while self.run(node.test):",
            "            self._interrupt = None",
            "            for tnode in node.body:",
            "                self.run(tnode)",
            "                if self._interrupt is not None:",
            "                    break",
            "            if isinstance(self._interrupt, ast.Break):",
            "                break",
            "        else:",
            "            for tnode in node.orelse:",
            "                self.run(tnode)",
            "        self._interrupt = None",
            "",
            "    def on_for(self, node):    # ('target', 'iter', 'body', 'orelse')",
            "        \"\"\"For blocks.\"\"\"",
            "        for val in self.run(node.iter):",
            "            self.node_assign(node.target, val)",
            "            self._interrupt = None",
            "            for tnode in node.body:",
            "                self.run(tnode)",
            "                if self._interrupt is not None:",
            "                    break",
            "            if isinstance(self._interrupt, ast.Break):",
            "                break",
            "        else:",
            "            for tnode in node.orelse:",
            "                self.run(tnode)",
            "        self._interrupt = None",
            "",
            "    def on_with(self, node):    # ('items', 'body', 'type_comment')",
            "        \"\"\"with blocks.\"\"\"",
            "        contexts = []",
            "        for item in node.items:",
            "            ctx = self.run(item.context_expr)",
            "            contexts.append(ctx)",
            "            if hasattr(ctx, '__enter__'):",
            "                result = ctx.__enter__()",
            "                if item.optional_vars is not None:",
            "                    self.node_assign(item.optional_vars, result)",
            "            else:",
            "                msg = \"object does not support the context manager protocol\"",
            "                raise TypeError(f\"'{type(ctx)}' {msg}\")",
            "        for bnode in node.body:",
            "            self.run(bnode)",
            "            if self._interrupt is not None:",
            "                break",
            "",
            "        for ctx in contexts:",
            "            if hasattr(ctx, '__exit__'):",
            "                ctx.__exit__()",
            "",
            "    def _comp_save_syms(self, node):",
            "        \"\"\"find and save symbols that will be used in a comprehension\"\"\"",
            "        saved_syms = {}",
            "        for tnode in node.generators:",
            "            if tnode.target.__class__ == ast.Name:",
            "                if (not valid_symbol_name(tnode.target.id) or",
            "                    tnode.target.id in self.readonly_symbols):",
            "                    errmsg = f\"invalid symbol name (reserved word?) {tnode.target.id}\"",
            "                    self.raise_exception(tnode.target, exc=NameError, msg=errmsg)",
            "                if tnode.target.id in self.symtable:",
            "                    saved_syms[tnode.target.id] = copy.deepcopy(self._getsym(tnode.target))",
            "",
            "            elif tnode.target.__class__ == ast.Tuple:",
            "                for tval in tnode.target.elts:",
            "                    if tval.id in self.symtable:",
            "                        saved_syms[tval.id] = copy.deepcopy(self._getsym(tval))",
            "        return saved_syms",
            "",
            "",
            "    def do_generator(self, gnodes, node, out):",
            "        \"\"\"general purpose generator \"\"\"",
            "        gnode = gnodes[0]",
            "        nametype = True",
            "        target = None",
            "        if gnode.target.__class__ == ast.Name:",
            "            if (not valid_symbol_name(gnode.target.id) or",
            "                gnode.target.id in self.readonly_symbols):",
            "                errmsg = f\"invalid symbol name (reserved word?) {gnode.target.id}\"",
            "                self.raise_exception(gnode.target, exc=NameError, msg=errmsg)",
            "            target = gnode.target.id",
            "        elif gnode.target.__class__ == ast.Tuple:",
            "            nametype = False",
            "            target = tuple([gval.id for gval in gnode.target.elts])",
            "",
            "        for val in self.run(gnode.iter):",
            "            if nametype and target is not None:",
            "                self.symtable[target] = val",
            "            else:",
            "                for telem, tval in zip(target, val):",
            "                    self.symtable[telem] = tval",
            "            add = True",
            "            for cond in gnode.ifs:",
            "                add = add and self.run(cond)",
            "                if not add:",
            "                    break",
            "            if add:",
            "                if len(gnodes) > 1:",
            "                    self.do_generator(gnodes[1:], node, out)",
            "                elif isinstance(out, list):",
            "                    out.append(self.run(node.elt))",
            "                elif isinstance(out, dict):",
            "                    out[self.run(node.key)] = self.run(node.value)",
            "",
            "    def on_listcomp(self, node):",
            "        \"\"\"List comprehension v2\"\"\"",
            "        saved_syms = self._comp_save_syms(node)",
            "",
            "        out = []",
            "        self.do_generator(node.generators, node, out)",
            "        for name, val in saved_syms.items():",
            "            self.symtable[name] = val",
            "        return out",
            "",
            "    def on_setcomp(self, node):",
            "        \"\"\"Set comprehension\"\"\"",
            "        return set(self.on_listcomp(node))",
            "",
            "    def on_dictcomp(self, node):",
            "        \"\"\"Dict comprehension v2\"\"\"",
            "        saved_syms = self._comp_save_syms(node)",
            "",
            "        out = {}",
            "        self.do_generator(node.generators, node, out)",
            "        for name, val in saved_syms.items():",
            "            self.symtable[name] = val",
            "        return out",
            "",
            "    def on_excepthandler(self, node):  # ('type', 'name', 'body')",
            "        \"\"\"Exception handler...\"\"\"",
            "        return (self.run(node.type), node.name, node.body)",
            "",
            "    def on_try(self, node):    # ('body', 'handlers', 'orelse', 'finalbody')",
            "        \"\"\"Try/except/else/finally blocks.\"\"\"",
            "        no_errors = True",
            "        for tnode in node.body:",
            "            self.run(tnode, with_raise=False)",
            "            no_errors = no_errors and len(self.error) == 0",
            "            if len(self.error) > 0:",
            "                e_type, e_value, _ = self.error[-1].exc_info",
            "                for hnd in node.handlers:",
            "                    htype = None",
            "                    if hnd.type is not None:",
            "                        htype = __builtins__.get(hnd.type.id, None)",
            "                    if htype is None or isinstance(e_type(), htype):",
            "                        self.error = []",
            "                        if hnd.name is not None:",
            "                            self.symtable[hnd.name] = e_value",
            "                        for tline in hnd.body:",
            "                            self.run(tline)",
            "                        break",
            "                break",
            "        if no_errors and hasattr(node, 'orelse'):",
            "            for tnode in node.orelse:",
            "                self.run(tnode)",
            "",
            "        if hasattr(node, 'finalbody'):",
            "            for tnode in node.finalbody:",
            "                self.run(tnode)",
            "",
            "    def on_raise(self, node):    # ('type', 'inst', 'tback')",
            "        \"\"\"Raise statement: note difference for python 2 and 3.\"\"\"",
            "        excnode = node.exc",
            "        msgnode = node.cause",
            "        out = self.run(excnode)",
            "        msg = ' '.join(out.args)",
            "        msg2 = self.run(msgnode)",
            "        if msg2 not in (None, 'None'):",
            "            msg = f\"{msg:s}: {msg2:s}\"",
            "        self.raise_exception(None, exc=out.__class__, msg=msg, expr='')",
            "",
            "    def on_call(self, node):",
            "        \"\"\"Function execution.\"\"\"",
            "        func = self.run(node.func)",
            "        if not hasattr(func, '__call__') and not isinstance(func, type):",
            "            msg = f\"'{func}' is not callable!!\"",
            "            self.raise_exception(node, exc=TypeError, msg=msg)",
            "        args = [self.run(targ) for targ in node.args]",
            "        starargs = getattr(node, 'starargs', None)",
            "        if starargs is not None:",
            "            args = args + self.run(starargs)",
            "",
            "        keywords = {}",
            "        if func == print:",
            "            keywords['file'] = self.writer",
            "        for key in node.keywords:",
            "            if not isinstance(key, ast.keyword):",
            "                msg = f\"keyword error in function call '{func}'\"",
            "                self.raise_exception(node, msg=msg)",
            "            if key.arg is None:",
            "                keywords.update(self.run(key.value))",
            "            elif key.arg in keywords:",
            "                self.raise_exception(node, exc=SyntaxError,",
            "                                     msg=f\"keyword argument repeated: {key.arg}\")",
            "            else:",
            "                keywords[key.arg] = self.run(key.value)",
            "",
            "        kwargs = getattr(node, 'kwargs', None)",
            "        if kwargs is not None:",
            "            keywords.update(self.run(kwargs))",
            "",
            "        if isinstance(func, Procedure):",
            "            self._calldepth += 1",
            "        try:",
            "            out = func(*args, **keywords)",
            "        except Exception as ex:",
            "            out = None",
            "            func_name = getattr(func, '__name__', str(func))",
            "            msg = f\"Error running function '{func_name}' with args '{args}'\"",
            "            msg = f\"{msg} and kwargs {keywords}: {ex}\"",
            "            self.raise_exception(node, msg=msg)",
            "        finally:",
            "            if isinstance(func, Procedure):",
            "                self._calldepth -= 1",
            "        return out",
            "",
            "    def on_arg(self, node):    # ('test', 'msg')",
            "        \"\"\"Arg for function definitions.\"\"\"",
            "        return node.arg",
            "",
            "    def on_functiondef(self, node):",
            "        \"\"\"Define procedures.\"\"\"",
            "        # ('name', 'args', 'body', 'decorator_list')",
            "        if node.decorator_list:",
            "            raise Warning(\"decorated procedures not supported!\")",
            "        kwargs = []",
            "",
            "        if (not valid_symbol_name(node.name) or",
            "                node.name in self.readonly_symbols):",
            "            errmsg = f\"invalid function name (reserved word?) {node.name}\"",
            "            self.raise_exception(node, exc=NameError, msg=errmsg)",
            "",
            "        offset = len(node.args.args) - len(node.args.defaults)",
            "        for idef, defnode in enumerate(node.args.defaults):",
            "            defval = self.run(defnode)",
            "            keyval = self.run(node.args.args[idef+offset])",
            "            kwargs.append((keyval, defval))",
            "",
            "        args = [tnode.arg for tnode in node.args.args[:offset]]",
            "        doc = None",
            "        nb0 = node.body[0]",
            "        if isinstance(nb0, ast.Expr) and isinstance(nb0.value, ast.Constant):",
            "            doc = nb0.value",
            "        varkws = node.args.kwarg",
            "        vararg = node.args.vararg",
            "        if isinstance(vararg, ast.arg):",
            "            vararg = vararg.arg",
            "        if isinstance(varkws, ast.arg):",
            "            varkws = varkws.arg",
            "        self.symtable[node.name] = Procedure(node.name, self, doc=doc,",
            "                                             lineno=self.lineno,",
            "                                             body=node.body,",
            "                                             args=args, kwargs=kwargs,",
            "                                             vararg=vararg, varkws=varkws)",
            "        if node.name in self.no_deepcopy:",
            "            self.no_deepcopy.remove(node.name)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "47": [],
            "49": [],
            "516": [
                "Interpreter",
                "on_formattedvalue"
            ],
            "576": [
                "Interpreter",
                "on_attribute"
            ],
            "577": [
                "Interpreter",
                "on_attribute"
            ],
            "578": [
                "Interpreter",
                "on_attribute"
            ],
            "579": [
                "Interpreter",
                "on_attribute"
            ],
            "580": [
                "Interpreter",
                "on_attribute"
            ],
            "581": [
                "Interpreter",
                "on_attribute"
            ],
            "582": [
                "Interpreter",
                "on_attribute"
            ],
            "583": [
                "Interpreter",
                "on_attribute"
            ],
            "584": [
                "Interpreter",
                "on_attribute"
            ],
            "585": [
                "Interpreter",
                "on_attribute"
            ],
            "586": [
                "Interpreter",
                "on_attribute"
            ],
            "587": [
                "Interpreter",
                "on_attribute"
            ],
            "588": [
                "Interpreter",
                "on_attribute"
            ],
            "589": [
                "Interpreter",
                "on_attribute"
            ],
            "590": [
                "Interpreter",
                "on_attribute"
            ],
            "591": [
                "Interpreter",
                "on_attribute"
            ]
        },
        "addLocation": []
    },
    "asteval/astutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from tokenize import ENCODING as tk_ENCODING"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from tokenize import NAME as tk_NAME"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from tokenize import tokenize as generate_tokens"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from string import Formatter"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " builtins = __builtins__"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " if not isinstance(builtins, dict):"
            },
            "7": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " except ImportError:"
            },
            "8": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     pass"
            },
            "9": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+# This is a necessary API but it's undocumented and moved around"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+# between Python releases"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+try:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    from _string import formatter_field_name_split"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+except ImportError:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    formatter_field_name_split = lambda \\"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        x: x._formatter_field_name_split()"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " MAX_EXPONENT = 10000"
            },
            "21": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "                 '__getattribute__', '__subclasshook__', '__new__',"
            },
            "22": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "                 '__init__', 'func_globals', 'func_code', 'func_closure',"
            },
            "23": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "                 'im_class', 'im_func', 'im_self', 'gi_code', 'gi_frame',"
            },
            "24": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'f_locals', '__asteval__')"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                'f_locals', '__asteval__','mro')"
            },
            "26": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " # unsafe attributes for particular objects, by type"
            },
            "28": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " UNSAFE_ATTRS_DTYPES = {str: ('format', 'format_map')}"
            },
            "29": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "              ast.UAdd: lambda a: +a,"
            },
            "30": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "              ast.USub: lambda a: -a}"
            },
            "31": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 277,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+# Safe version of getattr"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+def safe_getattr(obj, attr, raise_exc, node):"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+    \"\"\"safe version of getattr\"\"\""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+    unsafe = (attr in UNSAFE_ATTRS or"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+            (attr.startswith('__') and attr.endswith('__')))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+    if not unsafe:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+        for dtype, attrlist in UNSAFE_ATTRS_DTYPES.items():"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+            unsafe = (isinstance(obj, dtype) or obj is dtype) and attr in attrlist"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+            if unsafe:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+                break"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+    if unsafe:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+        msg = f\"no safe attribute '{attr}' for {repr(obj)}\""
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+        raise_exc(node, exc=AttributeError, msg=msg)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+    else:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+        try:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+            return getattr(obj, attr)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+        except AttributeError:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+            pass"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+class SafeFormatter(Formatter):"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+    def __init__(self, raise_exc, node):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+        self.raise_exc = raise_exc"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+        self.node = node"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+        super().__init__()"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+    def get_field(self, field_name, args, kwargs):"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        first, rest = formatter_field_name_split(field_name)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+        obj = self.get_value(first, args, kwargs)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+        for is_attr, i in rest:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+            if is_attr:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+                obj = safe_getattr(obj, i, self.raise_exc, self.node)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+            else:"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+                obj = obj[i]"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+        return obj, first"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+    "
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+def safe_format(_string, raise_exc, node, *args, **kwargs):"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+    formatter = SafeFormatter(raise_exc, node)"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+    return formatter.vformat(_string, args, kwargs)                    "
            },
            "71": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 317,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 318,
                "PatchRowcode": " def valid_symbol_name(name):"
            },
            "73": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 319,
                "PatchRowcode": "     \"\"\"Determine whether the input symbol name is a valid name."
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "utility functions for asteval",
            "",
            "   Matthew Newville <newville@cars.uchicago.edu>,",
            "   The University of Chicago",
            "\"\"\"",
            "import ast",
            "import io",
            "import math",
            "import numbers",
            "import re",
            "from sys import exc_info",
            "from tokenize import ENCODING as tk_ENCODING",
            "from tokenize import NAME as tk_NAME",
            "from tokenize import tokenize as generate_tokens",
            "",
            "builtins = __builtins__",
            "if not isinstance(builtins, dict):",
            "    builtins = builtins.__dict__",
            "",
            "HAS_NUMPY = False",
            "try:",
            "    import numpy",
            "    numpy_version = numpy.version.version.split('.', 2)",
            "    HAS_NUMPY = True",
            "except ImportError:",
            "    numpy = None",
            "",
            "HAS_NUMPY_FINANCIAL = False",
            "try:",
            "    import numpy_financial",
            "    HAS_NUMPY_FINANCIAL = True",
            "except ImportError:",
            "    pass",
            "",
            "",
            "",
            "MAX_EXPONENT = 10000",
            "MAX_STR_LEN = 2 << 17  # 256KiB",
            "MAX_SHIFT = 1000",
            "MAX_OPEN_BUFFER = 2 << 17",
            "",
            "RESERVED_WORDS = ('False', 'None', 'True', 'and', 'as', 'assert',",
            "                  'async', 'await', 'break', 'class', 'continue', 'def',",
            "                  'del', 'elif', 'else', 'except', 'finally', 'for',",
            "                  'from', 'global', 'if', 'import', 'in', 'is',",
            "                  'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise',",
            "                  'return', 'try', 'while', 'with', 'yield', 'exec',",
            "                  'eval', 'execfile', '__import__', '__package__',",
            "                  '__fstring__')",
            "",
            "NAME_MATCH = re.compile(r\"[a-zA-Z_][a-zA-Z0-9_]*$\").match",
            "",
            "# unsafe attributes for all objects:",
            "UNSAFE_ATTRS = ('__subclasses__', '__bases__', '__globals__', '__code__',",
            "                '__reduce__', '__reduce_ex__',  '__mro__',",
            "                '__closure__', '__func__', '__self__', '__module__',",
            "                '__dict__', '__class__', '__call__', '__get__',",
            "                '__getattribute__', '__subclasshook__', '__new__',",
            "                '__init__', 'func_globals', 'func_code', 'func_closure',",
            "                'im_class', 'im_func', 'im_self', 'gi_code', 'gi_frame',",
            "                'f_locals', '__asteval__')",
            "",
            "# unsafe attributes for particular objects, by type",
            "UNSAFE_ATTRS_DTYPES = {str: ('format', 'format_map')}",
            "",
            "",
            "# inherit these from python's __builtins__",
            "FROM_PY = ('ArithmeticError', 'AssertionError', 'AttributeError',",
            "           'BaseException', 'BufferError', 'BytesWarning',",
            "           'DeprecationWarning', 'EOFError', 'EnvironmentError',",
            "           'Exception', 'False', 'FloatingPointError', 'GeneratorExit',",
            "           'IOError', 'ImportError', 'ImportWarning', 'IndentationError',",
            "           'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError',",
            "           'MemoryError', 'NameError', 'None',",
            "           'NotImplementedError', 'OSError', 'OverflowError',",
            "           'ReferenceError', 'RuntimeError', 'RuntimeWarning',",
            "           'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',",
            "           'SystemExit', 'True', 'TypeError', 'UnboundLocalError',",
            "           'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError',",
            "           'UnicodeTranslateError', 'UnicodeWarning', 'ValueError',",
            "           'Warning', 'ZeroDivisionError', 'abs', 'all', 'any', 'bin',",
            "           'bool', 'bytearray', 'bytes', 'chr', 'complex', 'dict', 'dir',",
            "           'divmod', 'enumerate', 'filter', 'float', 'format', 'frozenset',",
            "           'hash', 'hex', 'id', 'int', 'isinstance', 'len', 'list', 'map',",
            "           'max', 'min', 'oct', 'ord', 'pow', 'range', 'repr',",
            "           'reversed', 'round', 'set', 'slice', 'sorted', 'str', 'sum',",
            "           'tuple', 'zip')",
            "",
            "BUILTINS_TABLE = {sym: builtins[sym] for sym in FROM_PY if sym in builtins}",
            "",
            "# inherit these from python's math",
            "FROM_MATH = ('acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh',",
            "             'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'exp',",
            "             'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',",
            "             'hypot', 'isinf', 'isnan', 'ldexp', 'log', 'log10', 'log1p',",
            "             'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan',",
            "             'tanh', 'trunc')",
            "",
            "MATH_TABLE = {sym: getattr(math, sym) for sym in FROM_MATH if hasattr(math, sym)}",
            "",
            "FROM_NUMPY = ('abs', 'add', 'all', 'amax', 'amin', 'angle', 'any', 'append',",
            "    'arange', 'arccos', 'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctan2',",
            "    'arctanh', 'argmax', 'argmin', 'argsort', 'argwhere', 'around', 'array',",
            "    'asarray', 'atleast_1d', 'atleast_2d', 'atleast_3d', 'average', 'bartlett',",
            "    'bitwise_and', 'bitwise_not', 'bitwise_or', 'bitwise_xor', 'blackman',",
            "    'broadcast', 'ceil', 'choose', 'clip', 'column_stack', 'common_type',",
            "    'complex128', 'compress', 'concatenate', 'conjugate', 'convolve',",
            "    'copysign', 'corrcoef', 'correlate', 'cos', 'cosh', 'cov', 'cross',",
            "    'cumprod', 'cumsum', 'datetime_data', 'deg2rad', 'degrees', 'delete',",
            "    'diag', 'diag_indices', 'diag_indices_from', 'diagflat', 'diagonal',",
            "    'diff', 'digitize', 'divide', 'dot', 'dsplit', 'dstack', 'dtype', 'e',",
            "    'ediff1d', 'empty', 'empty_like', 'equal', 'exp', 'exp2', 'expand_dims',",
            "    'expm1', 'extract', 'eye', 'fabs', 'fill_diagonal', 'finfo', 'fix',",
            "    'flatiter', 'flatnonzero', 'fliplr', 'flipud', 'float64', 'floor',",
            "    'floor_divide', 'fmax', 'fmin', 'fmod', 'format_parser', 'frexp',",
            "    'frombuffer', 'fromfile', 'fromfunction', 'fromiter', 'frompyfunc',",
            "    'fromregex', 'fromstring', 'genfromtxt', 'getbufsize', 'geterr',",
            "    'gradient', 'greater', 'greater_equal', 'hamming', 'hanning', 'histogram',",
            "    'histogram2d', 'histogramdd', 'hsplit', 'hstack', 'hypot', 'i0',",
            "    'identity', 'iinfo', 'imag', 'indices', 'inexact', 'inf', 'info', 'inner',",
            "    'insert', 'int32', 'integer', 'interp', 'intersect1d', 'invert',",
            "    'iscomplex', 'iscomplexobj', 'isfinite', 'isinf', 'isnan', 'isneginf',",
            "    'isposinf', 'isreal', 'isrealobj', 'isscalar', 'iterable', 'kaiser',",
            "    'kron', 'ldexp', 'left_shift', 'less', 'less_equal', 'linspace',",
            "    'little_endian', 'loadtxt', 'log', 'log10', 'log1p', 'log2', 'logaddexp',",
            "    'logaddexp2', 'logical_and', 'logical_not', 'logical_or', 'logical_xor',",
            "    'logspace', 'longdouble', 'longlong', 'mask_indices', 'matrix', 'maximum',",
            "    'may_share_memory', 'mean', 'median', 'memmap', 'meshgrid', 'minimum',",
            "    'mintypecode', 'mod', 'modf', 'msort', 'multiply', 'nan', 'nan_to_num',",
            "    'nanargmax', 'nanargmin', 'nanmax', 'nanmin', 'nansum', 'ndarray',",
            "    'ndenumerate', 'ndim', 'ndindex', 'negative', 'nextafter', 'nonzero',",
            "    'not_equal', 'number', 'ones', 'ones_like', 'outer', 'packbits',",
            "    'percentile', 'pi', 'piecewise', 'place', 'poly', 'poly1d', 'polyadd',",
            "    'polyder', 'polydiv', 'polyint', 'polymul', 'polysub', 'polyval', 'power',",
            "    'prod', 'ptp', 'put', 'putmask', 'rad2deg', 'radians', 'ravel', 'real',",
            "    'real_if_close', 'reciprocal', 'record', 'remainder', 'repeat', 'reshape',",
            "    'resize', 'right_shift', 'rint', 'roll', 'rollaxis', 'roots', 'rot90',",
            "    'round', 'searchsorted', 'select', 'setbufsize', 'setdiff1d', 'seterr',",
            "    'setxor1d', 'shape', 'short', 'sign', 'signbit', 'signedinteger', 'sin',",
            "    'sinc', 'single', 'sinh', 'size', 'sort', 'sort_complex', 'spacing',",
            "    'split', 'sqrt', 'square', 'squeeze', 'std', 'subtract', 'sum', 'swapaxes',",
            "    'take', 'tan', 'tanh', 'tensordot', 'tile', 'trace', 'transpose', 'tri',",
            "    'tril', 'tril_indices', 'tril_indices_from', 'trim_zeros', 'triu',",
            "    'triu_indices', 'triu_indices_from', 'true_divide', 'trunc', 'ubyte',",
            "    'uint', 'uint32', 'union1d', 'unique', 'unravel_index', 'unsignedinteger',",
            "    'unwrap', 'ushort', 'vander', 'var', 'vdot', 'vectorize', 'vsplit',",
            "    'vstack', 'where', 'zeros', 'zeros_like')",
            "",
            "",
            "FROM_NUMPY_FINANCIAL = ('fv', 'ipmt', 'irr', 'mirr', 'nper', 'npv',",
            "                        'pmt', 'ppmt', 'pv', 'rate')",
            "",
            "NUMPY_RENAMES = {'ln': 'log', 'asin': 'arcsin', 'acos': 'arccos',",
            "                 'atan': 'arctan', 'atan2': 'arctan2', 'atanh':",
            "                 'arctanh', 'acosh': 'arccosh', 'asinh': 'arcsinh'}",
            "",
            "if HAS_NUMPY:",
            "    FROM_NUMPY = tuple(set(FROM_NUMPY))",
            "    FROM_NUMPY = tuple(sym for sym in FROM_NUMPY if hasattr(numpy, sym))",
            "    NUMPY_RENAMES = {sym: value for sym, value in NUMPY_RENAMES.items() if hasattr(numpy, value)}",
            "",
            "    NUMPY_TABLE = {}",
            "    for sym in FROM_NUMPY:",
            "        obj = getattr(numpy, sym, None)",
            "        if obj is not None:",
            "            NUMPY_TABLE[sym] = obj",
            "",
            "    for sname, sym in NUMPY_RENAMES.items():",
            "        obj = getattr(numpy, sym, None)",
            "        if obj is not None:",
            "            NUMPY_TABLE[sname] = obj",
            "",
            "    if HAS_NUMPY_FINANCIAL:",
            "        for sym in FROM_NUMPY_FINANCIAL:",
            "            obj = getattr(numpy_financial, sym, None)",
            "            if obj is not None:",
            "                NUMPY_TABLE[sym] = obj",
            "",
            "else:",
            "    NUMPY_TABLE = {}",
            "",
            "",
            "def _open(filename, mode='r', buffering=-1, encoding=None):",
            "    \"\"\"read only version of open()\"\"\"",
            "    if mode not in ('r', 'rb', 'rU'):",
            "        raise RuntimeError(\"Invalid open file mode, must be 'r', 'rb', or 'rU'\")",
            "    if buffering > MAX_OPEN_BUFFER:",
            "        raise RuntimeError(f\"Invalid buffering value, max buffer size is {MAX_OPEN_BUFFER}\")",
            "    return open(filename, mode, buffering, encoding=encoding)",
            "",
            "",
            "def _type(x):",
            "    \"\"\"type that prevents varargs and varkws\"\"\"",
            "    return type(x).__name__",
            "",
            "",
            "LOCALFUNCS = {'open': _open, 'type': _type}",
            "",
            "",
            "# Safe versions of functions to prevent denial of service issues",
            "",
            "def safe_pow(base, exp):",
            "    \"\"\"safe version of pow\"\"\"",
            "    if isinstance(exp, numbers.Number):",
            "        if exp > MAX_EXPONENT:",
            "            raise RuntimeError(f\"Invalid exponent, max exponent is {MAX_EXPONENT}\")",
            "    elif HAS_NUMPY and isinstance(exp, numpy.ndarray):",
            "        if numpy.nanmax(exp) > MAX_EXPONENT:",
            "            raise RuntimeError(f\"Invalid exponent, max exponent is {MAX_EXPONENT}\")",
            "    return base ** exp",
            "",
            "",
            "def safe_mult(arg1, arg2):",
            "    \"\"\"safe version of multiply\"\"\"",
            "    if isinstance(arg1, str) and isinstance(arg2, int) and len(arg1) * arg2 > MAX_STR_LEN:",
            "        raise RuntimeError(f\"String length exceeded, max string length is {MAX_STR_LEN}\")",
            "    return arg1 * arg2",
            "",
            "",
            "def safe_add(arg1, arg2):",
            "    \"\"\"safe version of add\"\"\"",
            "    if isinstance(arg1, str) and isinstance(arg2, str) and len(arg1) + len(arg2) > MAX_STR_LEN:",
            "        raise RuntimeError(f\"String length exceeded, max string length is {MAX_STR_LEN}\")",
            "    return arg1 + arg2",
            "",
            "",
            "def safe_lshift(arg1, arg2):",
            "    \"\"\"safe version of lshift\"\"\"",
            "    if isinstance(arg2, numbers.Number):",
            "        if arg2 > MAX_SHIFT:",
            "            raise RuntimeError(f\"Invalid left shift, max left shift is {MAX_SHIFT}\")",
            "    elif HAS_NUMPY and isinstance(arg2, numpy.ndarray):",
            "        if numpy.nanmax(arg2) > MAX_SHIFT:",
            "            raise RuntimeError(f\"Invalid left shift, max left shift is {MAX_SHIFT}\")",
            "    return arg1 << arg2",
            "",
            "",
            "OPERATORS = {ast.Is: lambda a, b: a is b,",
            "             ast.IsNot: lambda a, b: a is not b,",
            "             ast.In: lambda a, b: a in b,",
            "             ast.NotIn: lambda a, b: a not in b,",
            "             ast.Add: safe_add,",
            "             ast.BitAnd: lambda a, b: a & b,",
            "             ast.BitOr: lambda a, b: a | b,",
            "             ast.BitXor: lambda a, b: a ^ b,",
            "             ast.Div: lambda a, b: a / b,",
            "             ast.FloorDiv: lambda a, b: a // b,",
            "             ast.LShift: safe_lshift,",
            "             ast.RShift: lambda a, b: a >> b,",
            "             ast.Mult: safe_mult,",
            "             ast.Pow: safe_pow,",
            "             ast.MatMult: lambda a, b: a @ b,",
            "             ast.Sub: lambda a, b: a - b,",
            "             ast.Mod: lambda a, b: a % b,",
            "             ast.And: lambda a, b: a and b,",
            "             ast.Or: lambda a, b: a or b,",
            "             ast.Eq: lambda a, b: a == b,",
            "             ast.Gt: lambda a, b: a > b,",
            "             ast.GtE: lambda a, b: a >= b,",
            "             ast.Lt: lambda a, b: a < b,",
            "             ast.LtE: lambda a, b: a <= b,",
            "             ast.NotEq: lambda a, b: a != b,",
            "             ast.Invert: lambda a: ~a,",
            "             ast.Not: lambda a: not a,",
            "             ast.UAdd: lambda a: +a,",
            "             ast.USub: lambda a: -a}",
            "",
            "",
            "def valid_symbol_name(name):",
            "    \"\"\"Determine whether the input symbol name is a valid name.",
            "",
            "    Arguments",
            "    ---------",
            "      name  : str",
            "         name to check for validity.",
            "",
            "    Returns",
            "    --------",
            "      valid :  bool",
            "        whether name is a a valid symbol name",
            "",
            "    This checks for Python reserved words and that the name matches",
            "    the regular expression ``[a-zA-Z_][a-zA-Z0-9_]``",
            "    \"\"\"",
            "    if name in RESERVED_WORDS:",
            "        return False",
            "",
            "    gen = generate_tokens(io.BytesIO(name.encode('utf-8')).readline)",
            "    typ, _, start, end, _ = next(gen)",
            "    if typ == tk_ENCODING:",
            "        typ, _, start, end, _ = next(gen)",
            "    return typ == tk_NAME and start == (1, 0) and end == (1, len(name))",
            "",
            "",
            "def op2func(oper):",
            "    \"\"\"Return function for operator nodes.\"\"\"",
            "    return OPERATORS[oper.__class__]",
            "",
            "",
            "class Empty:",
            "    \"\"\"Empty class.\"\"\"",
            "    def __init__(self):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        return",
            "",
            "    def __nonzero__(self):",
            "        \"\"\"Empty is TODO: docstring in magic method.\"\"\"",
            "        return False",
            "",
            "    def __repr__(self):",
            "        \"\"\"Empty is TODO: docstring in magic method.\"\"\"",
            "        return \"Empty\"",
            "",
            "ReturnedNone = Empty()",
            "",
            "class ExceptionHolder:",
            "    \"\"\"Basic exception handler.\"\"\"",
            "    def __init__(self, node, exc=None, msg='', expr=None, lineno=None):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        self.node = node",
            "        self.expr = expr",
            "        self.msg = msg",
            "        self.exc = exc",
            "        self.lineno = lineno",
            "        self.exc_info = exc_info()",
            "        if self.exc is None and self.exc_info[0] is not None:",
            "            self.exc = self.exc_info[0]",
            "        if self.msg == '' and self.exc_info[1] is not None:",
            "            self.msg = str(self.exc_info[1])",
            "",
            "    def get_error(self):",
            "        \"\"\"Retrieve error data.\"\"\"",
            "        col_offset = -1",
            "        if self.node is not None:",
            "            try:",
            "                col_offset = self.node.col_offset",
            "            except AttributeError:",
            "                pass",
            "        try:",
            "            exc_name = self.exc.__name__",
            "        except AttributeError:",
            "            exc_name = str(self.exc)",
            "        if exc_name in (None, 'None'):",
            "            exc_name = 'UnknownError'",
            "",
            "        out = [f\"   {self.expr}\"]",
            "        if col_offset > 0:",
            "            out.append(f\"    {col_offset*' '}^^^^\")",
            "        out.append(f\"{exc_name}: {self.msg}\")",
            "        return (exc_name, '\\n'.join(out))",
            "",
            "    def __repr__(self):",
            "        return f\"ExceptionHolder({self.exc}, {self.msg})\"",
            "",
            "class NameFinder(ast.NodeVisitor):",
            "    \"\"\"Find all symbol names used by a parsed node.\"\"\"",
            "",
            "    def __init__(self):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        self.names = []",
            "        ast.NodeVisitor.__init__(self)",
            "",
            "    def generic_visit(self, node):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        if node.__class__.__name__ == 'Name':",
            "            if node.id not in self.names:",
            "                self.names.append(node.id)",
            "        ast.NodeVisitor.generic_visit(self, node)",
            "",
            "",
            "def get_ast_names(astnode):",
            "    \"\"\"Return symbol Names from an AST node.\"\"\"",
            "    finder = NameFinder()",
            "    finder.generic_visit(astnode)",
            "    return finder.names",
            "",
            "",
            "def valid_varname(name):",
            "    \"is this a valid variable name\"",
            "    return name.isidentifier() and name not in RESERVED_WORDS",
            "",
            "",
            "class Group(dict):",
            "    \"\"\"",
            "    Group: a container of objects that can be accessed either as an object attributes",
            "    or dictionary  key/value.  Attribute names must follow Python naming conventions.",
            "    \"\"\"",
            "    def __init__(self, name=None, searchgroups=None, **kws):",
            "        if name is None:",
            "            name = hex(id(self))",
            "        self.__name__ = name",
            "        dict.__init__(self, **kws)",
            "        self._searchgroups = searchgroups",
            "",
            "    def __setattr__(self, name, value):",
            "        if not valid_varname(name):",
            "            raise SyntaxError(f\"invalid attribute name '{name}'\")",
            "        self[name] = value",
            "",
            "    def __getattr__(self, name, default=None):",
            "        if name in self:",
            "            return self[name]",
            "        if default is not None:",
            "            return default",
            "        raise KeyError(f\"no attribute named '{name}'\")",
            "",
            "    def __setitem__(self, name, value):",
            "        if valid_varname(name):",
            "            dict.__setitem__(self, name, value)",
            "        else: # raise SyntaxError(f\"invalid attribute name '{name}'\")",
            "            return setattr(self, name, value)",
            "",
            "    def get(self, key, default=None):",
            "        val = self.__getattr__(key, ReturnedNone)",
            "        if not isinstance(val, Empty):",
            "            return val",
            "        searchgroups = self._searchgroups",
            "        if searchgroups is not None:",
            "            for sgroup in searchgroups:",
            "                grp = self.__getattr__(sgroup, None)",
            "                if isinstance(grp, (Group, dict)):",
            "                    val = grp.__getattr__(key, ReturnedNone)",
            "                    if not isinstance(val, Empty):",
            "                        return val",
            "        return default",
            "",
            "",
            "    def __repr__(self):",
            "        keys = [a for a in self.keys() if a != '__name__']",
            "        return f\"Group('{self.__name__}', {len(keys)} symbols)\"",
            "",
            "    def _repr_html_(self):",
            "        \"\"\"HTML representation for Jupyter notebook\"\"\"",
            "        html = [f\"<table><caption>Group('{self.__name__}')</caption>\",",
            "  \"<tr><th>Attribute</th><th>DataType</th><th><b>Value</b></th></tr>\"]",
            "        for key, val in self.items():",
            "            html.append(f\"\"\"",
            "<tr><td>{key}</td><td><i>{type(val).__name__}</i></td>",
            "    <td>{repr(val):.75s}</td>",
            "</tr>\"\"\")",
            "        html.append(\"</table>\")",
            "        return '\\n'.join(html)",
            "",
            "",
            "def make_symbol_table(use_numpy=True, nested=False, top=True,  **kws):",
            "    \"\"\"Create a default symboltable, taking dict of user-defined symbols.",
            "",
            "    Arguments",
            "    ---------",
            "    numpy : bool, optional",
            "       whether to include symbols from numpy [True]",
            "    nested : bool, optional",
            "       whether to make a \"new-style\" nested table instead of a plain dict [False]",
            "    top : bool, optional",
            "       whether this is the top-level table in a nested-table [True]",
            "    kws :  optional",
            "       additional symbol name, value pairs to include in symbol table",
            "",
            "    Returns",
            "    --------",
            "    symbol_table : dict or nested Group",
            "       a symbol table that can be used in `asteval.Interpereter`",
            "",
            "    \"\"\"",
            "    if nested:",
            "        name = '_'",
            "        if top:",
            "            name = '_main'",
            "            if 'name' in kws:",
            "                name = kws.pop('name')",
            "        symtable = Group(name=name, Group=Group)",
            "    else:",
            "        symtable = {}",
            "",
            "    symtable.update(BUILTINS_TABLE)",
            "    symtable.update(LOCALFUNCS)",
            "    symtable.update(kws)",
            "    math_functions = dict(MATH_TABLE.items())",
            "    if use_numpy:",
            "        math_functions.update(NUMPY_TABLE)",
            "",
            "    if nested:",
            "        symtable['math'] = Group(name='math', **math_functions)",
            "        symtable['Group'] = Group",
            "        symtable._searchgroups = ('math',)",
            "    else:",
            "        symtable.update(math_functions)",
            "    symtable.update(**kws)",
            "    return symtable",
            "",
            "",
            "class Procedure:",
            "    \"\"\"Procedure: user-defined function for asteval.",
            "",
            "    This stores the parsed ast nodes as from the 'functiondef' ast node",
            "    for later evaluation.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, name, interp, doc=None, lineno=0,",
            "                 body=None, args=None, kwargs=None,",
            "                 vararg=None, varkws=None):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        self.__ininit__ = True",
            "        self.name = name",
            "        self.__name__ = self.name",
            "        self.__asteval__ = interp",
            "        self.__raise_exc__ = self.__asteval__.raise_exception",
            "        self.__doc__ = doc",
            "        self.__body__ = body",
            "        self.__argnames__ = args",
            "        self.__kwargs__ = kwargs",
            "        self.__vararg__ = vararg",
            "        self.__varkws__ = varkws",
            "        self.lineno = lineno",
            "        self.__ininit__ = False",
            "",
            "    def __setattr__(self, attr, val):",
            "        if not getattr(self, '__ininit__', True):",
            "            self.__raise_exc__(None, exc=TypeError,",
            "                           msg=\"procedure is read-only\")",
            "        self.__dict__[attr] = val",
            "",
            "    def __dir__(self):",
            "        return ['__getdoc__', 'argnames', 'kwargs', 'name', 'vararg', 'varkws']",
            "",
            "    def __getdoc__(self):",
            "        doc = self.__doc__",
            "        if isinstance(doc, ast.Constant):",
            "            doc = doc.value",
            "        return doc",
            "",
            "    def __repr__(self):",
            "        \"\"\"TODO: docstring in magic method.\"\"\"",
            "        sig = self.__signature__()",
            "        rep = f\"<Procedure {sig}>\"",
            "        doc = self.__getdoc__()",
            "        if doc is not None:",
            "            rep = f\"{rep}\\n {doc}\"",
            "        return rep",
            "",
            "    def __signature__(self):",
            "        \"call signature\"",
            "        sig = \"\"",
            "        if len(self.__argnames__) > 0:",
            "            sig = sig +  ', '.join(self.__argnames__)",
            "        if self.__vararg__ is not None:",
            "            sig = sig + f\"*{self.__vararg__}\"",
            "        if len(self.__kwargs__) > 0:",
            "            if len(sig) > 0:",
            "                sig = f\"{sig}, \"",
            "            _kw = [f\"{k}={v}\" for k, v in self.__kwargs__]",
            "            sig = f\"{sig}{', '.join(_kw)}\"",
            "",
            "            if self.__varkws__ is not None:",
            "                sig = f\"{sig}, **{self.__varkws__}\"",
            "        return f\"{self.name}({sig})\"",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        topsym = self.__asteval__.symtable",
            "        if self.__asteval__.config.get('nested_symtable', False):",
            "            sargs = {'_main': topsym}",
            "            sgroups = topsym.get('_searchgroups', None)",
            "            if sgroups is not None:",
            "                for sxname in sgroups:",
            "                    sargs[sxname] = topsym.get(sxname)",
            "",
            "",
            "            symlocals = Group(name=f'symtable_{self.name}_', **sargs)",
            "            symlocals._searchgroups = list(sargs.keys())",
            "        else:",
            "            symlocals = {}",
            "",
            "        args = list(args)",
            "        nargs = len(args)",
            "        nkws = len(kwargs)",
            "        nargs_expected = len(self.__argnames__)",
            "",
            "        # check for too few arguments, but the correct keyword given",
            "        if (nargs < nargs_expected) and nkws > 0:",
            "            for name in self.__argnames__[nargs:]:",
            "                if name in kwargs:",
            "                    args.append(kwargs.pop(name))",
            "            nargs = len(args)",
            "            nargs_expected = len(self.__argnames__)",
            "            nkws = len(kwargs)",
            "        if nargs < nargs_expected:",
            "            msg = f\"{self.name}() takes at least\"",
            "            msg = f\"{msg} {nargs_expected} arguments, got {nargs}\"",
            "            self.__raise_exc__(None, exc=TypeError, msg=msg)",
            "        # check for multiple values for named argument",
            "        if len(self.__argnames__) > 0 and kwargs is not None:",
            "            msg = \"multiple values for keyword argument\"",
            "            for targ in self.__argnames__:",
            "                if targ in kwargs:",
            "                    msg = f\"{msg} '{targ}' in Procedure {self.name}\"",
            "                    self.__raise_exc__(None, exc=TypeError, msg=msg, lineno=self.lineno)",
            "",
            "        # check more args given than expected, varargs not given",
            "        if nargs != nargs_expected:",
            "            msg = None",
            "            if nargs < nargs_expected:",
            "                msg = f\"not enough arguments for Procedure {self.name}()\"",
            "                msg = f\"{msg} (expected {nargs_expected}, got {nargs}\"",
            "                self.__raise_exc__(None, exc=TypeError, msg=msg)",
            "",
            "        if nargs > nargs_expected and self.__vararg__ is None:",
            "            if nargs - nargs_expected > len(self.__kwargs__):",
            "                msg = f\"too many arguments for {self.name}() expected at most\"",
            "                msg = f\"{msg} {len(self.__kwargs__)+nargs_expected}, got {nargs}\"",
            "                self.__raise_exc__(None, exc=TypeError, msg=msg)",
            "",
            "            for i, xarg in enumerate(args[nargs_expected:]):",
            "                kw_name = self.__kwargs__[i][0]",
            "                if kw_name not in kwargs:",
            "                    kwargs[kw_name] = xarg",
            "",
            "        for argname in self.__argnames__:",
            "            symlocals[argname] = args.pop(0)",
            "",
            "        try:",
            "            if self.__vararg__ is not None:",
            "                symlocals[self.__vararg__] = tuple(args)",
            "",
            "            for key, val in self.__kwargs__:",
            "                if key in kwargs:",
            "                    val = kwargs.pop(key)",
            "                symlocals[key] = val",
            "",
            "            if self.__varkws__ is not None:",
            "                symlocals[self.__varkws__] = kwargs",
            "",
            "            elif len(kwargs) > 0:",
            "                msg = f\"extra keyword arguments for Procedure {self.name}: \"",
            "                msg = msg + ','.join(list(kwargs.keys()))",
            "                self.__raise_exc__(None, msg=msg, exc=TypeError,",
            "                               lineno=self.lineno)",
            "",
            "        except (ValueError, LookupError, TypeError,",
            "                NameError, AttributeError):",
            "            msg = f\"incorrect arguments for Procedure {self.name}\"",
            "            self.__raise_exc__(None, msg=msg, lineno=self.lineno)",
            "",
            "        if self.__asteval__.config.get('nested_symtable', False):",
            "            save_symtable = self.__asteval__.symtable",
            "            self.__asteval__.symtable = symlocals",
            "        else:",
            "            save_symtable = self.__asteval__.symtable.copy()",
            "            self.__asteval__.symtable.update(symlocals)",
            "",
            "        self.__asteval__.retval = None",
            "        self.__asteval__._calldepth += 1",
            "        retval = None",
            "",
            "        # evaluate script of function",
            "        for node in self.__body__:",
            "            self.__asteval__.run(node, expr='<>', lineno=self.lineno)",
            "            if len(self.__asteval__.error) > 0:",
            "                break",
            "            if self.__asteval__.retval is not None:",
            "                retval = self.__asteval__.retval",
            "                self.__asteval__.retval = None",
            "                if retval is ReturnedNone:",
            "                    retval = None",
            "                break",
            "",
            "        self.__asteval__.symtable = save_symtable",
            "        self.__asteval__._calldepth -= 1",
            "        symlocals = None",
            "        return retval"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "utility functions for asteval",
            "",
            "   Matthew Newville <newville@cars.uchicago.edu>,",
            "   The University of Chicago",
            "\"\"\"",
            "import ast",
            "import io",
            "import math",
            "import numbers",
            "import re",
            "from sys import exc_info",
            "from tokenize import ENCODING as tk_ENCODING",
            "from tokenize import NAME as tk_NAME",
            "from tokenize import tokenize as generate_tokens",
            "from string import Formatter",
            "",
            "builtins = __builtins__",
            "if not isinstance(builtins, dict):",
            "    builtins = builtins.__dict__",
            "",
            "HAS_NUMPY = False",
            "try:",
            "    import numpy",
            "    numpy_version = numpy.version.version.split('.', 2)",
            "    HAS_NUMPY = True",
            "except ImportError:",
            "    numpy = None",
            "",
            "HAS_NUMPY_FINANCIAL = False",
            "try:",
            "    import numpy_financial",
            "    HAS_NUMPY_FINANCIAL = True",
            "except ImportError:",
            "    pass",
            "",
            "# This is a necessary API but it's undocumented and moved around",
            "# between Python releases",
            "try:",
            "    from _string import formatter_field_name_split",
            "except ImportError:",
            "    formatter_field_name_split = lambda \\",
            "        x: x._formatter_field_name_split()",
            "",
            "",
            "",
            "MAX_EXPONENT = 10000",
            "MAX_STR_LEN = 2 << 17  # 256KiB",
            "MAX_SHIFT = 1000",
            "MAX_OPEN_BUFFER = 2 << 17",
            "",
            "RESERVED_WORDS = ('False', 'None', 'True', 'and', 'as', 'assert',",
            "                  'async', 'await', 'break', 'class', 'continue', 'def',",
            "                  'del', 'elif', 'else', 'except', 'finally', 'for',",
            "                  'from', 'global', 'if', 'import', 'in', 'is',",
            "                  'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise',",
            "                  'return', 'try', 'while', 'with', 'yield', 'exec',",
            "                  'eval', 'execfile', '__import__', '__package__',",
            "                  '__fstring__')",
            "",
            "NAME_MATCH = re.compile(r\"[a-zA-Z_][a-zA-Z0-9_]*$\").match",
            "",
            "# unsafe attributes for all objects:",
            "UNSAFE_ATTRS = ('__subclasses__', '__bases__', '__globals__', '__code__',",
            "                '__reduce__', '__reduce_ex__',  '__mro__',",
            "                '__closure__', '__func__', '__self__', '__module__',",
            "                '__dict__', '__class__', '__call__', '__get__',",
            "                '__getattribute__', '__subclasshook__', '__new__',",
            "                '__init__', 'func_globals', 'func_code', 'func_closure',",
            "                'im_class', 'im_func', 'im_self', 'gi_code', 'gi_frame',",
            "                'f_locals', '__asteval__','mro')",
            "",
            "# unsafe attributes for particular objects, by type",
            "UNSAFE_ATTRS_DTYPES = {str: ('format', 'format_map')}",
            "",
            "",
            "# inherit these from python's __builtins__",
            "FROM_PY = ('ArithmeticError', 'AssertionError', 'AttributeError',",
            "           'BaseException', 'BufferError', 'BytesWarning',",
            "           'DeprecationWarning', 'EOFError', 'EnvironmentError',",
            "           'Exception', 'False', 'FloatingPointError', 'GeneratorExit',",
            "           'IOError', 'ImportError', 'ImportWarning', 'IndentationError',",
            "           'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError',",
            "           'MemoryError', 'NameError', 'None',",
            "           'NotImplementedError', 'OSError', 'OverflowError',",
            "           'ReferenceError', 'RuntimeError', 'RuntimeWarning',",
            "           'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',",
            "           'SystemExit', 'True', 'TypeError', 'UnboundLocalError',",
            "           'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError',",
            "           'UnicodeTranslateError', 'UnicodeWarning', 'ValueError',",
            "           'Warning', 'ZeroDivisionError', 'abs', 'all', 'any', 'bin',",
            "           'bool', 'bytearray', 'bytes', 'chr', 'complex', 'dict', 'dir',",
            "           'divmod', 'enumerate', 'filter', 'float', 'format', 'frozenset',",
            "           'hash', 'hex', 'id', 'int', 'isinstance', 'len', 'list', 'map',",
            "           'max', 'min', 'oct', 'ord', 'pow', 'range', 'repr',",
            "           'reversed', 'round', 'set', 'slice', 'sorted', 'str', 'sum',",
            "           'tuple', 'zip')",
            "",
            "BUILTINS_TABLE = {sym: builtins[sym] for sym in FROM_PY if sym in builtins}",
            "",
            "# inherit these from python's math",
            "FROM_MATH = ('acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh',",
            "             'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'exp',",
            "             'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',",
            "             'hypot', 'isinf', 'isnan', 'ldexp', 'log', 'log10', 'log1p',",
            "             'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan',",
            "             'tanh', 'trunc')",
            "",
            "MATH_TABLE = {sym: getattr(math, sym) for sym in FROM_MATH if hasattr(math, sym)}",
            "",
            "FROM_NUMPY = ('abs', 'add', 'all', 'amax', 'amin', 'angle', 'any', 'append',",
            "    'arange', 'arccos', 'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctan2',",
            "    'arctanh', 'argmax', 'argmin', 'argsort', 'argwhere', 'around', 'array',",
            "    'asarray', 'atleast_1d', 'atleast_2d', 'atleast_3d', 'average', 'bartlett',",
            "    'bitwise_and', 'bitwise_not', 'bitwise_or', 'bitwise_xor', 'blackman',",
            "    'broadcast', 'ceil', 'choose', 'clip', 'column_stack', 'common_type',",
            "    'complex128', 'compress', 'concatenate', 'conjugate', 'convolve',",
            "    'copysign', 'corrcoef', 'correlate', 'cos', 'cosh', 'cov', 'cross',",
            "    'cumprod', 'cumsum', 'datetime_data', 'deg2rad', 'degrees', 'delete',",
            "    'diag', 'diag_indices', 'diag_indices_from', 'diagflat', 'diagonal',",
            "    'diff', 'digitize', 'divide', 'dot', 'dsplit', 'dstack', 'dtype', 'e',",
            "    'ediff1d', 'empty', 'empty_like', 'equal', 'exp', 'exp2', 'expand_dims',",
            "    'expm1', 'extract', 'eye', 'fabs', 'fill_diagonal', 'finfo', 'fix',",
            "    'flatiter', 'flatnonzero', 'fliplr', 'flipud', 'float64', 'floor',",
            "    'floor_divide', 'fmax', 'fmin', 'fmod', 'format_parser', 'frexp',",
            "    'frombuffer', 'fromfile', 'fromfunction', 'fromiter', 'frompyfunc',",
            "    'fromregex', 'fromstring', 'genfromtxt', 'getbufsize', 'geterr',",
            "    'gradient', 'greater', 'greater_equal', 'hamming', 'hanning', 'histogram',",
            "    'histogram2d', 'histogramdd', 'hsplit', 'hstack', 'hypot', 'i0',",
            "    'identity', 'iinfo', 'imag', 'indices', 'inexact', 'inf', 'info', 'inner',",
            "    'insert', 'int32', 'integer', 'interp', 'intersect1d', 'invert',",
            "    'iscomplex', 'iscomplexobj', 'isfinite', 'isinf', 'isnan', 'isneginf',",
            "    'isposinf', 'isreal', 'isrealobj', 'isscalar', 'iterable', 'kaiser',",
            "    'kron', 'ldexp', 'left_shift', 'less', 'less_equal', 'linspace',",
            "    'little_endian', 'loadtxt', 'log', 'log10', 'log1p', 'log2', 'logaddexp',",
            "    'logaddexp2', 'logical_and', 'logical_not', 'logical_or', 'logical_xor',",
            "    'logspace', 'longdouble', 'longlong', 'mask_indices', 'matrix', 'maximum',",
            "    'may_share_memory', 'mean', 'median', 'memmap', 'meshgrid', 'minimum',",
            "    'mintypecode', 'mod', 'modf', 'msort', 'multiply', 'nan', 'nan_to_num',",
            "    'nanargmax', 'nanargmin', 'nanmax', 'nanmin', 'nansum', 'ndarray',",
            "    'ndenumerate', 'ndim', 'ndindex', 'negative', 'nextafter', 'nonzero',",
            "    'not_equal', 'number', 'ones', 'ones_like', 'outer', 'packbits',",
            "    'percentile', 'pi', 'piecewise', 'place', 'poly', 'poly1d', 'polyadd',",
            "    'polyder', 'polydiv', 'polyint', 'polymul', 'polysub', 'polyval', 'power',",
            "    'prod', 'ptp', 'put', 'putmask', 'rad2deg', 'radians', 'ravel', 'real',",
            "    'real_if_close', 'reciprocal', 'record', 'remainder', 'repeat', 'reshape',",
            "    'resize', 'right_shift', 'rint', 'roll', 'rollaxis', 'roots', 'rot90',",
            "    'round', 'searchsorted', 'select', 'setbufsize', 'setdiff1d', 'seterr',",
            "    'setxor1d', 'shape', 'short', 'sign', 'signbit', 'signedinteger', 'sin',",
            "    'sinc', 'single', 'sinh', 'size', 'sort', 'sort_complex', 'spacing',",
            "    'split', 'sqrt', 'square', 'squeeze', 'std', 'subtract', 'sum', 'swapaxes',",
            "    'take', 'tan', 'tanh', 'tensordot', 'tile', 'trace', 'transpose', 'tri',",
            "    'tril', 'tril_indices', 'tril_indices_from', 'trim_zeros', 'triu',",
            "    'triu_indices', 'triu_indices_from', 'true_divide', 'trunc', 'ubyte',",
            "    'uint', 'uint32', 'union1d', 'unique', 'unravel_index', 'unsignedinteger',",
            "    'unwrap', 'ushort', 'vander', 'var', 'vdot', 'vectorize', 'vsplit',",
            "    'vstack', 'where', 'zeros', 'zeros_like')",
            "",
            "",
            "FROM_NUMPY_FINANCIAL = ('fv', 'ipmt', 'irr', 'mirr', 'nper', 'npv',",
            "                        'pmt', 'ppmt', 'pv', 'rate')",
            "",
            "NUMPY_RENAMES = {'ln': 'log', 'asin': 'arcsin', 'acos': 'arccos',",
            "                 'atan': 'arctan', 'atan2': 'arctan2', 'atanh':",
            "                 'arctanh', 'acosh': 'arccosh', 'asinh': 'arcsinh'}",
            "",
            "if HAS_NUMPY:",
            "    FROM_NUMPY = tuple(set(FROM_NUMPY))",
            "    FROM_NUMPY = tuple(sym for sym in FROM_NUMPY if hasattr(numpy, sym))",
            "    NUMPY_RENAMES = {sym: value for sym, value in NUMPY_RENAMES.items() if hasattr(numpy, value)}",
            "",
            "    NUMPY_TABLE = {}",
            "    for sym in FROM_NUMPY:",
            "        obj = getattr(numpy, sym, None)",
            "        if obj is not None:",
            "            NUMPY_TABLE[sym] = obj",
            "",
            "    for sname, sym in NUMPY_RENAMES.items():",
            "        obj = getattr(numpy, sym, None)",
            "        if obj is not None:",
            "            NUMPY_TABLE[sname] = obj",
            "",
            "    if HAS_NUMPY_FINANCIAL:",
            "        for sym in FROM_NUMPY_FINANCIAL:",
            "            obj = getattr(numpy_financial, sym, None)",
            "            if obj is not None:",
            "                NUMPY_TABLE[sym] = obj",
            "",
            "else:",
            "    NUMPY_TABLE = {}",
            "",
            "",
            "def _open(filename, mode='r', buffering=-1, encoding=None):",
            "    \"\"\"read only version of open()\"\"\"",
            "    if mode not in ('r', 'rb', 'rU'):",
            "        raise RuntimeError(\"Invalid open file mode, must be 'r', 'rb', or 'rU'\")",
            "    if buffering > MAX_OPEN_BUFFER:",
            "        raise RuntimeError(f\"Invalid buffering value, max buffer size is {MAX_OPEN_BUFFER}\")",
            "    return open(filename, mode, buffering, encoding=encoding)",
            "",
            "",
            "def _type(x):",
            "    \"\"\"type that prevents varargs and varkws\"\"\"",
            "    return type(x).__name__",
            "",
            "",
            "LOCALFUNCS = {'open': _open, 'type': _type}",
            "",
            "",
            "# Safe versions of functions to prevent denial of service issues",
            "",
            "def safe_pow(base, exp):",
            "    \"\"\"safe version of pow\"\"\"",
            "    if isinstance(exp, numbers.Number):",
            "        if exp > MAX_EXPONENT:",
            "            raise RuntimeError(f\"Invalid exponent, max exponent is {MAX_EXPONENT}\")",
            "    elif HAS_NUMPY and isinstance(exp, numpy.ndarray):",
            "        if numpy.nanmax(exp) > MAX_EXPONENT:",
            "            raise RuntimeError(f\"Invalid exponent, max exponent is {MAX_EXPONENT}\")",
            "    return base ** exp",
            "",
            "",
            "def safe_mult(arg1, arg2):",
            "    \"\"\"safe version of multiply\"\"\"",
            "    if isinstance(arg1, str) and isinstance(arg2, int) and len(arg1) * arg2 > MAX_STR_LEN:",
            "        raise RuntimeError(f\"String length exceeded, max string length is {MAX_STR_LEN}\")",
            "    return arg1 * arg2",
            "",
            "",
            "def safe_add(arg1, arg2):",
            "    \"\"\"safe version of add\"\"\"",
            "    if isinstance(arg1, str) and isinstance(arg2, str) and len(arg1) + len(arg2) > MAX_STR_LEN:",
            "        raise RuntimeError(f\"String length exceeded, max string length is {MAX_STR_LEN}\")",
            "    return arg1 + arg2",
            "",
            "",
            "def safe_lshift(arg1, arg2):",
            "    \"\"\"safe version of lshift\"\"\"",
            "    if isinstance(arg2, numbers.Number):",
            "        if arg2 > MAX_SHIFT:",
            "            raise RuntimeError(f\"Invalid left shift, max left shift is {MAX_SHIFT}\")",
            "    elif HAS_NUMPY and isinstance(arg2, numpy.ndarray):",
            "        if numpy.nanmax(arg2) > MAX_SHIFT:",
            "            raise RuntimeError(f\"Invalid left shift, max left shift is {MAX_SHIFT}\")",
            "    return arg1 << arg2",
            "",
            "",
            "OPERATORS = {ast.Is: lambda a, b: a is b,",
            "             ast.IsNot: lambda a, b: a is not b,",
            "             ast.In: lambda a, b: a in b,",
            "             ast.NotIn: lambda a, b: a not in b,",
            "             ast.Add: safe_add,",
            "             ast.BitAnd: lambda a, b: a & b,",
            "             ast.BitOr: lambda a, b: a | b,",
            "             ast.BitXor: lambda a, b: a ^ b,",
            "             ast.Div: lambda a, b: a / b,",
            "             ast.FloorDiv: lambda a, b: a // b,",
            "             ast.LShift: safe_lshift,",
            "             ast.RShift: lambda a, b: a >> b,",
            "             ast.Mult: safe_mult,",
            "             ast.Pow: safe_pow,",
            "             ast.MatMult: lambda a, b: a @ b,",
            "             ast.Sub: lambda a, b: a - b,",
            "             ast.Mod: lambda a, b: a % b,",
            "             ast.And: lambda a, b: a and b,",
            "             ast.Or: lambda a, b: a or b,",
            "             ast.Eq: lambda a, b: a == b,",
            "             ast.Gt: lambda a, b: a > b,",
            "             ast.GtE: lambda a, b: a >= b,",
            "             ast.Lt: lambda a, b: a < b,",
            "             ast.LtE: lambda a, b: a <= b,",
            "             ast.NotEq: lambda a, b: a != b,",
            "             ast.Invert: lambda a: ~a,",
            "             ast.Not: lambda a: not a,",
            "             ast.UAdd: lambda a: +a,",
            "             ast.USub: lambda a: -a}",
            "",
            "# Safe version of getattr",
            "",
            "def safe_getattr(obj, attr, raise_exc, node):",
            "    \"\"\"safe version of getattr\"\"\"",
            "    unsafe = (attr in UNSAFE_ATTRS or",
            "            (attr.startswith('__') and attr.endswith('__')))",
            "    if not unsafe:",
            "        for dtype, attrlist in UNSAFE_ATTRS_DTYPES.items():",
            "            unsafe = (isinstance(obj, dtype) or obj is dtype) and attr in attrlist",
            "            if unsafe:",
            "                break",
            "    if unsafe:",
            "        msg = f\"no safe attribute '{attr}' for {repr(obj)}\"",
            "        raise_exc(node, exc=AttributeError, msg=msg)",
            "    else:",
            "        try:",
            "            return getattr(obj, attr)",
            "        except AttributeError:",
            "            pass",
            "",
            "class SafeFormatter(Formatter):",
            "    def __init__(self, raise_exc, node):",
            "        self.raise_exc = raise_exc",
            "        self.node = node",
            "        super().__init__()",
            "",
            "    def get_field(self, field_name, args, kwargs):",
            "        first, rest = formatter_field_name_split(field_name)",
            "        obj = self.get_value(first, args, kwargs)",
            "        for is_attr, i in rest:",
            "            if is_attr:",
            "                obj = safe_getattr(obj, i, self.raise_exc, self.node)",
            "            else:",
            "                obj = obj[i]",
            "        return obj, first",
            "    ",
            "def safe_format(_string, raise_exc, node, *args, **kwargs):",
            "    formatter = SafeFormatter(raise_exc, node)",
            "    return formatter.vformat(_string, args, kwargs)                    ",
            "",
            "def valid_symbol_name(name):",
            "    \"\"\"Determine whether the input symbol name is a valid name.",
            "",
            "    Arguments",
            "    ---------",
            "      name  : str",
            "         name to check for validity.",
            "",
            "    Returns",
            "    --------",
            "      valid :  bool",
            "        whether name is a a valid symbol name",
            "",
            "    This checks for Python reserved words and that the name matches",
            "    the regular expression ``[a-zA-Z_][a-zA-Z0-9_]``",
            "    \"\"\"",
            "    if name in RESERVED_WORDS:",
            "        return False",
            "",
            "    gen = generate_tokens(io.BytesIO(name.encode('utf-8')).readline)",
            "    typ, _, start, end, _ = next(gen)",
            "    if typ == tk_ENCODING:",
            "        typ, _, start, end, _ = next(gen)",
            "    return typ == tk_NAME and start == (1, 0) and end == (1, len(name))",
            "",
            "",
            "def op2func(oper):",
            "    \"\"\"Return function for operator nodes.\"\"\"",
            "    return OPERATORS[oper.__class__]",
            "",
            "",
            "class Empty:",
            "    \"\"\"Empty class.\"\"\"",
            "    def __init__(self):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        return",
            "",
            "    def __nonzero__(self):",
            "        \"\"\"Empty is TODO: docstring in magic method.\"\"\"",
            "        return False",
            "",
            "    def __repr__(self):",
            "        \"\"\"Empty is TODO: docstring in magic method.\"\"\"",
            "        return \"Empty\"",
            "",
            "ReturnedNone = Empty()",
            "",
            "class ExceptionHolder:",
            "    \"\"\"Basic exception handler.\"\"\"",
            "    def __init__(self, node, exc=None, msg='', expr=None, lineno=None):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        self.node = node",
            "        self.expr = expr",
            "        self.msg = msg",
            "        self.exc = exc",
            "        self.lineno = lineno",
            "        self.exc_info = exc_info()",
            "        if self.exc is None and self.exc_info[0] is not None:",
            "            self.exc = self.exc_info[0]",
            "        if self.msg == '' and self.exc_info[1] is not None:",
            "            self.msg = str(self.exc_info[1])",
            "",
            "    def get_error(self):",
            "        \"\"\"Retrieve error data.\"\"\"",
            "        col_offset = -1",
            "        if self.node is not None:",
            "            try:",
            "                col_offset = self.node.col_offset",
            "            except AttributeError:",
            "                pass",
            "        try:",
            "            exc_name = self.exc.__name__",
            "        except AttributeError:",
            "            exc_name = str(self.exc)",
            "        if exc_name in (None, 'None'):",
            "            exc_name = 'UnknownError'",
            "",
            "        out = [f\"   {self.expr}\"]",
            "        if col_offset > 0:",
            "            out.append(f\"    {col_offset*' '}^^^^\")",
            "        out.append(f\"{exc_name}: {self.msg}\")",
            "        return (exc_name, '\\n'.join(out))",
            "",
            "    def __repr__(self):",
            "        return f\"ExceptionHolder({self.exc}, {self.msg})\"",
            "",
            "class NameFinder(ast.NodeVisitor):",
            "    \"\"\"Find all symbol names used by a parsed node.\"\"\"",
            "",
            "    def __init__(self):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        self.names = []",
            "        ast.NodeVisitor.__init__(self)",
            "",
            "    def generic_visit(self, node):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        if node.__class__.__name__ == 'Name':",
            "            if node.id not in self.names:",
            "                self.names.append(node.id)",
            "        ast.NodeVisitor.generic_visit(self, node)",
            "",
            "",
            "def get_ast_names(astnode):",
            "    \"\"\"Return symbol Names from an AST node.\"\"\"",
            "    finder = NameFinder()",
            "    finder.generic_visit(astnode)",
            "    return finder.names",
            "",
            "",
            "def valid_varname(name):",
            "    \"is this a valid variable name\"",
            "    return name.isidentifier() and name not in RESERVED_WORDS",
            "",
            "",
            "class Group(dict):",
            "    \"\"\"",
            "    Group: a container of objects that can be accessed either as an object attributes",
            "    or dictionary  key/value.  Attribute names must follow Python naming conventions.",
            "    \"\"\"",
            "    def __init__(self, name=None, searchgroups=None, **kws):",
            "        if name is None:",
            "            name = hex(id(self))",
            "        self.__name__ = name",
            "        dict.__init__(self, **kws)",
            "        self._searchgroups = searchgroups",
            "",
            "    def __setattr__(self, name, value):",
            "        if not valid_varname(name):",
            "            raise SyntaxError(f\"invalid attribute name '{name}'\")",
            "        self[name] = value",
            "",
            "    def __getattr__(self, name, default=None):",
            "        if name in self:",
            "            return self[name]",
            "        if default is not None:",
            "            return default",
            "        raise KeyError(f\"no attribute named '{name}'\")",
            "",
            "    def __setitem__(self, name, value):",
            "        if valid_varname(name):",
            "            dict.__setitem__(self, name, value)",
            "        else: # raise SyntaxError(f\"invalid attribute name '{name}'\")",
            "            return setattr(self, name, value)",
            "",
            "    def get(self, key, default=None):",
            "        val = self.__getattr__(key, ReturnedNone)",
            "        if not isinstance(val, Empty):",
            "            return val",
            "        searchgroups = self._searchgroups",
            "        if searchgroups is not None:",
            "            for sgroup in searchgroups:",
            "                grp = self.__getattr__(sgroup, None)",
            "                if isinstance(grp, (Group, dict)):",
            "                    val = grp.__getattr__(key, ReturnedNone)",
            "                    if not isinstance(val, Empty):",
            "                        return val",
            "        return default",
            "",
            "",
            "    def __repr__(self):",
            "        keys = [a for a in self.keys() if a != '__name__']",
            "        return f\"Group('{self.__name__}', {len(keys)} symbols)\"",
            "",
            "    def _repr_html_(self):",
            "        \"\"\"HTML representation for Jupyter notebook\"\"\"",
            "        html = [f\"<table><caption>Group('{self.__name__}')</caption>\",",
            "  \"<tr><th>Attribute</th><th>DataType</th><th><b>Value</b></th></tr>\"]",
            "        for key, val in self.items():",
            "            html.append(f\"\"\"",
            "<tr><td>{key}</td><td><i>{type(val).__name__}</i></td>",
            "    <td>{repr(val):.75s}</td>",
            "</tr>\"\"\")",
            "        html.append(\"</table>\")",
            "        return '\\n'.join(html)",
            "",
            "",
            "def make_symbol_table(use_numpy=True, nested=False, top=True,  **kws):",
            "    \"\"\"Create a default symboltable, taking dict of user-defined symbols.",
            "",
            "    Arguments",
            "    ---------",
            "    numpy : bool, optional",
            "       whether to include symbols from numpy [True]",
            "    nested : bool, optional",
            "       whether to make a \"new-style\" nested table instead of a plain dict [False]",
            "    top : bool, optional",
            "       whether this is the top-level table in a nested-table [True]",
            "    kws :  optional",
            "       additional symbol name, value pairs to include in symbol table",
            "",
            "    Returns",
            "    --------",
            "    symbol_table : dict or nested Group",
            "       a symbol table that can be used in `asteval.Interpereter`",
            "",
            "    \"\"\"",
            "    if nested:",
            "        name = '_'",
            "        if top:",
            "            name = '_main'",
            "            if 'name' in kws:",
            "                name = kws.pop('name')",
            "        symtable = Group(name=name, Group=Group)",
            "    else:",
            "        symtable = {}",
            "",
            "    symtable.update(BUILTINS_TABLE)",
            "    symtable.update(LOCALFUNCS)",
            "    symtable.update(kws)",
            "    math_functions = dict(MATH_TABLE.items())",
            "    if use_numpy:",
            "        math_functions.update(NUMPY_TABLE)",
            "",
            "    if nested:",
            "        symtable['math'] = Group(name='math', **math_functions)",
            "        symtable['Group'] = Group",
            "        symtable._searchgroups = ('math',)",
            "    else:",
            "        symtable.update(math_functions)",
            "    symtable.update(**kws)",
            "    return symtable",
            "",
            "",
            "class Procedure:",
            "    \"\"\"Procedure: user-defined function for asteval.",
            "",
            "    This stores the parsed ast nodes as from the 'functiondef' ast node",
            "    for later evaluation.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, name, interp, doc=None, lineno=0,",
            "                 body=None, args=None, kwargs=None,",
            "                 vararg=None, varkws=None):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        self.__ininit__ = True",
            "        self.name = name",
            "        self.__name__ = self.name",
            "        self.__asteval__ = interp",
            "        self.__raise_exc__ = self.__asteval__.raise_exception",
            "        self.__doc__ = doc",
            "        self.__body__ = body",
            "        self.__argnames__ = args",
            "        self.__kwargs__ = kwargs",
            "        self.__vararg__ = vararg",
            "        self.__varkws__ = varkws",
            "        self.lineno = lineno",
            "        self.__ininit__ = False",
            "",
            "    def __setattr__(self, attr, val):",
            "        if not getattr(self, '__ininit__', True):",
            "            self.__raise_exc__(None, exc=TypeError,",
            "                           msg=\"procedure is read-only\")",
            "        self.__dict__[attr] = val",
            "",
            "    def __dir__(self):",
            "        return ['__getdoc__', 'argnames', 'kwargs', 'name', 'vararg', 'varkws']",
            "",
            "    def __getdoc__(self):",
            "        doc = self.__doc__",
            "        if isinstance(doc, ast.Constant):",
            "            doc = doc.value",
            "        return doc",
            "",
            "    def __repr__(self):",
            "        \"\"\"TODO: docstring in magic method.\"\"\"",
            "        sig = self.__signature__()",
            "        rep = f\"<Procedure {sig}>\"",
            "        doc = self.__getdoc__()",
            "        if doc is not None:",
            "            rep = f\"{rep}\\n {doc}\"",
            "        return rep",
            "",
            "    def __signature__(self):",
            "        \"call signature\"",
            "        sig = \"\"",
            "        if len(self.__argnames__) > 0:",
            "            sig = sig +  ', '.join(self.__argnames__)",
            "        if self.__vararg__ is not None:",
            "            sig = sig + f\"*{self.__vararg__}\"",
            "        if len(self.__kwargs__) > 0:",
            "            if len(sig) > 0:",
            "                sig = f\"{sig}, \"",
            "            _kw = [f\"{k}={v}\" for k, v in self.__kwargs__]",
            "            sig = f\"{sig}{', '.join(_kw)}\"",
            "",
            "            if self.__varkws__ is not None:",
            "                sig = f\"{sig}, **{self.__varkws__}\"",
            "        return f\"{self.name}({sig})\"",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        \"\"\"TODO: docstring in public method.\"\"\"",
            "        topsym = self.__asteval__.symtable",
            "        if self.__asteval__.config.get('nested_symtable', False):",
            "            sargs = {'_main': topsym}",
            "            sgroups = topsym.get('_searchgroups', None)",
            "            if sgroups is not None:",
            "                for sxname in sgroups:",
            "                    sargs[sxname] = topsym.get(sxname)",
            "",
            "",
            "            symlocals = Group(name=f'symtable_{self.name}_', **sargs)",
            "            symlocals._searchgroups = list(sargs.keys())",
            "        else:",
            "            symlocals = {}",
            "",
            "        args = list(args)",
            "        nargs = len(args)",
            "        nkws = len(kwargs)",
            "        nargs_expected = len(self.__argnames__)",
            "",
            "        # check for too few arguments, but the correct keyword given",
            "        if (nargs < nargs_expected) and nkws > 0:",
            "            for name in self.__argnames__[nargs:]:",
            "                if name in kwargs:",
            "                    args.append(kwargs.pop(name))",
            "            nargs = len(args)",
            "            nargs_expected = len(self.__argnames__)",
            "            nkws = len(kwargs)",
            "        if nargs < nargs_expected:",
            "            msg = f\"{self.name}() takes at least\"",
            "            msg = f\"{msg} {nargs_expected} arguments, got {nargs}\"",
            "            self.__raise_exc__(None, exc=TypeError, msg=msg)",
            "        # check for multiple values for named argument",
            "        if len(self.__argnames__) > 0 and kwargs is not None:",
            "            msg = \"multiple values for keyword argument\"",
            "            for targ in self.__argnames__:",
            "                if targ in kwargs:",
            "                    msg = f\"{msg} '{targ}' in Procedure {self.name}\"",
            "                    self.__raise_exc__(None, exc=TypeError, msg=msg, lineno=self.lineno)",
            "",
            "        # check more args given than expected, varargs not given",
            "        if nargs != nargs_expected:",
            "            msg = None",
            "            if nargs < nargs_expected:",
            "                msg = f\"not enough arguments for Procedure {self.name}()\"",
            "                msg = f\"{msg} (expected {nargs_expected}, got {nargs}\"",
            "                self.__raise_exc__(None, exc=TypeError, msg=msg)",
            "",
            "        if nargs > nargs_expected and self.__vararg__ is None:",
            "            if nargs - nargs_expected > len(self.__kwargs__):",
            "                msg = f\"too many arguments for {self.name}() expected at most\"",
            "                msg = f\"{msg} {len(self.__kwargs__)+nargs_expected}, got {nargs}\"",
            "                self.__raise_exc__(None, exc=TypeError, msg=msg)",
            "",
            "            for i, xarg in enumerate(args[nargs_expected:]):",
            "                kw_name = self.__kwargs__[i][0]",
            "                if kw_name not in kwargs:",
            "                    kwargs[kw_name] = xarg",
            "",
            "        for argname in self.__argnames__:",
            "            symlocals[argname] = args.pop(0)",
            "",
            "        try:",
            "            if self.__vararg__ is not None:",
            "                symlocals[self.__vararg__] = tuple(args)",
            "",
            "            for key, val in self.__kwargs__:",
            "                if key in kwargs:",
            "                    val = kwargs.pop(key)",
            "                symlocals[key] = val",
            "",
            "            if self.__varkws__ is not None:",
            "                symlocals[self.__varkws__] = kwargs",
            "",
            "            elif len(kwargs) > 0:",
            "                msg = f\"extra keyword arguments for Procedure {self.name}: \"",
            "                msg = msg + ','.join(list(kwargs.keys()))",
            "                self.__raise_exc__(None, msg=msg, exc=TypeError,",
            "                               lineno=self.lineno)",
            "",
            "        except (ValueError, LookupError, TypeError,",
            "                NameError, AttributeError):",
            "            msg = f\"incorrect arguments for Procedure {self.name}\"",
            "            self.__raise_exc__(None, msg=msg, lineno=self.lineno)",
            "",
            "        if self.__asteval__.config.get('nested_symtable', False):",
            "            save_symtable = self.__asteval__.symtable",
            "            self.__asteval__.symtable = symlocals",
            "        else:",
            "            save_symtable = self.__asteval__.symtable.copy()",
            "            self.__asteval__.symtable.update(symlocals)",
            "",
            "        self.__asteval__.retval = None",
            "        self.__asteval__._calldepth += 1",
            "        retval = None",
            "",
            "        # evaluate script of function",
            "        for node in self.__body__:",
            "            self.__asteval__.run(node, expr='<>', lineno=self.lineno)",
            "            if len(self.__asteval__.error) > 0:",
            "                break",
            "            if self.__asteval__.retval is not None:",
            "                retval = self.__asteval__.retval",
            "                self.__asteval__.retval = None",
            "                if retval is ReturnedNone:",
            "                    retval = None",
            "                break",
            "",
            "        self.__asteval__.symtable = save_symtable",
            "        self.__asteval__._calldepth -= 1",
            "        symlocals = None",
            "        return retval"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "62": []
        },
        "addLocation": [
            "asteval.astutils"
        ]
    }
}