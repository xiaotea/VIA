{
    "django/core/files/storage/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         if not hasattr(content, \"chunks\"):"
            },
            "1": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "             content = File(content, name)"
            },
            "2": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        # Ensure that the name is valid, before and after having the storage"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        # system potentially modifying the name. This duplicates the check made"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        # inside `get_available_name` but it's necessary for those cases where"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        # `get_available_name` is overriden and validation is lost."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        validate_file_name(name, allow_relative_path=True)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        # Potentially find a different name depending on storage constraints."
            },
            "10": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         name = self.get_available_name(name, max_length=max_length)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        # Validate the (potentially) new name."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        validate_file_name(name, allow_relative_path=True)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        # The save operation should return the actual name of the file saved."
            },
            "15": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         name = self._save(name, content)"
            },
            "16": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         # Ensure that the name returned from the storage system is still valid."
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         validate_file_name(name, allow_relative_path=True)"
            }
        },
        "frontPatchFile": [
            "import os",
            "import pathlib",
            "",
            "from django.core.exceptions import SuspiciousFileOperation",
            "from django.core.files import File",
            "from django.core.files.utils import validate_file_name",
            "from django.utils.crypto import get_random_string",
            "from django.utils.text import get_valid_filename",
            "",
            "",
            "class Storage:",
            "    \"\"\"",
            "    A base storage class, providing some default behaviors that all other",
            "    storage systems can inherit or override, as necessary.",
            "    \"\"\"",
            "",
            "    # The following methods represent a public interface to private methods.",
            "    # These shouldn't be overridden by subclasses unless absolutely necessary.",
            "",
            "    def open(self, name, mode=\"rb\"):",
            "        \"\"\"Retrieve the specified file from storage.\"\"\"",
            "        return self._open(name, mode)",
            "",
            "    def save(self, name, content, max_length=None):",
            "        \"\"\"",
            "        Save new content to the file specified by name. The content should be",
            "        a proper File object or any Python file-like object, ready to be read",
            "        from the beginning.",
            "        \"\"\"",
            "        # Get the proper name for the file, as it will actually be saved.",
            "        if name is None:",
            "            name = content.name",
            "",
            "        if not hasattr(content, \"chunks\"):",
            "            content = File(content, name)",
            "",
            "        name = self.get_available_name(name, max_length=max_length)",
            "        name = self._save(name, content)",
            "        # Ensure that the name returned from the storage system is still valid.",
            "        validate_file_name(name, allow_relative_path=True)",
            "        return name",
            "",
            "    # These methods are part of the public API, with default implementations.",
            "",
            "    def get_valid_name(self, name):",
            "        \"\"\"",
            "        Return a filename, based on the provided filename, that's suitable for",
            "        use in the target storage system.",
            "        \"\"\"",
            "        return get_valid_filename(name)",
            "",
            "    def get_alternative_name(self, file_root, file_ext):",
            "        \"\"\"",
            "        Return an alternative filename, by adding an underscore and a random 7",
            "        character alphanumeric string (before the file extension, if one",
            "        exists) to the filename.",
            "        \"\"\"",
            "        return \"%s_%s%s\" % (file_root, get_random_string(7), file_ext)",
            "",
            "    def get_available_name(self, name, max_length=None):",
            "        \"\"\"",
            "        Return a filename that's free on the target storage system and",
            "        available for new content to be written to.",
            "        \"\"\"",
            "        name = str(name).replace(\"\\\\\", \"/\")",
            "        dir_name, file_name = os.path.split(name)",
            "        if \"..\" in pathlib.PurePath(dir_name).parts:",
            "            raise SuspiciousFileOperation(",
            "                \"Detected path traversal attempt in '%s'\" % dir_name",
            "            )",
            "        validate_file_name(file_name)",
            "        file_root, file_ext = os.path.splitext(file_name)",
            "        # If the filename already exists, generate an alternative filename",
            "        # until it doesn't exist.",
            "        # Truncate original name if required, so the new filename does not",
            "        # exceed the max_length.",
            "        while self.exists(name) or (max_length and len(name) > max_length):",
            "            # file_ext includes the dot.",
            "            name = os.path.join(",
            "                dir_name, self.get_alternative_name(file_root, file_ext)",
            "            )",
            "            if max_length is None:",
            "                continue",
            "            # Truncate file_root if max_length exceeded.",
            "            truncation = len(name) - max_length",
            "            if truncation > 0:",
            "                file_root = file_root[:-truncation]",
            "                # Entire file_root was truncated in attempt to find an",
            "                # available filename.",
            "                if not file_root:",
            "                    raise SuspiciousFileOperation(",
            "                        'Storage can not find an available filename for \"%s\". '",
            "                        \"Please make sure that the corresponding file field \"",
            "                        'allows sufficient \"max_length\".' % name",
            "                    )",
            "                name = os.path.join(",
            "                    dir_name, self.get_alternative_name(file_root, file_ext)",
            "                )",
            "        return name",
            "",
            "    def generate_filename(self, filename):",
            "        \"\"\"",
            "        Validate the filename by calling get_valid_name() and return a filename",
            "        to be passed to the save() method.",
            "        \"\"\"",
            "        filename = str(filename).replace(\"\\\\\", \"/\")",
            "        # `filename` may include a path as returned by FileField.upload_to.",
            "        dirname, filename = os.path.split(filename)",
            "        if \"..\" in pathlib.PurePath(dirname).parts:",
            "            raise SuspiciousFileOperation(",
            "                \"Detected path traversal attempt in '%s'\" % dirname",
            "            )",
            "        return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))",
            "",
            "    def path(self, name):",
            "        \"\"\"",
            "        Return a local filesystem path where the file can be retrieved using",
            "        Python's built-in open() function. Storage systems that can't be",
            "        accessed using open() should *not* implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError(\"This backend doesn't support absolute paths.\")",
            "",
            "    # The following methods form the public API for storage systems, but with",
            "    # no default implementations. Subclasses must implement *all* of these.",
            "",
            "    def delete(self, name):",
            "        \"\"\"",
            "        Delete the specified file from the storage system.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a delete() method\"",
            "        )",
            "",
            "    def exists(self, name):",
            "        \"\"\"",
            "        Return True if a file referenced by the given name already exists in the",
            "        storage system, or False if the name is available for a new file.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide an exists() method\"",
            "        )",
            "",
            "    def listdir(self, path):",
            "        \"\"\"",
            "        List the contents of the specified path. Return a 2-tuple of lists:",
            "        the first item being directories, the second item being files.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a listdir() method\"",
            "        )",
            "",
            "    def size(self, name):",
            "        \"\"\"",
            "        Return the total size, in bytes, of the file specified by name.",
            "        \"\"\"",
            "        raise NotImplementedError(\"subclasses of Storage must provide a size() method\")",
            "",
            "    def url(self, name):",
            "        \"\"\"",
            "        Return an absolute URL where the file's contents can be accessed",
            "        directly by a web browser.",
            "        \"\"\"",
            "        raise NotImplementedError(\"subclasses of Storage must provide a url() method\")",
            "",
            "    def get_accessed_time(self, name):",
            "        \"\"\"",
            "        Return the last accessed time (as a datetime) of the file specified by",
            "        name. The datetime will be timezone-aware if USE_TZ=True.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a get_accessed_time() method\"",
            "        )",
            "",
            "    def get_created_time(self, name):",
            "        \"\"\"",
            "        Return the creation time (as a datetime) of the file specified by name.",
            "        The datetime will be timezone-aware if USE_TZ=True.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a get_created_time() method\"",
            "        )",
            "",
            "    def get_modified_time(self, name):",
            "        \"\"\"",
            "        Return the last modified time (as a datetime) of the file specified by",
            "        name. The datetime will be timezone-aware if USE_TZ=True.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a get_modified_time() method\"",
            "        )"
        ],
        "afterPatchFile": [
            "import os",
            "import pathlib",
            "",
            "from django.core.exceptions import SuspiciousFileOperation",
            "from django.core.files import File",
            "from django.core.files.utils import validate_file_name",
            "from django.utils.crypto import get_random_string",
            "from django.utils.text import get_valid_filename",
            "",
            "",
            "class Storage:",
            "    \"\"\"",
            "    A base storage class, providing some default behaviors that all other",
            "    storage systems can inherit or override, as necessary.",
            "    \"\"\"",
            "",
            "    # The following methods represent a public interface to private methods.",
            "    # These shouldn't be overridden by subclasses unless absolutely necessary.",
            "",
            "    def open(self, name, mode=\"rb\"):",
            "        \"\"\"Retrieve the specified file from storage.\"\"\"",
            "        return self._open(name, mode)",
            "",
            "    def save(self, name, content, max_length=None):",
            "        \"\"\"",
            "        Save new content to the file specified by name. The content should be",
            "        a proper File object or any Python file-like object, ready to be read",
            "        from the beginning.",
            "        \"\"\"",
            "        # Get the proper name for the file, as it will actually be saved.",
            "        if name is None:",
            "            name = content.name",
            "",
            "        if not hasattr(content, \"chunks\"):",
            "            content = File(content, name)",
            "",
            "        # Ensure that the name is valid, before and after having the storage",
            "        # system potentially modifying the name. This duplicates the check made",
            "        # inside `get_available_name` but it's necessary for those cases where",
            "        # `get_available_name` is overriden and validation is lost.",
            "        validate_file_name(name, allow_relative_path=True)",
            "",
            "        # Potentially find a different name depending on storage constraints.",
            "        name = self.get_available_name(name, max_length=max_length)",
            "        # Validate the (potentially) new name.",
            "        validate_file_name(name, allow_relative_path=True)",
            "",
            "        # The save operation should return the actual name of the file saved.",
            "        name = self._save(name, content)",
            "        # Ensure that the name returned from the storage system is still valid.",
            "        validate_file_name(name, allow_relative_path=True)",
            "        return name",
            "",
            "    # These methods are part of the public API, with default implementations.",
            "",
            "    def get_valid_name(self, name):",
            "        \"\"\"",
            "        Return a filename, based on the provided filename, that's suitable for",
            "        use in the target storage system.",
            "        \"\"\"",
            "        return get_valid_filename(name)",
            "",
            "    def get_alternative_name(self, file_root, file_ext):",
            "        \"\"\"",
            "        Return an alternative filename, by adding an underscore and a random 7",
            "        character alphanumeric string (before the file extension, if one",
            "        exists) to the filename.",
            "        \"\"\"",
            "        return \"%s_%s%s\" % (file_root, get_random_string(7), file_ext)",
            "",
            "    def get_available_name(self, name, max_length=None):",
            "        \"\"\"",
            "        Return a filename that's free on the target storage system and",
            "        available for new content to be written to.",
            "        \"\"\"",
            "        name = str(name).replace(\"\\\\\", \"/\")",
            "        dir_name, file_name = os.path.split(name)",
            "        if \"..\" in pathlib.PurePath(dir_name).parts:",
            "            raise SuspiciousFileOperation(",
            "                \"Detected path traversal attempt in '%s'\" % dir_name",
            "            )",
            "        validate_file_name(file_name)",
            "        file_root, file_ext = os.path.splitext(file_name)",
            "        # If the filename already exists, generate an alternative filename",
            "        # until it doesn't exist.",
            "        # Truncate original name if required, so the new filename does not",
            "        # exceed the max_length.",
            "        while self.exists(name) or (max_length and len(name) > max_length):",
            "            # file_ext includes the dot.",
            "            name = os.path.join(",
            "                dir_name, self.get_alternative_name(file_root, file_ext)",
            "            )",
            "            if max_length is None:",
            "                continue",
            "            # Truncate file_root if max_length exceeded.",
            "            truncation = len(name) - max_length",
            "            if truncation > 0:",
            "                file_root = file_root[:-truncation]",
            "                # Entire file_root was truncated in attempt to find an",
            "                # available filename.",
            "                if not file_root:",
            "                    raise SuspiciousFileOperation(",
            "                        'Storage can not find an available filename for \"%s\". '",
            "                        \"Please make sure that the corresponding file field \"",
            "                        'allows sufficient \"max_length\".' % name",
            "                    )",
            "                name = os.path.join(",
            "                    dir_name, self.get_alternative_name(file_root, file_ext)",
            "                )",
            "        return name",
            "",
            "    def generate_filename(self, filename):",
            "        \"\"\"",
            "        Validate the filename by calling get_valid_name() and return a filename",
            "        to be passed to the save() method.",
            "        \"\"\"",
            "        filename = str(filename).replace(\"\\\\\", \"/\")",
            "        # `filename` may include a path as returned by FileField.upload_to.",
            "        dirname, filename = os.path.split(filename)",
            "        if \"..\" in pathlib.PurePath(dirname).parts:",
            "            raise SuspiciousFileOperation(",
            "                \"Detected path traversal attempt in '%s'\" % dirname",
            "            )",
            "        return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))",
            "",
            "    def path(self, name):",
            "        \"\"\"",
            "        Return a local filesystem path where the file can be retrieved using",
            "        Python's built-in open() function. Storage systems that can't be",
            "        accessed using open() should *not* implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError(\"This backend doesn't support absolute paths.\")",
            "",
            "    # The following methods form the public API for storage systems, but with",
            "    # no default implementations. Subclasses must implement *all* of these.",
            "",
            "    def delete(self, name):",
            "        \"\"\"",
            "        Delete the specified file from the storage system.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a delete() method\"",
            "        )",
            "",
            "    def exists(self, name):",
            "        \"\"\"",
            "        Return True if a file referenced by the given name already exists in the",
            "        storage system, or False if the name is available for a new file.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide an exists() method\"",
            "        )",
            "",
            "    def listdir(self, path):",
            "        \"\"\"",
            "        List the contents of the specified path. Return a 2-tuple of lists:",
            "        the first item being directories, the second item being files.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a listdir() method\"",
            "        )",
            "",
            "    def size(self, name):",
            "        \"\"\"",
            "        Return the total size, in bytes, of the file specified by name.",
            "        \"\"\"",
            "        raise NotImplementedError(\"subclasses of Storage must provide a size() method\")",
            "",
            "    def url(self, name):",
            "        \"\"\"",
            "        Return an absolute URL where the file's contents can be accessed",
            "        directly by a web browser.",
            "        \"\"\"",
            "        raise NotImplementedError(\"subclasses of Storage must provide a url() method\")",
            "",
            "    def get_accessed_time(self, name):",
            "        \"\"\"",
            "        Return the last accessed time (as a datetime) of the file specified by",
            "        name. The datetime will be timezone-aware if USE_TZ=True.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a get_accessed_time() method\"",
            "        )",
            "",
            "    def get_created_time(self, name):",
            "        \"\"\"",
            "        Return the creation time (as a datetime) of the file specified by name.",
            "        The datetime will be timezone-aware if USE_TZ=True.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a get_created_time() method\"",
            "        )",
            "",
            "    def get_modified_time(self, name):",
            "        \"\"\"",
            "        Return the last modified time (as a datetime) of the file specified by",
            "        name. The datetime will be timezone-aware if USE_TZ=True.",
            "        \"\"\"",
            "        raise NotImplementedError(",
            "            \"subclasses of Storage must provide a get_modified_time() method\"",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "web.pgadmin.tools.import_export.create_import_export_job"
        ]
    },
    "django/core/files/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "         raise SuspiciousFileOperation(\"Could not derive file name from '%s'\" % name)"
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     if allow_relative_path:"
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Use PurePosixPath() because this branch is checked only in"
            },
            "4": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # FileField.generate_filename() where all file paths are expected to be"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Unix style (with forward slashes)."
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path = pathlib.PurePosixPath(name)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+        # Ensure that name can be treated as a pure posix path, i.e. Unix"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+        # style (with forward slashes)."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+        path = pathlib.PurePosixPath(str(name).replace(\"\\\\\", \"/\"))"
            },
            "10": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "         if path.is_absolute() or \"..\" in path.parts:"
            },
            "11": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "             raise SuspiciousFileOperation("
            },
            "12": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "                 \"Detected path traversal attempt in '%s'\" % name"
            }
        },
        "frontPatchFile": [
            "import os",
            "import pathlib",
            "",
            "from django.core.exceptions import SuspiciousFileOperation",
            "",
            "",
            "def validate_file_name(name, allow_relative_path=False):",
            "    # Remove potentially dangerous names",
            "    if os.path.basename(name) in {\"\", \".\", \"..\"}:",
            "        raise SuspiciousFileOperation(\"Could not derive file name from '%s'\" % name)",
            "",
            "    if allow_relative_path:",
            "        # Use PurePosixPath() because this branch is checked only in",
            "        # FileField.generate_filename() where all file paths are expected to be",
            "        # Unix style (with forward slashes).",
            "        path = pathlib.PurePosixPath(name)",
            "        if path.is_absolute() or \"..\" in path.parts:",
            "            raise SuspiciousFileOperation(",
            "                \"Detected path traversal attempt in '%s'\" % name",
            "            )",
            "    elif name != os.path.basename(name):",
            "        raise SuspiciousFileOperation(\"File name '%s' includes path elements\" % name)",
            "",
            "    return name",
            "",
            "",
            "class FileProxyMixin:",
            "    \"\"\"",
            "    A mixin class used to forward file methods to an underlaying file",
            "    object.  The internal file object has to be called \"file\"::",
            "",
            "        class FileProxy(FileProxyMixin):",
            "            def __init__(self, file):",
            "                self.file = file",
            "    \"\"\"",
            "",
            "    encoding = property(lambda self: self.file.encoding)",
            "    fileno = property(lambda self: self.file.fileno)",
            "    flush = property(lambda self: self.file.flush)",
            "    isatty = property(lambda self: self.file.isatty)",
            "    newlines = property(lambda self: self.file.newlines)",
            "    read = property(lambda self: self.file.read)",
            "    readinto = property(lambda self: self.file.readinto)",
            "    readline = property(lambda self: self.file.readline)",
            "    readlines = property(lambda self: self.file.readlines)",
            "    seek = property(lambda self: self.file.seek)",
            "    tell = property(lambda self: self.file.tell)",
            "    truncate = property(lambda self: self.file.truncate)",
            "    write = property(lambda self: self.file.write)",
            "    writelines = property(lambda self: self.file.writelines)",
            "",
            "    @property",
            "    def closed(self):",
            "        return not self.file or self.file.closed",
            "",
            "    def readable(self):",
            "        if self.closed:",
            "            return False",
            "        if hasattr(self.file, \"readable\"):",
            "            return self.file.readable()",
            "        return True",
            "",
            "    def writable(self):",
            "        if self.closed:",
            "            return False",
            "        if hasattr(self.file, \"writable\"):",
            "            return self.file.writable()",
            "        return \"w\" in getattr(self.file, \"mode\", \"\")",
            "",
            "    def seekable(self):",
            "        if self.closed:",
            "            return False",
            "        if hasattr(self.file, \"seekable\"):",
            "            return self.file.seekable()",
            "        return True",
            "",
            "    def __iter__(self):",
            "        return iter(self.file)"
        ],
        "afterPatchFile": [
            "import os",
            "import pathlib",
            "",
            "from django.core.exceptions import SuspiciousFileOperation",
            "",
            "",
            "def validate_file_name(name, allow_relative_path=False):",
            "    # Remove potentially dangerous names",
            "    if os.path.basename(name) in {\"\", \".\", \"..\"}:",
            "        raise SuspiciousFileOperation(\"Could not derive file name from '%s'\" % name)",
            "",
            "    if allow_relative_path:",
            "        # Ensure that name can be treated as a pure posix path, i.e. Unix",
            "        # style (with forward slashes).",
            "        path = pathlib.PurePosixPath(str(name).replace(\"\\\\\", \"/\"))",
            "        if path.is_absolute() or \"..\" in path.parts:",
            "            raise SuspiciousFileOperation(",
            "                \"Detected path traversal attempt in '%s'\" % name",
            "            )",
            "    elif name != os.path.basename(name):",
            "        raise SuspiciousFileOperation(\"File name '%s' includes path elements\" % name)",
            "",
            "    return name",
            "",
            "",
            "class FileProxyMixin:",
            "    \"\"\"",
            "    A mixin class used to forward file methods to an underlaying file",
            "    object.  The internal file object has to be called \"file\"::",
            "",
            "        class FileProxy(FileProxyMixin):",
            "            def __init__(self, file):",
            "                self.file = file",
            "    \"\"\"",
            "",
            "    encoding = property(lambda self: self.file.encoding)",
            "    fileno = property(lambda self: self.file.fileno)",
            "    flush = property(lambda self: self.file.flush)",
            "    isatty = property(lambda self: self.file.isatty)",
            "    newlines = property(lambda self: self.file.newlines)",
            "    read = property(lambda self: self.file.read)",
            "    readinto = property(lambda self: self.file.readinto)",
            "    readline = property(lambda self: self.file.readline)",
            "    readlines = property(lambda self: self.file.readlines)",
            "    seek = property(lambda self: self.file.seek)",
            "    tell = property(lambda self: self.file.tell)",
            "    truncate = property(lambda self: self.file.truncate)",
            "    write = property(lambda self: self.file.write)",
            "    writelines = property(lambda self: self.file.writelines)",
            "",
            "    @property",
            "    def closed(self):",
            "        return not self.file or self.file.closed",
            "",
            "    def readable(self):",
            "        if self.closed:",
            "            return False",
            "        if hasattr(self.file, \"readable\"):",
            "            return self.file.readable()",
            "        return True",
            "",
            "    def writable(self):",
            "        if self.closed:",
            "            return False",
            "        if hasattr(self.file, \"writable\"):",
            "            return self.file.writable()",
            "        return \"w\" in getattr(self.file, \"mode\", \"\")",
            "",
            "    def seekable(self):",
            "        if self.closed:",
            "            return False",
            "        if hasattr(self.file, \"seekable\"):",
            "            return self.file.seekable()",
            "        return True",
            "",
            "    def __iter__(self):",
            "        return iter(self.file)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [
                "validate_file_name"
            ],
            "14": [
                "validate_file_name"
            ],
            "15": [
                "validate_file_name"
            ],
            "16": [
                "validate_file_name"
            ]
        },
        "addLocation": []
    }
}