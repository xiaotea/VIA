{
    "web/pgadmin/tools/backup/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from flask_security import login_required, current_user"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\"
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fs_short_path, document_dir, does_utility_exist, get_server"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from pgadmin.utils.ajax import make_json_response, bad_request"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    fs_short_path, document_dir, does_utility_exist, get_server, \\"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    filename_with_file_manager_path"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from pgadmin.utils.ajax import make_json_response, bad_request, unauthorized"
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from config import PG_DEFAULT_DRIVER"
            },
            "10": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from pgadmin.model import Server, SharedServer"
            },
            "11": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     )"
            },
            "12": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 192,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def filename_with_file_manager_path(_file, create_file=True):"
            },
            "15": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "16": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Args:"
            },
            "17": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file: File name returned from client file manager"
            },
            "18": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        create_file: Set flag to False when file creation doesn't required"
            },
            "19": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Returns:"
            },
            "20": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Filename to use for backup with full path taken from preference"
            },
            "21": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "22": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Set file manager directory from preference"
            },
            "23": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    storage_dir = get_storage_directory()"
            },
            "24": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if storage_dir:"
            },
            "25": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))"
            },
            "26": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif not os.path.isabs(_file):"
            },
            "27": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _file = os.path.join(document_dir(), _file)"
            },
            "28": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "29": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def short_filepath():"
            },
            "30": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        short_path = fs_short_path(_file)"
            },
            "31": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # fs_short_path() function may return empty path on Windows"
            },
            "32": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # if directory doesn't exists. In that case we strip the last path"
            },
            "33": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # component and get the short path."
            },
            "34": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if os.name == 'nt' and short_path == '':"
            },
            "35": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            base_name = os.path.basename(_file)"
            },
            "36": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dir_name = os.path.dirname(_file)"
            },
            "37": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            short_path = fs_short_path(dir_name) + '\\\\' + base_name"
            },
            "38": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return short_path"
            },
            "39": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "40": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if create_file:"
            },
            "41": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Touch the file to get the short path of the file on windows."
            },
            "42": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with open(_file, 'a'):"
            },
            "43": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return short_filepath()"
            },
            "44": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "45": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return short_filepath()"
            },
            "46": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "47": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "48": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 193,
                "PatchRowcode": " def _get_args_params_values(data, conn, backup_obj_type, backup_file, server,"
            },
            "49": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "                             manager):"
            },
            "50": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "     \"\"\""
            },
            "51": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "     try:"
            },
            "52": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         backup_file = filename_with_file_manager_path("
            },
            "53": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "             data['file'], (data.get('format', '') != 'directory'))"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+    except PermissionError as e:"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+        return unauthorized(errormsg=str(e))"
            },
            "56": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     except Exception as e:"
            },
            "57": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "         return bad_request(errormsg=str(e))"
            },
            "58": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 341,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "\"\"\"Implements Backup Utility\"\"\"",
            "",
            "import simplejson as json",
            "import os",
            "import functools",
            "import operator",
            "",
            "from flask import render_template, request, current_app, \\",
            "    url_for, Response",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc",
            "from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\",
            "    fs_short_path, document_dir, does_utility_exist, get_server",
            "from pgadmin.utils.ajax import make_json_response, bad_request",
            "",
            "from config import PG_DEFAULT_DRIVER",
            "from pgadmin.model import Server, SharedServer",
            "from pgadmin.misc.bgprocess import escape_dquotes_process_arg",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "",
            "# set template path for sql scripts",
            "MODULE_NAME = 'backup'",
            "server_info = {}",
            "",
            "",
            "class BackupModule(PgAdminModule):",
            "    \"\"\"",
            "    class BackupModule():",
            "",
            "        It is a utility which inherits PgAdminModule",
            "        class and define methods to load its own",
            "        javascript file.",
            "    \"\"\"",
            "",
            "    LABEL = _('Backup')",
            "",
            "    def show_system_objects(self):",
            "        \"\"\"",
            "        return system preference objects",
            "        \"\"\"",
            "        return self.pref_show_system_objects",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['backup.create_server_job', 'backup.create_object_job',",
            "                'backup.utility_exists']",
            "",
            "",
            "# Create blueprint for BackupModule class",
            "blueprint = BackupModule(",
            "    MODULE_NAME, __name__, static_url_path=''",
            ")",
            "",
            "",
            "class BACKUP():",
            "    \"\"\"",
            "    Constants defined for Backup utilities",
            "    \"\"\"",
            "    GLOBALS = 1",
            "    SERVER = 2",
            "    OBJECT = 3",
            "",
            "",
            "class BackupMessage(IProcessDesc):",
            "    \"\"\"",
            "    BackupMessage(IProcessDesc)",
            "",
            "    Defines the message shown for the backup operation.",
            "    \"\"\"",
            "",
            "    def __init__(self, _type, _sid, _bfile, *_args, **_kwargs):",
            "        self.backup_type = _type",
            "        self.sid = _sid",
            "        self.bfile = _bfile",
            "        self.database = _kwargs['database'] if 'database' in _kwargs else None",
            "        self.cmd = ''",
            "        self.args_str = \"{0} ({1}:{2})\"",
            "",
            "        def cmd_arg(x):",
            "            if x:",
            "                x = x.replace('\\\\', '\\\\\\\\')",
            "                x = x.replace('\"', '\\\\\"')",
            "                x = x.replace('\"\"', '\\\\\"')",
            "                return ' \"' + x + '\"'",
            "            return ''",
            "",
            "        for arg in _args:",
            "            if arg and len(arg) >= 2 and arg[:2] == '--':",
            "                self.cmd += ' ' + arg",
            "            else:",
            "                self.cmd += cmd_arg(arg)",
            "",
            "    def get_server_name(self):",
            "        s = get_server(self.sid)",
            "",
            "        if s is None:",
            "            return _(\"Not available\")",
            "",
            "        from pgadmin.utils.driver import get_driver",
            "        driver = get_driver(PG_DEFAULT_DRIVER)",
            "        manager = driver.connection_manager(self.sid)",
            "",
            "        host = manager.local_bind_host if manager.use_ssh_tunnel else s.host",
            "        port = manager.local_bind_port if manager.use_ssh_tunnel else s.port",
            "",
            "        return \"{0} ({1}:{2})\".format(s.name, host, port)",
            "",
            "    @property",
            "    def type_desc(self):",
            "        if self.backup_type == BACKUP.OBJECT:",
            "            return _(\"Backing up an object on the server\")",
            "        if self.backup_type == BACKUP.GLOBALS:",
            "            return _(\"Backing up the global objects\")",
            "        elif self.backup_type == BACKUP.SERVER:",
            "            return _(\"Backing up the server\")",
            "        else:",
            "            # It should never reach here.",
            "            return _(\"Unknown Backup\")",
            "",
            "    @property",
            "    def message(self):",
            "        server_name = self.get_server_name()",
            "",
            "        if self.backup_type == BACKUP.OBJECT:",
            "            return _(",
            "                \"Backing up an object on the server '{0}' \"",
            "                \"from database '{1}'\"",
            "            ).format(server_name, self.database)",
            "        if self.backup_type == BACKUP.GLOBALS:",
            "            return _(\"Backing up the global objects on \"",
            "                     \"the server '{0}'\").format(",
            "                server_name",
            "            )",
            "        elif self.backup_type == BACKUP.SERVER:",
            "            return _(\"Backing up the server '{0}'\").format(",
            "                server_name",
            "            )",
            "        else:",
            "            # It should never reach here.",
            "            return \"Unknown Backup\"",
            "",
            "    def details(self, cmd, args):",
            "        server_name = self.get_server_name()",
            "        backup_type = _(\"Backup\")",
            "        if self.backup_type == BACKUP.OBJECT:",
            "            backup_type = _(\"Backup Object\")",
            "        elif self.backup_type == BACKUP.GLOBALS:",
            "            backup_type = _(\"Backup Globals\")",
            "        elif self.backup_type == BACKUP.SERVER:",
            "            backup_type = _(\"Backup Server\")",
            "",
            "        return {",
            "            \"message\": self.message,",
            "            \"cmd\": cmd + self.cmd,",
            "            \"server\": server_name,",
            "            \"object\": self.database,",
            "            \"type\": backup_type,",
            "        }",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/backup.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render own javascript\"\"\"",
            "    return Response(",
            "        response=render_template(",
            "            \"backup/js/backup.js\", _=_",
            "        ),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "def filename_with_file_manager_path(_file, create_file=True):",
            "    \"\"\"",
            "    Args:",
            "        file: File name returned from client file manager",
            "        create_file: Set flag to False when file creation doesn't required",
            "    Returns:",
            "        Filename to use for backup with full path taken from preference",
            "    \"\"\"",
            "    # Set file manager directory from preference",
            "    storage_dir = get_storage_directory()",
            "    if storage_dir:",
            "        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))",
            "    elif not os.path.isabs(_file):",
            "        _file = os.path.join(document_dir(), _file)",
            "",
            "    def short_filepath():",
            "        short_path = fs_short_path(_file)",
            "        # fs_short_path() function may return empty path on Windows",
            "        # if directory doesn't exists. In that case we strip the last path",
            "        # component and get the short path.",
            "        if os.name == 'nt' and short_path == '':",
            "            base_name = os.path.basename(_file)",
            "            dir_name = os.path.dirname(_file)",
            "            short_path = fs_short_path(dir_name) + '\\\\' + base_name",
            "        return short_path",
            "",
            "    if create_file:",
            "        # Touch the file to get the short path of the file on windows.",
            "        with open(_file, 'a'):",
            "            return short_filepath()",
            "",
            "    return short_filepath()",
            "",
            "",
            "def _get_args_params_values(data, conn, backup_obj_type, backup_file, server,",
            "                            manager):",
            "    \"\"\"",
            "    Used internally by create_backup_objects_job. This function will create",
            "    the required args and params for the job.",
            "    :param data: input data",
            "    :param conn: connection obj",
            "    :param backup_obj_type: object type",
            "    :param backup_file: file name",
            "    :param server: server obj",
            "    :param manager: connection manager",
            "    :return: args array",
            "    \"\"\"",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "",
            "    host, port = (manager.local_bind_host, str(manager.local_bind_port)) \\",
            "        if manager.use_ssh_tunnel else (server.host, str(server.port))",
            "    args = [",
            "        '--file',",
            "        backup_file,",
            "        '--host',",
            "        host,",
            "        '--port',",
            "        port,",
            "        '--username',",
            "        server.username,",
            "        '--no-password'",
            "    ]",
            "",
            "    def set_param(key, param, assertion=True):",
            "        if not assertion:",
            "            return",
            "        if data.get(key, None):",
            "            args.append(param)",
            "",
            "    def set_value(key, param, default_value=None, assertion=True):",
            "        if not assertion:",
            "            return",
            "        val = data.get(key, default_value)",
            "        if val:",
            "            args.append(param)",
            "            args.append(val)",
            "",
            "    if backup_obj_type != 'objects':",
            "        args.append('--database')",
            "        args.append(server.maintenance_db)",
            "",
            "    if backup_obj_type == 'globals':",
            "        args.append('--globals-only')",
            "",
            "    set_param('verbose', '--verbose')",
            "    set_param('dqoute', '--quote-all-identifiers')",
            "    set_value('role', '--role')",
            "",
            "    if backup_obj_type == 'objects' and data.get('format', None):",
            "        args.extend(['--format={0}'.format({",
            "            'custom': 'c',",
            "            'tar': 't',",
            "            'plain': 'p',",
            "            'directory': 'd'",
            "        }[data['format']])])",
            "",
            "        set_param('blobs', '--blobs', data['format'] in ['custom', 'tar'])",
            "        set_value('ratio', '--compress', None,",
            "                  ['custom', 'plain', 'directory'])",
            "",
            "    set_param('only_data', '--data-only',",
            "              data.get('only_data', None))",
            "    set_param('disable_trigger', '--disable-triggers',",
            "              data.get('only_data', None) and",
            "              data.get('format', '') == 'plain')",
            "",
            "    set_param('only_schema', '--schema-only',",
            "              data.get('only_schema', None) and",
            "              not data.get('only_data', None))",
            "",
            "    set_param('dns_owner', '--no-owner')",
            "    set_param('include_create_database', '--create')",
            "    set_param('include_drop_database', '--clean')",
            "    set_param('pre_data', '--section=pre-data')",
            "    set_param('data', '--section=data')",
            "    set_param('post_data', '--section=post-data')",
            "    set_param('dns_privilege', '--no-privileges')",
            "    set_param('dns_tablespace', '--no-tablespaces')",
            "    set_param('dns_unlogged_tbl_data', '--no-unlogged-table-data')",
            "    set_param('use_insert_commands', '--inserts')",
            "    set_param('use_column_inserts', '--column-inserts')",
            "    set_param('disable_quoting', '--disable-dollar-quoting')",
            "    set_param('with_oids', '--oids')",
            "    set_param('use_set_session_auth', '--use-set-session-authorization')",
            "",
            "    set_param('no_comments', '--no-comments', manager.version >= 110000)",
            "    set_param('load_via_partition_root', '--load-via-partition-root',",
            "              manager.version >= 110000)",
            "",
            "    set_value('encoding', '--encoding')",
            "    set_value('no_of_jobs', '--jobs')",
            "",
            "    args.extend(",
            "        functools.reduce(operator.iconcat, map(",
            "            lambda s: ['--schema', r'{0}'.format(driver.qtIdent(conn, s).",
            "                                                 replace('\"', '\\\"'))],",
            "            data.get('schemas', [])), []",
            "        )",
            "    )",
            "",
            "    args.extend(",
            "        functools.reduce(operator.iconcat, map(",
            "            lambda t: ['--table',",
            "                       r'{0}'.format(driver.qtIdent(conn, t[0], t[1])",
            "                                     .replace('\"', '\\\"'))],",
            "            data.get('tables', [])), []",
            "        )",
            "    )",
            "",
            "    return args",
            "",
            "",
            "@blueprint.route(",
            "    '/job/<int:sid>', methods=['POST'], endpoint='create_server_job'",
            ")",
            "@blueprint.route(",
            "    '/job/<int:sid>/object', methods=['POST'], endpoint='create_object_job'",
            ")",
            "@login_required",
            "def create_backup_objects_job(sid):",
            "    \"\"\"",
            "    Args:",
            "        sid: Server ID",
            "",
            "        Creates a new job for backup task",
            "        (Backup Database(s)/Schema(s)/Table(s))",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "",
            "    data = json.loads(request.data, encoding='utf-8')",
            "    backup_obj_type = data.get('type', 'objects')",
            "",
            "    try:",
            "        backup_file = filename_with_file_manager_path(",
            "            data['file'], (data.get('format', '') != 'directory'))",
            "    except Exception as e:",
            "        return bad_request(errormsg=str(e))",
            "",
            "    # Fetch the server details like hostname, port, roles etc",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    # To fetch MetaData for the server",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "    conn = manager.connection()",
            "    connected = conn.connected()",
            "",
            "    if not connected:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Please connect to the server first.\")",
            "        )",
            "",
            "    utility = manager.utility('backup') if backup_obj_type == 'objects' \\",
            "        else manager.utility('backup_server')",
            "",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    args = _get_args_params_values(",
            "        data, conn, backup_obj_type, backup_file, server, manager)",
            "",
            "    escaped_args = [",
            "        escape_dquotes_process_arg(arg) for arg in args",
            "    ]",
            "    try:",
            "        bfile = data['file'].encode('utf-8') \\",
            "            if hasattr(data['file'], 'encode') else data['file']",
            "        if backup_obj_type == 'objects':",
            "            args.append(data['database'])",
            "            escaped_args.append(data['database'])",
            "            p = BatchProcess(",
            "                desc=BackupMessage(",
            "                    BACKUP.OBJECT, server.id, bfile,",
            "                    *args,",
            "                    database=data['database']",
            "                ),",
            "                cmd=utility, args=escaped_args",
            "            )",
            "        else:",
            "            p = BatchProcess(",
            "                desc=BackupMessage(",
            "                    BACKUP.SERVER if backup_obj_type != 'globals'",
            "                    else BACKUP.GLOBALS,",
            "                    server.id, bfile,",
            "                    *args",
            "                ),",
            "                cmd=utility, args=escaped_args",
            "            )",
            "",
            "        manager.export_password_env(p.id)",
            "        # Check for connection timeout and if it is greater than 0 then",
            "        # set the environment variable PGCONNECT_TIMEOUT.",
            "        if manager.connect_timeout > 0:",
            "            env = dict()",
            "            env['PGCONNECT_TIMEOUT'] = str(manager.connect_timeout)",
            "            p.set_env_variables(server, env=env)",
            "        else:",
            "            p.set_env_variables(server)",
            "",
            "        p.start()",
            "        jid = p.id",
            "    except Exception as e:",
            "        current_app.logger.exception(e)",
            "        return make_json_response(",
            "            status=410,",
            "            success=0,",
            "            errormsg=str(e)",
            "        )",
            "",
            "    # Return response",
            "    return make_json_response(",
            "        data={'job_id': jid, 'desc': p.desc.message, 'Success': 1}",
            "    )",
            "",
            "",
            "@blueprint.route(",
            "    '/utility_exists/<int:sid>/<backup_obj_type>', endpoint='utility_exists'",
            ")",
            "@login_required",
            "def check_utility_exists(sid, backup_obj_type):",
            "    \"\"\"",
            "    This function checks the utility file exist on the given path.",
            "",
            "    Args:",
            "        sid: Server ID",
            "        backup_obj_type: Type of the object",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "",
            "    utility = manager.utility('backup') if backup_obj_type == 'objects' \\",
            "        else manager.utility('backup_server')",
            "",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    return make_json_response(success=1)"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "\"\"\"Implements Backup Utility\"\"\"",
            "",
            "import simplejson as json",
            "import os",
            "import functools",
            "import operator",
            "",
            "from flask import render_template, request, current_app, \\",
            "    url_for, Response",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc",
            "from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\",
            "    fs_short_path, document_dir, does_utility_exist, get_server, \\",
            "    filename_with_file_manager_path",
            "from pgadmin.utils.ajax import make_json_response, bad_request, unauthorized",
            "",
            "from config import PG_DEFAULT_DRIVER",
            "from pgadmin.model import Server, SharedServer",
            "from pgadmin.misc.bgprocess import escape_dquotes_process_arg",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "",
            "# set template path for sql scripts",
            "MODULE_NAME = 'backup'",
            "server_info = {}",
            "",
            "",
            "class BackupModule(PgAdminModule):",
            "    \"\"\"",
            "    class BackupModule():",
            "",
            "        It is a utility which inherits PgAdminModule",
            "        class and define methods to load its own",
            "        javascript file.",
            "    \"\"\"",
            "",
            "    LABEL = _('Backup')",
            "",
            "    def show_system_objects(self):",
            "        \"\"\"",
            "        return system preference objects",
            "        \"\"\"",
            "        return self.pref_show_system_objects",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['backup.create_server_job', 'backup.create_object_job',",
            "                'backup.utility_exists']",
            "",
            "",
            "# Create blueprint for BackupModule class",
            "blueprint = BackupModule(",
            "    MODULE_NAME, __name__, static_url_path=''",
            ")",
            "",
            "",
            "class BACKUP():",
            "    \"\"\"",
            "    Constants defined for Backup utilities",
            "    \"\"\"",
            "    GLOBALS = 1",
            "    SERVER = 2",
            "    OBJECT = 3",
            "",
            "",
            "class BackupMessage(IProcessDesc):",
            "    \"\"\"",
            "    BackupMessage(IProcessDesc)",
            "",
            "    Defines the message shown for the backup operation.",
            "    \"\"\"",
            "",
            "    def __init__(self, _type, _sid, _bfile, *_args, **_kwargs):",
            "        self.backup_type = _type",
            "        self.sid = _sid",
            "        self.bfile = _bfile",
            "        self.database = _kwargs['database'] if 'database' in _kwargs else None",
            "        self.cmd = ''",
            "        self.args_str = \"{0} ({1}:{2})\"",
            "",
            "        def cmd_arg(x):",
            "            if x:",
            "                x = x.replace('\\\\', '\\\\\\\\')",
            "                x = x.replace('\"', '\\\\\"')",
            "                x = x.replace('\"\"', '\\\\\"')",
            "                return ' \"' + x + '\"'",
            "            return ''",
            "",
            "        for arg in _args:",
            "            if arg and len(arg) >= 2 and arg[:2] == '--':",
            "                self.cmd += ' ' + arg",
            "            else:",
            "                self.cmd += cmd_arg(arg)",
            "",
            "    def get_server_name(self):",
            "        s = get_server(self.sid)",
            "",
            "        if s is None:",
            "            return _(\"Not available\")",
            "",
            "        from pgadmin.utils.driver import get_driver",
            "        driver = get_driver(PG_DEFAULT_DRIVER)",
            "        manager = driver.connection_manager(self.sid)",
            "",
            "        host = manager.local_bind_host if manager.use_ssh_tunnel else s.host",
            "        port = manager.local_bind_port if manager.use_ssh_tunnel else s.port",
            "",
            "        return \"{0} ({1}:{2})\".format(s.name, host, port)",
            "",
            "    @property",
            "    def type_desc(self):",
            "        if self.backup_type == BACKUP.OBJECT:",
            "            return _(\"Backing up an object on the server\")",
            "        if self.backup_type == BACKUP.GLOBALS:",
            "            return _(\"Backing up the global objects\")",
            "        elif self.backup_type == BACKUP.SERVER:",
            "            return _(\"Backing up the server\")",
            "        else:",
            "            # It should never reach here.",
            "            return _(\"Unknown Backup\")",
            "",
            "    @property",
            "    def message(self):",
            "        server_name = self.get_server_name()",
            "",
            "        if self.backup_type == BACKUP.OBJECT:",
            "            return _(",
            "                \"Backing up an object on the server '{0}' \"",
            "                \"from database '{1}'\"",
            "            ).format(server_name, self.database)",
            "        if self.backup_type == BACKUP.GLOBALS:",
            "            return _(\"Backing up the global objects on \"",
            "                     \"the server '{0}'\").format(",
            "                server_name",
            "            )",
            "        elif self.backup_type == BACKUP.SERVER:",
            "            return _(\"Backing up the server '{0}'\").format(",
            "                server_name",
            "            )",
            "        else:",
            "            # It should never reach here.",
            "            return \"Unknown Backup\"",
            "",
            "    def details(self, cmd, args):",
            "        server_name = self.get_server_name()",
            "        backup_type = _(\"Backup\")",
            "        if self.backup_type == BACKUP.OBJECT:",
            "            backup_type = _(\"Backup Object\")",
            "        elif self.backup_type == BACKUP.GLOBALS:",
            "            backup_type = _(\"Backup Globals\")",
            "        elif self.backup_type == BACKUP.SERVER:",
            "            backup_type = _(\"Backup Server\")",
            "",
            "        return {",
            "            \"message\": self.message,",
            "            \"cmd\": cmd + self.cmd,",
            "            \"server\": server_name,",
            "            \"object\": self.database,",
            "            \"type\": backup_type,",
            "        }",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/backup.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render own javascript\"\"\"",
            "    return Response(",
            "        response=render_template(",
            "            \"backup/js/backup.js\", _=_",
            "        ),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "def _get_args_params_values(data, conn, backup_obj_type, backup_file, server,",
            "                            manager):",
            "    \"\"\"",
            "    Used internally by create_backup_objects_job. This function will create",
            "    the required args and params for the job.",
            "    :param data: input data",
            "    :param conn: connection obj",
            "    :param backup_obj_type: object type",
            "    :param backup_file: file name",
            "    :param server: server obj",
            "    :param manager: connection manager",
            "    :return: args array",
            "    \"\"\"",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "",
            "    host, port = (manager.local_bind_host, str(manager.local_bind_port)) \\",
            "        if manager.use_ssh_tunnel else (server.host, str(server.port))",
            "    args = [",
            "        '--file',",
            "        backup_file,",
            "        '--host',",
            "        host,",
            "        '--port',",
            "        port,",
            "        '--username',",
            "        server.username,",
            "        '--no-password'",
            "    ]",
            "",
            "    def set_param(key, param, assertion=True):",
            "        if not assertion:",
            "            return",
            "        if data.get(key, None):",
            "            args.append(param)",
            "",
            "    def set_value(key, param, default_value=None, assertion=True):",
            "        if not assertion:",
            "            return",
            "        val = data.get(key, default_value)",
            "        if val:",
            "            args.append(param)",
            "            args.append(val)",
            "",
            "    if backup_obj_type != 'objects':",
            "        args.append('--database')",
            "        args.append(server.maintenance_db)",
            "",
            "    if backup_obj_type == 'globals':",
            "        args.append('--globals-only')",
            "",
            "    set_param('verbose', '--verbose')",
            "    set_param('dqoute', '--quote-all-identifiers')",
            "    set_value('role', '--role')",
            "",
            "    if backup_obj_type == 'objects' and data.get('format', None):",
            "        args.extend(['--format={0}'.format({",
            "            'custom': 'c',",
            "            'tar': 't',",
            "            'plain': 'p',",
            "            'directory': 'd'",
            "        }[data['format']])])",
            "",
            "        set_param('blobs', '--blobs', data['format'] in ['custom', 'tar'])",
            "        set_value('ratio', '--compress', None,",
            "                  ['custom', 'plain', 'directory'])",
            "",
            "    set_param('only_data', '--data-only',",
            "              data.get('only_data', None))",
            "    set_param('disable_trigger', '--disable-triggers',",
            "              data.get('only_data', None) and",
            "              data.get('format', '') == 'plain')",
            "",
            "    set_param('only_schema', '--schema-only',",
            "              data.get('only_schema', None) and",
            "              not data.get('only_data', None))",
            "",
            "    set_param('dns_owner', '--no-owner')",
            "    set_param('include_create_database', '--create')",
            "    set_param('include_drop_database', '--clean')",
            "    set_param('pre_data', '--section=pre-data')",
            "    set_param('data', '--section=data')",
            "    set_param('post_data', '--section=post-data')",
            "    set_param('dns_privilege', '--no-privileges')",
            "    set_param('dns_tablespace', '--no-tablespaces')",
            "    set_param('dns_unlogged_tbl_data', '--no-unlogged-table-data')",
            "    set_param('use_insert_commands', '--inserts')",
            "    set_param('use_column_inserts', '--column-inserts')",
            "    set_param('disable_quoting', '--disable-dollar-quoting')",
            "    set_param('with_oids', '--oids')",
            "    set_param('use_set_session_auth', '--use-set-session-authorization')",
            "",
            "    set_param('no_comments', '--no-comments', manager.version >= 110000)",
            "    set_param('load_via_partition_root', '--load-via-partition-root',",
            "              manager.version >= 110000)",
            "",
            "    set_value('encoding', '--encoding')",
            "    set_value('no_of_jobs', '--jobs')",
            "",
            "    args.extend(",
            "        functools.reduce(operator.iconcat, map(",
            "            lambda s: ['--schema', r'{0}'.format(driver.qtIdent(conn, s).",
            "                                                 replace('\"', '\\\"'))],",
            "            data.get('schemas', [])), []",
            "        )",
            "    )",
            "",
            "    args.extend(",
            "        functools.reduce(operator.iconcat, map(",
            "            lambda t: ['--table',",
            "                       r'{0}'.format(driver.qtIdent(conn, t[0], t[1])",
            "                                     .replace('\"', '\\\"'))],",
            "            data.get('tables', [])), []",
            "        )",
            "    )",
            "",
            "    return args",
            "",
            "",
            "@blueprint.route(",
            "    '/job/<int:sid>', methods=['POST'], endpoint='create_server_job'",
            ")",
            "@blueprint.route(",
            "    '/job/<int:sid>/object', methods=['POST'], endpoint='create_object_job'",
            ")",
            "@login_required",
            "def create_backup_objects_job(sid):",
            "    \"\"\"",
            "    Args:",
            "        sid: Server ID",
            "",
            "        Creates a new job for backup task",
            "        (Backup Database(s)/Schema(s)/Table(s))",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "",
            "    data = json.loads(request.data, encoding='utf-8')",
            "    backup_obj_type = data.get('type', 'objects')",
            "",
            "    try:",
            "        backup_file = filename_with_file_manager_path(",
            "            data['file'], (data.get('format', '') != 'directory'))",
            "    except PermissionError as e:",
            "        return unauthorized(errormsg=str(e))",
            "    except Exception as e:",
            "        return bad_request(errormsg=str(e))",
            "",
            "    # Fetch the server details like hostname, port, roles etc",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    # To fetch MetaData for the server",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "    conn = manager.connection()",
            "    connected = conn.connected()",
            "",
            "    if not connected:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Please connect to the server first.\")",
            "        )",
            "",
            "    utility = manager.utility('backup') if backup_obj_type == 'objects' \\",
            "        else manager.utility('backup_server')",
            "",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    args = _get_args_params_values(",
            "        data, conn, backup_obj_type, backup_file, server, manager)",
            "",
            "    escaped_args = [",
            "        escape_dquotes_process_arg(arg) for arg in args",
            "    ]",
            "    try:",
            "        bfile = data['file'].encode('utf-8') \\",
            "            if hasattr(data['file'], 'encode') else data['file']",
            "        if backup_obj_type == 'objects':",
            "            args.append(data['database'])",
            "            escaped_args.append(data['database'])",
            "            p = BatchProcess(",
            "                desc=BackupMessage(",
            "                    BACKUP.OBJECT, server.id, bfile,",
            "                    *args,",
            "                    database=data['database']",
            "                ),",
            "                cmd=utility, args=escaped_args",
            "            )",
            "        else:",
            "            p = BatchProcess(",
            "                desc=BackupMessage(",
            "                    BACKUP.SERVER if backup_obj_type != 'globals'",
            "                    else BACKUP.GLOBALS,",
            "                    server.id, bfile,",
            "                    *args",
            "                ),",
            "                cmd=utility, args=escaped_args",
            "            )",
            "",
            "        manager.export_password_env(p.id)",
            "        # Check for connection timeout and if it is greater than 0 then",
            "        # set the environment variable PGCONNECT_TIMEOUT.",
            "        if manager.connect_timeout > 0:",
            "            env = dict()",
            "            env['PGCONNECT_TIMEOUT'] = str(manager.connect_timeout)",
            "            p.set_env_variables(server, env=env)",
            "        else:",
            "            p.set_env_variables(server)",
            "",
            "        p.start()",
            "        jid = p.id",
            "    except Exception as e:",
            "        current_app.logger.exception(e)",
            "        return make_json_response(",
            "            status=410,",
            "            success=0,",
            "            errormsg=str(e)",
            "        )",
            "",
            "    # Return response",
            "    return make_json_response(",
            "        data={'job_id': jid, 'desc': p.desc.message, 'Success': 1}",
            "    )",
            "",
            "",
            "@blueprint.route(",
            "    '/utility_exists/<int:sid>/<backup_obj_type>', endpoint='utility_exists'",
            ")",
            "@login_required",
            "def check_utility_exists(sid, backup_obj_type):",
            "    \"\"\"",
            "    This function checks the utility file exist on the given path.",
            "",
            "    Args:",
            "        sid: Server ID",
            "        backup_obj_type: Type of the object",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "",
            "    utility = manager.utility('backup') if backup_obj_type == 'objects' \\",
            "        else manager.utility('backup_server')",
            "",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    return make_json_response(success=1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [],
            "23": [],
            "192": [
                "filename_with_file_manager_path"
            ],
            "193": [
                "filename_with_file_manager_path"
            ],
            "194": [
                "filename_with_file_manager_path"
            ],
            "195": [
                "filename_with_file_manager_path"
            ],
            "196": [
                "filename_with_file_manager_path"
            ],
            "197": [
                "filename_with_file_manager_path"
            ],
            "198": [
                "filename_with_file_manager_path"
            ],
            "199": [
                "filename_with_file_manager_path"
            ],
            "200": [
                "filename_with_file_manager_path"
            ],
            "201": [
                "filename_with_file_manager_path"
            ],
            "202": [
                "filename_with_file_manager_path"
            ],
            "203": [
                "filename_with_file_manager_path"
            ],
            "204": [
                "filename_with_file_manager_path"
            ],
            "205": [
                "filename_with_file_manager_path"
            ],
            "206": [
                "filename_with_file_manager_path"
            ],
            "207": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "208": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "209": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "210": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "211": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "212": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "213": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "214": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "215": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "216": [
                "filename_with_file_manager_path",
                "short_filepath"
            ],
            "217": [
                "filename_with_file_manager_path"
            ],
            "218": [
                "filename_with_file_manager_path"
            ],
            "219": [
                "filename_with_file_manager_path"
            ],
            "220": [
                "filename_with_file_manager_path"
            ],
            "221": [
                "filename_with_file_manager_path"
            ],
            "222": [
                "filename_with_file_manager_path"
            ],
            "223": [
                "filename_with_file_manager_path"
            ],
            "224": [],
            "225": []
        },
        "addLocation": []
    },
    "web/pgadmin/tools/import_export/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from flask_security import login_required, current_user"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\"
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fs_short_path, document_dir, IS_WIN, does_utility_exist"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from pgadmin.utils.ajax import make_json_response, bad_request"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    fs_short_path, document_dir, IS_WIN, does_utility_exist, \\"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    filename_with_file_manager_path"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from pgadmin.utils.ajax import make_json_response, bad_request, unauthorized"
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from config import PG_DEFAULT_DRIVER"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from pgadmin.model import Server"
            },
            "11": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     )"
            },
            "12": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def filename_with_file_manager_path(_file, _present=False):"
            },
            "15": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "16": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Args:"
            },
            "17": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file: File name returned from client file manager"
            },
            "18": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "19": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Returns:"
            },
            "20": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Filename to use for backup with full path taken from preference"
            },
            "21": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "22": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Set file manager directory from preference"
            },
            "23": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    storage_dir = get_storage_directory()"
            },
            "24": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "25": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if storage_dir:"
            },
            "26": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))"
            },
            "27": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif not os.path.isabs(_file):"
            },
            "28": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _file = os.path.join(document_dir(), _file)"
            },
            "29": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "30": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not _present:"
            },
            "31": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Touch the file to get the short path of the file on windows."
            },
            "32": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with open(_file, 'a'):"
            },
            "33": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return fs_short_path(_file)"
            },
            "34": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "35": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not os.path.isfile(_file):"
            },
            "36": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None"
            },
            "37": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "38": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return fs_short_path(_file)"
            },
            "39": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "40": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "41": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " def _get_ignored_column_list(data, driver, conn):"
            },
            "42": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "     \"\"\""
            },
            "43": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     Get list of ignored columns for import/export."
            },
            "44": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "     if 'filename' in data:"
            },
            "45": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "         try:"
            },
            "46": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "             _file = filename_with_file_manager_path("
            },
            "47": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data['filename'], data['is_import'])"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+                data['filename'], not data['is_import'])"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+        except PermissionError as e:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+            return unauthorized(errormsg=str(e))"
            },
            "51": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         except Exception as e:"
            },
            "52": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "             return bad_request(errormsg=str(e))"
            },
            "53": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 279,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the import and export functionality\"\"\"",
            "",
            "import simplejson as json",
            "import os",
            "import copy",
            "from flask import url_for, Response, render_template, request, current_app",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc",
            "from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\",
            "    fs_short_path, document_dir, IS_WIN, does_utility_exist",
            "from pgadmin.utils.ajax import make_json_response, bad_request",
            "",
            "from config import PG_DEFAULT_DRIVER",
            "from pgadmin.model import Server",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "from pgadmin.settings import get_setting, store_setting",
            "",
            "MODULE_NAME = 'import_export'",
            "",
            "",
            "class ImportExportModule(PgAdminModule):",
            "    \"\"\"",
            "    class ImportExportModule(PgAdminModule)",
            "",
            "        A module class for import which is derived from PgAdminModule.",
            "    \"\"\"",
            "",
            "    LABEL = _('Import/Export')",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['import_export.create_job', 'import_export.utility_exists',",
            "                'import_export.get_settings']",
            "",
            "",
            "blueprint = ImportExportModule(MODULE_NAME, __name__)",
            "",
            "",
            "class IEMessage(IProcessDesc):",
            "    \"\"\"",
            "    IEMessage(IProcessDesc)",
            "",
            "    Defines the message shown for the import/export operation.",
            "    \"\"\"",
            "    def __init__(self, *_args, **io_params):",
            "        self.sid = io_params['sid']",
            "        self.schema = io_params['schema']",
            "        self.table = io_params['table']",
            "        self.database = io_params['database']",
            "        self._cmd = ''",
            "        self.is_import = io_params['is_import']",
            "        self.bfile = io_params['filename']",
            "",
            "        if io_params['storage']:",
            "            io_params['storage'] = io_params['storage'].replace('\\\\', '/')",
            "",
            "        def cmd_arg(x):",
            "            if x:",
            "                x = x.replace('\\\\', '\\\\\\\\')",
            "                x = x.replace('\"', '\\\\\"')",
            "                x = x.replace('\"\"', '\\\\\"')",
            "",
            "                return ' \"' + x + '\"'",
            "            return ''",
            "",
            "        replace_next = False",
            "        for arg in _args:",
            "            if arg and len(arg) >= 2 and arg[:2] == '--':",
            "                if arg == '--command':",
            "                    replace_next = True",
            "                self._cmd += ' ' + arg",
            "            elif replace_next:",
            "                arg = cmd_arg(arg)",
            "                if io_params['storage'] is not None:",
            "                    arg = arg.replace(io_params['storage'], '<STORAGE_DIR>')",
            "                self._cmd += ' \"' + arg + '\"'",
            "            else:",
            "                self._cmd += cmd_arg(arg)",
            "",
            "    def get_server_name(self):",
            "        # Fetch the server details like hostname, port, roles etc",
            "        s = Server.query.filter_by(",
            "            id=self.sid, user_id=current_user.id",
            "        ).first()",
            "",
            "        if s is None:",
            "            return _(\"Not available\")",
            "        return \"{0} ({1}:{2})\".format(s.name, s.host, s.port)",
            "",
            "    @property",
            "    def message(self):",
            "        # Fetch the server details like hostname, port, roles etc",
            "        return _(",
            "            \"Copying table data '{0}.{1}' on database '{2}' \"",
            "            \"and server '{3}'\"",
            "        ).format(",
            "            self.schema, self.table, self.database,",
            "            self.get_server_name()",
            "        )",
            "",
            "    @property",
            "    def type_desc(self):",
            "        _type_desc = _(\"Import - \") if self.is_import else _(\"Export - \")",
            "        return _type_desc + _(\"Copying table data\")",
            "",
            "    def details(self, cmd, args):",
            "        # Fetch the server details like hostname, port, roles etc",
            "        return {",
            "            \"message\": self.message,",
            "            \"cmd\": self._cmd,",
            "            \"server\": self.get_server_name(),",
            "            \"object\": \"{0}/{1}.{2}\".format(self.database, self.schema,",
            "                                           self.table),",
            "            \"type\": _(\"Import Data\") if self.is_import else _(\"Export Data\")",
            "        }",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/js/import_export.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render the import/export javascript file\"\"\"",
            "    return Response(",
            "        response=render_template(\"import_export/js/import_export.js\", _=_),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "def filename_with_file_manager_path(_file, _present=False):",
            "    \"\"\"",
            "    Args:",
            "        file: File name returned from client file manager",
            "",
            "    Returns:",
            "        Filename to use for backup with full path taken from preference",
            "    \"\"\"",
            "    # Set file manager directory from preference",
            "    storage_dir = get_storage_directory()",
            "",
            "    if storage_dir:",
            "        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))",
            "    elif not os.path.isabs(_file):",
            "        _file = os.path.join(document_dir(), _file)",
            "",
            "    if not _present:",
            "        # Touch the file to get the short path of the file on windows.",
            "        with open(_file, 'a'):",
            "            return fs_short_path(_file)",
            "    else:",
            "        if not os.path.isfile(_file):",
            "            return None",
            "",
            "    return fs_short_path(_file)",
            "",
            "",
            "def _get_ignored_column_list(data, driver, conn):",
            "    \"\"\"",
            "    Get list of ignored columns for import/export.",
            "    :param data: Data.",
            "    :param driver: PG Driver.",
            "    :param conn: Connection.",
            "    :return: return ignored column list.",
            "    \"\"\"",
            "    icols = None",
            "",
            "    if data['icolumns']:",
            "        ignore_cols = data['icolumns']",
            "",
            "        # format the ignore column list required as per copy command",
            "        # requirement",
            "        if ignore_cols and len(ignore_cols) > 0:",
            "            icols = \", \".join([",
            "                driver.qtIdent(conn, col)",
            "                for col in ignore_cols])",
            "    return icols",
            "",
            "",
            "def _get_required_column_list(data, driver, conn):",
            "    \"\"\"",
            "    Get list of required columns for import/export.",
            "    :param data: Data.",
            "    :param driver: PG Driver.",
            "    :param conn: Connection.",
            "    :return: return required column list.",
            "    \"\"\"",
            "    cols = None",
            "",
            "    # format the column import/export list required as per copy command",
            "    # requirement",
            "    if data['columns']:",
            "        columns = data['columns']",
            "        if columns and len(columns) > 0:",
            "            for col in columns:",
            "                if cols:",
            "                    cols += ', '",
            "                else:",
            "                    cols = '('",
            "                cols += driver.qtIdent(conn, col)",
            "            cols += ')'",
            "",
            "    return cols",
            "",
            "",
            "def _save_import_export_settings(settings):",
            "    settings = {key: settings[key] for key in settings if key not in",
            "                ['icolumns', 'columns', 'database', 'schema', 'table',",
            "                 'save_btn_icon']}",
            "",
            "    if settings['is_import']:",
            "        settings['import_file_name'] = settings['filename']",
            "    else:",
            "        settings['export_file_name'] = settings['filename']",
            "",
            "    # Get existing setting -",
            "    old_settings = get_setting('import_export_setting')",
            "    if old_settings and old_settings != 'null':",
            "        old_settings = json.loads(old_settings)",
            "        old_settings.update(settings)",
            "        settings = json.dumps(settings)",
            "    else:",
            "        if 'import_file_name' not in settings:",
            "            settings['import_file_name'] = ''",
            "        elif 'export_file_name' not in settings:",
            "            settings['export_file_name'] = ''",
            "        settings = json.dumps(settings)",
            "",
            "    store_setting('import_export_setting', settings)",
            "",
            "",
            "@blueprint.route('/job/<int:sid>', methods=['POST'], endpoint=\"create_job\")",
            "@login_required",
            "def create_import_export_job(sid):",
            "    \"\"\"",
            "    Args:",
            "        sid: Server ID",
            "",
            "        Creates a new job for import and export table data functionality",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    if request.form:",
            "        data = json.loads(request.form['data'], encoding='utf-8')",
            "    else:",
            "        data = json.loads(request.data, encoding='utf-8')",
            "",
            "    # Fetch the server details like hostname, port, roles etc",
            "    server = Server.query.filter_by(",
            "        id=sid).first()",
            "",
            "    if server is None:",
            "        return bad_request(errormsg=_(\"Could not find the given server\"))",
            "",
            "    # To fetch MetaData for the server",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "    conn = manager.connection()",
            "    connected = conn.connected()",
            "",
            "    if not connected:",
            "        return bad_request(errormsg=_(\"Please connect to the server first...\"))",
            "",
            "    # Get the utility path from the connection manager",
            "    utility = manager.utility('sql')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "    # Copy request data to store",
            "    new_settings = copy.deepcopy(data)",
            "",
            "    # Get the storage path from preference",
            "    storage_dir = get_storage_directory()",
            "",
            "    if 'filename' in data:",
            "        try:",
            "            _file = filename_with_file_manager_path(",
            "                data['filename'], data['is_import'])",
            "        except Exception as e:",
            "            return bad_request(errormsg=str(e))",
            "",
            "        if not _file:",
            "            return bad_request(errormsg=_('Please specify a valid file'))",
            "        elif IS_WIN:",
            "            _file = _file.replace('\\\\', '/')",
            "",
            "        data['filename'] = _file",
            "    else:",
            "        return bad_request(errormsg=_('Please specify a valid file'))",
            "",
            "    # Get required and ignored column list",
            "    icols = _get_ignored_column_list(data, driver, conn)",
            "    cols = _get_required_column_list(data, driver, conn)",
            "",
            "    # Save the settings",
            "    _save_import_export_settings(new_settings)",
            "",
            "    # Create the COPY FROM/TO  from template",
            "    query = render_template(",
            "        'import_export/sql/cmd.sql',",
            "        conn=conn,",
            "        data=data,",
            "        columns=cols,",
            "        ignore_column_list=icols",
            "    )",
            "",
            "    args = ['--command', query]",
            "",
            "    try:",
            "",
            "        io_params = {",
            "            'sid': sid,",
            "            'schema': data['schema'],",
            "            'table': data['table'],",
            "            'database': data['database'],",
            "            'is_import': data['is_import'],",
            "            'filename': data['filename'],",
            "            'storage': storage_dir,",
            "            'utility': utility",
            "        }",
            "",
            "        p = BatchProcess(",
            "            desc=IEMessage(",
            "                *args,",
            "                **io_params",
            "            ),",
            "            cmd=utility, args=args",
            "        )",
            "        manager.export_password_env(p.id)",
            "",
            "        env = dict()",
            "",
            "        env['PGHOST'] = \\",
            "            manager.local_bind_host if manager.use_ssh_tunnel else server.host",
            "        env['PGPORT'] = \\",
            "            str(manager.local_bind_port) if manager.use_ssh_tunnel else str(",
            "                server.port)",
            "        env['PGUSER'] = server.username",
            "        env['PGDATABASE'] = data['database']",
            "        p.set_env_variables(server, env=env)",
            "        p.start()",
            "        jid = p.id",
            "    except Exception as e:",
            "        current_app.logger.exception(e)",
            "        return bad_request(errormsg=str(e))",
            "",
            "    # Return response",
            "    return make_json_response(",
            "        data={'job_id': jid, 'desc': p.desc.message, 'success': 1}",
            "    )",
            "",
            "",
            "@blueprint.route('/get_settings/', methods=['GET'], endpoint='get_settings')",
            "@login_required",
            "def get_import_export_settings():",
            "    settings = get_setting('import_export_setting', None)",
            "    if settings is None:",
            "        return make_json_response(success=True, data={})",
            "    else:",
            "        data = json.loads(settings)",
            "        return make_json_response(success=True, data=data)",
            "",
            "",
            "@blueprint.route(",
            "    '/utility_exists/<int:sid>', endpoint='utility_exists'",
            ")",
            "@login_required",
            "def check_utility_exists(sid):",
            "    \"\"\"",
            "    This function checks the utility file exist on the given path.",
            "",
            "    Args:",
            "        sid: Server ID",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    server = Server.query.filter_by(",
            "        id=sid, user_id=current_user.id",
            "    ).first()",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "",
            "    utility = manager.utility('sql')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    return make_json_response(success=1)"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the import and export functionality\"\"\"",
            "",
            "import simplejson as json",
            "import os",
            "import copy",
            "from flask import url_for, Response, render_template, request, current_app",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc",
            "from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\",
            "    fs_short_path, document_dir, IS_WIN, does_utility_exist, \\",
            "    filename_with_file_manager_path",
            "from pgadmin.utils.ajax import make_json_response, bad_request, unauthorized",
            "",
            "from config import PG_DEFAULT_DRIVER",
            "from pgadmin.model import Server",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "from pgadmin.settings import get_setting, store_setting",
            "",
            "MODULE_NAME = 'import_export'",
            "",
            "",
            "class ImportExportModule(PgAdminModule):",
            "    \"\"\"",
            "    class ImportExportModule(PgAdminModule)",
            "",
            "        A module class for import which is derived from PgAdminModule.",
            "    \"\"\"",
            "",
            "    LABEL = _('Import/Export')",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['import_export.create_job', 'import_export.utility_exists',",
            "                'import_export.get_settings']",
            "",
            "",
            "blueprint = ImportExportModule(MODULE_NAME, __name__)",
            "",
            "",
            "class IEMessage(IProcessDesc):",
            "    \"\"\"",
            "    IEMessage(IProcessDesc)",
            "",
            "    Defines the message shown for the import/export operation.",
            "    \"\"\"",
            "    def __init__(self, *_args, **io_params):",
            "        self.sid = io_params['sid']",
            "        self.schema = io_params['schema']",
            "        self.table = io_params['table']",
            "        self.database = io_params['database']",
            "        self._cmd = ''",
            "        self.is_import = io_params['is_import']",
            "        self.bfile = io_params['filename']",
            "",
            "        if io_params['storage']:",
            "            io_params['storage'] = io_params['storage'].replace('\\\\', '/')",
            "",
            "        def cmd_arg(x):",
            "            if x:",
            "                x = x.replace('\\\\', '\\\\\\\\')",
            "                x = x.replace('\"', '\\\\\"')",
            "                x = x.replace('\"\"', '\\\\\"')",
            "",
            "                return ' \"' + x + '\"'",
            "            return ''",
            "",
            "        replace_next = False",
            "        for arg in _args:",
            "            if arg and len(arg) >= 2 and arg[:2] == '--':",
            "                if arg == '--command':",
            "                    replace_next = True",
            "                self._cmd += ' ' + arg",
            "            elif replace_next:",
            "                arg = cmd_arg(arg)",
            "                if io_params['storage'] is not None:",
            "                    arg = arg.replace(io_params['storage'], '<STORAGE_DIR>')",
            "                self._cmd += ' \"' + arg + '\"'",
            "            else:",
            "                self._cmd += cmd_arg(arg)",
            "",
            "    def get_server_name(self):",
            "        # Fetch the server details like hostname, port, roles etc",
            "        s = Server.query.filter_by(",
            "            id=self.sid, user_id=current_user.id",
            "        ).first()",
            "",
            "        if s is None:",
            "            return _(\"Not available\")",
            "        return \"{0} ({1}:{2})\".format(s.name, s.host, s.port)",
            "",
            "    @property",
            "    def message(self):",
            "        # Fetch the server details like hostname, port, roles etc",
            "        return _(",
            "            \"Copying table data '{0}.{1}' on database '{2}' \"",
            "            \"and server '{3}'\"",
            "        ).format(",
            "            self.schema, self.table, self.database,",
            "            self.get_server_name()",
            "        )",
            "",
            "    @property",
            "    def type_desc(self):",
            "        _type_desc = _(\"Import - \") if self.is_import else _(\"Export - \")",
            "        return _type_desc + _(\"Copying table data\")",
            "",
            "    def details(self, cmd, args):",
            "        # Fetch the server details like hostname, port, roles etc",
            "        return {",
            "            \"message\": self.message,",
            "            \"cmd\": self._cmd,",
            "            \"server\": self.get_server_name(),",
            "            \"object\": \"{0}/{1}.{2}\".format(self.database, self.schema,",
            "                                           self.table),",
            "            \"type\": _(\"Import Data\") if self.is_import else _(\"Export Data\")",
            "        }",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/js/import_export.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render the import/export javascript file\"\"\"",
            "    return Response(",
            "        response=render_template(\"import_export/js/import_export.js\", _=_),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "def _get_ignored_column_list(data, driver, conn):",
            "    \"\"\"",
            "    Get list of ignored columns for import/export.",
            "    :param data: Data.",
            "    :param driver: PG Driver.",
            "    :param conn: Connection.",
            "    :return: return ignored column list.",
            "    \"\"\"",
            "    icols = None",
            "",
            "    if data['icolumns']:",
            "        ignore_cols = data['icolumns']",
            "",
            "        # format the ignore column list required as per copy command",
            "        # requirement",
            "        if ignore_cols and len(ignore_cols) > 0:",
            "            icols = \", \".join([",
            "                driver.qtIdent(conn, col)",
            "                for col in ignore_cols])",
            "    return icols",
            "",
            "",
            "def _get_required_column_list(data, driver, conn):",
            "    \"\"\"",
            "    Get list of required columns for import/export.",
            "    :param data: Data.",
            "    :param driver: PG Driver.",
            "    :param conn: Connection.",
            "    :return: return required column list.",
            "    \"\"\"",
            "    cols = None",
            "",
            "    # format the column import/export list required as per copy command",
            "    # requirement",
            "    if data['columns']:",
            "        columns = data['columns']",
            "        if columns and len(columns) > 0:",
            "            for col in columns:",
            "                if cols:",
            "                    cols += ', '",
            "                else:",
            "                    cols = '('",
            "                cols += driver.qtIdent(conn, col)",
            "            cols += ')'",
            "",
            "    return cols",
            "",
            "",
            "def _save_import_export_settings(settings):",
            "    settings = {key: settings[key] for key in settings if key not in",
            "                ['icolumns', 'columns', 'database', 'schema', 'table',",
            "                 'save_btn_icon']}",
            "",
            "    if settings['is_import']:",
            "        settings['import_file_name'] = settings['filename']",
            "    else:",
            "        settings['export_file_name'] = settings['filename']",
            "",
            "    # Get existing setting -",
            "    old_settings = get_setting('import_export_setting')",
            "    if old_settings and old_settings != 'null':",
            "        old_settings = json.loads(old_settings)",
            "        old_settings.update(settings)",
            "        settings = json.dumps(settings)",
            "    else:",
            "        if 'import_file_name' not in settings:",
            "            settings['import_file_name'] = ''",
            "        elif 'export_file_name' not in settings:",
            "            settings['export_file_name'] = ''",
            "        settings = json.dumps(settings)",
            "",
            "    store_setting('import_export_setting', settings)",
            "",
            "",
            "@blueprint.route('/job/<int:sid>', methods=['POST'], endpoint=\"create_job\")",
            "@login_required",
            "def create_import_export_job(sid):",
            "    \"\"\"",
            "    Args:",
            "        sid: Server ID",
            "",
            "        Creates a new job for import and export table data functionality",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    if request.form:",
            "        data = json.loads(request.form['data'], encoding='utf-8')",
            "    else:",
            "        data = json.loads(request.data, encoding='utf-8')",
            "",
            "    # Fetch the server details like hostname, port, roles etc",
            "    server = Server.query.filter_by(",
            "        id=sid).first()",
            "",
            "    if server is None:",
            "        return bad_request(errormsg=_(\"Could not find the given server\"))",
            "",
            "    # To fetch MetaData for the server",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "    conn = manager.connection()",
            "    connected = conn.connected()",
            "",
            "    if not connected:",
            "        return bad_request(errormsg=_(\"Please connect to the server first...\"))",
            "",
            "    # Get the utility path from the connection manager",
            "    utility = manager.utility('sql')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "    # Copy request data to store",
            "    new_settings = copy.deepcopy(data)",
            "",
            "    # Get the storage path from preference",
            "    storage_dir = get_storage_directory()",
            "",
            "    if 'filename' in data:",
            "        try:",
            "            _file = filename_with_file_manager_path(",
            "                data['filename'], not data['is_import'])",
            "        except PermissionError as e:",
            "            return unauthorized(errormsg=str(e))",
            "        except Exception as e:",
            "            return bad_request(errormsg=str(e))",
            "",
            "        if not _file:",
            "            return bad_request(errormsg=_('Please specify a valid file'))",
            "        elif IS_WIN:",
            "            _file = _file.replace('\\\\', '/')",
            "",
            "        data['filename'] = _file",
            "    else:",
            "        return bad_request(errormsg=_('Please specify a valid file'))",
            "",
            "    # Get required and ignored column list",
            "    icols = _get_ignored_column_list(data, driver, conn)",
            "    cols = _get_required_column_list(data, driver, conn)",
            "",
            "    # Save the settings",
            "    _save_import_export_settings(new_settings)",
            "",
            "    # Create the COPY FROM/TO  from template",
            "    query = render_template(",
            "        'import_export/sql/cmd.sql',",
            "        conn=conn,",
            "        data=data,",
            "        columns=cols,",
            "        ignore_column_list=icols",
            "    )",
            "",
            "    args = ['--command', query]",
            "",
            "    try:",
            "",
            "        io_params = {",
            "            'sid': sid,",
            "            'schema': data['schema'],",
            "            'table': data['table'],",
            "            'database': data['database'],",
            "            'is_import': data['is_import'],",
            "            'filename': data['filename'],",
            "            'storage': storage_dir,",
            "            'utility': utility",
            "        }",
            "",
            "        p = BatchProcess(",
            "            desc=IEMessage(",
            "                *args,",
            "                **io_params",
            "            ),",
            "            cmd=utility, args=args",
            "        )",
            "        manager.export_password_env(p.id)",
            "",
            "        env = dict()",
            "",
            "        env['PGHOST'] = \\",
            "            manager.local_bind_host if manager.use_ssh_tunnel else server.host",
            "        env['PGPORT'] = \\",
            "            str(manager.local_bind_port) if manager.use_ssh_tunnel else str(",
            "                server.port)",
            "        env['PGUSER'] = server.username",
            "        env['PGDATABASE'] = data['database']",
            "        p.set_env_variables(server, env=env)",
            "        p.start()",
            "        jid = p.id",
            "    except Exception as e:",
            "        current_app.logger.exception(e)",
            "        return bad_request(errormsg=str(e))",
            "",
            "    # Return response",
            "    return make_json_response(",
            "        data={'job_id': jid, 'desc': p.desc.message, 'success': 1}",
            "    )",
            "",
            "",
            "@blueprint.route('/get_settings/', methods=['GET'], endpoint='get_settings')",
            "@login_required",
            "def get_import_export_settings():",
            "    settings = get_setting('import_export_setting', None)",
            "    if settings is None:",
            "        return make_json_response(success=True, data={})",
            "    else:",
            "        data = json.loads(settings)",
            "        return make_json_response(success=True, data=data)",
            "",
            "",
            "@blueprint.route(",
            "    '/utility_exists/<int:sid>', endpoint='utility_exists'",
            ")",
            "@login_required",
            "def check_utility_exists(sid):",
            "    \"\"\"",
            "    This function checks the utility file exist on the given path.",
            "",
            "    Args:",
            "        sid: Server ID",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    server = Server.query.filter_by(",
            "        id=sid, user_id=current_user.id",
            "    ).first()",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "",
            "    utility = manager.utility('sql')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    return make_json_response(success=1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [],
            "21": [],
            "148": [
                "filename_with_file_manager_path"
            ],
            "149": [
                "filename_with_file_manager_path"
            ],
            "150": [
                "filename_with_file_manager_path"
            ],
            "151": [
                "filename_with_file_manager_path"
            ],
            "152": [
                "filename_with_file_manager_path"
            ],
            "153": [
                "filename_with_file_manager_path"
            ],
            "154": [
                "filename_with_file_manager_path"
            ],
            "155": [
                "filename_with_file_manager_path"
            ],
            "156": [
                "filename_with_file_manager_path"
            ],
            "157": [
                "filename_with_file_manager_path"
            ],
            "158": [
                "filename_with_file_manager_path"
            ],
            "159": [
                "filename_with_file_manager_path"
            ],
            "160": [
                "filename_with_file_manager_path"
            ],
            "161": [
                "filename_with_file_manager_path"
            ],
            "162": [
                "filename_with_file_manager_path"
            ],
            "163": [
                "filename_with_file_manager_path"
            ],
            "164": [
                "filename_with_file_manager_path"
            ],
            "165": [
                "filename_with_file_manager_path"
            ],
            "166": [
                "filename_with_file_manager_path"
            ],
            "167": [
                "filename_with_file_manager_path"
            ],
            "168": [
                "filename_with_file_manager_path"
            ],
            "169": [
                "filename_with_file_manager_path"
            ],
            "170": [
                "filename_with_file_manager_path"
            ],
            "171": [
                "filename_with_file_manager_path"
            ],
            "172": [
                "filename_with_file_manager_path"
            ],
            "173": [],
            "174": [],
            "300": [
                "create_import_export_job"
            ]
        },
        "addLocation": []
    },
    "web/pgadmin/tools/import_export_servers/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from pgadmin.utils import PgAdminModule"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from pgadmin.utils.ajax import bad_request"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from pgadmin.utils.constants import MIMETYPE_APP_JS"
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from pgadmin.utils.ajax import make_json_response, internal_server_error"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from pgadmin.utils.ajax import make_json_response, internal_server_error, \\"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    unauthorized"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from pgadmin.model import ServerGroup, Server"
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from pgadmin.utils import clear_database_servers, dump_database_servers,\\"
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    load_database_servers, validate_json_data"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    load_database_servers, validate_json_data, filename_with_file_manager_path"
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from urllib.parse import unquote"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from pgadmin.utils.paths import get_storage_directory"
            },
            "12": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     # retrieve storage directory path"
            },
            "15": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     storage_manager_path = get_storage_directory()"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    try:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        file_path = filename_with_file_manager_path(file_path)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    except PermissionError as e:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        return unauthorized(errormsg=str(e))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+    except Exception as e:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        return bad_request(errormsg=str(e))"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "     if storage_manager_path:"
            },
            "25": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         # generate full path of file"
            },
            "26": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         file_path = os.path.join("
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the import and export servers",
            "functionality\"\"\"",
            "",
            "import json",
            "import os",
            "import secrets",
            "",
            "from flask import Response, render_template, request",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.ajax import bad_request",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "from pgadmin.utils.ajax import make_json_response, internal_server_error",
            "from pgadmin.model import ServerGroup, Server",
            "from pgadmin.utils import clear_database_servers, dump_database_servers,\\",
            "    load_database_servers, validate_json_data",
            "from urllib.parse import unquote",
            "from pgadmin.utils.paths import get_storage_directory",
            "",
            "MODULE_NAME = 'import_export_servers'",
            "",
            "",
            "class ImportExportServersModule(PgAdminModule):",
            "    \"\"\"",
            "    class ImportExportServersModule(PgAdminModule)",
            "",
            "        A module class for import which is derived from PgAdminModule.",
            "    \"\"\"",
            "",
            "    LABEL = _('Import/Export Servers')",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['import_export_servers.get_servers',",
            "                'import_export_servers.load_servers',",
            "                'import_export_servers.save']",
            "",
            "",
            "blueprint = ImportExportServersModule(MODULE_NAME, __name__)",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/js/import_export_servers.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render the import/export javascript file\"\"\"",
            "    return Response(",
            "        response=render_template(",
            "            \"import_export_servers/js/import_export_servers.js\", _=_),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "@blueprint.route('/get_servers', methods=['GET'], endpoint='get_servers')",
            "@login_required",
            "def get_servers():",
            "    \"\"\"",
            "    This function is used to get the servers with server groups",
            "    \"\"\"",
            "    all_servers = []",
            "    groups = ServerGroup.query.filter_by(",
            "        user_id=current_user.id",
            "    ).order_by(\"id\")",
            "",
            "    # Loop through all the server groups",
            "    for idx, group in enumerate(groups):",
            "        children = []",
            "        # Loop through all the servers for specific server group",
            "        servers = Server.query.filter(",
            "            Server.user_id == current_user.id,",
            "            Server.servergroup_id == group.id)",
            "        for server in servers:",
            "            children.append({'value': server.id, 'label': server.name})",
            "",
            "        # Add server group only when some servers are there.",
            "        if len(children) > 0:",
            "            all_servers.append(",
            "                {'value': group.name, 'label': group.name,",
            "                 'children': children})",
            "",
            "    return make_json_response(success=1, data=all_servers)",
            "",
            "",
            "@blueprint.route('/load_servers', methods=['POST'], endpoint='load_servers')",
            "@login_required",
            "def load_servers():",
            "    \"\"\"",
            "    This function is used to load the servers from the json file.",
            "    \"\"\"",
            "    filename = None",
            "    groups = {}",
            "    all_servers = []",
            "",
            "    data = request.form if request.form else json.loads(request.data.decode())",
            "    if 'filename' in data:",
            "        filename = data['filename']",
            "",
            "    file_path = unquote(filename)",
            "",
            "    # retrieve storage directory path",
            "    storage_manager_path = get_storage_directory()",
            "    if storage_manager_path:",
            "        # generate full path of file",
            "        file_path = os.path.join(",
            "            storage_manager_path,",
            "            file_path.lstrip('/').lstrip('\\\\')",
            "        )",
            "",
            "    if file_path and os.path.exists(file_path):",
            "        try:",
            "            with open(file_path, 'r') as j:",
            "                data = json.loads(j.read())",
            "",
            "                # Validate the json file and data",
            "                errmsg = validate_json_data(data, False)",
            "                if errmsg is not None:",
            "                    return internal_server_error(errmsg)",
            "",
            "                if 'Servers' in data:",
            "                    for server in data[\"Servers\"]:",
            "                        obj = data[\"Servers\"][server]",
            "                        server_id = server + '_' + str(",
            "                            secrets.choice(range(1, 9999)))",
            "",
            "                        if obj['Group'] in groups:",
            "                            groups[obj['Group']]['children'].append(",
            "                                {'value': server_id,",
            "                                 'label': obj['Name']})",
            "                        else:",
            "                            groups[obj['Group']] = \\",
            "                                {'value': obj['Group'], 'label': obj['Group'],",
            "                                 'children': [{",
            "                                     'value': server_id,",
            "                                     'label': obj['Name']}]}",
            "                else:",
            "                    return internal_server_error(",
            "                        _('The specified file is not in the correct format.'))",
            "",
            "            for item in groups:",
            "                all_servers.append(groups[item])",
            "        except Exception:",
            "            return internal_server_error(",
            "                _('Unable to load the specified file.'))",
            "    else:",
            "        return internal_server_error(_('The specified file does not exist.'))",
            "",
            "    return make_json_response(success=1, data=all_servers)",
            "",
            "",
            "@blueprint.route('/save', methods=['POST'], endpoint='save')",
            "@login_required",
            "def save():",
            "    \"\"\"",
            "    This function is used to import or export based on the data",
            "    \"\"\"",
            "    required_args = [",
            "        'type', 'filename'",
            "    ]",
            "",
            "    data = request.form if request.form else json.loads(request.data.decode())",
            "    for arg in required_args:",
            "        if arg not in data:",
            "            return make_json_response(",
            "                status=410,",
            "                success=0,",
            "                errormsg=_(",
            "                    \"Could not find the required parameter ({}).\"",
            "                ).format(arg)",
            "            )",
            "",
            "    status = False",
            "    errmsg = None",
            "    if data['type'] == 'export':",
            "        status, errmsg = \\",
            "            dump_database_servers(data['filename'], data['selected_sever_ids'])",
            "    elif data['type'] == 'import':",
            "        # Clear all the existing servers",
            "        if 'replace_servers' in data and data['replace_servers']:",
            "            clear_database_servers()",
            "        status, errmsg = \\",
            "            load_database_servers(data['filename'], data['selected_sever_ids'])",
            "",
            "    if not status:",
            "        return internal_server_error(errmsg)",
            "",
            "    return make_json_response(success=1)"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module implementing the import and export servers",
            "functionality\"\"\"",
            "",
            "import json",
            "import os",
            "import secrets",
            "",
            "from flask import Response, render_template, request",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.utils import PgAdminModule",
            "from pgadmin.utils.ajax import bad_request",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "from pgadmin.utils.ajax import make_json_response, internal_server_error, \\",
            "    unauthorized",
            "from pgadmin.model import ServerGroup, Server",
            "from pgadmin.utils import clear_database_servers, dump_database_servers,\\",
            "    load_database_servers, validate_json_data, filename_with_file_manager_path",
            "from urllib.parse import unquote",
            "from pgadmin.utils.paths import get_storage_directory",
            "",
            "MODULE_NAME = 'import_export_servers'",
            "",
            "",
            "class ImportExportServersModule(PgAdminModule):",
            "    \"\"\"",
            "    class ImportExportServersModule(PgAdminModule)",
            "",
            "        A module class for import which is derived from PgAdminModule.",
            "    \"\"\"",
            "",
            "    LABEL = _('Import/Export Servers')",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['import_export_servers.get_servers',",
            "                'import_export_servers.load_servers',",
            "                'import_export_servers.save']",
            "",
            "",
            "blueprint = ImportExportServersModule(MODULE_NAME, __name__)",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/js/import_export_servers.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render the import/export javascript file\"\"\"",
            "    return Response(",
            "        response=render_template(",
            "            \"import_export_servers/js/import_export_servers.js\", _=_),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "@blueprint.route('/get_servers', methods=['GET'], endpoint='get_servers')",
            "@login_required",
            "def get_servers():",
            "    \"\"\"",
            "    This function is used to get the servers with server groups",
            "    \"\"\"",
            "    all_servers = []",
            "    groups = ServerGroup.query.filter_by(",
            "        user_id=current_user.id",
            "    ).order_by(\"id\")",
            "",
            "    # Loop through all the server groups",
            "    for idx, group in enumerate(groups):",
            "        children = []",
            "        # Loop through all the servers for specific server group",
            "        servers = Server.query.filter(",
            "            Server.user_id == current_user.id,",
            "            Server.servergroup_id == group.id)",
            "        for server in servers:",
            "            children.append({'value': server.id, 'label': server.name})",
            "",
            "        # Add server group only when some servers are there.",
            "        if len(children) > 0:",
            "            all_servers.append(",
            "                {'value': group.name, 'label': group.name,",
            "                 'children': children})",
            "",
            "    return make_json_response(success=1, data=all_servers)",
            "",
            "",
            "@blueprint.route('/load_servers', methods=['POST'], endpoint='load_servers')",
            "@login_required",
            "def load_servers():",
            "    \"\"\"",
            "    This function is used to load the servers from the json file.",
            "    \"\"\"",
            "    filename = None",
            "    groups = {}",
            "    all_servers = []",
            "",
            "    data = request.form if request.form else json.loads(request.data.decode())",
            "    if 'filename' in data:",
            "        filename = data['filename']",
            "",
            "    file_path = unquote(filename)",
            "",
            "    # retrieve storage directory path",
            "    storage_manager_path = get_storage_directory()",
            "",
            "    try:",
            "        file_path = filename_with_file_manager_path(file_path)",
            "    except PermissionError as e:",
            "        return unauthorized(errormsg=str(e))",
            "    except Exception as e:",
            "        return bad_request(errormsg=str(e))",
            "",
            "    if storage_manager_path:",
            "        # generate full path of file",
            "        file_path = os.path.join(",
            "            storage_manager_path,",
            "            file_path.lstrip('/').lstrip('\\\\')",
            "        )",
            "",
            "    if file_path and os.path.exists(file_path):",
            "        try:",
            "            with open(file_path, 'r') as j:",
            "                data = json.loads(j.read())",
            "",
            "                # Validate the json file and data",
            "                errmsg = validate_json_data(data, False)",
            "                if errmsg is not None:",
            "                    return internal_server_error(errmsg)",
            "",
            "                if 'Servers' in data:",
            "                    for server in data[\"Servers\"]:",
            "                        obj = data[\"Servers\"][server]",
            "                        server_id = server + '_' + str(",
            "                            secrets.choice(range(1, 9999)))",
            "",
            "                        if obj['Group'] in groups:",
            "                            groups[obj['Group']]['children'].append(",
            "                                {'value': server_id,",
            "                                 'label': obj['Name']})",
            "                        else:",
            "                            groups[obj['Group']] = \\",
            "                                {'value': obj['Group'], 'label': obj['Group'],",
            "                                 'children': [{",
            "                                     'value': server_id,",
            "                                     'label': obj['Name']}]}",
            "                else:",
            "                    return internal_server_error(",
            "                        _('The specified file is not in the correct format.'))",
            "",
            "            for item in groups:",
            "                all_servers.append(groups[item])",
            "        except Exception:",
            "            return internal_server_error(",
            "                _('Unable to load the specified file.'))",
            "    else:",
            "        return internal_server_error(_('The specified file does not exist.'))",
            "",
            "    return make_json_response(success=1, data=all_servers)",
            "",
            "",
            "@blueprint.route('/save', methods=['POST'], endpoint='save')",
            "@login_required",
            "def save():",
            "    \"\"\"",
            "    This function is used to import or export based on the data",
            "    \"\"\"",
            "    required_args = [",
            "        'type', 'filename'",
            "    ]",
            "",
            "    data = request.form if request.form else json.loads(request.data.decode())",
            "    for arg in required_args:",
            "        if arg not in data:",
            "            return make_json_response(",
            "                status=410,",
            "                success=0,",
            "                errormsg=_(",
            "                    \"Could not find the required parameter ({}).\"",
            "                ).format(arg)",
            "            )",
            "",
            "    status = False",
            "    errmsg = None",
            "    if data['type'] == 'export':",
            "        status, errmsg = \\",
            "            dump_database_servers(data['filename'], data['selected_sever_ids'])",
            "    elif data['type'] == 'import':",
            "        # Clear all the existing servers",
            "        if 'replace_servers' in data and data['replace_servers']:",
            "            clear_database_servers()",
            "        status, errmsg = \\",
            "            load_database_servers(data['filename'], data['selected_sever_ids'])",
            "",
            "    if not status:",
            "        return internal_server_error(errmsg)",
            "",
            "    return make_json_response(success=1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [],
            "26": []
        },
        "addLocation": []
    },
    "web/pgadmin/tools/restore/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from flask_security import login_required, current_user"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\"
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fs_short_path, document_dir, does_utility_exist, get_server"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from pgadmin.utils.ajax import make_json_response, bad_request"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    fs_short_path, document_dir, does_utility_exist, get_server, \\"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    filename_with_file_manager_path"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from pgadmin.utils.ajax import make_json_response, bad_request, \\"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    internal_server_error"
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from config import PG_DEFAULT_DRIVER"
            },
            "11": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from pgadmin.model import Server, SharedServer"
            },
            "12": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     )"
            },
            "13": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def filename_with_file_manager_path(_file):"
            },
            "16": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "17": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Args:"
            },
            "18": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file: File name returned from client file manager"
            },
            "19": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "20": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Returns:"
            },
            "21": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Filename to use for backup with full path taken from preference"
            },
            "22": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Set file manager directory from preference"
            },
            "24": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    storage_dir = get_storage_directory()"
            },
            "25": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if storage_dir:"
            },
            "27": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))"
            },
            "28": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif not os.path.isabs(_file):"
            },
            "29": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _file = os.path.join(document_dir(), _file)"
            },
            "30": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "31": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not os.path.isfile(_file) and not os.path.exists(_file):"
            },
            "32": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return None"
            },
            "33": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "34": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return fs_short_path(_file)"
            },
            "35": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "36": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "37": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " def _get_create_req_data():"
            },
            "38": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "     \"\"\""
            },
            "39": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     Get data from request for create restore job."
            },
            "40": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     try:"
            },
            "41": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         _file = filename_with_file_manager_path(data['file'])"
            },
            "42": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     except Exception as e:"
            },
            "43": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return True, bad_request(errormsg=str(e)), data"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        return True, internal_server_error(errormsg=str(e)), data, None"
            },
            "45": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     if _file is None:"
            },
            "47": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         return True, make_json_response("
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"Implements Restore Utility\"\"\"",
            "",
            "import simplejson as json",
            "import os",
            "",
            "from flask import render_template, request, current_app, \\",
            "    url_for, Response",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc",
            "from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\",
            "    fs_short_path, document_dir, does_utility_exist, get_server",
            "from pgadmin.utils.ajax import make_json_response, bad_request",
            "",
            "from config import PG_DEFAULT_DRIVER",
            "from pgadmin.model import Server, SharedServer",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "",
            "# set template path for sql scripts",
            "MODULE_NAME = 'restore'",
            "server_info = {}",
            "",
            "",
            "class RestoreModule(PgAdminModule):",
            "    \"\"\"",
            "    class RestoreModule():",
            "",
            "        It is a utility which inherits PgAdminModule",
            "        class and define methods to load its own",
            "        javascript file.",
            "    \"\"\"",
            "",
            "    LABEL = _('Restore')",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['restore.create_job', 'restore.utility_exists']",
            "",
            "",
            "# Create blueprint for RestoreModule class",
            "blueprint = RestoreModule(",
            "    MODULE_NAME, __name__, static_url_path=''",
            ")",
            "",
            "",
            "class RestoreMessage(IProcessDesc):",
            "    def __init__(self, _sid, _bfile, *_args, **_kwargs):",
            "        self.sid = _sid",
            "        self.bfile = _bfile",
            "        self.database = _kwargs['database'] if 'database' in _kwargs else None",
            "        self.cmd = ''",
            "",
            "        def cmd_arg(x):",
            "            if x:",
            "                x = x.replace('\\\\', '\\\\\\\\')",
            "                x = x.replace('\"', '\\\\\"')",
            "                x = x.replace('\"\"', '\\\\\"')",
            "                return ' \"' + x + '\"'",
            "            return ''",
            "",
            "        for arg in _args:",
            "            if arg and len(arg) >= 2 and arg[:2] == '--':",
            "                self.cmd += ' ' + arg",
            "            else:",
            "                self.cmd += cmd_arg(arg)",
            "",
            "    def get_server_name(self):",
            "        s = get_server(self.sid)",
            "",
            "        if s is None:",
            "            return _(\"Not available\")",
            "",
            "        from pgadmin.utils.driver import get_driver",
            "        driver = get_driver(PG_DEFAULT_DRIVER)",
            "        manager = driver.connection_manager(self.sid)",
            "",
            "        host = manager.local_bind_host if manager.use_ssh_tunnel else s.host",
            "        port = manager.local_bind_port if manager.use_ssh_tunnel else s.port",
            "",
            "        return \"{0} ({1}:{2})\".format(s.name, host, port)",
            "",
            "    @property",
            "    def message(self):",
            "        return _(\"Restoring backup on the server '{0}'\")\\",
            "            .format(self.get_server_name())",
            "",
            "    @property",
            "    def type_desc(self):",
            "        return _(\"Restoring backup on the server\")",
            "",
            "    def details(self, cmd, args):",
            "        return {",
            "            \"message\": self.message,",
            "            \"cmd\": cmd + self.cmd,",
            "            \"server\": self.get_server_name(),",
            "            \"object\": getattr(self, 'database', ''),",
            "            \"type\": _(\"Restore\"),",
            "        }",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/restore.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render own javascript\"\"\"",
            "    return Response(",
            "        response=render_template(",
            "            \"restore/js/restore.js\", _=_",
            "        ),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "def filename_with_file_manager_path(_file):",
            "    \"\"\"",
            "    Args:",
            "        file: File name returned from client file manager",
            "",
            "    Returns:",
            "        Filename to use for backup with full path taken from preference",
            "    \"\"\"",
            "    # Set file manager directory from preference",
            "    storage_dir = get_storage_directory()",
            "",
            "    if storage_dir:",
            "        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))",
            "    elif not os.path.isabs(_file):",
            "        _file = os.path.join(document_dir(), _file)",
            "",
            "    if not os.path.isfile(_file) and not os.path.exists(_file):",
            "        return None",
            "",
            "    return fs_short_path(_file)",
            "",
            "",
            "def _get_create_req_data():",
            "    \"\"\"",
            "    Get data from request for create restore job.",
            "    :return: return data if no error occurred.",
            "    \"\"\"",
            "    if request.form:",
            "        data = json.loads(request.form['data'], encoding='utf-8')",
            "    else:",
            "        data = json.loads(request.data, encoding='utf-8')",
            "",
            "    try:",
            "        _file = filename_with_file_manager_path(data['file'])",
            "    except Exception as e:",
            "        return True, bad_request(errormsg=str(e)), data",
            "",
            "    if _file is None:",
            "        return True, make_json_response(",
            "            status=410,",
            "            success=0,",
            "            errormsg=_(\"File could not be found.\")",
            "        ), data, _file",
            "",
            "    return False, '', data, _file",
            "",
            "",
            "def _connect_server(sid):",
            "    \"\"\"",
            "    Get server object and try to connect with it.",
            "    :param sid: Server ID.",
            "    :return: if not error occurred then return connection data.",
            "    \"\"\"",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return True, make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        ), None, None, None, None, None",
            "",
            "    # To fetch MetaData for the server",
            "    from pgadmin.utils.driver import get_driver",
            "",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "    conn = manager.connection()",
            "    connected = conn.connected()",
            "",
            "    if not connected:",
            "        return True, make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Please connect to the server first.\")",
            "        ), driver, manager, conn, connected, server",
            "",
            "    return False, '', driver, manager, conn, connected, server",
            "",
            "",
            "def set_param(key, param, data, args):",
            "    \"\"\"",
            "    check and add parameter to args list.",
            "    :param key: Key.",
            "    :param param:  Parameter to be add in the args list.",
            "    :param data: Data.",
            "    :param args: args list.",
            "    :return: Return true if key in data else return false.",
            "    \"\"\"",
            "    if key in data and data[key]:",
            "        args.append(param)",
            "        return True",
            "    return False",
            "",
            "",
            "def set_value(key, param, data, args, default_value=None):",
            "    \"\"\"",
            "    Add values to args list if key not present in data set default value.",
            "    :param key: Key.",
            "    :param param: Parameter to be add in the args list.",
            "    :param data: Data.",
            "    :param args: args list.",
            "    :param default_value:  default value flag.",
            "    :return:",
            "    \"\"\"",
            "    if key in data and data[key] is not None and data[key] != '':",
            "        args.append(param)",
            "        args.append(data[key])",
            "    elif default_value is not None:",
            "        args.append(param)",
            "        args.append(default_value)",
            "",
            "",
            "def _set_value_with_schema(data, key, args, param, driver, conn):",
            "    \"\"\"",
            "    Set value if with_schema flag is true.",
            "    :param data: Data.",
            "    :param key: Key.",
            "    :param args: args list.",
            "    :param param: parameter to be add in the args list.",
            "    :param driver: Driver.",
            "    :param conn: connection.",
            "    :return:",
            "    \"\"\"",
            "    if isinstance(data[key], list):",
            "        s, t = data[key]",
            "        args.extend([",
            "            param,",
            "            driver.qtIdent(",
            "                conn, s",
            "            ) + '.' + driver.qtIdent(conn, t)",
            "        ])",
            "    else:",
            "        for s, o in data[key]:",
            "            args.extend([",
            "                param,",
            "                driver.qtIdent(",
            "                    conn, s",
            "                ) + '.' + driver.qtIdent(conn, o)",
            "            ])",
            "",
            "",
            "def set_multiple(key, param, data, args, driver, conn, with_schema=True):",
            "    if key in data and \\",
            "            len(data[key]) > 0:",
            "        if with_schema:",
            "            # TODO:// This is temporary",
            "            # Once object tree is implemented then we will use",
            "            # list of tuples 'else' part",
            "            _set_value_with_schema(data, key, args, param, driver, conn)",
            "        else:",
            "            for o in data[key]:",
            "                args.extend([param, o])",
            "        return True",
            "    return False",
            "",
            "",
            "def _set_args_param_values(data, manager, server, driver, conn, _file):",
            "    \"\"\"",
            "    add args to the list.",
            "    :param data: Data.",
            "    :param manager: Manager.",
            "    :param server: Server.",
            "    :param driver: Driver.",
            "    :param conn: Connection.",
            "    :param _file: File.",
            "    :return: args list.",
            "    \"\"\"",
            "    args = []",
            "",
            "    if 'list' in data:",
            "        args.append('--list')",
            "    else:",
            "        args.extend([",
            "            '--host',",
            "            manager.local_bind_host if manager.use_ssh_tunnel else server.host,",
            "            '--port',",
            "            str(manager.local_bind_port) if manager.use_ssh_tunnel",
            "            else str(server.port),",
            "            '--username', server.username, '--no-password'",
            "        ])",
            "",
            "        set_value('role', '--role', data, args)",
            "        set_value('database', '--dbname', data, args)",
            "",
            "        if data['format'] == 'directory':",
            "            args.extend(['--format=d'])",
            "",
            "        set_param('pre_data', '--section=pre-data', data, args)",
            "        set_param('data', '--section=data', data, args)",
            "        set_param('post_data', '--section=post-data', data, args)",
            "",
            "        if not set_param('only_data', '--data-only', data, args):",
            "            set_param('dns_owner', '--no-owner', data, args)",
            "            set_param('dns_privilege', '--no-privileges', data, args)",
            "            set_param('dns_tablespace', '--no-tablespaces', data, args)",
            "",
            "        if not set_param('only_schema', '--schema-only', data, args):",
            "            set_param('disable_trigger', '--disable-triggers', data, args)",
            "",
            "        set_param('include_create_database', '--create', data, args)",
            "        set_param('clean', '--clean', data, args)",
            "        set_param('single_transaction', '--single-transaction', data, args)",
            "        set_param('no_data_fail_table', '--no-data-for-failed-tables', data,",
            "                  args)",
            "        set_param('use_set_session_auth', '--use-set-session-authorization',",
            "                  data, args)",
            "        set_param('exit_on_error', '--exit-on-error', data, args)",
            "",
            "        if manager.version >= 110000:",
            "            set_param('no_comments', '--no-comments', data, args)",
            "",
            "        set_value('no_of_jobs', '--jobs', data, args)",
            "        set_param('verbose', '--verbose', data, args)",
            "",
            "        set_multiple('schemas', '--schema', data, args, driver, conn, False)",
            "        set_multiple('tables', '--table', data, args, driver, conn, False)",
            "        set_multiple('functions', '--function', data, args, driver, conn,",
            "                     False)",
            "        set_multiple('triggers', '--trigger', data, args, driver, conn, False)",
            "        set_multiple('trigger_funcs', '--function', data, args, driver, conn,",
            "                     False)",
            "        set_multiple('indexes', '--index', data, args, driver, conn, False)",
            "",
            "    args.append(fs_short_path(_file))",
            "",
            "    return args",
            "",
            "",
            "@blueprint.route('/job/<int:sid>', methods=['POST'], endpoint='create_job')",
            "@login_required",
            "def create_restore_job(sid):",
            "    \"\"\"",
            "    Args:",
            "        sid: Server ID",
            "",
            "        Creates a new job for restore task",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    is_error, errmsg, data, _file = _get_create_req_data()",
            "    if is_error:",
            "        return errmsg",
            "",
            "    is_error, errmsg, driver, manager, conn, \\",
            "        connected, server = _connect_server(sid)",
            "    if is_error:",
            "        return errmsg",
            "",
            "    utility = manager.utility('restore')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    args = _set_args_param_values(data, manager, server, driver, conn, _file)",
            "",
            "    try:",
            "        p = BatchProcess(",
            "            desc=RestoreMessage(",
            "                server.id,",
            "                data['file'].encode('utf-8') if hasattr(",
            "                    data['file'], 'encode'",
            "                ) else data['file'],",
            "                *args,",
            "                database=data['database']",
            "            ),",
            "            cmd=utility, args=args",
            "        )",
            "        manager.export_password_env(p.id)",
            "        # Check for connection timeout and if it is greater than 0 then",
            "        # set the environment variable PGCONNECT_TIMEOUT.",
            "        if manager.connect_timeout > 0:",
            "            env = dict()",
            "            env['PGCONNECT_TIMEOUT'] = str(manager.connect_timeout)",
            "            p.set_env_variables(server, env=env)",
            "        else:",
            "            p.set_env_variables(server)",
            "",
            "        p.start()",
            "        jid = p.id",
            "    except Exception as e:",
            "        current_app.logger.exception(e)",
            "        return make_json_response(",
            "            status=410,",
            "            success=0,",
            "            errormsg=str(e)",
            "        )",
            "    # Return response",
            "    return make_json_response(",
            "        data={'job_id': jid, 'desc': p.desc.message, 'Success': 1}",
            "    )",
            "",
            "",
            "@blueprint.route(",
            "    '/utility_exists/<int:sid>', endpoint='utility_exists'",
            ")",
            "@login_required",
            "def check_utility_exists(sid):",
            "    \"\"\"",
            "    This function checks the utility file exist on the given path.",
            "",
            "    Args:",
            "        sid: Server ID",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    # Fetch the server details like hostname, port, roles etc",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "",
            "    utility = manager.utility('restore')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    return make_json_response(success=1)"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"Implements Restore Utility\"\"\"",
            "",
            "import simplejson as json",
            "import os",
            "",
            "from flask import render_template, request, current_app, \\",
            "    url_for, Response",
            "from flask_babel import gettext as _",
            "from flask_security import login_required, current_user",
            "from pgadmin.misc.bgprocess.processes import BatchProcess, IProcessDesc",
            "from pgadmin.utils import PgAdminModule, get_storage_directory, html, \\",
            "    fs_short_path, document_dir, does_utility_exist, get_server, \\",
            "    filename_with_file_manager_path",
            "from pgadmin.utils.ajax import make_json_response, bad_request, \\",
            "    internal_server_error",
            "",
            "from config import PG_DEFAULT_DRIVER",
            "from pgadmin.model import Server, SharedServer",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS",
            "",
            "# set template path for sql scripts",
            "MODULE_NAME = 'restore'",
            "server_info = {}",
            "",
            "",
            "class RestoreModule(PgAdminModule):",
            "    \"\"\"",
            "    class RestoreModule():",
            "",
            "        It is a utility which inherits PgAdminModule",
            "        class and define methods to load its own",
            "        javascript file.",
            "    \"\"\"",
            "",
            "    LABEL = _('Restore')",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: URL endpoints for backup module",
            "        \"\"\"",
            "        return ['restore.create_job', 'restore.utility_exists']",
            "",
            "",
            "# Create blueprint for RestoreModule class",
            "blueprint = RestoreModule(",
            "    MODULE_NAME, __name__, static_url_path=''",
            ")",
            "",
            "",
            "class RestoreMessage(IProcessDesc):",
            "    def __init__(self, _sid, _bfile, *_args, **_kwargs):",
            "        self.sid = _sid",
            "        self.bfile = _bfile",
            "        self.database = _kwargs['database'] if 'database' in _kwargs else None",
            "        self.cmd = ''",
            "",
            "        def cmd_arg(x):",
            "            if x:",
            "                x = x.replace('\\\\', '\\\\\\\\')",
            "                x = x.replace('\"', '\\\\\"')",
            "                x = x.replace('\"\"', '\\\\\"')",
            "                return ' \"' + x + '\"'",
            "            return ''",
            "",
            "        for arg in _args:",
            "            if arg and len(arg) >= 2 and arg[:2] == '--':",
            "                self.cmd += ' ' + arg",
            "            else:",
            "                self.cmd += cmd_arg(arg)",
            "",
            "    def get_server_name(self):",
            "        s = get_server(self.sid)",
            "",
            "        if s is None:",
            "            return _(\"Not available\")",
            "",
            "        from pgadmin.utils.driver import get_driver",
            "        driver = get_driver(PG_DEFAULT_DRIVER)",
            "        manager = driver.connection_manager(self.sid)",
            "",
            "        host = manager.local_bind_host if manager.use_ssh_tunnel else s.host",
            "        port = manager.local_bind_port if manager.use_ssh_tunnel else s.port",
            "",
            "        return \"{0} ({1}:{2})\".format(s.name, host, port)",
            "",
            "    @property",
            "    def message(self):",
            "        return _(\"Restoring backup on the server '{0}'\")\\",
            "            .format(self.get_server_name())",
            "",
            "    @property",
            "    def type_desc(self):",
            "        return _(\"Restoring backup on the server\")",
            "",
            "    def details(self, cmd, args):",
            "        return {",
            "            \"message\": self.message,",
            "            \"cmd\": cmd + self.cmd,",
            "            \"server\": self.get_server_name(),",
            "            \"object\": getattr(self, 'database', ''),",
            "            \"type\": _(\"Restore\"),",
            "        }",
            "",
            "",
            "@blueprint.route(\"/\")",
            "@login_required",
            "def index():",
            "    return bad_request(errormsg=_(\"This URL cannot be called directly.\"))",
            "",
            "",
            "@blueprint.route(\"/restore.js\")",
            "@login_required",
            "def script():",
            "    \"\"\"render own javascript\"\"\"",
            "    return Response(",
            "        response=render_template(",
            "            \"restore/js/restore.js\", _=_",
            "        ),",
            "        status=200,",
            "        mimetype=MIMETYPE_APP_JS",
            "    )",
            "",
            "",
            "def _get_create_req_data():",
            "    \"\"\"",
            "    Get data from request for create restore job.",
            "    :return: return data if no error occurred.",
            "    \"\"\"",
            "    if request.form:",
            "        data = json.loads(request.form['data'], encoding='utf-8')",
            "    else:",
            "        data = json.loads(request.data, encoding='utf-8')",
            "",
            "    try:",
            "        _file = filename_with_file_manager_path(data['file'])",
            "    except Exception as e:",
            "        return True, internal_server_error(errormsg=str(e)), data, None",
            "",
            "    if _file is None:",
            "        return True, make_json_response(",
            "            status=410,",
            "            success=0,",
            "            errormsg=_(\"File could not be found.\")",
            "        ), data, _file",
            "",
            "    return False, '', data, _file",
            "",
            "",
            "def _connect_server(sid):",
            "    \"\"\"",
            "    Get server object and try to connect with it.",
            "    :param sid: Server ID.",
            "    :return: if not error occurred then return connection data.",
            "    \"\"\"",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return True, make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        ), None, None, None, None, None",
            "",
            "    # To fetch MetaData for the server",
            "    from pgadmin.utils.driver import get_driver",
            "",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "    conn = manager.connection()",
            "    connected = conn.connected()",
            "",
            "    if not connected:",
            "        return True, make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Please connect to the server first.\")",
            "        ), driver, manager, conn, connected, server",
            "",
            "    return False, '', driver, manager, conn, connected, server",
            "",
            "",
            "def set_param(key, param, data, args):",
            "    \"\"\"",
            "    check and add parameter to args list.",
            "    :param key: Key.",
            "    :param param:  Parameter to be add in the args list.",
            "    :param data: Data.",
            "    :param args: args list.",
            "    :return: Return true if key in data else return false.",
            "    \"\"\"",
            "    if key in data and data[key]:",
            "        args.append(param)",
            "        return True",
            "    return False",
            "",
            "",
            "def set_value(key, param, data, args, default_value=None):",
            "    \"\"\"",
            "    Add values to args list if key not present in data set default value.",
            "    :param key: Key.",
            "    :param param: Parameter to be add in the args list.",
            "    :param data: Data.",
            "    :param args: args list.",
            "    :param default_value:  default value flag.",
            "    :return:",
            "    \"\"\"",
            "    if key in data and data[key] is not None and data[key] != '':",
            "        args.append(param)",
            "        args.append(data[key])",
            "    elif default_value is not None:",
            "        args.append(param)",
            "        args.append(default_value)",
            "",
            "",
            "def _set_value_with_schema(data, key, args, param, driver, conn):",
            "    \"\"\"",
            "    Set value if with_schema flag is true.",
            "    :param data: Data.",
            "    :param key: Key.",
            "    :param args: args list.",
            "    :param param: parameter to be add in the args list.",
            "    :param driver: Driver.",
            "    :param conn: connection.",
            "    :return:",
            "    \"\"\"",
            "    if isinstance(data[key], list):",
            "        s, t = data[key]",
            "        args.extend([",
            "            param,",
            "            driver.qtIdent(",
            "                conn, s",
            "            ) + '.' + driver.qtIdent(conn, t)",
            "        ])",
            "    else:",
            "        for s, o in data[key]:",
            "            args.extend([",
            "                param,",
            "                driver.qtIdent(",
            "                    conn, s",
            "                ) + '.' + driver.qtIdent(conn, o)",
            "            ])",
            "",
            "",
            "def set_multiple(key, param, data, args, driver, conn, with_schema=True):",
            "    if key in data and \\",
            "            len(data[key]) > 0:",
            "        if with_schema:",
            "            # TODO:// This is temporary",
            "            # Once object tree is implemented then we will use",
            "            # list of tuples 'else' part",
            "            _set_value_with_schema(data, key, args, param, driver, conn)",
            "        else:",
            "            for o in data[key]:",
            "                args.extend([param, o])",
            "        return True",
            "    return False",
            "",
            "",
            "def _set_args_param_values(data, manager, server, driver, conn, _file):",
            "    \"\"\"",
            "    add args to the list.",
            "    :param data: Data.",
            "    :param manager: Manager.",
            "    :param server: Server.",
            "    :param driver: Driver.",
            "    :param conn: Connection.",
            "    :param _file: File.",
            "    :return: args list.",
            "    \"\"\"",
            "    args = []",
            "",
            "    if 'list' in data:",
            "        args.append('--list')",
            "    else:",
            "        args.extend([",
            "            '--host',",
            "            manager.local_bind_host if manager.use_ssh_tunnel else server.host,",
            "            '--port',",
            "            str(manager.local_bind_port) if manager.use_ssh_tunnel",
            "            else str(server.port),",
            "            '--username', server.username, '--no-password'",
            "        ])",
            "",
            "        set_value('role', '--role', data, args)",
            "        set_value('database', '--dbname', data, args)",
            "",
            "        if data['format'] == 'directory':",
            "            args.extend(['--format=d'])",
            "",
            "        set_param('pre_data', '--section=pre-data', data, args)",
            "        set_param('data', '--section=data', data, args)",
            "        set_param('post_data', '--section=post-data', data, args)",
            "",
            "        if not set_param('only_data', '--data-only', data, args):",
            "            set_param('dns_owner', '--no-owner', data, args)",
            "            set_param('dns_privilege', '--no-privileges', data, args)",
            "            set_param('dns_tablespace', '--no-tablespaces', data, args)",
            "",
            "        if not set_param('only_schema', '--schema-only', data, args):",
            "            set_param('disable_trigger', '--disable-triggers', data, args)",
            "",
            "        set_param('include_create_database', '--create', data, args)",
            "        set_param('clean', '--clean', data, args)",
            "        set_param('single_transaction', '--single-transaction', data, args)",
            "        set_param('no_data_fail_table', '--no-data-for-failed-tables', data,",
            "                  args)",
            "        set_param('use_set_session_auth', '--use-set-session-authorization',",
            "                  data, args)",
            "        set_param('exit_on_error', '--exit-on-error', data, args)",
            "",
            "        if manager.version >= 110000:",
            "            set_param('no_comments', '--no-comments', data, args)",
            "",
            "        set_value('no_of_jobs', '--jobs', data, args)",
            "        set_param('verbose', '--verbose', data, args)",
            "",
            "        set_multiple('schemas', '--schema', data, args, driver, conn, False)",
            "        set_multiple('tables', '--table', data, args, driver, conn, False)",
            "        set_multiple('functions', '--function', data, args, driver, conn,",
            "                     False)",
            "        set_multiple('triggers', '--trigger', data, args, driver, conn, False)",
            "        set_multiple('trigger_funcs', '--function', data, args, driver, conn,",
            "                     False)",
            "        set_multiple('indexes', '--index', data, args, driver, conn, False)",
            "",
            "    args.append(fs_short_path(_file))",
            "",
            "    return args",
            "",
            "",
            "@blueprint.route('/job/<int:sid>', methods=['POST'], endpoint='create_job')",
            "@login_required",
            "def create_restore_job(sid):",
            "    \"\"\"",
            "    Args:",
            "        sid: Server ID",
            "",
            "        Creates a new job for restore task",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    is_error, errmsg, data, _file = _get_create_req_data()",
            "    if is_error:",
            "        return errmsg",
            "",
            "    is_error, errmsg, driver, manager, conn, \\",
            "        connected, server = _connect_server(sid)",
            "    if is_error:",
            "        return errmsg",
            "",
            "    utility = manager.utility('restore')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    args = _set_args_param_values(data, manager, server, driver, conn, _file)",
            "",
            "    try:",
            "        p = BatchProcess(",
            "            desc=RestoreMessage(",
            "                server.id,",
            "                data['file'].encode('utf-8') if hasattr(",
            "                    data['file'], 'encode'",
            "                ) else data['file'],",
            "                *args,",
            "                database=data['database']",
            "            ),",
            "            cmd=utility, args=args",
            "        )",
            "        manager.export_password_env(p.id)",
            "        # Check for connection timeout and if it is greater than 0 then",
            "        # set the environment variable PGCONNECT_TIMEOUT.",
            "        if manager.connect_timeout > 0:",
            "            env = dict()",
            "            env['PGCONNECT_TIMEOUT'] = str(manager.connect_timeout)",
            "            p.set_env_variables(server, env=env)",
            "        else:",
            "            p.set_env_variables(server)",
            "",
            "        p.start()",
            "        jid = p.id",
            "    except Exception as e:",
            "        current_app.logger.exception(e)",
            "        return make_json_response(",
            "            status=410,",
            "            success=0,",
            "            errormsg=str(e)",
            "        )",
            "    # Return response",
            "    return make_json_response(",
            "        data={'job_id': jid, 'desc': p.desc.message, 'Success': 1}",
            "    )",
            "",
            "",
            "@blueprint.route(",
            "    '/utility_exists/<int:sid>', endpoint='utility_exists'",
            ")",
            "@login_required",
            "def check_utility_exists(sid):",
            "    \"\"\"",
            "    This function checks the utility file exist on the given path.",
            "",
            "    Args:",
            "        sid: Server ID",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    # Fetch the server details like hostname, port, roles etc",
            "    server = get_server(sid)",
            "",
            "    if server is None:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=_(\"Could not find the specified server.\")",
            "        )",
            "",
            "    from pgadmin.utils.driver import get_driver",
            "    driver = get_driver(PG_DEFAULT_DRIVER)",
            "    manager = driver.connection_manager(server.id)",
            "",
            "    utility = manager.utility('restore')",
            "    ret_val = does_utility_exist(utility)",
            "    if ret_val:",
            "        return make_json_response(",
            "            success=0,",
            "            errormsg=ret_val",
            "        )",
            "",
            "    return make_json_response(success=1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [],
            "22": [],
            "132": [
                "filename_with_file_manager_path"
            ],
            "133": [
                "filename_with_file_manager_path"
            ],
            "134": [
                "filename_with_file_manager_path"
            ],
            "135": [
                "filename_with_file_manager_path"
            ],
            "136": [
                "filename_with_file_manager_path"
            ],
            "137": [
                "filename_with_file_manager_path"
            ],
            "138": [
                "filename_with_file_manager_path"
            ],
            "139": [
                "filename_with_file_manager_path"
            ],
            "140": [
                "filename_with_file_manager_path"
            ],
            "141": [
                "filename_with_file_manager_path"
            ],
            "142": [
                "filename_with_file_manager_path"
            ],
            "143": [
                "filename_with_file_manager_path"
            ],
            "144": [
                "filename_with_file_manager_path"
            ],
            "145": [
                "filename_with_file_manager_path"
            ],
            "146": [
                "filename_with_file_manager_path"
            ],
            "147": [
                "filename_with_file_manager_path"
            ],
            "148": [
                "filename_with_file_manager_path"
            ],
            "149": [
                "filename_with_file_manager_path"
            ],
            "150": [
                "filename_with_file_manager_path"
            ],
            "151": [
                "filename_with_file_manager_path"
            ],
            "152": [],
            "153": [],
            "167": [
                "_get_create_req_data"
            ]
        },
        "addLocation": []
    },
    "web/pgadmin/utils/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         return file"
            },
            "1": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 261,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 262,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+def filename_with_file_manager_path(_file, create_file=False,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                                    skip_permission_check=False):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+    \"\"\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+    Args:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+        file: File name returned from client file manager"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        create_file: Set flag to False when file creation doesn't required"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+    Returns:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        Filename to use for backup with full path taken from preference"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+    \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+    # Set file manager directory from preference"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    storage_dir = get_storage_directory()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    from pgadmin.misc.file_manager import Filemanager"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+    Filemanager.check_access_permission("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+        storage_dir, _file, skip_permission_check)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+    if storage_dir:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+    elif not os.path.isabs(_file):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+        _file = os.path.join(document_dir(), _file)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+    def short_filepath():"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        short_path = fs_short_path(_file)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+        # fs_short_path() function may return empty path on Windows"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        # if directory doesn't exists. In that case we strip the last path"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+        # component and get the short path."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        if os.name == 'nt' and short_path == '':"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+            base_name = os.path.basename(_file)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+            dir_name = os.path.dirname(_file)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+            short_path = fs_short_path(dir_name) + '\\\\' + base_name"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+        return short_path"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+    if create_file:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+        # Touch the file to get the short path of the file on windows."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+        with open(_file, 'a'):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+            return short_filepath()"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+    return short_filepath()"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 302,
                "PatchRowcode": " def does_utility_exist(file):"
            },
            "43": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "     \"\"\""
            },
            "44": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "     This function will check the utility file exists on given path."
            },
            "45": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 473,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 474,
                "PatchRowcode": "     object_dict[\"Servers\"] = server_dict"
            },
            "47": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 475,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # retrieve storage directory path"
            },
            "49": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    storage_manager_path = None"
            },
            "50": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not from_setup:"
            },
            "51": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        storage_manager_path = get_storage_directory(user)"
            },
            "52": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "53": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # generate full path of file"
            },
            "54": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    file_path = unquote(output_file)"
            },
            "55": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "56": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from pgadmin.misc.file_manager import Filemanager"
            },
            "57": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 476,
                "PatchRowcode": "     try:"
            },
            "58": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Filemanager.check_access_permission(storage_manager_path, file_path,"
            },
            "59": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                            from_setup)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+        file_path = filename_with_file_manager_path("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+            unquote(output_file), skip_permission_check=from_setup)"
            },
            "62": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 479,
                "PatchRowcode": "     except Exception as e:"
            },
            "63": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "         return _handle_error(str(e), from_setup)"
            },
            "64": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 481,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if storage_manager_path is not None:"
            },
            "66": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file_path = os.path.join("
            },
            "67": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            storage_manager_path,"
            },
            "68": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file_path.lstrip('/').lstrip('\\\\')"
            },
            "69": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "70": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "71": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 482,
                "PatchRowcode": "     # write to file"
            },
            "72": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 483,
                "PatchRowcode": "     file_content = json.dumps(object_dict, indent=4)"
            },
            "73": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 484,
                "PatchRowcode": "     error_str = \"Error: {0}\""
            },
            "74": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "     if user is None:"
            },
            "75": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "         return False, USER_NOT_FOUND % load_user"
            },
            "76": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 574,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # retrieve storage directory path"
            },
            "78": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    storage_manager_path = None"
            },
            "79": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not from_setup:"
            },
            "80": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        storage_manager_path = get_storage_directory(user)"
            },
            "81": {
                "beforePatchRowNumber": 555,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "82": {
                "beforePatchRowNumber": 556,
                "afterPatchRowNumber": 575,
                "PatchRowcode": "     # generate full path of file"
            },
            "83": {
                "beforePatchRowNumber": 557,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    file_path = unquote(input_file)"
            },
            "84": {
                "beforePatchRowNumber": 558,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if storage_manager_path:"
            },
            "85": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # generate full path of file"
            },
            "86": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file_path = os.path.join("
            },
            "87": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            storage_manager_path,"
            },
            "88": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file_path.lstrip('/').lstrip('\\\\')"
            },
            "89": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+    try:"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 577,
                "PatchRowcode": "+        file_path = filename_with_file_manager_path("
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 578,
                "PatchRowcode": "+            unquote(input_file), skip_permission_check=from_setup)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 579,
                "PatchRowcode": "+    except Exception as e:"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 580,
                "PatchRowcode": "+        return _handle_error(str(e), from_setup)"
            },
            "95": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 581,
                "PatchRowcode": " "
            },
            "96": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 582,
                "PatchRowcode": "     try:"
            },
            "97": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 583,
                "PatchRowcode": "         with open(file_path) as f:"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import os",
            "import sys",
            "import json",
            "import subprocess",
            "from collections import defaultdict",
            "from operator import attrgetter",
            "",
            "from flask import Blueprint, current_app, url_for",
            "from flask_babel import gettext",
            "from flask_security import current_user, login_required",
            "from flask_security.utils import get_post_login_redirect",
            "from threading import Lock",
            "",
            "from .paths import get_storage_directory",
            "from .preferences import Preferences",
            "from pgadmin.utils.constants import UTILITIES_ARRAY, USER_NOT_FOUND",
            "from pgadmin.model import db, User, ServerGroup, Server",
            "from urllib.parse import unquote",
            "",
            "ADD_SERVERS_MSG = \"Added %d Server Group(s) and %d Server(s).\"",
            "",
            "",
            "class PgAdminModule(Blueprint):",
            "    \"\"\"",
            "    Base class for every PgAdmin Module.",
            "",
            "    This class defines a set of method and attributes that",
            "    every module should implement.",
            "    \"\"\"",
            "",
            "    def __init__(self, name, import_name, **kwargs):",
            "        kwargs.setdefault('url_prefix', '/' + name)",
            "        kwargs.setdefault('template_folder', 'templates')",
            "        kwargs.setdefault('static_folder', 'static')",
            "        self.submodules = []",
            "        self.parentmodules = []",
            "",
            "        super().__init__(name, import_name, **kwargs)",
            "",
            "        def create_module_preference():",
            "            # Create preference for each module by default",
            "            if hasattr(self, 'LABEL'):",
            "                self.preference = Preferences(self.name, self.LABEL)",
            "            else:",
            "                self.preference = Preferences(self.name, None)",
            "",
            "            self.register_preferences()",
            "",
            "        # Create and register the module preference object and preferences for",
            "        # it just before the first request",
            "        self.before_app_first_request(create_module_preference)",
            "",
            "    def register_preferences(self):",
            "        # To be implemented by child classes",
            "        pass",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "",
            "        super().register(app, options)",
            "",
            "        for module in self.submodules:",
            "            module.parentmodules.append(self)",
            "            if app.blueprints.get(module.name) is None:",
            "                app.register_blueprint(module)",
            "                app.register_logout_hook(module)",
            "",
            "    def get_own_stylesheets(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: the stylesheets used by this module, not including any",
            "                stylesheet needed by the submodules.",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_own_messages(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the i18n messages used by this module, not including any",
            "                messages needed by the submodules.",
            "        \"\"\"",
            "        return dict()",
            "",
            "    def get_own_menuitems(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the menuitems for this module, not including",
            "                any needed from the submodules.",
            "        \"\"\"",
            "        return defaultdict(list)",
            "",
            "    def get_panels(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of panel objects to add",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    def stylesheets(self):",
            "        stylesheets = self.get_own_stylesheets()",
            "        for module in self.submodules:",
            "            stylesheets.extend(module.stylesheets)",
            "        return stylesheets",
            "",
            "    @property",
            "    def messages(self):",
            "        res = self.get_own_messages()",
            "",
            "        for module in self.submodules:",
            "            res.update(module.messages)",
            "        return res",
            "",
            "    @property",
            "    def menu_items(self):",
            "        menu_items = self.get_own_menuitems()",
            "        for module in self.submodules:",
            "            for key, value in module.menu_items.items():",
            "                menu_items[key].extend(value)",
            "        menu_items = dict((key, sorted(value, key=attrgetter('priority')))",
            "                          for key, value in menu_items.items())",
            "        return menu_items",
            "",
            "    @property",
            "    def exposed_endpoints(self):",
            "        res = self.get_exposed_url_endpoints()",
            "",
            "        for module in self.submodules:",
            "            res += module.exposed_endpoints",
            "",
            "        return res",
            "",
            "",
            "IS_WIN = (os.name == 'nt')",
            "",
            "sys_encoding = sys.getdefaultencoding()",
            "if not sys_encoding or sys_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the default encoding,",
            "    # or 'ascii'.",
            "    sys_encoding = 'utf-8'",
            "",
            "fs_encoding = sys.getfilesystemencoding()",
            "if not fs_encoding or fs_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the file-system encoding,",
            "    # or 'ascii'.",
            "    fs_encoding = 'utf-8'",
            "",
            "",
            "def u_encode(_s, _encoding=sys_encoding):",
            "    return _s",
            "",
            "",
            "def file_quote(_p):",
            "    return _p",
            "",
            "",
            "if IS_WIN:",
            "    import ctypes",
            "    from ctypes import wintypes",
            "",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    _GetShortPathNameW = ctypes.windll.kernel32.GetShortPathNameW",
            "    _GetShortPathNameW.argtypes = [",
            "        wintypes.LPCWSTR, wintypes.LPWSTR, wintypes.DWORD",
            "    ]",
            "    _GetShortPathNameW.restype = wintypes.DWORD",
            "",
            "    def fs_short_path(_path):",
            "        \"\"\"",
            "        Gets the short path name of a given long path.",
            "        http://stackoverflow.com/a/23598461/200291",
            "        \"\"\"",
            "        buf_size = len(_path)",
            "        while True:",
            "            res = ctypes.create_unicode_buffer(buf_size)",
            "            # Note:- _GetShortPathNameW may return empty value",
            "            # if directory doesn't exist.",
            "            needed = _GetShortPathNameW(_path, res, buf_size)",
            "",
            "            if buf_size >= needed:",
            "                return res.value",
            "            else:",
            "                buf_size += needed",
            "",
            "    def document_dir():",
            "        CSIDL_PERSONAL = 5  # My Documents",
            "        SHGFP_TYPE_CURRENT = 0  # Get current, not default value",
            "",
            "        buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH)",
            "        ctypes.windll.shell32.SHGetFolderPathW(",
            "            None, CSIDL_PERSONAL, None, SHGFP_TYPE_CURRENT, buf",
            "        )",
            "",
            "        return buf.value",
            "",
            "else:",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    def fs_short_path(_path):",
            "        return _path",
            "",
            "    def document_dir():",
            "        return os.path.realpath(os.path.expanduser('~/'))",
            "",
            "",
            "def get_complete_file_path(file, validate=True):",
            "    \"\"\"",
            "    Args:",
            "        file: File returned by file manager",
            "",
            "    Returns:",
            "         Full path for the file",
            "    \"\"\"",
            "    if not file:",
            "        return None",
            "",
            "    # If desktop mode",
            "    if current_app.PGADMIN_RUNTIME or not current_app.config['SERVER_MODE']:",
            "        return file if os.path.isfile(file) else None",
            "",
            "    storage_dir = get_storage_directory()",
            "    if storage_dir:",
            "        file = os.path.join(",
            "            storage_dir,",
            "            file.lstrip('/').lstrip('\\\\')",
            "        )",
            "        if IS_WIN:",
            "            file = file.replace('\\\\', '/')",
            "            file = fs_short_path(file)",
            "",
            "    if validate:",
            "        return file if os.path.isfile(file) else None",
            "    else:",
            "        return file",
            "",
            "",
            "def does_utility_exist(file):",
            "    \"\"\"",
            "    This function will check the utility file exists on given path.",
            "    :return:",
            "    \"\"\"",
            "    error_msg = None",
            "    if file is None:",
            "        error_msg = gettext(\"Utility file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\")",
            "        return error_msg",
            "",
            "    if not os.path.exists(file):",
            "        error_msg = gettext(\"'%s' file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\" % file)",
            "    return error_msg",
            "",
            "",
            "def get_server(sid):",
            "    \"\"\"",
            "    # Fetch the server  etc",
            "    :param sid:",
            "    :return: server",
            "    \"\"\"",
            "    server = Server.query.filter_by(id=sid).first()",
            "    return server",
            "",
            "",
            "def set_binary_path(binary_path, bin_paths, server_type,",
            "                    version_number=None, set_as_default=False):",
            "    \"\"\"",
            "    This function is used to iterate through the utilities and set the",
            "    default binary path.",
            "    \"\"\"",
            "    path_with_dir = binary_path if \"$DIR\" in binary_path else None",
            "",
            "    # Check if \"$DIR\" present in binary path",
            "    binary_path = replace_binary_path(binary_path)",
            "",
            "    for utility in UTILITIES_ARRAY:",
            "        full_path = os.path.abspath(",
            "            os.path.join(binary_path, (utility if os.name != 'nt' else",
            "                                       (utility + '.exe'))))",
            "",
            "        try:",
            "            # if version_number is provided then no need to fetch it.",
            "            if version_number is None:",
            "                # Get the output of the '--version' command",
            "                version_string = \\",
            "                    subprocess.getoutput('\"{0}\" --version'.format(full_path))",
            "",
            "                # Get the version number by splitting the result string",
            "                version_number = \\",
            "                    version_string.split(\") \", 1)[1].split('.', 1)[0]",
            "            elif version_number.find('.'):",
            "                version_number = version_number.split('.', 1)[0]",
            "",
            "            # Get the paths array based on server type",
            "            if 'pg_bin_paths' in bin_paths or 'as_bin_paths' in bin_paths:",
            "                paths_array = bin_paths['pg_bin_paths']",
            "                if server_type == 'ppas':",
            "                    paths_array = bin_paths['as_bin_paths']",
            "            else:",
            "                paths_array = bin_paths",
            "",
            "            for path in paths_array:",
            "                if path['version'].find(version_number) == 0 and \\",
            "                        path['binaryPath'] is None:",
            "                    path['binaryPath'] = path_with_dir \\",
            "                        if path_with_dir is not None else binary_path",
            "                    if set_as_default:",
            "                        path['isDefault'] = True",
            "                    break",
            "            break",
            "        except Exception:",
            "            continue",
            "",
            "",
            "def replace_binary_path(binary_path):",
            "    \"\"\"",
            "    This function is used to check if $DIR is present in",
            "    the binary path. If it is there then replace it with",
            "    module.",
            "    \"\"\"",
            "    if \"$DIR\" in binary_path:",
            "        # When running as an WSGI application, we will not find the",
            "        # '__file__' attribute for the '__main__' module.",
            "        main_module_file = getattr(",
            "            sys.modules['__main__'], '__file__', None",
            "        )",
            "",
            "        if main_module_file is not None:",
            "            binary_path = binary_path.replace(",
            "                \"$DIR\", os.path.dirname(main_module_file)",
            "            )",
            "",
            "    return binary_path",
            "",
            "",
            "def add_value(attr_dict, key, value):",
            "    \"\"\"Add a value to the attribute dict if non-empty.",
            "",
            "    Args:",
            "        attr_dict (dict): The dictionary to add the values to",
            "        key (str): The key for the new value",
            "        value (str): The value to add",
            "",
            "    Returns:",
            "        The updated attribute dictionary",
            "    \"\"\"",
            "    if value != \"\" and value is not None:",
            "        attr_dict[key] = value",
            "",
            "    return attr_dict",
            "",
            "",
            "def dump_database_servers(output_file, selected_servers,",
            "                          dump_user=current_user, from_setup=False):",
            "    \"\"\"Dump the server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(dump_user, from_setup)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % dump_user",
            "",
            "    user_id = user.id",
            "    # Dict to collect the output",
            "    object_dict = {}",
            "    # Counters",
            "    servers_dumped = 0",
            "",
            "    # Dump servers",
            "    servers = Server.query.filter_by(user_id=user_id).all()",
            "    server_dict = {}",
            "    for server in servers:",
            "        if selected_servers is None or str(server.id) in selected_servers:",
            "            # Get the group name",
            "            group_name = ServerGroup.query.filter_by(",
            "                user_id=user_id, id=server.servergroup_id).first().name",
            "",
            "            attr_dict = {}",
            "            add_value(attr_dict, \"Name\", server.name)",
            "            add_value(attr_dict, \"Group\", group_name)",
            "            add_value(attr_dict, \"Host\", server.host)",
            "            add_value(attr_dict, \"HostAddr\", server.hostaddr)",
            "            add_value(attr_dict, \"Port\", server.port)",
            "            add_value(attr_dict, \"MaintenanceDB\", server.maintenance_db)",
            "            add_value(attr_dict, \"Username\", server.username)",
            "            add_value(attr_dict, \"Role\", server.role)",
            "            add_value(attr_dict, \"SSLMode\", server.ssl_mode)",
            "            add_value(attr_dict, \"Comment\", server.comment)",
            "            add_value(attr_dict, \"Shared\", server.shared)",
            "            add_value(attr_dict, \"DBRestriction\", server.db_res)",
            "            add_value(attr_dict, \"PassFile\", server.passfile)",
            "            add_value(attr_dict, \"SSLCert\", server.sslcert)",
            "            add_value(attr_dict, \"SSLKey\", server.sslkey)",
            "            add_value(attr_dict, \"SSLRootCert\", server.sslrootcert)",
            "            add_value(attr_dict, \"SSLCrl\", server.sslcrl)",
            "            add_value(attr_dict, \"SSLCompression\", server.sslcompression)",
            "            add_value(attr_dict, \"BGColor\", server.bgcolor)",
            "            add_value(attr_dict, \"FGColor\", server.fgcolor)",
            "            add_value(attr_dict, \"Service\", server.service)",
            "            add_value(attr_dict, \"Timeout\", server.connect_timeout)",
            "            add_value(attr_dict, \"UseSSHTunnel\", server.use_ssh_tunnel)",
            "            add_value(attr_dict, \"TunnelHost\", server.tunnel_host)",
            "            add_value(attr_dict, \"TunnelPort\", server.tunnel_port)",
            "            add_value(attr_dict, \"TunnelUsername\", server.tunnel_username)",
            "            add_value(attr_dict, \"TunnelAuthentication\",",
            "                      server.tunnel_authentication)",
            "",
            "            servers_dumped = servers_dumped + 1",
            "",
            "            server_dict[servers_dumped] = attr_dict",
            "",
            "    object_dict[\"Servers\"] = server_dict",
            "",
            "    # retrieve storage directory path",
            "    storage_manager_path = None",
            "    if not from_setup:",
            "        storage_manager_path = get_storage_directory(user)",
            "",
            "    # generate full path of file",
            "    file_path = unquote(output_file)",
            "",
            "    from pgadmin.misc.file_manager import Filemanager",
            "    try:",
            "        Filemanager.check_access_permission(storage_manager_path, file_path,",
            "                                            from_setup)",
            "    except Exception as e:",
            "        return _handle_error(str(e), from_setup)",
            "",
            "    if storage_manager_path is not None:",
            "        file_path = os.path.join(",
            "            storage_manager_path,",
            "            file_path.lstrip('/').lstrip('\\\\')",
            "        )",
            "",
            "    # write to file",
            "    file_content = json.dumps(object_dict, indent=4)",
            "    error_str = \"Error: {0}\"",
            "    try:",
            "        with open(file_path, 'w') as output_file:",
            "            output_file.write(file_content)",
            "    except IOError as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "    except Exception as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "",
            "    msg = gettext(\"Configuration for %s servers dumped to %s\" %",
            "                  (servers_dumped, output_file.name))",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def validate_json_data(data, is_admin):",
            "    \"\"\"",
            "    Used internally by load_servers to validate servers data.",
            "    :param data: servers data",
            "    :param is_admin:",
            "    :return: error message if any",
            "    \"\"\"",
            "    skip_servers = []",
            "    # Loop through the servers...",
            "    if \"Servers\" not in data:",
            "        return gettext(\"'Servers' attribute not found in the specified file.\")",
            "",
            "    for server in data[\"Servers\"]:",
            "        obj = data[\"Servers\"][server]",
            "",
            "        # Check if server is shared.Won't import if user is non-admin",
            "        if obj.get('Shared', None) and not is_admin:",
            "            print(\"Won't import the server '%s' as it is shared \" %",
            "                  obj[\"Name\"])",
            "            skip_servers.append(server)",
            "            continue",
            "",
            "        def check_attrib(attrib):",
            "            if attrib not in obj:",
            "                return gettext(\"'%s' attribute not found for server '%s'\" %",
            "                               (attrib, server))",
            "            return None",
            "",
            "        def check_is_integer(value):",
            "            if not isinstance(value, int):",
            "                return gettext(\"Port must be integer for server '%s'\" % server)",
            "            return None",
            "",
            "        for attrib in (\"Group\", \"Name\"):",
            "            errmsg = check_attrib(attrib)",
            "            if errmsg:",
            "                return errmsg",
            "",
            "        is_service_attrib_available = obj.get(\"Service\", None) is not None",
            "",
            "        if not is_service_attrib_available:",
            "            for attrib in (\"Port\", \"Username\"):",
            "                errmsg = check_attrib(attrib)",
            "                if errmsg:",
            "                    return errmsg",
            "                if attrib == 'Port':",
            "                    errmsg = check_is_integer(obj[attrib])",
            "                    if errmsg:",
            "                        return errmsg",
            "",
            "        for attrib in (\"SSLMode\", \"MaintenanceDB\"):",
            "            errmsg = check_attrib(attrib)",
            "            if errmsg:",
            "                return errmsg",
            "",
            "        if \"Host\" not in obj and \"HostAddr\" not in obj and not \\",
            "                is_service_attrib_available:",
            "            return gettext(\"'Host', 'HostAddr' or 'Service' attribute not \"",
            "                           \"found for server '%s'\" % server)",
            "",
            "    for server in skip_servers:",
            "        del data[\"Servers\"][server]",
            "    return None",
            "",
            "",
            "def load_database_servers(input_file, selected_servers,",
            "                          load_user=current_user, from_setup=False):",
            "    \"\"\"Load server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % load_user",
            "",
            "    # retrieve storage directory path",
            "    storage_manager_path = None",
            "    if not from_setup:",
            "        storage_manager_path = get_storage_directory(user)",
            "",
            "    # generate full path of file",
            "    file_path = unquote(input_file)",
            "    if storage_manager_path:",
            "        # generate full path of file",
            "        file_path = os.path.join(",
            "            storage_manager_path,",
            "            file_path.lstrip('/').lstrip('\\\\')",
            "        )",
            "",
            "    try:",
            "        with open(file_path) as f:",
            "            data = json.load(f)",
            "    except json.decoder.JSONDecodeError as e:",
            "        return _handle_error(gettext(\"Error parsing input file %s: %s\" %",
            "                             (file_path, e)), from_setup)",
            "    except Exception as e:",
            "        return _handle_error(gettext(\"Error reading input file %s: [%d] %s\" %",
            "                             (file_path, e.errno, e.strerror)), from_setup)",
            "",
            "    f.close()",
            "",
            "    user_id = user.id",
            "    # Counters",
            "    groups_added = 0",
            "    servers_added = 0",
            "",
            "    # Get the server groups",
            "    groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "    # Validate server data",
            "    error_msg = validate_json_data(data, user.has_role(\"Administrator\"))",
            "    if error_msg is not None and from_setup:",
            "        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "        return _handle_error(error_msg, from_setup)",
            "",
            "    for server in data[\"Servers\"]:",
            "        if selected_servers is None or str(server) in selected_servers:",
            "            obj = data[\"Servers\"][server]",
            "",
            "            # Get the group. Create if necessary",
            "            group_id = next(",
            "                (g.id for g in groups if g.name == obj[\"Group\"]), -1)",
            "",
            "            if group_id == -1:",
            "                new_group = ServerGroup()",
            "                new_group.name = obj[\"Group\"]",
            "                new_group.user_id = user_id",
            "                db.session.add(new_group)",
            "",
            "                try:",
            "                    db.session.commit()",
            "                except Exception as e:",
            "                    if from_setup:",
            "                        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                    return _handle_error(",
            "                        gettext(\"Error creating server group '%s': %s\" %",
            "                                (new_group.name, e)), from_setup)",
            "",
            "                group_id = new_group.id",
            "                groups_added = groups_added + 1",
            "                groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "            # Create the server",
            "            new_server = Server()",
            "            new_server.name = obj[\"Name\"]",
            "            new_server.servergroup_id = group_id",
            "            new_server.user_id = user_id",
            "            new_server.ssl_mode = obj[\"SSLMode\"]",
            "            new_server.maintenance_db = obj[\"MaintenanceDB\"]",
            "",
            "            new_server.host = obj.get(\"Host\", None)",
            "",
            "            new_server.hostaddr = obj.get(\"HostAddr\", None)",
            "",
            "            new_server.port = obj.get(\"Port\", None)",
            "",
            "            new_server.username = obj.get(\"Username\", None)",
            "",
            "            new_server.role = obj.get(\"Role\", None)",
            "",
            "            new_server.ssl_mode = obj[\"SSLMode\"]",
            "",
            "            new_server.comment = obj.get(\"Comment\", None)",
            "",
            "            new_server.db_res = obj.get(\"DBRestriction\", None)",
            "",
            "            new_server.passfile = obj.get(\"PassFile\", None)",
            "",
            "            new_server.sslcert = obj.get(\"SSLCert\", None)",
            "",
            "            new_server.sslkey = obj.get(\"SSLKey\", None)",
            "",
            "            new_server.sslrootcert = obj.get(\"SSLRootCert\", None)",
            "",
            "            new_server.sslcrl = obj.get(\"SSLCrl\", None)",
            "",
            "            new_server.sslcompression = obj.get(\"SSLCompression\", None)",
            "",
            "            new_server.bgcolor = obj.get(\"BGColor\", None)",
            "",
            "            new_server.fgcolor = obj.get(\"FGColor\", None)",
            "",
            "            new_server.service = obj.get(\"Service\", None)",
            "",
            "            new_server.connect_timeout = obj.get(\"Timeout\", None)",
            "",
            "            new_server.use_ssh_tunnel = obj.get(\"UseSSHTunnel\", None)",
            "",
            "            new_server.tunnel_host = obj.get(\"TunnelHost\", None)",
            "",
            "            new_server.tunnel_port = obj.get(\"TunnelPort\", None)",
            "",
            "            new_server.tunnel_username = obj.get(\"TunnelUsername\", None)",
            "",
            "            new_server.tunnel_authentication = \\",
            "                obj.get(\"TunnelAuthentication\", None)",
            "",
            "            new_server.shared = \\",
            "                obj.get(\"Shared\", None)",
            "",
            "            db.session.add(new_server)",
            "",
            "            try:",
            "                db.session.commit()",
            "            except Exception as e:",
            "                if from_setup:",
            "                    print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                return _handle_error(gettext(\"Error creating server '%s': %s\" %",
            "                                             (new_server.name, e)), from_setup)",
            "",
            "            servers_added = servers_added + 1",
            "",
            "    msg = ADD_SERVERS_MSG % (groups_added, servers_added)",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def clear_database_servers(load_user=current_user, from_setup=False):",
            "    \"\"\"Clear groups and servers configurations.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup)",
            "    if user is None:",
            "        return False",
            "",
            "    user_id = user.id",
            "",
            "    # Remove all servers",
            "    servers = Server.query.filter_by(user_id=user_id)",
            "    for server in servers:",
            "        db.session.delete(server)",
            "",
            "    # Remove all groups",
            "    groups = ServerGroup.query.filter_by(user_id=user_id)",
            "    for group in groups:",
            "        db.session.delete(group)",
            "    servers = Server.query.filter_by(user_id=user_id)",
            "",
            "    for server in servers:",
            "        db.session.delete(server)",
            "",
            "    try:",
            "        db.session.commit()",
            "    except Exception as e:",
            "        error_msg = \\",
            "            gettext(\"Error clearing server configuration with error (%s)\" %",
            "                    str(e))",
            "        if from_setup:",
            "            print(error_msg)",
            "            sys.exit(1)",
            "",
            "        return False, error_msg",
            "",
            "",
            "def _does_user_exist(user, from_setup):",
            "    \"\"\"",
            "    This function will check user is exist or not. If exist then return",
            "    \"\"\"",
            "    if isinstance(user, User):",
            "        user = user.email",
            "",
            "    new_user = User.query.filter_by(email=user).first()",
            "",
            "    if new_user is None:",
            "        print(USER_NOT_FOUND % user)",
            "        if from_setup:",
            "            sys.exit(1)",
            "",
            "    return new_user",
            "",
            "",
            "def _handle_error(error_msg, from_setup):",
            "    \"\"\"",
            "    This function is used to print the error msg and exit from app if",
            "    called from setup.py",
            "    \"\"\"",
            "    if from_setup:",
            "        print(error_msg)",
            "        sys.exit(1)",
            "",
            "    return False, error_msg",
            "",
            "",
            "# Shortcut configuration for Accesskey",
            "ACCESSKEY_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    }",
            "]",
            "",
            "# Shortcut configuration",
            "SHORTCUT_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    },",
            "    {",
            "        'name': 'shift',",
            "        'type': 'checkbox',",
            "        'label': gettext('Shift')",
            "    },",
            "",
            "    {",
            "        'name': 'control',",
            "        'type': 'checkbox',",
            "        'label': gettext('Ctrl')",
            "    },",
            "    {",
            "        'name': 'alt',",
            "        'type': 'checkbox',",
            "        'label': gettext('Alt/Option')",
            "    }",
            "]",
            "",
            "",
            "class KeyManager:",
            "    def __init__(self):",
            "        self.users = dict()",
            "        self.lock = Lock()",
            "",
            "    @login_required",
            "    def get(self):",
            "        user = self.users.get(current_user.id, None)",
            "        if user is not None:",
            "            return user.get('key', None)",
            "",
            "    @login_required",
            "    def set(self, _key, _new_login=True):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "            if user is None:",
            "                self.users[current_user.id] = dict(",
            "                    session_count=1, key=_key)",
            "            else:",
            "                if _new_login:",
            "                    user['session_count'] += 1",
            "                user['key'] = _key",
            "",
            "    @login_required",
            "    def reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                # This will not decrement if session expired",
            "                user['session_count'] -= 1",
            "                if user['session_count'] == 0:",
            "                    del self.users[current_user.id]",
            "",
            "    @login_required",
            "    def hard_reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                del self.users[current_user.id]",
            "",
            "",
            "def get_safe_post_login_redirect():",
            "    allow_list = [",
            "        url_for('browser.index')",
            "    ]",
            "    if \"SCRIPT_NAME\" in os.environ and os.environ[\"SCRIPT_NAME\"]:",
            "        allow_list.append(os.environ[\"SCRIPT_NAME\"])",
            "",
            "    url = get_post_login_redirect()",
            "    for item in allow_list:",
            "        if url.startswith(item):",
            "            return url",
            "",
            "    return url_for('browser.index')"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2023, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import os",
            "import sys",
            "import json",
            "import subprocess",
            "from collections import defaultdict",
            "from operator import attrgetter",
            "",
            "from flask import Blueprint, current_app, url_for",
            "from flask_babel import gettext",
            "from flask_security import current_user, login_required",
            "from flask_security.utils import get_post_login_redirect",
            "from threading import Lock",
            "",
            "from .paths import get_storage_directory",
            "from .preferences import Preferences",
            "from pgadmin.utils.constants import UTILITIES_ARRAY, USER_NOT_FOUND",
            "from pgadmin.model import db, User, ServerGroup, Server",
            "from urllib.parse import unquote",
            "",
            "ADD_SERVERS_MSG = \"Added %d Server Group(s) and %d Server(s).\"",
            "",
            "",
            "class PgAdminModule(Blueprint):",
            "    \"\"\"",
            "    Base class for every PgAdmin Module.",
            "",
            "    This class defines a set of method and attributes that",
            "    every module should implement.",
            "    \"\"\"",
            "",
            "    def __init__(self, name, import_name, **kwargs):",
            "        kwargs.setdefault('url_prefix', '/' + name)",
            "        kwargs.setdefault('template_folder', 'templates')",
            "        kwargs.setdefault('static_folder', 'static')",
            "        self.submodules = []",
            "        self.parentmodules = []",
            "",
            "        super().__init__(name, import_name, **kwargs)",
            "",
            "        def create_module_preference():",
            "            # Create preference for each module by default",
            "            if hasattr(self, 'LABEL'):",
            "                self.preference = Preferences(self.name, self.LABEL)",
            "            else:",
            "                self.preference = Preferences(self.name, None)",
            "",
            "            self.register_preferences()",
            "",
            "        # Create and register the module preference object and preferences for",
            "        # it just before the first request",
            "        self.before_app_first_request(create_module_preference)",
            "",
            "    def register_preferences(self):",
            "        # To be implemented by child classes",
            "        pass",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "",
            "        super().register(app, options)",
            "",
            "        for module in self.submodules:",
            "            module.parentmodules.append(self)",
            "            if app.blueprints.get(module.name) is None:",
            "                app.register_blueprint(module)",
            "                app.register_logout_hook(module)",
            "",
            "    def get_own_stylesheets(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: the stylesheets used by this module, not including any",
            "                stylesheet needed by the submodules.",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_own_messages(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the i18n messages used by this module, not including any",
            "                messages needed by the submodules.",
            "        \"\"\"",
            "        return dict()",
            "",
            "    def get_own_menuitems(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the menuitems for this module, not including",
            "                any needed from the submodules.",
            "        \"\"\"",
            "        return defaultdict(list)",
            "",
            "    def get_panels(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of panel objects to add",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    def stylesheets(self):",
            "        stylesheets = self.get_own_stylesheets()",
            "        for module in self.submodules:",
            "            stylesheets.extend(module.stylesheets)",
            "        return stylesheets",
            "",
            "    @property",
            "    def messages(self):",
            "        res = self.get_own_messages()",
            "",
            "        for module in self.submodules:",
            "            res.update(module.messages)",
            "        return res",
            "",
            "    @property",
            "    def menu_items(self):",
            "        menu_items = self.get_own_menuitems()",
            "        for module in self.submodules:",
            "            for key, value in module.menu_items.items():",
            "                menu_items[key].extend(value)",
            "        menu_items = dict((key, sorted(value, key=attrgetter('priority')))",
            "                          for key, value in menu_items.items())",
            "        return menu_items",
            "",
            "    @property",
            "    def exposed_endpoints(self):",
            "        res = self.get_exposed_url_endpoints()",
            "",
            "        for module in self.submodules:",
            "            res += module.exposed_endpoints",
            "",
            "        return res",
            "",
            "",
            "IS_WIN = (os.name == 'nt')",
            "",
            "sys_encoding = sys.getdefaultencoding()",
            "if not sys_encoding or sys_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the default encoding,",
            "    # or 'ascii'.",
            "    sys_encoding = 'utf-8'",
            "",
            "fs_encoding = sys.getfilesystemencoding()",
            "if not fs_encoding or fs_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the file-system encoding,",
            "    # or 'ascii'.",
            "    fs_encoding = 'utf-8'",
            "",
            "",
            "def u_encode(_s, _encoding=sys_encoding):",
            "    return _s",
            "",
            "",
            "def file_quote(_p):",
            "    return _p",
            "",
            "",
            "if IS_WIN:",
            "    import ctypes",
            "    from ctypes import wintypes",
            "",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    _GetShortPathNameW = ctypes.windll.kernel32.GetShortPathNameW",
            "    _GetShortPathNameW.argtypes = [",
            "        wintypes.LPCWSTR, wintypes.LPWSTR, wintypes.DWORD",
            "    ]",
            "    _GetShortPathNameW.restype = wintypes.DWORD",
            "",
            "    def fs_short_path(_path):",
            "        \"\"\"",
            "        Gets the short path name of a given long path.",
            "        http://stackoverflow.com/a/23598461/200291",
            "        \"\"\"",
            "        buf_size = len(_path)",
            "        while True:",
            "            res = ctypes.create_unicode_buffer(buf_size)",
            "            # Note:- _GetShortPathNameW may return empty value",
            "            # if directory doesn't exist.",
            "            needed = _GetShortPathNameW(_path, res, buf_size)",
            "",
            "            if buf_size >= needed:",
            "                return res.value",
            "            else:",
            "                buf_size += needed",
            "",
            "    def document_dir():",
            "        CSIDL_PERSONAL = 5  # My Documents",
            "        SHGFP_TYPE_CURRENT = 0  # Get current, not default value",
            "",
            "        buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH)",
            "        ctypes.windll.shell32.SHGetFolderPathW(",
            "            None, CSIDL_PERSONAL, None, SHGFP_TYPE_CURRENT, buf",
            "        )",
            "",
            "        return buf.value",
            "",
            "else:",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    def fs_short_path(_path):",
            "        return _path",
            "",
            "    def document_dir():",
            "        return os.path.realpath(os.path.expanduser('~/'))",
            "",
            "",
            "def get_complete_file_path(file, validate=True):",
            "    \"\"\"",
            "    Args:",
            "        file: File returned by file manager",
            "",
            "    Returns:",
            "         Full path for the file",
            "    \"\"\"",
            "    if not file:",
            "        return None",
            "",
            "    # If desktop mode",
            "    if current_app.PGADMIN_RUNTIME or not current_app.config['SERVER_MODE']:",
            "        return file if os.path.isfile(file) else None",
            "",
            "    storage_dir = get_storage_directory()",
            "    if storage_dir:",
            "        file = os.path.join(",
            "            storage_dir,",
            "            file.lstrip('/').lstrip('\\\\')",
            "        )",
            "        if IS_WIN:",
            "            file = file.replace('\\\\', '/')",
            "            file = fs_short_path(file)",
            "",
            "    if validate:",
            "        return file if os.path.isfile(file) else None",
            "    else:",
            "        return file",
            "",
            "",
            "def filename_with_file_manager_path(_file, create_file=False,",
            "                                    skip_permission_check=False):",
            "    \"\"\"",
            "    Args:",
            "        file: File name returned from client file manager",
            "        create_file: Set flag to False when file creation doesn't required",
            "    Returns:",
            "        Filename to use for backup with full path taken from preference",
            "    \"\"\"",
            "    # Set file manager directory from preference",
            "    storage_dir = get_storage_directory()",
            "",
            "    from pgadmin.misc.file_manager import Filemanager",
            "    Filemanager.check_access_permission(",
            "        storage_dir, _file, skip_permission_check)",
            "    if storage_dir:",
            "        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))",
            "    elif not os.path.isabs(_file):",
            "        _file = os.path.join(document_dir(), _file)",
            "",
            "    def short_filepath():",
            "        short_path = fs_short_path(_file)",
            "        # fs_short_path() function may return empty path on Windows",
            "        # if directory doesn't exists. In that case we strip the last path",
            "        # component and get the short path.",
            "        if os.name == 'nt' and short_path == '':",
            "            base_name = os.path.basename(_file)",
            "            dir_name = os.path.dirname(_file)",
            "            short_path = fs_short_path(dir_name) + '\\\\' + base_name",
            "        return short_path",
            "",
            "    if create_file:",
            "        # Touch the file to get the short path of the file on windows.",
            "        with open(_file, 'a'):",
            "            return short_filepath()",
            "",
            "    return short_filepath()",
            "",
            "",
            "def does_utility_exist(file):",
            "    \"\"\"",
            "    This function will check the utility file exists on given path.",
            "    :return:",
            "    \"\"\"",
            "    error_msg = None",
            "    if file is None:",
            "        error_msg = gettext(\"Utility file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\")",
            "        return error_msg",
            "",
            "    if not os.path.exists(file):",
            "        error_msg = gettext(\"'%s' file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\" % file)",
            "    return error_msg",
            "",
            "",
            "def get_server(sid):",
            "    \"\"\"",
            "    # Fetch the server  etc",
            "    :param sid:",
            "    :return: server",
            "    \"\"\"",
            "    server = Server.query.filter_by(id=sid).first()",
            "    return server",
            "",
            "",
            "def set_binary_path(binary_path, bin_paths, server_type,",
            "                    version_number=None, set_as_default=False):",
            "    \"\"\"",
            "    This function is used to iterate through the utilities and set the",
            "    default binary path.",
            "    \"\"\"",
            "    path_with_dir = binary_path if \"$DIR\" in binary_path else None",
            "",
            "    # Check if \"$DIR\" present in binary path",
            "    binary_path = replace_binary_path(binary_path)",
            "",
            "    for utility in UTILITIES_ARRAY:",
            "        full_path = os.path.abspath(",
            "            os.path.join(binary_path, (utility if os.name != 'nt' else",
            "                                       (utility + '.exe'))))",
            "",
            "        try:",
            "            # if version_number is provided then no need to fetch it.",
            "            if version_number is None:",
            "                # Get the output of the '--version' command",
            "                version_string = \\",
            "                    subprocess.getoutput('\"{0}\" --version'.format(full_path))",
            "",
            "                # Get the version number by splitting the result string",
            "                version_number = \\",
            "                    version_string.split(\") \", 1)[1].split('.', 1)[0]",
            "            elif version_number.find('.'):",
            "                version_number = version_number.split('.', 1)[0]",
            "",
            "            # Get the paths array based on server type",
            "            if 'pg_bin_paths' in bin_paths or 'as_bin_paths' in bin_paths:",
            "                paths_array = bin_paths['pg_bin_paths']",
            "                if server_type == 'ppas':",
            "                    paths_array = bin_paths['as_bin_paths']",
            "            else:",
            "                paths_array = bin_paths",
            "",
            "            for path in paths_array:",
            "                if path['version'].find(version_number) == 0 and \\",
            "                        path['binaryPath'] is None:",
            "                    path['binaryPath'] = path_with_dir \\",
            "                        if path_with_dir is not None else binary_path",
            "                    if set_as_default:",
            "                        path['isDefault'] = True",
            "                    break",
            "            break",
            "        except Exception:",
            "            continue",
            "",
            "",
            "def replace_binary_path(binary_path):",
            "    \"\"\"",
            "    This function is used to check if $DIR is present in",
            "    the binary path. If it is there then replace it with",
            "    module.",
            "    \"\"\"",
            "    if \"$DIR\" in binary_path:",
            "        # When running as an WSGI application, we will not find the",
            "        # '__file__' attribute for the '__main__' module.",
            "        main_module_file = getattr(",
            "            sys.modules['__main__'], '__file__', None",
            "        )",
            "",
            "        if main_module_file is not None:",
            "            binary_path = binary_path.replace(",
            "                \"$DIR\", os.path.dirname(main_module_file)",
            "            )",
            "",
            "    return binary_path",
            "",
            "",
            "def add_value(attr_dict, key, value):",
            "    \"\"\"Add a value to the attribute dict if non-empty.",
            "",
            "    Args:",
            "        attr_dict (dict): The dictionary to add the values to",
            "        key (str): The key for the new value",
            "        value (str): The value to add",
            "",
            "    Returns:",
            "        The updated attribute dictionary",
            "    \"\"\"",
            "    if value != \"\" and value is not None:",
            "        attr_dict[key] = value",
            "",
            "    return attr_dict",
            "",
            "",
            "def dump_database_servers(output_file, selected_servers,",
            "                          dump_user=current_user, from_setup=False):",
            "    \"\"\"Dump the server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(dump_user, from_setup)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % dump_user",
            "",
            "    user_id = user.id",
            "    # Dict to collect the output",
            "    object_dict = {}",
            "    # Counters",
            "    servers_dumped = 0",
            "",
            "    # Dump servers",
            "    servers = Server.query.filter_by(user_id=user_id).all()",
            "    server_dict = {}",
            "    for server in servers:",
            "        if selected_servers is None or str(server.id) in selected_servers:",
            "            # Get the group name",
            "            group_name = ServerGroup.query.filter_by(",
            "                user_id=user_id, id=server.servergroup_id).first().name",
            "",
            "            attr_dict = {}",
            "            add_value(attr_dict, \"Name\", server.name)",
            "            add_value(attr_dict, \"Group\", group_name)",
            "            add_value(attr_dict, \"Host\", server.host)",
            "            add_value(attr_dict, \"HostAddr\", server.hostaddr)",
            "            add_value(attr_dict, \"Port\", server.port)",
            "            add_value(attr_dict, \"MaintenanceDB\", server.maintenance_db)",
            "            add_value(attr_dict, \"Username\", server.username)",
            "            add_value(attr_dict, \"Role\", server.role)",
            "            add_value(attr_dict, \"SSLMode\", server.ssl_mode)",
            "            add_value(attr_dict, \"Comment\", server.comment)",
            "            add_value(attr_dict, \"Shared\", server.shared)",
            "            add_value(attr_dict, \"DBRestriction\", server.db_res)",
            "            add_value(attr_dict, \"PassFile\", server.passfile)",
            "            add_value(attr_dict, \"SSLCert\", server.sslcert)",
            "            add_value(attr_dict, \"SSLKey\", server.sslkey)",
            "            add_value(attr_dict, \"SSLRootCert\", server.sslrootcert)",
            "            add_value(attr_dict, \"SSLCrl\", server.sslcrl)",
            "            add_value(attr_dict, \"SSLCompression\", server.sslcompression)",
            "            add_value(attr_dict, \"BGColor\", server.bgcolor)",
            "            add_value(attr_dict, \"FGColor\", server.fgcolor)",
            "            add_value(attr_dict, \"Service\", server.service)",
            "            add_value(attr_dict, \"Timeout\", server.connect_timeout)",
            "            add_value(attr_dict, \"UseSSHTunnel\", server.use_ssh_tunnel)",
            "            add_value(attr_dict, \"TunnelHost\", server.tunnel_host)",
            "            add_value(attr_dict, \"TunnelPort\", server.tunnel_port)",
            "            add_value(attr_dict, \"TunnelUsername\", server.tunnel_username)",
            "            add_value(attr_dict, \"TunnelAuthentication\",",
            "                      server.tunnel_authentication)",
            "",
            "            servers_dumped = servers_dumped + 1",
            "",
            "            server_dict[servers_dumped] = attr_dict",
            "",
            "    object_dict[\"Servers\"] = server_dict",
            "",
            "    try:",
            "        file_path = filename_with_file_manager_path(",
            "            unquote(output_file), skip_permission_check=from_setup)",
            "    except Exception as e:",
            "        return _handle_error(str(e), from_setup)",
            "",
            "    # write to file",
            "    file_content = json.dumps(object_dict, indent=4)",
            "    error_str = \"Error: {0}\"",
            "    try:",
            "        with open(file_path, 'w') as output_file:",
            "            output_file.write(file_content)",
            "    except IOError as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "    except Exception as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "",
            "    msg = gettext(\"Configuration for %s servers dumped to %s\" %",
            "                  (servers_dumped, output_file.name))",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def validate_json_data(data, is_admin):",
            "    \"\"\"",
            "    Used internally by load_servers to validate servers data.",
            "    :param data: servers data",
            "    :param is_admin:",
            "    :return: error message if any",
            "    \"\"\"",
            "    skip_servers = []",
            "    # Loop through the servers...",
            "    if \"Servers\" not in data:",
            "        return gettext(\"'Servers' attribute not found in the specified file.\")",
            "",
            "    for server in data[\"Servers\"]:",
            "        obj = data[\"Servers\"][server]",
            "",
            "        # Check if server is shared.Won't import if user is non-admin",
            "        if obj.get('Shared', None) and not is_admin:",
            "            print(\"Won't import the server '%s' as it is shared \" %",
            "                  obj[\"Name\"])",
            "            skip_servers.append(server)",
            "            continue",
            "",
            "        def check_attrib(attrib):",
            "            if attrib not in obj:",
            "                return gettext(\"'%s' attribute not found for server '%s'\" %",
            "                               (attrib, server))",
            "            return None",
            "",
            "        def check_is_integer(value):",
            "            if not isinstance(value, int):",
            "                return gettext(\"Port must be integer for server '%s'\" % server)",
            "            return None",
            "",
            "        for attrib in (\"Group\", \"Name\"):",
            "            errmsg = check_attrib(attrib)",
            "            if errmsg:",
            "                return errmsg",
            "",
            "        is_service_attrib_available = obj.get(\"Service\", None) is not None",
            "",
            "        if not is_service_attrib_available:",
            "            for attrib in (\"Port\", \"Username\"):",
            "                errmsg = check_attrib(attrib)",
            "                if errmsg:",
            "                    return errmsg",
            "                if attrib == 'Port':",
            "                    errmsg = check_is_integer(obj[attrib])",
            "                    if errmsg:",
            "                        return errmsg",
            "",
            "        for attrib in (\"SSLMode\", \"MaintenanceDB\"):",
            "            errmsg = check_attrib(attrib)",
            "            if errmsg:",
            "                return errmsg",
            "",
            "        if \"Host\" not in obj and \"HostAddr\" not in obj and not \\",
            "                is_service_attrib_available:",
            "            return gettext(\"'Host', 'HostAddr' or 'Service' attribute not \"",
            "                           \"found for server '%s'\" % server)",
            "",
            "    for server in skip_servers:",
            "        del data[\"Servers\"][server]",
            "    return None",
            "",
            "",
            "def load_database_servers(input_file, selected_servers,",
            "                          load_user=current_user, from_setup=False):",
            "    \"\"\"Load server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % load_user",
            "",
            "    # generate full path of file",
            "    try:",
            "        file_path = filename_with_file_manager_path(",
            "            unquote(input_file), skip_permission_check=from_setup)",
            "    except Exception as e:",
            "        return _handle_error(str(e), from_setup)",
            "",
            "    try:",
            "        with open(file_path) as f:",
            "            data = json.load(f)",
            "    except json.decoder.JSONDecodeError as e:",
            "        return _handle_error(gettext(\"Error parsing input file %s: %s\" %",
            "                             (file_path, e)), from_setup)",
            "    except Exception as e:",
            "        return _handle_error(gettext(\"Error reading input file %s: [%d] %s\" %",
            "                             (file_path, e.errno, e.strerror)), from_setup)",
            "",
            "    f.close()",
            "",
            "    user_id = user.id",
            "    # Counters",
            "    groups_added = 0",
            "    servers_added = 0",
            "",
            "    # Get the server groups",
            "    groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "    # Validate server data",
            "    error_msg = validate_json_data(data, user.has_role(\"Administrator\"))",
            "    if error_msg is not None and from_setup:",
            "        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "        return _handle_error(error_msg, from_setup)",
            "",
            "    for server in data[\"Servers\"]:",
            "        if selected_servers is None or str(server) in selected_servers:",
            "            obj = data[\"Servers\"][server]",
            "",
            "            # Get the group. Create if necessary",
            "            group_id = next(",
            "                (g.id for g in groups if g.name == obj[\"Group\"]), -1)",
            "",
            "            if group_id == -1:",
            "                new_group = ServerGroup()",
            "                new_group.name = obj[\"Group\"]",
            "                new_group.user_id = user_id",
            "                db.session.add(new_group)",
            "",
            "                try:",
            "                    db.session.commit()",
            "                except Exception as e:",
            "                    if from_setup:",
            "                        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                    return _handle_error(",
            "                        gettext(\"Error creating server group '%s': %s\" %",
            "                                (new_group.name, e)), from_setup)",
            "",
            "                group_id = new_group.id",
            "                groups_added = groups_added + 1",
            "                groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "            # Create the server",
            "            new_server = Server()",
            "            new_server.name = obj[\"Name\"]",
            "            new_server.servergroup_id = group_id",
            "            new_server.user_id = user_id",
            "            new_server.ssl_mode = obj[\"SSLMode\"]",
            "            new_server.maintenance_db = obj[\"MaintenanceDB\"]",
            "",
            "            new_server.host = obj.get(\"Host\", None)",
            "",
            "            new_server.hostaddr = obj.get(\"HostAddr\", None)",
            "",
            "            new_server.port = obj.get(\"Port\", None)",
            "",
            "            new_server.username = obj.get(\"Username\", None)",
            "",
            "            new_server.role = obj.get(\"Role\", None)",
            "",
            "            new_server.ssl_mode = obj[\"SSLMode\"]",
            "",
            "            new_server.comment = obj.get(\"Comment\", None)",
            "",
            "            new_server.db_res = obj.get(\"DBRestriction\", None)",
            "",
            "            new_server.passfile = obj.get(\"PassFile\", None)",
            "",
            "            new_server.sslcert = obj.get(\"SSLCert\", None)",
            "",
            "            new_server.sslkey = obj.get(\"SSLKey\", None)",
            "",
            "            new_server.sslrootcert = obj.get(\"SSLRootCert\", None)",
            "",
            "            new_server.sslcrl = obj.get(\"SSLCrl\", None)",
            "",
            "            new_server.sslcompression = obj.get(\"SSLCompression\", None)",
            "",
            "            new_server.bgcolor = obj.get(\"BGColor\", None)",
            "",
            "            new_server.fgcolor = obj.get(\"FGColor\", None)",
            "",
            "            new_server.service = obj.get(\"Service\", None)",
            "",
            "            new_server.connect_timeout = obj.get(\"Timeout\", None)",
            "",
            "            new_server.use_ssh_tunnel = obj.get(\"UseSSHTunnel\", None)",
            "",
            "            new_server.tunnel_host = obj.get(\"TunnelHost\", None)",
            "",
            "            new_server.tunnel_port = obj.get(\"TunnelPort\", None)",
            "",
            "            new_server.tunnel_username = obj.get(\"TunnelUsername\", None)",
            "",
            "            new_server.tunnel_authentication = \\",
            "                obj.get(\"TunnelAuthentication\", None)",
            "",
            "            new_server.shared = \\",
            "                obj.get(\"Shared\", None)",
            "",
            "            db.session.add(new_server)",
            "",
            "            try:",
            "                db.session.commit()",
            "            except Exception as e:",
            "                if from_setup:",
            "                    print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                return _handle_error(gettext(\"Error creating server '%s': %s\" %",
            "                                             (new_server.name, e)), from_setup)",
            "",
            "            servers_added = servers_added + 1",
            "",
            "    msg = ADD_SERVERS_MSG % (groups_added, servers_added)",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def clear_database_servers(load_user=current_user, from_setup=False):",
            "    \"\"\"Clear groups and servers configurations.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup)",
            "    if user is None:",
            "        return False",
            "",
            "    user_id = user.id",
            "",
            "    # Remove all servers",
            "    servers = Server.query.filter_by(user_id=user_id)",
            "    for server in servers:",
            "        db.session.delete(server)",
            "",
            "    # Remove all groups",
            "    groups = ServerGroup.query.filter_by(user_id=user_id)",
            "    for group in groups:",
            "        db.session.delete(group)",
            "    servers = Server.query.filter_by(user_id=user_id)",
            "",
            "    for server in servers:",
            "        db.session.delete(server)",
            "",
            "    try:",
            "        db.session.commit()",
            "    except Exception as e:",
            "        error_msg = \\",
            "            gettext(\"Error clearing server configuration with error (%s)\" %",
            "                    str(e))",
            "        if from_setup:",
            "            print(error_msg)",
            "            sys.exit(1)",
            "",
            "        return False, error_msg",
            "",
            "",
            "def _does_user_exist(user, from_setup):",
            "    \"\"\"",
            "    This function will check user is exist or not. If exist then return",
            "    \"\"\"",
            "    if isinstance(user, User):",
            "        user = user.email",
            "",
            "    new_user = User.query.filter_by(email=user).first()",
            "",
            "    if new_user is None:",
            "        print(USER_NOT_FOUND % user)",
            "        if from_setup:",
            "            sys.exit(1)",
            "",
            "    return new_user",
            "",
            "",
            "def _handle_error(error_msg, from_setup):",
            "    \"\"\"",
            "    This function is used to print the error msg and exit from app if",
            "    called from setup.py",
            "    \"\"\"",
            "    if from_setup:",
            "        print(error_msg)",
            "        sys.exit(1)",
            "",
            "    return False, error_msg",
            "",
            "",
            "# Shortcut configuration for Accesskey",
            "ACCESSKEY_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    }",
            "]",
            "",
            "# Shortcut configuration",
            "SHORTCUT_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    },",
            "    {",
            "        'name': 'shift',",
            "        'type': 'checkbox',",
            "        'label': gettext('Shift')",
            "    },",
            "",
            "    {",
            "        'name': 'control',",
            "        'type': 'checkbox',",
            "        'label': gettext('Ctrl')",
            "    },",
            "    {",
            "        'name': 'alt',",
            "        'type': 'checkbox',",
            "        'label': gettext('Alt/Option')",
            "    }",
            "]",
            "",
            "",
            "class KeyManager:",
            "    def __init__(self):",
            "        self.users = dict()",
            "        self.lock = Lock()",
            "",
            "    @login_required",
            "    def get(self):",
            "        user = self.users.get(current_user.id, None)",
            "        if user is not None:",
            "            return user.get('key', None)",
            "",
            "    @login_required",
            "    def set(self, _key, _new_login=True):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "            if user is None:",
            "                self.users[current_user.id] = dict(",
            "                    session_count=1, key=_key)",
            "            else:",
            "                if _new_login:",
            "                    user['session_count'] += 1",
            "                user['key'] = _key",
            "",
            "    @login_required",
            "    def reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                # This will not decrement if session expired",
            "                user['session_count'] -= 1",
            "                if user['session_count'] == 0:",
            "                    del self.users[current_user.id]",
            "",
            "    @login_required",
            "    def hard_reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                del self.users[current_user.id]",
            "",
            "",
            "def get_safe_post_login_redirect():",
            "    allow_list = [",
            "        url_for('browser.index')",
            "    ]",
            "    if \"SCRIPT_NAME\" in os.environ and os.environ[\"SCRIPT_NAME\"]:",
            "        allow_list.append(os.environ[\"SCRIPT_NAME\"])",
            "",
            "    url = get_post_login_redirect()",
            "    for item in allow_list:",
            "        if url.startswith(item):",
            "            return url",
            "",
            "    return url_for('browser.index')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "437": [
                "dump_database_servers"
            ],
            "438": [
                "dump_database_servers"
            ],
            "439": [
                "dump_database_servers"
            ],
            "440": [
                "dump_database_servers"
            ],
            "441": [
                "dump_database_servers"
            ],
            "442": [
                "dump_database_servers"
            ],
            "443": [
                "dump_database_servers"
            ],
            "444": [
                "dump_database_servers"
            ],
            "445": [
                "dump_database_servers"
            ],
            "447": [
                "dump_database_servers"
            ],
            "448": [
                "dump_database_servers"
            ],
            "452": [
                "dump_database_servers"
            ],
            "453": [
                "dump_database_servers"
            ],
            "454": [
                "dump_database_servers"
            ],
            "455": [
                "dump_database_servers"
            ],
            "456": [
                "dump_database_servers"
            ],
            "457": [
                "dump_database_servers"
            ],
            "551": [
                "load_database_servers"
            ],
            "552": [
                "load_database_servers"
            ],
            "553": [
                "load_database_servers"
            ],
            "554": [
                "load_database_servers"
            ],
            "555": [
                "load_database_servers"
            ],
            "557": [
                "load_database_servers"
            ],
            "558": [
                "load_database_servers"
            ],
            "559": [
                "load_database_servers"
            ],
            "560": [
                "load_database_servers"
            ],
            "561": [
                "load_database_servers"
            ],
            "562": [
                "load_database_servers"
            ],
            "563": [
                "load_database_servers"
            ]
        },
        "addLocation": []
    }
}