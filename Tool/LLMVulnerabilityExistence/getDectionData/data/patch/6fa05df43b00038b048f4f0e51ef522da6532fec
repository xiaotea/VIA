{
    "tensorflow/python/ops/array_ops_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from tensorflow.python.framework import tensor_spec"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from tensorflow.python.framework import test_util"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from tensorflow.python.ops import array_ops"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from tensorflow.python.ops import gen_array_ops"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from tensorflow.python.ops import math_ops"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from tensorflow.python.ops import random_ops"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from tensorflow.python.platform import test"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     # Create a tensor with an unknown dim 1."
            },
            "8": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     x = random_ops.random_normal([4, 10, 10])"
            },
            "9": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     x = array_ops.gather("
            },
            "10": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        x,"
            },
            "11": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]),"
            },
            "12": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        axis=1)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        x, array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]), axis=1"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    )"
            },
            "15": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     x.shape.assert_is_compatible_with([4, None, 10])"
            },
            "16": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     with backprop.GradientTape() as tape:"
            },
            "18": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     # Create a tensor with an unknown dim 1."
            },
            "19": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     x = random_ops.random_normal([4, 10, 10])"
            },
            "20": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     x = array_ops.gather("
            },
            "21": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        x,"
            },
            "22": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]),"
            },
            "23": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        axis=1)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        x, array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]), axis=1"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    )"
            },
            "26": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     x.shape.assert_is_compatible_with([4, None, 10])"
            },
            "27": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     a = array_ops.reshape(x, array_ops.shape(x))"
            },
            "28": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     a.shape.assert_is_compatible_with([4, None, 10])"
            },
            "29": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     c = array_ops.reshape("
            },
            "30": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         x,"
            },
            "31": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         math_ops.cast("
            },
            "32": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            math_ops.cast(array_ops.shape(x), dtypes.float32), dtypes.int32))"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            math_ops.cast(array_ops.shape(x), dtypes.float32), dtypes.int32"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        ),"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    )"
            },
            "36": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     c.shape.assert_is_compatible_with([None, None, None])"
            },
            "37": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "   def testEmptyMeshgrid(self):"
            },
            "39": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     self.assertEqual(array_ops.meshgrid(), [])"
            },
            "40": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "   def testSlicedPartialShapeInference(self):"
            },
            "42": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "43": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     @def_function.function(autograph=False)"
            },
            "44": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     def g(x):"
            },
            "45": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "       return array_ops.zeros([array_ops.shape(x)[0]])"
            },
            "46": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     self.assertAllEqual(conc.output_shapes.as_list(), [10])"
            },
            "47": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "   def testIdentityOnSlicedPartialShapeInference(self):"
            },
            "49": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "50": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     @def_function.function(autograph=False)"
            },
            "51": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     def g(x):"
            },
            "52": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "       return array_ops.zeros([array_ops.identity(array_ops.shape(x)[0])])"
            },
            "53": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     ):"
            },
            "54": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "       func()"
            },
            "55": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+  @test_util.run_in_graph_and_eager_modes"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+  def testUpperBoundValuesWrongRank(self):"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    # Used to cause a segfault, b/266336058"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+    arg0 = array_ops.zeros([2, 3], dtype=dtypes.float32)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    arg1 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        Exception, \"Shape must be rank 2 but is rank 3\""
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    ):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+      gen_array_ops.upper_bound(arg0, arg1)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+  def testLowerBoundValuesWrongRank(self):"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    # Used to cause a segfault, b/266336058"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    arg0 = array_ops.zeros([2, 3], dtype=dtypes.float32)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    arg1 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        Exception, \"Shape must be rank 2 but is rank 3\""
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    ):"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+      gen_array_ops.lower_bound(arg0, arg1)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+  def testUpperBoundInputsWrongRank(self):"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    # Used to cause a segfault, b/266336058"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+    arg0 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    arg1 = array_ops.zeros([2, 3], dtype=dtypes.float32)"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        Exception, \"Shape must be rank 2 but is rank 3\""
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    ):"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+      gen_array_ops.upper_bound(arg0, arg1)"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+  def testLowerBoundInputsWrongRank(self):"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    # Used to cause a segfault, b/266336058"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    arg0 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    arg1 = array_ops.zeros([2, 3], dtype=dtypes.float32)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        Exception, \"Shape must be rank 2 but is rank 3\""
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    ):"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+      gen_array_ops.lower_bound(arg0, arg1)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "93": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "94": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " if __name__ == \"__main__\":"
            },
            "95": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "   test.main()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for array operations.\"\"\"",
            "",
            "from tensorflow.python.eager import backprop",
            "from tensorflow.python.eager import def_function",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import tensor_spec",
            "from tensorflow.python.framework import test_util",
            "from tensorflow.python.ops import array_ops",
            "from tensorflow.python.ops import math_ops",
            "from tensorflow.python.ops import random_ops",
            "from tensorflow.python.platform import test",
            "",
            "",
            "class ArrayOpTest(test.TestCase):",
            "",
            "  def testGatherGradHasPartialStaticShape(self):",
            "    # Create a tensor with an unknown dim 1.",
            "    x = random_ops.random_normal([4, 10, 10])",
            "    x = array_ops.gather(",
            "        x,",
            "        array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]),",
            "        axis=1)",
            "    x.shape.assert_is_compatible_with([4, None, 10])",
            "",
            "    with backprop.GradientTape() as tape:",
            "      tape.watch(x)",
            "      a = array_ops.gather(array_ops.gather(x, [0, 1]), [0, 1])",
            "    grad_a = tape.gradient(a, x)",
            "    with backprop.GradientTape() as tape:",
            "      tape.watch(x)",
            "      b = array_ops.gather(array_ops.gather(x, [2, 3], axis=2), [0, 1])",
            "    grad_b = tape.gradient(b, x)",
            "",
            "    # We make sure that the representation of the shapes are correct; the shape",
            "    # equality check will always eval to false due to the shapes being partial.",
            "    grad_a.shape.assert_is_compatible_with([None, None, 10])",
            "    grad_b.shape.assert_is_compatible_with([4, None, 10])",
            "",
            "  def testReshapeShapeInference(self):",
            "    # Create a tensor with an unknown dim 1.",
            "    x = random_ops.random_normal([4, 10, 10])",
            "    x = array_ops.gather(",
            "        x,",
            "        array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]),",
            "        axis=1)",
            "    x.shape.assert_is_compatible_with([4, None, 10])",
            "    a = array_ops.reshape(x, array_ops.shape(x))",
            "    a.shape.assert_is_compatible_with([4, None, 10])",
            "    b = array_ops.reshape(x, math_ops.cast(array_ops.shape(x), dtypes.int64))",
            "    b.shape.assert_is_compatible_with([4, None, 10])",
            "",
            "    # We do not shape-infer across a tf.cast into anything that's not tf.int32",
            "    # or tf.int64, since they might end up mangling the shape.",
            "    c = array_ops.reshape(",
            "        x,",
            "        math_ops.cast(",
            "            math_ops.cast(array_ops.shape(x), dtypes.float32), dtypes.int32))",
            "    c.shape.assert_is_compatible_with([None, None, None])",
            "",
            "  def testEmptyMeshgrid(self):",
            "    self.assertEqual(array_ops.meshgrid(), [])",
            "",
            "  def testSlicedPartialShapeInference(self):",
            "",
            "    @def_function.function(autograph=False)",
            "    def g(x):",
            "      return array_ops.zeros([array_ops.shape(x)[0]])",
            "",
            "    conc = g.get_concrete_function(tensor_spec.TensorSpec([10, None]))",
            "    self.assertAllEqual(conc.output_shapes.as_list(), [10])",
            "",
            "  def testIdentityOnSlicedPartialShapeInference(self):",
            "",
            "    @def_function.function(autograph=False)",
            "    def g(x):",
            "      return array_ops.zeros([array_ops.identity(array_ops.shape(x)[0])])",
            "",
            "    conc = g.get_concrete_function(tensor_spec.TensorSpec([10, None]))",
            "    self.assertAllEqual(conc.output_shapes.as_list(), [10])",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def testParallelConcatFailsWithRankZeroShape(self):",
            "    op = array_ops.ParallelConcat",
            "    para = {\"shape\": 0, \"values\": [1]}",
            "",
            "    def func():",
            "      y = op(**para)",
            "      return y",
            "",
            "    with self.assertRaisesRegex(",
            "        Exception, \"(rank|dimension) of .* must be greater than .* 0\"",
            "    ):",
            "      func()",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "afterPatchFile": [
            "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for array operations.\"\"\"",
            "",
            "from tensorflow.python.eager import backprop",
            "from tensorflow.python.eager import def_function",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import tensor_spec",
            "from tensorflow.python.framework import test_util",
            "from tensorflow.python.ops import array_ops",
            "from tensorflow.python.ops import gen_array_ops",
            "from tensorflow.python.ops import math_ops",
            "from tensorflow.python.ops import random_ops",
            "from tensorflow.python.platform import test",
            "",
            "",
            "class ArrayOpTest(test.TestCase):",
            "",
            "  def testGatherGradHasPartialStaticShape(self):",
            "    # Create a tensor with an unknown dim 1.",
            "    x = random_ops.random_normal([4, 10, 10])",
            "    x = array_ops.gather(",
            "        x, array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]), axis=1",
            "    )",
            "    x.shape.assert_is_compatible_with([4, None, 10])",
            "",
            "    with backprop.GradientTape() as tape:",
            "      tape.watch(x)",
            "      a = array_ops.gather(array_ops.gather(x, [0, 1]), [0, 1])",
            "    grad_a = tape.gradient(a, x)",
            "    with backprop.GradientTape() as tape:",
            "      tape.watch(x)",
            "      b = array_ops.gather(array_ops.gather(x, [2, 3], axis=2), [0, 1])",
            "    grad_b = tape.gradient(b, x)",
            "",
            "    # We make sure that the representation of the shapes are correct; the shape",
            "    # equality check will always eval to false due to the shapes being partial.",
            "    grad_a.shape.assert_is_compatible_with([None, None, 10])",
            "    grad_b.shape.assert_is_compatible_with([4, None, 10])",
            "",
            "  def testReshapeShapeInference(self):",
            "    # Create a tensor with an unknown dim 1.",
            "    x = random_ops.random_normal([4, 10, 10])",
            "    x = array_ops.gather(",
            "        x, array_ops.reshape(array_ops.where_v2(x[0, :, 0] > 0.5), [-1]), axis=1",
            "    )",
            "    x.shape.assert_is_compatible_with([4, None, 10])",
            "    a = array_ops.reshape(x, array_ops.shape(x))",
            "    a.shape.assert_is_compatible_with([4, None, 10])",
            "    b = array_ops.reshape(x, math_ops.cast(array_ops.shape(x), dtypes.int64))",
            "    b.shape.assert_is_compatible_with([4, None, 10])",
            "",
            "    # We do not shape-infer across a tf.cast into anything that's not tf.int32",
            "    # or tf.int64, since they might end up mangling the shape.",
            "    c = array_ops.reshape(",
            "        x,",
            "        math_ops.cast(",
            "            math_ops.cast(array_ops.shape(x), dtypes.float32), dtypes.int32",
            "        ),",
            "    )",
            "    c.shape.assert_is_compatible_with([None, None, None])",
            "",
            "  def testEmptyMeshgrid(self):",
            "    self.assertEqual(array_ops.meshgrid(), [])",
            "",
            "  def testSlicedPartialShapeInference(self):",
            "    @def_function.function(autograph=False)",
            "    def g(x):",
            "      return array_ops.zeros([array_ops.shape(x)[0]])",
            "",
            "    conc = g.get_concrete_function(tensor_spec.TensorSpec([10, None]))",
            "    self.assertAllEqual(conc.output_shapes.as_list(), [10])",
            "",
            "  def testIdentityOnSlicedPartialShapeInference(self):",
            "    @def_function.function(autograph=False)",
            "    def g(x):",
            "      return array_ops.zeros([array_ops.identity(array_ops.shape(x)[0])])",
            "",
            "    conc = g.get_concrete_function(tensor_spec.TensorSpec([10, None]))",
            "    self.assertAllEqual(conc.output_shapes.as_list(), [10])",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def testParallelConcatFailsWithRankZeroShape(self):",
            "    op = array_ops.ParallelConcat",
            "    para = {\"shape\": 0, \"values\": [1]}",
            "",
            "    def func():",
            "      y = op(**para)",
            "      return y",
            "",
            "    with self.assertRaisesRegex(",
            "        Exception, \"(rank|dimension) of .* must be greater than .* 0\"",
            "    ):",
            "      func()",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def testUpperBoundValuesWrongRank(self):",
            "    # Used to cause a segfault, b/266336058",
            "    arg0 = array_ops.zeros([2, 3], dtype=dtypes.float32)",
            "    arg1 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)",
            "    with self.assertRaisesRegex(",
            "        Exception, \"Shape must be rank 2 but is rank 3\"",
            "    ):",
            "      gen_array_ops.upper_bound(arg0, arg1)",
            "",
            "  def testLowerBoundValuesWrongRank(self):",
            "    # Used to cause a segfault, b/266336058",
            "    arg0 = array_ops.zeros([2, 3], dtype=dtypes.float32)",
            "    arg1 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)",
            "    with self.assertRaisesRegex(",
            "        Exception, \"Shape must be rank 2 but is rank 3\"",
            "    ):",
            "      gen_array_ops.lower_bound(arg0, arg1)",
            "",
            "  def testUpperBoundInputsWrongRank(self):",
            "    # Used to cause a segfault, b/266336058",
            "    arg0 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)",
            "    arg1 = array_ops.zeros([2, 3], dtype=dtypes.float32)",
            "    with self.assertRaisesRegex(",
            "        Exception, \"Shape must be rank 2 but is rank 3\"",
            "    ):",
            "      gen_array_ops.upper_bound(arg0, arg1)",
            "",
            "  def testLowerBoundInputsWrongRank(self):",
            "    # Used to cause a segfault, b/266336058",
            "    arg0 = array_ops.zeros([2, 1, 0], dtype=dtypes.float32)",
            "    arg1 = array_ops.zeros([2, 3], dtype=dtypes.float32)",
            "    with self.assertRaisesRegex(",
            "        Exception, \"Shape must be rank 2 but is rank 3\"",
            "    ):",
            "      gen_array_ops.lower_bound(arg0, arg1)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "34": [
                "ArrayOpTest",
                "testGatherGradHasPartialStaticShape"
            ],
            "35": [
                "ArrayOpTest",
                "testGatherGradHasPartialStaticShape"
            ],
            "36": [
                "ArrayOpTest",
                "testGatherGradHasPartialStaticShape"
            ],
            "57": [
                "ArrayOpTest",
                "testReshapeShapeInference"
            ],
            "58": [
                "ArrayOpTest",
                "testReshapeShapeInference"
            ],
            "59": [
                "ArrayOpTest",
                "testReshapeShapeInference"
            ],
            "71": [
                "ArrayOpTest",
                "testReshapeShapeInference"
            ],
            "78": [
                "ArrayOpTest",
                "testSlicedPartialShapeInference"
            ],
            "87": [
                "ArrayOpTest",
                "testIdentityOnSlicedPartialShapeInference"
            ]
        },
        "addLocation": []
    }
}