{
    "suricata/update/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     if args.config:"
            },
            "1": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         logger.info(\"Loading %s\", args.config)"
            },
            "2": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         with open(args.config, \"rb\") as fileobj:"
            },
            "3": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            config = yaml.load(fileobj)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            config = yaml.safe_load(fileobj)"
            },
            "5": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "             if config:"
            },
            "6": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "                 _config.update(config)"
            },
            "7": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     elif os.path.exists(DEFAULT_UPDATE_YAML_PATH):"
            },
            "8": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         logger.info(\"Loading %s\", DEFAULT_UPDATE_YAML_PATH)"
            },
            "9": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         with open(DEFAULT_UPDATE_YAML_PATH, \"rb\") as fileobj:"
            },
            "10": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            config = yaml.load(fileobj)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+            config = yaml.safe_load(fileobj)"
            },
            "12": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             if config:"
            },
            "13": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "                 _config.update(config)"
            },
            "14": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (C) 2017 Open Information Security Foundation",
            "# Copyright (c) 2015-2017 Jason Ish",
            "#",
            "# You can copy, redistribute or modify this Program under the terms of",
            "# the GNU General Public License version 2 as published by the Free",
            "# Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# version 2 along with this program; if not, write to the Free Software",
            "# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA",
            "# 02110-1301, USA.",
            "",
            "import os.path",
            "import logging",
            "",
            "import yaml",
            "",
            "logger = logging.getLogger()",
            "",
            "DEFAULT_DATA_DIRECTORY = \"/var/lib/suricata\"",
            "",
            "# Cache directory - relative to the data directory.",
            "CACHE_DIRECTORY = os.path.join(\"update\", \"cache\")",
            "",
            "# Source directory - relative to the data directory.",
            "SOURCE_DIRECTORY = os.path.join(\"update\", \"sources\")",
            "",
            "# Configuration keys.",
            "DATA_DIRECTORY_KEY = \"data-directory\"",
            "CACHE_DIRECTORY_KEY = \"cache-directory\"",
            "IGNORE_KEY = \"ignore\"",
            "DISABLE_CONF_KEY = \"disable-conf\"",
            "ENABLE_CONF_KEY = \"enable-conf\"",
            "MODIFY_CONF_KEY = \"modify-conf\"",
            "DROP_CONF_KEY = \"drop-conf\"",
            "LOCAL_CONF_KEY = \"local\"",
            "OUTPUT_KEY = \"output\"",
            "",
            "DEFAULT_UPDATE_YAML_PATH = \"/etc/suricata/update.yaml\"",
            "",
            "DEFAULT_SURICATA_YAML_PATH = [",
            "    \"/etc/suricata/suricata.yaml\",",
            "    \"/usr/local/etc/suricata/suricata.yaml\",",
            "    \"/etc/suricata/suricata-debian.yaml\"",
            "]",
            "",
            "DEFAULT_CONFIG = {",
            "    \"disable-conf\": \"/etc/suricata/disable.conf\",",
            "    \"enable-conf\": \"/etc/suricata/enable.conf\",",
            "    \"drop-conf\": \"/etc/suricata/drop.conf\",",
            "    \"modify-conf\": \"/etc/suricata/modify.conf\",",
            "    \"suricata-conf\": \"/etc/suricata/suricata.conf\",",
            "    \"sources\": [],",
            "    LOCAL_CONF_KEY: [],",
            "",
            "    # The default file patterns to ignore.",
            "    \"ignore\": [",
            "        \"*deleted.rules\",",
            "    ],",
            "}",
            "",
            "_args = None",
            "_config = {}",
            "",
            "def set(key, value):",
            "    \"\"\"Set a configuration value.\"\"\"",
            "    _config[key] = value",
            "",
            "def get(key):",
            "    \"\"\"Get a configuration value.\"\"\"",
            "    if key in _config:",
            "        return _config[key]",
            "    return None",
            "",
            "def set_state_dir(directory):",
            "    _config[DATA_DIRECTORY_KEY] = directory",
            "",
            "def get_state_dir():",
            "    \"\"\"Get the data directory. This is more of the Suricata state",
            "    directory than a specific Suricata-Update directory, and is used",
            "    as the root directory for Suricata-Update data.",
            "    \"\"\"",
            "    if os.getenv(\"DATA_DIRECTORY\"):",
            "        return os.getenv(\"DATA_DIRECTORY\")",
            "    if DATA_DIRECTORY_KEY in _config:",
            "        return _config[DATA_DIRECTORY_KEY]",
            "    return DEFAULT_DATA_DIRECTORY",
            "",
            "def set_cache_dir(directory):",
            "    \"\"\"Set an alternate cache directory.\"\"\"",
            "    _config[CACHE_DIRECTORY_KEY] = directory",
            "",
            "def get_cache_dir():",
            "    \"\"\"Get the cache directory.\"\"\"",
            "    if CACHE_DIRECTORY_KEY in _config:",
            "        return _config[CACHE_DIRECTORY_KEY]",
            "    return os.path.join(get_state_dir(), CACHE_DIRECTORY)",
            "",
            "def get_output_dir():",
            "    \"\"\"Get the rule output directory.\"\"\"",
            "    if OUTPUT_KEY in _config:",
            "        return _config[OUTPUT_KEY]",
            "    return os.path.join(get_state_dir(), \"rules\")",
            "",
            "def args():",
            "    \"\"\"Return sthe parsed argument object.\"\"\"",
            "    return _args",
            "",
            "def get_arg(key):",
            "    key = key.replace(\"-\", \"_\")",
            "    if hasattr(_args, key):",
            "        val = getattr(_args, key)",
            "        if val not in [[], None]:",
            "            return val",
            "    return None",
            "",
            "def init(args):",
            "    global _args",
            "",
            "    _args = args",
            "    _config.update(DEFAULT_CONFIG)",
            "",
            "    for suriyaml in DEFAULT_SURICATA_YAML_PATH:",
            "        if os.path.exists(suriyaml):",
            "            _config[\"suricata-conf\"] = suriyaml",
            "            break",
            "",
            "    if args.config:",
            "        logger.info(\"Loading %s\", args.config)",
            "        with open(args.config, \"rb\") as fileobj:",
            "            config = yaml.load(fileobj)",
            "            if config:",
            "                _config.update(config)",
            "    elif os.path.exists(DEFAULT_UPDATE_YAML_PATH):",
            "        logger.info(\"Loading %s\", DEFAULT_UPDATE_YAML_PATH)",
            "        with open(DEFAULT_UPDATE_YAML_PATH, \"rb\") as fileobj:",
            "            config = yaml.load(fileobj)",
            "            if config:",
            "                _config.update(config)",
            "",
            "    # Apply command line arguments to the config.",
            "",
            "    for arg in vars(args):",
            "        if arg == \"local\":",
            "            for local in args.local:",
            "                logger.debug(\"Adding local ruleset to config: %s\", local)",
            "                _config[LOCAL_CONF_KEY].append(local)",
            "        elif arg == \"data_dir\" and args.data_dir:",
            "            logger.debug(\"Setting data directory to %s\", args.data_dir)",
            "            _config[DATA_DIRECTORY_KEY] = args.data_dir",
            "        elif getattr(args, arg):",
            "            _config[arg.replace(\"_\", \"-\")] = getattr(args, arg)"
        ],
        "afterPatchFile": [
            "# Copyright (C) 2017 Open Information Security Foundation",
            "# Copyright (c) 2015-2017 Jason Ish",
            "#",
            "# You can copy, redistribute or modify this Program under the terms of",
            "# the GNU General Public License version 2 as published by the Free",
            "# Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# version 2 along with this program; if not, write to the Free Software",
            "# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA",
            "# 02110-1301, USA.",
            "",
            "import os.path",
            "import logging",
            "",
            "import yaml",
            "",
            "logger = logging.getLogger()",
            "",
            "DEFAULT_DATA_DIRECTORY = \"/var/lib/suricata\"",
            "",
            "# Cache directory - relative to the data directory.",
            "CACHE_DIRECTORY = os.path.join(\"update\", \"cache\")",
            "",
            "# Source directory - relative to the data directory.",
            "SOURCE_DIRECTORY = os.path.join(\"update\", \"sources\")",
            "",
            "# Configuration keys.",
            "DATA_DIRECTORY_KEY = \"data-directory\"",
            "CACHE_DIRECTORY_KEY = \"cache-directory\"",
            "IGNORE_KEY = \"ignore\"",
            "DISABLE_CONF_KEY = \"disable-conf\"",
            "ENABLE_CONF_KEY = \"enable-conf\"",
            "MODIFY_CONF_KEY = \"modify-conf\"",
            "DROP_CONF_KEY = \"drop-conf\"",
            "LOCAL_CONF_KEY = \"local\"",
            "OUTPUT_KEY = \"output\"",
            "",
            "DEFAULT_UPDATE_YAML_PATH = \"/etc/suricata/update.yaml\"",
            "",
            "DEFAULT_SURICATA_YAML_PATH = [",
            "    \"/etc/suricata/suricata.yaml\",",
            "    \"/usr/local/etc/suricata/suricata.yaml\",",
            "    \"/etc/suricata/suricata-debian.yaml\"",
            "]",
            "",
            "DEFAULT_CONFIG = {",
            "    \"disable-conf\": \"/etc/suricata/disable.conf\",",
            "    \"enable-conf\": \"/etc/suricata/enable.conf\",",
            "    \"drop-conf\": \"/etc/suricata/drop.conf\",",
            "    \"modify-conf\": \"/etc/suricata/modify.conf\",",
            "    \"suricata-conf\": \"/etc/suricata/suricata.conf\",",
            "    \"sources\": [],",
            "    LOCAL_CONF_KEY: [],",
            "",
            "    # The default file patterns to ignore.",
            "    \"ignore\": [",
            "        \"*deleted.rules\",",
            "    ],",
            "}",
            "",
            "_args = None",
            "_config = {}",
            "",
            "def set(key, value):",
            "    \"\"\"Set a configuration value.\"\"\"",
            "    _config[key] = value",
            "",
            "def get(key):",
            "    \"\"\"Get a configuration value.\"\"\"",
            "    if key in _config:",
            "        return _config[key]",
            "    return None",
            "",
            "def set_state_dir(directory):",
            "    _config[DATA_DIRECTORY_KEY] = directory",
            "",
            "def get_state_dir():",
            "    \"\"\"Get the data directory. This is more of the Suricata state",
            "    directory than a specific Suricata-Update directory, and is used",
            "    as the root directory for Suricata-Update data.",
            "    \"\"\"",
            "    if os.getenv(\"DATA_DIRECTORY\"):",
            "        return os.getenv(\"DATA_DIRECTORY\")",
            "    if DATA_DIRECTORY_KEY in _config:",
            "        return _config[DATA_DIRECTORY_KEY]",
            "    return DEFAULT_DATA_DIRECTORY",
            "",
            "def set_cache_dir(directory):",
            "    \"\"\"Set an alternate cache directory.\"\"\"",
            "    _config[CACHE_DIRECTORY_KEY] = directory",
            "",
            "def get_cache_dir():",
            "    \"\"\"Get the cache directory.\"\"\"",
            "    if CACHE_DIRECTORY_KEY in _config:",
            "        return _config[CACHE_DIRECTORY_KEY]",
            "    return os.path.join(get_state_dir(), CACHE_DIRECTORY)",
            "",
            "def get_output_dir():",
            "    \"\"\"Get the rule output directory.\"\"\"",
            "    if OUTPUT_KEY in _config:",
            "        return _config[OUTPUT_KEY]",
            "    return os.path.join(get_state_dir(), \"rules\")",
            "",
            "def args():",
            "    \"\"\"Return sthe parsed argument object.\"\"\"",
            "    return _args",
            "",
            "def get_arg(key):",
            "    key = key.replace(\"-\", \"_\")",
            "    if hasattr(_args, key):",
            "        val = getattr(_args, key)",
            "        if val not in [[], None]:",
            "            return val",
            "    return None",
            "",
            "def init(args):",
            "    global _args",
            "",
            "    _args = args",
            "    _config.update(DEFAULT_CONFIG)",
            "",
            "    for suriyaml in DEFAULT_SURICATA_YAML_PATH:",
            "        if os.path.exists(suriyaml):",
            "            _config[\"suricata-conf\"] = suriyaml",
            "            break",
            "",
            "    if args.config:",
            "        logger.info(\"Loading %s\", args.config)",
            "        with open(args.config, \"rb\") as fileobj:",
            "            config = yaml.safe_load(fileobj)",
            "            if config:",
            "                _config.update(config)",
            "    elif os.path.exists(DEFAULT_UPDATE_YAML_PATH):",
            "        logger.info(\"Loading %s\", DEFAULT_UPDATE_YAML_PATH)",
            "        with open(DEFAULT_UPDATE_YAML_PATH, \"rb\") as fileobj:",
            "            config = yaml.safe_load(fileobj)",
            "            if config:",
            "                _config.update(config)",
            "",
            "    # Apply command line arguments to the config.",
            "",
            "    for arg in vars(args):",
            "        if arg == \"local\":",
            "            for local in args.local:",
            "                logger.debug(\"Adding local ruleset to config: %s\", local)",
            "                _config[LOCAL_CONF_KEY].append(local)",
            "        elif arg == \"data_dir\" and args.data_dir:",
            "            logger.debug(\"Setting data directory to %s\", args.data_dir)",
            "            _config[DATA_DIRECTORY_KEY] = args.data_dir",
            "        elif getattr(args, arg):",
            "            _config[arg.replace(\"_\", \"-\")] = getattr(args, arg)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "136": [
                "init"
            ],
            "142": [
                "init"
            ]
        },
        "addLocation": []
    },
    "suricata/update/sources.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         self.reload()"
            },
            "1": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     def reload(self):"
            },
            "3": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        index = yaml.load(open(self.filename, \"rb\"))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        index = yaml.safe_load(open(self.filename, \"rb\"))"
            },
            "5": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         self.index = index"
            },
            "6": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def resolve_url(self, name, params={}):"
            },
            "8": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         for filename in filenames:"
            },
            "9": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "             if filename.endswith(\".yaml\"):"
            },
            "10": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "                 path = os.path.join(dirpath, filename)"
            },
            "11": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                source = yaml.load(open(path, \"rb\"))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+                source = yaml.safe_load(open(path, \"rb\"))"
            },
            "13": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                 sources[source[\"source\"]] = source"
            },
            "14": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                 if \"params\" in source:"
            }
        },
        "frontPatchFile": [
            "# Copyright (C) 2017 Open Information Security Foundation",
            "#",
            "# You can copy, redistribute or modify this Program under the terms of",
            "# the GNU General Public License version 2 as published by the Free",
            "# Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# version 2 along with this program; if not, write to the Free Software",
            "# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA",
            "# 02110-1301, USA.",
            "",
            "from __future__ import print_function",
            "",
            "import os",
            "import logging",
            "import io",
            "import argparse",
            "",
            "import yaml",
            "",
            "from suricata.update import config",
            "from suricata.update import net",
            "from suricata.update import util",
            "from suricata.update import loghandler",
            "",
            "logger = logging.getLogger()",
            "",
            "DEFAULT_SOURCE_INDEX_URL = \"https://www.openinfosecfoundation.org/rules/index.yaml\"",
            "SOURCE_INDEX_FILENAME = \"index.yaml\"",
            "",
            "DEFAULT_ETOPEN_URL = \"https://rules.emergingthreats.net/open/suricata-%(__version__)s/emerging.rules.tar.gz\"",
            "",
            "def get_source_directory():",
            "    \"\"\"Return the directory where source configuration files are kept.\"\"\"",
            "    return os.path.join(config.get_state_dir(), config.SOURCE_DIRECTORY)",
            "",
            "def get_index_filename():",
            "    return os.path.join(config.get_cache_dir(), SOURCE_INDEX_FILENAME)",
            "",
            "def get_enabled_source_filename(name):",
            "    return os.path.join(get_source_directory(), \"%s.yaml\" % (",
            "        safe_filename(name)))",
            "",
            "def get_disabled_source_filename(name):",
            "    return os.path.join(get_source_directory(), \"%s.yaml.disabled\" % (",
            "        safe_filename(name)))",
            "",
            "def source_name_exists(name):",
            "    \"\"\"Return True if a source already exists with name.\"\"\"",
            "    if os.path.exists(get_enabled_source_filename(name)) or \\",
            "       os.path.exists(get_disabled_source_filename(name)):",
            "        return True",
            "    return False",
            "",
            "def source_index_exists(config):",
            "    \"\"\"Return True if the source index file exists.\"\"\"",
            "    return os.path.exists(get_index_filename())",
            "",
            "def get_source_index_url():",
            "    if os.getenv(\"SOURCE_INDEX_URL\"):",
            "        return os.getenv(\"SOURCE_INDEX_URL\")",
            "    return DEFAULT_SOURCE_INDEX_URL",
            "",
            "def save_source_config(source_config):",
            "    with open(get_enabled_source_filename(source_config.name), \"w\") as fileobj:",
            "        fileobj.write(yaml.safe_dump(",
            "            source_config.dict(), default_flow_style=False))",
            "",
            "class SourceConfiguration:",
            "",
            "    def __init__(self, name, url=None, params={}):",
            "        self.name = name",
            "        self.url = url",
            "        self.params = params",
            "",
            "    def dict(self):",
            "        d = {",
            "            \"source\": self.name,",
            "        }",
            "        if self.url:",
            "            d[\"url\"] = self.url",
            "        if self.params:",
            "            d[\"params\"] = self.params",
            "        return d",
            "",
            "class Index:",
            "",
            "    def __init__(self, filename):",
            "        self.filename = filename",
            "        self.index = {}",
            "        self.reload()",
            "",
            "    def reload(self):",
            "        index = yaml.load(open(self.filename, \"rb\"))",
            "        self.index = index",
            "",
            "    def resolve_url(self, name, params={}):",
            "        if not name in self.index[\"sources\"]:",
            "            raise Exception(\"Source name not in index: %s\" % (name))",
            "        source = self.index[\"sources\"][name]",
            "        try:",
            "            return source[\"url\"] % params",
            "        except KeyError as err:",
            "            raise Exception(\"Missing URL parameter: %s\" % (str(err.args[0])))",
            "",
            "    def get_sources(self):",
            "        return self.index[\"sources\"]",
            "",
            "    def get_source_by_name(self, name):",
            "        if name in self.index[\"sources\"]:",
            "            return self.index[\"sources\"][name]",
            "        return None",
            "",
            "def load_source_index(config):",
            "    return Index(get_index_filename())",
            "",
            "def get_enabled_sources():",
            "    \"\"\"Return a map of enabled sources, keyed by name.\"\"\"",
            "    if not os.path.exists(get_source_directory()):",
            "        return {}",
            "    sources = {}",
            "    for dirpath, dirnames, filenames in os.walk(get_source_directory()):",
            "        for filename in filenames:",
            "            if filename.endswith(\".yaml\"):",
            "                path = os.path.join(dirpath, filename)",
            "                source = yaml.load(open(path, \"rb\"))",
            "                sources[source[\"source\"]] = source",
            "",
            "                if \"params\" in source:",
            "                    for param in source[\"params\"]:",
            "                        if param.startswith(\"secret\"):",
            "                            loghandler.add_secret(source[\"params\"][param], param)",
            "",
            "    return sources",
            "",
            "def remove_source(config):",
            "    name = config.args.name",
            "",
            "    enabled_source_filename = get_enabled_source_filename(name)",
            "    if os.path.exists(enabled_source_filename):",
            "        logger.debug(\"Deleting file %s.\", enabled_source_filename)",
            "        os.remove(enabled_source_filename)",
            "        logger.info(\"Source %s removed, previously enabled.\", name)",
            "        return 0",
            "",
            "    disabled_source_filename = get_disabled_source_filename(name)",
            "    if os.path.exists(disabled_source_filename):",
            "        logger.debug(\"Deleting file %s.\", disabled_source_filename)",
            "        os.remove(disabled_source_filename)",
            "        logger.info(\"Source %s removed, previously disabled.\", name)",
            "        return 0",
            "",
            "    logger.warning(\"Source %s does not exist.\", name)",
            "    return 1",
            "",
            "def safe_filename(name):",
            "    \"\"\"Utility function to make a source short-name safe as a",
            "    filename.\"\"\"",
            "    name = name.replace(\"/\", \"-\")",
            "    return name",
            "",
            "def get_etopen_url(params):",
            "    if os.getenv(\"ETOPEN_URL\"):",
            "        return os.getenv(\"ETOPEN_URL\") % params",
            "    return DEFAULT_ETOPEN_URL % params"
        ],
        "afterPatchFile": [
            "# Copyright (C) 2017 Open Information Security Foundation",
            "#",
            "# You can copy, redistribute or modify this Program under the terms of",
            "# the GNU General Public License version 2 as published by the Free",
            "# Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# version 2 along with this program; if not, write to the Free Software",
            "# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA",
            "# 02110-1301, USA.",
            "",
            "from __future__ import print_function",
            "",
            "import os",
            "import logging",
            "import io",
            "import argparse",
            "",
            "import yaml",
            "",
            "from suricata.update import config",
            "from suricata.update import net",
            "from suricata.update import util",
            "from suricata.update import loghandler",
            "",
            "logger = logging.getLogger()",
            "",
            "DEFAULT_SOURCE_INDEX_URL = \"https://www.openinfosecfoundation.org/rules/index.yaml\"",
            "SOURCE_INDEX_FILENAME = \"index.yaml\"",
            "",
            "DEFAULT_ETOPEN_URL = \"https://rules.emergingthreats.net/open/suricata-%(__version__)s/emerging.rules.tar.gz\"",
            "",
            "def get_source_directory():",
            "    \"\"\"Return the directory where source configuration files are kept.\"\"\"",
            "    return os.path.join(config.get_state_dir(), config.SOURCE_DIRECTORY)",
            "",
            "def get_index_filename():",
            "    return os.path.join(config.get_cache_dir(), SOURCE_INDEX_FILENAME)",
            "",
            "def get_enabled_source_filename(name):",
            "    return os.path.join(get_source_directory(), \"%s.yaml\" % (",
            "        safe_filename(name)))",
            "",
            "def get_disabled_source_filename(name):",
            "    return os.path.join(get_source_directory(), \"%s.yaml.disabled\" % (",
            "        safe_filename(name)))",
            "",
            "def source_name_exists(name):",
            "    \"\"\"Return True if a source already exists with name.\"\"\"",
            "    if os.path.exists(get_enabled_source_filename(name)) or \\",
            "       os.path.exists(get_disabled_source_filename(name)):",
            "        return True",
            "    return False",
            "",
            "def source_index_exists(config):",
            "    \"\"\"Return True if the source index file exists.\"\"\"",
            "    return os.path.exists(get_index_filename())",
            "",
            "def get_source_index_url():",
            "    if os.getenv(\"SOURCE_INDEX_URL\"):",
            "        return os.getenv(\"SOURCE_INDEX_URL\")",
            "    return DEFAULT_SOURCE_INDEX_URL",
            "",
            "def save_source_config(source_config):",
            "    with open(get_enabled_source_filename(source_config.name), \"w\") as fileobj:",
            "        fileobj.write(yaml.safe_dump(",
            "            source_config.dict(), default_flow_style=False))",
            "",
            "class SourceConfiguration:",
            "",
            "    def __init__(self, name, url=None, params={}):",
            "        self.name = name",
            "        self.url = url",
            "        self.params = params",
            "",
            "    def dict(self):",
            "        d = {",
            "            \"source\": self.name,",
            "        }",
            "        if self.url:",
            "            d[\"url\"] = self.url",
            "        if self.params:",
            "            d[\"params\"] = self.params",
            "        return d",
            "",
            "class Index:",
            "",
            "    def __init__(self, filename):",
            "        self.filename = filename",
            "        self.index = {}",
            "        self.reload()",
            "",
            "    def reload(self):",
            "        index = yaml.safe_load(open(self.filename, \"rb\"))",
            "        self.index = index",
            "",
            "    def resolve_url(self, name, params={}):",
            "        if not name in self.index[\"sources\"]:",
            "            raise Exception(\"Source name not in index: %s\" % (name))",
            "        source = self.index[\"sources\"][name]",
            "        try:",
            "            return source[\"url\"] % params",
            "        except KeyError as err:",
            "            raise Exception(\"Missing URL parameter: %s\" % (str(err.args[0])))",
            "",
            "    def get_sources(self):",
            "        return self.index[\"sources\"]",
            "",
            "    def get_source_by_name(self, name):",
            "        if name in self.index[\"sources\"]:",
            "            return self.index[\"sources\"][name]",
            "        return None",
            "",
            "def load_source_index(config):",
            "    return Index(get_index_filename())",
            "",
            "def get_enabled_sources():",
            "    \"\"\"Return a map of enabled sources, keyed by name.\"\"\"",
            "    if not os.path.exists(get_source_directory()):",
            "        return {}",
            "    sources = {}",
            "    for dirpath, dirnames, filenames in os.walk(get_source_directory()):",
            "        for filename in filenames:",
            "            if filename.endswith(\".yaml\"):",
            "                path = os.path.join(dirpath, filename)",
            "                source = yaml.safe_load(open(path, \"rb\"))",
            "                sources[source[\"source\"]] = source",
            "",
            "                if \"params\" in source:",
            "                    for param in source[\"params\"]:",
            "                        if param.startswith(\"secret\"):",
            "                            loghandler.add_secret(source[\"params\"][param], param)",
            "",
            "    return sources",
            "",
            "def remove_source(config):",
            "    name = config.args.name",
            "",
            "    enabled_source_filename = get_enabled_source_filename(name)",
            "    if os.path.exists(enabled_source_filename):",
            "        logger.debug(\"Deleting file %s.\", enabled_source_filename)",
            "        os.remove(enabled_source_filename)",
            "        logger.info(\"Source %s removed, previously enabled.\", name)",
            "        return 0",
            "",
            "    disabled_source_filename = get_disabled_source_filename(name)",
            "    if os.path.exists(disabled_source_filename):",
            "        logger.debug(\"Deleting file %s.\", disabled_source_filename)",
            "        os.remove(disabled_source_filename)",
            "        logger.info(\"Source %s removed, previously disabled.\", name)",
            "        return 0",
            "",
            "    logger.warning(\"Source %s does not exist.\", name)",
            "    return 1",
            "",
            "def safe_filename(name):",
            "    \"\"\"Utility function to make a source short-name safe as a",
            "    filename.\"\"\"",
            "    name = name.replace(\"/\", \"-\")",
            "    return name",
            "",
            "def get_etopen_url(params):",
            "    if os.getenv(\"ETOPEN_URL\"):",
            "        return os.getenv(\"ETOPEN_URL\") % params",
            "    return DEFAULT_ETOPEN_URL % params"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "99": [
                "Index",
                "reload"
            ],
            "131": [
                "get_enabled_sources"
            ]
        },
        "addLocation": []
    }
}