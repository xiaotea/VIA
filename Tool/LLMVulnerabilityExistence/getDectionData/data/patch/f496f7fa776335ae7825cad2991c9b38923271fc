{
    "python/composio/tools/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "         )"
            },
            "1": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "         self.max_retries = max_retries"
            },
            "2": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+        # To be populated by get_tools(), from within subclasses like"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+        # composio_openai's Toolset."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        self._requested_actions: t.Optional[t.List[str]] = None"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "     def _validating_connection_ids("
            },
            "8": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         self,"
            },
            "9": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         connected_account_ids: t.Dict[AppType, str],"
            },
            "10": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": 801,
                "PatchRowcode": "         :return: Output object from the function call"
            },
            "11": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": 802,
                "PatchRowcode": "         \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": 803,
                "PatchRowcode": "         action = Action(action)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 804,
                "PatchRowcode": "+        if ("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 805,
                "PatchRowcode": "+            self._requested_actions is not None"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 806,
                "PatchRowcode": "+            and action.slug not in self._requested_actions"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 807,
                "PatchRowcode": "+        ):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 808,
                "PatchRowcode": "+            raise ComposioSDKError("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 809,
                "PatchRowcode": "+                f\"Action {action.slug} is being called, but was never requested by the toolset. \""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 810,
                "PatchRowcode": "+                \"Make sure that the actions you are trying to execute are requested in your \""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 811,
                "PatchRowcode": "+                \"`get_tools()` call.\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 812,
                "PatchRowcode": "+            )"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 813,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": 814,
                "PatchRowcode": "         params = self._serialize_execute_params(param=params)"
            },
            "24": {
                "beforePatchRowNumber": 801,
                "afterPatchRowNumber": 815,
                "PatchRowcode": "         if processors is not None:"
            },
            "25": {
                "beforePatchRowNumber": 802,
                "afterPatchRowNumber": 816,
                "PatchRowcode": "             self._merge_processors(processors)"
            },
            "26": {
                "beforePatchRowNumber": 932,
                "afterPatchRowNumber": 946,
                "PatchRowcode": "         # NOTE: This an experimental, can convert to decorator for more convinience"
            },
            "27": {
                "beforePatchRowNumber": 933,
                "afterPatchRowNumber": 947,
                "PatchRowcode": "         if not apps and not actions and not tags:"
            },
            "28": {
                "beforePatchRowNumber": 934,
                "afterPatchRowNumber": 948,
                "PatchRowcode": "             return"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 949,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": 935,
                "afterPatchRowNumber": 950,
                "PatchRowcode": "         self.workspace.check_for_missing_dependencies("
            },
            "31": {
                "beforePatchRowNumber": 936,
                "afterPatchRowNumber": 951,
                "PatchRowcode": "             apps=apps,"
            },
            "32": {
                "beforePatchRowNumber": 937,
                "afterPatchRowNumber": 952,
                "PatchRowcode": "             actions=actions,"
            },
            "33": {
                "beforePatchRowNumber": 945,
                "afterPatchRowNumber": 960,
                "PatchRowcode": "         tags: t.Optional[t.Sequence[TagType]] = None,"
            },
            "34": {
                "beforePatchRowNumber": 946,
                "afterPatchRowNumber": 961,
                "PatchRowcode": "         *,"
            },
            "35": {
                "beforePatchRowNumber": 947,
                "afterPatchRowNumber": 962,
                "PatchRowcode": "         check_connected_accounts: bool = True,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 963,
                "PatchRowcode": "+        _populate_requested: bool = False,"
            },
            "37": {
                "beforePatchRowNumber": 948,
                "afterPatchRowNumber": 964,
                "PatchRowcode": "     ) -> t.List[ActionModel]:"
            },
            "38": {
                "beforePatchRowNumber": 949,
                "afterPatchRowNumber": 965,
                "PatchRowcode": "         runtime_actions = t.cast("
            },
            "39": {
                "beforePatchRowNumber": 950,
                "afterPatchRowNumber": 966,
                "PatchRowcode": "             t.List[t.Type[LocalAction]],"
            },
            "40": {
                "beforePatchRowNumber": 1010,
                "afterPatchRowNumber": 1026,
                "PatchRowcode": "             if item.name == Action.ANTHROPIC_TEXT_EDITOR.slug:"
            },
            "41": {
                "beforePatchRowNumber": 1011,
                "afterPatchRowNumber": 1027,
                "PatchRowcode": "                 item.name = \"str_replace_editor\""
            },
            "42": {
                "beforePatchRowNumber": 1012,
                "afterPatchRowNumber": 1028,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1029,
                "PatchRowcode": "+        if _populate_requested:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1030,
                "PatchRowcode": "+            action_names = [item.name for item in items]"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1031,
                "PatchRowcode": "+            if self._requested_actions is None:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1032,
                "PatchRowcode": "+                self._requested_actions = []"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1033,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1034,
                "PatchRowcode": "+            self._requested_actions += action_names"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1035,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": 1013,
                "afterPatchRowNumber": 1036,
                "PatchRowcode": "         return items"
            },
            "51": {
                "beforePatchRowNumber": 1014,
                "afterPatchRowNumber": 1037,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 1015,
                "afterPatchRowNumber": 1038,
                "PatchRowcode": "     def _process_schema(self, action_item: ActionModel) -> ActionModel:"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Composio SDK tools.",
            "\"\"\"",
            "",
            "import base64",
            "import binascii",
            "import hashlib",
            "import itertools",
            "import json",
            "import os",
            "import time",
            "import typing as t",
            "import uuid",
            "import warnings",
            "from datetime import datetime",
            "from functools import wraps",
            "from importlib.util import find_spec",
            "from pathlib import Path",
            "",
            "import typing_extensions as te",
            "from pydantic import BaseModel",
            "",
            "from composio import Action, ActionType, App, AppType, TagType",
            "from composio.client import Composio, Entity",
            "from composio.client.collections import (",
            "    AUTH_SCHEMES,",
            "    ActionModel,",
            "    AppAuthScheme,",
            "    AppModel,",
            "    AuthSchemeField,",
            "    AuthSchemeType,",
            "    ConnectedAccountModel,",
            "    ConnectionParams,",
            "    ConnectionRequestModel,",
            "    CustomAuthObject,",
            "    CustomAuthParameter,",
            "    ExpectedFieldInput,",
            "    FileType,",
            "    IntegrationModel,",
            "    SuccessExecuteActionResponseModel,",
            "    TriggerModel,",
            "    TriggerSubscription,",
            ")",
            "from composio.client.enums import TriggerType",
            "from composio.client.enums.base import EnumStringNotFound",
            "from composio.client.exceptions import ComposioClientError, HTTPError, NoItemsFound",
            "from composio.client.utils import check_cache_refresh",
            "from composio.constants import (",
            "    DEFAULT_ENTITY_ID,",
            "    ENV_COMPOSIO_API_KEY,",
            "    LOCAL_CACHE_DIRECTORY,",
            "    LOCAL_OUTPUT_FILE_DIRECTORY_NAME,",
            "    USER_DATA_FILE_NAME,",
            ")",
            "from composio.exceptions import ApiKeyNotProvidedError, ComposioSDKError",
            "from composio.storage.user import UserData",
            "from composio.tools.base.abs import tool_registry",
            "from composio.tools.base.local import LocalAction",
            "from composio.tools.env.base import (",
            "    ENV_GITHUB_ACCESS_TOKEN,",
            "    Workspace,",
            "    WorkspaceConfigType,",
            ")",
            "from composio.tools.env.factory import HostWorkspaceConfig, WorkspaceFactory",
            "from composio.tools.local import load_local_tools",
            "from composio.tools.local.handler import LocalClient",
            "from composio.utils.enums import get_enum_key",
            "from composio.utils.logging import LogIngester, LogLevel, WithLogger",
            "from composio.utils.url import get_api_url_base",
            "",
            "",
            "T = te.TypeVar(\"T\")",
            "P = te.ParamSpec(\"P\")",
            "",
            "_KeyType = t.Union[AppType, ActionType]",
            "_CallableType = t.Callable[[t.Dict], t.Dict]",
            "",
            "MetadataType = t.Dict[_KeyType, t.Dict]",
            "ParamType = t.TypeVar(\"ParamType\")",
            "ProcessorType = te.Literal[\"pre\", \"post\", \"schema\"]",
            "",
            "_IS_CI: t.Optional[bool] = None",
            "",
            "",
            "class IntegrationParams(te.TypedDict):",
            "",
            "    integration_id: str",
            "    auth_scheme: str",
            "    expected_params: t.List[ExpectedFieldInput]",
            "",
            "",
            "class ProcessorsType(te.TypedDict):",
            "    \"\"\"Request and response processors.\"\"\"",
            "",
            "    pre: te.NotRequired[t.Dict[_KeyType, _CallableType]]",
            "    \"\"\"Request processors.\"\"\"",
            "",
            "    post: te.NotRequired[t.Dict[_KeyType, _CallableType]]",
            "    \"\"\"Response processors.\"\"\"",
            "",
            "    schema: te.NotRequired[t.Dict[_KeyType, _CallableType]]",
            "    \"\"\"Schema processors\"\"\"",
            "",
            "",
            "def _check_agentops() -> bool:",
            "    \"\"\"Check if AgentOps is installed and initialized.\"\"\"",
            "    if find_spec(\"agentops\") is None:",
            "        return False",
            "    import agentops  # pylint: disable=import-outside-toplevel # type: ignore",
            "",
            "    return agentops.get_api_key() is not None",
            "",
            "",
            "def _is_ci():",
            "    global _IS_CI",
            "    if _IS_CI is None:",
            "        _IS_CI = os.environ.get(\"CI\") == \"true\"",
            "    return _IS_CI",
            "",
            "",
            "def _record_action_if_available(func: t.Callable[P, T]) -> t.Callable[P, T]:",
            "    @wraps(func)",
            "    def wrapper(self, *args, **kwargs):",
            "        if _check_agentops():",
            "            import agentops  # pylint: disable=import-outside-toplevel # type: ignore",
            "",
            "            action_name = str(kwargs.get(\"action\", \"unknown_action\"))",
            "            return agentops.record_action(action_name)(func)(self, *args, **kwargs)",
            "        return func(self, *args, **kwargs)  # type: ignore",
            "",
            "    return wrapper  # type: ignore",
            "",
            "",
            "class _Retry:",
            "    \"\"\"Sentinel value to indicate that the processor should retry the action\"\"\"",
            "",
            "",
            "RETRY = _Retry()",
            "",
            "",
            "class ComposioToolSet(WithLogger):  # pylint: disable=too-many-public-methods",
            "    \"\"\"Composio toolset.\"\"\"",
            "",
            "    _custom_auth: t.Dict[App, CustomAuthObject]",
            "",
            "    _connected_accounts: t.Optional[t.List[ConnectedAccountModel]] = None",
            "    _remote_client: t.Optional[Composio] = None",
            "    _workspace: t.Optional[Workspace] = None",
            "",
            "    _runtime: str = \"composio\"",
            "    _description_char_limit: int = 1024",
            "    _action_name_char_limit: t.Optional[int] = None",
            "    _log_ingester_client: t.Optional[LogIngester] = None",
            "",
            "    def __init_subclass__(",
            "        cls,",
            "        *args: t.Any,",
            "        runtime: t.Optional[str] = None,",
            "        description_char_limit: t.Optional[int] = None,",
            "        action_name_char_limit: t.Optional[int] = None,",
            "        **kwargs: t.Any,",
            "    ) -> None:",
            "        if runtime is None:",
            "            warnings.warn(",
            "                f\"runtime is not set on {cls.__name__}, using 'composio' as default\"",
            "            )",
            "        cls._runtime = runtime or \"composio\"",
            "",
            "        if description_char_limit is None:",
            "            warnings.warn(",
            "                f\"description_char_limit is not set on {cls.__name__}, using 1024 as default\"",
            "            )",
            "        cls._description_char_limit = description_char_limit or 1024",
            "        cls._action_name_char_limit = action_name_char_limit",
            "        if len(args) > 0 or len(kwargs) > 0:",
            "            error = (",
            "                f\"Composio toolset subclass initializer got extra {args=} and {kwargs=}\"",
            "            )",
            "            if _is_ci():",
            "                raise RuntimeError(error)",
            "            warnings.warn(error)",
            "",
            "    def __init__(",
            "        self,",
            "        api_key: t.Optional[str] = None,",
            "        base_url: t.Optional[str] = None,",
            "        entity_id: str = DEFAULT_ENTITY_ID,",
            "        workspace_id: t.Optional[str] = None,",
            "        workspace_config: t.Optional[WorkspaceConfigType] = None,",
            "        metadata: t.Optional[MetadataType] = None,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        output_in_file: bool = False,",
            "        logging_level: LogLevel = LogLevel.INFO,",
            "        output_dir: t.Optional[Path] = None,",
            "        verbosity_level: t.Optional[int] = None,",
            "        connected_account_ids: t.Optional[t.Dict[AppType, str]] = None,",
            "        *,",
            "        max_retries: int = 3,",
            "        **kwargs: t.Any,",
            "    ) -> None:",
            "        \"\"\"",
            "        Initialize composio toolset",
            "",
            "        :param api_key: Composio API key",
            "        :param base_url: Base URL for the Composio API server",
            "        :param runtime: Name of the framework runtime, eg. openai, crewai...",
            "        :param output_in_file: Whether to output the result to a file.",
            "        :param entity_id: The ID of the entity to execute the action on.",
            "            Defaults to \"default\".",
            "        :param workspace_env: Environment where actions should be executed,",
            "            you can choose from `host`, `docker`, `flyio` and `e2b`.",
            "        :param workspace_id: Workspace ID for loading an existing workspace",
            "        :param metadata: Additional metadata for executing an action or an",
            "            action which belongs to a specific app. The additional metadata",
            "            needs to be JSON serialisable dictionary. For example",
            "",
            "            ```python",
            "            toolset = ComposioToolSet(",
            "                ...,",
            "                metadata={",
            "                    App.IMAGEANALYSER: {",
            "                        \"base_url\": \"https://image.analyser/api\",",
            "                    },",
            "                    Action.IMAGEANALYSER_GTP4:{",
            "                        \"openai_api_key\": \"sk-proj-somekey\",",
            "                    }",
            "                }",
            "            )",
            "            ```",
            "        :param processors: Request and response processors, use these to",
            "            pre-process requests before executing an action and post-process",
            "            the response after an action has been executed. The processors can",
            "            be defined at app and action level. The order of execution will be",
            "",
            "            `App pre-processor -> Action pre-processor -> execute action -> Action post-processor -> App post-processor`",
            "",
            "            Heres and example of a request pre-processor",
            "",
            "            ```python",
            "            def _add_cwd_if_missing(request: t.Dict) -> t.Dict:",
            "                if \"cwd\" not in request:",
            "                    request[\"cwd\"] = \"~/project\"",
            "                return request",
            "",
            "            def _sanitise_file_search_request(request: t.Dict) -> t.Dict:",
            "                if \".tox\" not in request[\"exclude\"]:",
            "                    request[\"exclude\"].append(\".tox\")",
            "                return request",
            "",
            "            def _limit_file_search_response(response: t.Dict) -> t.Dict:",
            "                if len(response[\"results\"]) > 100:",
            "                    response[\"results\"] = response[\"results\"][:100]",
            "                return response",
            "",
            "            toolset = ComposioToolSet(",
            "                ...,",
            "                processors={",
            "                    \"pre\": {",
            "                        App.FILETOOL: _add_cwd_if_missing,",
            "                        Action.FILETOOL_SEARCH: _sanitise_file_search_request,",
            "                    },",
            "                    \"post\": {",
            "                        Action.FILETOOL_SEARCH: _limit_file_search_response,",
            "                    }",
            "                }",
            "            )",
            "            ```",
            "        :param verbosity_level: This defines the size of the log object that will",
            "            be printed on the console.",
            "        :param connection_ids: Use this to define connection IDs to use when executing",
            "            an action for a specific app.",
            "        \"\"\"",
            "        super().__init__(",
            "            logging_level=logging_level,",
            "            verbosity_level=verbosity_level,",
            "        )",
            "        self.logger.info(",
            "            f\"Logging is set to {self._logging_level}, \"",
            "            \"use `logging_level` argument or \"",
            "            \"`COMPOSIO_LOGGING_LEVEL` change this\"",
            "        )",
            "",
            "        self.session_id = workspace_id or uuid.uuid4().hex",
            "",
            "        self.entity_id = entity_id",
            "        self.output_in_file = output_in_file",
            "        self.output_dir = (",
            "            output_dir or LOCAL_CACHE_DIRECTORY / LOCAL_OUTPUT_FILE_DIRECTORY_NAME",
            "        )",
            "        self._ensure_output_dir_exists()",
            "",
            "        self._base_url = base_url or get_api_url_base()",
            "        try:",
            "            self._api_key = (",
            "                api_key",
            "                or os.environ.get(ENV_COMPOSIO_API_KEY)",
            "                or UserData.load(LOCAL_CACHE_DIRECTORY / USER_DATA_FILE_NAME).api_key",
            "            )",
            "        except FileNotFoundError:",
            "            self._api_key = None",
            "            self.logger.debug(\"`api_key` is not set when initializing toolset.\")",
            "",
            "        if processors is not None:",
            "            warnings.warn(",
            "                \"Setting 'processors' on the ToolSet is deprecated, they should\"",
            "                \"be provided to the 'get_tools()' method instead.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self._processors: ProcessorsType = processors",
            "        else:",
            "            self._processors = {\"post\": {}, \"pre\": {}, \"schema\": {}}",
            "",
            "        self._metadata = metadata or {}",
            "        self._workspace_id = workspace_id",
            "        self._workspace_config = workspace_config",
            "        self._local_client = LocalClient()",
            "        self._custom_auth = {}",
            "",
            "        if len(kwargs) > 0:",
            "            self.logger.info(f\"Extra kwargs while initializing toolset: {kwargs}\")",
            "",
            "        self.logger.debug(\"Loading local tools\")",
            "        load_local_tools()",
            "",
            "        self._connected_account_ids = self._validating_connection_ids(",
            "            connected_account_ids=connected_account_ids or {}",
            "        )",
            "        self.max_retries = max_retries",
            "",
            "    def _validating_connection_ids(",
            "        self,",
            "        connected_account_ids: t.Dict[AppType, str],",
            "    ) -> t.Dict[App, str]:",
            "        \"\"\"Validate connection IDs.\"\"\"",
            "        valid = {}",
            "        invalid = []",
            "        entity = self.client.get_entity(id=self.entity_id)",
            "        for app, connected_account_id in connected_account_ids.items():",
            "            self.logger.debug(f\"Validating {app} {connected_account_id=}\")",
            "            try:",
            "                entity.get_connection(",
            "                    app=app,",
            "                    connected_account_id=connected_account_id,",
            "                )",
            "                valid[App(app)] = connected_account_id",
            "            except HTTPError:",
            "                invalid.append((str(app), connected_account_id))",
            "",
            "        if len(invalid) == 0:",
            "            return valid",
            "",
            "        raise ComposioSDKError(message=f\"Invalid connected accounts found: {invalid}\")",
            "",
            "    def _get_connected_account(self, action: ActionType) -> t.Optional[str]:",
            "        return self._connected_account_ids.get(App(Action(action).app))",
            "",
            "    def _try_get_github_access_token_for_current_entity(self) -> t.Optional[str]:",
            "        \"\"\"Try and get github access token for current entiry.\"\"\"",
            "        from_env = os.environ.get(f\"_COMPOSIO_{ENV_GITHUB_ACCESS_TOKEN}\")",
            "        if from_env is not None:",
            "            self.logger.debug(\"Using composio github access token\")",
            "            return from_env",
            "",
            "        self.logger.debug(f\"Trying to get github access token for {self.entity_id=}\")",
            "        try:",
            "            account = self.client.get_entity(id=self.entity_id).get_connection(",
            "                app=App.GITHUB",
            "            )",
            "            token = (",
            "                self.client.connected_accounts.get(connection_id=account.id)",
            "                .connectionParams.headers[\"Authorization\"]  # type: ignore",
            "                .replace(\"Bearer \", \"\")",
            "            )",
            "            self.logger.debug(",
            "                f\"Using `{token}` with scopes: {account.connectionParams.scope}\"",
            "            )",
            "            return token",
            "        except ComposioClientError:",
            "            return None",
            "",
            "    @property",
            "    def _log_ingester(self) -> LogIngester:",
            "        if self._log_ingester_client is None:",
            "            self._log_ingester_client = LogIngester()",
            "        return self._log_ingester_client",
            "",
            "    @property",
            "    def api_key(self) -> str:",
            "        if self._api_key is None:",
            "            raise ApiKeyNotProvidedError()",
            "        return self._api_key",
            "",
            "    @property",
            "    def client(self) -> Composio:",
            "        if self._remote_client is None:",
            "            self._remote_client = Composio(",
            "                api_key=self._api_key,",
            "                base_url=self._base_url,",
            "                runtime=self._runtime,",
            "            )",
            "            check_cache_refresh(self._remote_client)",
            "",
            "        self._remote_client.local = self._local_client",
            "        return self._remote_client",
            "",
            "    @property",
            "    def workspace(self) -> Workspace:",
            "        \"\"\"Workspace for this toolset instance.\"\"\"",
            "        if self._workspace is not None:",
            "            return self._workspace",
            "",
            "        if self._workspace_id is not None:",
            "            self._workspace = WorkspaceFactory.get(id=self._workspace_id)",
            "            return self._workspace",
            "",
            "        workspace_config = self._workspace_config or HostWorkspaceConfig()",
            "        if workspace_config.composio_api_key is None:",
            "            workspace_config.composio_api_key = self.api_key",
            "",
            "        if workspace_config.composio_base_url is None:",
            "            workspace_config.composio_base_url = self._base_url",
            "",
            "        if workspace_config.github_access_token is None:",
            "            workspace_config.github_access_token = (",
            "                self._try_get_github_access_token_for_current_entity()",
            "            )",
            "",
            "        self._workspace = WorkspaceFactory.new(config=workspace_config)",
            "        return self._workspace",
            "",
            "    def set_workspace_id(self, workspace_id: str) -> None:",
            "        self._workspace_id = workspace_id",
            "        if self._workspace is not None:",
            "            self._workspace = WorkspaceFactory.get(id=workspace_id)",
            "",
            "    def add_auth(",
            "        self,",
            "        app: AppType,",
            "        parameters: t.List[CustomAuthParameter],",
            "        base_url: t.Optional[str] = None,",
            "        body: t.Optional[t.Dict] = None,",
            "    ) -> None:",
            "        self._custom_auth[App(app)] = CustomAuthObject(",
            "            body=body or {},",
            "            base_url=base_url,",
            "            parameters=parameters,",
            "        )",
            "",
            "    def check_connected_account(self, action: ActionType) -> None:",
            "        \"\"\"Check if connected account is required and if required it exists or not.\"\"\"",
            "        action = Action(action)",
            "        if action.no_auth or action.is_runtime:",
            "            return",
            "",
            "        if App(action.app) in self._custom_auth:",
            "            return",
            "",
            "        if self._connected_accounts is None:",
            "            self._connected_accounts = t.cast(",
            "                t.List[ConnectedAccountModel],",
            "                self.client.connected_accounts.get(),",
            "            )",
            "",
            "        if action.app not in [",
            "            # Normalize app names/ids coming from API",
            "            connection.appUniqueId.upper()",
            "            for connection in self._connected_accounts",
            "        ]:",
            "            raise ComposioSDKError(",
            "                f\"No connected account found for app `{action.app}`; \"",
            "                f\"Run `composio add {action.app.lower()}` to fix this\"",
            "            )",
            "",
            "    def _execute_local(",
            "        self,",
            "        action: Action,",
            "        params: t.Dict,",
            "        metadata: t.Optional[t.Dict] = None,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"Execute a local action.\"\"\"",
            "        metadata = metadata or {}",
            "        metadata[\"_toolset\"] = self",
            "        response = self.workspace.execute_action(",
            "            action=action,",
            "            request_data=params,",
            "            metadata={",
            "                **(metadata or {}),",
            "                \"entity_id\": entity_id or self.entity_id,",
            "            },",
            "        )",
            "",
            "        if isinstance(response, BaseModel):",
            "            response = response.model_dump()",
            "",
            "        self._log_ingester.log(",
            "            connection_id=None,",
            "            provider_name=action.app,",
            "            action_name=action.name,",
            "            request=params,",
            "            response=response,",
            "            is_error=not response.get(\"successful\", False),",
            "            session_id=self.workspace.id,",
            "        )",
            "",
            "        return response",
            "",
            "    def _execute_remote(",
            "        self,",
            "        action: Action,",
            "        params: t.Dict,",
            "        entity_id: str = DEFAULT_ENTITY_ID,",
            "        connected_account_id: t.Optional[str] = None,",
            "        session_id: t.Optional[str] = None,",
            "        text: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"Execute a remote action.\"\"\"",
            "        auth = self._custom_auth.get(App(action.app))",
            "        if auth is None:",
            "            self.check_connected_account(action=action)",
            "",
            "        entity = self.client.get_entity(id=entity_id)",
            "        output = entity._execute(  # pylint: disable=protected-access",
            "            action=action,",
            "            params=params,",
            "            connected_account_id=connected_account_id,",
            "            session_id=session_id,",
            "            text=text,",
            "            auth=auth,",
            "        )",
            "",
            "        if self.output_in_file:",
            "            return self._write_to_file(",
            "                action=action,",
            "                output=output,",
            "                entity_id=entity_id,",
            "            )",
            "",
            "        try:",
            "            self.logger.debug(\"Trying to validate success response model\")",
            "            success_response_model = SuccessExecuteActionResponseModel.model_validate(",
            "                output",
            "            )",
            "        except Exception:",
            "            self.logger.debug(\"Failed to validate success response model\")",
            "            return output",
            "",
            "        return self._save_var_files(",
            "            file_name_prefix=f\"{action.name}_{entity_id}_{time.time()}\",",
            "            success_response_model=success_response_model,",
            "        )",
            "",
            "    def _ensure_output_dir_exists(self):",
            "        \"\"\"Ensure the output directory exists.\"\"\"",
            "        if not self.output_dir.exists():",
            "            self.output_dir.mkdir(parents=True, exist_ok=True)",
            "",
            "    def _save_var_files(",
            "        self,",
            "        file_name_prefix: str,",
            "        success_response_model: SuccessExecuteActionResponseModel,",
            "    ) -> dict:",
            "        error = success_response_model.error",
            "        resp_data = success_response_model.data",
            "        is_invalid_file = False",
            "        for key, val in resp_data.items():",
            "            try:",
            "                file_model = FileType.model_validate(val)",
            "                self._ensure_output_dir_exists()",
            "",
            "                local_filepath = (",
            "                    self.output_dir",
            "                    / f\"{file_name_prefix}_{file_model.name.replace('/', '_')}\"",
            "                )",
            "",
            "                _write_file(",
            "                    local_filepath, base64.urlsafe_b64decode(file_model.content)",
            "                )",
            "",
            "                resp_data[key] = str(local_filepath)",
            "            except binascii.Error:",
            "                is_invalid_file = True",
            "                resp_data[key] = \"Invalid File! Unable to decode.\"",
            "            except Exception:",
            "                pass",
            "",
            "        if is_invalid_file is True and error is None:",
            "            success_response_model.error = \"Execution failed\"",
            "        success_response_model.data = resp_data",
            "        return success_response_model.model_dump()",
            "",
            "    def _write_to_file(",
            "        self,",
            "        action: Action,",
            "        output: t.Dict,",
            "        entity_id: str = DEFAULT_ENTITY_ID,",
            "    ) -> t.Dict:",
            "        \"\"\"Write output to a file.\"\"\"",
            "        filename = hashlib.sha256(",
            "            f\"{action.name}-{entity_id}-{time.time()}\".encode()",
            "        ).hexdigest()",
            "        self._ensure_output_dir_exists()",
            "        outfile = self.output_dir / filename",
            "        self.logger.info(f\"Writing output to: {outfile}\")",
            "        _write_file(outfile, json.dumps(output))",
            "        return {",
            "            \"message\": f\"output written to {outfile.resolve()}\",",
            "            \"file\": str(outfile.resolve()),",
            "        }",
            "",
            "    def _serialize_execute_params(self, param: ParamType) -> ParamType:",
            "        \"\"\"Returns a serialized version of the parameters object.\"\"\"",
            "        if param is None:",
            "            return param  # type: ignore",
            "",
            "        if isinstance(param, (int, float, str, bool)):",
            "            return param  # type: ignore",
            "",
            "        if isinstance(param, BaseModel):",
            "            return param.model_dump(exclude_none=True)  # type: ignore",
            "",
            "        if isinstance(param, list):",
            "            return [self._serialize_execute_params(p) for p in param]  # type: ignore",
            "",
            "        if isinstance(param, dict):",
            "            return {",
            "                key: self._serialize_execute_params(val)  # type: ignore",
            "                for key, val in param.items()",
            "            }",
            "",
            "        raise ValueError(",
            "            \"Invalid value found for execute parameters\"",
            "            f\"\\ntype={type(param)} \\nvalue={param}\"",
            "        )",
            "",
            "    def _get_metadata(self, key: _KeyType) -> t.Dict:",
            "        metadata = self._metadata.get(key)  # type: ignore",
            "        if metadata is not None:",
            "            return metadata",
            "",
            "        try:",
            "            return self._metadata.get(Action(t.cast(ActionType, key)), {})  # type: ignore",
            "        except EnumStringNotFound:",
            "            return self._metadata.get(App(t.cast(AppType, key)), {})  # type: ignore",
            "",
            "    def _add_metadata(self, action: Action, metadata: t.Optional[t.Dict]) -> t.Dict:",
            "        metadata = metadata or {}",
            "        metadata.update(self._get_metadata(key=App(action.app)))",
            "        metadata.update(self._get_metadata(key=action))",
            "        return metadata",
            "",
            "    def _get_processor(",
            "        self,",
            "        key: _KeyType,",
            "        type_: te.Literal[\"post\", \"pre\", \"schema\"],",
            "    ) -> t.Optional[_CallableType]:",
            "        \"\"\"Get processor for given app or action\"\"\"",
            "        processor = self._processors.get(type_, {}).get(key)  # type: ignore",
            "        if processor is not None:",
            "            return processor",
            "",
            "        try:",
            "            return self._processors.get(type_, {}).get(Action(t.cast(ActionType, key)))  # type: ignore",
            "        except EnumStringNotFound:",
            "            return self._processors.get(type_, {}).get(App(t.cast(AppType, key)))  # type: ignore",
            "",
            "    def _process(",
            "        self,",
            "        key: _KeyType,",
            "        data: t.Dict,",
            "        type_: te.Literal[\"pre\", \"post\", \"schema\"],",
            "    ) -> t.Union[t.Dict, _Retry]:",
            "        processor = self._get_processor(key=key, type_=type_)",
            "        if processor is not None:",
            "            self.logger.info(",
            "                f\"Running {'request' if type_ == 'pre' else 'response' if type_ == 'post' else 'schema'}\"",
            "                f\" through: {processor.__name__}\"",
            "            )",
            "            data = processor(data)",
            "            # Users may not respect our type annotations and return something that isn't a dict.",
            "            # If that happens we should show a friendly error message.",
            "            if not isinstance(data, t.Dict):",
            "                warnings.warn(",
            "                    f\"Expected {type_}-processor to return 'dict', got {type(data).__name__!r}\",",
            "                    stacklevel=2,",
            "                )",
            "        return data",
            "",
            "    def _process_request(self, action: Action, request: t.Dict) -> t.Dict:",
            "        processed = self._process(",
            "            key=App(action.app),",
            "            data=request,",
            "            type_=\"pre\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from App preprocessor function.\"",
            "                \" Preprocessors cannot be retried.\"",
            "            )",
            "",
            "        processed = self._process(",
            "            key=action,",
            "            data=processed,",
            "            type_=\"pre\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from Action preprocessor function.\"",
            "                \" Preprocessors cannot be retried.\"",
            "            )",
            "",
            "        return processed",
            "",
            "    def _process_respone(",
            "        self, action: Action, response: t.Dict",
            "    ) -> t.Union[t.Dict, _Retry]:",
            "        processed = self._process(",
            "            key=App(action.app),",
            "            data=response,",
            "            type_=\"post\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            return RETRY",
            "",
            "        processed = self._process(",
            "            key=action,",
            "            data=processed,",
            "            type_=\"post\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            return RETRY",
            "",
            "        return processed",
            "",
            "    def _process_schema_properties(self, action: Action, properties: t.Dict) -> t.Dict:",
            "        processed = self._process(",
            "            key=App(action.app),",
            "            data=properties,",
            "            type_=\"schema\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from App schema processor function.\"",
            "                \" Schema pprocessors cannot be retried.\"",
            "            )",
            "",
            "        processed = self._process(",
            "            key=action,",
            "            data=processed,",
            "            type_=\"schema\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from Action preprocessor function.\"",
            "                \" Schema processors cannot be retried.\"",
            "            )",
            "        return processed",
            "",
            "    def _merge_processors(self, processors: ProcessorsType) -> None:",
            "        for processor_type in self._processors.keys():",
            "            if processor_type not in processors:",
            "                continue",
            "",
            "            processor_type = t.cast(ProcessorType, processor_type)",
            "            new_processors = processors[processor_type]",
            "",
            "            if processor_type in self._processors:",
            "                existing_processors = self._processors[processor_type]",
            "            else:",
            "                existing_processors = {}",
            "                self._processors[processor_type] = existing_processors",
            "",
            "            existing_processors.update(new_processors)",
            "",
            "    @_record_action_if_available",
            "    def execute_action(",
            "        self,",
            "        action: ActionType,",
            "        params: dict,",
            "        metadata: t.Optional[t.Dict] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        connected_account_id: t.Optional[str] = None,",
            "        text: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute an action on a given entity.",
            "",
            "        :param action: Action to execute",
            "        :param params: The parameters to pass to the action",
            "        :param entity_id: The ID of the entity to execute the action on. Defaults to \"default\"",
            "        :param text: Extra text to use for generating function calling metadata",
            "        :param metadata: Metadata for executing local action",
            "        :param connected_account_id: Connection ID for executing the remote action",
            "        :return: Output object from the function call",
            "        \"\"\"",
            "        action = Action(action)",
            "        params = self._serialize_execute_params(param=params)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "",
            "        if not action.is_runtime:",
            "            params = self._process_request(action=action, request=params)",
            "            metadata = self._add_metadata(action=action, metadata=metadata)",
            "            connected_account_id = connected_account_id or self._get_connected_account(",
            "                action=action",
            "            )",
            "",
            "        self.logger.info(",
            "            f\"Executing `{action.slug}` with {params=} and {metadata=} {connected_account_id=}\"",
            "        )",
            "",
            "        failed_responses = []",
            "        for _ in range(self.max_retries):",
            "            response = (",
            "                self._execute_local(",
            "                    action=action,",
            "                    params=params,",
            "                    metadata=metadata,",
            "                    entity_id=entity_id,",
            "                )",
            "                if action.is_local",
            "                else self._execute_remote(",
            "                    action=action,",
            "                    params=params,",
            "                    entity_id=entity_id or self.entity_id,",
            "                    connected_account_id=connected_account_id,",
            "                    text=text,",
            "                    session_id=self.session_id,",
            "                )",
            "            )",
            "            processed_response = (",
            "                response",
            "                if action.is_runtime",
            "                else self._process_respone(action=action, response=response)",
            "            )",
            "            if isinstance(processed_response, _Retry):",
            "                self.logger.info(",
            "                    f\"Got {processed_response=} from {action=} with {params=}, retrying...\"",
            "                )",
            "                failed_responses.append(response)",
            "                continue",
            "",
            "            response = processed_response",
            "            self.logger.info(f\"Got {response=} from {action=} with {params=}\")",
            "            return response",
            "",
            "        return SuccessExecuteActionResponseModel(",
            "            successfull=False,",
            "            data={\"failed_responses\": failed_responses},",
            "            error=f\"Execution failed after {self.max_retries} retries.\",",
            "        ).model_dump()",
            "",
            "    @t.overload",
            "    def execute_request(",
            "        self,",
            "        endpoint: str,",
            "        method: str,",
            "        *,",
            "        body: t.Optional[t.Dict] = None,",
            "        parameters: t.Optional[t.List[CustomAuthParameter]] = None,",
            "        connection_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        pass",
            "",
            "    @t.overload",
            "    def execute_request(",
            "        self,",
            "        endpoint: str,",
            "        method: str,",
            "        *,",
            "        body: t.Optional[t.Dict] = None,",
            "        parameters: t.Optional[t.List[CustomAuthParameter]] = None,",
            "        app: t.Optional[AppType] = None,",
            "    ) -> t.Dict:",
            "        pass",
            "",
            "    def execute_request(",
            "        self,",
            "        endpoint: str,",
            "        method: str,",
            "        *,",
            "        body: t.Optional[t.Dict] = None,",
            "        parameters: t.Optional[t.List[CustomAuthParameter]] = None,",
            "        connection_id: t.Optional[str] = None,",
            "        app: t.Optional[AppType] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute a proxy request to a connected account.",
            "",
            "        :param endpoint: API endpoint to call",
            "        :param method: HTTP method to use (GET, POST, etc.)",
            "        :param body: Request body data",
            "        :param parameters: Additional auth parameters",
            "        :param connection_id: ID of the connected account",
            "        :param app: App type to use for connection lookup",
            "",
            "        :returns: Response from the proxy request",
            "        :raises: ComposioSDKError: If neither connection_id nor app is provided",
            "        \"\"\"",
            "        if app is not None and connection_id is None:",
            "            connection_id = (",
            "                self.get_entity(id=self.entity_id).get_connection(app=app).id",
            "            )",
            "",
            "        if connection_id is None:",
            "            raise ComposioSDKError(",
            "                \"Please provide connection id or app name to execute a request\"",
            "            )",
            "",
            "        self.logger.info(",
            "            f\"Executing request to {endpoint} with method={method}, connection_id={connection_id}\"",
            "        )",
            "        response = self.client.actions.request(",
            "            connection_id=connection_id,",
            "            body=body,",
            "            method=method,",
            "            endpoint=endpoint,",
            "            parameters=parameters,",
            "        )",
            "        self.logger.info(f\"Got {response=}\")",
            "        return response",
            "",
            "    def validate_tools(",
            "        self,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        tags: t.Optional[t.Sequence[TagType]] = None,",
            "    ) -> None:",
            "        # NOTE: This an experimental, can convert to decorator for more convinience",
            "        if not apps and not actions and not tags:",
            "            return",
            "        self.workspace.check_for_missing_dependencies(",
            "            apps=apps,",
            "            actions=actions,",
            "            tags=tags,",
            "        )",
            "",
            "    def get_action_schemas(",
            "        self,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        tags: t.Optional[t.Sequence[TagType]] = None,",
            "        *,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[ActionModel]:",
            "        runtime_actions = t.cast(",
            "            t.List[t.Type[LocalAction]],",
            "            [action for action in actions or [] if hasattr(action, \"run_on_shell\")],",
            "        )",
            "        actions = t.cast(",
            "            t.List[Action],",
            "            [",
            "                Action(action)",
            "                for action in actions or []",
            "                if action not in runtime_actions",
            "            ],",
            "        )",
            "        apps = t.cast(t.List[App], [App(app) for app in apps or []])",
            "        items: t.List[ActionModel] = []",
            "",
            "        local_actions = [action for action in actions if action.is_local]",
            "        local_apps = [app for app in apps if app.is_local]",
            "        if len(local_actions) > 0 or len(local_apps) > 0:",
            "            items += [",
            "                ActionModel(**item)",
            "                for item in self._local_client.get_action_schemas(",
            "                    apps=local_apps,",
            "                    actions=local_actions,",
            "                    tags=tags,",
            "                )",
            "            ]",
            "",
            "        remote_actions = [action for action in actions if not action.is_local]",
            "        remote_apps = [app for app in apps if not app.is_local]",
            "        if len(remote_actions) > 0 or len(remote_apps) > 0:",
            "            remote_items = self.client.actions.get(",
            "                apps=remote_apps,",
            "                actions=remote_actions,",
            "                tags=tags,",
            "            )",
            "            if check_connected_accounts:",
            "                for item in remote_items:",
            "                    self.check_connected_account(action=item.name)",
            "            else:",
            "                warnings.warn(",
            "                    \"Not verifying connected accounts for apps.\"",
            "                    \" Actions may fail when the Agent tries to use them.\",",
            "                    UserWarning,",
            "                )",
            "            items = items + remote_items",
            "",
            "        for act in runtime_actions:",
            "            schema = act.schema()",
            "            schema[\"name\"] = act.enum",
            "            items.append(ActionModel(**schema).model_copy(deep=True))",
            "",
            "        for item in items:",
            "            item = self._process_schema(item)",
            "",
            "            # This is to support anthropic-claude",
            "            if item.name == Action.ANTHROPIC_BASH_COMMAND.slug:",
            "                item.name = \"bash\"",
            "",
            "            if item.name == Action.ANTHROPIC_COMPUTER.slug:",
            "                item.name = \"computer\"",
            "",
            "            if item.name == Action.ANTHROPIC_TEXT_EDITOR.slug:",
            "                item.name = \"str_replace_editor\"",
            "",
            "        return items",
            "",
            "    def _process_schema(self, action_item: ActionModel) -> ActionModel:",
            "        required_params = action_item.parameters.required or []",
            "        for param_name, param_details in action_item.parameters.properties.items():",
            "            if param_details.get(\"title\") == \"FileType\" and all(",
            "                fprop in param_details.get(\"properties\", {})",
            "                for fprop in (\"name\", \"content\")",
            "            ):",
            "                action_item.parameters.properties[param_name].pop(\"properties\")",
            "                action_item.parameters.properties[param_name] = {",
            "                    \"default\": param_details.get(\"default\"),",
            "                    \"type\": \"string\",",
            "                    \"format\": \"file-path\",",
            "                    \"description\": f\"File path to {param_details.get('description', '')}\",",
            "                }",
            "            elif param_details.get(\"allOf\", [{}])[0].get(\"title\") == \"FileType\" and all(",
            "                fprop in param_details.get(\"allOf\", [{}])[0].get(\"properties\", {})",
            "                for fprop in (\"name\", \"content\")",
            "            ):",
            "                action_item.parameters.properties[param_name].pop(\"allOf\")",
            "                action_item.parameters.properties[param_name].update(",
            "                    {",
            "                        \"default\": param_details.get(\"default\"),",
            "                        \"type\": \"string\",",
            "                        \"format\": \"file-path\",",
            "                        \"description\": f\"File path to {param_details.get('description', '')}\",",
            "                    }",
            "                )",
            "            elif param_details.get(\"type\") in [",
            "                \"string\",",
            "                \"integer\",",
            "                \"number\",",
            "                \"boolean\",",
            "            ]:",
            "                ext = f'Please provide a value of type {param_details[\"type\"]}.'",
            "                description = param_details.get(\"description\", \"\").rstrip(\".\")",
            "                param_details[\"description\"] = (",
            "                    f\"{description}. {ext}\" if description else ext",
            "                )",
            "",
            "            if param_name in required_params:",
            "                description = param_details.get(\"description\", \"\")",
            "                if description:",
            "                    param_details[\"description\"] = (",
            "                        f\"{description.rstrip('.')}. This parameter is required.\"",
            "                    )",
            "                else:",
            "                    param_details[\"description\"] = \"This parameter is required.\"",
            "",
            "        if action_item.description is not None:",
            "            action_item.description = action_item.description[",
            "                : self._description_char_limit",
            "            ]",
            "        action_item.parameters.properties = self._process_schema_properties(",
            "            action=Action(action_item.name.upper()),",
            "            properties=action_item.parameters.properties,",
            "        )",
            "        if self._action_name_char_limit is not None:",
            "            action_item.name = action_item.name[: self._action_name_char_limit]",
            "        return action_item",
            "",
            "    def create_trigger_listener(self, timeout: float = 15.0) -> TriggerSubscription:",
            "        \"\"\"Create trigger subscription.\"\"\"",
            "        return self.client.triggers.subscribe(timeout=timeout)",
            "",
            "    def find_actions_by_use_case(",
            "        self,",
            "        *apps: AppType,",
            "        use_case: str,",
            "        advanced: bool = False,",
            "    ) -> t.List[Action]:",
            "        \"\"\"",
            "        Find actions by specified use case.",
            "",
            "        :param apps: List of apps to search.",
            "        :param use_case: String describing the use case.",
            "        :param advanced: Use advanced search (will be slower than the normal search)",
            "        :return: A list of actions matching the relevant use case.",
            "        \"\"\"",
            "        if advanced:",
            "            actions = []",
            "            for task in self.client.actions.search_for_a_task(use_case=use_case):",
            "                actions += task.actions",
            "        else:",
            "            actions = list(",
            "                map(",
            "                    lambda x: get_enum_key(x.name),",
            "                    self.client.actions.get(",
            "                        apps=[App(app) for app in apps],",
            "                        use_case=use_case,",
            "                        allow_all=True,",
            "                    ),",
            "                )",
            "            )",
            "        return [Action(action) for action in actions]",
            "",
            "    def find_actions_by_tags(",
            "        self,",
            "        *apps: AppType,",
            "        tags: t.List[str],",
            "    ) -> t.List[Action]:",
            "        \"\"\"",
            "        Find actions by specified use case.",
            "",
            "        :param apps: List of apps to search.",
            "        :param use_case: String describing the use case.",
            "        :return: A list of actions matching the relevant use case.",
            "        \"\"\"",
            "        if len(tags) == 0:",
            "            raise ComposioClientError(",
            "                \"Please provide at least one tag to perform search\"",
            "            )",
            "",
            "        if len(apps) > 0:",
            "            return list(",
            "                itertools.chain(",
            "                    *[list(App(app).get_actions(tags=tags)) for app in apps]",
            "                )",
            "            )",
            "",
            "        actions = []",
            "        for action in Action.all():",
            "            if any(tag in action.tags for tag in tags):",
            "                actions.append(action)",
            "        return actions",
            "",
            "    def get_agent_instructions(",
            "        self,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        tags: t.Optional[t.Sequence[TagType]] = None,",
            "    ) -> str:",
            "        \"\"\"",
            "        Generate a formatted string with instructions for agents based on the provided apps, actions, and tags.",
            "",
            "        This function compiles a list of available tools from the specified apps, actions, and tags,",
            "        and formats them into a human-readable string that can be used as instructions for agents.",
            "",
            "        :param apps: Optional sequence of AppType to include in the search.",
            "        :param actions: Optional sequence of ActionType to include in the search.",
            "        :param tags: Optional sequence of TagType to filter the actions.",
            "        :return: A formatted string with instructions for agents.",
            "        \"\"\"",
            "        # Retrieve schema information for the given apps, actions, and tags",
            "        schema_list = [",
            "            schema.model_dump()",
            "            for schema in (",
            "                self.get_action_schemas(apps=apps, tags=tags)",
            "                + self.get_action_schemas(actions=actions)",
            "            )",
            "        ]",
            "        schema_info = [",
            "            (schema_obj[\"appName\"], schema_obj[\"name\"]) for schema_obj in schema_list",
            "        ]",
            "",
            "        # Helper function to format a list of items into a string",
            "        def format_list(items):",
            "            if not items:",
            "                return \"\"",
            "            if len(items) == 1:",
            "                return items[0]",
            "            return \", \".join(items[:-2] + [\" and \".join(items[-2:])])",
            "",
            "        # Organize the schema information by app name",
            "        action_dict: t.Dict[str, t.List] = {}",
            "        for appName, name in schema_info:",
            "            if appName not in action_dict:",
            "                action_dict[appName] = []",
            "            action_dict[appName].append(name)",
            "",
            "        # Format the schema information into a human-readable string",
            "        formatted_schema_info = (",
            "            \"You have various tools, among which \"",
            "            + \", \".join(",
            "                [",
            "                    f\"for interacting with **{appName}** you might use {format_list(action_items)} tools\"",
            "                    for appName, action_items in action_dict.items()",
            "                ]",
            "            )",
            "            + \". Whichever tool is useful to execute your task, use that with proper parameters.\"",
            "        )",
            "        return formatted_schema_info",
            "",
            "    def get_auth_params(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        connection_id: t.Optional[str] = None,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Optional[ConnectionParams]:",
            "        \"\"\"Get authentication parameters for given app.\"\"\"",
            "        if app is None and connection_id is None:",
            "            raise ComposioSDKError(\"Both `app` and `connection_id` cannot be `None`\")",
            "",
            "        try:",
            "            connection_id = (",
            "                connection_id",
            "                or self.client.get_entity(id=entity_id or self.entity_id)",
            "                .get_connection(app=app)",
            "                .id",
            "            )",
            "            return self.client.connected_accounts.info(connection_id=connection_id)",
            "        except ComposioClientError:",
            "            return None",
            "",
            "    def get_auth_schemes(self, app: AppType) -> t.List[AppAuthScheme]:",
            "        \"\"\"Get the list of auth schemes for an app.\"\"\"",
            "        return self.client.apps.get(name=str(app)).auth_schemes or []",
            "",
            "    def get_app(self, app: AppType) -> AppModel:",
            "        return self.client.apps.get(name=str(App(app)))",
            "",
            "    def get_apps(",
            "        self,",
            "        no_auth: t.Optional[bool] = None,",
            "        include_local: bool = True,",
            "    ) -> t.List[AppModel]:",
            "        apps = self.client.apps.get()",
            "        print(apps)",
            "        if no_auth is not None:",
            "            apps = [a for a in apps if a.no_auth is no_auth]",
            "",
            "        if include_local:",
            "            for app in tool_registry[\"local\"].values():",
            "                apps.append(",
            "                    AppModel(",
            "                        name=app.name,",
            "                        key=app.name,",
            "                        appId=app.name,",
            "                        description=app.description,",
            "                        categories=[\"local\"],",
            "                        meta={},",
            "                        no_auth=True,",
            "                    )",
            "                )",
            "        return apps",
            "",
            "    def get_action(self, action: ActionType) -> ActionModel:",
            "        return self.client.actions.get(actions=[action]).pop()",
            "",
            "    def get_trigger(self, trigger: TriggerType) -> TriggerModel:",
            "        return self.client.triggers.get(trigger_names=[trigger]).pop()",
            "",
            "    def get_integration(self, id: str) -> IntegrationModel:",
            "        return self.client.integrations.get(id=id)",
            "",
            "    def get_integrations(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "    ) -> t.List[IntegrationModel]:",
            "        integrations = self.client.integrations.get()",
            "        if app is not None:",
            "            app = str(app).lower()",
            "            integrations = [i for i in integrations if i.appName.lower() == app]",
            "",
            "        if auth_scheme is not None:",
            "            integrations = [i for i in integrations if i.authScheme == auth_scheme]",
            "",
            "        return integrations",
            "",
            "    def get_connected_account(self, id: str) -> ConnectedAccountModel:",
            "        return self.client.connected_accounts.get(connection_id=id)",
            "",
            "    def get_connected_accounts(self) -> t.List[ConnectedAccountModel]:",
            "        return self.client.connected_accounts.get()",
            "",
            "    def get_entity(self, id: t.Optional[str] = None) -> Entity:",
            "        \"\"\"Get entity object for given ID.\"\"\"",
            "        return self.client.get_entity(id=id or self.entity_id)",
            "",
            "    def get_auth_scheme_for_app(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "    ) -> AppAuthScheme:",
            "        auth_schemes = {",
            "            scheme.auth_mode: scheme",
            "            for scheme in self.client.apps.get(name=str(app)).auth_schemes or []",
            "        }",
            "",
            "        if auth_scheme is not None and auth_scheme not in auth_schemes:",
            "            raise ComposioSDKError(",
            "                message=f\"Auth scheme `{auth_scheme}` not found for app `{app}`\"",
            "            )",
            "",
            "        if auth_scheme is not None:",
            "            return auth_schemes[auth_scheme]",
            "",
            "        for scheme in AUTH_SCHEMES:",
            "            if scheme in auth_schemes:",
            "                scheme = t.cast(AuthSchemeType, scheme)",
            "                return auth_schemes[scheme]",
            "",
            "        raise ComposioSDKError(",
            "            message=(",
            "                f\"Error getting expected params for {app=}, {auth_scheme=}, \"",
            "                f\"available_schems={list(auth_schemes)}\"",
            "            )",
            "        )",
            "",
            "    def _get_expected_params_from_integration_id(self, id: str) -> IntegrationParams:",
            "        integration = self.get_integration(id=id)",
            "        return {",
            "            \"integration_id\": integration.id,",
            "            \"auth_scheme\": integration.authScheme,",
            "            \"expected_params\": integration.expectedInputFields,",
            "        }",
            "",
            "    def _get_integration_for_app(",
            "        self,",
            "        app: AppType,",
            "        auth_scheme: t.Optional[str] = None,",
            "    ) -> IntegrationModel:",
            "        for integration in sorted(self.get_integrations(), key=lambda x: x.createdAt):",
            "            if integration.appName.lower() == str(app).lower():",
            "                if (",
            "                    auth_scheme is not None",
            "                    and integration.authScheme.lower() != auth_scheme.lower()",
            "                ):",
            "                    continue",
            "                return self.get_integration(id=integration.id)",
            "        raise NoItemsFound(f\"No integration found for `{app}`\")",
            "",
            "    def _get_expected_params_from_app(",
            "        self,",
            "        app: AppType,",
            "        auth_scheme: t.Optional[str] = None,",
            "    ) -> IntegrationParams:",
            "        integration = self._get_integration_for_app(app=app, auth_scheme=auth_scheme)",
            "        return {",
            "            \"integration_id\": integration.id,",
            "            \"auth_scheme\": integration.authScheme,",
            "            \"expected_params\": integration.expectedInputFields,",
            "        }",
            "",
            "    def _can_use_auth_scheme_without_user_input(",
            "        self, scheme: AppAuthScheme, app: AppModel",
            "    ) -> bool:",
            "        if (",
            "            scheme.auth_mode in (\"OAUTH2\", \"OAUTH1\")",
            "            and len(app.testConnectors or []) > 0",
            "        ):",
            "            return True",
            "",
            "        for field in scheme.fields:",
            "            if not field.expected_from_customer and field.required:",
            "                return False",
            "",
            "        return True",
            "",
            "    def get_expected_params_for_user(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "        integration_id: t.Optional[str] = None,",
            "    ) -> IntegrationParams:",
            "        \"\"\"",
            "        This method returns a list of parameters that are suppossed to be",
            "        provided by the user.",
            "        \"\"\"",
            "        # If `integration_id` is provided, use it to fetch the params",
            "        if integration_id is not None:",
            "            response = self._get_expected_params_from_integration_id(id=integration_id)",
            "            if auth_scheme is not None and response[\"auth_scheme\"] != auth_scheme:",
            "                raise ComposioSDKError(",
            "                    message=(",
            "                        \"Auth scheme does not match provided integration ID, \"",
            "                        f\"auth scheme associated with integration ID {response['auth_scheme']} \"",
            "                        f\"auth scheme provided {auth_scheme}\"",
            "                    )",
            "                )",
            "            return response",
            "",
            "        if app is None:",
            "            raise ComposioSDKError(",
            "                message=\"Both `integration_id` and `app` cannot be None\"",
            "            )",
            "",
            "        try:",
            "            # Check if integration is available for an app, and if available",
            "            # return params from that integration",
            "            return self._get_expected_params_from_app(app=app, auth_scheme=auth_scheme)",
            "        except ValueError:",
            "            pass",
            "",
            "        app_data = self.client.apps.get(name=str(app))",
            "        # Go through available schemes and check if any scheme can be used",
            "        # without user inputs to create an integratuib, if yes then create",
            "        # an integration and return params from there.",
            "        for scheme in app_data.auth_schemes or []:",
            "            if auth_scheme is not None and auth_scheme != scheme.auth_mode.upper():",
            "                continue",
            "            if self._can_use_auth_scheme_without_user_input(",
            "                scheme=scheme, app=app_data",
            "            ):",
            "                integration = self.create_integration(",
            "                    app=app,",
            "                    auth_mode=scheme.auth_mode,",
            "                    auth_config={},",
            "                    use_composio_oauth_app=scheme.auth_mode in (\"OAUTH2\", \"OAUTH1\"),",
            "                )",
            "                return {",
            "                    \"integration_id\": integration.id,",
            "                    \"auth_scheme\": integration.authScheme,",
            "                    \"expected_params\": integration.expectedInputFields,",
            "                }",
            "",
            "        raise ComposioSDKError(",
            "            message=(",
            "                f\"No existing integration found for `{str(app)}`, with auth \"",
            "                f\"scheme {auth_scheme} Please create an integration and use the\"",
            "                \" ID to fetch the expected params.\"",
            "            )",
            "        )",
            "",
            "    def fetch_expected_integration_params(",
            "        self,",
            "        app: AppModel,",
            "        auth_scheme: AuthSchemeType,",
            "    ) -> t.List[AuthSchemeField]:",
            "        \"\"\"Fetch expected integration params for creating an integration.\"\"\"",
            "        for scheme in app.auth_schemes or []:",
            "            if auth_scheme != scheme.auth_mode.upper():",
            "                continue",
            "            return [f for f in scheme.fields if not f.expected_from_customer]",
            "        raise ComposioSDKError(",
            "            message=f\"{app.name!r} does not support {auth_scheme!r} auth scheme\"",
            "        )",
            "",
            "    def create_integration(",
            "        self,",
            "        app: AppType,",
            "        auth_mode: t.Optional[AuthSchemeType] = None,",
            "        auth_config: t.Optional[t.Dict[str, t.Any]] = None,",
            "        use_composio_oauth_app: bool = True,",
            "        force_new_integration: bool = False,",
            "    ) -> IntegrationModel:",
            "        app_data = self.client.apps.get(name=str(app))",
            "        timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")",
            "        return self.client.integrations.create(",
            "            app_id=app_data.appId,",
            "            name=f\"{app}_{timestamp}\",",
            "            auth_mode=auth_mode,",
            "            auth_config=auth_config,",
            "            use_composio_auth=use_composio_oauth_app,",
            "            force_new_integration=force_new_integration,",
            "        )",
            "",
            "    def initiate_connection(",
            "        self,",
            "        integration_id: t.Optional[str] = None,",
            "        app: t.Optional[AppType] = None,",
            "        labels: t.Optional[t.List] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        redirect_url: t.Optional[str] = None,",
            "        connected_account_params: t.Optional[t.Dict] = None,",
            "        *,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "        auth_config: t.Optional[t.Dict[str, t.Any]] = None,",
            "    ) -> ConnectionRequestModel:",
            "        \"\"\"",
            "        Initiates a connection with the specified integration.",
            "",
            "        If no integration exists for the given app, automatically creates one.",
            "",
            "        :param integration_id: (Optional[str]): ID of the existing integration",
            "        :param app: (Optional[AppType]): App to create/use integration for",
            "        :param redirect_url: (Optional[str]) Redirect URL for the App",
            "        :param auth_scheme: (Optional[AuthSchemeType]): Authentication scheme to use",
            "        :return: (ConnectionRequestModel) Details of the connection request.",
            "        \"\"\"",
            "        if auth_scheme is not None and auth_scheme not in AUTH_SCHEMES:",
            "            raise ComposioSDKError(f\"'auth_scheme' must be one of {AUTH_SCHEMES}\")",
            "",
            "        if integration_id is None:",
            "            if app is None:",
            "                raise ComposioSDKError(",
            "                    message=\"Both `integration_id` and `app` cannot be None\"",
            "                )",
            "",
            "            if auth_scheme is None:",
            "                auth_scheme = self.get_auth_scheme_for_app(app).auth_mode",
            "",
            "            try:",
            "                integration_id = self._get_integration_for_app(",
            "                    app=t.cast(",
            "                        AppType,",
            "                        app,",
            "                    ),",
            "                    auth_scheme=auth_scheme,",
            "                ).id",
            "            except NoItemsFound:",
            "                auth_config, use_composio_auth = self._validate_auth_config(",
            "                    app, auth_scheme, auth_config",
            "                )",
            "                integration = self.create_integration(",
            "                    app=app,",
            "                    auth_mode=auth_scheme,",
            "                    auth_config=auth_config,",
            "                    use_composio_oauth_app=use_composio_auth,",
            "                )",
            "                integration_id = integration.id",
            "",
            "        connected_account_params = connected_account_params or {}",
            "        expected_params = self.get_expected_params_for_user(",
            "            auth_scheme=auth_scheme, integration_id=integration_id",
            "        )[\"expected_params\"]",
            "        required_params = [param for param in expected_params if param.required]",
            "        unavailable_params = [",
            "            param.name",
            "            for param in required_params",
            "            if param.name not in connected_account_params",
            "        ]",
            "        if unavailable_params:",
            "            raise ComposioSDKError(",
            "                f\"Expected 'connected_account_params' to provide these params: {unavailable_params}\"",
            "            )",
            "",
            "        # Populate defaults in the connected_account_params",
            "        for param in expected_params:",
            "            if param.default is not None and param.name not in connected_account_params:",
            "                connected_account_params[param.name] = param.default",
            "",
            "        return self.client.connected_accounts.initiate(",
            "            integration_id=integration_id,",
            "            entity_id=entity_id or self.entity_id,",
            "            params=connected_account_params,",
            "            labels=labels,",
            "            redirect_url=redirect_url,",
            "        )",
            "",
            "    def _validate_auth_config(",
            "        self,",
            "        app: AppType,",
            "        auth_scheme: AuthSchemeType,",
            "        auth_config: t.Optional[t.Dict[str, t.Any]],",
            "    ) -> t.Tuple[t.Optional[t.Dict[str, t.Any]], bool]:",
            "        app_data = self.client.apps.get(name=str(app))",
            "        if auth_config is None and app_data.testConnectors:",
            "            # If we have connectors, can fallback to composio's own auth",
            "            return None, True",
            "",
            "        if auth_config is None:",
            "            auth_config = {}",
            "",
            "        auth_fields = self.fetch_expected_integration_params(",
            "            app=app_data, auth_scheme=auth_scheme",
            "        )",
            "        required_fields = [field for field in auth_fields if field.required]",
            "        unavailable_fields = [",
            "            field.name for field in required_fields if field.name not in auth_config",
            "        ]",
            "        if unavailable_fields:",
            "            raise ComposioSDKError(",
            "                f\"Expected 'auth_config' to provide these fields: {unavailable_fields}\"",
            "            ) from None",
            "",
            "        # Populate defaults in the auth_config",
            "        for field in auth_fields:",
            "            if field.default is not None and field.name not in auth_config:",
            "                auth_config[field.name] = field.default",
            "",
            "        return auth_config, False",
            "",
            "",
            "def _write_file(file_path: t.Union[str, os.PathLike], content: t.Union[str, bytes]):",
            "    \"\"\"Write content to a file.\"\"\"",
            "    if isinstance(content, str):",
            "        with open(file_path, \"w\", encoding=\"utf-8\") as file:",
            "            file.write(content)",
            "    else:",
            "        with open(file_path, \"wb\") as file:",
            "            file.write(content)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Composio SDK tools.",
            "\"\"\"",
            "",
            "import base64",
            "import binascii",
            "import hashlib",
            "import itertools",
            "import json",
            "import os",
            "import time",
            "import typing as t",
            "import uuid",
            "import warnings",
            "from datetime import datetime",
            "from functools import wraps",
            "from importlib.util import find_spec",
            "from pathlib import Path",
            "",
            "import typing_extensions as te",
            "from pydantic import BaseModel",
            "",
            "from composio import Action, ActionType, App, AppType, TagType",
            "from composio.client import Composio, Entity",
            "from composio.client.collections import (",
            "    AUTH_SCHEMES,",
            "    ActionModel,",
            "    AppAuthScheme,",
            "    AppModel,",
            "    AuthSchemeField,",
            "    AuthSchemeType,",
            "    ConnectedAccountModel,",
            "    ConnectionParams,",
            "    ConnectionRequestModel,",
            "    CustomAuthObject,",
            "    CustomAuthParameter,",
            "    ExpectedFieldInput,",
            "    FileType,",
            "    IntegrationModel,",
            "    SuccessExecuteActionResponseModel,",
            "    TriggerModel,",
            "    TriggerSubscription,",
            ")",
            "from composio.client.enums import TriggerType",
            "from composio.client.enums.base import EnumStringNotFound",
            "from composio.client.exceptions import ComposioClientError, HTTPError, NoItemsFound",
            "from composio.client.utils import check_cache_refresh",
            "from composio.constants import (",
            "    DEFAULT_ENTITY_ID,",
            "    ENV_COMPOSIO_API_KEY,",
            "    LOCAL_CACHE_DIRECTORY,",
            "    LOCAL_OUTPUT_FILE_DIRECTORY_NAME,",
            "    USER_DATA_FILE_NAME,",
            ")",
            "from composio.exceptions import ApiKeyNotProvidedError, ComposioSDKError",
            "from composio.storage.user import UserData",
            "from composio.tools.base.abs import tool_registry",
            "from composio.tools.base.local import LocalAction",
            "from composio.tools.env.base import (",
            "    ENV_GITHUB_ACCESS_TOKEN,",
            "    Workspace,",
            "    WorkspaceConfigType,",
            ")",
            "from composio.tools.env.factory import HostWorkspaceConfig, WorkspaceFactory",
            "from composio.tools.local import load_local_tools",
            "from composio.tools.local.handler import LocalClient",
            "from composio.utils.enums import get_enum_key",
            "from composio.utils.logging import LogIngester, LogLevel, WithLogger",
            "from composio.utils.url import get_api_url_base",
            "",
            "",
            "T = te.TypeVar(\"T\")",
            "P = te.ParamSpec(\"P\")",
            "",
            "_KeyType = t.Union[AppType, ActionType]",
            "_CallableType = t.Callable[[t.Dict], t.Dict]",
            "",
            "MetadataType = t.Dict[_KeyType, t.Dict]",
            "ParamType = t.TypeVar(\"ParamType\")",
            "ProcessorType = te.Literal[\"pre\", \"post\", \"schema\"]",
            "",
            "_IS_CI: t.Optional[bool] = None",
            "",
            "",
            "class IntegrationParams(te.TypedDict):",
            "",
            "    integration_id: str",
            "    auth_scheme: str",
            "    expected_params: t.List[ExpectedFieldInput]",
            "",
            "",
            "class ProcessorsType(te.TypedDict):",
            "    \"\"\"Request and response processors.\"\"\"",
            "",
            "    pre: te.NotRequired[t.Dict[_KeyType, _CallableType]]",
            "    \"\"\"Request processors.\"\"\"",
            "",
            "    post: te.NotRequired[t.Dict[_KeyType, _CallableType]]",
            "    \"\"\"Response processors.\"\"\"",
            "",
            "    schema: te.NotRequired[t.Dict[_KeyType, _CallableType]]",
            "    \"\"\"Schema processors\"\"\"",
            "",
            "",
            "def _check_agentops() -> bool:",
            "    \"\"\"Check if AgentOps is installed and initialized.\"\"\"",
            "    if find_spec(\"agentops\") is None:",
            "        return False",
            "    import agentops  # pylint: disable=import-outside-toplevel # type: ignore",
            "",
            "    return agentops.get_api_key() is not None",
            "",
            "",
            "def _is_ci():",
            "    global _IS_CI",
            "    if _IS_CI is None:",
            "        _IS_CI = os.environ.get(\"CI\") == \"true\"",
            "    return _IS_CI",
            "",
            "",
            "def _record_action_if_available(func: t.Callable[P, T]) -> t.Callable[P, T]:",
            "    @wraps(func)",
            "    def wrapper(self, *args, **kwargs):",
            "        if _check_agentops():",
            "            import agentops  # pylint: disable=import-outside-toplevel # type: ignore",
            "",
            "            action_name = str(kwargs.get(\"action\", \"unknown_action\"))",
            "            return agentops.record_action(action_name)(func)(self, *args, **kwargs)",
            "        return func(self, *args, **kwargs)  # type: ignore",
            "",
            "    return wrapper  # type: ignore",
            "",
            "",
            "class _Retry:",
            "    \"\"\"Sentinel value to indicate that the processor should retry the action\"\"\"",
            "",
            "",
            "RETRY = _Retry()",
            "",
            "",
            "class ComposioToolSet(WithLogger):  # pylint: disable=too-many-public-methods",
            "    \"\"\"Composio toolset.\"\"\"",
            "",
            "    _custom_auth: t.Dict[App, CustomAuthObject]",
            "",
            "    _connected_accounts: t.Optional[t.List[ConnectedAccountModel]] = None",
            "    _remote_client: t.Optional[Composio] = None",
            "    _workspace: t.Optional[Workspace] = None",
            "",
            "    _runtime: str = \"composio\"",
            "    _description_char_limit: int = 1024",
            "    _action_name_char_limit: t.Optional[int] = None",
            "    _log_ingester_client: t.Optional[LogIngester] = None",
            "",
            "    def __init_subclass__(",
            "        cls,",
            "        *args: t.Any,",
            "        runtime: t.Optional[str] = None,",
            "        description_char_limit: t.Optional[int] = None,",
            "        action_name_char_limit: t.Optional[int] = None,",
            "        **kwargs: t.Any,",
            "    ) -> None:",
            "        if runtime is None:",
            "            warnings.warn(",
            "                f\"runtime is not set on {cls.__name__}, using 'composio' as default\"",
            "            )",
            "        cls._runtime = runtime or \"composio\"",
            "",
            "        if description_char_limit is None:",
            "            warnings.warn(",
            "                f\"description_char_limit is not set on {cls.__name__}, using 1024 as default\"",
            "            )",
            "        cls._description_char_limit = description_char_limit or 1024",
            "        cls._action_name_char_limit = action_name_char_limit",
            "        if len(args) > 0 or len(kwargs) > 0:",
            "            error = (",
            "                f\"Composio toolset subclass initializer got extra {args=} and {kwargs=}\"",
            "            )",
            "            if _is_ci():",
            "                raise RuntimeError(error)",
            "            warnings.warn(error)",
            "",
            "    def __init__(",
            "        self,",
            "        api_key: t.Optional[str] = None,",
            "        base_url: t.Optional[str] = None,",
            "        entity_id: str = DEFAULT_ENTITY_ID,",
            "        workspace_id: t.Optional[str] = None,",
            "        workspace_config: t.Optional[WorkspaceConfigType] = None,",
            "        metadata: t.Optional[MetadataType] = None,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        output_in_file: bool = False,",
            "        logging_level: LogLevel = LogLevel.INFO,",
            "        output_dir: t.Optional[Path] = None,",
            "        verbosity_level: t.Optional[int] = None,",
            "        connected_account_ids: t.Optional[t.Dict[AppType, str]] = None,",
            "        *,",
            "        max_retries: int = 3,",
            "        **kwargs: t.Any,",
            "    ) -> None:",
            "        \"\"\"",
            "        Initialize composio toolset",
            "",
            "        :param api_key: Composio API key",
            "        :param base_url: Base URL for the Composio API server",
            "        :param runtime: Name of the framework runtime, eg. openai, crewai...",
            "        :param output_in_file: Whether to output the result to a file.",
            "        :param entity_id: The ID of the entity to execute the action on.",
            "            Defaults to \"default\".",
            "        :param workspace_env: Environment where actions should be executed,",
            "            you can choose from `host`, `docker`, `flyio` and `e2b`.",
            "        :param workspace_id: Workspace ID for loading an existing workspace",
            "        :param metadata: Additional metadata for executing an action or an",
            "            action which belongs to a specific app. The additional metadata",
            "            needs to be JSON serialisable dictionary. For example",
            "",
            "            ```python",
            "            toolset = ComposioToolSet(",
            "                ...,",
            "                metadata={",
            "                    App.IMAGEANALYSER: {",
            "                        \"base_url\": \"https://image.analyser/api\",",
            "                    },",
            "                    Action.IMAGEANALYSER_GTP4:{",
            "                        \"openai_api_key\": \"sk-proj-somekey\",",
            "                    }",
            "                }",
            "            )",
            "            ```",
            "        :param processors: Request and response processors, use these to",
            "            pre-process requests before executing an action and post-process",
            "            the response after an action has been executed. The processors can",
            "            be defined at app and action level. The order of execution will be",
            "",
            "            `App pre-processor -> Action pre-processor -> execute action -> Action post-processor -> App post-processor`",
            "",
            "            Heres and example of a request pre-processor",
            "",
            "            ```python",
            "            def _add_cwd_if_missing(request: t.Dict) -> t.Dict:",
            "                if \"cwd\" not in request:",
            "                    request[\"cwd\"] = \"~/project\"",
            "                return request",
            "",
            "            def _sanitise_file_search_request(request: t.Dict) -> t.Dict:",
            "                if \".tox\" not in request[\"exclude\"]:",
            "                    request[\"exclude\"].append(\".tox\")",
            "                return request",
            "",
            "            def _limit_file_search_response(response: t.Dict) -> t.Dict:",
            "                if len(response[\"results\"]) > 100:",
            "                    response[\"results\"] = response[\"results\"][:100]",
            "                return response",
            "",
            "            toolset = ComposioToolSet(",
            "                ...,",
            "                processors={",
            "                    \"pre\": {",
            "                        App.FILETOOL: _add_cwd_if_missing,",
            "                        Action.FILETOOL_SEARCH: _sanitise_file_search_request,",
            "                    },",
            "                    \"post\": {",
            "                        Action.FILETOOL_SEARCH: _limit_file_search_response,",
            "                    }",
            "                }",
            "            )",
            "            ```",
            "        :param verbosity_level: This defines the size of the log object that will",
            "            be printed on the console.",
            "        :param connection_ids: Use this to define connection IDs to use when executing",
            "            an action for a specific app.",
            "        \"\"\"",
            "        super().__init__(",
            "            logging_level=logging_level,",
            "            verbosity_level=verbosity_level,",
            "        )",
            "        self.logger.info(",
            "            f\"Logging is set to {self._logging_level}, \"",
            "            \"use `logging_level` argument or \"",
            "            \"`COMPOSIO_LOGGING_LEVEL` change this\"",
            "        )",
            "",
            "        self.session_id = workspace_id or uuid.uuid4().hex",
            "",
            "        self.entity_id = entity_id",
            "        self.output_in_file = output_in_file",
            "        self.output_dir = (",
            "            output_dir or LOCAL_CACHE_DIRECTORY / LOCAL_OUTPUT_FILE_DIRECTORY_NAME",
            "        )",
            "        self._ensure_output_dir_exists()",
            "",
            "        self._base_url = base_url or get_api_url_base()",
            "        try:",
            "            self._api_key = (",
            "                api_key",
            "                or os.environ.get(ENV_COMPOSIO_API_KEY)",
            "                or UserData.load(LOCAL_CACHE_DIRECTORY / USER_DATA_FILE_NAME).api_key",
            "            )",
            "        except FileNotFoundError:",
            "            self._api_key = None",
            "            self.logger.debug(\"`api_key` is not set when initializing toolset.\")",
            "",
            "        if processors is not None:",
            "            warnings.warn(",
            "                \"Setting 'processors' on the ToolSet is deprecated, they should\"",
            "                \"be provided to the 'get_tools()' method instead.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self._processors: ProcessorsType = processors",
            "        else:",
            "            self._processors = {\"post\": {}, \"pre\": {}, \"schema\": {}}",
            "",
            "        self._metadata = metadata or {}",
            "        self._workspace_id = workspace_id",
            "        self._workspace_config = workspace_config",
            "        self._local_client = LocalClient()",
            "        self._custom_auth = {}",
            "",
            "        if len(kwargs) > 0:",
            "            self.logger.info(f\"Extra kwargs while initializing toolset: {kwargs}\")",
            "",
            "        self.logger.debug(\"Loading local tools\")",
            "        load_local_tools()",
            "",
            "        self._connected_account_ids = self._validating_connection_ids(",
            "            connected_account_ids=connected_account_ids or {}",
            "        )",
            "        self.max_retries = max_retries",
            "",
            "        # To be populated by get_tools(), from within subclasses like",
            "        # composio_openai's Toolset.",
            "        self._requested_actions: t.Optional[t.List[str]] = None",
            "",
            "    def _validating_connection_ids(",
            "        self,",
            "        connected_account_ids: t.Dict[AppType, str],",
            "    ) -> t.Dict[App, str]:",
            "        \"\"\"Validate connection IDs.\"\"\"",
            "        valid = {}",
            "        invalid = []",
            "        entity = self.client.get_entity(id=self.entity_id)",
            "        for app, connected_account_id in connected_account_ids.items():",
            "            self.logger.debug(f\"Validating {app} {connected_account_id=}\")",
            "            try:",
            "                entity.get_connection(",
            "                    app=app,",
            "                    connected_account_id=connected_account_id,",
            "                )",
            "                valid[App(app)] = connected_account_id",
            "            except HTTPError:",
            "                invalid.append((str(app), connected_account_id))",
            "",
            "        if len(invalid) == 0:",
            "            return valid",
            "",
            "        raise ComposioSDKError(message=f\"Invalid connected accounts found: {invalid}\")",
            "",
            "    def _get_connected_account(self, action: ActionType) -> t.Optional[str]:",
            "        return self._connected_account_ids.get(App(Action(action).app))",
            "",
            "    def _try_get_github_access_token_for_current_entity(self) -> t.Optional[str]:",
            "        \"\"\"Try and get github access token for current entiry.\"\"\"",
            "        from_env = os.environ.get(f\"_COMPOSIO_{ENV_GITHUB_ACCESS_TOKEN}\")",
            "        if from_env is not None:",
            "            self.logger.debug(\"Using composio github access token\")",
            "            return from_env",
            "",
            "        self.logger.debug(f\"Trying to get github access token for {self.entity_id=}\")",
            "        try:",
            "            account = self.client.get_entity(id=self.entity_id).get_connection(",
            "                app=App.GITHUB",
            "            )",
            "            token = (",
            "                self.client.connected_accounts.get(connection_id=account.id)",
            "                .connectionParams.headers[\"Authorization\"]  # type: ignore",
            "                .replace(\"Bearer \", \"\")",
            "            )",
            "            self.logger.debug(",
            "                f\"Using `{token}` with scopes: {account.connectionParams.scope}\"",
            "            )",
            "            return token",
            "        except ComposioClientError:",
            "            return None",
            "",
            "    @property",
            "    def _log_ingester(self) -> LogIngester:",
            "        if self._log_ingester_client is None:",
            "            self._log_ingester_client = LogIngester()",
            "        return self._log_ingester_client",
            "",
            "    @property",
            "    def api_key(self) -> str:",
            "        if self._api_key is None:",
            "            raise ApiKeyNotProvidedError()",
            "        return self._api_key",
            "",
            "    @property",
            "    def client(self) -> Composio:",
            "        if self._remote_client is None:",
            "            self._remote_client = Composio(",
            "                api_key=self._api_key,",
            "                base_url=self._base_url,",
            "                runtime=self._runtime,",
            "            )",
            "            check_cache_refresh(self._remote_client)",
            "",
            "        self._remote_client.local = self._local_client",
            "        return self._remote_client",
            "",
            "    @property",
            "    def workspace(self) -> Workspace:",
            "        \"\"\"Workspace for this toolset instance.\"\"\"",
            "        if self._workspace is not None:",
            "            return self._workspace",
            "",
            "        if self._workspace_id is not None:",
            "            self._workspace = WorkspaceFactory.get(id=self._workspace_id)",
            "            return self._workspace",
            "",
            "        workspace_config = self._workspace_config or HostWorkspaceConfig()",
            "        if workspace_config.composio_api_key is None:",
            "            workspace_config.composio_api_key = self.api_key",
            "",
            "        if workspace_config.composio_base_url is None:",
            "            workspace_config.composio_base_url = self._base_url",
            "",
            "        if workspace_config.github_access_token is None:",
            "            workspace_config.github_access_token = (",
            "                self._try_get_github_access_token_for_current_entity()",
            "            )",
            "",
            "        self._workspace = WorkspaceFactory.new(config=workspace_config)",
            "        return self._workspace",
            "",
            "    def set_workspace_id(self, workspace_id: str) -> None:",
            "        self._workspace_id = workspace_id",
            "        if self._workspace is not None:",
            "            self._workspace = WorkspaceFactory.get(id=workspace_id)",
            "",
            "    def add_auth(",
            "        self,",
            "        app: AppType,",
            "        parameters: t.List[CustomAuthParameter],",
            "        base_url: t.Optional[str] = None,",
            "        body: t.Optional[t.Dict] = None,",
            "    ) -> None:",
            "        self._custom_auth[App(app)] = CustomAuthObject(",
            "            body=body or {},",
            "            base_url=base_url,",
            "            parameters=parameters,",
            "        )",
            "",
            "    def check_connected_account(self, action: ActionType) -> None:",
            "        \"\"\"Check if connected account is required and if required it exists or not.\"\"\"",
            "        action = Action(action)",
            "        if action.no_auth or action.is_runtime:",
            "            return",
            "",
            "        if App(action.app) in self._custom_auth:",
            "            return",
            "",
            "        if self._connected_accounts is None:",
            "            self._connected_accounts = t.cast(",
            "                t.List[ConnectedAccountModel],",
            "                self.client.connected_accounts.get(),",
            "            )",
            "",
            "        if action.app not in [",
            "            # Normalize app names/ids coming from API",
            "            connection.appUniqueId.upper()",
            "            for connection in self._connected_accounts",
            "        ]:",
            "            raise ComposioSDKError(",
            "                f\"No connected account found for app `{action.app}`; \"",
            "                f\"Run `composio add {action.app.lower()}` to fix this\"",
            "            )",
            "",
            "    def _execute_local(",
            "        self,",
            "        action: Action,",
            "        params: t.Dict,",
            "        metadata: t.Optional[t.Dict] = None,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"Execute a local action.\"\"\"",
            "        metadata = metadata or {}",
            "        metadata[\"_toolset\"] = self",
            "        response = self.workspace.execute_action(",
            "            action=action,",
            "            request_data=params,",
            "            metadata={",
            "                **(metadata or {}),",
            "                \"entity_id\": entity_id or self.entity_id,",
            "            },",
            "        )",
            "",
            "        if isinstance(response, BaseModel):",
            "            response = response.model_dump()",
            "",
            "        self._log_ingester.log(",
            "            connection_id=None,",
            "            provider_name=action.app,",
            "            action_name=action.name,",
            "            request=params,",
            "            response=response,",
            "            is_error=not response.get(\"successful\", False),",
            "            session_id=self.workspace.id,",
            "        )",
            "",
            "        return response",
            "",
            "    def _execute_remote(",
            "        self,",
            "        action: Action,",
            "        params: t.Dict,",
            "        entity_id: str = DEFAULT_ENTITY_ID,",
            "        connected_account_id: t.Optional[str] = None,",
            "        session_id: t.Optional[str] = None,",
            "        text: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"Execute a remote action.\"\"\"",
            "        auth = self._custom_auth.get(App(action.app))",
            "        if auth is None:",
            "            self.check_connected_account(action=action)",
            "",
            "        entity = self.client.get_entity(id=entity_id)",
            "        output = entity._execute(  # pylint: disable=protected-access",
            "            action=action,",
            "            params=params,",
            "            connected_account_id=connected_account_id,",
            "            session_id=session_id,",
            "            text=text,",
            "            auth=auth,",
            "        )",
            "",
            "        if self.output_in_file:",
            "            return self._write_to_file(",
            "                action=action,",
            "                output=output,",
            "                entity_id=entity_id,",
            "            )",
            "",
            "        try:",
            "            self.logger.debug(\"Trying to validate success response model\")",
            "            success_response_model = SuccessExecuteActionResponseModel.model_validate(",
            "                output",
            "            )",
            "        except Exception:",
            "            self.logger.debug(\"Failed to validate success response model\")",
            "            return output",
            "",
            "        return self._save_var_files(",
            "            file_name_prefix=f\"{action.name}_{entity_id}_{time.time()}\",",
            "            success_response_model=success_response_model,",
            "        )",
            "",
            "    def _ensure_output_dir_exists(self):",
            "        \"\"\"Ensure the output directory exists.\"\"\"",
            "        if not self.output_dir.exists():",
            "            self.output_dir.mkdir(parents=True, exist_ok=True)",
            "",
            "    def _save_var_files(",
            "        self,",
            "        file_name_prefix: str,",
            "        success_response_model: SuccessExecuteActionResponseModel,",
            "    ) -> dict:",
            "        error = success_response_model.error",
            "        resp_data = success_response_model.data",
            "        is_invalid_file = False",
            "        for key, val in resp_data.items():",
            "            try:",
            "                file_model = FileType.model_validate(val)",
            "                self._ensure_output_dir_exists()",
            "",
            "                local_filepath = (",
            "                    self.output_dir",
            "                    / f\"{file_name_prefix}_{file_model.name.replace('/', '_')}\"",
            "                )",
            "",
            "                _write_file(",
            "                    local_filepath, base64.urlsafe_b64decode(file_model.content)",
            "                )",
            "",
            "                resp_data[key] = str(local_filepath)",
            "            except binascii.Error:",
            "                is_invalid_file = True",
            "                resp_data[key] = \"Invalid File! Unable to decode.\"",
            "            except Exception:",
            "                pass",
            "",
            "        if is_invalid_file is True and error is None:",
            "            success_response_model.error = \"Execution failed\"",
            "        success_response_model.data = resp_data",
            "        return success_response_model.model_dump()",
            "",
            "    def _write_to_file(",
            "        self,",
            "        action: Action,",
            "        output: t.Dict,",
            "        entity_id: str = DEFAULT_ENTITY_ID,",
            "    ) -> t.Dict:",
            "        \"\"\"Write output to a file.\"\"\"",
            "        filename = hashlib.sha256(",
            "            f\"{action.name}-{entity_id}-{time.time()}\".encode()",
            "        ).hexdigest()",
            "        self._ensure_output_dir_exists()",
            "        outfile = self.output_dir / filename",
            "        self.logger.info(f\"Writing output to: {outfile}\")",
            "        _write_file(outfile, json.dumps(output))",
            "        return {",
            "            \"message\": f\"output written to {outfile.resolve()}\",",
            "            \"file\": str(outfile.resolve()),",
            "        }",
            "",
            "    def _serialize_execute_params(self, param: ParamType) -> ParamType:",
            "        \"\"\"Returns a serialized version of the parameters object.\"\"\"",
            "        if param is None:",
            "            return param  # type: ignore",
            "",
            "        if isinstance(param, (int, float, str, bool)):",
            "            return param  # type: ignore",
            "",
            "        if isinstance(param, BaseModel):",
            "            return param.model_dump(exclude_none=True)  # type: ignore",
            "",
            "        if isinstance(param, list):",
            "            return [self._serialize_execute_params(p) for p in param]  # type: ignore",
            "",
            "        if isinstance(param, dict):",
            "            return {",
            "                key: self._serialize_execute_params(val)  # type: ignore",
            "                for key, val in param.items()",
            "            }",
            "",
            "        raise ValueError(",
            "            \"Invalid value found for execute parameters\"",
            "            f\"\\ntype={type(param)} \\nvalue={param}\"",
            "        )",
            "",
            "    def _get_metadata(self, key: _KeyType) -> t.Dict:",
            "        metadata = self._metadata.get(key)  # type: ignore",
            "        if metadata is not None:",
            "            return metadata",
            "",
            "        try:",
            "            return self._metadata.get(Action(t.cast(ActionType, key)), {})  # type: ignore",
            "        except EnumStringNotFound:",
            "            return self._metadata.get(App(t.cast(AppType, key)), {})  # type: ignore",
            "",
            "    def _add_metadata(self, action: Action, metadata: t.Optional[t.Dict]) -> t.Dict:",
            "        metadata = metadata or {}",
            "        metadata.update(self._get_metadata(key=App(action.app)))",
            "        metadata.update(self._get_metadata(key=action))",
            "        return metadata",
            "",
            "    def _get_processor(",
            "        self,",
            "        key: _KeyType,",
            "        type_: te.Literal[\"post\", \"pre\", \"schema\"],",
            "    ) -> t.Optional[_CallableType]:",
            "        \"\"\"Get processor for given app or action\"\"\"",
            "        processor = self._processors.get(type_, {}).get(key)  # type: ignore",
            "        if processor is not None:",
            "            return processor",
            "",
            "        try:",
            "            return self._processors.get(type_, {}).get(Action(t.cast(ActionType, key)))  # type: ignore",
            "        except EnumStringNotFound:",
            "            return self._processors.get(type_, {}).get(App(t.cast(AppType, key)))  # type: ignore",
            "",
            "    def _process(",
            "        self,",
            "        key: _KeyType,",
            "        data: t.Dict,",
            "        type_: te.Literal[\"pre\", \"post\", \"schema\"],",
            "    ) -> t.Union[t.Dict, _Retry]:",
            "        processor = self._get_processor(key=key, type_=type_)",
            "        if processor is not None:",
            "            self.logger.info(",
            "                f\"Running {'request' if type_ == 'pre' else 'response' if type_ == 'post' else 'schema'}\"",
            "                f\" through: {processor.__name__}\"",
            "            )",
            "            data = processor(data)",
            "            # Users may not respect our type annotations and return something that isn't a dict.",
            "            # If that happens we should show a friendly error message.",
            "            if not isinstance(data, t.Dict):",
            "                warnings.warn(",
            "                    f\"Expected {type_}-processor to return 'dict', got {type(data).__name__!r}\",",
            "                    stacklevel=2,",
            "                )",
            "        return data",
            "",
            "    def _process_request(self, action: Action, request: t.Dict) -> t.Dict:",
            "        processed = self._process(",
            "            key=App(action.app),",
            "            data=request,",
            "            type_=\"pre\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from App preprocessor function.\"",
            "                \" Preprocessors cannot be retried.\"",
            "            )",
            "",
            "        processed = self._process(",
            "            key=action,",
            "            data=processed,",
            "            type_=\"pre\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from Action preprocessor function.\"",
            "                \" Preprocessors cannot be retried.\"",
            "            )",
            "",
            "        return processed",
            "",
            "    def _process_respone(",
            "        self, action: Action, response: t.Dict",
            "    ) -> t.Union[t.Dict, _Retry]:",
            "        processed = self._process(",
            "            key=App(action.app),",
            "            data=response,",
            "            type_=\"post\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            return RETRY",
            "",
            "        processed = self._process(",
            "            key=action,",
            "            data=processed,",
            "            type_=\"post\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            return RETRY",
            "",
            "        return processed",
            "",
            "    def _process_schema_properties(self, action: Action, properties: t.Dict) -> t.Dict:",
            "        processed = self._process(",
            "            key=App(action.app),",
            "            data=properties,",
            "            type_=\"schema\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from App schema processor function.\"",
            "                \" Schema pprocessors cannot be retried.\"",
            "            )",
            "",
            "        processed = self._process(",
            "            key=action,",
            "            data=processed,",
            "            type_=\"schema\",",
            "        )",
            "        if isinstance(processed, _Retry):",
            "            raise ComposioSDKError(",
            "                \"Received RETRY from Action preprocessor function.\"",
            "                \" Schema processors cannot be retried.\"",
            "            )",
            "        return processed",
            "",
            "    def _merge_processors(self, processors: ProcessorsType) -> None:",
            "        for processor_type in self._processors.keys():",
            "            if processor_type not in processors:",
            "                continue",
            "",
            "            processor_type = t.cast(ProcessorType, processor_type)",
            "            new_processors = processors[processor_type]",
            "",
            "            if processor_type in self._processors:",
            "                existing_processors = self._processors[processor_type]",
            "            else:",
            "                existing_processors = {}",
            "                self._processors[processor_type] = existing_processors",
            "",
            "            existing_processors.update(new_processors)",
            "",
            "    @_record_action_if_available",
            "    def execute_action(",
            "        self,",
            "        action: ActionType,",
            "        params: dict,",
            "        metadata: t.Optional[t.Dict] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        connected_account_id: t.Optional[str] = None,",
            "        text: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute an action on a given entity.",
            "",
            "        :param action: Action to execute",
            "        :param params: The parameters to pass to the action",
            "        :param entity_id: The ID of the entity to execute the action on. Defaults to \"default\"",
            "        :param text: Extra text to use for generating function calling metadata",
            "        :param metadata: Metadata for executing local action",
            "        :param connected_account_id: Connection ID for executing the remote action",
            "        :return: Output object from the function call",
            "        \"\"\"",
            "        action = Action(action)",
            "        if (",
            "            self._requested_actions is not None",
            "            and action.slug not in self._requested_actions",
            "        ):",
            "            raise ComposioSDKError(",
            "                f\"Action {action.slug} is being called, but was never requested by the toolset. \"",
            "                \"Make sure that the actions you are trying to execute are requested in your \"",
            "                \"`get_tools()` call.\"",
            "            )",
            "",
            "        params = self._serialize_execute_params(param=params)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "",
            "        if not action.is_runtime:",
            "            params = self._process_request(action=action, request=params)",
            "            metadata = self._add_metadata(action=action, metadata=metadata)",
            "            connected_account_id = connected_account_id or self._get_connected_account(",
            "                action=action",
            "            )",
            "",
            "        self.logger.info(",
            "            f\"Executing `{action.slug}` with {params=} and {metadata=} {connected_account_id=}\"",
            "        )",
            "",
            "        failed_responses = []",
            "        for _ in range(self.max_retries):",
            "            response = (",
            "                self._execute_local(",
            "                    action=action,",
            "                    params=params,",
            "                    metadata=metadata,",
            "                    entity_id=entity_id,",
            "                )",
            "                if action.is_local",
            "                else self._execute_remote(",
            "                    action=action,",
            "                    params=params,",
            "                    entity_id=entity_id or self.entity_id,",
            "                    connected_account_id=connected_account_id,",
            "                    text=text,",
            "                    session_id=self.session_id,",
            "                )",
            "            )",
            "            processed_response = (",
            "                response",
            "                if action.is_runtime",
            "                else self._process_respone(action=action, response=response)",
            "            )",
            "            if isinstance(processed_response, _Retry):",
            "                self.logger.info(",
            "                    f\"Got {processed_response=} from {action=} with {params=}, retrying...\"",
            "                )",
            "                failed_responses.append(response)",
            "                continue",
            "",
            "            response = processed_response",
            "            self.logger.info(f\"Got {response=} from {action=} with {params=}\")",
            "            return response",
            "",
            "        return SuccessExecuteActionResponseModel(",
            "            successfull=False,",
            "            data={\"failed_responses\": failed_responses},",
            "            error=f\"Execution failed after {self.max_retries} retries.\",",
            "        ).model_dump()",
            "",
            "    @t.overload",
            "    def execute_request(",
            "        self,",
            "        endpoint: str,",
            "        method: str,",
            "        *,",
            "        body: t.Optional[t.Dict] = None,",
            "        parameters: t.Optional[t.List[CustomAuthParameter]] = None,",
            "        connection_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        pass",
            "",
            "    @t.overload",
            "    def execute_request(",
            "        self,",
            "        endpoint: str,",
            "        method: str,",
            "        *,",
            "        body: t.Optional[t.Dict] = None,",
            "        parameters: t.Optional[t.List[CustomAuthParameter]] = None,",
            "        app: t.Optional[AppType] = None,",
            "    ) -> t.Dict:",
            "        pass",
            "",
            "    def execute_request(",
            "        self,",
            "        endpoint: str,",
            "        method: str,",
            "        *,",
            "        body: t.Optional[t.Dict] = None,",
            "        parameters: t.Optional[t.List[CustomAuthParameter]] = None,",
            "        connection_id: t.Optional[str] = None,",
            "        app: t.Optional[AppType] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute a proxy request to a connected account.",
            "",
            "        :param endpoint: API endpoint to call",
            "        :param method: HTTP method to use (GET, POST, etc.)",
            "        :param body: Request body data",
            "        :param parameters: Additional auth parameters",
            "        :param connection_id: ID of the connected account",
            "        :param app: App type to use for connection lookup",
            "",
            "        :returns: Response from the proxy request",
            "        :raises: ComposioSDKError: If neither connection_id nor app is provided",
            "        \"\"\"",
            "        if app is not None and connection_id is None:",
            "            connection_id = (",
            "                self.get_entity(id=self.entity_id).get_connection(app=app).id",
            "            )",
            "",
            "        if connection_id is None:",
            "            raise ComposioSDKError(",
            "                \"Please provide connection id or app name to execute a request\"",
            "            )",
            "",
            "        self.logger.info(",
            "            f\"Executing request to {endpoint} with method={method}, connection_id={connection_id}\"",
            "        )",
            "        response = self.client.actions.request(",
            "            connection_id=connection_id,",
            "            body=body,",
            "            method=method,",
            "            endpoint=endpoint,",
            "            parameters=parameters,",
            "        )",
            "        self.logger.info(f\"Got {response=}\")",
            "        return response",
            "",
            "    def validate_tools(",
            "        self,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        tags: t.Optional[t.Sequence[TagType]] = None,",
            "    ) -> None:",
            "        # NOTE: This an experimental, can convert to decorator for more convinience",
            "        if not apps and not actions and not tags:",
            "            return",
            "",
            "        self.workspace.check_for_missing_dependencies(",
            "            apps=apps,",
            "            actions=actions,",
            "            tags=tags,",
            "        )",
            "",
            "    def get_action_schemas(",
            "        self,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        tags: t.Optional[t.Sequence[TagType]] = None,",
            "        *,",
            "        check_connected_accounts: bool = True,",
            "        _populate_requested: bool = False,",
            "    ) -> t.List[ActionModel]:",
            "        runtime_actions = t.cast(",
            "            t.List[t.Type[LocalAction]],",
            "            [action for action in actions or [] if hasattr(action, \"run_on_shell\")],",
            "        )",
            "        actions = t.cast(",
            "            t.List[Action],",
            "            [",
            "                Action(action)",
            "                for action in actions or []",
            "                if action not in runtime_actions",
            "            ],",
            "        )",
            "        apps = t.cast(t.List[App], [App(app) for app in apps or []])",
            "        items: t.List[ActionModel] = []",
            "",
            "        local_actions = [action for action in actions if action.is_local]",
            "        local_apps = [app for app in apps if app.is_local]",
            "        if len(local_actions) > 0 or len(local_apps) > 0:",
            "            items += [",
            "                ActionModel(**item)",
            "                for item in self._local_client.get_action_schemas(",
            "                    apps=local_apps,",
            "                    actions=local_actions,",
            "                    tags=tags,",
            "                )",
            "            ]",
            "",
            "        remote_actions = [action for action in actions if not action.is_local]",
            "        remote_apps = [app for app in apps if not app.is_local]",
            "        if len(remote_actions) > 0 or len(remote_apps) > 0:",
            "            remote_items = self.client.actions.get(",
            "                apps=remote_apps,",
            "                actions=remote_actions,",
            "                tags=tags,",
            "            )",
            "            if check_connected_accounts:",
            "                for item in remote_items:",
            "                    self.check_connected_account(action=item.name)",
            "            else:",
            "                warnings.warn(",
            "                    \"Not verifying connected accounts for apps.\"",
            "                    \" Actions may fail when the Agent tries to use them.\",",
            "                    UserWarning,",
            "                )",
            "            items = items + remote_items",
            "",
            "        for act in runtime_actions:",
            "            schema = act.schema()",
            "            schema[\"name\"] = act.enum",
            "            items.append(ActionModel(**schema).model_copy(deep=True))",
            "",
            "        for item in items:",
            "            item = self._process_schema(item)",
            "",
            "            # This is to support anthropic-claude",
            "            if item.name == Action.ANTHROPIC_BASH_COMMAND.slug:",
            "                item.name = \"bash\"",
            "",
            "            if item.name == Action.ANTHROPIC_COMPUTER.slug:",
            "                item.name = \"computer\"",
            "",
            "            if item.name == Action.ANTHROPIC_TEXT_EDITOR.slug:",
            "                item.name = \"str_replace_editor\"",
            "",
            "        if _populate_requested:",
            "            action_names = [item.name for item in items]",
            "            if self._requested_actions is None:",
            "                self._requested_actions = []",
            "",
            "            self._requested_actions += action_names",
            "",
            "        return items",
            "",
            "    def _process_schema(self, action_item: ActionModel) -> ActionModel:",
            "        required_params = action_item.parameters.required or []",
            "        for param_name, param_details in action_item.parameters.properties.items():",
            "            if param_details.get(\"title\") == \"FileType\" and all(",
            "                fprop in param_details.get(\"properties\", {})",
            "                for fprop in (\"name\", \"content\")",
            "            ):",
            "                action_item.parameters.properties[param_name].pop(\"properties\")",
            "                action_item.parameters.properties[param_name] = {",
            "                    \"default\": param_details.get(\"default\"),",
            "                    \"type\": \"string\",",
            "                    \"format\": \"file-path\",",
            "                    \"description\": f\"File path to {param_details.get('description', '')}\",",
            "                }",
            "            elif param_details.get(\"allOf\", [{}])[0].get(\"title\") == \"FileType\" and all(",
            "                fprop in param_details.get(\"allOf\", [{}])[0].get(\"properties\", {})",
            "                for fprop in (\"name\", \"content\")",
            "            ):",
            "                action_item.parameters.properties[param_name].pop(\"allOf\")",
            "                action_item.parameters.properties[param_name].update(",
            "                    {",
            "                        \"default\": param_details.get(\"default\"),",
            "                        \"type\": \"string\",",
            "                        \"format\": \"file-path\",",
            "                        \"description\": f\"File path to {param_details.get('description', '')}\",",
            "                    }",
            "                )",
            "            elif param_details.get(\"type\") in [",
            "                \"string\",",
            "                \"integer\",",
            "                \"number\",",
            "                \"boolean\",",
            "            ]:",
            "                ext = f'Please provide a value of type {param_details[\"type\"]}.'",
            "                description = param_details.get(\"description\", \"\").rstrip(\".\")",
            "                param_details[\"description\"] = (",
            "                    f\"{description}. {ext}\" if description else ext",
            "                )",
            "",
            "            if param_name in required_params:",
            "                description = param_details.get(\"description\", \"\")",
            "                if description:",
            "                    param_details[\"description\"] = (",
            "                        f\"{description.rstrip('.')}. This parameter is required.\"",
            "                    )",
            "                else:",
            "                    param_details[\"description\"] = \"This parameter is required.\"",
            "",
            "        if action_item.description is not None:",
            "            action_item.description = action_item.description[",
            "                : self._description_char_limit",
            "            ]",
            "        action_item.parameters.properties = self._process_schema_properties(",
            "            action=Action(action_item.name.upper()),",
            "            properties=action_item.parameters.properties,",
            "        )",
            "        if self._action_name_char_limit is not None:",
            "            action_item.name = action_item.name[: self._action_name_char_limit]",
            "        return action_item",
            "",
            "    def create_trigger_listener(self, timeout: float = 15.0) -> TriggerSubscription:",
            "        \"\"\"Create trigger subscription.\"\"\"",
            "        return self.client.triggers.subscribe(timeout=timeout)",
            "",
            "    def find_actions_by_use_case(",
            "        self,",
            "        *apps: AppType,",
            "        use_case: str,",
            "        advanced: bool = False,",
            "    ) -> t.List[Action]:",
            "        \"\"\"",
            "        Find actions by specified use case.",
            "",
            "        :param apps: List of apps to search.",
            "        :param use_case: String describing the use case.",
            "        :param advanced: Use advanced search (will be slower than the normal search)",
            "        :return: A list of actions matching the relevant use case.",
            "        \"\"\"",
            "        if advanced:",
            "            actions = []",
            "            for task in self.client.actions.search_for_a_task(use_case=use_case):",
            "                actions += task.actions",
            "        else:",
            "            actions = list(",
            "                map(",
            "                    lambda x: get_enum_key(x.name),",
            "                    self.client.actions.get(",
            "                        apps=[App(app) for app in apps],",
            "                        use_case=use_case,",
            "                        allow_all=True,",
            "                    ),",
            "                )",
            "            )",
            "        return [Action(action) for action in actions]",
            "",
            "    def find_actions_by_tags(",
            "        self,",
            "        *apps: AppType,",
            "        tags: t.List[str],",
            "    ) -> t.List[Action]:",
            "        \"\"\"",
            "        Find actions by specified use case.",
            "",
            "        :param apps: List of apps to search.",
            "        :param use_case: String describing the use case.",
            "        :return: A list of actions matching the relevant use case.",
            "        \"\"\"",
            "        if len(tags) == 0:",
            "            raise ComposioClientError(",
            "                \"Please provide at least one tag to perform search\"",
            "            )",
            "",
            "        if len(apps) > 0:",
            "            return list(",
            "                itertools.chain(",
            "                    *[list(App(app).get_actions(tags=tags)) for app in apps]",
            "                )",
            "            )",
            "",
            "        actions = []",
            "        for action in Action.all():",
            "            if any(tag in action.tags for tag in tags):",
            "                actions.append(action)",
            "        return actions",
            "",
            "    def get_agent_instructions(",
            "        self,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        tags: t.Optional[t.Sequence[TagType]] = None,",
            "    ) -> str:",
            "        \"\"\"",
            "        Generate a formatted string with instructions for agents based on the provided apps, actions, and tags.",
            "",
            "        This function compiles a list of available tools from the specified apps, actions, and tags,",
            "        and formats them into a human-readable string that can be used as instructions for agents.",
            "",
            "        :param apps: Optional sequence of AppType to include in the search.",
            "        :param actions: Optional sequence of ActionType to include in the search.",
            "        :param tags: Optional sequence of TagType to filter the actions.",
            "        :return: A formatted string with instructions for agents.",
            "        \"\"\"",
            "        # Retrieve schema information for the given apps, actions, and tags",
            "        schema_list = [",
            "            schema.model_dump()",
            "            for schema in (",
            "                self.get_action_schemas(apps=apps, tags=tags)",
            "                + self.get_action_schemas(actions=actions)",
            "            )",
            "        ]",
            "        schema_info = [",
            "            (schema_obj[\"appName\"], schema_obj[\"name\"]) for schema_obj in schema_list",
            "        ]",
            "",
            "        # Helper function to format a list of items into a string",
            "        def format_list(items):",
            "            if not items:",
            "                return \"\"",
            "            if len(items) == 1:",
            "                return items[0]",
            "            return \", \".join(items[:-2] + [\" and \".join(items[-2:])])",
            "",
            "        # Organize the schema information by app name",
            "        action_dict: t.Dict[str, t.List] = {}",
            "        for appName, name in schema_info:",
            "            if appName not in action_dict:",
            "                action_dict[appName] = []",
            "            action_dict[appName].append(name)",
            "",
            "        # Format the schema information into a human-readable string",
            "        formatted_schema_info = (",
            "            \"You have various tools, among which \"",
            "            + \", \".join(",
            "                [",
            "                    f\"for interacting with **{appName}** you might use {format_list(action_items)} tools\"",
            "                    for appName, action_items in action_dict.items()",
            "                ]",
            "            )",
            "            + \". Whichever tool is useful to execute your task, use that with proper parameters.\"",
            "        )",
            "        return formatted_schema_info",
            "",
            "    def get_auth_params(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        connection_id: t.Optional[str] = None,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Optional[ConnectionParams]:",
            "        \"\"\"Get authentication parameters for given app.\"\"\"",
            "        if app is None and connection_id is None:",
            "            raise ComposioSDKError(\"Both `app` and `connection_id` cannot be `None`\")",
            "",
            "        try:",
            "            connection_id = (",
            "                connection_id",
            "                or self.client.get_entity(id=entity_id or self.entity_id)",
            "                .get_connection(app=app)",
            "                .id",
            "            )",
            "            return self.client.connected_accounts.info(connection_id=connection_id)",
            "        except ComposioClientError:",
            "            return None",
            "",
            "    def get_auth_schemes(self, app: AppType) -> t.List[AppAuthScheme]:",
            "        \"\"\"Get the list of auth schemes for an app.\"\"\"",
            "        return self.client.apps.get(name=str(app)).auth_schemes or []",
            "",
            "    def get_app(self, app: AppType) -> AppModel:",
            "        return self.client.apps.get(name=str(App(app)))",
            "",
            "    def get_apps(",
            "        self,",
            "        no_auth: t.Optional[bool] = None,",
            "        include_local: bool = True,",
            "    ) -> t.List[AppModel]:",
            "        apps = self.client.apps.get()",
            "        print(apps)",
            "        if no_auth is not None:",
            "            apps = [a for a in apps if a.no_auth is no_auth]",
            "",
            "        if include_local:",
            "            for app in tool_registry[\"local\"].values():",
            "                apps.append(",
            "                    AppModel(",
            "                        name=app.name,",
            "                        key=app.name,",
            "                        appId=app.name,",
            "                        description=app.description,",
            "                        categories=[\"local\"],",
            "                        meta={},",
            "                        no_auth=True,",
            "                    )",
            "                )",
            "        return apps",
            "",
            "    def get_action(self, action: ActionType) -> ActionModel:",
            "        return self.client.actions.get(actions=[action]).pop()",
            "",
            "    def get_trigger(self, trigger: TriggerType) -> TriggerModel:",
            "        return self.client.triggers.get(trigger_names=[trigger]).pop()",
            "",
            "    def get_integration(self, id: str) -> IntegrationModel:",
            "        return self.client.integrations.get(id=id)",
            "",
            "    def get_integrations(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "    ) -> t.List[IntegrationModel]:",
            "        integrations = self.client.integrations.get()",
            "        if app is not None:",
            "            app = str(app).lower()",
            "            integrations = [i for i in integrations if i.appName.lower() == app]",
            "",
            "        if auth_scheme is not None:",
            "            integrations = [i for i in integrations if i.authScheme == auth_scheme]",
            "",
            "        return integrations",
            "",
            "    def get_connected_account(self, id: str) -> ConnectedAccountModel:",
            "        return self.client.connected_accounts.get(connection_id=id)",
            "",
            "    def get_connected_accounts(self) -> t.List[ConnectedAccountModel]:",
            "        return self.client.connected_accounts.get()",
            "",
            "    def get_entity(self, id: t.Optional[str] = None) -> Entity:",
            "        \"\"\"Get entity object for given ID.\"\"\"",
            "        return self.client.get_entity(id=id or self.entity_id)",
            "",
            "    def get_auth_scheme_for_app(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "    ) -> AppAuthScheme:",
            "        auth_schemes = {",
            "            scheme.auth_mode: scheme",
            "            for scheme in self.client.apps.get(name=str(app)).auth_schemes or []",
            "        }",
            "",
            "        if auth_scheme is not None and auth_scheme not in auth_schemes:",
            "            raise ComposioSDKError(",
            "                message=f\"Auth scheme `{auth_scheme}` not found for app `{app}`\"",
            "            )",
            "",
            "        if auth_scheme is not None:",
            "            return auth_schemes[auth_scheme]",
            "",
            "        for scheme in AUTH_SCHEMES:",
            "            if scheme in auth_schemes:",
            "                scheme = t.cast(AuthSchemeType, scheme)",
            "                return auth_schemes[scheme]",
            "",
            "        raise ComposioSDKError(",
            "            message=(",
            "                f\"Error getting expected params for {app=}, {auth_scheme=}, \"",
            "                f\"available_schems={list(auth_schemes)}\"",
            "            )",
            "        )",
            "",
            "    def _get_expected_params_from_integration_id(self, id: str) -> IntegrationParams:",
            "        integration = self.get_integration(id=id)",
            "        return {",
            "            \"integration_id\": integration.id,",
            "            \"auth_scheme\": integration.authScheme,",
            "            \"expected_params\": integration.expectedInputFields,",
            "        }",
            "",
            "    def _get_integration_for_app(",
            "        self,",
            "        app: AppType,",
            "        auth_scheme: t.Optional[str] = None,",
            "    ) -> IntegrationModel:",
            "        for integration in sorted(self.get_integrations(), key=lambda x: x.createdAt):",
            "            if integration.appName.lower() == str(app).lower():",
            "                if (",
            "                    auth_scheme is not None",
            "                    and integration.authScheme.lower() != auth_scheme.lower()",
            "                ):",
            "                    continue",
            "                return self.get_integration(id=integration.id)",
            "        raise NoItemsFound(f\"No integration found for `{app}`\")",
            "",
            "    def _get_expected_params_from_app(",
            "        self,",
            "        app: AppType,",
            "        auth_scheme: t.Optional[str] = None,",
            "    ) -> IntegrationParams:",
            "        integration = self._get_integration_for_app(app=app, auth_scheme=auth_scheme)",
            "        return {",
            "            \"integration_id\": integration.id,",
            "            \"auth_scheme\": integration.authScheme,",
            "            \"expected_params\": integration.expectedInputFields,",
            "        }",
            "",
            "    def _can_use_auth_scheme_without_user_input(",
            "        self, scheme: AppAuthScheme, app: AppModel",
            "    ) -> bool:",
            "        if (",
            "            scheme.auth_mode in (\"OAUTH2\", \"OAUTH1\")",
            "            and len(app.testConnectors or []) > 0",
            "        ):",
            "            return True",
            "",
            "        for field in scheme.fields:",
            "            if not field.expected_from_customer and field.required:",
            "                return False",
            "",
            "        return True",
            "",
            "    def get_expected_params_for_user(",
            "        self,",
            "        app: t.Optional[AppType] = None,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "        integration_id: t.Optional[str] = None,",
            "    ) -> IntegrationParams:",
            "        \"\"\"",
            "        This method returns a list of parameters that are suppossed to be",
            "        provided by the user.",
            "        \"\"\"",
            "        # If `integration_id` is provided, use it to fetch the params",
            "        if integration_id is not None:",
            "            response = self._get_expected_params_from_integration_id(id=integration_id)",
            "            if auth_scheme is not None and response[\"auth_scheme\"] != auth_scheme:",
            "                raise ComposioSDKError(",
            "                    message=(",
            "                        \"Auth scheme does not match provided integration ID, \"",
            "                        f\"auth scheme associated with integration ID {response['auth_scheme']} \"",
            "                        f\"auth scheme provided {auth_scheme}\"",
            "                    )",
            "                )",
            "            return response",
            "",
            "        if app is None:",
            "            raise ComposioSDKError(",
            "                message=\"Both `integration_id` and `app` cannot be None\"",
            "            )",
            "",
            "        try:",
            "            # Check if integration is available for an app, and if available",
            "            # return params from that integration",
            "            return self._get_expected_params_from_app(app=app, auth_scheme=auth_scheme)",
            "        except ValueError:",
            "            pass",
            "",
            "        app_data = self.client.apps.get(name=str(app))",
            "        # Go through available schemes and check if any scheme can be used",
            "        # without user inputs to create an integratuib, if yes then create",
            "        # an integration and return params from there.",
            "        for scheme in app_data.auth_schemes or []:",
            "            if auth_scheme is not None and auth_scheme != scheme.auth_mode.upper():",
            "                continue",
            "            if self._can_use_auth_scheme_without_user_input(",
            "                scheme=scheme, app=app_data",
            "            ):",
            "                integration = self.create_integration(",
            "                    app=app,",
            "                    auth_mode=scheme.auth_mode,",
            "                    auth_config={},",
            "                    use_composio_oauth_app=scheme.auth_mode in (\"OAUTH2\", \"OAUTH1\"),",
            "                )",
            "                return {",
            "                    \"integration_id\": integration.id,",
            "                    \"auth_scheme\": integration.authScheme,",
            "                    \"expected_params\": integration.expectedInputFields,",
            "                }",
            "",
            "        raise ComposioSDKError(",
            "            message=(",
            "                f\"No existing integration found for `{str(app)}`, with auth \"",
            "                f\"scheme {auth_scheme} Please create an integration and use the\"",
            "                \" ID to fetch the expected params.\"",
            "            )",
            "        )",
            "",
            "    def fetch_expected_integration_params(",
            "        self,",
            "        app: AppModel,",
            "        auth_scheme: AuthSchemeType,",
            "    ) -> t.List[AuthSchemeField]:",
            "        \"\"\"Fetch expected integration params for creating an integration.\"\"\"",
            "        for scheme in app.auth_schemes or []:",
            "            if auth_scheme != scheme.auth_mode.upper():",
            "                continue",
            "            return [f for f in scheme.fields if not f.expected_from_customer]",
            "        raise ComposioSDKError(",
            "            message=f\"{app.name!r} does not support {auth_scheme!r} auth scheme\"",
            "        )",
            "",
            "    def create_integration(",
            "        self,",
            "        app: AppType,",
            "        auth_mode: t.Optional[AuthSchemeType] = None,",
            "        auth_config: t.Optional[t.Dict[str, t.Any]] = None,",
            "        use_composio_oauth_app: bool = True,",
            "        force_new_integration: bool = False,",
            "    ) -> IntegrationModel:",
            "        app_data = self.client.apps.get(name=str(app))",
            "        timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")",
            "        return self.client.integrations.create(",
            "            app_id=app_data.appId,",
            "            name=f\"{app}_{timestamp}\",",
            "            auth_mode=auth_mode,",
            "            auth_config=auth_config,",
            "            use_composio_auth=use_composio_oauth_app,",
            "            force_new_integration=force_new_integration,",
            "        )",
            "",
            "    def initiate_connection(",
            "        self,",
            "        integration_id: t.Optional[str] = None,",
            "        app: t.Optional[AppType] = None,",
            "        labels: t.Optional[t.List] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        redirect_url: t.Optional[str] = None,",
            "        connected_account_params: t.Optional[t.Dict] = None,",
            "        *,",
            "        auth_scheme: t.Optional[AuthSchemeType] = None,",
            "        auth_config: t.Optional[t.Dict[str, t.Any]] = None,",
            "    ) -> ConnectionRequestModel:",
            "        \"\"\"",
            "        Initiates a connection with the specified integration.",
            "",
            "        If no integration exists for the given app, automatically creates one.",
            "",
            "        :param integration_id: (Optional[str]): ID of the existing integration",
            "        :param app: (Optional[AppType]): App to create/use integration for",
            "        :param redirect_url: (Optional[str]) Redirect URL for the App",
            "        :param auth_scheme: (Optional[AuthSchemeType]): Authentication scheme to use",
            "        :return: (ConnectionRequestModel) Details of the connection request.",
            "        \"\"\"",
            "        if auth_scheme is not None and auth_scheme not in AUTH_SCHEMES:",
            "            raise ComposioSDKError(f\"'auth_scheme' must be one of {AUTH_SCHEMES}\")",
            "",
            "        if integration_id is None:",
            "            if app is None:",
            "                raise ComposioSDKError(",
            "                    message=\"Both `integration_id` and `app` cannot be None\"",
            "                )",
            "",
            "            if auth_scheme is None:",
            "                auth_scheme = self.get_auth_scheme_for_app(app).auth_mode",
            "",
            "            try:",
            "                integration_id = self._get_integration_for_app(",
            "                    app=t.cast(",
            "                        AppType,",
            "                        app,",
            "                    ),",
            "                    auth_scheme=auth_scheme,",
            "                ).id",
            "            except NoItemsFound:",
            "                auth_config, use_composio_auth = self._validate_auth_config(",
            "                    app, auth_scheme, auth_config",
            "                )",
            "                integration = self.create_integration(",
            "                    app=app,",
            "                    auth_mode=auth_scheme,",
            "                    auth_config=auth_config,",
            "                    use_composio_oauth_app=use_composio_auth,",
            "                )",
            "                integration_id = integration.id",
            "",
            "        connected_account_params = connected_account_params or {}",
            "        expected_params = self.get_expected_params_for_user(",
            "            auth_scheme=auth_scheme, integration_id=integration_id",
            "        )[\"expected_params\"]",
            "        required_params = [param for param in expected_params if param.required]",
            "        unavailable_params = [",
            "            param.name",
            "            for param in required_params",
            "            if param.name not in connected_account_params",
            "        ]",
            "        if unavailable_params:",
            "            raise ComposioSDKError(",
            "                f\"Expected 'connected_account_params' to provide these params: {unavailable_params}\"",
            "            )",
            "",
            "        # Populate defaults in the connected_account_params",
            "        for param in expected_params:",
            "            if param.default is not None and param.name not in connected_account_params:",
            "                connected_account_params[param.name] = param.default",
            "",
            "        return self.client.connected_accounts.initiate(",
            "            integration_id=integration_id,",
            "            entity_id=entity_id or self.entity_id,",
            "            params=connected_account_params,",
            "            labels=labels,",
            "            redirect_url=redirect_url,",
            "        )",
            "",
            "    def _validate_auth_config(",
            "        self,",
            "        app: AppType,",
            "        auth_scheme: AuthSchemeType,",
            "        auth_config: t.Optional[t.Dict[str, t.Any]],",
            "    ) -> t.Tuple[t.Optional[t.Dict[str, t.Any]], bool]:",
            "        app_data = self.client.apps.get(name=str(app))",
            "        if auth_config is None and app_data.testConnectors:",
            "            # If we have connectors, can fallback to composio's own auth",
            "            return None, True",
            "",
            "        if auth_config is None:",
            "            auth_config = {}",
            "",
            "        auth_fields = self.fetch_expected_integration_params(",
            "            app=app_data, auth_scheme=auth_scheme",
            "        )",
            "        required_fields = [field for field in auth_fields if field.required]",
            "        unavailable_fields = [",
            "            field.name for field in required_fields if field.name not in auth_config",
            "        ]",
            "        if unavailable_fields:",
            "            raise ComposioSDKError(",
            "                f\"Expected 'auth_config' to provide these fields: {unavailable_fields}\"",
            "            ) from None",
            "",
            "        # Populate defaults in the auth_config",
            "        for field in auth_fields:",
            "            if field.default is not None and field.name not in auth_config:",
            "                auth_config[field.name] = field.default",
            "",
            "        return auth_config, False",
            "",
            "",
            "def _write_file(file_path: t.Union[str, os.PathLike], content: t.Union[str, bytes]):",
            "    \"\"\"Write content to a file.\"\"\"",
            "    if isinstance(content, str):",
            "        with open(file_path, \"w\", encoding=\"utf-8\") as file:",
            "            file.write(content)",
            "    else:",
            "        with open(file_path, \"wb\") as file:",
            "            file.write(content)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.composio.tools.toolset._record_action_if_available.func",
            "python.composio.tools.toolset.ComposioToolSet.execute_action.failed_responses",
            "python.composio.tools.toolset.ComposioToolSet",
            "python.composio.tools.toolset.ComposioToolSet.self",
            "python.composio.tools.toolset.ComposioToolSet.get_agent_instructions",
            "python.composio.tools.toolset.ComposioToolSet._processors",
            "python.composio.tools.toolset.ComposioToolSet._custom_auth",
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    },
    "python/examples/miscellaneous/runtime_tools/langchain_math.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from langchain.agents import AgentExecutor, create_openai_functions_agent"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from langchain_openai import ChatOpenAI"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " @action(toolname=\"math\", requires=[\"smtplib\"])"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " def multiply(a: int, b: int, c: int) -> int:"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "# Initialise imports",
            "# Import from composio_langchain",
            "from composio_langchain import Action, App, ComposioToolSet",
            "from composio import action",
            "from langchain import hub",
            "from langchain.agents import AgentExecutor, create_openai_functions_agent",
            "from langchain_openai import ChatOpenAI",
            "",
            "@action(toolname=\"math\", requires=[\"smtplib\"])",
            "def multiply(a: int, b: int, c: int) -> int:",
            "    \"\"\"",
            "    Multiply three numbers",
            "",
            "    :param a: Number a",
            "    :param b: Number b",
            "    :param c: Number c",
            "    :return result: Result of the multiplication",
            "    \"\"\"",
            "    return a * b * c",
            "",
            "",
            "llm = ChatOpenAI(model=\"gpt-4-turbo\")",
            "",
            "prompt = hub.pull(\"hwchase17/openai-functions-agent\")",
            "",
            "# Get All the tools",
            "tools = ComposioToolSet().get_tools(actions=[multiply])",
            "task = \"Calculate the formula 445*669*8886\"",
            "",
            "agent = create_openai_functions_agent(llm, tools, prompt)",
            "agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)",
            "",
            "# Execute using agent_executor",
            "agent_executor.invoke({\"input\": task})"
        ],
        "afterPatchFile": [
            "# Initialise imports",
            "# Import from composio_langchain",
            "from composio_langchain import Action, App, ComposioToolSet",
            "from composio import action",
            "from langchain import hub",
            "from langchain.agents import AgentExecutor, create_openai_functions_agent",
            "from langchain_openai import ChatOpenAI",
            "",
            "",
            "@action(toolname=\"math\", requires=[\"smtplib\"])",
            "def multiply(a: int, b: int, c: int) -> int:",
            "    \"\"\"",
            "    Multiply three numbers",
            "",
            "    :param a: Number a",
            "    :param b: Number b",
            "    :param c: Number c",
            "    :return result: Result of the multiplication",
            "    \"\"\"",
            "    return a * b * c",
            "",
            "",
            "llm = ChatOpenAI(model=\"gpt-4-turbo\")",
            "",
            "prompt = hub.pull(\"hwchase17/openai-functions-agent\")",
            "",
            "# Get All the tools",
            "tools = ComposioToolSet().get_tools(actions=[multiply])",
            "task = \"Calculate the formula 445*669*8886\"",
            "",
            "agent = create_openai_functions_agent(llm, tools, prompt)",
            "agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)",
            "",
            "# Execute using agent_executor",
            "agent_executor.invoke({\"input\": task})"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "python/plugins/autogen/composio_autogen/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         self,\r"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         caller: ConversableAgent,\r"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         executor: ConversableAgent,\r"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        apps: t.Optional[t.Sequence[AppType]] = None,\r"
            },
            "4": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         actions: t.Optional[t.Sequence[ActionType]] = None,\r"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        apps: t.Optional[t.Sequence[AppType]] = None,\r"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         tags: t.Optional[t.List[TagType]] = None,\r"
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         entity_id: t.Optional[str] = None,\r"
            },
            "8": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     ) -> None:\r"
            }
        },
        "frontPatchFile": [
            "import hashlib\r",
            "import types\r",
            "import typing as t\r",
            "from inspect import Signature\r",
            "\r",
            "import autogen\r",
            "import typing_extensions as te\r",
            "from autogen.agentchat.conversable_agent import ConversableAgent\r",
            "\r",
            "from composio import Action, ActionType, AppType, TagType\r",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet\r",
            "from composio.utils.shared import get_signature_format_from_schema_params\r",
            "\r",
            "\r",
            "class ComposioToolSet(\r",
            "    BaseComposioToolSet,\r",
            "    runtime=\"autogen\",\r",
            "    description_char_limit=1024,\r",
            "    action_name_char_limit=64,\r",
            "):\r",
            "    \"\"\"\r",
            "    Composio toolset for autogen framework.\r",
            "    \"\"\"\r",
            "\r",
            "    def register_tools(\r",
            "        self,\r",
            "        caller: ConversableAgent,\r",
            "        executor: ConversableAgent,\r",
            "        apps: t.Optional[t.Sequence[AppType]] = None,\r",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,\r",
            "        tags: t.Optional[t.List[TagType]] = None,\r",
            "        entity_id: t.Optional[str] = None,\r",
            "    ) -> None:\r",
            "        \"\"\"\r",
            "        Register tools to the proxy agents.\r",
            "\r",
            "        :param executor: Executor agent.\r",
            "        :param caller: Caller agent.\r",
            "        :param apps: List of apps to wrap\r",
            "        :param actions: List of actions to wrap\r",
            "        :param tags: Filter the apps by given tags\r",
            "        :param entity_id: Entity ID for the function wrapper\r",
            "        :param entity_id: Entity ID to use for executing function calls.\r",
            "        \"\"\"\r",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)\r",
            "        schemas = self.get_action_schemas(actions=actions, apps=apps, tags=tags)\r",
            "        for schema in schemas:\r",
            "            self._register_schema_to_autogen(\r",
            "                schema=schema.model_dump(\r",
            "                    exclude_defaults=True,\r",
            "                    exclude_none=True,\r",
            "                    exclude_unset=True,\r",
            "                ),\r",
            "                caller=caller,\r",
            "                executor=executor,\r",
            "                entity_id=entity_id or self.entity_id,\r",
            "            )\r",
            "\r",
            "    @te.deprecated(\"Use `ComposioToolSet.register_tools` instead\")\r",
            "    def register_actions(\r",
            "        self,\r",
            "        caller: ConversableAgent,\r",
            "        executor: ConversableAgent,\r",
            "        actions: t.Sequence[ActionType],\r",
            "        entity_id: t.Optional[str] = None,\r",
            "    ):\r",
            "        \"\"\"\r",
            "        Register tools to the proxy agents.\r",
            "\r",
            "        :param actions: List of tools to register.\r",
            "        :param caller: Caller agent.\r",
            "        :param executor: Executor agent.\r",
            "        :param entity_id: Entity ID to use for executing function calls.\r",
            "        \"\"\"\r",
            "        self.register_tools(\r",
            "            caller=caller,\r",
            "            executor=executor,\r",
            "            actions=actions,\r",
            "            entity_id=entity_id,\r",
            "        )\r",
            "\r",
            "    def _process_function_name_for_registration(\r",
            "        self,\r",
            "        input_string: str,\r",
            "        max_allowed_length: int = 64,\r",
            "        num_hash_char: int = 10,\r",
            "    ):\r",
            "        \"\"\"\r",
            "        Process function name for proxy registration under given character length limitation.\r",
            "        \"\"\"\r",
            "        hash_hex = hashlib.sha256(input_string.encode(encoding=\"utf-8\")).hexdigest()\r",
            "        hash_chars_to_attach = hash_hex[:10]\r",
            "        num_input_str_char = max_allowed_length - (num_hash_char + 1)\r",
            "        input_str_to_attach = input_string[-num_input_str_char:]\r",
            "        processed_name = input_str_to_attach + \"_\" + hash_chars_to_attach\r",
            "        return processed_name\r",
            "\r",
            "    def _register_schema_to_autogen(\r",
            "        self,\r",
            "        schema: t.Dict,\r",
            "        caller: ConversableAgent,\r",
            "        executor: ConversableAgent,\r",
            "        entity_id: t.Optional[str] = None,\r",
            "    ) -> None:\r",
            "        \"\"\"\r",
            "        Register a schema to the Autogen registry.\r",
            "\r",
            "        Args:\r",
            "            schema (dict[str, any]): The action schema to be registered.\r",
            "            caller (ConversableAgent): The agent responsible for initiating the tool registration.\r",
            "            executor (ConversableAgent): The agent responsible for executing the registered tools.\r",
            "            entity_id (str, optional): The identifier of the entity for which the action is executed. Defaults to None.\r",
            "        \"\"\"\r",
            "        name = schema[\"name\"]\r",
            "        appName = schema[\"appName\"]\r",
            "        description = schema[\"description\"]\r",
            "\r",
            "        def execute_action(**kwargs: t.Any) -> t.Dict:\r",
            "            \"\"\"Placeholder function for executing action.\"\"\"\r",
            "            return self.execute_action(\r",
            "                action=Action(value=name),\r",
            "                params=kwargs,\r",
            "                entity_id=entity_id or self.entity_id,\r",
            "            )\r",
            "\r",
            "        function = types.FunctionType(\r",
            "            code=execute_action.__code__,\r",
            "            globals=globals(),\r",
            "            name=self._process_function_name_for_registration(\r",
            "                input_string=name,\r",
            "            ),\r",
            "            closure=execute_action.__closure__,\r",
            "        )\r",
            "        function.__signature__ = Signature(  # type: ignore\r",
            "            parameters=get_signature_format_from_schema_params(\r",
            "                schema_params=schema[\"parameters\"],\r",
            "            ),\r",
            "        )\r",
            "        function.__doc__ = (\r",
            "            description if description else f\"Action {name} from {appName}\"\r",
            "        )\r",
            "        autogen.agentchat.register_function(\r",
            "            function,\r",
            "            caller=caller,\r",
            "            executor=executor,\r",
            "            name=self._process_function_name_for_registration(\r",
            "                input_string=name,\r",
            "            ),\r",
            "            description=description if description else f\"Action {name} from {appName}\",\r",
            "        )\r"
        ],
        "afterPatchFile": [
            "import hashlib\r",
            "import types\r",
            "import typing as t\r",
            "from inspect import Signature\r",
            "\r",
            "import autogen\r",
            "import typing_extensions as te\r",
            "from autogen.agentchat.conversable_agent import ConversableAgent\r",
            "\r",
            "from composio import Action, ActionType, AppType, TagType\r",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet\r",
            "from composio.utils.shared import get_signature_format_from_schema_params\r",
            "\r",
            "\r",
            "class ComposioToolSet(\r",
            "    BaseComposioToolSet,\r",
            "    runtime=\"autogen\",\r",
            "    description_char_limit=1024,\r",
            "    action_name_char_limit=64,\r",
            "):\r",
            "    \"\"\"\r",
            "    Composio toolset for autogen framework.\r",
            "    \"\"\"\r",
            "\r",
            "    def register_tools(\r",
            "        self,\r",
            "        caller: ConversableAgent,\r",
            "        executor: ConversableAgent,\r",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,\r",
            "        apps: t.Optional[t.Sequence[AppType]] = None,\r",
            "        tags: t.Optional[t.List[TagType]] = None,\r",
            "        entity_id: t.Optional[str] = None,\r",
            "    ) -> None:\r",
            "        \"\"\"\r",
            "        Register tools to the proxy agents.\r",
            "\r",
            "        :param executor: Executor agent.\r",
            "        :param caller: Caller agent.\r",
            "        :param apps: List of apps to wrap\r",
            "        :param actions: List of actions to wrap\r",
            "        :param tags: Filter the apps by given tags\r",
            "        :param entity_id: Entity ID for the function wrapper\r",
            "        :param entity_id: Entity ID to use for executing function calls.\r",
            "        \"\"\"\r",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)\r",
            "        schemas = self.get_action_schemas(actions=actions, apps=apps, tags=tags)\r",
            "        for schema in schemas:\r",
            "            self._register_schema_to_autogen(\r",
            "                schema=schema.model_dump(\r",
            "                    exclude_defaults=True,\r",
            "                    exclude_none=True,\r",
            "                    exclude_unset=True,\r",
            "                ),\r",
            "                caller=caller,\r",
            "                executor=executor,\r",
            "                entity_id=entity_id or self.entity_id,\r",
            "            )\r",
            "\r",
            "    @te.deprecated(\"Use `ComposioToolSet.register_tools` instead\")\r",
            "    def register_actions(\r",
            "        self,\r",
            "        caller: ConversableAgent,\r",
            "        executor: ConversableAgent,\r",
            "        actions: t.Sequence[ActionType],\r",
            "        entity_id: t.Optional[str] = None,\r",
            "    ):\r",
            "        \"\"\"\r",
            "        Register tools to the proxy agents.\r",
            "\r",
            "        :param actions: List of tools to register.\r",
            "        :param caller: Caller agent.\r",
            "        :param executor: Executor agent.\r",
            "        :param entity_id: Entity ID to use for executing function calls.\r",
            "        \"\"\"\r",
            "        self.register_tools(\r",
            "            caller=caller,\r",
            "            executor=executor,\r",
            "            actions=actions,\r",
            "            entity_id=entity_id,\r",
            "        )\r",
            "\r",
            "    def _process_function_name_for_registration(\r",
            "        self,\r",
            "        input_string: str,\r",
            "        max_allowed_length: int = 64,\r",
            "        num_hash_char: int = 10,\r",
            "    ):\r",
            "        \"\"\"\r",
            "        Process function name for proxy registration under given character length limitation.\r",
            "        \"\"\"\r",
            "        hash_hex = hashlib.sha256(input_string.encode(encoding=\"utf-8\")).hexdigest()\r",
            "        hash_chars_to_attach = hash_hex[:10]\r",
            "        num_input_str_char = max_allowed_length - (num_hash_char + 1)\r",
            "        input_str_to_attach = input_string[-num_input_str_char:]\r",
            "        processed_name = input_str_to_attach + \"_\" + hash_chars_to_attach\r",
            "        return processed_name\r",
            "\r",
            "    def _register_schema_to_autogen(\r",
            "        self,\r",
            "        schema: t.Dict,\r",
            "        caller: ConversableAgent,\r",
            "        executor: ConversableAgent,\r",
            "        entity_id: t.Optional[str] = None,\r",
            "    ) -> None:\r",
            "        \"\"\"\r",
            "        Register a schema to the Autogen registry.\r",
            "\r",
            "        Args:\r",
            "            schema (dict[str, any]): The action schema to be registered.\r",
            "            caller (ConversableAgent): The agent responsible for initiating the tool registration.\r",
            "            executor (ConversableAgent): The agent responsible for executing the registered tools.\r",
            "            entity_id (str, optional): The identifier of the entity for which the action is executed. Defaults to None.\r",
            "        \"\"\"\r",
            "        name = schema[\"name\"]\r",
            "        appName = schema[\"appName\"]\r",
            "        description = schema[\"description\"]\r",
            "\r",
            "        def execute_action(**kwargs: t.Any) -> t.Dict:\r",
            "            \"\"\"Placeholder function for executing action.\"\"\"\r",
            "            return self.execute_action(\r",
            "                action=Action(value=name),\r",
            "                params=kwargs,\r",
            "                entity_id=entity_id or self.entity_id,\r",
            "            )\r",
            "\r",
            "        function = types.FunctionType(\r",
            "            code=execute_action.__code__,\r",
            "            globals=globals(),\r",
            "            name=self._process_function_name_for_registration(\r",
            "                input_string=name,\r",
            "            ),\r",
            "            closure=execute_action.__closure__,\r",
            "        )\r",
            "        function.__signature__ = Signature(  # type: ignore\r",
            "            parameters=get_signature_format_from_schema_params(\r",
            "                schema_params=schema[\"parameters\"],\r",
            "            ),\r",
            "        )\r",
            "        function.__doc__ = (\r",
            "            description if description else f\"Action {name} from {appName}\"\r",
            "        )\r",
            "        autogen.agentchat.register_function(\r",
            "            function,\r",
            "            caller=caller,\r",
            "            executor=executor,\r",
            "            name=self._process_function_name_for_registration(\r",
            "                input_string=name,\r",
            "            ),\r",
            "            description=description if description else f\"Action {name} from {appName}\",\r",
            "        )\r"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "29": [
                "ComposioToolSet",
                "register_tools"
            ]
        },
        "addLocation": []
    },
    "python/plugins/camel/composio_camel/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         ]"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Camel tool spec.",
            "\"\"\"",
            "",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "",
            "# pylint: disable=E0611",
            "from camel.toolkits import OpenAIFunction",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.constants import DEFAULT_ENTITY_ID",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.schema import OpenAISchema, SchemaType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "# pylint: enable=E0611",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"camel\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for OpenAI framework.",
            "",
            "    Example:",
            "    ```python",
            "        from colorama import Fore",
            "",
            "        from camel.agents import ChatAgent",
            "        from camel.configs import ChatGPTConfig",
            "        from camel.messages import BaseMessage",
            "        from camel.models import ModelFactory",
            "        from camel.types import ModelPlatformType, ModelType",
            "        from camel.utils import print_text_animated",
            "        from composio_camel import ComposioToolSet, Action",
            "",
            "        composio_toolset = ComposioToolSet()",
            "        tools = composio_toolset.get_actions(",
            "            actions=[Action.GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER]",
            "        )",
            "",
            "        # set up LLM model",
            "        assistant_model_config = ChatGPTConfig(",
            "            temperature=0.0,",
            "            tools=tools,",
            "        )",
            "",
            "        model = ModelFactory.create(",
            "            model_platform=ModelPlatformType.OPENAI,",
            "            model_type=ModelType.GPT_3_5_TURBO,",
            "            model_config_dict=assistant_model_config.__dict__,",
            "        )",
            "",
            "",
            "        # set up agent",
            "        assistant_sys_msg = BaseMessage.make_assistant_message(",
            "            role_name=\"Developer\",",
            "            content=(",
            "                \"You are a programmer as well an experienced github user. \"",
            "                \"When asked given a instruction, \"",
            "                \"you try to use available tools, and execute it\"",
            "            ),",
            "        )",
            "",
            "        agent = ChatAgent(",
            "            assistant_sys_msg,",
            "            model,",
            "            tools=tools,",
            "        )",
            "        agent.reset()",
            "",
            "",
            "        # set up agent",
            "",
            "        prompt = (",
            "            \"I have created a new Github Repo,\"",
            "            \"Please star my github repository: camel-ai/camel\"",
            "        )",
            "        user_msg = BaseMessage.make_user_message(role_name=\"User\", content=prompt)",
            "        print(Fore.YELLOW + f\"user prompt:\\n{prompt}\\n\")",
            "",
            "        response = agent.step(user_msg)",
            "        for msg in response.msgs:",
            "            print_text_animated(Fore.GREEN + f\"Agent response:\\n{msg.content}\\n\")",
            "    ```",
            "    \"\"\"",
            "",
            "    schema = SchemaType.OPENAI",
            "",
            "    def validate_entity_id(self, entity_id: str) -> str:",
            "        \"\"\"Validate entity ID.\"\"\"",
            "        if (",
            "            self.entity_id != DEFAULT_ENTITY_ID",
            "            and entity_id != DEFAULT_ENTITY_ID",
            "            and self.entity_id != entity_id",
            "        ):",
            "            raise ValueError(",
            "                \"Separate `entity_id` can not be provided during \"",
            "                \"initialization and handling tool calls\"",
            "            )",
            "        if self.entity_id != DEFAULT_ENTITY_ID:",
            "            entity_id = self.entity_id",
            "        return entity_id",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> OpenAIFunction:",
            "        \"\"\"",
            "        Wrap composio tool as Camel `OpenAIFunction` object.",
            "        \"\"\"",
            "        name = schema[\"function\"][\"name\"]",
            "",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Composio tool wrapped as camel's OpenAIFunction.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=name),",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        return OpenAIFunction(",
            "            func=function,",
            "            openai_tool_schema=schema,",
            "        )",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[OpenAIFunction]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Camel `OpenAIFunction` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `OpenAIFunction` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[OpenAIFunction]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Camel `OpenAIFunction` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `OpenAIFunction` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(  # type: ignore",
            "                t.cast(",
            "                    OpenAISchema,",
            "                    self.schema.format(",
            "                        schema.model_dump(",
            "                            exclude_none=True,",
            "                        ),",
            "                    ),",
            "                ).model_dump(),",
            "                entity_id=entity_id,",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Camel tool spec.",
            "\"\"\"",
            "",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "",
            "# pylint: disable=E0611",
            "from camel.toolkits import OpenAIFunction",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.constants import DEFAULT_ENTITY_ID",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.schema import OpenAISchema, SchemaType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "# pylint: enable=E0611",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"camel\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for OpenAI framework.",
            "",
            "    Example:",
            "    ```python",
            "        from colorama import Fore",
            "",
            "        from camel.agents import ChatAgent",
            "        from camel.configs import ChatGPTConfig",
            "        from camel.messages import BaseMessage",
            "        from camel.models import ModelFactory",
            "        from camel.types import ModelPlatformType, ModelType",
            "        from camel.utils import print_text_animated",
            "        from composio_camel import ComposioToolSet, Action",
            "",
            "        composio_toolset = ComposioToolSet()",
            "        tools = composio_toolset.get_actions(",
            "            actions=[Action.GITHUB_STAR_A_REPOSITORY_FOR_THE_AUTHENTICATED_USER]",
            "        )",
            "",
            "        # set up LLM model",
            "        assistant_model_config = ChatGPTConfig(",
            "            temperature=0.0,",
            "            tools=tools,",
            "        )",
            "",
            "        model = ModelFactory.create(",
            "            model_platform=ModelPlatformType.OPENAI,",
            "            model_type=ModelType.GPT_3_5_TURBO,",
            "            model_config_dict=assistant_model_config.__dict__,",
            "        )",
            "",
            "",
            "        # set up agent",
            "        assistant_sys_msg = BaseMessage.make_assistant_message(",
            "            role_name=\"Developer\",",
            "            content=(",
            "                \"You are a programmer as well an experienced github user. \"",
            "                \"When asked given a instruction, \"",
            "                \"you try to use available tools, and execute it\"",
            "            ),",
            "        )",
            "",
            "        agent = ChatAgent(",
            "            assistant_sys_msg,",
            "            model,",
            "            tools=tools,",
            "        )",
            "        agent.reset()",
            "",
            "",
            "        # set up agent",
            "",
            "        prompt = (",
            "            \"I have created a new Github Repo,\"",
            "            \"Please star my github repository: camel-ai/camel\"",
            "        )",
            "        user_msg = BaseMessage.make_user_message(role_name=\"User\", content=prompt)",
            "        print(Fore.YELLOW + f\"user prompt:\\n{prompt}\\n\")",
            "",
            "        response = agent.step(user_msg)",
            "        for msg in response.msgs:",
            "            print_text_animated(Fore.GREEN + f\"Agent response:\\n{msg.content}\\n\")",
            "    ```",
            "    \"\"\"",
            "",
            "    schema = SchemaType.OPENAI",
            "",
            "    def validate_entity_id(self, entity_id: str) -> str:",
            "        \"\"\"Validate entity ID.\"\"\"",
            "        if (",
            "            self.entity_id != DEFAULT_ENTITY_ID",
            "            and entity_id != DEFAULT_ENTITY_ID",
            "            and self.entity_id != entity_id",
            "        ):",
            "            raise ValueError(",
            "                \"Separate `entity_id` can not be provided during \"",
            "                \"initialization and handling tool calls\"",
            "            )",
            "        if self.entity_id != DEFAULT_ENTITY_ID:",
            "            entity_id = self.entity_id",
            "        return entity_id",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> OpenAIFunction:",
            "        \"\"\"",
            "        Wrap composio tool as Camel `OpenAIFunction` object.",
            "        \"\"\"",
            "        name = schema[\"function\"][\"name\"]",
            "",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Composio tool wrapped as camel's OpenAIFunction.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=name),",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        return OpenAIFunction(",
            "            func=function,",
            "            openai_tool_schema=schema,",
            "        )",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[OpenAIFunction]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Camel `OpenAIFunction` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `OpenAIFunction` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[OpenAIFunction]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Camel `OpenAIFunction` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `OpenAIFunction` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(  # type: ignore",
            "                t.cast(",
            "                    OpenAISchema,",
            "                    self.schema.format(",
            "                        schema.model_dump(",
            "                            exclude_none=True,",
            "                        ),",
            "                    ),",
            "                ).model_dump(),",
            "                entity_id=entity_id,",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs",
            "python.plugins.camel.composio_camel.toolset.ComposioToolSet.get_actions"
        ]
    },
    "python/plugins/claude/composio_claude/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         ]"
            },
            "6": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import typing as t",
            "",
            "import typing_extensions as te",
            "",
            "",
            "try:",
            "    from anthropic.types.beta.tools import ToolUseBlock, ToolsBetaMessage",
            "    from anthropic.types.beta.tools.tool_param import ToolParam",
            "",
            "    class BetaToolUseBlock:  # type: ignore",
            "        pass",
            "",
            "except ModuleNotFoundError:",
            "    from anthropic.types.tool_use_block import ToolUseBlock",
            "    from anthropic.types.tool_param import ToolParam",
            "    from anthropic.types.message import Message as ToolsBetaMessage",
            "    from anthropic.types.beta.beta_tool_use_block import BetaToolUseBlock  # type: ignore",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.constants import DEFAULT_ENTITY_ID",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.schema import ClaudeSchema, SchemaType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"claude\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Anthropic Claude platform.",
            "",
            "    Example:",
            "    ```python",
            "        import anthropic",
            "        import dotenv",
            "        from composio_claude import App, ComposioToolSet",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize tools.",
            "        claude_client = anthropic.Anthropic()",
            "        composio_tools = ComposioToolSet()",
            "",
            "        # Define task.",
            "        task = \"Star a repo composiohq/composio on GitHub\"",
            "",
            "        # Get GitHub tools that are pre-configured",
            "        actions = composio_toolset.get_tools(tools=[App.GITHUB])",
            "",
            "        # Get response from the LLM",
            "        response = claude_client.beta.tools.messages.create(",
            "            model=\"claude-3-opus-20240229\",",
            "            max_tokens=1024,",
            "            tools=composio_tools,",
            "            messages=[",
            "                {\"role\": \"user\", \"content\": \"Star me composiohq/composio repo in github.\"},",
            "            ],",
            "        )",
            "        print(response)",
            "",
            "        # Execute the function calls.",
            "        result = composio_tools.handle_calls(response)",
            "        print(result)",
            "    ```",
            "    \"\"\"",
            "",
            "    schema = SchemaType.CLAUDE",
            "",
            "    def validate_entity_id(self, entity_id: str) -> str:",
            "        \"\"\"Validate entity ID.\"\"\"",
            "        if (",
            "            self.entity_id != DEFAULT_ENTITY_ID",
            "            and entity_id != DEFAULT_ENTITY_ID",
            "            and self.entity_id != entity_id",
            "        ):",
            "            raise ValueError(",
            "                \"separate `entity_id` can not be provided during \"",
            "                \"initialization and handelling tool calls\"",
            "            )",
            "        if self.entity_id != DEFAULT_ENTITY_ID:",
            "            entity_id = self.entity_id",
            "        return entity_id",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(self, actions: t.Sequence[ActionType]) -> t.List[ToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as `ToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :return: Composio tools wrapped as `ToolParam` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[ToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            ToolParam(",
            "                **t.cast(",
            "                    ClaudeSchema,",
            "                    self.schema.format(",
            "                        schema.model_dump(",
            "                            exclude_none=True,",
            "                        )",
            "                    ),",
            "                ).model_dump()",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]",
            "",
            "    def execute_tool_call(",
            "        self,",
            "        tool_call: ToolUseBlock,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute a tool call.",
            "",
            "        :param tool_call: Tool call metadata.",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: Object containing output data from the tool call.",
            "        \"\"\"",
            "        return self.execute_action(",
            "            action=Action(value=tool_call.name),",
            "            params=t.cast(t.Dict, tool_call.input),",
            "            entity_id=entity_id or self.entity_id,",
            "        )",
            "",
            "    def handle_tool_calls(",
            "        self,",
            "        llm_response: ToolsBetaMessage,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[t.Dict]:",
            "        \"\"\"",
            "        Handle tool calls from OpenAI chat completion object.",
            "",
            "        :param response: Chat completion object from",
            "                        openai.OpenAI.chat.completions.create function call",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: A list of output objects from the function calls.",
            "        \"\"\"",
            "        outputs = []",
            "        entity_id = self.validate_entity_id(entity_id or self.entity_id)",
            "        for content in llm_response.content:",
            "            if isinstance(content, (ToolUseBlock, BetaToolUseBlock)):",
            "                outputs.append(",
            "                    self.execute_tool_call(",
            "                        tool_call=content,",
            "                        entity_id=entity_id or self.entity_id,",
            "                    )",
            "                )",
            "        return outputs"
        ],
        "afterPatchFile": [
            "import typing as t",
            "",
            "import typing_extensions as te",
            "",
            "",
            "try:",
            "    from anthropic.types.beta.tools import ToolUseBlock, ToolsBetaMessage",
            "    from anthropic.types.beta.tools.tool_param import ToolParam",
            "",
            "    class BetaToolUseBlock:  # type: ignore",
            "        pass",
            "",
            "except ModuleNotFoundError:",
            "    from anthropic.types.tool_use_block import ToolUseBlock",
            "    from anthropic.types.tool_param import ToolParam",
            "    from anthropic.types.message import Message as ToolsBetaMessage",
            "    from anthropic.types.beta.beta_tool_use_block import BetaToolUseBlock  # type: ignore",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.constants import DEFAULT_ENTITY_ID",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.schema import ClaudeSchema, SchemaType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"claude\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Anthropic Claude platform.",
            "",
            "    Example:",
            "    ```python",
            "        import anthropic",
            "        import dotenv",
            "        from composio_claude import App, ComposioToolSet",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize tools.",
            "        claude_client = anthropic.Anthropic()",
            "        composio_tools = ComposioToolSet()",
            "",
            "        # Define task.",
            "        task = \"Star a repo composiohq/composio on GitHub\"",
            "",
            "        # Get GitHub tools that are pre-configured",
            "        actions = composio_toolset.get_tools(tools=[App.GITHUB])",
            "",
            "        # Get response from the LLM",
            "        response = claude_client.beta.tools.messages.create(",
            "            model=\"claude-3-opus-20240229\",",
            "            max_tokens=1024,",
            "            tools=composio_tools,",
            "            messages=[",
            "                {\"role\": \"user\", \"content\": \"Star me composiohq/composio repo in github.\"},",
            "            ],",
            "        )",
            "        print(response)",
            "",
            "        # Execute the function calls.",
            "        result = composio_tools.handle_calls(response)",
            "        print(result)",
            "    ```",
            "    \"\"\"",
            "",
            "    schema = SchemaType.CLAUDE",
            "",
            "    def validate_entity_id(self, entity_id: str) -> str:",
            "        \"\"\"Validate entity ID.\"\"\"",
            "        if (",
            "            self.entity_id != DEFAULT_ENTITY_ID",
            "            and entity_id != DEFAULT_ENTITY_ID",
            "            and self.entity_id != entity_id",
            "        ):",
            "            raise ValueError(",
            "                \"separate `entity_id` can not be provided during \"",
            "                \"initialization and handelling tool calls\"",
            "            )",
            "        if self.entity_id != DEFAULT_ENTITY_ID:",
            "            entity_id = self.entity_id",
            "        return entity_id",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(self, actions: t.Sequence[ActionType]) -> t.List[ToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as `ToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :return: Composio tools wrapped as `ToolParam` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[ToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            ToolParam(",
            "                **t.cast(",
            "                    ClaudeSchema,",
            "                    self.schema.format(",
            "                        schema.model_dump(",
            "                            exclude_none=True,",
            "                        )",
            "                    ),",
            "                ).model_dump()",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]",
            "",
            "    def execute_tool_call(",
            "        self,",
            "        tool_call: ToolUseBlock,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute a tool call.",
            "",
            "        :param tool_call: Tool call metadata.",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: Object containing output data from the tool call.",
            "        \"\"\"",
            "        return self.execute_action(",
            "            action=Action(value=tool_call.name),",
            "            params=t.cast(t.Dict, tool_call.input),",
            "            entity_id=entity_id or self.entity_id,",
            "        )",
            "",
            "    def handle_tool_calls(",
            "        self,",
            "        llm_response: ToolsBetaMessage,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[t.Dict]:",
            "        \"\"\"",
            "        Handle tool calls from OpenAI chat completion object.",
            "",
            "        :param response: Chat completion object from",
            "                        openai.OpenAI.chat.completions.create function call",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: A list of output objects from the function calls.",
            "        \"\"\"",
            "        outputs = []",
            "        entity_id = self.validate_entity_id(entity_id or self.entity_id)",
            "        for content in llm_response.content:",
            "            if isinstance(content, (ToolUseBlock, BetaToolUseBlock)):",
            "                outputs.append(",
            "                    self.execute_tool_call(",
            "                        tool_call=content,",
            "                        entity_id=entity_id or self.entity_id,",
            "                    )",
            "                )",
            "        return outputs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs",
            "python.plugins.claude.composio_claude.toolset.ComposioToolSet.get_actions"
        ]
    },
    "python/plugins/crew_ai/composio_crewai/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "                     apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "                     tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "                     check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+                    _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "                 )"
            },
            "5": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "             ]"
            },
            "6": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from crewai import __version__",
            "from semver import Version",
            "",
            "",
            "_BREAKING_VERSION = Version(major=0, minor=79, patch=0)",
            "_CURRENT_VERSION = Version.parse(__version__)",
            "",
            "if _CURRENT_VERSION < _BREAKING_VERSION:",
            "    from composio_langchain import ComposioToolSet as Base",
            "",
            "    class ComposioToolSet(  # type: ignore[no-redef]",
            "        Base,",
            "        runtime=\"crewai\",",
            "        description_char_limit=1024,",
            "        action_name_char_limit=64,",
            "    ):",
            "        pass",
            "",
            "else:",
            "    import typing as t",
            "",
            "    import pydantic",
            "    import pydantic.error_wrappers",
            "    import typing_extensions as te",
            "    from crewai.tools import BaseTool",
            "",
            "    from composio import Action, ActionType, AppType, TagType",
            "    from composio.tools.toolset import ComposioToolSet as BaseComposioToolSet",
            "    from composio.tools.toolset import ProcessorsType",
            "    from composio.utils.pydantic import parse_pydantic_error",
            "    from composio.utils.shared import json_schema_to_model",
            "",
            "    class ComposioToolSet(  # type: ignore[no-redef]",
            "        BaseComposioToolSet,",
            "        runtime=\"crewai\",",
            "        description_char_limit=1024,",
            "        action_name_char_limit=64,",
            "    ):",
            "        \"\"\"",
            "        Composio toolset for CrewiAI framework.",
            "",
            "        Example:",
            "        ```python",
            "        import os",
            "",
            "        import dotenv",
            "        from crewai import Agent, Crew, Task",
            "        from langchain_openai import ChatOpenAI",
            "",
            "        from composio_crewai import Action, App, ComposioToolSet",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize tools.",
            "        openai_client = ChatOpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        # Get All the tools",
            "        tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Define agent",
            "        crewai_agent = Agent(",
            "            role=\"Github Agent\",",
            "            goal=\"You take action on Github using Github APIs\",",
            "            backstory=(",
            "                \"You are AI agent that is responsible for taking actions on Github \"",
            "                \"on users behalf. You need to take action on Github using Github APIs\"",
            "            ),",
            "            verbose=True,",
            "            tools=tools,",
            "            llm=openai_client,",
            "        )",
            "",
            "        # Define task",
            "        task = Task(",
            "            description=\"Star a repo composiohq/composio on GitHub\",",
            "            agent=crewai_agent,",
            "            expected_output=\"if the star happened\",",
            "        )",
            "        my_crew = Crew(agents=[crewai_agent], tasks=[task])",
            "        result = my_crew.kickoff()",
            "        print(result)",
            "        \"\"\"",
            "",
            "        def _wrap_tool(",
            "            self,",
            "            schema: t.Dict[str, t.Any],",
            "            entity_id: t.Optional[str] = None,",
            "        ) -> BaseTool:",
            "            \"\"\"Wraps composio tool as Langchain StructuredTool object.\"\"\"",
            "            action = schema[\"name\"]",
            "            description = schema[\"description\"]",
            "            schema_params = schema[\"parameters\"]",
            "",
            "            def execute(**kwargs: t.Any) -> t.Dict:",
            "                \"\"\"Wrapper function for composio action.\"\"\"",
            "                return self.execute_action(",
            "                    action=Action(value=action),",
            "                    params=kwargs,",
            "                    entity_id=entity_id or self.entity_id,",
            "                )",
            "",
            "            class Wrapper(BaseTool):",
            "",
            "                def _run(self, *args, **kwargs):",
            "                    try:",
            "                        return execute(*args, **kwargs)",
            "                    except pydantic.ValidationError as e:",
            "                        return {",
            "                            \"successful\": False,",
            "                            \"error\": parse_pydantic_error(e),",
            "                            \"data\": None,",
            "                        }",
            "",
            "            return Wrapper(",
            "                name=action,",
            "                description=description,",
            "                args_schema=json_schema_to_model(",
            "                    json_schema=schema_params,",
            "                ),",
            "            )",
            "",
            "        @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "        def get_actions(",
            "            self,",
            "            actions: t.Sequence[ActionType],",
            "            entity_id: t.Optional[str] = None,",
            "        ) -> t.Sequence[BaseTool]:",
            "            \"\"\"",
            "            Get composio tools wrapped as Langchain StructuredTool objects.",
            "",
            "            :param actions: List of actions to wrap",
            "            :param entity_id: Entity ID to use for executing function calls.",
            "",
            "            :return: Composio tools wrapped as `StructuredTool` objects",
            "            \"\"\"",
            "            return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "        def get_tools(",
            "            self,",
            "            actions: t.Optional[t.Sequence[ActionType]] = None,",
            "            apps: t.Optional[t.Sequence[AppType]] = None,",
            "            tags: t.Optional[t.List[TagType]] = None,",
            "            entity_id: t.Optional[str] = None,",
            "            *,",
            "            processors: t.Optional[ProcessorsType] = None,",
            "            check_connected_accounts: bool = True,",
            "        ) -> t.Sequence[BaseTool]:",
            "            \"\"\"",
            "            Get composio tools as Langchain StructuredTool objects.",
            "",
            "            :param actions: List of actions to wrap",
            "            :param apps: List of apps to wrap",
            "            :param tags: Filter the apps by given tags",
            "            :param entity_id: Entity ID for the function wrapper",
            "",
            "            :return: Composio tools as `StructuredTool` objects",
            "            \"\"\"",
            "            self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "            if processors is not None:",
            "                self._merge_processors(processors)",
            "",
            "            tools = [",
            "                self._wrap_tool(",
            "                    schema=tool.model_dump(",
            "                        exclude_none=True,",
            "                    ),",
            "                    entity_id=entity_id or self.entity_id,",
            "                )",
            "                for tool in self.get_action_schemas(",
            "                    actions=actions,",
            "                    apps=apps,",
            "                    tags=tags,",
            "                    check_connected_accounts=check_connected_accounts,",
            "                )",
            "            ]",
            "",
            "            return tools  # Ensure this returns a list of BaseTool instances"
        ],
        "afterPatchFile": [
            "from crewai import __version__",
            "from semver import Version",
            "",
            "",
            "_BREAKING_VERSION = Version(major=0, minor=79, patch=0)",
            "_CURRENT_VERSION = Version.parse(__version__)",
            "",
            "if _CURRENT_VERSION < _BREAKING_VERSION:",
            "    from composio_langchain import ComposioToolSet as Base",
            "",
            "    class ComposioToolSet(  # type: ignore[no-redef]",
            "        Base,",
            "        runtime=\"crewai\",",
            "        description_char_limit=1024,",
            "        action_name_char_limit=64,",
            "    ):",
            "        pass",
            "",
            "else:",
            "    import typing as t",
            "",
            "    import pydantic",
            "    import pydantic.error_wrappers",
            "    import typing_extensions as te",
            "    from crewai.tools import BaseTool",
            "",
            "    from composio import Action, ActionType, AppType, TagType",
            "    from composio.tools.toolset import ComposioToolSet as BaseComposioToolSet",
            "    from composio.tools.toolset import ProcessorsType",
            "    from composio.utils.pydantic import parse_pydantic_error",
            "    from composio.utils.shared import json_schema_to_model",
            "",
            "    class ComposioToolSet(  # type: ignore[no-redef]",
            "        BaseComposioToolSet,",
            "        runtime=\"crewai\",",
            "        description_char_limit=1024,",
            "        action_name_char_limit=64,",
            "    ):",
            "        \"\"\"",
            "        Composio toolset for CrewiAI framework.",
            "",
            "        Example:",
            "        ```python",
            "        import os",
            "",
            "        import dotenv",
            "        from crewai import Agent, Crew, Task",
            "        from langchain_openai import ChatOpenAI",
            "",
            "        from composio_crewai import Action, App, ComposioToolSet",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize tools.",
            "        openai_client = ChatOpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        # Get All the tools",
            "        tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Define agent",
            "        crewai_agent = Agent(",
            "            role=\"Github Agent\",",
            "            goal=\"You take action on Github using Github APIs\",",
            "            backstory=(",
            "                \"You are AI agent that is responsible for taking actions on Github \"",
            "                \"on users behalf. You need to take action on Github using Github APIs\"",
            "            ),",
            "            verbose=True,",
            "            tools=tools,",
            "            llm=openai_client,",
            "        )",
            "",
            "        # Define task",
            "        task = Task(",
            "            description=\"Star a repo composiohq/composio on GitHub\",",
            "            agent=crewai_agent,",
            "            expected_output=\"if the star happened\",",
            "        )",
            "        my_crew = Crew(agents=[crewai_agent], tasks=[task])",
            "        result = my_crew.kickoff()",
            "        print(result)",
            "        \"\"\"",
            "",
            "        def _wrap_tool(",
            "            self,",
            "            schema: t.Dict[str, t.Any],",
            "            entity_id: t.Optional[str] = None,",
            "        ) -> BaseTool:",
            "            \"\"\"Wraps composio tool as Langchain StructuredTool object.\"\"\"",
            "            action = schema[\"name\"]",
            "            description = schema[\"description\"]",
            "            schema_params = schema[\"parameters\"]",
            "",
            "            def execute(**kwargs: t.Any) -> t.Dict:",
            "                \"\"\"Wrapper function for composio action.\"\"\"",
            "                return self.execute_action(",
            "                    action=Action(value=action),",
            "                    params=kwargs,",
            "                    entity_id=entity_id or self.entity_id,",
            "                )",
            "",
            "            class Wrapper(BaseTool):",
            "",
            "                def _run(self, *args, **kwargs):",
            "                    try:",
            "                        return execute(*args, **kwargs)",
            "                    except pydantic.ValidationError as e:",
            "                        return {",
            "                            \"successful\": False,",
            "                            \"error\": parse_pydantic_error(e),",
            "                            \"data\": None,",
            "                        }",
            "",
            "            return Wrapper(",
            "                name=action,",
            "                description=description,",
            "                args_schema=json_schema_to_model(",
            "                    json_schema=schema_params,",
            "                ),",
            "            )",
            "",
            "        @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "        def get_actions(",
            "            self,",
            "            actions: t.Sequence[ActionType],",
            "            entity_id: t.Optional[str] = None,",
            "        ) -> t.Sequence[BaseTool]:",
            "            \"\"\"",
            "            Get composio tools wrapped as Langchain StructuredTool objects.",
            "",
            "            :param actions: List of actions to wrap",
            "            :param entity_id: Entity ID to use for executing function calls.",
            "",
            "            :return: Composio tools wrapped as `StructuredTool` objects",
            "            \"\"\"",
            "            return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "        def get_tools(",
            "            self,",
            "            actions: t.Optional[t.Sequence[ActionType]] = None,",
            "            apps: t.Optional[t.Sequence[AppType]] = None,",
            "            tags: t.Optional[t.List[TagType]] = None,",
            "            entity_id: t.Optional[str] = None,",
            "            *,",
            "            processors: t.Optional[ProcessorsType] = None,",
            "            check_connected_accounts: bool = True,",
            "        ) -> t.Sequence[BaseTool]:",
            "            \"\"\"",
            "            Get composio tools as Langchain StructuredTool objects.",
            "",
            "            :param actions: List of actions to wrap",
            "            :param apps: List of apps to wrap",
            "            :param tags: Filter the apps by given tags",
            "            :param entity_id: Entity ID for the function wrapper",
            "",
            "            :return: Composio tools as `StructuredTool` objects",
            "            \"\"\"",
            "            self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "            if processors is not None:",
            "                self._merge_processors(processors)",
            "",
            "            tools = [",
            "                self._wrap_tool(",
            "                    schema=tool.model_dump(",
            "                        exclude_none=True,",
            "                    ),",
            "                    entity_id=entity_id or self.entity_id,",
            "                )",
            "                for tool in self.get_action_schemas(",
            "                    actions=actions,",
            "                    apps=apps,",
            "                    tags=tags,",
            "                    check_connected_accounts=check_connected_accounts,",
            "                    _populate_requested=True,",
            "                )",
            "            ]",
            "",
            "            return tools  # Ensure this returns a list of BaseTool instances"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "python/plugins/griptape/composio_griptape/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         ]"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "from griptape.tools import BaseTool",
            "from griptape.utils.decorators import activity",
            "from schema import Literal, Schema",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.shared import PYDANTIC_TYPE_TO_PYTHON_TYPE",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"griptape\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset wrapper for Griptape framework.",
            "",
            "    Example:",
            "    ```python",
            "        import dotenv",
            "",
            "        from composio_griptape import App, ComposioToolSet",
            "        from griptape.structures import Agent",
            "        from griptape.utils import Chat",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize Toolset",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        #",
            "        github_tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Initialize agent.",
            "        agent = Agent(tools=github_tools)",
            "",
            "        # Start the agent.",
            "        Chat(agent).start()",
            "    ```",
            "    \"\"\"",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> BaseTool:",
            "        \"\"\"Wrap Composio tool as GripTape `BaseTool` object\"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "",
            "        schema_dict = {}",
            "        for param_name, param_body in schema[\"parameters\"][\"properties\"].items():",
            "            dtype = param_body[\"type\"]",
            "            description = param_body[\"description\"]",
            "            schema_key = Literal(param_name, description=description)",
            "            if dtype in PYDANTIC_TYPE_TO_PYTHON_TYPE:",
            "                schema_dtype = PYDANTIC_TYPE_TO_PYTHON_TYPE.get(dtype)",
            "            elif dtype == \"array\":",
            "                schema_array_dtype = PYDANTIC_TYPE_TO_PYTHON_TYPE.get(",
            "                    param_body[\"items\"].get(\"type\"),",
            "                    None,",
            "                )",
            "                schema_dtype = list[schema_array_dtype] if schema_array_dtype else list  # type: ignore",
            "            else:",
            "                raise TypeError(",
            "                    f\"Some dtype of current schema are not handled yet. Current Schema: {param_body}\"",
            "                )",
            "",
            "            schema_dict[schema_key] = schema_dtype",
            "",
            "        def _execute_task(params: t.Dict) -> t.Dict:",
            "            \"\"\"Placeholder method for executing task.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=name),",
            "                params=params,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        class GripTapeTool(BaseTool):",
            "            \"\"\"",
            "            Griptap tool wrapper for Composio tools.",
            "            \"\"\"",
            "",
            "            @activity(",
            "                config={",
            "                    \"description\": description,",
            "                    \"schema\": Schema(schema=schema_dict),",
            "                }",
            "            )",
            "            def execute_task(self, params: t.Dict) -> t.Dict:",
            "                \"\"\"Executed task.\"\"\"",
            "                return _execute_task(params=params[\"values\"])",
            "",
            "            @property",
            "            def manifest(self) -> t.Dict:",
            "                \"\"\"Tool menifest.\"\"\"",
            "                return {",
            "                    \"version\": \"v1\",",
            "                    \"name\": name,",
            "                    \"description\": description,",
            "                    \"contact_email\": \"hello@composio.dev\",",
            "                    \"legal_info_url\": \"https://www.composio.dev/legal\",",
            "                }",
            "",
            "        name = \"\".join(map(lambda x: x.title(), name.split(\"_\"))) + \"Client\"",
            "        cls = type(name, (GripTapeTool,), {})",
            "        return cls()",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[BaseTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as GripTape `BaseTool` type objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: Composio tools wrapped as `BaseTool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[BaseTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as GripTape `BaseTool` type objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `BaseTool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=tool.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]"
        ],
        "afterPatchFile": [
            "import logging",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "from griptape.tools import BaseTool",
            "from griptape.utils.decorators import activity",
            "from schema import Literal, Schema",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.shared import PYDANTIC_TYPE_TO_PYTHON_TYPE",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"griptape\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset wrapper for Griptape framework.",
            "",
            "    Example:",
            "    ```python",
            "        import dotenv",
            "",
            "        from composio_griptape import App, ComposioToolSet",
            "        from griptape.structures import Agent",
            "        from griptape.utils import Chat",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize Toolset",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        #",
            "        github_tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Initialize agent.",
            "        agent = Agent(tools=github_tools)",
            "",
            "        # Start the agent.",
            "        Chat(agent).start()",
            "    ```",
            "    \"\"\"",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> BaseTool:",
            "        \"\"\"Wrap Composio tool as GripTape `BaseTool` object\"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "",
            "        schema_dict = {}",
            "        for param_name, param_body in schema[\"parameters\"][\"properties\"].items():",
            "            dtype = param_body[\"type\"]",
            "            description = param_body[\"description\"]",
            "            schema_key = Literal(param_name, description=description)",
            "            if dtype in PYDANTIC_TYPE_TO_PYTHON_TYPE:",
            "                schema_dtype = PYDANTIC_TYPE_TO_PYTHON_TYPE.get(dtype)",
            "            elif dtype == \"array\":",
            "                schema_array_dtype = PYDANTIC_TYPE_TO_PYTHON_TYPE.get(",
            "                    param_body[\"items\"].get(\"type\"),",
            "                    None,",
            "                )",
            "                schema_dtype = list[schema_array_dtype] if schema_array_dtype else list  # type: ignore",
            "            else:",
            "                raise TypeError(",
            "                    f\"Some dtype of current schema are not handled yet. Current Schema: {param_body}\"",
            "                )",
            "",
            "            schema_dict[schema_key] = schema_dtype",
            "",
            "        def _execute_task(params: t.Dict) -> t.Dict:",
            "            \"\"\"Placeholder method for executing task.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=name),",
            "                params=params,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        class GripTapeTool(BaseTool):",
            "            \"\"\"",
            "            Griptap tool wrapper for Composio tools.",
            "            \"\"\"",
            "",
            "            @activity(",
            "                config={",
            "                    \"description\": description,",
            "                    \"schema\": Schema(schema=schema_dict),",
            "                }",
            "            )",
            "            def execute_task(self, params: t.Dict) -> t.Dict:",
            "                \"\"\"Executed task.\"\"\"",
            "                return _execute_task(params=params[\"values\"])",
            "",
            "            @property",
            "            def manifest(self) -> t.Dict:",
            "                \"\"\"Tool menifest.\"\"\"",
            "                return {",
            "                    \"version\": \"v1\",",
            "                    \"name\": name,",
            "                    \"description\": description,",
            "                    \"contact_email\": \"hello@composio.dev\",",
            "                    \"legal_info_url\": \"https://www.composio.dev/legal\",",
            "                }",
            "",
            "        name = \"\".join(map(lambda x: x.title(), name.split(\"_\"))) + \"Client\"",
            "        cls = type(name, (GripTapeTool,), {})",
            "        return cls()",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[BaseTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as GripTape `BaseTool` type objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: Composio tools wrapped as `BaseTool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[BaseTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as GripTape `BaseTool` type objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `BaseTool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=tool.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs",
            "python.plugins.griptape.composio_griptape.toolset.ComposioToolSet.get_actions"
        ]
    },
    "python/plugins/langchain/composio_langchain/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         ]"
            }
        },
        "frontPatchFile": [
            "import types",
            "import typing as t",
            "from inspect import Signature",
            "",
            "import pydantic",
            "import pydantic.error_wrappers",
            "import typing_extensions as te",
            "from langchain_core.tools import StructuredTool as BaseStructuredTool",
            "",
            "from composio import ActionType, AppType, TagType",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.pydantic import parse_pydantic_error",
            "from composio.utils.shared import (",
            "    get_signature_format_from_schema_params,",
            "    json_schema_to_model,",
            ")",
            "",
            "",
            "class StructuredTool(BaseStructuredTool):",
            "    def run(self, *args, **kwargs):",
            "        try:",
            "            return super().run(*args, **kwargs)",
            "        except pydantic.ValidationError as e:",
            "            return {\"successful\": False, \"error\": parse_pydantic_error(e), \"data\": None}",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"langchain\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Langchain framework.",
            "",
            "    Example:",
            "    ```python",
            "        import os",
            "        import dotenv",
            "",
            "        from composio_langchain import App, ComposioToolSet",
            "        from langchain.agents import AgentExecutor, create_openai_functions_agent",
            "        from langchain_openai import ChatOpenAI",
            "",
            "        from langchain import hub",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "",
            "        # Pull relevant agent model.",
            "        prompt = hub.pull(\"hwchase17/openai-functions-agent\")",
            "",
            "        # Initialize tools.",
            "        openai_client = ChatOpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        # Get All the tools",
            "        tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Define task",
            "        task = \"Star a repo composiohq/docs on GitHub\"",
            "",
            "        # Define agent",
            "        agent = create_openai_functions_agent(openai_client, tools, prompt)",
            "        agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)",
            "",
            "        # Execute using agent_executor",
            "        agent_executor.invoke({\"input\": task})",
            "    ```",
            "    \"\"\"",
            "",
            "    def _wrap_action(",
            "        self,",
            "        action: str,",
            "        description: str,",
            "        schema_params: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ):",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Wrapper function for composio action.\"\"\"",
            "            self.logger.debug(f\"Executing action: {action} with params: {kwargs}\")",
            "            return self.execute_action(",
            "                action=action,",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        action_func = types.FunctionType(",
            "            function.__code__,",
            "            globals=globals(),",
            "            name=action,",
            "            closure=function.__closure__,",
            "        )",
            "        action_func.__signature__ = Signature(  # type: ignore",
            "            parameters=get_signature_format_from_schema_params(",
            "                schema_params=schema_params",
            "            )",
            "        )",
            "",
            "        action_func.__doc__ = description",
            "",
            "        return action_func",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict[str, t.Any],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> StructuredTool:",
            "        \"\"\"Wraps composio tool as Langchain StructuredTool object.\"\"\"",
            "        action = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "        schema_params = schema[\"parameters\"]",
            "        action_func = self._wrap_action(",
            "            action=action,",
            "            description=description,",
            "            schema_params=schema_params,",
            "            entity_id=entity_id,",
            "        )",
            "        parameters = json_schema_to_model(json_schema=schema_params)",
            "        tool = StructuredTool.from_function(",
            "            name=action,",
            "            description=description,",
            "            args_schema=parameters,",
            "            return_schema=True,",
            "            func=action_func,",
            "        )",
            "        return tool  # type: ignore",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Sequence[StructuredTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Langchain StructuredTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.Sequence[StructuredTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Langchain StructuredTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=tool.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]"
        ],
        "afterPatchFile": [
            "import types",
            "import typing as t",
            "from inspect import Signature",
            "",
            "import pydantic",
            "import pydantic.error_wrappers",
            "import typing_extensions as te",
            "from langchain_core.tools import StructuredTool as BaseStructuredTool",
            "",
            "from composio import ActionType, AppType, TagType",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.pydantic import parse_pydantic_error",
            "from composio.utils.shared import (",
            "    get_signature_format_from_schema_params,",
            "    json_schema_to_model,",
            ")",
            "",
            "",
            "class StructuredTool(BaseStructuredTool):",
            "    def run(self, *args, **kwargs):",
            "        try:",
            "            return super().run(*args, **kwargs)",
            "        except pydantic.ValidationError as e:",
            "            return {\"successful\": False, \"error\": parse_pydantic_error(e), \"data\": None}",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"langchain\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Langchain framework.",
            "",
            "    Example:",
            "    ```python",
            "        import os",
            "        import dotenv",
            "",
            "        from composio_langchain import App, ComposioToolSet",
            "        from langchain.agents import AgentExecutor, create_openai_functions_agent",
            "        from langchain_openai import ChatOpenAI",
            "",
            "        from langchain import hub",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "",
            "        # Pull relevant agent model.",
            "        prompt = hub.pull(\"hwchase17/openai-functions-agent\")",
            "",
            "        # Initialize tools.",
            "        openai_client = ChatOpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        # Get All the tools",
            "        tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Define task",
            "        task = \"Star a repo composiohq/docs on GitHub\"",
            "",
            "        # Define agent",
            "        agent = create_openai_functions_agent(openai_client, tools, prompt)",
            "        agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)",
            "",
            "        # Execute using agent_executor",
            "        agent_executor.invoke({\"input\": task})",
            "    ```",
            "    \"\"\"",
            "",
            "    def _wrap_action(",
            "        self,",
            "        action: str,",
            "        description: str,",
            "        schema_params: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ):",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Wrapper function for composio action.\"\"\"",
            "            self.logger.debug(f\"Executing action: {action} with params: {kwargs}\")",
            "            return self.execute_action(",
            "                action=action,",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        action_func = types.FunctionType(",
            "            function.__code__,",
            "            globals=globals(),",
            "            name=action,",
            "            closure=function.__closure__,",
            "        )",
            "        action_func.__signature__ = Signature(  # type: ignore",
            "            parameters=get_signature_format_from_schema_params(",
            "                schema_params=schema_params",
            "            )",
            "        )",
            "",
            "        action_func.__doc__ = description",
            "",
            "        return action_func",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict[str, t.Any],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> StructuredTool:",
            "        \"\"\"Wraps composio tool as Langchain StructuredTool object.\"\"\"",
            "        action = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "        schema_params = schema[\"parameters\"]",
            "        action_func = self._wrap_action(",
            "            action=action,",
            "            description=description,",
            "            schema_params=schema_params,",
            "            entity_id=entity_id,",
            "        )",
            "        parameters = json_schema_to_model(json_schema=schema_params)",
            "        tool = StructuredTool.from_function(",
            "            name=action,",
            "            description=description,",
            "            args_schema=parameters,",
            "            return_schema=True,",
            "            func=action_func,",
            "        )",
            "        return tool  # type: ignore",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Sequence[StructuredTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Langchain StructuredTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.Sequence[StructuredTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Langchain StructuredTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=tool.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.plugins.langchain.composio_langchain.toolset.ComposioToolSet.get_actions",
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    },
    "python/plugins/llamaindex/composio_llamaindex/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         ]"
            }
        },
        "frontPatchFile": [
            "import types",
            "import typing as t",
            "from inspect import Signature",
            "",
            "import typing_extensions as te",
            "from llama_index.core.tools import FunctionTool",
            "",
            "from composio import Action, ActionType, AppType",
            "from composio import ComposioToolSet as BaseComposioToolSet",
            "from composio import TagType",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.shared import get_pydantic_signature_format_from_schema_params",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"llamaindex\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for LlamaIndex framework.",
            "",
            "    Example:",
            "    ```python",
            "        import os",
            "        import dotenv",
            "",
            "        from composio_langchain import App, ComposioToolSet",
            "        from langchain.agents import AgentExecutor, create_openai_functions_agent",
            "        from langchain_openai import ChatOpenAI",
            "",
            "        from langchain import hub",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "",
            "        # Pull relevant agent model.",
            "        prompt = hub.pull(\"hwchase17/openai-functions-agent\")",
            "",
            "        # Initialize tools.",
            "        openai_client = ChatOpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        # Get All the tools",
            "        tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Define task",
            "        task = \"Star a repo composiohq/composio on GitHub\"",
            "",
            "        # Define agent",
            "        agent = create_openai_functions_agent(openai_client, tools, prompt)",
            "        agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)",
            "",
            "        # Execute using agent_executor",
            "        agent_executor.invoke({\"input\": task})",
            "    ```",
            "    \"\"\"",
            "",
            "    def _wrap_action(",
            "        self,",
            "        action: str,",
            "        description: str,",
            "        schema_params: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ):",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Wrapper function for composio action.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=action),",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        action_func = types.FunctionType(",
            "            function.__code__,",
            "            globals=globals(),",
            "            name=action,",
            "            closure=function.__closure__,",
            "        )",
            "        action_func.__signature__ = Signature(  # type: ignore",
            "            parameters=get_pydantic_signature_format_from_schema_params(",
            "                schema_params=schema_params",
            "            )",
            "        )",
            "        action_func.__doc__ = description",
            "",
            "        return action_func",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict[str, t.Any],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> FunctionTool:",
            "        \"\"\"Wraps composio tool as LlamaIndex FunctionTool object.\"\"\"",
            "        action = schema[\"name\"]",
            "        description = schema.get(\"description\", schema[\"name\"])",
            "        schema_params = schema[\"parameters\"]",
            "",
            "        action_func = self._wrap_action(",
            "            action=action,",
            "            description=description,",
            "            schema_params=schema_params,",
            "            entity_id=entity_id,",
            "        )",
            "        return FunctionTool.from_defaults(",
            "            action_func,",
            "            name=action,",
            "            description=description,",
            "        )",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Sequence[FunctionTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as LlamaIndex FunctionTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.Sequence[FunctionTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as LlamaIndex FunctionTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=tool.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]"
        ],
        "afterPatchFile": [
            "import types",
            "import typing as t",
            "from inspect import Signature",
            "",
            "import typing_extensions as te",
            "from llama_index.core.tools import FunctionTool",
            "",
            "from composio import Action, ActionType, AppType",
            "from composio import ComposioToolSet as BaseComposioToolSet",
            "from composio import TagType",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.shared import get_pydantic_signature_format_from_schema_params",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"llamaindex\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for LlamaIndex framework.",
            "",
            "    Example:",
            "    ```python",
            "        import os",
            "        import dotenv",
            "",
            "        from composio_langchain import App, ComposioToolSet",
            "        from langchain.agents import AgentExecutor, create_openai_functions_agent",
            "        from langchain_openai import ChatOpenAI",
            "",
            "        from langchain import hub",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "",
            "        # Pull relevant agent model.",
            "        prompt = hub.pull(\"hwchase17/openai-functions-agent\")",
            "",
            "        # Initialize tools.",
            "        openai_client = ChatOpenAI(api_key=os.environ[\"OPENAI_API_KEY\"])",
            "        composio_toolset = ComposioToolSet()",
            "",
            "        # Get All the tools",
            "        tools = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Define task",
            "        task = \"Star a repo composiohq/composio on GitHub\"",
            "",
            "        # Define agent",
            "        agent = create_openai_functions_agent(openai_client, tools, prompt)",
            "        agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)",
            "",
            "        # Execute using agent_executor",
            "        agent_executor.invoke({\"input\": task})",
            "    ```",
            "    \"\"\"",
            "",
            "    def _wrap_action(",
            "        self,",
            "        action: str,",
            "        description: str,",
            "        schema_params: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ):",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Wrapper function for composio action.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=action),",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        action_func = types.FunctionType(",
            "            function.__code__,",
            "            globals=globals(),",
            "            name=action,",
            "            closure=function.__closure__,",
            "        )",
            "        action_func.__signature__ = Signature(  # type: ignore",
            "            parameters=get_pydantic_signature_format_from_schema_params(",
            "                schema_params=schema_params",
            "            )",
            "        )",
            "        action_func.__doc__ = description",
            "",
            "        return action_func",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict[str, t.Any],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> FunctionTool:",
            "        \"\"\"Wraps composio tool as LlamaIndex FunctionTool object.\"\"\"",
            "        action = schema[\"name\"]",
            "        description = schema.get(\"description\", schema[\"name\"])",
            "        schema_params = schema[\"parameters\"]",
            "",
            "        action_func = self._wrap_action(",
            "            action=action,",
            "            description=description,",
            "            schema_params=schema_params,",
            "            entity_id=entity_id,",
            "        )",
            "        return FunctionTool.from_defaults(",
            "            action_func,",
            "            name=action,",
            "            description=description,",
            "        )",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Sequence[FunctionTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as LlamaIndex FunctionTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.Sequence[FunctionTool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as LlamaIndex FunctionTool objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `StructuredTool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=tool.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs",
            "python.plugins.llamaindex.composio_llamaindex.toolset.ComposioToolSet.get_actions"
        ]
    },
    "python/plugins/lyzr/composio_lyzr/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         ]"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Lyzr tool spec.",
            "\"\"\"",
            "",
            "import types",
            "import typing as t",
            "from inspect import Signature",
            "",
            "import typing_extensions as te",
            "from lyzr_automata import Tool",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.shared import (",
            "    get_signature_format_from_schema_params,",
            "    json_schema_to_model,",
            ")",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"lyzr\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Lyzr framework.",
            "    \"\"\"",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> Tool:",
            "        \"\"\"",
            "        Wrap composio tool as Lyzr `Tool` object.",
            "        \"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Composio tool wrapped as Lyzr tool.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=name),",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        action_func = types.FunctionType(",
            "            function.__code__,",
            "            globals=globals(),",
            "            name=name,",
            "            closure=function.__closure__,",
            "        )",
            "        action_func.__signature__ = Signature(  # type: ignore",
            "            parameters=get_signature_format_from_schema_params(",
            "                schema_params=schema[\"parameters\"],",
            "            )",
            "        )",
            "        action_func.__doc__ = description",
            "        return Tool(",
            "            name=name,",
            "            desc=description,",
            "            function=action_func,",
            "            function_input=json_schema_to_model(",
            "                json_schema=schema[\"parameters\"],",
            "            ),",
            "            function_output=json_schema_to_model(",
            "                json_schema=schema[\"response\"],",
            "            ),",
            "            default_params={},",
            "        )",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[Tool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Lyzr `Tool` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `Tool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[Tool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Lyzr `Tool` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `Tool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=schema.model_dump(exclude_none=True),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Lyzr tool spec.",
            "\"\"\"",
            "",
            "import types",
            "import typing as t",
            "from inspect import Signature",
            "",
            "import typing_extensions as te",
            "from lyzr_automata import Tool",
            "",
            "from composio import Action, ActionType, AppType, TagType",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.toolset import ProcessorsType",
            "from composio.utils.shared import (",
            "    get_signature_format_from_schema_params,",
            "    json_schema_to_model,",
            ")",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"lyzr\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Lyzr framework.",
            "    \"\"\"",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> Tool:",
            "        \"\"\"",
            "        Wrap composio tool as Lyzr `Tool` object.",
            "        \"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "",
            "        def function(**kwargs: t.Any) -> t.Dict:",
            "            \"\"\"Composio tool wrapped as Lyzr tool.\"\"\"",
            "            return self.execute_action(",
            "                action=Action(value=name),",
            "                params=kwargs,",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "",
            "        action_func = types.FunctionType(",
            "            function.__code__,",
            "            globals=globals(),",
            "            name=name,",
            "            closure=function.__closure__,",
            "        )",
            "        action_func.__signature__ = Signature(  # type: ignore",
            "            parameters=get_signature_format_from_schema_params(",
            "                schema_params=schema[\"parameters\"],",
            "            )",
            "        )",
            "        action_func.__doc__ = description",
            "        return Tool(",
            "            name=name,",
            "            desc=description,",
            "            function=action_func,",
            "            function_input=json_schema_to_model(",
            "                json_schema=schema[\"parameters\"],",
            "            ),",
            "            function_output=json_schema_to_model(",
            "                json_schema=schema[\"response\"],",
            "            ),",
            "            default_params={},",
            "        )",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[Tool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Lyzr `Tool` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `Tool` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[Tool]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Lyzr `Tool` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Composio tools wrapped as `Tool` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=schema.model_dump(exclude_none=True),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs",
            "python.plugins.lyzr.composio_lyzr.toolset.ComposioToolSet.get_actions"
        ]
    },
    "python/plugins/openai/composio_openai/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         ]"
            },
            "6": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "OpenAI tool spec.",
            "\"\"\"",
            "",
            "import json",
            "import time",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "from openai import Client",
            "from openai.types.beta.thread import Thread",
            "from openai.types.beta.threads.run import RequiredAction, Run",
            "from openai.types.chat.chat_completion import ChatCompletion",
            "from openai.types.chat.chat_completion_message_tool_call import (",
            "    ChatCompletionMessageToolCall,",
            ")",
            "from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam",
            "",
            "from composio import ActionType, AppType, TagType",
            "from composio.constants import DEFAULT_ENTITY_ID",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.schema import OpenAISchema, SchemaType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"openai\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for OpenAI framework.",
            "",
            "    Example:",
            "    ```python",
            "        import dotenv",
            "        from composio_openai import App, ComposioToolSet",
            "        from openai import OpenAI",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize tools.",
            "        openai_client = OpenAI()",
            "        composio_tools = ComposioToolSet()",
            "",
            "        # Define task.",
            "        task = \"Star a repo composiohq/composio on GitHub\"",
            "",
            "        # Get GitHub tools that are pre-configured",
            "        actions = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Get response from the LLM",
            "        response = openai_client.chat.completions.create(",
            "            model=\"gpt-4-turbo-preview\",",
            "            tools=actions,",
            "            messages=[",
            "                {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},",
            "                {\"role\": \"user\", \"content\": task},",
            "            ],",
            "        )",
            "        print(response)",
            "",
            "        # Execute the function calls.",
            "        result = composio_tools.handle_calls(response)",
            "        print(result)",
            "    ```",
            "    \"\"\"",
            "",
            "    schema = SchemaType.OPENAI",
            "",
            "    def validate_entity_id(self, entity_id: str) -> str:",
            "        \"\"\"Validate entity ID.\"\"\"",
            "        if (",
            "            self.entity_id != DEFAULT_ENTITY_ID",
            "            and entity_id != DEFAULT_ENTITY_ID",
            "            and self.entity_id != entity_id",
            "        ):",
            "            raise ValueError(",
            "                \"separate `entity_id` can not be provided during \"",
            "                \"initialization and handelling tool calls\"",
            "            )",
            "        if self.entity_id != DEFAULT_ENTITY_ID:",
            "            entity_id = self.entity_id",
            "        return entity_id",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self, actions: t.Sequence[ActionType]",
            "    ) -> t.List[ChatCompletionToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[ChatCompletionToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            ChatCompletionToolParam(  # type: ignore",
            "                **t.cast(",
            "                    OpenAISchema,",
            "                    self.schema.format(",
            "                        schema.model_dump(",
            "                            exclude_none=True,",
            "                        )",
            "                    ),",
            "                ).model_dump()",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]",
            "",
            "    def get_realtime_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "    ) -> t.List[t.Dict]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        tools = self.get_tools(actions=actions, apps=apps, tags=tags)",
            "        return [",
            "            {",
            "                \"type\": \"function\",",
            "                \"name\": tool[\"function\"][\"name\"],",
            "                \"description\": tool[\"function\"].get(\"description\", \"\"),",
            "                \"parameters\": tool[\"function\"].get(\"parameters\", {}),",
            "            }",
            "            for tool in tools",
            "        ]",
            "",
            "    def execute_tool_call(",
            "        self,",
            "        tool_call: ChatCompletionMessageToolCall,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute a tool call.",
            "",
            "        :param tool_call: Tool call metadata.",
            "        :param entity_id: Entity ID to use for executing the function call.",
            "        :return: Object containing output data from the tool call.",
            "        \"\"\"",
            "        return self.execute_action(",
            "            action=tool_call.function.name,",
            "            params=json.loads(tool_call.function.arguments),",
            "            entity_id=entity_id or self.entity_id,",
            "        )",
            "",
            "    def handle_tool_calls(",
            "        self,",
            "        response: ChatCompletion,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[t.Dict]:",
            "        \"\"\"",
            "        Handle tool calls from OpenAI chat completion object.",
            "",
            "        :param response: Chat completion object from",
            "                        openai.OpenAI.chat.completions.create function call",
            "        :param entity_id: Entity ID to use for executing the function call.",
            "        :return: A list of output objects from the function calls.",
            "        \"\"\"",
            "        entity_id = self.validate_entity_id(entity_id or self.entity_id)",
            "        outputs = []",
            "        if response.choices:",
            "            for choice in response.choices:",
            "                if choice.message.tool_calls:",
            "                    for tool_call in choice.message.tool_calls:",
            "                        outputs.append(",
            "                            self.execute_tool_call(",
            "                                tool_call=tool_call,",
            "                                entity_id=entity_id or self.entity_id,",
            "                            )",
            "                        )",
            "        return outputs",
            "",
            "    def handle_assistant_tool_calls(",
            "        self,",
            "        run: Run,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List:",
            "        \"\"\"Wait and handle assistant function calls\"\"\"",
            "        tool_outputs = []",
            "        for tool_call in t.cast(",
            "            RequiredAction, run.required_action",
            "        ).submit_tool_outputs.tool_calls:",
            "            tool_response = self.execute_tool_call(",
            "                tool_call=t.cast(ChatCompletionMessageToolCall, tool_call),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            tool_output = {",
            "                \"tool_call_id\": tool_call.id,",
            "                \"output\": json.dumps(tool_response),",
            "            }",
            "            tool_outputs.append(tool_output)",
            "        return tool_outputs",
            "",
            "    def wait_and_handle_assistant_tool_calls(",
            "        self,",
            "        client: Client,",
            "        run: Run,",
            "        thread: Thread,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> Run:",
            "        \"\"\"Wait and handle assistant function calls\"\"\"",
            "        thread_object = thread",
            "        while run.status in (\"queued\", \"in_progress\", \"requires_action\"):",
            "            if run.status == \"requires_action\":",
            "                run = client.beta.threads.runs.submit_tool_outputs(",
            "                    thread_id=thread_object.id,",
            "                    run_id=run.id,",
            "                    tool_outputs=self.handle_assistant_tool_calls(",
            "                        run=run,",
            "                        entity_id=entity_id or self.entity_id,",
            "                    ),",
            "                )",
            "            else:",
            "                run = client.beta.threads.runs.retrieve(",
            "                    thread_id=thread_object.id,",
            "                    run_id=run.id,",
            "                )",
            "                time.sleep(0.5)",
            "        return run"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "OpenAI tool spec.",
            "\"\"\"",
            "",
            "import json",
            "import time",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "from openai import Client",
            "from openai.types.beta.thread import Thread",
            "from openai.types.beta.threads.run import RequiredAction, Run",
            "from openai.types.chat.chat_completion import ChatCompletion",
            "from openai.types.chat.chat_completion_message_tool_call import (",
            "    ChatCompletionMessageToolCall,",
            ")",
            "from openai.types.chat.chat_completion_tool_param import ChatCompletionToolParam",
            "",
            "from composio import ActionType, AppType, TagType",
            "from composio.constants import DEFAULT_ENTITY_ID",
            "from composio.tools import ComposioToolSet as BaseComposioToolSet",
            "from composio.tools.schema import OpenAISchema, SchemaType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"openai\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for OpenAI framework.",
            "",
            "    Example:",
            "    ```python",
            "        import dotenv",
            "        from composio_openai import App, ComposioToolSet",
            "        from openai import OpenAI",
            "",
            "",
            "        # Load environment variables from .env",
            "        dotenv.load_dotenv()",
            "",
            "        # Initialize tools.",
            "        openai_client = OpenAI()",
            "        composio_tools = ComposioToolSet()",
            "",
            "        # Define task.",
            "        task = \"Star a repo composiohq/composio on GitHub\"",
            "",
            "        # Get GitHub tools that are pre-configured",
            "        actions = composio_toolset.get_tools(apps=[App.GITHUB])",
            "",
            "        # Get response from the LLM",
            "        response = openai_client.chat.completions.create(",
            "            model=\"gpt-4-turbo-preview\",",
            "            tools=actions,",
            "            messages=[",
            "                {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},",
            "                {\"role\": \"user\", \"content\": task},",
            "            ],",
            "        )",
            "        print(response)",
            "",
            "        # Execute the function calls.",
            "        result = composio_tools.handle_calls(response)",
            "        print(result)",
            "    ```",
            "    \"\"\"",
            "",
            "    schema = SchemaType.OPENAI",
            "",
            "    def validate_entity_id(self, entity_id: str) -> str:",
            "        \"\"\"Validate entity ID.\"\"\"",
            "        if (",
            "            self.entity_id != DEFAULT_ENTITY_ID",
            "            and entity_id != DEFAULT_ENTITY_ID",
            "            and self.entity_id != entity_id",
            "        ):",
            "            raise ValueError(",
            "                \"separate `entity_id` can not be provided during \"",
            "                \"initialization and handelling tool calls\"",
            "            )",
            "        if self.entity_id != DEFAULT_ENTITY_ID:",
            "            entity_id = self.entity_id",
            "        return entity_id",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self, actions: t.Sequence[ActionType]",
            "    ) -> t.List[ChatCompletionToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[ChatCompletionToolParam]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            ChatCompletionToolParam(  # type: ignore",
            "                **t.cast(",
            "                    OpenAISchema,",
            "                    self.schema.format(",
            "                        schema.model_dump(",
            "                            exclude_none=True,",
            "                        )",
            "                    ),",
            "                ).model_dump()",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]",
            "",
            "    def get_realtime_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "    ) -> t.List[t.Dict]:",
            "        \"\"\"",
            "        Get composio tools wrapped as OpenAI `ChatCompletionToolParam` objects.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "",
            "        :return: Composio tools wrapped as `ChatCompletionToolParam` objects",
            "        \"\"\"",
            "        tools = self.get_tools(actions=actions, apps=apps, tags=tags)",
            "        return [",
            "            {",
            "                \"type\": \"function\",",
            "                \"name\": tool[\"function\"][\"name\"],",
            "                \"description\": tool[\"function\"].get(\"description\", \"\"),",
            "                \"parameters\": tool[\"function\"].get(\"parameters\", {}),",
            "            }",
            "            for tool in tools",
            "        ]",
            "",
            "    def execute_tool_call(",
            "        self,",
            "        tool_call: ChatCompletionMessageToolCall,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.Dict:",
            "        \"\"\"",
            "        Execute a tool call.",
            "",
            "        :param tool_call: Tool call metadata.",
            "        :param entity_id: Entity ID to use for executing the function call.",
            "        :return: Object containing output data from the tool call.",
            "        \"\"\"",
            "        return self.execute_action(",
            "            action=tool_call.function.name,",
            "            params=json.loads(tool_call.function.arguments),",
            "            entity_id=entity_id or self.entity_id,",
            "        )",
            "",
            "    def handle_tool_calls(",
            "        self,",
            "        response: ChatCompletion,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[t.Dict]:",
            "        \"\"\"",
            "        Handle tool calls from OpenAI chat completion object.",
            "",
            "        :param response: Chat completion object from",
            "                        openai.OpenAI.chat.completions.create function call",
            "        :param entity_id: Entity ID to use for executing the function call.",
            "        :return: A list of output objects from the function calls.",
            "        \"\"\"",
            "        entity_id = self.validate_entity_id(entity_id or self.entity_id)",
            "        outputs = []",
            "        if response.choices:",
            "            for choice in response.choices:",
            "                if choice.message.tool_calls:",
            "                    for tool_call in choice.message.tool_calls:",
            "                        outputs.append(",
            "                            self.execute_tool_call(",
            "                                tool_call=tool_call,",
            "                                entity_id=entity_id or self.entity_id,",
            "                            )",
            "                        )",
            "        return outputs",
            "",
            "    def handle_assistant_tool_calls(",
            "        self,",
            "        run: Run,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List:",
            "        \"\"\"Wait and handle assistant function calls\"\"\"",
            "        tool_outputs = []",
            "        for tool_call in t.cast(",
            "            RequiredAction, run.required_action",
            "        ).submit_tool_outputs.tool_calls:",
            "            tool_response = self.execute_tool_call(",
            "                tool_call=t.cast(ChatCompletionMessageToolCall, tool_call),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            tool_output = {",
            "                \"tool_call_id\": tool_call.id,",
            "                \"output\": json.dumps(tool_response),",
            "            }",
            "            tool_outputs.append(tool_output)",
            "        return tool_outputs",
            "",
            "    def wait_and_handle_assistant_tool_calls(",
            "        self,",
            "        client: Client,",
            "        run: Run,",
            "        thread: Thread,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> Run:",
            "        \"\"\"Wait and handle assistant function calls\"\"\"",
            "        thread_object = thread",
            "        while run.status in (\"queued\", \"in_progress\", \"requires_action\"):",
            "            if run.status == \"requires_action\":",
            "                run = client.beta.threads.runs.submit_tool_outputs(",
            "                    thread_id=thread_object.id,",
            "                    run_id=run.id,",
            "                    tool_outputs=self.handle_assistant_tool_calls(",
            "                        run=run,",
            "                        entity_id=entity_id or self.entity_id,",
            "                    ),",
            "                )",
            "            else:",
            "                run = client.beta.threads.runs.retrieve(",
            "                    thread_id=thread_object.id,",
            "                    run_id=run.id,",
            "                )",
            "                time.sleep(0.5)",
            "        return run"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs",
            "python.plugins.openai.composio_openai.toolset.ComposioToolSet.get_actions",
            "python.plugins.openai.composio_openai.toolset.ComposioToolSet.get_realtime_tools"
        ]
    },
    "python/plugins/phidata/composio_phidata/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         ]"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "PhiData tool spec.",
            "\"\"\"",
            "",
            "import json",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "from phi.tools.toolkit import Toolkit",
            "from pydantic import validate_call",
            "",
            "from composio import Action, ActionType, AppType",
            "from composio import ComposioToolSet as BaseComposioToolSet",
            "from composio import TagType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"phidata\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Phidata framework.",
            "    \"\"\"",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> Toolkit:",
            "        \"\"\"",
            "        Wrap composio tool as Phidata `Toolkit` object.",
            "        \"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "        parameters = schema[\"parameters\"]",
            "",
            "        # Create a new Toolkit instance",
            "        toolkit = Toolkit(name=name)",
            "",
            "        @validate_call",
            "        def function(**kwargs: t.Any) -> str:",
            "            \"\"\"Composio tool wrapped as Phidata `Function`.",
            "",
            "            Args:",
            "                **kwargs: Function parameters based on the schema",
            "",
            "            Returns:",
            "                str: JSON string containing the function execution result",
            "            \"\"\"",
            "            return json.dumps(",
            "                self.execute_action(",
            "                    action=Action(value=name),",
            "                    params=kwargs,",
            "                    entity_id=entity_id or self.entity_id,",
            "                )",
            "            )",
            "",
            "        # Set function docstring from schema",
            "        param_docs = []",
            "        if \"properties\" in parameters:",
            "            for param_name, param_info in parameters[\"properties\"].items():",
            "                param_desc = param_info.get(\"description\", \"No description available\")",
            "                param_type = param_info.get(\"type\", \"any\")",
            "                param_docs.append(f\":param {param_name}: {param_desc} ({param_type})\")",
            "",
            "        function.__doc__ = f\"{description}\\n\\n\" + \"\\n\".join(param_docs)",
            "",
            "        # Register the function with the toolkit",
            "        toolkit.register(function)",
            "",
            "        return toolkit",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(self, actions: t.Sequence[ActionType]) -> t.List[Toolkit]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Phidata `Toolkit` objects.",
            "",
            "        Args:",
            "            actions: List of actions to wrap",
            "",
            "        Returns:",
            "            List[Toolkit]: Composio tools wrapped as `Toolkit` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[Toolkit]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Phidata `Toolkit` objects.",
            "",
            "        Args:",
            "            actions: List of actions to wrap",
            "            apps: List of apps to wrap",
            "            tags: Filter the apps by given tags",
            "            processors: Optional processors to apply",
            "            check_connected_accounts: Whether to check for connected accounts",
            "",
            "        Returns:",
            "            List[Toolkit]: Composio tools wrapped as `Toolkit` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=schema.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=self.entity_id,",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "PhiData tool spec.",
            "\"\"\"",
            "",
            "import json",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "from phi.tools.toolkit import Toolkit",
            "from pydantic import validate_call",
            "",
            "from composio import Action, ActionType, AppType",
            "from composio import ComposioToolSet as BaseComposioToolSet",
            "from composio import TagType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"phidata\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for Phidata framework.",
            "    \"\"\"",
            "",
            "    def _wrap_tool(",
            "        self,",
            "        schema: t.Dict,",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> Toolkit:",
            "        \"\"\"",
            "        Wrap composio tool as Phidata `Toolkit` object.",
            "        \"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"]",
            "        parameters = schema[\"parameters\"]",
            "",
            "        # Create a new Toolkit instance",
            "        toolkit = Toolkit(name=name)",
            "",
            "        @validate_call",
            "        def function(**kwargs: t.Any) -> str:",
            "            \"\"\"Composio tool wrapped as Phidata `Function`.",
            "",
            "            Args:",
            "                **kwargs: Function parameters based on the schema",
            "",
            "            Returns:",
            "                str: JSON string containing the function execution result",
            "            \"\"\"",
            "            return json.dumps(",
            "                self.execute_action(",
            "                    action=Action(value=name),",
            "                    params=kwargs,",
            "                    entity_id=entity_id or self.entity_id,",
            "                )",
            "            )",
            "",
            "        # Set function docstring from schema",
            "        param_docs = []",
            "        if \"properties\" in parameters:",
            "            for param_name, param_info in parameters[\"properties\"].items():",
            "                param_desc = param_info.get(\"description\", \"No description available\")",
            "                param_type = param_info.get(\"type\", \"any\")",
            "                param_docs.append(f\":param {param_name}: {param_desc} ({param_type})\")",
            "",
            "        function.__doc__ = f\"{description}\\n\\n\" + \"\\n\".join(param_docs)",
            "",
            "        # Register the function with the toolkit",
            "        toolkit.register(function)",
            "",
            "        return toolkit",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(self, actions: t.Sequence[ActionType]) -> t.List[Toolkit]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Phidata `Toolkit` objects.",
            "",
            "        Args:",
            "            actions: List of actions to wrap",
            "",
            "        Returns:",
            "            List[Toolkit]: Composio tools wrapped as `Toolkit` objects",
            "        \"\"\"",
            "        return self.get_tools(actions=actions)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[Toolkit]:",
            "        \"\"\"",
            "        Get composio tools wrapped as Phidata `Toolkit` objects.",
            "",
            "        Args:",
            "            actions: List of actions to wrap",
            "            apps: List of apps to wrap",
            "            tags: Filter the apps by given tags",
            "            processors: Optional processors to apply",
            "            check_connected_accounts: Whether to check for connected accounts",
            "",
            "        Returns:",
            "            List[Toolkit]: Composio tools wrapped as `Toolkit` objects",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._wrap_tool(",
            "                schema=schema.model_dump(",
            "                    exclude_none=True,",
            "                ),",
            "                entity_id=self.entity_id,",
            "            )",
            "            for schema in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.plugins.phidata.composio_phidata.toolset.ComposioToolSet.get_actions",
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    },
    "python/plugins/praisonai/composio_praisonai/toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "                 apps=apps,"
            },
            "1": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "                 tags=tags,"
            },
            "2": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "                 check_connected_accounts=check_connected_accounts,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+                _populate_requested=True,"
            },
            "4": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         ]"
            }
        },
        "frontPatchFile": [
            "import os",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "",
            "from composio import Action, ActionType, AppType",
            "from composio import ComposioToolSet as BaseComposioToolSet",
            "from composio import TagType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "_openapi_to_python = {",
            "    \"string\": \"str\",",
            "    \"number\": \"int\",",
            "    \"integer\": \"int\",",
            "    \"boolean\": \"bool\",",
            "}",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"praisonai\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for PraisonAI framework.",
            "    \"\"\"",
            "",
            "    _tools_file = \"tools.py\"",
            "    _imports = [",
            "        \"import typing as t\",",
            "        \"from typing import Type\",",
            "        \"from praisonai_tools import BaseTool\",",
            "        \"from composio_praisonai import ComposioToolSet\",",
            "        \"from langchain.pydantic_v1 import BaseModel, Field\",",
            "    ]",
            "",
            "    def _create_tool_file(self) -> None:",
            "        if not os.path.exists(self._tools_file):",
            "            with open(self._tools_file, \"w\", encoding=\"utf-8\") as tool_file:",
            "                tool_file.write(\"\\n\".join(self._imports) + \"\\n\\n\")",
            "",
            "    def _process_input_schema(",
            "        self,",
            "        input_model_name: str,",
            "        param_properties: t.Dict,",
            "    ):",
            "        input_model_lines = []",
            "        input_model_lines.append(f\"class {input_model_name}(BaseModel):\")",
            "        for param_name, param_body in param_properties.items():",
            "            description = param_body[\"description\"]",
            "            dtype = param_body[\"type\"]",
            "            if dtype in _openapi_to_python:",
            "                schema_dtype = _openapi_to_python.get(dtype)",
            "            elif dtype == \"array\":",
            "                schema_array_dtype = _openapi_to_python.get(",
            "                    param_body[\"items\"].get(\"type\"),",
            "                    None,",
            "                )",
            "                schema_dtype = (",
            "                    f\"list[{schema_array_dtype}]\" if schema_array_dtype else \"list\"",
            "                )",
            "            else:",
            "                raise TypeError(",
            "                    f\"Some dtype of current schema are not handled yet. Current Schema: {param_body}\"",
            "                )",
            "",
            "            input_model_lines.append(",
            "                f'\\t{param_name}: {schema_dtype} = Field(description=\"{description}\")'",
            "            )",
            "",
            "        return \"\\n\".join(input_model_lines)",
            "",
            "    def execute_tool(self, tool_identifier, params):",
            "        return self.execute_action(",
            "            action=Action(value=tool_identifier),",
            "            params=params,",
            "            entity_id=self.entity_id,",
            "        )",
            "",
            "    def _process_basetool(",
            "        self,",
            "        action_name: str,",
            "        tool_name: str,",
            "        entity_id: t.Any,",
            "        tool_description: str,",
            "        tool_input_model_name: str,",
            "    ) -> str:",
            "        \"\"\"",
            "        Generates the string representation of a BaseTool class.",
            "",
            "        :param action_name: Identifier for the tool action.",
            "        :param tool_name: Name of the tool class.",
            "        :param tool_description: Description of the tool.",
            "        :param tool_input_model_name: Name of the input model class.",
            "        :return: String representation of the BaseTool class.",
            "        \"\"\"",
            "        basetool_lines = [",
            "            f\"class {tool_name}(BaseTool):\",",
            "            f'\\tname: str = \"{tool_name}\"',",
            "            f'\\tdescription: str = \"{tool_description}\"',",
            "            f\"\\targs_schema: Type[BaseModel] = {tool_input_model_name}\",",
            "            \"\",",
            "            \"\\tdef _run(self, **kwargs: t.Any) -> t.Any:\",",
            "            f\"\\t\\ttoolset = ComposioToolSet(entity_id='{entity_id}')\",",
            "            \"\\t\\treturn toolset.execute_tool(\",",
            "            f'\\t\\t\\ttool_identifier=\"{action_name}\",',",
            "            \"\\t\\t\\tparams=kwargs,\",",
            "            \"\\t\\t)\",",
            "        ]",
            "        return \"\\n\".join(basetool_lines)",
            "",
            "    def _write_tool(",
            "        self,",
            "        schema: t.Dict[str, t.Any],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> str:",
            "        \"\"\"",
            "        Generates PraisonAI tools from Composio Actions",
            "",
            "        :param action_name: Identifier for the tool action.",
            "        :param tool_name: Name of the tool class.",
            "        :param tool_description: Description of the tool.",
            "        :param tool_input_model_name: Name of the input model class.",
            "        :return: String representation of the BaseTool class.",
            "        \"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"].replace('\"', \"'\").replace(\"\\n\", \" \")",
            "",
            "        tool_name = f\"{name.upper()}_TOOL\"",
            "        tool_input_model_name = f\"{name.upper()}_PARAMS\"",
            "",
            "        input_model_str = self._process_input_schema(",
            "            input_model_name=tool_input_model_name,",
            "            param_properties=schema[\"parameters\"][\"properties\"],",
            "        )",
            "",
            "        basetool_str = self._process_basetool(",
            "            action_name=name,",
            "            tool_name=tool_name,",
            "            entity_id=entity_id,",
            "            tool_description=description,",
            "            tool_input_model_name=tool_input_model_name,",
            "        )",
            "",
            "        tool_str = input_model_str + \"\\n\\n\" + basetool_str",
            "        if not os.path.exists(self._tools_file):",
            "            self._create_tool_file()",
            "",
            "        with open(self._tools_file, \"r+\", encoding=\"utf-8\") as tool_file:",
            "            if tool_str not in tool_file.read():",
            "                tool_file.write(\"\\n\\n\" + tool_str)",
            "",
            "        return tool_name",
            "",
            "    def get_tools_section(self, tool_names: t.List) -> str:",
            "        \"\"\"",
            "        Constructs a YAML section for the tools.",
            "",
            "        :param tool_names: A list of tool names to include in the section.",
            "        :return: A string representing the YAML section.",
            "        \"\"\"",
            "        tools_section_parts = [\"\\n\"]",
            "        tools_section_parts.append(\"    tools:\")",
            "        for tool_name in tool_names:",
            "            tools_section_parts.append(f\"    - {tool_name}\")",
            "",
            "        return \"\\n\".join(tools_section_parts)",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[str]:",
            "        \"\"\"",
            "        Get composio tools written as ParisonAi supported tools.",
            "",
            "        :param actions: List of actions to write",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: Name of the tools written",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[str]:",
            "        \"\"\"",
            "        Get composio tools written as ParisonAi supported tools.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Name of the tools written",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._write_tool(",
            "                schema=tool.model_dump(exclude_none=True),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "            )",
            "        ]"
        ],
        "afterPatchFile": [
            "import os",
            "import typing as t",
            "",
            "import typing_extensions as te",
            "",
            "from composio import Action, ActionType, AppType",
            "from composio import ComposioToolSet as BaseComposioToolSet",
            "from composio import TagType",
            "from composio.tools.toolset import ProcessorsType",
            "",
            "",
            "_openapi_to_python = {",
            "    \"string\": \"str\",",
            "    \"number\": \"int\",",
            "    \"integer\": \"int\",",
            "    \"boolean\": \"bool\",",
            "}",
            "",
            "",
            "class ComposioToolSet(",
            "    BaseComposioToolSet,",
            "    runtime=\"praisonai\",",
            "    description_char_limit=1024,",
            "    action_name_char_limit=64,",
            "):",
            "    \"\"\"",
            "    Composio toolset for PraisonAI framework.",
            "    \"\"\"",
            "",
            "    _tools_file = \"tools.py\"",
            "    _imports = [",
            "        \"import typing as t\",",
            "        \"from typing import Type\",",
            "        \"from praisonai_tools import BaseTool\",",
            "        \"from composio_praisonai import ComposioToolSet\",",
            "        \"from langchain.pydantic_v1 import BaseModel, Field\",",
            "    ]",
            "",
            "    def _create_tool_file(self) -> None:",
            "        if not os.path.exists(self._tools_file):",
            "            with open(self._tools_file, \"w\", encoding=\"utf-8\") as tool_file:",
            "                tool_file.write(\"\\n\".join(self._imports) + \"\\n\\n\")",
            "",
            "    def _process_input_schema(",
            "        self,",
            "        input_model_name: str,",
            "        param_properties: t.Dict,",
            "    ):",
            "        input_model_lines = []",
            "        input_model_lines.append(f\"class {input_model_name}(BaseModel):\")",
            "        for param_name, param_body in param_properties.items():",
            "            description = param_body[\"description\"]",
            "            dtype = param_body[\"type\"]",
            "            if dtype in _openapi_to_python:",
            "                schema_dtype = _openapi_to_python.get(dtype)",
            "            elif dtype == \"array\":",
            "                schema_array_dtype = _openapi_to_python.get(",
            "                    param_body[\"items\"].get(\"type\"),",
            "                    None,",
            "                )",
            "                schema_dtype = (",
            "                    f\"list[{schema_array_dtype}]\" if schema_array_dtype else \"list\"",
            "                )",
            "            else:",
            "                raise TypeError(",
            "                    f\"Some dtype of current schema are not handled yet. Current Schema: {param_body}\"",
            "                )",
            "",
            "            input_model_lines.append(",
            "                f'\\t{param_name}: {schema_dtype} = Field(description=\"{description}\")'",
            "            )",
            "",
            "        return \"\\n\".join(input_model_lines)",
            "",
            "    def execute_tool(self, tool_identifier, params):",
            "        return self.execute_action(",
            "            action=Action(value=tool_identifier),",
            "            params=params,",
            "            entity_id=self.entity_id,",
            "        )",
            "",
            "    def _process_basetool(",
            "        self,",
            "        action_name: str,",
            "        tool_name: str,",
            "        entity_id: t.Any,",
            "        tool_description: str,",
            "        tool_input_model_name: str,",
            "    ) -> str:",
            "        \"\"\"",
            "        Generates the string representation of a BaseTool class.",
            "",
            "        :param action_name: Identifier for the tool action.",
            "        :param tool_name: Name of the tool class.",
            "        :param tool_description: Description of the tool.",
            "        :param tool_input_model_name: Name of the input model class.",
            "        :return: String representation of the BaseTool class.",
            "        \"\"\"",
            "        basetool_lines = [",
            "            f\"class {tool_name}(BaseTool):\",",
            "            f'\\tname: str = \"{tool_name}\"',",
            "            f'\\tdescription: str = \"{tool_description}\"',",
            "            f\"\\targs_schema: Type[BaseModel] = {tool_input_model_name}\",",
            "            \"\",",
            "            \"\\tdef _run(self, **kwargs: t.Any) -> t.Any:\",",
            "            f\"\\t\\ttoolset = ComposioToolSet(entity_id='{entity_id}')\",",
            "            \"\\t\\treturn toolset.execute_tool(\",",
            "            f'\\t\\t\\ttool_identifier=\"{action_name}\",',",
            "            \"\\t\\t\\tparams=kwargs,\",",
            "            \"\\t\\t)\",",
            "        ]",
            "        return \"\\n\".join(basetool_lines)",
            "",
            "    def _write_tool(",
            "        self,",
            "        schema: t.Dict[str, t.Any],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> str:",
            "        \"\"\"",
            "        Generates PraisonAI tools from Composio Actions",
            "",
            "        :param action_name: Identifier for the tool action.",
            "        :param tool_name: Name of the tool class.",
            "        :param tool_description: Description of the tool.",
            "        :param tool_input_model_name: Name of the input model class.",
            "        :return: String representation of the BaseTool class.",
            "        \"\"\"",
            "        name = schema[\"name\"]",
            "        description = schema[\"description\"].replace('\"', \"'\").replace(\"\\n\", \" \")",
            "",
            "        tool_name = f\"{name.upper()}_TOOL\"",
            "        tool_input_model_name = f\"{name.upper()}_PARAMS\"",
            "",
            "        input_model_str = self._process_input_schema(",
            "            input_model_name=tool_input_model_name,",
            "            param_properties=schema[\"parameters\"][\"properties\"],",
            "        )",
            "",
            "        basetool_str = self._process_basetool(",
            "            action_name=name,",
            "            tool_name=tool_name,",
            "            entity_id=entity_id,",
            "            tool_description=description,",
            "            tool_input_model_name=tool_input_model_name,",
            "        )",
            "",
            "        tool_str = input_model_str + \"\\n\\n\" + basetool_str",
            "        if not os.path.exists(self._tools_file):",
            "            self._create_tool_file()",
            "",
            "        with open(self._tools_file, \"r+\", encoding=\"utf-8\") as tool_file:",
            "            if tool_str not in tool_file.read():",
            "                tool_file.write(\"\\n\\n\" + tool_str)",
            "",
            "        return tool_name",
            "",
            "    def get_tools_section(self, tool_names: t.List) -> str:",
            "        \"\"\"",
            "        Constructs a YAML section for the tools.",
            "",
            "        :param tool_names: A list of tool names to include in the section.",
            "        :return: A string representing the YAML section.",
            "        \"\"\"",
            "        tools_section_parts = [\"\\n\"]",
            "        tools_section_parts.append(\"    tools:\")",
            "        for tool_name in tool_names:",
            "            tools_section_parts.append(f\"    - {tool_name}\")",
            "",
            "        return \"\\n\".join(tools_section_parts)",
            "",
            "    @te.deprecated(\"Use `ComposioToolSet.get_tools` instead\")",
            "    def get_actions(",
            "        self,",
            "        actions: t.Sequence[ActionType],",
            "        entity_id: t.Optional[str] = None,",
            "    ) -> t.List[str]:",
            "        \"\"\"",
            "        Get composio tools written as ParisonAi supported tools.",
            "",
            "        :param actions: List of actions to write",
            "        :param entity_id: Entity ID to use for executing function calls.",
            "        :return: Name of the tools written",
            "        \"\"\"",
            "        return self.get_tools(actions=actions, entity_id=entity_id)",
            "",
            "    def get_tools(",
            "        self,",
            "        actions: t.Optional[t.Sequence[ActionType]] = None,",
            "        apps: t.Optional[t.Sequence[AppType]] = None,",
            "        tags: t.Optional[t.List[TagType]] = None,",
            "        entity_id: t.Optional[str] = None,",
            "        *,",
            "        processors: t.Optional[ProcessorsType] = None,",
            "        check_connected_accounts: bool = True,",
            "    ) -> t.List[str]:",
            "        \"\"\"",
            "        Get composio tools written as ParisonAi supported tools.",
            "",
            "        :param actions: List of actions to wrap",
            "        :param apps: List of apps to wrap",
            "        :param tags: Filter the apps by given tags",
            "        :param entity_id: Entity ID for the function wrapper",
            "",
            "        :return: Name of the tools written",
            "        \"\"\"",
            "        self.validate_tools(apps=apps, actions=actions, tags=tags)",
            "        if processors is not None:",
            "            self._merge_processors(processors)",
            "        return [",
            "            self._write_tool(",
            "                schema=tool.model_dump(exclude_none=True),",
            "                entity_id=entity_id or self.entity_id,",
            "            )",
            "            for tool in self.get_action_schemas(",
            "                actions=actions,",
            "                apps=apps,",
            "                tags=tags,",
            "                check_connected_accounts=check_connected_accounts,",
            "                _populate_requested=True,",
            "            )",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.plugins.praisonai.composio_praisonai.toolset.ComposioToolSet.get_actions",
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    },
    "python/tests/test_cli/test_connections.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         assert ("
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "             \"Id    : 6f4f4191-7fe9-4b5c-b491-4b7ec56ebf5d\" in result.stdout"
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         ), result.stderr"
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert \"Status: ACTIVE\" in result.stdout, result.stderr"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        assert \"Status: EXPIRED\" in result.stdout, result.stderr"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Test connections command group.",
            "\"\"\"",
            "",
            "from tests.test_cli.base import BaseCliTest",
            "",
            "",
            "class TestListConnections(BaseCliTest):",
            "    \"\"\"Test list connections.\"\"\"",
            "",
            "    def test_list_all(self) -> None:",
            "        \"\"\"Test list connections.\"\"\"",
            "        result = self.run(\"connections\")",
            "",
            "        assert result.exit_code == 0, result.stderr",
            "        assert \"App: github\" in result.stdout, result.stderr",
            "        assert \"Id :\" in result.stdout, result.stderr",
            "",
            "    def test_list_one(self) -> None:",
            "        \"\"\"Test list one connection.\"\"\"",
            "        result = self.run(\"connections\", \"get\", \"6f4f4191-7fe9-4b5c-b491-4b7ec56ebf5d\")",
            "",
            "        assert result.exit_code == 0, result.stderr",
            "        assert \"App   : github\" in result.stdout, result.stderr",
            "        assert (",
            "            \"Id    : 6f4f4191-7fe9-4b5c-b491-4b7ec56ebf5d\" in result.stdout",
            "        ), result.stderr",
            "        assert \"Status: ACTIVE\" in result.stdout, result.stderr"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Test connections command group.",
            "\"\"\"",
            "",
            "from tests.test_cli.base import BaseCliTest",
            "",
            "",
            "class TestListConnections(BaseCliTest):",
            "    \"\"\"Test list connections.\"\"\"",
            "",
            "    def test_list_all(self) -> None:",
            "        \"\"\"Test list connections.\"\"\"",
            "        result = self.run(\"connections\")",
            "",
            "        assert result.exit_code == 0, result.stderr",
            "        assert \"App: github\" in result.stdout, result.stderr",
            "        assert \"Id :\" in result.stdout, result.stderr",
            "",
            "    def test_list_one(self) -> None:",
            "        \"\"\"Test list one connection.\"\"\"",
            "        result = self.run(\"connections\", \"get\", \"6f4f4191-7fe9-4b5c-b491-4b7ec56ebf5d\")",
            "",
            "        assert result.exit_code == 0, result.stderr",
            "        assert \"App   : github\" in result.stdout, result.stderr",
            "        assert (",
            "            \"Id    : 6f4f4191-7fe9-4b5c-b491-4b7ec56ebf5d\" in result.stdout",
            "        ), result.stderr",
            "        assert \"Status: EXPIRED\" in result.stdout, result.stderr"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "28": [
                "TestListConnections",
                "test_list_one"
            ]
        },
        "addLocation": []
    },
    "python/tests/test_tools/test_toolset.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "             ]"
            },
            "1": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "         )"
            },
            "2": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "         assert len(t.cast(str, schema.name)) == char_limit"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+def test_invalid_handle_tool_calls() -> None:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+    \"\"\"Test edge case where the Agent tries to call a tool that wasn't requested from get_tools().\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+    toolset = LangchainToolSet()"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+    toolset.get_tools(actions=[Action.GMAIL_FETCH_EMAILS])"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+    with pytest.raises(ComposioSDKError) as exc:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+        with mock.patch.object(toolset, \"_execute_remote\"):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+            toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+    assert ("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+        \"Action HACKERNEWS_GET_FRONTPAGE is being called, but was never requested by the toolset.\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+        in exc.value.message"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+    )"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+    # Ensure it does NOT fail if a subsequent get_tools added that action"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+    toolset.get_tools(actions=[Action.HACKERNEWS_GET_FRONTPAGE])"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+    with mock.patch.object(toolset, \"_execute_remote\"):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+    # Ensure it DOES NOT fail if get_tools is never called"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+    toolset = LangchainToolSet()"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+    with mock.patch.object(toolset, \"_execute_remote\"):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+        toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Test composio toolset.",
            "\"\"\"",
            "",
            "import logging",
            "import re",
            "import typing as t",
            "from unittest import mock",
            "",
            "import pytest",
            "from pydantic import BaseModel",
            "",
            "from composio import Action, App",
            "from composio.exceptions import ApiKeyNotProvidedError, ComposioSDKError",
            "from composio.tools.base.abs import action_registry, tool_registry",
            "from composio.tools.base.runtime import action as custom_action",
            "from composio.tools.toolset import ComposioToolSet",
            "from composio.utils.pypi import reset_installed_list",
            "",
            "from composio_langchain.toolset import ComposioToolSet as LangchainToolSet",
            "",
            "",
            "def test_get_schemas() -> None:",
            "    \"\"\"Test `ComposioToolSet.find_actions_by_tags` method.\"\"\"",
            "    toolset = ComposioToolSet()",
            "    assert (",
            "        len(",
            "            toolset.get_action_schemas(",
            "                actions=[",
            "                    Action.SHELLTOOL_EXEC_COMMAND,",
            "                    Action.GITHUB_ACCEPT_A_REPOSITORY_INVITATION,",
            "                ]",
            "            )",
            "        )",
            "        > 0",
            "    )",
            "",
            "",
            "def test_find_actions_by_tags() -> None:",
            "    \"\"\"Test `ComposioToolSet.find_actions_by_tags` method.\"\"\"",
            "    toolset = ComposioToolSet()",
            "    for action in toolset.find_actions_by_tags(tags=[\"important\"]):",
            "        assert \"important\" in action.tags",
            "",
            "    for action in toolset.find_actions_by_tags(",
            "        App.SLACK, App.GITHUB, tags=[\"important\"]",
            "    ):",
            "        assert \"important\" in action.tags",
            "        assert action.app in (\"GITHUB\", \"SLACK\", \"SLACKBOT\")",
            "",
            "",
            "def test_uninitialize_app() -> None:",
            "    \"\"\"Test if the usage of an app without connected account raises error or not.\"\"\"",
            "    # Ensure the app is cached",
            "    # TODO: remove this once App.iter() uses a dedicated endpoint",
            "    # for fetching latest enums",
            "    App.ATTIO.load()",
            "",
            "    with pytest.raises(",
            "        ComposioSDKError,",
            "        match=(",
            "            \"No connected account found for app `ATTIO`; \"",
            "            \"Run `composio add attio` to fix this\"",
            "        ),",
            "    ):",
            "        ComposioToolSet().get_action_schemas(actions=[Action.ATTIO_UPDATE_A_LIST])",
            "",
            "",
            "class TestValidateTools:",
            "    toolset: ComposioToolSet",
            "    package = \"somepackage1\"",
            "",
            "    @classmethod",
            "    def setup_class(cls) -> None:",
            "        cls.toolset = ComposioToolSet()",
            "        tool_registry[\"local\"][App.BROWSER_TOOL.slug].requires = [cls.package]",
            "        action_registry[\"local\"][Action.BROWSER_TOOL_CLICK_ELEMENT.slug].requires = [",
            "            cls.package",
            "        ]",
            "",
            "    def setup_method(self) -> None:",
            "        reset_installed_list()",
            "",
            "    def test_validate_tools_app(self, caplog) -> None:",
            "        \"\"\"Test `ComposioToolSet.validate_tools` method.\"\"\"",
            "        with caplog.at_level(logging.INFO), mock.patch(",
            "            \"subprocess.check_output\",",
            "            return_value=b\"Successfully installed\",",
            "        ):",
            "            self.toolset.validate_tools(apps=[App.BROWSER_TOOL])",
            "            assert f\"Installed {self.package}\" in caplog.text",
            "",
            "    def test_validate_tools_action(self, caplog) -> None:",
            "        \"\"\"Test `ComposioToolSet.validate_tools` method.\"\"\"",
            "        with caplog.at_level(logging.INFO), mock.patch(",
            "            \"subprocess.check_output\",",
            "            return_value=b\"Successfully installed\",",
            "        ):",
            "            self.toolset.validate_tools(",
            "                actions=[",
            "                    Action.BROWSER_TOOL_CLICK_ELEMENT,",
            "                ]",
            "            )",
            "            assert f\"Installed {self.package}\" in caplog.text",
            "",
            "    def test_installation_failed(self, caplog) -> None:",
            "        \"\"\"Test `ComposioToolSet.validate_tools` method.\"\"\"",
            "        with caplog.at_level(logging.INFO), mock.patch(",
            "            \"subprocess.check_output\",",
            "            return_value=b\"\",",
            "        ), pytest.raises(",
            "            ComposioSDKError,",
            "            match=f\"Error installing {self.package}\",",
            "        ):",
            "            self.toolset.validate_tools(apps=[App.BROWSER_TOOL])",
            "",
            "",
            "class TestConnectedAccountProvider:",
            "    connected_account = \"some_account_id\"",
            "",
            "    def test_invalid_account_id(self) -> None:",
            "        with pytest.raises(",
            "            ComposioSDKError,",
            "            match=re.escape(",
            "                f\"Invalid connected accounts found: [('GITHUB', '{self.connected_account}')]\"",
            "            ),",
            "        ):",
            "            ComposioToolSet(",
            "                connected_account_ids={",
            "                    App.GITHUB: self.connected_account,",
            "                }",
            "            )",
            "",
            "    def test_using_provided_account_id(self) -> None:",
            "        def _patch(*_, **kwargs):",
            "            assert kwargs.get(\"connected_account_id\") == self.connected_account",
            "",
            "        with mock.patch(\"composio.client.Entity.get_connection\"):",
            "            toolset = ComposioToolSet(",
            "                connected_account_ids={",
            "                    App.GITHUB: self.connected_account,",
            "                }",
            "            )",
            "            setattr(toolset, \"_execute_remote\", _patch)",
            "            setattr(",
            "                toolset,",
            "                \"_try_get_github_access_token_for_current_entity\",",
            "                lambda *_: \"\",",
            "            )",
            "            toolset.execute_action(",
            "                action=Action.GITHUB_GITHUB_API_ROOT,",
            "                params={},",
            "            )",
            "",
            "",
            "def test_api_key_missing() -> None:",
            "    toolset = ComposioToolSet()",
            "    toolset._api_key = None  # pylint: disable=protected-access",
            "    with pytest.raises(",
            "        ApiKeyNotProvidedError,",
            "        match=(",
            "            \"API Key not provided, either provide API key or export it as \"",
            "            \"`COMPOSIO_API_KEY` or run `composio login`\"",
            "        ),",
            "    ):",
            "        _ = toolset.workspace",
            "",
            "",
            "def test_processors(monkeypatch: pytest.MonkeyPatch) -> None:",
            "    \"\"\"Test the `processors` field in `ComposioToolSet` constructor.\"\"\"",
            "    preprocessor_called = postprocessor_called = False",
            "",
            "    def preprocess(request: dict) -> dict:",
            "        nonlocal preprocessor_called",
            "        preprocessor_called = True",
            "        return request",
            "",
            "    def postprocess(response: dict) -> dict:",
            "        nonlocal postprocessor_called",
            "        postprocessor_called = True",
            "        return response",
            "",
            "    with pytest.warns(DeprecationWarning):",
            "        toolset = ComposioToolSet(",
            "            processors={",
            "                \"pre\": {App.GMAIL: preprocess},",
            "                \"post\": {App.GMAIL: postprocess},",
            "            }",
            "        )",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "",
            "    # Happy case",
            "    toolset.execute_action(action=Action.GMAIL_FETCH_EMAILS, params={})",
            "    assert preprocessor_called",
            "    assert postprocessor_called",
            "",
            "    # Improperly defined processors",
            "    preprocessor_called = postprocessor_called = False",
            "",
            "    def weird_postprocessor(reponse: dict) -> None:",
            "        \"\"\"Forgets to return the reponse.\"\"\"",
            "        reponse[\"something\"] = True",
            "",
            "    # users may not respect our type annotations",
            "    toolset = ComposioToolSet(",
            "        processors={\"post\": {App.SERPAPI: weird_postprocessor}}  # type: ignore",
            "    )",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "",
            "    with pytest.warns(",
            "        UserWarning,",
            "        match=\"Expected post-processor to return 'dict', got 'NoneType'\",",
            "    ):",
            "        result = toolset.execute_action(action=Action.SERPAPI_SEARCH, params={})",
            "",
            "    assert result is None",
            "",
            "",
            "def test_processors_on_execute_action(monkeypatch: pytest.MonkeyPatch) -> None:",
            "    \"\"\"Test the `processors` field in `execute_action()` methods of ToolSet's.\"\"\"",
            "    preprocessor_called = False",
            "",
            "    def preprocess(response: dict) -> dict:",
            "        nonlocal preprocessor_called",
            "        preprocessor_called = True",
            "        return response",
            "",
            "    toolset = LangchainToolSet()",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "    toolset.execute_action(",
            "        Action.ATTIO_LIST_NOTES,",
            "        params={},",
            "        processors={\"pre\": {Action.ATTIO_LIST_NOTES: preprocess}},",
            "    )",
            "    assert preprocessor_called",
            "",
            "",
            "def test_processors_on_get_tools(monkeypatch: pytest.MonkeyPatch) -> None:",
            "    \"\"\"Test the `processors` field in `get_tools()` methods of ToolSet's.\"\"\"",
            "    postprocessor_called = False",
            "",
            "    def postprocess(response: dict) -> dict:",
            "        nonlocal postprocessor_called",
            "        postprocessor_called = True",
            "        return response",
            "",
            "    toolset = LangchainToolSet()",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "",
            "    toolset.get_tools(",
            "        actions=[Action.COMPOSIO_ENABLE_TRIGGER],",
            "        processors={\"post\": {Action.COMPOSIO_ENABLE_TRIGGER: postprocess}},",
            "    )",
            "    toolset.execute_action(Action.COMPOSIO_ENABLE_TRIGGER, {})",
            "    assert postprocessor_called",
            "",
            "",
            "def test_check_connected_accounts_flag() -> None:",
            "    \"\"\"Test the `check_connected_accounts` flag on `get_tools()`.\"\"\"",
            "",
            "    toolset = LangchainToolSet()",
            "    # Ensure `check_connected_account()` gets called by default",
            "    with mock.patch.object(toolset, \"check_connected_account\") as mocked:",
            "        toolset.get_tools(actions=[Action.GMAIL_FETCH_EMAILS])",
            "        mocked.assert_called_once()",
            "",
            "    # Ensure `check_connected_account()` DOES NOT get called when the flag is set",
            "    with mock.patch.object(toolset, \"check_connected_account\") as mocked:",
            "        with pytest.warns(",
            "            UserWarning,",
            "            match=\"Not verifying connected accounts for apps.\",",
            "        ):",
            "            toolset.get_tools(",
            "                actions=[Action.GMAIL_FETCH_EMAILS],",
            "                check_connected_accounts=False,",
            "            )",
            "        mocked.assert_not_called()",
            "",
            "",
            "def test_get_action_schemas_description_for_runtime_tool() -> None:",
            "",
            "    @custom_action(toolname=\"runtime\")",
            "    def some_action(name: str) -> str:",
            "        \"\"\"",
            "        Some action",
            "",
            "        :param name: Name of the user",
            "        :return message: Message for user",
            "        \"\"\"",
            "        return f\"Hello, {name}\"",
            "",
            "    (schema_0,) = ComposioToolSet().get_action_schemas(actions=[some_action])",
            "    assert (",
            "        schema_0.parameters.properties[\"name\"][\"description\"]",
            "        == \"Name of the user. Please provide a value of type string. This parameter is required.\"",
            "    )",
            "",
            "    (schema_1,) = ComposioToolSet().get_action_schemas(actions=[some_action])",
            "    assert (",
            "        schema_1.parameters.properties[\"name\"][\"description\"]",
            "        == \"Name of the user. Please provide a value of type string. This parameter is required.\"",
            "    )",
            "",
            "",
            "def test_execute_action() -> None:",
            "    toolset = ComposioToolSet()",
            "    response = toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})",
            "    assert response[\"successfull\"]",
            "",
            "",
            "class EmailAddressModel(BaseModel):",
            "    name: str",
            "    email: str",
            "",
            "",
            "def test_execute_action_param_serialization() -> None:",
            "    toolset = LangchainToolSet()",
            "    with mock.patch.object(toolset, \"_execute_remote\") as mocked:",
            "        toolset.execute_action(",
            "            Action.OUTLOOK_OUTLOOK_CREATE_CONTACT,",
            "            {\"contact\": EmailAddressModel(name=\"John Doe\", email=\"johndoe@gmail.com\")},",
            "        )",
            "",
            "    mocked.assert_called_once_with(",
            "        action=Action.OUTLOOK_OUTLOOK_CREATE_CONTACT,",
            "        params={\"contact\": {\"name\": \"John Doe\", \"email\": \"johndoe@gmail.com\"}},",
            "        entity_id=\"default\",",
            "        connected_account_id=None,",
            "        text=None,",
            "        session_id=mock.ANY,",
            "    )",
            "",
            "",
            "class TestSubclassInit:",
            "",
            "    def test_runtime(self):",
            "",
            "        class SomeToolsetExtention(ComposioToolSet):",
            "            pass",
            "",
            "        assert (",
            "            SomeToolsetExtention._runtime  # pylint: disable=protected-access",
            "            == \"composio\"",
            "        )",
            "",
            "        class SomeOtherToolsetExtention(ComposioToolSet, runtime=\"some_toolset\"):",
            "            pass",
            "",
            "        assert (",
            "            SomeOtherToolsetExtention._runtime  # pylint: disable=protected-access",
            "            == \"some_toolset\"",
            "        )",
            "",
            "    def test_description_char_limit(self) -> None:",
            "",
            "        char_limit = 512",
            "        (schema,) = ComposioToolSet().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.description)) > char_limit",
            "",
            "        class SomeToolsetExtention(ComposioToolSet, description_char_limit=char_limit):",
            "            pass",
            "",
            "        (schema,) = SomeToolsetExtention().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.description)) == char_limit",
            "",
            "    def test_action_name_char_limit(self) -> None:",
            "",
            "        char_limit = 12",
            "        (schema,) = ComposioToolSet().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.name)) > char_limit",
            "",
            "        class SomeToolsetExtention(ComposioToolSet, action_name_char_limit=char_limit):",
            "            pass",
            "",
            "        (schema,) = SomeToolsetExtention().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.name)) == char_limit"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Test composio toolset.",
            "\"\"\"",
            "",
            "import logging",
            "import re",
            "import typing as t",
            "from unittest import mock",
            "",
            "import pytest",
            "from pydantic import BaseModel",
            "",
            "from composio import Action, App",
            "from composio.exceptions import ApiKeyNotProvidedError, ComposioSDKError",
            "from composio.tools.base.abs import action_registry, tool_registry",
            "from composio.tools.base.runtime import action as custom_action",
            "from composio.tools.toolset import ComposioToolSet",
            "from composio.utils.pypi import reset_installed_list",
            "",
            "from composio_langchain.toolset import ComposioToolSet as LangchainToolSet",
            "",
            "",
            "def test_get_schemas() -> None:",
            "    \"\"\"Test `ComposioToolSet.find_actions_by_tags` method.\"\"\"",
            "    toolset = ComposioToolSet()",
            "    assert (",
            "        len(",
            "            toolset.get_action_schemas(",
            "                actions=[",
            "                    Action.SHELLTOOL_EXEC_COMMAND,",
            "                    Action.GITHUB_ACCEPT_A_REPOSITORY_INVITATION,",
            "                ]",
            "            )",
            "        )",
            "        > 0",
            "    )",
            "",
            "",
            "def test_find_actions_by_tags() -> None:",
            "    \"\"\"Test `ComposioToolSet.find_actions_by_tags` method.\"\"\"",
            "    toolset = ComposioToolSet()",
            "    for action in toolset.find_actions_by_tags(tags=[\"important\"]):",
            "        assert \"important\" in action.tags",
            "",
            "    for action in toolset.find_actions_by_tags(",
            "        App.SLACK, App.GITHUB, tags=[\"important\"]",
            "    ):",
            "        assert \"important\" in action.tags",
            "        assert action.app in (\"GITHUB\", \"SLACK\", \"SLACKBOT\")",
            "",
            "",
            "def test_uninitialize_app() -> None:",
            "    \"\"\"Test if the usage of an app without connected account raises error or not.\"\"\"",
            "    # Ensure the app is cached",
            "    # TODO: remove this once App.iter() uses a dedicated endpoint",
            "    # for fetching latest enums",
            "    App.ATTIO.load()",
            "",
            "    with pytest.raises(",
            "        ComposioSDKError,",
            "        match=(",
            "            \"No connected account found for app `ATTIO`; \"",
            "            \"Run `composio add attio` to fix this\"",
            "        ),",
            "    ):",
            "        ComposioToolSet().get_action_schemas(actions=[Action.ATTIO_UPDATE_A_LIST])",
            "",
            "",
            "class TestValidateTools:",
            "    toolset: ComposioToolSet",
            "    package = \"somepackage1\"",
            "",
            "    @classmethod",
            "    def setup_class(cls) -> None:",
            "        cls.toolset = ComposioToolSet()",
            "        tool_registry[\"local\"][App.BROWSER_TOOL.slug].requires = [cls.package]",
            "        action_registry[\"local\"][Action.BROWSER_TOOL_CLICK_ELEMENT.slug].requires = [",
            "            cls.package",
            "        ]",
            "",
            "    def setup_method(self) -> None:",
            "        reset_installed_list()",
            "",
            "    def test_validate_tools_app(self, caplog) -> None:",
            "        \"\"\"Test `ComposioToolSet.validate_tools` method.\"\"\"",
            "        with caplog.at_level(logging.INFO), mock.patch(",
            "            \"subprocess.check_output\",",
            "            return_value=b\"Successfully installed\",",
            "        ):",
            "            self.toolset.validate_tools(apps=[App.BROWSER_TOOL])",
            "            assert f\"Installed {self.package}\" in caplog.text",
            "",
            "    def test_validate_tools_action(self, caplog) -> None:",
            "        \"\"\"Test `ComposioToolSet.validate_tools` method.\"\"\"",
            "        with caplog.at_level(logging.INFO), mock.patch(",
            "            \"subprocess.check_output\",",
            "            return_value=b\"Successfully installed\",",
            "        ):",
            "            self.toolset.validate_tools(",
            "                actions=[",
            "                    Action.BROWSER_TOOL_CLICK_ELEMENT,",
            "                ]",
            "            )",
            "            assert f\"Installed {self.package}\" in caplog.text",
            "",
            "    def test_installation_failed(self, caplog) -> None:",
            "        \"\"\"Test `ComposioToolSet.validate_tools` method.\"\"\"",
            "        with caplog.at_level(logging.INFO), mock.patch(",
            "            \"subprocess.check_output\",",
            "            return_value=b\"\",",
            "        ), pytest.raises(",
            "            ComposioSDKError,",
            "            match=f\"Error installing {self.package}\",",
            "        ):",
            "            self.toolset.validate_tools(apps=[App.BROWSER_TOOL])",
            "",
            "",
            "class TestConnectedAccountProvider:",
            "    connected_account = \"some_account_id\"",
            "",
            "    def test_invalid_account_id(self) -> None:",
            "        with pytest.raises(",
            "            ComposioSDKError,",
            "            match=re.escape(",
            "                f\"Invalid connected accounts found: [('GITHUB', '{self.connected_account}')]\"",
            "            ),",
            "        ):",
            "            ComposioToolSet(",
            "                connected_account_ids={",
            "                    App.GITHUB: self.connected_account,",
            "                }",
            "            )",
            "",
            "    def test_using_provided_account_id(self) -> None:",
            "        def _patch(*_, **kwargs):",
            "            assert kwargs.get(\"connected_account_id\") == self.connected_account",
            "",
            "        with mock.patch(\"composio.client.Entity.get_connection\"):",
            "            toolset = ComposioToolSet(",
            "                connected_account_ids={",
            "                    App.GITHUB: self.connected_account,",
            "                }",
            "            )",
            "            setattr(toolset, \"_execute_remote\", _patch)",
            "            setattr(",
            "                toolset,",
            "                \"_try_get_github_access_token_for_current_entity\",",
            "                lambda *_: \"\",",
            "            )",
            "            toolset.execute_action(",
            "                action=Action.GITHUB_GITHUB_API_ROOT,",
            "                params={},",
            "            )",
            "",
            "",
            "def test_api_key_missing() -> None:",
            "    toolset = ComposioToolSet()",
            "    toolset._api_key = None  # pylint: disable=protected-access",
            "    with pytest.raises(",
            "        ApiKeyNotProvidedError,",
            "        match=(",
            "            \"API Key not provided, either provide API key or export it as \"",
            "            \"`COMPOSIO_API_KEY` or run `composio login`\"",
            "        ),",
            "    ):",
            "        _ = toolset.workspace",
            "",
            "",
            "def test_processors(monkeypatch: pytest.MonkeyPatch) -> None:",
            "    \"\"\"Test the `processors` field in `ComposioToolSet` constructor.\"\"\"",
            "    preprocessor_called = postprocessor_called = False",
            "",
            "    def preprocess(request: dict) -> dict:",
            "        nonlocal preprocessor_called",
            "        preprocessor_called = True",
            "        return request",
            "",
            "    def postprocess(response: dict) -> dict:",
            "        nonlocal postprocessor_called",
            "        postprocessor_called = True",
            "        return response",
            "",
            "    with pytest.warns(DeprecationWarning):",
            "        toolset = ComposioToolSet(",
            "            processors={",
            "                \"pre\": {App.GMAIL: preprocess},",
            "                \"post\": {App.GMAIL: postprocess},",
            "            }",
            "        )",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "",
            "    # Happy case",
            "    toolset.execute_action(action=Action.GMAIL_FETCH_EMAILS, params={})",
            "    assert preprocessor_called",
            "    assert postprocessor_called",
            "",
            "    # Improperly defined processors",
            "    preprocessor_called = postprocessor_called = False",
            "",
            "    def weird_postprocessor(reponse: dict) -> None:",
            "        \"\"\"Forgets to return the reponse.\"\"\"",
            "        reponse[\"something\"] = True",
            "",
            "    # users may not respect our type annotations",
            "    toolset = ComposioToolSet(",
            "        processors={\"post\": {App.SERPAPI: weird_postprocessor}}  # type: ignore",
            "    )",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "",
            "    with pytest.warns(",
            "        UserWarning,",
            "        match=\"Expected post-processor to return 'dict', got 'NoneType'\",",
            "    ):",
            "        result = toolset.execute_action(action=Action.SERPAPI_SEARCH, params={})",
            "",
            "    assert result is None",
            "",
            "",
            "def test_processors_on_execute_action(monkeypatch: pytest.MonkeyPatch) -> None:",
            "    \"\"\"Test the `processors` field in `execute_action()` methods of ToolSet's.\"\"\"",
            "    preprocessor_called = False",
            "",
            "    def preprocess(response: dict) -> dict:",
            "        nonlocal preprocessor_called",
            "        preprocessor_called = True",
            "        return response",
            "",
            "    toolset = LangchainToolSet()",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "    toolset.execute_action(",
            "        Action.ATTIO_LIST_NOTES,",
            "        params={},",
            "        processors={\"pre\": {Action.ATTIO_LIST_NOTES: preprocess}},",
            "    )",
            "    assert preprocessor_called",
            "",
            "",
            "def test_processors_on_get_tools(monkeypatch: pytest.MonkeyPatch) -> None:",
            "    \"\"\"Test the `processors` field in `get_tools()` methods of ToolSet's.\"\"\"",
            "    postprocessor_called = False",
            "",
            "    def postprocess(response: dict) -> dict:",
            "        nonlocal postprocessor_called",
            "        postprocessor_called = True",
            "        return response",
            "",
            "    toolset = LangchainToolSet()",
            "    monkeypatch.setattr(toolset, \"_execute_remote\", lambda **_: {})",
            "",
            "    toolset.get_tools(",
            "        actions=[Action.COMPOSIO_ENABLE_TRIGGER],",
            "        processors={\"post\": {Action.COMPOSIO_ENABLE_TRIGGER: postprocess}},",
            "    )",
            "    toolset.execute_action(Action.COMPOSIO_ENABLE_TRIGGER, {})",
            "    assert postprocessor_called",
            "",
            "",
            "def test_check_connected_accounts_flag() -> None:",
            "    \"\"\"Test the `check_connected_accounts` flag on `get_tools()`.\"\"\"",
            "",
            "    toolset = LangchainToolSet()",
            "    # Ensure `check_connected_account()` gets called by default",
            "    with mock.patch.object(toolset, \"check_connected_account\") as mocked:",
            "        toolset.get_tools(actions=[Action.GMAIL_FETCH_EMAILS])",
            "        mocked.assert_called_once()",
            "",
            "    # Ensure `check_connected_account()` DOES NOT get called when the flag is set",
            "    with mock.patch.object(toolset, \"check_connected_account\") as mocked:",
            "        with pytest.warns(",
            "            UserWarning,",
            "            match=\"Not verifying connected accounts for apps.\",",
            "        ):",
            "            toolset.get_tools(",
            "                actions=[Action.GMAIL_FETCH_EMAILS],",
            "                check_connected_accounts=False,",
            "            )",
            "        mocked.assert_not_called()",
            "",
            "",
            "def test_get_action_schemas_description_for_runtime_tool() -> None:",
            "",
            "    @custom_action(toolname=\"runtime\")",
            "    def some_action(name: str) -> str:",
            "        \"\"\"",
            "        Some action",
            "",
            "        :param name: Name of the user",
            "        :return message: Message for user",
            "        \"\"\"",
            "        return f\"Hello, {name}\"",
            "",
            "    (schema_0,) = ComposioToolSet().get_action_schemas(actions=[some_action])",
            "    assert (",
            "        schema_0.parameters.properties[\"name\"][\"description\"]",
            "        == \"Name of the user. Please provide a value of type string. This parameter is required.\"",
            "    )",
            "",
            "    (schema_1,) = ComposioToolSet().get_action_schemas(actions=[some_action])",
            "    assert (",
            "        schema_1.parameters.properties[\"name\"][\"description\"]",
            "        == \"Name of the user. Please provide a value of type string. This parameter is required.\"",
            "    )",
            "",
            "",
            "def test_execute_action() -> None:",
            "    toolset = ComposioToolSet()",
            "    response = toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})",
            "    assert response[\"successfull\"]",
            "",
            "",
            "class EmailAddressModel(BaseModel):",
            "    name: str",
            "    email: str",
            "",
            "",
            "def test_execute_action_param_serialization() -> None:",
            "    toolset = LangchainToolSet()",
            "    with mock.patch.object(toolset, \"_execute_remote\") as mocked:",
            "        toolset.execute_action(",
            "            Action.OUTLOOK_OUTLOOK_CREATE_CONTACT,",
            "            {\"contact\": EmailAddressModel(name=\"John Doe\", email=\"johndoe@gmail.com\")},",
            "        )",
            "",
            "    mocked.assert_called_once_with(",
            "        action=Action.OUTLOOK_OUTLOOK_CREATE_CONTACT,",
            "        params={\"contact\": {\"name\": \"John Doe\", \"email\": \"johndoe@gmail.com\"}},",
            "        entity_id=\"default\",",
            "        connected_account_id=None,",
            "        text=None,",
            "        session_id=mock.ANY,",
            "    )",
            "",
            "",
            "class TestSubclassInit:",
            "",
            "    def test_runtime(self):",
            "",
            "        class SomeToolsetExtention(ComposioToolSet):",
            "            pass",
            "",
            "        assert (",
            "            SomeToolsetExtention._runtime  # pylint: disable=protected-access",
            "            == \"composio\"",
            "        )",
            "",
            "        class SomeOtherToolsetExtention(ComposioToolSet, runtime=\"some_toolset\"):",
            "            pass",
            "",
            "        assert (",
            "            SomeOtherToolsetExtention._runtime  # pylint: disable=protected-access",
            "            == \"some_toolset\"",
            "        )",
            "",
            "    def test_description_char_limit(self) -> None:",
            "",
            "        char_limit = 512",
            "        (schema,) = ComposioToolSet().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.description)) > char_limit",
            "",
            "        class SomeToolsetExtention(ComposioToolSet, description_char_limit=char_limit):",
            "            pass",
            "",
            "        (schema,) = SomeToolsetExtention().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.description)) == char_limit",
            "",
            "    def test_action_name_char_limit(self) -> None:",
            "",
            "        char_limit = 12",
            "        (schema,) = ComposioToolSet().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.name)) > char_limit",
            "",
            "        class SomeToolsetExtention(ComposioToolSet, action_name_char_limit=char_limit):",
            "            pass",
            "",
            "        (schema,) = SomeToolsetExtention().get_action_schemas(",
            "            actions=[",
            "                Action.FILETOOL_GIT_CLONE,",
            "            ]",
            "        )",
            "        assert len(t.cast(str, schema.name)) == char_limit",
            "",
            "",
            "def test_invalid_handle_tool_calls() -> None:",
            "    \"\"\"Test edge case where the Agent tries to call a tool that wasn't requested from get_tools().\"\"\"",
            "    toolset = LangchainToolSet()",
            "",
            "    toolset.get_tools(actions=[Action.GMAIL_FETCH_EMAILS])",
            "    with pytest.raises(ComposioSDKError) as exc:",
            "        with mock.patch.object(toolset, \"_execute_remote\"):",
            "            toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})",
            "",
            "    assert (",
            "        \"Action HACKERNEWS_GET_FRONTPAGE is being called, but was never requested by the toolset.\"",
            "        in exc.value.message",
            "    )",
            "",
            "    # Ensure it does NOT fail if a subsequent get_tools added that action",
            "    toolset.get_tools(actions=[Action.HACKERNEWS_GET_FRONTPAGE])",
            "    with mock.patch.object(toolset, \"_execute_remote\"):",
            "        toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})",
            "",
            "    # Ensure it DOES NOT fail if get_tools is never called",
            "    toolset = LangchainToolSet()",
            "    with mock.patch.object(toolset, \"_execute_remote\"):",
            "        toolset.execute_action(Action.HACKERNEWS_GET_FRONTPAGE, {})"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    }
}