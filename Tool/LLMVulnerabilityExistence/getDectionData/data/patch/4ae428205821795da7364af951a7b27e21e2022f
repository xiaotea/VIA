{
    "mlflow/recipes/cards/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "             '<p><strong>Step status: <span style=\"color:red\">Failed</span></strong></p>',"
            },
            "1": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         )"
            },
            "2": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         self.add_tab("
            },
            "3": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"Stacktrace\", \"<div class='stacktrace-container'>{{ STACKTRACE }}</div>\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+            \"Stacktrace\", \"<div class='stacktrace-container'>{{ STACKTRACE|e }}</div>\""
            },
            "5": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         ).add_html(\"STACKTRACE\", f'<p style=\"margin-top:0px\"><code>{failure_traceback}</code></p>')"
            },
            "6": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         warning_output_path = os.path.join(output_directory, \"warning_logs.txt\")"
            },
            "7": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         if os.path.exists(warning_output_path):"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import base64",
            "import html",
            "import logging",
            "import os",
            "import pathlib",
            "import pickle",
            "import random",
            "import re",
            "import string",
            "from io import StringIO",
            "from typing import Optional, Union",
            "",
            "from packaging.version import Version",
            "",
            "from mlflow.exceptions import INVALID_PARAMETER_VALUE, MlflowException",
            "",
            "CARD_PICKLE_NAME = \"card.pkl\"",
            "CARD_HTML_NAME = \"card.html\"",
            "",
            "_PP_VARIABLE_LINK_REGEX = re.compile(r'<a\\s+href=\"?(?P<href>#pp_var_[-0-9]+)\"?\\s*>')",
            "",
            "",
            "_logger = logging.getLogger(__name__)",
            "",
            "",
            "class CardTab:",
            "    def __init__(self, name: str, template: str) -> None:",
            "        \"\"\"",
            "        Construct a step card tab with supported HTML template.",
            "",
            "        :param name: a string representing the name of the tab.",
            "        :param template: a string representing the HTML template for the card content.",
            "        \"\"\"",
            "        import jinja2",
            "        from jinja2 import meta as jinja2_meta",
            "",
            "        self.name = name",
            "        self.template = template",
            "",
            "        j2_env = jinja2.Environment()",
            "        self._variables = jinja2_meta.find_undeclared_variables(j2_env.parse(template))",
            "        self._context = {}",
            "",
            "    def add_html(self, name: str, html_content: str) -> CardTab:",
            "        \"\"\"",
            "        Adds html to the CardTab.",
            "",
            "        :param name: String, name of the variable in the Jinja2 template",
            "        :param html_content: String, the html to replace the named template variable",
            "        :return: the updated card instance",
            "        \"\"\"",
            "        if name not in self._variables:",
            "            raise MlflowException(",
            "                f\"{name} is not a valid template variable defined in template: '{self.template}'\",",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "        self._context[name] = html_content",
            "        return self",
            "",
            "    def add_markdown(self, name: str, markdown: str) -> CardTab:",
            "        \"\"\"",
            "        Adds markdown to the card replacing the variable name in the CardTab template.",
            "",
            "        :param name: name of the variable in the CardTab Jinja2 template",
            "        :param markdown: the markdown content",
            "        :return: the updated card tab instance",
            "        \"\"\"",
            "        from markdown import markdown as md_to_html",
            "",
            "        self.add_html(name, md_to_html(markdown))",
            "        return self",
            "",
            "    def add_image(",
            "        self,",
            "        name: str,",
            "        image_file_path: str,",
            "        width: Optional[int] = None,",
            "        height: Optional[int] = None,",
            "    ) -> None:",
            "        if not os.path.exists(image_file_path):",
            "            self.add_html(name, \"Image Unavailable\")",
            "            _logger.warning(f\"Unable to locate image file {image_file_path} to render {name}.\")",
            "            return",
            "",
            "        with open(image_file_path, \"rb\") as f:",
            "            base64_str = base64.b64encode(f.read()).decode(\"utf-8\")",
            "",
            "        image_type = pathlib.Path(image_file_path).suffix[1:]",
            "",
            "        width_style = f'width=\"{width}\"' if width else \"\"",
            "        height_style = f'height=\"{width}\"' if height else \"\"",
            "        img_html = (",
            "            f'<img src=\"data:image/{image_type};base64, {base64_str}\" '",
            "            f\"{width_style} {height_style} />\"",
            "        )",
            "        self.add_html(name, img_html)",
            "",
            "    def add_pandas_profile(self, name: str, profile: str) -> CardTab:",
            "        \"\"\"",
            "        Add a new tab representing the provided pandas profile to the card.",
            "",
            "        :param name: name of the variable in the Jinja2 template",
            "        :param profile: html string to render profile in the step card",
            "        :return: the updated card instance",
            "        \"\"\"",
            "        try:",
            "            profile_iframe = (",
            "                \"<iframe srcdoc='{src}' width='100%' height='500' frameborder='0'></iframe>\"",
            "            ).format(src=html.escape(profile))",
            "        except Exception as e:",
            "            profile_iframe = f\"Unable to create data profile. Error found:\\n{e}\"",
            "        self.add_html(name, profile_iframe)",
            "        return self",
            "",
            "    def to_html(self) -> str:",
            "        \"\"\"",
            "        Returns a rendered HTML representing the content of the tab.",
            "",
            "        :return: a HTML string",
            "        \"\"\"",
            "        from jinja2 import BaseLoader",
            "        from jinja2.sandbox import SandboxedEnvironment",
            "",
            "        j2_env = SandboxedEnvironment(loader=BaseLoader()).from_string(self.template)",
            "        return j2_env.render({**self._context})",
            "",
            "",
            "class BaseCard:",
            "    def __init__(self, recipe_name: str, step_name: str) -> None:",
            "        \"\"\"",
            "        BaseCard Constructor",
            "",
            "        :param recipe_name: a string representing name of the recipe.",
            "        :param step_name: a string representing the name of the step.",
            "        \"\"\"",
            "        self._recipe_name = recipe_name",
            "        self._step_name = step_name",
            "        self._template_name = \"base.html\"",
            "",
            "        self._string_builder = StringIO()",
            "        self._tabs = []",
            "",
            "    def add_tab(self, name, html_template) -> CardTab:",
            "        \"\"\"",
            "        Add a new tab with arbitrary content.",
            "",
            "        :param name: a string representing the name of the tab.",
            "        :param html_template: a string representing the HTML template for the card content.",
            "        \"\"\"",
            "        tab = CardTab(name, html_template)",
            "        self._tabs.append((name, tab))",
            "        return tab",
            "",
            "    def get_tab(self, name) -> Union[CardTab, None]:",
            "        \"\"\"",
            "        Returns an existing tab with the specified name. Returns None if not found.",
            "",
            "        :param name: a string representing the name of the tab.",
            "        \"\"\"",
            "        for key, tab in self._tabs:",
            "            if key == name:",
            "                return tab",
            "        return None",
            "",
            "    def add_text(self, text: str) -> BaseCard:",
            "        \"\"\"",
            "        Add text to the textual representation of this card.",
            "",
            "        :param text: a string text",
            "        :return: the updated card instance",
            "        \"\"\"",
            "        self._string_builder.write(text)",
            "        return self",
            "",
            "    def to_html(self) -> str:",
            "        \"\"\"",
            "        This funtion renders the Jinja2 template based on the provided context so far.",
            "",
            "        :return: a HTML string",
            "        \"\"\"",
            "        import jinja2",
            "",
            "        def get_random_id(length=6):",
            "            return \"\".join(",
            "                random.choice(string.ascii_lowercase + string.digits) for _ in range(length)",
            "            )",
            "",
            "        base_template_path = os.path.join(os.path.dirname(__file__), \"templates\")",
            "        j2_env = jinja2.Environment(loader=jinja2.FileSystemLoader(base_template_path))",
            "        tab_list = [(name, tab.to_html()) for name, tab in self._tabs]",
            "        page_id = get_random_id()",
            "        return j2_env.get_template(self._template_name).render(",
            "            {",
            "                \"HEADER_TITLE\": f\"{self._step_name.capitalize()}@{self._recipe_name}\",",
            "                \"TABLINK\": f\"tablink-{page_id}\",",
            "                \"CONTENT\": f\"content-{page_id}\",",
            "                \"BUTTON_CONTAINER\": f\"button-container-{page_id}\",",
            "                \"tab_list\": tab_list,",
            "            }",
            "        )",
            "",
            "    def to_text(self) -> str:",
            "        \"\"\"",
            "        :return: the textual representation of the card.",
            "        \"\"\"",
            "        return self._string_builder.getvalue()",
            "",
            "    def save_as_html(self, path) -> None:",
            "        if os.path.isdir(path):",
            "            path = os.path.join(path, CARD_HTML_NAME)",
            "        with open(path, \"w\", encoding=\"utf-8\") as f:",
            "            f.write(self.to_html())",
            "",
            "    def save(self, path: str) -> None:",
            "        if os.path.isdir(path):",
            "            path = os.path.join(path, CARD_PICKLE_NAME)",
            "        with open(path, \"wb\") as out:",
            "            pickle.dump(self, out)",
            "",
            "    @staticmethod",
            "    def load(path):",
            "        if os.path.isdir(path):",
            "            path = os.path.join(path, CARD_PICKLE_NAME)",
            "        with open(path, \"rb\") as f:",
            "            return pickle.load(f)",
            "",
            "    @staticmethod",
            "    def render_table(table, columns=None, hide_index=True):",
            "        \"\"\"",
            "        Renders a table-like object as an HTML table.",
            "",
            "        :param table: Table-like object (e.g. pandas DataFrame, 2D numpy array, list of tuples).",
            "        :param columns: Column names to use. If `table` doesn't have column names, this argument",
            "            provides names for the columns. Otherwise, only the specified columns will be included",
            "            in the output HTML table.",
            "        :param hide_index: Hide index column when rendering.",
            "        \"\"\"",
            "        import pandas as pd",
            "        from pandas.io.formats.style import Styler",
            "",
            "        if not isinstance(table, Styler):",
            "            table = pd.DataFrame(table, columns=columns).style",
            "",
            "        pandas_version = Version(pd.__version__)",
            "",
            "        styler = table.set_table_attributes('style=\"border-collapse:collapse\"').set_table_styles(",
            "            [",
            "                {",
            "                    \"selector\": \"table, th, td\",",
            "                    \"props\": [",
            "                        (\"border\", \"1px solid grey\"),",
            "                        (\"text-align\", \"left\"),",
            "                        (\"padding\", \"5px\"),",
            "                    ],",
            "                },",
            "            ]",
            "        )",
            "        if hide_index:",
            "            rendered_table = (",
            "                styler.hide(axis=\"index\").to_html()",
            "                if pandas_version >= Version(\"1.4.0\")",
            "                else styler.hide_index().render()",
            "            )",
            "        else:",
            "            rendered_table = (",
            "                styler.to_html() if pandas_version >= Version(\"1.4.0\") else styler.render()",
            "            )",
            "        return f'<div style=\"max-height: 500px; overflow: scroll;\">{rendered_table}</div>'",
            "",
            "",
            "class FailureCard(BaseCard):",
            "    \"\"\"",
            "    Step card providing information about a failed step execution, including a stacktrace.",
            "",
            "    TODO: Migrate the failure card to a tab-based card, removing this class and its associated",
            "          HTML template in the process.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, recipe_name: str, step_name: str, failure_traceback: str, output_directory: str",
            "    ):",
            "        super().__init__(",
            "            recipe_name=recipe_name,",
            "            step_name=step_name,",
            "        )",
            "        self.add_tab(\"Step Status\", \"{{ STEP_STATUS }}\").add_html(",
            "            \"STEP_STATUS\",",
            "            '<p><strong>Step status: <span style=\"color:red\">Failed</span></strong></p>',",
            "        )",
            "        self.add_tab(",
            "            \"Stacktrace\", \"<div class='stacktrace-container'>{{ STACKTRACE }}</div>\"",
            "        ).add_html(\"STACKTRACE\", f'<p style=\"margin-top:0px\"><code>{failure_traceback}</code></p>')",
            "        warning_output_path = os.path.join(output_directory, \"warning_logs.txt\")",
            "        if os.path.exists(warning_output_path):",
            "            with open(warning_output_path) as f:",
            "                self.add_tab(\"Warning Logs\", \"{{ STEP_WARNINGS }}\").add_html(",
            "                    \"STEP_WARNINGS\", f\"<pre>{f.read()}</pre>\"",
            "                )"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import base64",
            "import html",
            "import logging",
            "import os",
            "import pathlib",
            "import pickle",
            "import random",
            "import re",
            "import string",
            "from io import StringIO",
            "from typing import Optional, Union",
            "",
            "from packaging.version import Version",
            "",
            "from mlflow.exceptions import INVALID_PARAMETER_VALUE, MlflowException",
            "",
            "CARD_PICKLE_NAME = \"card.pkl\"",
            "CARD_HTML_NAME = \"card.html\"",
            "",
            "_PP_VARIABLE_LINK_REGEX = re.compile(r'<a\\s+href=\"?(?P<href>#pp_var_[-0-9]+)\"?\\s*>')",
            "",
            "",
            "_logger = logging.getLogger(__name__)",
            "",
            "",
            "class CardTab:",
            "    def __init__(self, name: str, template: str) -> None:",
            "        \"\"\"",
            "        Construct a step card tab with supported HTML template.",
            "",
            "        :param name: a string representing the name of the tab.",
            "        :param template: a string representing the HTML template for the card content.",
            "        \"\"\"",
            "        import jinja2",
            "        from jinja2 import meta as jinja2_meta",
            "",
            "        self.name = name",
            "        self.template = template",
            "",
            "        j2_env = jinja2.Environment()",
            "        self._variables = jinja2_meta.find_undeclared_variables(j2_env.parse(template))",
            "        self._context = {}",
            "",
            "    def add_html(self, name: str, html_content: str) -> CardTab:",
            "        \"\"\"",
            "        Adds html to the CardTab.",
            "",
            "        :param name: String, name of the variable in the Jinja2 template",
            "        :param html_content: String, the html to replace the named template variable",
            "        :return: the updated card instance",
            "        \"\"\"",
            "        if name not in self._variables:",
            "            raise MlflowException(",
            "                f\"{name} is not a valid template variable defined in template: '{self.template}'\",",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "        self._context[name] = html_content",
            "        return self",
            "",
            "    def add_markdown(self, name: str, markdown: str) -> CardTab:",
            "        \"\"\"",
            "        Adds markdown to the card replacing the variable name in the CardTab template.",
            "",
            "        :param name: name of the variable in the CardTab Jinja2 template",
            "        :param markdown: the markdown content",
            "        :return: the updated card tab instance",
            "        \"\"\"",
            "        from markdown import markdown as md_to_html",
            "",
            "        self.add_html(name, md_to_html(markdown))",
            "        return self",
            "",
            "    def add_image(",
            "        self,",
            "        name: str,",
            "        image_file_path: str,",
            "        width: Optional[int] = None,",
            "        height: Optional[int] = None,",
            "    ) -> None:",
            "        if not os.path.exists(image_file_path):",
            "            self.add_html(name, \"Image Unavailable\")",
            "            _logger.warning(f\"Unable to locate image file {image_file_path} to render {name}.\")",
            "            return",
            "",
            "        with open(image_file_path, \"rb\") as f:",
            "            base64_str = base64.b64encode(f.read()).decode(\"utf-8\")",
            "",
            "        image_type = pathlib.Path(image_file_path).suffix[1:]",
            "",
            "        width_style = f'width=\"{width}\"' if width else \"\"",
            "        height_style = f'height=\"{width}\"' if height else \"\"",
            "        img_html = (",
            "            f'<img src=\"data:image/{image_type};base64, {base64_str}\" '",
            "            f\"{width_style} {height_style} />\"",
            "        )",
            "        self.add_html(name, img_html)",
            "",
            "    def add_pandas_profile(self, name: str, profile: str) -> CardTab:",
            "        \"\"\"",
            "        Add a new tab representing the provided pandas profile to the card.",
            "",
            "        :param name: name of the variable in the Jinja2 template",
            "        :param profile: html string to render profile in the step card",
            "        :return: the updated card instance",
            "        \"\"\"",
            "        try:",
            "            profile_iframe = (",
            "                \"<iframe srcdoc='{src}' width='100%' height='500' frameborder='0'></iframe>\"",
            "            ).format(src=html.escape(profile))",
            "        except Exception as e:",
            "            profile_iframe = f\"Unable to create data profile. Error found:\\n{e}\"",
            "        self.add_html(name, profile_iframe)",
            "        return self",
            "",
            "    def to_html(self) -> str:",
            "        \"\"\"",
            "        Returns a rendered HTML representing the content of the tab.",
            "",
            "        :return: a HTML string",
            "        \"\"\"",
            "        from jinja2 import BaseLoader",
            "        from jinja2.sandbox import SandboxedEnvironment",
            "",
            "        j2_env = SandboxedEnvironment(loader=BaseLoader()).from_string(self.template)",
            "        return j2_env.render({**self._context})",
            "",
            "",
            "class BaseCard:",
            "    def __init__(self, recipe_name: str, step_name: str) -> None:",
            "        \"\"\"",
            "        BaseCard Constructor",
            "",
            "        :param recipe_name: a string representing name of the recipe.",
            "        :param step_name: a string representing the name of the step.",
            "        \"\"\"",
            "        self._recipe_name = recipe_name",
            "        self._step_name = step_name",
            "        self._template_name = \"base.html\"",
            "",
            "        self._string_builder = StringIO()",
            "        self._tabs = []",
            "",
            "    def add_tab(self, name, html_template) -> CardTab:",
            "        \"\"\"",
            "        Add a new tab with arbitrary content.",
            "",
            "        :param name: a string representing the name of the tab.",
            "        :param html_template: a string representing the HTML template for the card content.",
            "        \"\"\"",
            "        tab = CardTab(name, html_template)",
            "        self._tabs.append((name, tab))",
            "        return tab",
            "",
            "    def get_tab(self, name) -> Union[CardTab, None]:",
            "        \"\"\"",
            "        Returns an existing tab with the specified name. Returns None if not found.",
            "",
            "        :param name: a string representing the name of the tab.",
            "        \"\"\"",
            "        for key, tab in self._tabs:",
            "            if key == name:",
            "                return tab",
            "        return None",
            "",
            "    def add_text(self, text: str) -> BaseCard:",
            "        \"\"\"",
            "        Add text to the textual representation of this card.",
            "",
            "        :param text: a string text",
            "        :return: the updated card instance",
            "        \"\"\"",
            "        self._string_builder.write(text)",
            "        return self",
            "",
            "    def to_html(self) -> str:",
            "        \"\"\"",
            "        This funtion renders the Jinja2 template based on the provided context so far.",
            "",
            "        :return: a HTML string",
            "        \"\"\"",
            "        import jinja2",
            "",
            "        def get_random_id(length=6):",
            "            return \"\".join(",
            "                random.choice(string.ascii_lowercase + string.digits) for _ in range(length)",
            "            )",
            "",
            "        base_template_path = os.path.join(os.path.dirname(__file__), \"templates\")",
            "        j2_env = jinja2.Environment(loader=jinja2.FileSystemLoader(base_template_path))",
            "        tab_list = [(name, tab.to_html()) for name, tab in self._tabs]",
            "        page_id = get_random_id()",
            "        return j2_env.get_template(self._template_name).render(",
            "            {",
            "                \"HEADER_TITLE\": f\"{self._step_name.capitalize()}@{self._recipe_name}\",",
            "                \"TABLINK\": f\"tablink-{page_id}\",",
            "                \"CONTENT\": f\"content-{page_id}\",",
            "                \"BUTTON_CONTAINER\": f\"button-container-{page_id}\",",
            "                \"tab_list\": tab_list,",
            "            }",
            "        )",
            "",
            "    def to_text(self) -> str:",
            "        \"\"\"",
            "        :return: the textual representation of the card.",
            "        \"\"\"",
            "        return self._string_builder.getvalue()",
            "",
            "    def save_as_html(self, path) -> None:",
            "        if os.path.isdir(path):",
            "            path = os.path.join(path, CARD_HTML_NAME)",
            "        with open(path, \"w\", encoding=\"utf-8\") as f:",
            "            f.write(self.to_html())",
            "",
            "    def save(self, path: str) -> None:",
            "        if os.path.isdir(path):",
            "            path = os.path.join(path, CARD_PICKLE_NAME)",
            "        with open(path, \"wb\") as out:",
            "            pickle.dump(self, out)",
            "",
            "    @staticmethod",
            "    def load(path):",
            "        if os.path.isdir(path):",
            "            path = os.path.join(path, CARD_PICKLE_NAME)",
            "        with open(path, \"rb\") as f:",
            "            return pickle.load(f)",
            "",
            "    @staticmethod",
            "    def render_table(table, columns=None, hide_index=True):",
            "        \"\"\"",
            "        Renders a table-like object as an HTML table.",
            "",
            "        :param table: Table-like object (e.g. pandas DataFrame, 2D numpy array, list of tuples).",
            "        :param columns: Column names to use. If `table` doesn't have column names, this argument",
            "            provides names for the columns. Otherwise, only the specified columns will be included",
            "            in the output HTML table.",
            "        :param hide_index: Hide index column when rendering.",
            "        \"\"\"",
            "        import pandas as pd",
            "        from pandas.io.formats.style import Styler",
            "",
            "        if not isinstance(table, Styler):",
            "            table = pd.DataFrame(table, columns=columns).style",
            "",
            "        pandas_version = Version(pd.__version__)",
            "",
            "        styler = table.set_table_attributes('style=\"border-collapse:collapse\"').set_table_styles(",
            "            [",
            "                {",
            "                    \"selector\": \"table, th, td\",",
            "                    \"props\": [",
            "                        (\"border\", \"1px solid grey\"),",
            "                        (\"text-align\", \"left\"),",
            "                        (\"padding\", \"5px\"),",
            "                    ],",
            "                },",
            "            ]",
            "        )",
            "        if hide_index:",
            "            rendered_table = (",
            "                styler.hide(axis=\"index\").to_html()",
            "                if pandas_version >= Version(\"1.4.0\")",
            "                else styler.hide_index().render()",
            "            )",
            "        else:",
            "            rendered_table = (",
            "                styler.to_html() if pandas_version >= Version(\"1.4.0\") else styler.render()",
            "            )",
            "        return f'<div style=\"max-height: 500px; overflow: scroll;\">{rendered_table}</div>'",
            "",
            "",
            "class FailureCard(BaseCard):",
            "    \"\"\"",
            "    Step card providing information about a failed step execution, including a stacktrace.",
            "",
            "    TODO: Migrate the failure card to a tab-based card, removing this class and its associated",
            "          HTML template in the process.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, recipe_name: str, step_name: str, failure_traceback: str, output_directory: str",
            "    ):",
            "        super().__init__(",
            "            recipe_name=recipe_name,",
            "            step_name=step_name,",
            "        )",
            "        self.add_tab(\"Step Status\", \"{{ STEP_STATUS }}\").add_html(",
            "            \"STEP_STATUS\",",
            "            '<p><strong>Step status: <span style=\"color:red\">Failed</span></strong></p>',",
            "        )",
            "        self.add_tab(",
            "            \"Stacktrace\", \"<div class='stacktrace-container'>{{ STACKTRACE|e }}</div>\"",
            "        ).add_html(\"STACKTRACE\", f'<p style=\"margin-top:0px\"><code>{failure_traceback}</code></p>')",
            "        warning_output_path = os.path.join(output_directory, \"warning_logs.txt\")",
            "        if os.path.exists(warning_output_path):",
            "            with open(warning_output_path) as f:",
            "                self.add_tab(\"Warning Logs\", \"{{ STEP_WARNINGS }}\").add_html(",
            "                    \"STEP_WARNINGS\", f\"<pre>{f.read()}</pre>\"",
            "                )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "293": [
                "FailureCard",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "mlflow/recipes/steps/ingest/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             )"
            },
            "1": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         # Tab #2 -- Ingested dataset schema."
            },
            "2": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         schema_html = BaseCard.render_table(schema[\"fields\"])"
            },
            "3": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        card.add_tab(\"Data Schema\", \"{{SCHEMA}}\").add_html(\"SCHEMA\", schema_html)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        card.add_tab(\"Data Schema\", \"{{SCHEMA|e}}\").add_html(\"SCHEMA\", schema_html)"
            },
            "5": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         if data_preview is not None:"
            },
            "7": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "             # Tab #3 -- Ingested dataset preview."
            }
        },
        "frontPatchFile": [
            "import abc",
            "import logging",
            "import os",
            "from pathlib import Path",
            "from typing import Any, Dict, Optional",
            "",
            "import pandas as pd",
            "",
            "from mlflow.exceptions import MlflowException",
            "from mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE",
            "from mlflow.recipes.artifacts import DataframeArtifact",
            "from mlflow.recipes.cards import BaseCard",
            "from mlflow.recipes.step import BaseStep, StepClass",
            "from mlflow.recipes.steps.ingest.datasets import (",
            "    CustomDataset,",
            "    DeltaTableDataset,",
            "    ParquetDataset,",
            "    SparkSqlDataset,",
            ")",
            "from mlflow.recipes.utils.step import get_pandas_data_profiles, validate_classification_config",
            "from mlflow.utils.file_utils import read_parquet_as_pandas_df",
            "",
            "_logger = logging.getLogger(__name__)",
            "",
            "",
            "class BaseIngestStep(BaseStep, metaclass=abc.ABCMeta):",
            "    _DATASET_FORMAT_SPARK_TABLE = \"spark_table\"",
            "    _DATASET_FORMAT_DELTA = \"delta\"",
            "    _DATASET_FORMAT_PARQUET = \"parquet\"",
            "    _DATASET_PROFILE_OUTPUT_NAME = \"dataset_profile.html\"",
            "    _STEP_CARD_OUTPUT_NAME = \"card.pkl\"",
            "    _SUPPORTED_DATASETS = [",
            "        ParquetDataset,",
            "        DeltaTableDataset,",
            "        SparkSqlDataset,",
            "        # NB: The custom dataset is deliberately listed last as a catch-all for any",
            "        # format not matched by the datasets above. When mapping a format to a dataset,",
            "        # datasets are explored in the listed order",
            "        CustomDataset,",
            "    ]",
            "",
            "    def _validate_and_apply_step_config(self):",
            "        dataset_format = self.step_config.get(\"using\")",
            "        if not dataset_format:",
            "            raise MlflowException(",
            "                message=(",
            "                    \"Dataset format must be specified via the `using` key within the `ingest`\"",
            "                    \" section of recipe.yaml\"",
            "                ),",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        if self.step_class() == StepClass.TRAINING:",
            "            self.target_col = self.step_config.get(\"target_col\")",
            "            if self.target_col is None:",
            "                raise MlflowException(",
            "                    \"Missing target_col config in recipe config.\",",
            "                    error_code=INVALID_PARAMETER_VALUE,",
            "                )",
            "            self.positive_class = self.step_config.get(\"positive_class\")",
            "        for dataset_class in BaseIngestStep._SUPPORTED_DATASETS:",
            "            if dataset_class.handles_format(dataset_format):",
            "                self.dataset = dataset_class.from_config(",
            "                    dataset_config=self.step_config,",
            "                    recipe_root=self.recipe_root,",
            "                )",
            "                break",
            "        else:",
            "            raise MlflowException(",
            "                message=f\"Unrecognized dataset format: {dataset_format}\",",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "        self.skip_data_profiling = self.step_config.get(\"skip_data_profiling\", False)",
            "",
            "    def _run(self, output_directory: str) -> BaseCard:",
            "        dataset_dst_path = os.path.abspath(os.path.join(output_directory, self.dataset_output_name))",
            "        self.dataset.resolve_to_parquet(",
            "            dst_path=dataset_dst_path,",
            "        )",
            "        _logger.debug(\"Successfully stored data in parquet format at '%s'\", dataset_dst_path)",
            "",
            "        ingested_df = read_parquet_as_pandas_df(data_parquet_path=dataset_dst_path)",
            "        if self.step_class() == StepClass.TRAINING:",
            "            if self.target_col not in ingested_df.columns:",
            "                raise MlflowException(",
            "                    f\"Target column '{self.target_col}' not found in ingested dataset.\",",
            "                    error_code=INVALID_PARAMETER_VALUE,",
            "                )",
            "            if self.task == \"classification\":",
            "                validate_classification_config(",
            "                    self.task, self.positive_class, ingested_df, self.target_col",
            "                )",
            "                cardinality = ingested_df[self.target_col].nunique()",
            "                if cardinality > 2 and self.positive_class is not None:",
            "                    raise MlflowException(",
            "                        f\"Target column '{self.target_col}' must have a cardinality of 2,\"",
            "                        f\"found '{cardinality}'.\",",
            "                        error_code=INVALID_PARAMETER_VALUE,",
            "                    )",
            "                if self.positive_class is not None and cardinality != 2:",
            "                    raise MlflowException(",
            "                        f\"`For binary classification problems, \"",
            "                        f\"target column '{self.target_col}' must have a cardinality of 2,\"",
            "                        f\"found '{cardinality}'. `positive_class` was set, \"",
            "                        f\"so we treat this problem as a binary classification problem. \",",
            "                        error_code=INVALID_PARAMETER_VALUE,",
            "                    )",
            "",
            "        ingested_dataset_profile = None",
            "        if not self.skip_data_profiling:",
            "            _logger.debug(\"Profiling ingested dataset\")",
            "            ingested_dataset_profile = get_pandas_data_profiles(",
            "                [[\"Profile of Ingested Dataset\", ingested_df]]",
            "            )",
            "            dataset_profile_path = Path(",
            "                str(os.path.join(output_directory, BaseIngestStep._DATASET_PROFILE_OUTPUT_NAME))",
            "            )",
            "            dataset_profile_path.write_text(ingested_dataset_profile, encoding=\"utf-8\")",
            "            _logger.debug(f\"Wrote dataset profile to '{dataset_profile_path}'\")",
            "",
            "        schema = pd.io.json.build_table_schema(ingested_df, index=False)",
            "",
            "        return self._build_step_card(",
            "            ingested_dataset_profile=ingested_dataset_profile,",
            "            ingested_rows=len(ingested_df),",
            "            schema=schema,",
            "            data_preview=ingested_df.head(),",
            "            dataset_src_location=getattr(self.dataset, \"location\", None),",
            "            dataset_sql=getattr(self.dataset, \"sql\", None),",
            "        )",
            "",
            "    def _build_step_card(",
            "        self,",
            "        ingested_dataset_profile: str,",
            "        ingested_rows: int,",
            "        schema: Dict,",
            "        data_preview: pd.DataFrame = None,",
            "        dataset_src_location: Optional[str] = None,",
            "        dataset_sql: Optional[str] = None,",
            "    ) -> BaseCard:",
            "        \"\"\"",
            "        Constructs a step card instance corresponding to the current ingest step state.",
            "",
            "        :param ingested_dataset_path: The local filesystem path to the ingested parquet dataset",
            "                                      file.",
            "        :param dataset_src_location: The source location of the dataset",
            "                                     (e.g. '/tmp/myfile.parquet', 's3://mybucket/mypath', ...),",
            "                                     if the dataset is a location-based dataset. Either",
            "                                     ``dataset_src_location`` or ``dataset_sql`` must be specified.",
            "        :param dataset_sql: The Spark SQL query string that defines the dataset",
            "                            (e.g. 'SELECT * FROM my_spark_table'), if the dataset is a Spark SQL",
            "                            dataset. Either ``dataset_src_location`` or ``dataset_sql`` must be",
            "                            specified.",
            "        :return: An BaseCard instance corresponding to the current ingest step state.",
            "        \"\"\"",
            "        if dataset_src_location is None and dataset_sql is None:",
            "            raise MlflowException(",
            "                message=(",
            "                    \"Failed to build step card because neither a dataset location nor a\"",
            "                    \" dataset Spark SQL query were specified\"",
            "                ),",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        card = BaseCard(self.recipe_name, self.name)",
            "        if not self.skip_data_profiling:",
            "            (  # Tab #1 -- Ingested dataset profile.",
            "                card.add_tab(\"Data Profile\", \"{{PROFILE}}\").add_pandas_profile(",
            "                    \"PROFILE\", ingested_dataset_profile",
            "                )",
            "            )",
            "        # Tab #2 -- Ingested dataset schema.",
            "        schema_html = BaseCard.render_table(schema[\"fields\"])",
            "        card.add_tab(\"Data Schema\", \"{{SCHEMA}}\").add_html(\"SCHEMA\", schema_html)",
            "",
            "        if data_preview is not None:",
            "            # Tab #3 -- Ingested dataset preview.",
            "            card.add_tab(\"Data Preview\", \"{{DATA_PREVIEW}}\").add_html(",
            "                \"DATA_PREVIEW\", BaseCard.render_table(data_preview)",
            "            )",
            "",
            "        (  # Tab #4 -- Step run summary.",
            "            card.add_tab(",
            "                \"Run Summary\",",
            "                \"{{ INGESTED_ROWS }}\"",
            "                + \"{{ DATA_SOURCE }}\"",
            "                + \"{{ EXE_DURATION }}\"",
            "                + \"{{ LAST_UPDATE_TIME }}\",",
            "            )",
            "            .add_markdown(",
            "                name=\"INGESTED_ROWS\",",
            "                markdown=f\"**Number of rows ingested:** `{ingested_rows}`\",",
            "            )",
            "            .add_markdown(",
            "                name=\"DATA_SOURCE\",",
            "                markdown=(",
            "                    f\"**Dataset source location:** `{dataset_src_location}`\"",
            "                    if dataset_src_location is not None",
            "                    else f\"**Dataset SQL:** `{dataset_sql}`\"",
            "                ),",
            "            )",
            "        )",
            "        return card",
            "",
            "",
            "class IngestStep(BaseIngestStep):",
            "    _DATASET_OUTPUT_NAME = \"dataset.parquet\"",
            "",
            "    def __init__(self, step_config: Dict[str, Any], recipe_root: str):",
            "        super().__init__(step_config, recipe_root)",
            "        self.dataset_output_name = IngestStep._DATASET_OUTPUT_NAME",
            "",
            "    @classmethod",
            "    def from_recipe_config(cls, recipe_config: Dict[str, Any], recipe_root: str):",
            "        ingest_config = recipe_config.get(\"steps\", {}).get(\"ingest\", {})",
            "        target_config = {\"target_col\": recipe_config.get(\"target_col\")}",
            "        if \"positive_class\" in recipe_config:",
            "            target_config[\"positive_class\"] = recipe_config.get(\"positive_class\")",
            "        return cls(",
            "            step_config={",
            "                **ingest_config,",
            "                **target_config,",
            "                **{\"recipe\": recipe_config.get(\"recipe\", \"regression/v1\")},",
            "            },",
            "            recipe_root=recipe_root,",
            "        )",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        return \"ingest\"",
            "",
            "    def get_artifacts(self):",
            "        return [",
            "            DataframeArtifact(",
            "                \"ingested_data\", self.recipe_root, self.name, IngestStep._DATASET_OUTPUT_NAME",
            "            )",
            "        ]",
            "",
            "    def step_class(self):",
            "        return StepClass.TRAINING",
            "",
            "",
            "class IngestScoringStep(BaseIngestStep):",
            "    _DATASET_OUTPUT_NAME = \"scoring-dataset.parquet\"",
            "",
            "    def __init__(self, step_config: Dict[str, Any], recipe_root: str):",
            "        super().__init__(step_config, recipe_root)",
            "        self.dataset_output_name = IngestScoringStep._DATASET_OUTPUT_NAME",
            "",
            "    @classmethod",
            "    def from_recipe_config(cls, recipe_config: Dict[str, Any], recipe_root: str):",
            "        step_config = recipe_config.get(\"steps\", {}).get(\"ingest_scoring\", {})",
            "        step_config[\"recipe\"] = recipe_config.get(\"recipe\")",
            "        return cls(",
            "            step_config=step_config,",
            "            recipe_root=recipe_root,",
            "        )",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        return \"ingest_scoring\"",
            "",
            "    def get_artifacts(self):",
            "        return [",
            "            DataframeArtifact(",
            "                \"ingested_scoring_data\",",
            "                self.recipe_root,",
            "                self.name,",
            "                IngestScoringStep._DATASET_OUTPUT_NAME,",
            "            )",
            "        ]",
            "",
            "    def step_class(self):",
            "        return StepClass.PREDICTION"
        ],
        "afterPatchFile": [
            "import abc",
            "import logging",
            "import os",
            "from pathlib import Path",
            "from typing import Any, Dict, Optional",
            "",
            "import pandas as pd",
            "",
            "from mlflow.exceptions import MlflowException",
            "from mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE",
            "from mlflow.recipes.artifacts import DataframeArtifact",
            "from mlflow.recipes.cards import BaseCard",
            "from mlflow.recipes.step import BaseStep, StepClass",
            "from mlflow.recipes.steps.ingest.datasets import (",
            "    CustomDataset,",
            "    DeltaTableDataset,",
            "    ParquetDataset,",
            "    SparkSqlDataset,",
            ")",
            "from mlflow.recipes.utils.step import get_pandas_data_profiles, validate_classification_config",
            "from mlflow.utils.file_utils import read_parquet_as_pandas_df",
            "",
            "_logger = logging.getLogger(__name__)",
            "",
            "",
            "class BaseIngestStep(BaseStep, metaclass=abc.ABCMeta):",
            "    _DATASET_FORMAT_SPARK_TABLE = \"spark_table\"",
            "    _DATASET_FORMAT_DELTA = \"delta\"",
            "    _DATASET_FORMAT_PARQUET = \"parquet\"",
            "    _DATASET_PROFILE_OUTPUT_NAME = \"dataset_profile.html\"",
            "    _STEP_CARD_OUTPUT_NAME = \"card.pkl\"",
            "    _SUPPORTED_DATASETS = [",
            "        ParquetDataset,",
            "        DeltaTableDataset,",
            "        SparkSqlDataset,",
            "        # NB: The custom dataset is deliberately listed last as a catch-all for any",
            "        # format not matched by the datasets above. When mapping a format to a dataset,",
            "        # datasets are explored in the listed order",
            "        CustomDataset,",
            "    ]",
            "",
            "    def _validate_and_apply_step_config(self):",
            "        dataset_format = self.step_config.get(\"using\")",
            "        if not dataset_format:",
            "            raise MlflowException(",
            "                message=(",
            "                    \"Dataset format must be specified via the `using` key within the `ingest`\"",
            "                    \" section of recipe.yaml\"",
            "                ),",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        if self.step_class() == StepClass.TRAINING:",
            "            self.target_col = self.step_config.get(\"target_col\")",
            "            if self.target_col is None:",
            "                raise MlflowException(",
            "                    \"Missing target_col config in recipe config.\",",
            "                    error_code=INVALID_PARAMETER_VALUE,",
            "                )",
            "            self.positive_class = self.step_config.get(\"positive_class\")",
            "        for dataset_class in BaseIngestStep._SUPPORTED_DATASETS:",
            "            if dataset_class.handles_format(dataset_format):",
            "                self.dataset = dataset_class.from_config(",
            "                    dataset_config=self.step_config,",
            "                    recipe_root=self.recipe_root,",
            "                )",
            "                break",
            "        else:",
            "            raise MlflowException(",
            "                message=f\"Unrecognized dataset format: {dataset_format}\",",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "        self.skip_data_profiling = self.step_config.get(\"skip_data_profiling\", False)",
            "",
            "    def _run(self, output_directory: str) -> BaseCard:",
            "        dataset_dst_path = os.path.abspath(os.path.join(output_directory, self.dataset_output_name))",
            "        self.dataset.resolve_to_parquet(",
            "            dst_path=dataset_dst_path,",
            "        )",
            "        _logger.debug(\"Successfully stored data in parquet format at '%s'\", dataset_dst_path)",
            "",
            "        ingested_df = read_parquet_as_pandas_df(data_parquet_path=dataset_dst_path)",
            "        if self.step_class() == StepClass.TRAINING:",
            "            if self.target_col not in ingested_df.columns:",
            "                raise MlflowException(",
            "                    f\"Target column '{self.target_col}' not found in ingested dataset.\",",
            "                    error_code=INVALID_PARAMETER_VALUE,",
            "                )",
            "            if self.task == \"classification\":",
            "                validate_classification_config(",
            "                    self.task, self.positive_class, ingested_df, self.target_col",
            "                )",
            "                cardinality = ingested_df[self.target_col].nunique()",
            "                if cardinality > 2 and self.positive_class is not None:",
            "                    raise MlflowException(",
            "                        f\"Target column '{self.target_col}' must have a cardinality of 2,\"",
            "                        f\"found '{cardinality}'.\",",
            "                        error_code=INVALID_PARAMETER_VALUE,",
            "                    )",
            "                if self.positive_class is not None and cardinality != 2:",
            "                    raise MlflowException(",
            "                        f\"`For binary classification problems, \"",
            "                        f\"target column '{self.target_col}' must have a cardinality of 2,\"",
            "                        f\"found '{cardinality}'. `positive_class` was set, \"",
            "                        f\"so we treat this problem as a binary classification problem. \",",
            "                        error_code=INVALID_PARAMETER_VALUE,",
            "                    )",
            "",
            "        ingested_dataset_profile = None",
            "        if not self.skip_data_profiling:",
            "            _logger.debug(\"Profiling ingested dataset\")",
            "            ingested_dataset_profile = get_pandas_data_profiles(",
            "                [[\"Profile of Ingested Dataset\", ingested_df]]",
            "            )",
            "            dataset_profile_path = Path(",
            "                str(os.path.join(output_directory, BaseIngestStep._DATASET_PROFILE_OUTPUT_NAME))",
            "            )",
            "            dataset_profile_path.write_text(ingested_dataset_profile, encoding=\"utf-8\")",
            "            _logger.debug(f\"Wrote dataset profile to '{dataset_profile_path}'\")",
            "",
            "        schema = pd.io.json.build_table_schema(ingested_df, index=False)",
            "",
            "        return self._build_step_card(",
            "            ingested_dataset_profile=ingested_dataset_profile,",
            "            ingested_rows=len(ingested_df),",
            "            schema=schema,",
            "            data_preview=ingested_df.head(),",
            "            dataset_src_location=getattr(self.dataset, \"location\", None),",
            "            dataset_sql=getattr(self.dataset, \"sql\", None),",
            "        )",
            "",
            "    def _build_step_card(",
            "        self,",
            "        ingested_dataset_profile: str,",
            "        ingested_rows: int,",
            "        schema: Dict,",
            "        data_preview: pd.DataFrame = None,",
            "        dataset_src_location: Optional[str] = None,",
            "        dataset_sql: Optional[str] = None,",
            "    ) -> BaseCard:",
            "        \"\"\"",
            "        Constructs a step card instance corresponding to the current ingest step state.",
            "",
            "        :param ingested_dataset_path: The local filesystem path to the ingested parquet dataset",
            "                                      file.",
            "        :param dataset_src_location: The source location of the dataset",
            "                                     (e.g. '/tmp/myfile.parquet', 's3://mybucket/mypath', ...),",
            "                                     if the dataset is a location-based dataset. Either",
            "                                     ``dataset_src_location`` or ``dataset_sql`` must be specified.",
            "        :param dataset_sql: The Spark SQL query string that defines the dataset",
            "                            (e.g. 'SELECT * FROM my_spark_table'), if the dataset is a Spark SQL",
            "                            dataset. Either ``dataset_src_location`` or ``dataset_sql`` must be",
            "                            specified.",
            "        :return: An BaseCard instance corresponding to the current ingest step state.",
            "        \"\"\"",
            "        if dataset_src_location is None and dataset_sql is None:",
            "            raise MlflowException(",
            "                message=(",
            "                    \"Failed to build step card because neither a dataset location nor a\"",
            "                    \" dataset Spark SQL query were specified\"",
            "                ),",
            "                error_code=INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        card = BaseCard(self.recipe_name, self.name)",
            "        if not self.skip_data_profiling:",
            "            (  # Tab #1 -- Ingested dataset profile.",
            "                card.add_tab(\"Data Profile\", \"{{PROFILE}}\").add_pandas_profile(",
            "                    \"PROFILE\", ingested_dataset_profile",
            "                )",
            "            )",
            "        # Tab #2 -- Ingested dataset schema.",
            "        schema_html = BaseCard.render_table(schema[\"fields\"])",
            "        card.add_tab(\"Data Schema\", \"{{SCHEMA|e}}\").add_html(\"SCHEMA\", schema_html)",
            "",
            "        if data_preview is not None:",
            "            # Tab #3 -- Ingested dataset preview.",
            "            card.add_tab(\"Data Preview\", \"{{DATA_PREVIEW}}\").add_html(",
            "                \"DATA_PREVIEW\", BaseCard.render_table(data_preview)",
            "            )",
            "",
            "        (  # Tab #4 -- Step run summary.",
            "            card.add_tab(",
            "                \"Run Summary\",",
            "                \"{{ INGESTED_ROWS }}\"",
            "                + \"{{ DATA_SOURCE }}\"",
            "                + \"{{ EXE_DURATION }}\"",
            "                + \"{{ LAST_UPDATE_TIME }}\",",
            "            )",
            "            .add_markdown(",
            "                name=\"INGESTED_ROWS\",",
            "                markdown=f\"**Number of rows ingested:** `{ingested_rows}`\",",
            "            )",
            "            .add_markdown(",
            "                name=\"DATA_SOURCE\",",
            "                markdown=(",
            "                    f\"**Dataset source location:** `{dataset_src_location}`\"",
            "                    if dataset_src_location is not None",
            "                    else f\"**Dataset SQL:** `{dataset_sql}`\"",
            "                ),",
            "            )",
            "        )",
            "        return card",
            "",
            "",
            "class IngestStep(BaseIngestStep):",
            "    _DATASET_OUTPUT_NAME = \"dataset.parquet\"",
            "",
            "    def __init__(self, step_config: Dict[str, Any], recipe_root: str):",
            "        super().__init__(step_config, recipe_root)",
            "        self.dataset_output_name = IngestStep._DATASET_OUTPUT_NAME",
            "",
            "    @classmethod",
            "    def from_recipe_config(cls, recipe_config: Dict[str, Any], recipe_root: str):",
            "        ingest_config = recipe_config.get(\"steps\", {}).get(\"ingest\", {})",
            "        target_config = {\"target_col\": recipe_config.get(\"target_col\")}",
            "        if \"positive_class\" in recipe_config:",
            "            target_config[\"positive_class\"] = recipe_config.get(\"positive_class\")",
            "        return cls(",
            "            step_config={",
            "                **ingest_config,",
            "                **target_config,",
            "                **{\"recipe\": recipe_config.get(\"recipe\", \"regression/v1\")},",
            "            },",
            "            recipe_root=recipe_root,",
            "        )",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        return \"ingest\"",
            "",
            "    def get_artifacts(self):",
            "        return [",
            "            DataframeArtifact(",
            "                \"ingested_data\", self.recipe_root, self.name, IngestStep._DATASET_OUTPUT_NAME",
            "            )",
            "        ]",
            "",
            "    def step_class(self):",
            "        return StepClass.TRAINING",
            "",
            "",
            "class IngestScoringStep(BaseIngestStep):",
            "    _DATASET_OUTPUT_NAME = \"scoring-dataset.parquet\"",
            "",
            "    def __init__(self, step_config: Dict[str, Any], recipe_root: str):",
            "        super().__init__(step_config, recipe_root)",
            "        self.dataset_output_name = IngestScoringStep._DATASET_OUTPUT_NAME",
            "",
            "    @classmethod",
            "    def from_recipe_config(cls, recipe_config: Dict[str, Any], recipe_root: str):",
            "        step_config = recipe_config.get(\"steps\", {}).get(\"ingest_scoring\", {})",
            "        step_config[\"recipe\"] = recipe_config.get(\"recipe\")",
            "        return cls(",
            "            step_config=step_config,",
            "            recipe_root=recipe_root,",
            "        )",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        return \"ingest_scoring\"",
            "",
            "    def get_artifacts(self):",
            "        return [",
            "            DataframeArtifact(",
            "                \"ingested_scoring_data\",",
            "                self.recipe_root,",
            "                self.name,",
            "                IngestScoringStep._DATASET_OUTPUT_NAME,",
            "            )",
            "        ]",
            "",
            "    def step_class(self):",
            "        return StepClass.PREDICTION"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "174": [
                "BaseIngestStep",
                "_build_step_card"
            ]
        },
        "addLocation": []
    }
}