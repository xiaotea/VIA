{
    "Products/CMFPlone/CatalogTool.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 394,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "     __call__ = searchResults"
            },
            "2": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 396,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+    def search(self, *args, **kw):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+        # Wrap search() the same way that searchResults() is"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+        query = {}"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+        if args:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+            query = args[0]"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+        elif 'query_request' in kw:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+            query = kw.get['query_request']"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+        kw['query_request'] = query.copy()"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+        user = _getAuthenticatedUser(self)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+        query['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+        if not _checkPermission(AccessInactivePortalContent, self):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+            query['effectiveRange'] = DateTime()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+        kw['query_request'] = query"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+        return super(CatalogTool, self).search(**kw)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 418,
                "PatchRowcode": "     security.declareProtected(ManageZCatalogEntries, 'clearFindAndRebuild')"
            },
            "25": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 419,
                "PatchRowcode": "     def clearFindAndRebuild(self):"
            },
            "26": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 420,
                "PatchRowcode": "         \"\"\"Empties catalog, then finds all contentish objects (i.e. objects"
            }
        },
        "frontPatchFile": [
            "import re",
            "import time",
            "import urllib",
            "",
            "from AccessControl import ClassSecurityInfo",
            "from AccessControl.Permissions import manage_zcatalog_entries as \\",
            "    ManageZCatalogEntries",
            "from AccessControl.Permissions import search_zcatalog as SearchZCatalog",
            "from AccessControl.PermissionRole import rolesForPermissionOn",
            "from Acquisition import aq_base",
            "from Acquisition import aq_inner",
            "from Acquisition import aq_parent",
            "from App.class_init import InitializeClass",
            "from App.special_dtml import DTMLFile",
            "from BTrees.Length import Length",
            "from DateTime import DateTime",
            "from OFS.interfaces import IOrderedContainer",
            "from plone.indexer import indexer",
            "from plone.indexer.interfaces import IIndexableObject",
            "from Products.CMFCore.utils import _checkPermission",
            "from Products.CMFCore.utils import _getAuthenticatedUser",
            "from Products.CMFCore.utils import getToolByName",
            "from Products.CMFCore.CatalogTool import _mergedLocalRoles",
            "from Products.CMFCore.CatalogTool import CatalogTool as BaseTool",
            "from Products.CMFCore.permissions import AccessInactivePortalContent",
            "from Products.ZCatalog.ZCatalog import ZCatalog",
            "from Products.Archetypes.interfaces import IExtensibleMetadata",
            "from zope.component import queryMultiAdapter",
            "from zope.interface import Interface",
            "from zope.interface import implements",
            "from zope.interface import providedBy",
            "",
            "from Products.CMFPlone.PloneBaseTool import PloneBaseTool",
            "from Products.CMFPlone.interfaces import INonStructuralFolder",
            "from Products.CMFPlone.utils import base_hasattr",
            "from Products.CMFPlone.utils import safe_callable",
            "from Products.CMFPlone.utils import safe_unicode",
            "from Products.CMFPlone.interfaces import IPloneCatalogTool",
            "",
            "from plone.i18n.normalizer.base import mapUnicode",
            "",
            "_marker = object()",
            "",
            "MAX_SORTABLE_TITLE = 40",
            "BLACKLISTED_INTERFACES = frozenset((",
            "    'AccessControl.interfaces.IOwned',",
            "    'AccessControl.interfaces.IPermissionMappingSupport',",
            "    'AccessControl.interfaces.IRoleManager',",
            "    'Acquisition.interfaces.IAcquirer',",
            "    'App.interfaces.INavigation',",
            "    'App.interfaces.IPersistentExtra',",
            "    'App.interfaces.IUndoSupport',",
            "    'archetypes.schemaextender.interfaces.IExtensible',",
            "    'OFS.interfaces.ICopyContainer',",
            "    'OFS.interfaces.ICopySource',",
            "    'OFS.interfaces.IFindSupport',",
            "    'OFS.interfaces.IFolder',",
            "    'OFS.interfaces.IFTPAccess',",
            "    'OFS.interfaces.IItem',",
            "    'OFS.interfaces.IManageable',",
            "    'OFS.interfaces.IObjectManager',",
            "    'OFS.interfaces.IOrderedContainer',",
            "    'OFS.interfaces.IPropertyManager',",
            "    'OFS.interfaces.ISimpleItem',",
            "    'OFS.interfaces.ITraversable',",
            "    'OFS.interfaces.IZopeObject',",
            "    'persistent.interfaces.IPersistent',",
            "    'plone.app.folder.bbb.IArchivable',",
            "    'plone.app.folder.bbb.IPhotoAlbumAble',",
            "    'plone.app.folder.folder.IATUnifiedFolder',",
            "    'plone.app.imaging.interfaces.IBaseObject',",
            "    'plone.app.iterate.interfaces.IIterateAware',",
            "    'plone.app.kss.interfaces.IPortalObject',",
            "    'plone.contentrules.engine.interfaces.IRuleAssignable',",
            "    'plone.folder.interfaces.IFolder',",
            "    'plone.folder.interfaces.IOrderableFolder',",
            "    'plone.locking.interfaces.ITTWLockable',",
            "    'plone.portlets.interfaces.ILocalPortletAssignable',",
            "    'plone.uuid.interfaces.IUUIDAware',",
            "    'Products.Archetypes.interfaces.athistoryaware.IATHistoryAware',",
            "    'Products.Archetypes.interfaces.base.IBaseContent',",
            "    'Products.Archetypes.interfaces.base.IBaseFolder',",
            "    'Products.Archetypes.interfaces.base.IBaseObject',",
            "    'Products.Archetypes.interfaces.metadata.IExtensibleMetadata',",
            "    'Products.Archetypes.interfaces.referenceable.IReferenceable',",
            "    'Products.ATContentTypes.exportimport.content.IDisabledExport',",
            "    'Products.ATContentTypes.interfaces.folder.IATBTreeFolder',",
            "    'Products.ATContentTypes.interfaces.interfaces.IATContentType',",
            "    'Products.ATContentTypes.interfaces.interfaces.IHistoryAware',",
            "    'Products.ATContentTypes.interfaces.interfaces.ITextContent',",
            "    'Products.CMFCore.interfaces._content.ICatalogableDublinCore',",
            "    'Products.CMFCore.interfaces._content.ICatalogAware',",
            "    'Products.CMFCore.interfaces._content.IDublinCore',",
            "    'Products.CMFCore.interfaces._content.IDynamicType',",
            "    'Products.CMFCore.interfaces._content.IFolderish',",
            "    'Products.CMFCore.interfaces._content.IMinimalDublinCore',",
            "    'Products.CMFCore.interfaces._content.IMutableDublinCore',",
            "    'Products.CMFCore.interfaces._content.IMutableMinimalDublinCore',",
            "    'Products.CMFCore.interfaces._content.IOpaqueItemManager',",
            "    'Products.CMFCore.interfaces._content.IWorkflowAware',",
            "    'Products.CMFDynamicViewFTI.interfaces.IBrowserDefault',",
            "    'Products.CMFDynamicViewFTI.interfaces.ISelectableBrowserDefault',",
            "    'Products.CMFPlone.interfaces.constrains.IConstrainTypes',",
            "    'Products.CMFPlone.interfaces.constrains.ISelectableConstrainTypes',",
            "    'Products.GenericSetup.interfaces.IDAVAware',",
            "    'webdav.EtagSupport.EtagBaseInterface',",
            "    'webdav.interfaces.IDAVCollection',",
            "    'webdav.interfaces.IDAVResource',",
            "    'zope.annotation.interfaces.IAnnotatable',",
            "    'zope.annotation.interfaces.IAttributeAnnotatable',",
            "    'zope.component.interfaces.IPossibleSite',",
            "    'zope.container.interfaces.IContainer',",
            "    'zope.container.interfaces.IItemContainer',",
            "    'zope.container.interfaces.IReadContainer',",
            "    'zope.container.interfaces.ISimpleReadContainer',",
            "    'zope.container.interfaces.IWriteContainer',",
            "    'zope.interface.common.mapping.IEnumerableMapping',",
            "    'zope.interface.common.mapping.IItemMapping',",
            "    'zope.interface.common.mapping.IReadMapping',",
            "    'zope.interface.Interface',",
            "))",
            "",
            "",
            "@indexer(Interface)",
            "def allowedRolesAndUsers(obj):",
            "    \"\"\"Return a list of roles and users with View permission.",
            "    Used to filter out items you're not allowed to see.",
            "    \"\"\"",
            "    allowed = {}",
            "    for r in rolesForPermissionOn('View', obj):",
            "        allowed[r] = 1",
            "    # shortcut roles and only index the most basic system role if the object",
            "    # is viewable by either of those",
            "    if 'Anonymous' in allowed:",
            "        return ['Anonymous']",
            "    elif 'Authenticated' in allowed:",
            "        return ['Authenticated']",
            "    localroles = {}",
            "    try:",
            "        acl_users = getToolByName(obj, 'acl_users', None)",
            "        if acl_users is not None:",
            "            localroles = acl_users._getAllLocalRoles(obj)",
            "    except AttributeError:",
            "        localroles = _mergedLocalRoles(obj)",
            "    for user, roles in localroles.items():",
            "        for role in roles:",
            "            if role in allowed:",
            "                allowed['user:' + user] = 1",
            "    if 'Owner' in allowed:",
            "        del allowed['Owner']",
            "    return list(allowed.keys())",
            "",
            "",
            "@indexer(Interface)",
            "def object_provides(obj):",
            "    return tuple([i.__identifier__ for i in providedBy(obj).flattened()",
            "        if i.__identifier__ not in BLACKLISTED_INTERFACES])",
            "",
            "",
            "def zero_fill(matchobj):",
            "    return matchobj.group().zfill(4)",
            "",
            "num_sort_regex = re.compile('\\d+')",
            "",
            "",
            "@indexer(Interface)",
            "def sortable_title(obj):",
            "    \"\"\" Helper method for to provide FieldIndex for Title.",
            "    \"\"\"",
            "    title = getattr(obj, 'Title', None)",
            "    if title is not None:",
            "        if safe_callable(title):",
            "            title = title()",
            "",
            "        if isinstance(title, basestring):",
            "            # Ignore case, normalize accents, strip spaces",
            "            sortabletitle = mapUnicode(safe_unicode(title)).lower().strip()",
            "            # Replace numbers with zero filled numbers",
            "            sortabletitle = num_sort_regex.sub(zero_fill, sortabletitle)",
            "            # Truncate to prevent bloat, take bits from start and end",
            "            if len(sortabletitle) > MAX_SORTABLE_TITLE:",
            "                start = sortabletitle[:(MAX_SORTABLE_TITLE - 13)]",
            "                end = sortabletitle[-10:]",
            "                sortabletitle = start + '...' + end",
            "            return sortabletitle.encode('utf-8')",
            "    return ''",
            "",
            "",
            "@indexer(Interface)",
            "def getObjPositionInParent(obj):",
            "    \"\"\" Helper method for catalog based folder contents.",
            "    \"\"\"",
            "    parent = aq_parent(aq_inner(obj))",
            "    ordered = IOrderedContainer(parent, None)",
            "    if ordered is not None:",
            "        return ordered.getObjectPosition(obj.getId())",
            "    return 0",
            "",
            "SIZE_CONST = {'KB': 1024, 'MB': 1024 * 1024, 'GB': 1024 * 1024 * 1024}",
            "SIZE_ORDER = ('GB', 'MB', 'KB')",
            "",
            "",
            "@indexer(Interface)",
            "def getObjSize(obj):",
            "    \"\"\" Helper method for catalog based folder contents.",
            "    \"\"\"",
            "    smaller = SIZE_ORDER[-1]",
            "",
            "    if base_hasattr(obj, 'get_size'):",
            "        size = obj.get_size()",
            "    else:",
            "        size = 0",
            "",
            "    # if the size is a float, then make it an int",
            "    # happens for large files",
            "    try:",
            "        size = int(size)",
            "    except (ValueError, TypeError):",
            "        pass",
            "",
            "    if not size:",
            "        return '0 %s' % smaller",
            "",
            "    if isinstance(size, (int, long)):",
            "        if size < SIZE_CONST[smaller]:",
            "            return '1 %s' % smaller",
            "        for c in SIZE_ORDER:",
            "            if size / SIZE_CONST[c] > 0:",
            "                break",
            "        return '%.1f %s' % (float(size / float(SIZE_CONST[c])), c)",
            "    return size",
            "",
            "",
            "@indexer(Interface)",
            "def is_folderish(obj):",
            "    \"\"\"Should this item be treated as a folder?",
            "",
            "    Checks isPrincipiaFolderish, as well as the INonStructuralFolder",
            "    interfaces.",
            "    \"\"\"",
            "    # If the object explicitly states it doesn't want to be treated as a",
            "    # structural folder, don't argue with it.",
            "    folderish = bool(getattr(aq_base(obj), 'isPrincipiaFolderish', False))",
            "    if not folderish:",
            "        return False",
            "    elif INonStructuralFolder.providedBy(obj):",
            "        return False",
            "    else:",
            "        return folderish",
            "",
            "",
            "@indexer(Interface)",
            "def is_default_page(obj):",
            "    \"\"\"Is this the default page in its folder",
            "    \"\"\"",
            "    ptool = getToolByName(obj, 'plone_utils', None)",
            "    if ptool is None:",
            "        return False",
            "    return ptool.isDefaultPage(obj)",
            "",
            "",
            "@indexer(Interface)",
            "def getIcon(obj):",
            "    \"\"\"Make sure we index icon relative to portal\"\"\"",
            "    return obj.getIcon(True)",
            "",
            "",
            "@indexer(IExtensibleMetadata)",
            "def location(obj):",
            "    return obj.getField('location').get(obj)",
            "",
            "",
            "",
            "",
            "class CatalogTool(PloneBaseTool, BaseTool):",
            "    \"\"\"Plone's catalog tool\"\"\"",
            "",
            "    implements(IPloneCatalogTool)",
            "",
            "    meta_type = 'Plone Catalog Tool'",
            "    security = ClassSecurityInfo()",
            "    toolicon = 'skins/plone_images/book_icon.png'",
            "    _counter = None",
            "",
            "    manage_catalogAdvanced = DTMLFile('www/catalogAdvanced', globals())",
            "",
            "    manage_options = (",
            "        {'action': 'manage_main', 'label': 'Contents'},",
            "        {'action': 'manage_catalogView', 'label': 'Catalog'},",
            "        {'action': 'manage_catalogIndexes', 'label': 'Indexes'},",
            "        {'action': 'manage_catalogSchema', 'label': 'Metadata'},",
            "        {'action': 'manage_catalogAdvanced', 'label': 'Advanced'},",
            "        {'action': 'manage_catalogReport', 'label': 'Query Report'},",
            "        {'action': 'manage_catalogPlan', 'label': 'Query Plan'},",
            "        {'action': 'manage_propertiesForm', 'label': 'Properties'},",
            "    )",
            "",
            "    def __init__(self):",
            "        ZCatalog.__init__(self, self.getId())",
            "",
            "    def _removeIndex(self, index):",
            "        \"\"\"Safe removal of an index.",
            "        \"\"\"",
            "        try:",
            "            self.manage_delIndex(index)",
            "        except:",
            "            pass",
            "",
            "    def _listAllowedRolesAndUsers(self, user):",
            "        \"\"\"Makes sure the list includes the user's groups.",
            "        \"\"\"",
            "        result = user.getRoles()",
            "        if 'Anonymous' in result:",
            "            # The anonymous user has no further roles",
            "            return ['Anonymous']",
            "        result = list(result)",
            "        if hasattr(aq_base(user), 'getGroups'):",
            "            groups = ['user:%s' % x for x in user.getGroups()]",
            "            if groups:",
            "                result = result + groups",
            "        # Order the arguments from small to large sets",
            "        result.insert(0, 'user:%s' % user.getId())",
            "        result.append('Anonymous')",
            "        return result",
            "",
            "    security.declarePrivate('indexObject')",
            "    def indexObject(self, object, idxs=None):",
            "        \"\"\"Add object to catalog.",
            "",
            "        The optional idxs argument is a list of specific indexes",
            "        to populate (all of them by default).",
            "        \"\"\"",
            "        if idxs is None:",
            "            idxs = []",
            "        self.reindexObject(object, idxs)",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'catalog_object')",
            "    def catalog_object(self, object, uid=None, idxs=None,",
            "                       update_metadata=1, pghandler=None):",
            "        if idxs is None:",
            "            idxs = []",
            "        self._increment_counter()",
            "",
            "        w = object",
            "        if not IIndexableObject.providedBy(object):",
            "            # This is the CMF 2.2 compatible approach, which should be used",
            "            # going forward",
            "            wrapper = queryMultiAdapter((object, self), IIndexableObject)",
            "            if wrapper is not None:",
            "                w = wrapper",
            "",
            "        ZCatalog.catalog_object(self, w, uid, idxs,",
            "                                update_metadata, pghandler=pghandler)",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'catalog_object')",
            "    def uncatalog_object(self, *args, **kwargs):",
            "        self._increment_counter()",
            "        return BaseTool.uncatalog_object(self, *args, **kwargs)",
            "",
            "    def _increment_counter(self):",
            "        if self._counter is None:",
            "            self._counter = Length()",
            "        self._counter.change(1)",
            "",
            "    security.declarePrivate('getCounter')",
            "    def getCounter(self):",
            "        return self._counter is not None and self._counter() or 0",
            "",
            "    security.declareProtected(SearchZCatalog, 'searchResults')",
            "    def searchResults(self, REQUEST=None, **kw):",
            "        \"\"\"Calls ZCatalog.searchResults with extra arguments that",
            "        limit the results to what the user is allowed to see.",
            "",
            "        This version uses the 'effectiveRange' DateRangeIndex.",
            "",
            "        It also accepts a keyword argument show_inactive to disable",
            "        effectiveRange checking entirely even for those without portal",
            "        wide AccessInactivePortalContent permission.",
            "        \"\"\"",
            "        kw = kw.copy()",
            "        show_inactive = kw.get('show_inactive', False)",
            "        if isinstance(REQUEST, dict) and not show_inactive:",
            "            show_inactive = 'show_inactive' in REQUEST",
            "",
            "        user = _getAuthenticatedUser(self)",
            "        kw['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)",
            "",
            "        if not show_inactive and not _checkPermission(",
            "            AccessInactivePortalContent, self):",
            "",
            "            kw['effectiveRange'] = DateTime()",
            "",
            "        return ZCatalog.searchResults(self, REQUEST, **kw)",
            "",
            "    __call__ = searchResults",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'clearFindAndRebuild')",
            "    def clearFindAndRebuild(self):",
            "        \"\"\"Empties catalog, then finds all contentish objects (i.e. objects",
            "           with an indexObject method), and reindexes them.",
            "           This may take a long time.",
            "        \"\"\"",
            "        def indexObject(obj, path):",
            "            if (base_hasattr(obj, 'indexObject') and",
            "                safe_callable(obj.indexObject)):",
            "                try:",
            "                    obj.indexObject()",
            "                except TypeError:",
            "                    # Catalogs have 'indexObject' as well, but they",
            "                    # take different args, and will fail",
            "                    pass",
            "        self.manage_catalogClear()",
            "        portal = aq_parent(aq_inner(self))",
            "        portal.ZopeFindAndApply(portal, search_sub=True,",
            "            apply_func=indexObject)",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'manage_catalogRebuild')",
            "    def manage_catalogRebuild(self, RESPONSE=None, URL1=None):",
            "        \"\"\"Clears the catalog and indexes all objects with an 'indexObject'",
            "        method. This may take a long time.",
            "        \"\"\"",
            "        elapse = time.time()",
            "        c_elapse = time.clock()",
            "",
            "        self.clearFindAndRebuild()",
            "",
            "        elapse = time.time() - elapse",
            "        c_elapse = time.clock() - c_elapse",
            "",
            "        if RESPONSE is not None:",
            "            RESPONSE.redirect(",
            "              URL1 + '/manage_catalogAdvanced?manage_tabs_message=' +",
            "              urllib.quote('Catalog Rebuilt\\n'",
            "                           'Total time: %s\\n'",
            "                           'Total CPU time: %s'",
            "                                % (repr(elapse), repr(c_elapse))))",
            "",
            "InitializeClass(CatalogTool)"
        ],
        "afterPatchFile": [
            "import re",
            "import time",
            "import urllib",
            "",
            "from AccessControl import ClassSecurityInfo",
            "from AccessControl.Permissions import manage_zcatalog_entries as \\",
            "    ManageZCatalogEntries",
            "from AccessControl.Permissions import search_zcatalog as SearchZCatalog",
            "from AccessControl.PermissionRole import rolesForPermissionOn",
            "from Acquisition import aq_base",
            "from Acquisition import aq_inner",
            "from Acquisition import aq_parent",
            "from App.class_init import InitializeClass",
            "from App.special_dtml import DTMLFile",
            "from BTrees.Length import Length",
            "from DateTime import DateTime",
            "from OFS.interfaces import IOrderedContainer",
            "from plone.indexer import indexer",
            "from plone.indexer.interfaces import IIndexableObject",
            "from Products.CMFCore.utils import _checkPermission",
            "from Products.CMFCore.utils import _getAuthenticatedUser",
            "from Products.CMFCore.utils import getToolByName",
            "from Products.CMFCore.CatalogTool import _mergedLocalRoles",
            "from Products.CMFCore.CatalogTool import CatalogTool as BaseTool",
            "from Products.CMFCore.permissions import AccessInactivePortalContent",
            "from Products.ZCatalog.ZCatalog import ZCatalog",
            "from Products.Archetypes.interfaces import IExtensibleMetadata",
            "from zope.component import queryMultiAdapter",
            "from zope.interface import Interface",
            "from zope.interface import implements",
            "from zope.interface import providedBy",
            "",
            "from Products.CMFPlone.PloneBaseTool import PloneBaseTool",
            "from Products.CMFPlone.interfaces import INonStructuralFolder",
            "from Products.CMFPlone.utils import base_hasattr",
            "from Products.CMFPlone.utils import safe_callable",
            "from Products.CMFPlone.utils import safe_unicode",
            "from Products.CMFPlone.interfaces import IPloneCatalogTool",
            "",
            "from plone.i18n.normalizer.base import mapUnicode",
            "",
            "_marker = object()",
            "",
            "MAX_SORTABLE_TITLE = 40",
            "BLACKLISTED_INTERFACES = frozenset((",
            "    'AccessControl.interfaces.IOwned',",
            "    'AccessControl.interfaces.IPermissionMappingSupport',",
            "    'AccessControl.interfaces.IRoleManager',",
            "    'Acquisition.interfaces.IAcquirer',",
            "    'App.interfaces.INavigation',",
            "    'App.interfaces.IPersistentExtra',",
            "    'App.interfaces.IUndoSupport',",
            "    'archetypes.schemaextender.interfaces.IExtensible',",
            "    'OFS.interfaces.ICopyContainer',",
            "    'OFS.interfaces.ICopySource',",
            "    'OFS.interfaces.IFindSupport',",
            "    'OFS.interfaces.IFolder',",
            "    'OFS.interfaces.IFTPAccess',",
            "    'OFS.interfaces.IItem',",
            "    'OFS.interfaces.IManageable',",
            "    'OFS.interfaces.IObjectManager',",
            "    'OFS.interfaces.IOrderedContainer',",
            "    'OFS.interfaces.IPropertyManager',",
            "    'OFS.interfaces.ISimpleItem',",
            "    'OFS.interfaces.ITraversable',",
            "    'OFS.interfaces.IZopeObject',",
            "    'persistent.interfaces.IPersistent',",
            "    'plone.app.folder.bbb.IArchivable',",
            "    'plone.app.folder.bbb.IPhotoAlbumAble',",
            "    'plone.app.folder.folder.IATUnifiedFolder',",
            "    'plone.app.imaging.interfaces.IBaseObject',",
            "    'plone.app.iterate.interfaces.IIterateAware',",
            "    'plone.app.kss.interfaces.IPortalObject',",
            "    'plone.contentrules.engine.interfaces.IRuleAssignable',",
            "    'plone.folder.interfaces.IFolder',",
            "    'plone.folder.interfaces.IOrderableFolder',",
            "    'plone.locking.interfaces.ITTWLockable',",
            "    'plone.portlets.interfaces.ILocalPortletAssignable',",
            "    'plone.uuid.interfaces.IUUIDAware',",
            "    'Products.Archetypes.interfaces.athistoryaware.IATHistoryAware',",
            "    'Products.Archetypes.interfaces.base.IBaseContent',",
            "    'Products.Archetypes.interfaces.base.IBaseFolder',",
            "    'Products.Archetypes.interfaces.base.IBaseObject',",
            "    'Products.Archetypes.interfaces.metadata.IExtensibleMetadata',",
            "    'Products.Archetypes.interfaces.referenceable.IReferenceable',",
            "    'Products.ATContentTypes.exportimport.content.IDisabledExport',",
            "    'Products.ATContentTypes.interfaces.folder.IATBTreeFolder',",
            "    'Products.ATContentTypes.interfaces.interfaces.IATContentType',",
            "    'Products.ATContentTypes.interfaces.interfaces.IHistoryAware',",
            "    'Products.ATContentTypes.interfaces.interfaces.ITextContent',",
            "    'Products.CMFCore.interfaces._content.ICatalogableDublinCore',",
            "    'Products.CMFCore.interfaces._content.ICatalogAware',",
            "    'Products.CMFCore.interfaces._content.IDublinCore',",
            "    'Products.CMFCore.interfaces._content.IDynamicType',",
            "    'Products.CMFCore.interfaces._content.IFolderish',",
            "    'Products.CMFCore.interfaces._content.IMinimalDublinCore',",
            "    'Products.CMFCore.interfaces._content.IMutableDublinCore',",
            "    'Products.CMFCore.interfaces._content.IMutableMinimalDublinCore',",
            "    'Products.CMFCore.interfaces._content.IOpaqueItemManager',",
            "    'Products.CMFCore.interfaces._content.IWorkflowAware',",
            "    'Products.CMFDynamicViewFTI.interfaces.IBrowserDefault',",
            "    'Products.CMFDynamicViewFTI.interfaces.ISelectableBrowserDefault',",
            "    'Products.CMFPlone.interfaces.constrains.IConstrainTypes',",
            "    'Products.CMFPlone.interfaces.constrains.ISelectableConstrainTypes',",
            "    'Products.GenericSetup.interfaces.IDAVAware',",
            "    'webdav.EtagSupport.EtagBaseInterface',",
            "    'webdav.interfaces.IDAVCollection',",
            "    'webdav.interfaces.IDAVResource',",
            "    'zope.annotation.interfaces.IAnnotatable',",
            "    'zope.annotation.interfaces.IAttributeAnnotatable',",
            "    'zope.component.interfaces.IPossibleSite',",
            "    'zope.container.interfaces.IContainer',",
            "    'zope.container.interfaces.IItemContainer',",
            "    'zope.container.interfaces.IReadContainer',",
            "    'zope.container.interfaces.ISimpleReadContainer',",
            "    'zope.container.interfaces.IWriteContainer',",
            "    'zope.interface.common.mapping.IEnumerableMapping',",
            "    'zope.interface.common.mapping.IItemMapping',",
            "    'zope.interface.common.mapping.IReadMapping',",
            "    'zope.interface.Interface',",
            "))",
            "",
            "",
            "@indexer(Interface)",
            "def allowedRolesAndUsers(obj):",
            "    \"\"\"Return a list of roles and users with View permission.",
            "    Used to filter out items you're not allowed to see.",
            "    \"\"\"",
            "    allowed = {}",
            "    for r in rolesForPermissionOn('View', obj):",
            "        allowed[r] = 1",
            "    # shortcut roles and only index the most basic system role if the object",
            "    # is viewable by either of those",
            "    if 'Anonymous' in allowed:",
            "        return ['Anonymous']",
            "    elif 'Authenticated' in allowed:",
            "        return ['Authenticated']",
            "    localroles = {}",
            "    try:",
            "        acl_users = getToolByName(obj, 'acl_users', None)",
            "        if acl_users is not None:",
            "            localroles = acl_users._getAllLocalRoles(obj)",
            "    except AttributeError:",
            "        localroles = _mergedLocalRoles(obj)",
            "    for user, roles in localroles.items():",
            "        for role in roles:",
            "            if role in allowed:",
            "                allowed['user:' + user] = 1",
            "    if 'Owner' in allowed:",
            "        del allowed['Owner']",
            "    return list(allowed.keys())",
            "",
            "",
            "@indexer(Interface)",
            "def object_provides(obj):",
            "    return tuple([i.__identifier__ for i in providedBy(obj).flattened()",
            "        if i.__identifier__ not in BLACKLISTED_INTERFACES])",
            "",
            "",
            "def zero_fill(matchobj):",
            "    return matchobj.group().zfill(4)",
            "",
            "num_sort_regex = re.compile('\\d+')",
            "",
            "",
            "@indexer(Interface)",
            "def sortable_title(obj):",
            "    \"\"\" Helper method for to provide FieldIndex for Title.",
            "    \"\"\"",
            "    title = getattr(obj, 'Title', None)",
            "    if title is not None:",
            "        if safe_callable(title):",
            "            title = title()",
            "",
            "        if isinstance(title, basestring):",
            "            # Ignore case, normalize accents, strip spaces",
            "            sortabletitle = mapUnicode(safe_unicode(title)).lower().strip()",
            "            # Replace numbers with zero filled numbers",
            "            sortabletitle = num_sort_regex.sub(zero_fill, sortabletitle)",
            "            # Truncate to prevent bloat, take bits from start and end",
            "            if len(sortabletitle) > MAX_SORTABLE_TITLE:",
            "                start = sortabletitle[:(MAX_SORTABLE_TITLE - 13)]",
            "                end = sortabletitle[-10:]",
            "                sortabletitle = start + '...' + end",
            "            return sortabletitle.encode('utf-8')",
            "    return ''",
            "",
            "",
            "@indexer(Interface)",
            "def getObjPositionInParent(obj):",
            "    \"\"\" Helper method for catalog based folder contents.",
            "    \"\"\"",
            "    parent = aq_parent(aq_inner(obj))",
            "    ordered = IOrderedContainer(parent, None)",
            "    if ordered is not None:",
            "        return ordered.getObjectPosition(obj.getId())",
            "    return 0",
            "",
            "SIZE_CONST = {'KB': 1024, 'MB': 1024 * 1024, 'GB': 1024 * 1024 * 1024}",
            "SIZE_ORDER = ('GB', 'MB', 'KB')",
            "",
            "",
            "@indexer(Interface)",
            "def getObjSize(obj):",
            "    \"\"\" Helper method for catalog based folder contents.",
            "    \"\"\"",
            "    smaller = SIZE_ORDER[-1]",
            "",
            "    if base_hasattr(obj, 'get_size'):",
            "        size = obj.get_size()",
            "    else:",
            "        size = 0",
            "",
            "    # if the size is a float, then make it an int",
            "    # happens for large files",
            "    try:",
            "        size = int(size)",
            "    except (ValueError, TypeError):",
            "        pass",
            "",
            "    if not size:",
            "        return '0 %s' % smaller",
            "",
            "    if isinstance(size, (int, long)):",
            "        if size < SIZE_CONST[smaller]:",
            "            return '1 %s' % smaller",
            "        for c in SIZE_ORDER:",
            "            if size / SIZE_CONST[c] > 0:",
            "                break",
            "        return '%.1f %s' % (float(size / float(SIZE_CONST[c])), c)",
            "    return size",
            "",
            "",
            "@indexer(Interface)",
            "def is_folderish(obj):",
            "    \"\"\"Should this item be treated as a folder?",
            "",
            "    Checks isPrincipiaFolderish, as well as the INonStructuralFolder",
            "    interfaces.",
            "    \"\"\"",
            "    # If the object explicitly states it doesn't want to be treated as a",
            "    # structural folder, don't argue with it.",
            "    folderish = bool(getattr(aq_base(obj), 'isPrincipiaFolderish', False))",
            "    if not folderish:",
            "        return False",
            "    elif INonStructuralFolder.providedBy(obj):",
            "        return False",
            "    else:",
            "        return folderish",
            "",
            "",
            "@indexer(Interface)",
            "def is_default_page(obj):",
            "    \"\"\"Is this the default page in its folder",
            "    \"\"\"",
            "    ptool = getToolByName(obj, 'plone_utils', None)",
            "    if ptool is None:",
            "        return False",
            "    return ptool.isDefaultPage(obj)",
            "",
            "",
            "@indexer(Interface)",
            "def getIcon(obj):",
            "    \"\"\"Make sure we index icon relative to portal\"\"\"",
            "    return obj.getIcon(True)",
            "",
            "",
            "@indexer(IExtensibleMetadata)",
            "def location(obj):",
            "    return obj.getField('location').get(obj)",
            "",
            "",
            "",
            "",
            "class CatalogTool(PloneBaseTool, BaseTool):",
            "    \"\"\"Plone's catalog tool\"\"\"",
            "",
            "    implements(IPloneCatalogTool)",
            "",
            "    meta_type = 'Plone Catalog Tool'",
            "    security = ClassSecurityInfo()",
            "    toolicon = 'skins/plone_images/book_icon.png'",
            "    _counter = None",
            "",
            "    manage_catalogAdvanced = DTMLFile('www/catalogAdvanced', globals())",
            "",
            "    manage_options = (",
            "        {'action': 'manage_main', 'label': 'Contents'},",
            "        {'action': 'manage_catalogView', 'label': 'Catalog'},",
            "        {'action': 'manage_catalogIndexes', 'label': 'Indexes'},",
            "        {'action': 'manage_catalogSchema', 'label': 'Metadata'},",
            "        {'action': 'manage_catalogAdvanced', 'label': 'Advanced'},",
            "        {'action': 'manage_catalogReport', 'label': 'Query Report'},",
            "        {'action': 'manage_catalogPlan', 'label': 'Query Plan'},",
            "        {'action': 'manage_propertiesForm', 'label': 'Properties'},",
            "    )",
            "",
            "    def __init__(self):",
            "        ZCatalog.__init__(self, self.getId())",
            "",
            "    def _removeIndex(self, index):",
            "        \"\"\"Safe removal of an index.",
            "        \"\"\"",
            "        try:",
            "            self.manage_delIndex(index)",
            "        except:",
            "            pass",
            "",
            "    def _listAllowedRolesAndUsers(self, user):",
            "        \"\"\"Makes sure the list includes the user's groups.",
            "        \"\"\"",
            "        result = user.getRoles()",
            "        if 'Anonymous' in result:",
            "            # The anonymous user has no further roles",
            "            return ['Anonymous']",
            "        result = list(result)",
            "        if hasattr(aq_base(user), 'getGroups'):",
            "            groups = ['user:%s' % x for x in user.getGroups()]",
            "            if groups:",
            "                result = result + groups",
            "        # Order the arguments from small to large sets",
            "        result.insert(0, 'user:%s' % user.getId())",
            "        result.append('Anonymous')",
            "        return result",
            "",
            "    security.declarePrivate('indexObject')",
            "    def indexObject(self, object, idxs=None):",
            "        \"\"\"Add object to catalog.",
            "",
            "        The optional idxs argument is a list of specific indexes",
            "        to populate (all of them by default).",
            "        \"\"\"",
            "        if idxs is None:",
            "            idxs = []",
            "        self.reindexObject(object, idxs)",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'catalog_object')",
            "    def catalog_object(self, object, uid=None, idxs=None,",
            "                       update_metadata=1, pghandler=None):",
            "        if idxs is None:",
            "            idxs = []",
            "        self._increment_counter()",
            "",
            "        w = object",
            "        if not IIndexableObject.providedBy(object):",
            "            # This is the CMF 2.2 compatible approach, which should be used",
            "            # going forward",
            "            wrapper = queryMultiAdapter((object, self), IIndexableObject)",
            "            if wrapper is not None:",
            "                w = wrapper",
            "",
            "        ZCatalog.catalog_object(self, w, uid, idxs,",
            "                                update_metadata, pghandler=pghandler)",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'catalog_object')",
            "    def uncatalog_object(self, *args, **kwargs):",
            "        self._increment_counter()",
            "        return BaseTool.uncatalog_object(self, *args, **kwargs)",
            "",
            "    def _increment_counter(self):",
            "        if self._counter is None:",
            "            self._counter = Length()",
            "        self._counter.change(1)",
            "",
            "    security.declarePrivate('getCounter')",
            "    def getCounter(self):",
            "        return self._counter is not None and self._counter() or 0",
            "",
            "    security.declareProtected(SearchZCatalog, 'searchResults')",
            "    def searchResults(self, REQUEST=None, **kw):",
            "        \"\"\"Calls ZCatalog.searchResults with extra arguments that",
            "        limit the results to what the user is allowed to see.",
            "",
            "        This version uses the 'effectiveRange' DateRangeIndex.",
            "",
            "        It also accepts a keyword argument show_inactive to disable",
            "        effectiveRange checking entirely even for those without portal",
            "        wide AccessInactivePortalContent permission.",
            "        \"\"\"",
            "        kw = kw.copy()",
            "        show_inactive = kw.get('show_inactive', False)",
            "        if isinstance(REQUEST, dict) and not show_inactive:",
            "            show_inactive = 'show_inactive' in REQUEST",
            "",
            "        user = _getAuthenticatedUser(self)",
            "        kw['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)",
            "",
            "        if not show_inactive and not _checkPermission(",
            "            AccessInactivePortalContent, self):",
            "",
            "            kw['effectiveRange'] = DateTime()",
            "",
            "        return ZCatalog.searchResults(self, REQUEST, **kw)",
            "",
            "    __call__ = searchResults",
            "",
            "    def search(self, *args, **kw):",
            "        # Wrap search() the same way that searchResults() is",
            "        query = {}",
            "",
            "        if args:",
            "            query = args[0]",
            "        elif 'query_request' in kw:",
            "            query = kw.get['query_request']",
            "",
            "        kw['query_request'] = query.copy()",
            "",
            "        user = _getAuthenticatedUser(self)",
            "        query['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)",
            "",
            "        if not _checkPermission(AccessInactivePortalContent, self):",
            "            query['effectiveRange'] = DateTime()",
            "",
            "        kw['query_request'] = query",
            "",
            "        return super(CatalogTool, self).search(**kw)",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'clearFindAndRebuild')",
            "    def clearFindAndRebuild(self):",
            "        \"\"\"Empties catalog, then finds all contentish objects (i.e. objects",
            "           with an indexObject method), and reindexes them.",
            "           This may take a long time.",
            "        \"\"\"",
            "        def indexObject(obj, path):",
            "            if (base_hasattr(obj, 'indexObject') and",
            "                safe_callable(obj.indexObject)):",
            "                try:",
            "                    obj.indexObject()",
            "                except TypeError:",
            "                    # Catalogs have 'indexObject' as well, but they",
            "                    # take different args, and will fail",
            "                    pass",
            "        self.manage_catalogClear()",
            "        portal = aq_parent(aq_inner(self))",
            "        portal.ZopeFindAndApply(portal, search_sub=True,",
            "            apply_func=indexObject)",
            "",
            "    security.declareProtected(ManageZCatalogEntries, 'manage_catalogRebuild')",
            "    def manage_catalogRebuild(self, RESPONSE=None, URL1=None):",
            "        \"\"\"Clears the catalog and indexes all objects with an 'indexObject'",
            "        method. This may take a long time.",
            "        \"\"\"",
            "        elapse = time.time()",
            "        c_elapse = time.clock()",
            "",
            "        self.clearFindAndRebuild()",
            "",
            "        elapse = time.time() - elapse",
            "        c_elapse = time.clock() - c_elapse",
            "",
            "        if RESPONSE is not None:",
            "            RESPONSE.redirect(",
            "              URL1 + '/manage_catalogAdvanced?manage_tabs_message=' +",
            "              urllib.quote('Catalog Rebuilt\\n'",
            "                           'Total time: %s\\n'",
            "                           'Total CPU time: %s'",
            "                                % (repr(elapse), repr(c_elapse))))",
            "",
            "InitializeClass(CatalogTool)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "Products.CMFPlone.CatalogTool.CatalogTool.self",
            "Products.CMFPlone.CatalogTool.BaseTool",
            "Products.CMFPlone.CatalogTool.CatalogTool.manage_options",
            "trytond.res.user",
            "Products.CMFPlone.CatalogTool.CatalogTool",
            "Products.CMFPlone.CatalogTool"
        ]
    },
    "Products/CMFPlone/FactoryTool.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "     f = open(os.path.join(wwwpath, 'portal_factory_docs.stx'), 'r')"
            },
            "1": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "     _docs = f.read()"
            },
            "2": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "     f.close()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    del f"
            },
            "4": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "     _docs = stx2html(_docs)"
            },
            "5": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 277,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "     security.declarePublic('docs')"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import os",
            "",
            "from zope.interface import implements",
            "from zope.structuredtext import stx2html",
            "",
            "from AccessControl import Owned, ClassSecurityInfo, getSecurityManager",
            "from Acquisition import aq_parent, aq_base, aq_inner, aq_get",
            "from App.class_init import InitializeClass",
            "from App.Common import package_home",
            "from OFS.SimpleItem import SimpleItem",
            "from zExceptions import NotFound",
            "from ZPublisher.Publish import call_object, missing_name, dont_publish_class",
            "from ZPublisher.mapply import mapply",
            "from Products.CMFPlone import cmfplone_globals",
            "from Products.PageTemplates.PageTemplateFile import PageTemplateFile",
            "from Products.CMFCore.permissions import ManagePortal",
            "from Products.CMFCore.utils import UniqueObject",
            "from Products.CMFCore.utils import getToolByName",
            "from Products.CMFPlone.interfaces import IFactoryTool",
            "from Products.CMFPlone.interfaces import IHideFromBreadcrumbs",
            "from Products.CMFPlone.PloneFolder import PloneFolder as TempFolderBase",
            "from Products.CMFPlone.PloneBaseTool import PloneBaseTool",
            "from Products.CMFPlone.utils import base_hasattr",
            "from Products.CMFPlone.utils import log_exc",
            "from ZODB.POSException import ConflictError",
            "",
            "FACTORY_INFO = '__factory__info__'",
            "",
            "",
            "class FauxArchetypeTool(object):",
            "    \"\"\"A faux archetypes tool which prevents content from being indexed.\"\"\"",
            "",
            "    __allow_access_to_unprotected_subobjects__ = 1",
            "",
            "    def __init__(self, tool):",
            "        self.tool = tool",
            "",
            "    def getCatalogsByType(self, type_name):",
            "        return []",
            "",
            "    def __getitem__(self, id):",
            "        return getattr(self.tool, id)",
            "",
            "",
            "def _createObjectByType(type_name, container, id, *args, **kw):",
            "    \"\"\"This function replaces Products.CMFPlone.utils._createObjectByType.",
            "",
            "    If no product is set on fti, use IFactory to lookup the factory.",
            "    Additionally we add 'container' as 'parent' kw argument when calling the",
            "    IFactory implementation. this ensures the availability of the acquisition",
            "    chain if needed inside the construction logic.",
            "",
            "    The kw argument hack is some kind of semi-valid since the IFactory",
            "    interface promises the __call__ function to accept all given args and kw",
            "    args. As long as the specific IFactory implementation provides this",
            "    signature everything works well unless any other 3rd party factory expects",
            "    another kind of object as 'parent' kw arg than the provided one.",
            "    \"\"\"",
            "    id = str(id)",
            "    typesTool = getToolByName(container, 'portal_types')",
            "    fti = typesTool.getTypeInfo(type_name)",
            "    if not fti:",
            "        raise ValueError('Invalid type %s' % type_name)",
            "",
            "    if not fti.product:",
            "        kw['parent'] = container",
            "",
            "    return fti._constructInstance(container, id, *args, **kw)",
            "",
            "",
            "# #############################################################################",
            "# A class used for generating the temporary folder that will",
            "# hold temporary objects.  We need a separate class so that",
            "# we can add all types to types_tool's allowed_content_types",
            "# for the class without having side effects in the rest of",
            "# the portal.",
            "class TempFolder(TempFolderBase):",
            "",
            "    portal_type = meta_type = 'TempFolder'",
            "    isPrincipiaFolderish = 0",
            "",
            "    implements(IHideFromBreadcrumbs)",
            "",
            "    # override getPhysicalPath so that temporary objects return a full path",
            "    # that includes the acquisition parent of portal_factory (otherwise we get",
            "    # portal_root/portal_factory/... no matter where the object will reside)",
            "    def getPhysicalPath(self):",
            "        '''Returns a path (an immutable sequence of strings)",
            "        that can be used to access this object again",
            "        later, for example in a copy/paste operation.  getPhysicalRoot()",
            "        and getPhysicalPath() are designed to operate together.",
            "        '''",
            "        portal_factory = aq_parent(aq_inner(self))",
            "        path = aq_parent(portal_factory).getPhysicalPath() + \\",
            "            (portal_factory.getId(), self.getId(), )",
            "        return path",
            "",
            "    # override / delegate local roles methods",
            "    def __ac_local_roles__(self):",
            "        \"\"\"__ac_local_roles__ needs to be handled carefully.",
            "        Zope's and GRUF's User.getRolesInContext both walk up the",
            "        acquisition hierarchy using aq_parent(aq_inner(obj)) when",
            "        they gather local roles, and this process will result in",
            "        their walking from TempFolder to portal_factory to the portal root.\"\"\"",
            "        object = aq_parent(aq_parent(self))",
            "        local_roles = {}",
            "        while 1:",
            "            # Get local roles for this user",
            "            lr = getattr(object, '__ac_local_roles__', None)",
            "            if lr:",
            "                if callable(lr):",
            "                    lr = lr()",
            "                lr = lr or {}",
            "                for k, v in lr.items():",
            "                    if not k in local_roles:",
            "                        local_roles[k] = []",
            "                    for role in v:",
            "                        if not role in local_roles[k]:",
            "                            local_roles[k].append(role)",
            "",
            "            # Check if local role has to be acquired (PLIP 16)",
            "            if getattr(object, '__ac_local_roles_block__', None):",
            "                # Ok, we have to stop there, as lr. blocking is enabled",
            "                break",
            "",
            "            # Prepare next iteration",
            "            inner = getattr(object, 'aq_inner', object)",
            "            parent = getattr(inner, 'aq_parent', None)",
            "            if parent is not None:",
            "                object = parent",
            "                continue",
            "            if hasattr(object, 'im_self'):",
            "                object = object.im_self",
            "                object = getattr(object, 'aq_inner', object)",
            "                continue",
            "            break",
            "        return local_roles",
            "",
            "    def has_local_roles(self):",
            "        return len(self.__ac_local_roles__())",
            "",
            "    def get_local_roles_for_userid(self, userid):",
            "        return tuple(self.__ac_local_roles__().get(userid, []))",
            "",
            "    def get_valid_userids(self):",
            "        return aq_parent(aq_parent(self)).get_valid_userids()",
            "",
            "    def valid_roles(self):",
            "        return aq_parent(aq_parent(self)).valid_roles()",
            "",
            "    def validate_roles(self, roles):",
            "        return aq_parent(aq_parent(self)).validate_roles(roles)",
            "",
            "    def userdefined_roles(self):",
            "        return aq_parent(aq_parent(self)).userdefined_roles()",
            "",
            "    # delegate Owned methods",
            "    def owner_info(self):",
            "        return aq_parent(aq_parent(self)).owner_info()",
            "",
            "    def getOwner(self, info=0,",
            "                 aq_get=aq_get,",
            "                 UnownableOwner=Owned.UnownableOwner,",
            "                 getSecurityManager=getSecurityManager,",
            "                 ):",
            "        return aq_parent(",
            "                    aq_parent(self)).getOwner(",
            "                        info, aq_get, UnownableOwner, getSecurityManager)",
            "",
            "    def userCanTakeOwnership(self):",
            "        return aq_parent(aq_parent(self)).userCanTakeOwnership()",
            "",
            "    # delegate allowedContentTypes",
            "    def allowedContentTypes(self):",
            "        return aq_parent(aq_parent(self)).allowedContentTypes()",
            "",
            "    def __getitem__(self, id):",
            "        # Zope's inner acquisition chain for objects returned by __getitem__",
            "        # will be portal -> portal_factory -> temporary_folder -> object",
            "        # What we really want is for the inner acquisition chain to be",
            "        # intended_parent_folder -> portal_factory -> temporary_folder -> object",
            "        # So we need to rewrap...",
            "        portal_factory = aq_parent(aq_inner(self))",
            "        intended_parent = aq_parent(portal_factory)",
            "",
            "        # If the intended parent has an object with the given id, just do a",
            "        # passthrough",
            "        if hasattr(intended_parent, id):",
            "            return getattr(intended_parent, id)",
            "",
            "        # rewrap portal_factory",
            "        portal_factory = aq_base(portal_factory).__of__(intended_parent)",
            "        # rewrap self",
            "        temp_folder = aq_base(self).__of__(portal_factory)",
            "",
            "        if id in self:",
            "            return (aq_base(self._getOb(id)).__of__(temp_folder)) \\",
            "                        .__of__(intended_parent)",
            "        else:",
            "            type_name = self.getId()",
            "            try:",
            "                # We fake an archetype tool which returns no catalogs for the",
            "                # object to be indexed in to avoid it showing up in the catalog",
            "                # in the first place.",
            "                self.archetype_tool = FauxArchetypeTool(",
            "                                        getToolByName(self, 'archetype_tool'))",
            "                _createObjectByType(type_name, self, id)",
            "            except ConflictError:",
            "                raise",
            "            except:",
            "                # some errors from invokeFactory (AttributeError, maybe others)",
            "                # get swallowed -- dump the exception to the log to make sure",
            "                # developers can see what's going on",
            "                log_exc(severity=logging.DEBUG)",
            "                raise",
            "            obj = self._getOb(id)",
            "",
            "            # keep obj out of the catalog",
            "            obj.unindexObject()",
            "",
            "            # additionally keep it out of Archetypes UID and refs catalogs",
            "            if base_hasattr(obj, '_uncatalogUID'):",
            "                obj._uncatalogUID(obj)",
            "            if base_hasattr(obj, '_uncatalogRefs'):",
            "                obj._uncatalogRefs(obj)",
            "",
            "            return (aq_base(obj).__of__(temp_folder)).__of__(intended_parent)",
            "",
            "    # ignore rename requests since they don't do anything",
            "    def manage_renameObject(self, id, new_id, REQUEST=None):",
            "        pass",
            "",
            "",
            "# #############################################################################",
            "class FactoryTool(PloneBaseTool, UniqueObject, SimpleItem):",
            "    \"\"\" \"\"\"",
            "    id = 'portal_factory'",
            "    meta_type = 'Plone Factory Tool'",
            "    toolicon = 'skins/plone_images/add_icon.png'",
            "    security = ClassSecurityInfo()",
            "    isPrincipiaFolderish = 0",
            "",
            "    implements(IFactoryTool, IHideFromBreadcrumbs)",
            "",
            "    manage_options = (",
            "        ({'label': 'Overview', 'action': 'manage_overview'},",
            "         {'label': 'Documentation', 'action': 'manage_docs'},",
            "         {'label': 'Factory Types', 'action': 'manage_portal_factory_types'}) +",
            "        SimpleItem.manage_options)",
            "",
            "    security.declareProtected(ManagePortal, 'manage_overview')",
            "    manage_overview = PageTemplateFile(",
            "                        'www/portal_factory_manage_overview', globals())",
            "    manage_overview.__name__ = 'manage_overview'",
            "    manage_overview._need__name__ = 0",
            "",
            "    security.declareProtected(ManagePortal, 'manage_portal_factory_types')",
            "    manage_portal_factory_types = PageTemplateFile(",
            "        os.path.join('www', 'portal_factory_manage_types'), globals())",
            "    manage_portal_factory_types.__name__ = 'manage_portal_factory_types'",
            "    manage_portal_factory_types._need__name__ = 0",
            "",
            "    manage_main = manage_overview",
            "",
            "    security.declareProtected(ManagePortal, 'manage_docs')",
            "    manage_docs = PageTemplateFile(",
            "        os.path.join('www', 'portal_factory_manage_docs'), globals())",
            "    manage_docs.__name__ = 'manage_docs'",
            "",
            "    wwwpath = os.path.join(package_home(cmfplone_globals), 'www')",
            "    f = open(os.path.join(wwwpath, 'portal_factory_docs.stx'), 'r')",
            "    _docs = f.read()",
            "    f.close()",
            "    _docs = stx2html(_docs)",
            "",
            "    security.declarePublic('docs')",
            "    def docs(self):",
            "        \"\"\"Returns FactoryTool docs formatted as HTML\"\"\"",
            "        return self._docs",
            "",
            "    def getFactoryTypes(self):",
            "        if not hasattr(self, '_factory_types'):",
            "            self._factory_types = {}",
            "        return self._factory_types",
            "",
            "    security.declareProtected(ManagePortal, 'manage_setPortalFactoryTypes')",
            "    def manage_setPortalFactoryTypes(self, REQUEST=None, listOfTypeIds=None):",
            "        \"\"\"Set the portal types that should use the factory.\"\"\"",
            "        if listOfTypeIds is not None:",
            "            dict = {}",
            "            for l in listOfTypeIds:",
            "                dict[l] = 1",
            "        elif REQUEST is not None:",
            "            dict = REQUEST.form",
            "        if dict is None:",
            "            dict = {}",
            "        self._factory_types = {}",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        for t in types_tool.listContentTypes():",
            "            if t in dict:",
            "                self._factory_types[t] = 1",
            "        self._p_changed = 1",
            "        if REQUEST:",
            "            REQUEST.RESPONSE.redirect('manage_main')",
            "",
            "    def doCreate(self, obj, id=None, **kw):",
            "        \"\"\"Create a real object from a temporary object.\"\"\"",
            "        if self.isTemporary(obj=obj):",
            "            if id is not None:",
            "                id = id.strip()",
            "            if not id:",
            "                if hasattr(obj, 'getId') and callable(getattr(obj, 'getId')):",
            "                    id = obj.getId()",
            "                else:",
            "                    id = getattr(obj, 'id', None)",
            "            # get the ID of the TempFolder",
            "            type_name = aq_parent(aq_inner(obj)).id",
            "            folder = aq_parent(aq_parent(aq_parent(aq_inner(obj))))",
            "            folder.invokeFactory(id=id, type_name=type_name)",
            "            obj = getattr(folder, id)",
            "",
            "            # give ownership to currently authenticated member if not anonymous",
            "            # TODO is this necessary?",
            "            membership_tool = getToolByName(self, 'portal_membership')",
            "            if not membership_tool.isAnonymousUser():",
            "                member = membership_tool.getAuthenticatedMember()",
            "                obj.changeOwnership(member.getUser(), 1)",
            "            if hasattr(aq_base(obj), 'manage_afterPortalFactoryCreate'):",
            "                obj.manage_afterPortalFactoryCreate()",
            "        return obj",
            "",
            "    def _fixRequest(self):",
            "        \"\"\"Our before_publishing_traverse call mangles URL0.  This fixes up",
            "        the REQUEST.\"\"\"",
            "        # Everything seems to work without this method being called at all...",
            "        factory_info = self.REQUEST.get(FACTORY_INFO, None)",
            "        if not factory_info:",
            "            return",
            "        stack = factory_info['stack']",
            "        FACTORY_URL = self.REQUEST.URL",
            "        URL = '/'.join([FACTORY_URL] + stack)",
            "        self.REQUEST.set('URL', URL)",
            "",
            "        url_list = URL.split('/')",
            "        n = 0",
            "        while len(url_list) > 0 and url_list[-1] != '':",
            "            self.REQUEST.set('URL%d' % n, '/'.join(url_list))",
            "            url_list = url_list[:-1]",
            "            n = n + 1",
            "",
            "        # BASE1 is the url of the Zope App object",
            "        n = len(self.REQUEST._steps) + 2",
            "        base = FACTORY_URL",
            "        for part in stack:",
            "            base = '%s/%s' % (base, part)",
            "            self.REQUEST.set('BASE%d' % n, base)",
            "            n += 1",
            "        # TODO fix URLPATHn, BASEPATHn here too",
            "",
            "    def isTemporary(self, obj):",
            "        \"\"\"Check to see if an object is temporary\"\"\"",
            "        ob = aq_base(aq_parent(aq_inner(obj)))",
            "        return hasattr(ob, 'meta_type') \\",
            "                and ob.meta_type == TempFolder.meta_type",
            "",
            "    def __before_publishing_traverse__(self, other, REQUEST):",
            "",
            "        if REQUEST.get(FACTORY_INFO, None):",
            "            del REQUEST[FACTORY_INFO]",
            "",
            "        stack = REQUEST.get('TraversalRequestNameStack')",
            "        # convert from unicode if necessary (happens in Epoz for some weird",
            "        # reason)",
            "        stack = [str(s) for s in stack]",
            "",
            "        # need 2 more things on the stack at least for portal_factory to",
            "        # kick in:",
            "        #    (1) a type, and (2) an id",
            "        if len(stack) < 2:  # ignore",
            "            return",
            "",
            "        # Keep track of how many path elements we want to eat",
            "        gobbled_length = 0",
            "",
            "        type_name = stack[-1]",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        # make sure this is really a type name",
            "        if not type_name in types_tool.listContentTypes():",
            "            return  # nope -- do nothing",
            "",
            "        gobbled_length += 1",
            "",
            "        id = stack[-2]",
            "        intended_parent = aq_parent(self)",
            "        if hasattr(intended_parent, id):",
            "            return  # do normal traversal via __bobo_traverse__",
            "",
            "        gobbled_length += 1",
            "",
            "        # about to create an object",
            "",
            "        # before halting traversal, check for method aliases",
            "        # stack should be [...optional stuff..., id, type_name]",
            "        key = len(stack) >= 3 and stack[-3] or '(Default)'",
            "        ti = types_tool.getTypeInfo(type_name)",
            "        method_id = ti and ti.queryMethodID(key)",
            "        if method_id:",
            "            if key != '(Default)':",
            "                del(stack[-3])",
            "            if method_id != '(Default)':",
            "                stack.insert(-2, method_id)",
            "                gobbled_length += 1",
            "            REQUEST._hacked_path = 1",
            "        else:",
            "            gobbled_length += 1",
            "",
            "        # Pevent further traversal if we are doing a normal factory request,",
            "        # but allow it if there is a traversal sub-path beyond the (edit)",
            "        # view on the content item. In this case, portal_factory will not",
            "        # be responsible for rendering the object.",
            "        if len(stack) <= gobbled_length:",
            "            REQUEST.set('TraversalRequestNameStack', [])",
            "",
            "        stack.reverse()",
            "        factory_info = {'stack': stack}",
            "        REQUEST.set(FACTORY_INFO, factory_info)",
            "",
            "    def __bobo_traverse__(self, REQUEST, name):",
            "        # __bobo_traverse__ can be invoked directly by a restricted_traverse",
            "        # method call in which case the traversal stack will not have been",
            "        # cleared by __before_publishing_traverse__",
            "        name = str(name)  # fix unicode weirdness",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        if not name in types_tool.listContentTypes():",
            "            # not a type name -- do the standard thing",
            "            return getattr(self, name)",
            "        # a type name -- return a temp folder",
            "        return self._getTempFolder(str(name))",
            "",
            "    security.declarePublic('__call__')",
            "    def __call__(self, *args, **kwargs):",
            "        \"\"\"call method\"\"\"",
            "        self._fixRequest()",
            "        factory_info = self.REQUEST.get(FACTORY_INFO, {})",
            "        stack = factory_info['stack']",
            "        type_name = stack[0]",
            "        id = stack[1]",
            "",
            "        # do a passthrough if parent contains the id",
            "        if id in aq_parent(self):",
            "            return aq_parent(self).restrictedTraverse(",
            "                        '/'.join(stack[1:]))(*args, **kwargs)",
            "",
            "        tempFolder = self._getTempFolder(type_name)",
            "        # Mysterious hack that fixes some problematic interactions with",
            "        # SpeedPack:",
            "        #   Get the first item in the stack by explicitly calling __getitem__",
            "        temp_obj = tempFolder.__getitem__(id)",
            "        stack = stack[2:]",
            "        if stack:",
            "            try:",
            "                obj = temp_obj.restrictedTraverse('/'.join(stack))",
            "            except AttributeError:",
            "                raise NotFound",
            "",
            "            # Mimic URL traversal, sort of",
            "            if getattr(aq_base(obj), 'index_html', None):",
            "                obj = obj.restrictedTraverse('index_html')",
            "            else:",
            "                obj = getattr(obj, 'GET', obj)",
            "",
            "        else:",
            "            obj = temp_obj",
            "        return mapply(obj, self.REQUEST.args, self.REQUEST,",
            "                               call_object, 1, missing_name,",
            "                               dont_publish_class, self.REQUEST, bind=1)",
            "",
            "    index_html = None  # call __call__, not index_html",
            "",
            "    def _getTempFolder(self, type_name):",
            "        factory_info = self.REQUEST.get(FACTORY_INFO, {})",
            "        tempFolder = factory_info.get(type_name, None)",
            "        if tempFolder is not None:",
            "            tempFolder = aq_inner(tempFolder).__of__(self)",
            "            return tempFolder",
            "",
            "        # make sure we can add an object of this type to the temp folder",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        if not type_name in types_tool.TempFolder.allowed_content_types:",
            "            # update allowed types for tempfolder",
            "            types_tool.TempFolder.allowed_content_types = \\",
            "                (types_tool.listContentTypes())",
            "",
            "        tempFolder = TempFolder(type_name).__of__(self)",
            "",
            "        factory_info[type_name] = tempFolder",
            "        self.REQUEST.set(FACTORY_INFO, factory_info)",
            "        return tempFolder",
            "",
            "InitializeClass(FactoryTool)"
        ],
        "afterPatchFile": [
            "import logging",
            "import os",
            "",
            "from zope.interface import implements",
            "from zope.structuredtext import stx2html",
            "",
            "from AccessControl import Owned, ClassSecurityInfo, getSecurityManager",
            "from Acquisition import aq_parent, aq_base, aq_inner, aq_get",
            "from App.class_init import InitializeClass",
            "from App.Common import package_home",
            "from OFS.SimpleItem import SimpleItem",
            "from zExceptions import NotFound",
            "from ZPublisher.Publish import call_object, missing_name, dont_publish_class",
            "from ZPublisher.mapply import mapply",
            "from Products.CMFPlone import cmfplone_globals",
            "from Products.PageTemplates.PageTemplateFile import PageTemplateFile",
            "from Products.CMFCore.permissions import ManagePortal",
            "from Products.CMFCore.utils import UniqueObject",
            "from Products.CMFCore.utils import getToolByName",
            "from Products.CMFPlone.interfaces import IFactoryTool",
            "from Products.CMFPlone.interfaces import IHideFromBreadcrumbs",
            "from Products.CMFPlone.PloneFolder import PloneFolder as TempFolderBase",
            "from Products.CMFPlone.PloneBaseTool import PloneBaseTool",
            "from Products.CMFPlone.utils import base_hasattr",
            "from Products.CMFPlone.utils import log_exc",
            "from ZODB.POSException import ConflictError",
            "",
            "FACTORY_INFO = '__factory__info__'",
            "",
            "",
            "class FauxArchetypeTool(object):",
            "    \"\"\"A faux archetypes tool which prevents content from being indexed.\"\"\"",
            "",
            "    __allow_access_to_unprotected_subobjects__ = 1",
            "",
            "    def __init__(self, tool):",
            "        self.tool = tool",
            "",
            "    def getCatalogsByType(self, type_name):",
            "        return []",
            "",
            "    def __getitem__(self, id):",
            "        return getattr(self.tool, id)",
            "",
            "",
            "def _createObjectByType(type_name, container, id, *args, **kw):",
            "    \"\"\"This function replaces Products.CMFPlone.utils._createObjectByType.",
            "",
            "    If no product is set on fti, use IFactory to lookup the factory.",
            "    Additionally we add 'container' as 'parent' kw argument when calling the",
            "    IFactory implementation. this ensures the availability of the acquisition",
            "    chain if needed inside the construction logic.",
            "",
            "    The kw argument hack is some kind of semi-valid since the IFactory",
            "    interface promises the __call__ function to accept all given args and kw",
            "    args. As long as the specific IFactory implementation provides this",
            "    signature everything works well unless any other 3rd party factory expects",
            "    another kind of object as 'parent' kw arg than the provided one.",
            "    \"\"\"",
            "    id = str(id)",
            "    typesTool = getToolByName(container, 'portal_types')",
            "    fti = typesTool.getTypeInfo(type_name)",
            "    if not fti:",
            "        raise ValueError('Invalid type %s' % type_name)",
            "",
            "    if not fti.product:",
            "        kw['parent'] = container",
            "",
            "    return fti._constructInstance(container, id, *args, **kw)",
            "",
            "",
            "# #############################################################################",
            "# A class used for generating the temporary folder that will",
            "# hold temporary objects.  We need a separate class so that",
            "# we can add all types to types_tool's allowed_content_types",
            "# for the class without having side effects in the rest of",
            "# the portal.",
            "class TempFolder(TempFolderBase):",
            "",
            "    portal_type = meta_type = 'TempFolder'",
            "    isPrincipiaFolderish = 0",
            "",
            "    implements(IHideFromBreadcrumbs)",
            "",
            "    # override getPhysicalPath so that temporary objects return a full path",
            "    # that includes the acquisition parent of portal_factory (otherwise we get",
            "    # portal_root/portal_factory/... no matter where the object will reside)",
            "    def getPhysicalPath(self):",
            "        '''Returns a path (an immutable sequence of strings)",
            "        that can be used to access this object again",
            "        later, for example in a copy/paste operation.  getPhysicalRoot()",
            "        and getPhysicalPath() are designed to operate together.",
            "        '''",
            "        portal_factory = aq_parent(aq_inner(self))",
            "        path = aq_parent(portal_factory).getPhysicalPath() + \\",
            "            (portal_factory.getId(), self.getId(), )",
            "        return path",
            "",
            "    # override / delegate local roles methods",
            "    def __ac_local_roles__(self):",
            "        \"\"\"__ac_local_roles__ needs to be handled carefully.",
            "        Zope's and GRUF's User.getRolesInContext both walk up the",
            "        acquisition hierarchy using aq_parent(aq_inner(obj)) when",
            "        they gather local roles, and this process will result in",
            "        their walking from TempFolder to portal_factory to the portal root.\"\"\"",
            "        object = aq_parent(aq_parent(self))",
            "        local_roles = {}",
            "        while 1:",
            "            # Get local roles for this user",
            "            lr = getattr(object, '__ac_local_roles__', None)",
            "            if lr:",
            "                if callable(lr):",
            "                    lr = lr()",
            "                lr = lr or {}",
            "                for k, v in lr.items():",
            "                    if not k in local_roles:",
            "                        local_roles[k] = []",
            "                    for role in v:",
            "                        if not role in local_roles[k]:",
            "                            local_roles[k].append(role)",
            "",
            "            # Check if local role has to be acquired (PLIP 16)",
            "            if getattr(object, '__ac_local_roles_block__', None):",
            "                # Ok, we have to stop there, as lr. blocking is enabled",
            "                break",
            "",
            "            # Prepare next iteration",
            "            inner = getattr(object, 'aq_inner', object)",
            "            parent = getattr(inner, 'aq_parent', None)",
            "            if parent is not None:",
            "                object = parent",
            "                continue",
            "            if hasattr(object, 'im_self'):",
            "                object = object.im_self",
            "                object = getattr(object, 'aq_inner', object)",
            "                continue",
            "            break",
            "        return local_roles",
            "",
            "    def has_local_roles(self):",
            "        return len(self.__ac_local_roles__())",
            "",
            "    def get_local_roles_for_userid(self, userid):",
            "        return tuple(self.__ac_local_roles__().get(userid, []))",
            "",
            "    def get_valid_userids(self):",
            "        return aq_parent(aq_parent(self)).get_valid_userids()",
            "",
            "    def valid_roles(self):",
            "        return aq_parent(aq_parent(self)).valid_roles()",
            "",
            "    def validate_roles(self, roles):",
            "        return aq_parent(aq_parent(self)).validate_roles(roles)",
            "",
            "    def userdefined_roles(self):",
            "        return aq_parent(aq_parent(self)).userdefined_roles()",
            "",
            "    # delegate Owned methods",
            "    def owner_info(self):",
            "        return aq_parent(aq_parent(self)).owner_info()",
            "",
            "    def getOwner(self, info=0,",
            "                 aq_get=aq_get,",
            "                 UnownableOwner=Owned.UnownableOwner,",
            "                 getSecurityManager=getSecurityManager,",
            "                 ):",
            "        return aq_parent(",
            "                    aq_parent(self)).getOwner(",
            "                        info, aq_get, UnownableOwner, getSecurityManager)",
            "",
            "    def userCanTakeOwnership(self):",
            "        return aq_parent(aq_parent(self)).userCanTakeOwnership()",
            "",
            "    # delegate allowedContentTypes",
            "    def allowedContentTypes(self):",
            "        return aq_parent(aq_parent(self)).allowedContentTypes()",
            "",
            "    def __getitem__(self, id):",
            "        # Zope's inner acquisition chain for objects returned by __getitem__",
            "        # will be portal -> portal_factory -> temporary_folder -> object",
            "        # What we really want is for the inner acquisition chain to be",
            "        # intended_parent_folder -> portal_factory -> temporary_folder -> object",
            "        # So we need to rewrap...",
            "        portal_factory = aq_parent(aq_inner(self))",
            "        intended_parent = aq_parent(portal_factory)",
            "",
            "        # If the intended parent has an object with the given id, just do a",
            "        # passthrough",
            "        if hasattr(intended_parent, id):",
            "            return getattr(intended_parent, id)",
            "",
            "        # rewrap portal_factory",
            "        portal_factory = aq_base(portal_factory).__of__(intended_parent)",
            "        # rewrap self",
            "        temp_folder = aq_base(self).__of__(portal_factory)",
            "",
            "        if id in self:",
            "            return (aq_base(self._getOb(id)).__of__(temp_folder)) \\",
            "                        .__of__(intended_parent)",
            "        else:",
            "            type_name = self.getId()",
            "            try:",
            "                # We fake an archetype tool which returns no catalogs for the",
            "                # object to be indexed in to avoid it showing up in the catalog",
            "                # in the first place.",
            "                self.archetype_tool = FauxArchetypeTool(",
            "                                        getToolByName(self, 'archetype_tool'))",
            "                _createObjectByType(type_name, self, id)",
            "            except ConflictError:",
            "                raise",
            "            except:",
            "                # some errors from invokeFactory (AttributeError, maybe others)",
            "                # get swallowed -- dump the exception to the log to make sure",
            "                # developers can see what's going on",
            "                log_exc(severity=logging.DEBUG)",
            "                raise",
            "            obj = self._getOb(id)",
            "",
            "            # keep obj out of the catalog",
            "            obj.unindexObject()",
            "",
            "            # additionally keep it out of Archetypes UID and refs catalogs",
            "            if base_hasattr(obj, '_uncatalogUID'):",
            "                obj._uncatalogUID(obj)",
            "            if base_hasattr(obj, '_uncatalogRefs'):",
            "                obj._uncatalogRefs(obj)",
            "",
            "            return (aq_base(obj).__of__(temp_folder)).__of__(intended_parent)",
            "",
            "    # ignore rename requests since they don't do anything",
            "    def manage_renameObject(self, id, new_id, REQUEST=None):",
            "        pass",
            "",
            "",
            "# #############################################################################",
            "class FactoryTool(PloneBaseTool, UniqueObject, SimpleItem):",
            "    \"\"\" \"\"\"",
            "    id = 'portal_factory'",
            "    meta_type = 'Plone Factory Tool'",
            "    toolicon = 'skins/plone_images/add_icon.png'",
            "    security = ClassSecurityInfo()",
            "    isPrincipiaFolderish = 0",
            "",
            "    implements(IFactoryTool, IHideFromBreadcrumbs)",
            "",
            "    manage_options = (",
            "        ({'label': 'Overview', 'action': 'manage_overview'},",
            "         {'label': 'Documentation', 'action': 'manage_docs'},",
            "         {'label': 'Factory Types', 'action': 'manage_portal_factory_types'}) +",
            "        SimpleItem.manage_options)",
            "",
            "    security.declareProtected(ManagePortal, 'manage_overview')",
            "    manage_overview = PageTemplateFile(",
            "                        'www/portal_factory_manage_overview', globals())",
            "    manage_overview.__name__ = 'manage_overview'",
            "    manage_overview._need__name__ = 0",
            "",
            "    security.declareProtected(ManagePortal, 'manage_portal_factory_types')",
            "    manage_portal_factory_types = PageTemplateFile(",
            "        os.path.join('www', 'portal_factory_manage_types'), globals())",
            "    manage_portal_factory_types.__name__ = 'manage_portal_factory_types'",
            "    manage_portal_factory_types._need__name__ = 0",
            "",
            "    manage_main = manage_overview",
            "",
            "    security.declareProtected(ManagePortal, 'manage_docs')",
            "    manage_docs = PageTemplateFile(",
            "        os.path.join('www', 'portal_factory_manage_docs'), globals())",
            "    manage_docs.__name__ = 'manage_docs'",
            "",
            "    wwwpath = os.path.join(package_home(cmfplone_globals), 'www')",
            "    f = open(os.path.join(wwwpath, 'portal_factory_docs.stx'), 'r')",
            "    _docs = f.read()",
            "    f.close()",
            "    del f",
            "    _docs = stx2html(_docs)",
            "",
            "    security.declarePublic('docs')",
            "    def docs(self):",
            "        \"\"\"Returns FactoryTool docs formatted as HTML\"\"\"",
            "        return self._docs",
            "",
            "    def getFactoryTypes(self):",
            "        if not hasattr(self, '_factory_types'):",
            "            self._factory_types = {}",
            "        return self._factory_types",
            "",
            "    security.declareProtected(ManagePortal, 'manage_setPortalFactoryTypes')",
            "    def manage_setPortalFactoryTypes(self, REQUEST=None, listOfTypeIds=None):",
            "        \"\"\"Set the portal types that should use the factory.\"\"\"",
            "        if listOfTypeIds is not None:",
            "            dict = {}",
            "            for l in listOfTypeIds:",
            "                dict[l] = 1",
            "        elif REQUEST is not None:",
            "            dict = REQUEST.form",
            "        if dict is None:",
            "            dict = {}",
            "        self._factory_types = {}",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        for t in types_tool.listContentTypes():",
            "            if t in dict:",
            "                self._factory_types[t] = 1",
            "        self._p_changed = 1",
            "        if REQUEST:",
            "            REQUEST.RESPONSE.redirect('manage_main')",
            "",
            "    def doCreate(self, obj, id=None, **kw):",
            "        \"\"\"Create a real object from a temporary object.\"\"\"",
            "        if self.isTemporary(obj=obj):",
            "            if id is not None:",
            "                id = id.strip()",
            "            if not id:",
            "                if hasattr(obj, 'getId') and callable(getattr(obj, 'getId')):",
            "                    id = obj.getId()",
            "                else:",
            "                    id = getattr(obj, 'id', None)",
            "            # get the ID of the TempFolder",
            "            type_name = aq_parent(aq_inner(obj)).id",
            "            folder = aq_parent(aq_parent(aq_parent(aq_inner(obj))))",
            "            folder.invokeFactory(id=id, type_name=type_name)",
            "            obj = getattr(folder, id)",
            "",
            "            # give ownership to currently authenticated member if not anonymous",
            "            # TODO is this necessary?",
            "            membership_tool = getToolByName(self, 'portal_membership')",
            "            if not membership_tool.isAnonymousUser():",
            "                member = membership_tool.getAuthenticatedMember()",
            "                obj.changeOwnership(member.getUser(), 1)",
            "            if hasattr(aq_base(obj), 'manage_afterPortalFactoryCreate'):",
            "                obj.manage_afterPortalFactoryCreate()",
            "        return obj",
            "",
            "    def _fixRequest(self):",
            "        \"\"\"Our before_publishing_traverse call mangles URL0.  This fixes up",
            "        the REQUEST.\"\"\"",
            "        # Everything seems to work without this method being called at all...",
            "        factory_info = self.REQUEST.get(FACTORY_INFO, None)",
            "        if not factory_info:",
            "            return",
            "        stack = factory_info['stack']",
            "        FACTORY_URL = self.REQUEST.URL",
            "        URL = '/'.join([FACTORY_URL] + stack)",
            "        self.REQUEST.set('URL', URL)",
            "",
            "        url_list = URL.split('/')",
            "        n = 0",
            "        while len(url_list) > 0 and url_list[-1] != '':",
            "            self.REQUEST.set('URL%d' % n, '/'.join(url_list))",
            "            url_list = url_list[:-1]",
            "            n = n + 1",
            "",
            "        # BASE1 is the url of the Zope App object",
            "        n = len(self.REQUEST._steps) + 2",
            "        base = FACTORY_URL",
            "        for part in stack:",
            "            base = '%s/%s' % (base, part)",
            "            self.REQUEST.set('BASE%d' % n, base)",
            "            n += 1",
            "        # TODO fix URLPATHn, BASEPATHn here too",
            "",
            "    def isTemporary(self, obj):",
            "        \"\"\"Check to see if an object is temporary\"\"\"",
            "        ob = aq_base(aq_parent(aq_inner(obj)))",
            "        return hasattr(ob, 'meta_type') \\",
            "                and ob.meta_type == TempFolder.meta_type",
            "",
            "    def __before_publishing_traverse__(self, other, REQUEST):",
            "",
            "        if REQUEST.get(FACTORY_INFO, None):",
            "            del REQUEST[FACTORY_INFO]",
            "",
            "        stack = REQUEST.get('TraversalRequestNameStack')",
            "        # convert from unicode if necessary (happens in Epoz for some weird",
            "        # reason)",
            "        stack = [str(s) for s in stack]",
            "",
            "        # need 2 more things on the stack at least for portal_factory to",
            "        # kick in:",
            "        #    (1) a type, and (2) an id",
            "        if len(stack) < 2:  # ignore",
            "            return",
            "",
            "        # Keep track of how many path elements we want to eat",
            "        gobbled_length = 0",
            "",
            "        type_name = stack[-1]",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        # make sure this is really a type name",
            "        if not type_name in types_tool.listContentTypes():",
            "            return  # nope -- do nothing",
            "",
            "        gobbled_length += 1",
            "",
            "        id = stack[-2]",
            "        intended_parent = aq_parent(self)",
            "        if hasattr(intended_parent, id):",
            "            return  # do normal traversal via __bobo_traverse__",
            "",
            "        gobbled_length += 1",
            "",
            "        # about to create an object",
            "",
            "        # before halting traversal, check for method aliases",
            "        # stack should be [...optional stuff..., id, type_name]",
            "        key = len(stack) >= 3 and stack[-3] or '(Default)'",
            "        ti = types_tool.getTypeInfo(type_name)",
            "        method_id = ti and ti.queryMethodID(key)",
            "        if method_id:",
            "            if key != '(Default)':",
            "                del(stack[-3])",
            "            if method_id != '(Default)':",
            "                stack.insert(-2, method_id)",
            "                gobbled_length += 1",
            "            REQUEST._hacked_path = 1",
            "        else:",
            "            gobbled_length += 1",
            "",
            "        # Pevent further traversal if we are doing a normal factory request,",
            "        # but allow it if there is a traversal sub-path beyond the (edit)",
            "        # view on the content item. In this case, portal_factory will not",
            "        # be responsible for rendering the object.",
            "        if len(stack) <= gobbled_length:",
            "            REQUEST.set('TraversalRequestNameStack', [])",
            "",
            "        stack.reverse()",
            "        factory_info = {'stack': stack}",
            "        REQUEST.set(FACTORY_INFO, factory_info)",
            "",
            "    def __bobo_traverse__(self, REQUEST, name):",
            "        # __bobo_traverse__ can be invoked directly by a restricted_traverse",
            "        # method call in which case the traversal stack will not have been",
            "        # cleared by __before_publishing_traverse__",
            "        name = str(name)  # fix unicode weirdness",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        if not name in types_tool.listContentTypes():",
            "            # not a type name -- do the standard thing",
            "            return getattr(self, name)",
            "        # a type name -- return a temp folder",
            "        return self._getTempFolder(str(name))",
            "",
            "    security.declarePublic('__call__')",
            "    def __call__(self, *args, **kwargs):",
            "        \"\"\"call method\"\"\"",
            "        self._fixRequest()",
            "        factory_info = self.REQUEST.get(FACTORY_INFO, {})",
            "        stack = factory_info['stack']",
            "        type_name = stack[0]",
            "        id = stack[1]",
            "",
            "        # do a passthrough if parent contains the id",
            "        if id in aq_parent(self):",
            "            return aq_parent(self).restrictedTraverse(",
            "                        '/'.join(stack[1:]))(*args, **kwargs)",
            "",
            "        tempFolder = self._getTempFolder(type_name)",
            "        # Mysterious hack that fixes some problematic interactions with",
            "        # SpeedPack:",
            "        #   Get the first item in the stack by explicitly calling __getitem__",
            "        temp_obj = tempFolder.__getitem__(id)",
            "        stack = stack[2:]",
            "        if stack:",
            "            try:",
            "                obj = temp_obj.restrictedTraverse('/'.join(stack))",
            "            except AttributeError:",
            "                raise NotFound",
            "",
            "            # Mimic URL traversal, sort of",
            "            if getattr(aq_base(obj), 'index_html', None):",
            "                obj = obj.restrictedTraverse('index_html')",
            "            else:",
            "                obj = getattr(obj, 'GET', obj)",
            "",
            "        else:",
            "            obj = temp_obj",
            "        return mapply(obj, self.REQUEST.args, self.REQUEST,",
            "                               call_object, 1, missing_name,",
            "                               dont_publish_class, self.REQUEST, bind=1)",
            "",
            "    index_html = None  # call __call__, not index_html",
            "",
            "    def _getTempFolder(self, type_name):",
            "        factory_info = self.REQUEST.get(FACTORY_INFO, {})",
            "        tempFolder = factory_info.get(type_name, None)",
            "        if tempFolder is not None:",
            "            tempFolder = aq_inner(tempFolder).__of__(self)",
            "            return tempFolder",
            "",
            "        # make sure we can add an object of this type to the temp folder",
            "        types_tool = getToolByName(self, 'portal_types')",
            "        if not type_name in types_tool.TempFolder.allowed_content_types:",
            "            # update allowed types for tempfolder",
            "            types_tool.TempFolder.allowed_content_types = \\",
            "                (types_tool.listContentTypes())",
            "",
            "        tempFolder = TempFolder(type_name).__of__(self)",
            "",
            "        factory_info[type_name] = tempFolder",
            "        self.REQUEST.set(FACTORY_INFO, factory_info)",
            "        return tempFolder",
            "",
            "InitializeClass(FactoryTool)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "Products.CMFPlone.FactoryTool.FactoryTool.manage_options",
            "Products.CMFPlone.FactoryTool.FactoryTool.self"
        ]
    },
    "Products/CMFPlone/tests/testCatalogTool.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 480,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "         self.assertEqual(len(self.catalog(SearchableText='\u00c9conom\u00e9trie')), 3)"
            },
            "1": {
                "beforePatchRowNumber": 481,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "         self.assertEqual(len(self.catalog(SearchableText='Econom\u00e9trie')), 3)"
            },
            "2": {
                "beforePatchRowNumber": 482,
                "afterPatchRowNumber": 482,
                "PatchRowcode": "         self.assertEqual(len(self.catalog(SearchableText='ECONOMETRIE')), 3)"
            },
            "3": {
                "beforePatchRowNumber": 483,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                "
            },
            "4": {
                "beforePatchRowNumber": 484,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                "
            },
            "5": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": 483,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 486,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        "
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+    def testSearchIsProtected(self):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+        self.login()"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+        self.folder.invokeFactory(\"Document\", \"sekretz\")"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+        self.logout()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+        catalog = self.portal.portal_catalog"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+        bogus = catalog.search({'portal_type': 'Document'})"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+        real = catalog.portal_catalog.searchResults(portal_type='Document')"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        self.assertEqual(len(bogus), len(real))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 487,
                "afterPatchRowNumber": 494,
                "PatchRowcode": " class TestCatalogSorting(PloneTestCase.PloneTestCase):"
            },
            "18": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": 495,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 496,
                "PatchRowcode": "     def afterSetUp(self):"
            }
        },
        "frontPatchFile": [
            "# -*- encoding: utf-8 -*-",
            "#",
            "# CatalogTool tests",
            "#",
            "",
            "import unittest",
            "import zope.interface",
            "",
            "from Products.CMFPlone.tests import PloneTestCase",
            "",
            "from Acquisition import aq_base",
            "from DateTime import DateTime",
            "from OFS.ObjectManager import REPLACEABLE",
            "from Products.CMFCore.permissions import AccessInactivePortalContent",
            "import transaction",
            "",
            "from plone.indexer.wrapper import IndexableObjectWrapper",
            "from Products.CMFPlone.CatalogTool import CatalogTool",
            "",
            "from Products.CMFPlone.CatalogTool import is_folderish",
            "from Products.CMFPlone.tests import dummy",
            "from plone.uuid.interfaces import IUUID",
            "from plone.uuid.interfaces import IAttributeUUID",
            "",
            "from zope.event import notify",
            "from zope.lifecycleevent import ObjectCreatedEvent",
            "from zope.interface.declarations import alsoProvides",
            "",
            "portal_name = PloneTestCase.portal_name",
            "default_user = PloneTestCase.default_user",
            "",
            "user2 = 'u2'",
            "group2 = 'g2'",
            "",
            "base_content = ['Members', 'aggregator', 'aggregator',",
            "                'events', 'news', default_user, 'front-page', 'doc']",
            "",
            "",
            "class TestCatalogSetup(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "",
            "    def testSearchableTextIsZCTextIndex(self):",
            "        # SearchableText index should be a ZCTextIndex",
            "        itype = self.catalog.Indexes['SearchableText'].__class__.__name__",
            "        self.assertEqual(itype, 'ZCTextIndex')",
            "",
            "    def testDescriptionIsZCTextIndex(self):",
            "        # Description index should be a ZCTextIndex",
            "        itype = self.catalog.Indexes['Description'].__class__.__name__",
            "        self.assertEqual(itype, 'ZCTextIndex')",
            "",
            "    def testTitleIsZCTextIndex(self):",
            "        # Title index should be a ZCTextIndex",
            "        itype = self.catalog.Indexes['Title'].__class__.__name__",
            "        self.assertEqual(itype, 'ZCTextIndex')",
            "",
            "    def testPloneLexiconIsZCTextLexicon(self):",
            "        # Lexicon should be a ZCTextIndex lexicon",
            "        self.assertTrue(hasattr(aq_base(self.catalog), 'plone_lexicon'))",
            "        self.assertEqual(self.catalog.plone_lexicon.meta_type,\\",
            "                         'ZCTextIndex Lexicon')",
            "",
            "    def testPathIsExtendedPathIndex(self):",
            "        # path index should be an ExtendedPathIndex",
            "        self.assertEqual(self.catalog.Indexes['path'].__class__.__name__,",
            "                         'ExtendedPathIndex')",
            "",
            "    def testGetObjPositionInParentIsGopipIndex(self):",
            "        # getObjPositionInParent index should be a FieldIndex",
            "        # also see TestCatalogOrdering below",
            "        self.assertEqual(",
            "             self.catalog.Indexes['getObjPositionInParent'].__class__.__name__,",
            "             'GopipIndex')",
            "",
            "    def testGetObjSizeInSchema(self):",
            "        # getObjSize column should be in catalog schema",
            "        self.assertTrue('getObjSize' in self.catalog.schema())",
            "",
            "    def testExclude_from_navInSchema(self):",
            "        # exclude_from_nav column should be in catalog schema",
            "        self.assertTrue('exclude_from_nav' in self.catalog.schema())",
            "",
            "    def testIs_folderishInSchema(self):",
            "        # is_folderish should be in catalog schema",
            "        self.assertTrue('is_folderish' in self.catalog.schema())",
            "",
            "    def testIs_folderishIsBooleanIndex(self):",
            "        # is_folderish should be a BooleanIndex",
            "        self.assertTrue(",
            "             self.catalog.Indexes['is_folderish'].__class__.__name__,",
            "             'BooleanIndex')",
            "",
            "    def testDateIsDateIndex(self):",
            "        # Date should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['Date'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testCreatedIsDateIndex(self):",
            "        # created should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['created'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testEffectiveIsDateIndex(self):",
            "        # effective should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['effective'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testEndIsDateIndex(self):",
            "        # end should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['end'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testExpiresIsDateIndex(self):",
            "        # expires should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['expires'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testModifiedIsDateIndex(self):",
            "        # modified should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['modified'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testStartIsDateIndex(self):",
            "        # start should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['start'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testEffectiveRangeIsDateRangeIndex(self):",
            "        # effectiveRange should be a DateRangeIndex",
            "        self.assertEqual(",
            "             self.catalog.Indexes['effectiveRange'].__class__.__name__,",
            "             'DateRangeIndex')",
            "",
            "    def testSortable_TitleIsFieldIndex(self):",
            "        # sortable_title should be a FieldIndex",
            "        self.assertEqual(",
            "             self.catalog.Indexes['sortable_title'].__class__.__name__,",
            "             'FieldIndex')",
            "",
            "    def testExpirationDateInSchema(self):",
            "        # ExpirationDate column should be in catalog schema",
            "        self.assertTrue('ExpirationDate' in self.catalog.schema())",
            "",
            "    def testExpiresDateNotInSchema(self):",
            "        # ExpirationDate column should be in catalog schema",
            "        self.assertFalse('ExpiresDate' in self.catalog.schema())",
            "",
            "    def testIs_Default_PageIsBooleanIndex(self):",
            "        # sortable_title should be a BooleanIndex",
            "        self.assertEqual(",
            "             self.catalog.Indexes['is_default_page'].__class__.__name__,",
            "             'BooleanIndex')",
            "",
            "",
            "class TestCatalogIndexing(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Document', id='doc',",
            "                                  title='Foo', description='Bar')",
            "        self.catalog.unindexObject(self.folder.doc)",
            "",
            "    def assertResults(self, result, expect):",
            "        # Verifies ids of catalog results against expected ids",
            "        lhs = [r.getId for r in result]",
            "        lhs.sort()",
            "        rhs = list(expect)",
            "        rhs.sort()",
            "        self.assertEqual(lhs, rhs)",
            "",
            "    def testFixture(self):",
            "        self.assertEqual(self.folder.doc.getId(), 'doc')",
            "        self.assertEqual(self.folder.doc.Title(), 'Foo')",
            "        self.assertEqual(self.folder.doc.Description(), 'Bar')",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 0)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 0)",
            "",
            "    def testIndexObject(self):",
            "        # Object should be indexed",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 1)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 1)",
            "",
            "    def testReindexObject(self):",
            "        # Object should be indexed",
            "        self.catalog.reindexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 1)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 1)",
            "",
            "    def testUnindexObject(self):",
            "        # Object should be unindexed",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.catalog.unindexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)",
            "",
            "    def testIndexObjectUpdatesMetadata(self):",
            "        # Indexing should update metadata",
            "        self.catalog.indexObject(self.folder.doc)",
            "        brain = self.catalog(getId='doc')[0]",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Foo')",
            "        self.assertEqual(brain.Description, 'Bar')",
            "",
            "    def testReindexObjectUpdatesMetadata(self):",
            "        # Reindexing should update metadata",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc)",
            "        brain = self.catalog(getId='doc')[0]",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Fred')",
            "        self.assertEqual(brain.Description, 'BamBam')",
            "",
            "    def testReindexObjectSkipsMetadata(self):",
            "        # Reindexing should not update metadata when update_metadata=0",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, update_metadata=0)",
            "        brain = self.catalog(getId='doc')[0]",
            "        # Metadata did not change",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Foo')",
            "        self.assertEqual(brain.Description, 'Bar')",
            "",
            "    def testReindexTitleOnly(self):",
            "        # Reindexing should only index the Title",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, idxs=['Title'])",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.assertEqual(len(self.catalog(Title='Fred')), 1)",
            "        # Description index did not change",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 1)",
            "        self.assertEqual(len(self.catalog(Description='BamBam')), 0)",
            "",
            "    def testReindexTitleOnlyUpdatesMetadata(self):",
            "        # Reindexing Title should update metadata",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, idxs=['Title'])",
            "        brain = self.catalog(getId='doc')[0]",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Fred')",
            "        self.assertEqual(brain.Description, 'BamBam')",
            "",
            "    def testReindexTitleOnlySkipsMetadata(self):",
            "        # Reindexing Title should not update metadata when update_metadata=0",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, idxs=['Title'],",
            "                                   update_metadata=0)",
            "        brain = self.catalog(getId='doc')[0]",
            "        # Metadata did not change",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Foo')",
            "        self.assertEqual(brain.Description, 'Bar')",
            "",
            "    def testIndexTitleOnly(self):",
            "        # Indexing should only index the Title",
            "        #",
            "        # TODO: This does not work as expected. The object",
            "        # appears to be in the catalog but is not returned",
            "        # by searchResults()!?",
            "        #",
            "        self.catalog.indexObject(self.folder.doc, idxs=['Title'])",
            "        # The document is cataloged",
            "        path = self.catalog._CatalogTool__url(self.folder.doc)",
            "        self.assertTrue(path in self.catalog._catalog.paths.values())",
            "        # But it is not returned when searching...",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 0)  # <-- Should be 1",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 0)",
            "",
            "    def testIndexIdOnly(self):",
            "        # Indexing should only index the id",
            "        #",
            "        # TODO: Demonstrate that the behavior is independent",
            "        # of index type.",
            "        #",
            "        self.catalog.indexObject(self.folder.doc, idxs=['getId'])",
            "        # The document is cataloged",
            "        path = self.catalog._CatalogTool__url(self.folder.doc)",
            "        self.assertTrue(path in self.catalog._catalog.paths.values())",
            "        # But it is not returned when searching...",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)  # <-- Should be 1",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 0)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 0)",
            "",
            "    def testClearFindAndRebuildRemovesBadContent(self):",
            "        # Index the doc for consistency",
            "        self.catalog.indexObject(self.folder.doc)",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "        # index an object which shouldn't be there",
            "        self.catalog.indexObject(self.portal.portal_skins)",
            "        res = self.catalog.searchResults()",
            "        # Since the introduction of the IIndexableObject interface, we cannot",
            "        # easily get bad content into the catalog anymore",
            "        self.assertResults(res, base_content)",
            "        self.catalog.clearFindAndRebuild()",
            "        # This will add the document added in afterSetup",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testClearFindAndRebuildAddsMissingContent(self):",
            "        # Index the doc for consistency",
            "        self.catalog.indexObject(self.folder.doc)",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "        # index an object which shouldn't be there",
            "        self.catalog.unindexObject(self.portal.Members)",
            "        altered_content = base_content[:]",
            "        altered_content.remove('Members')",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, altered_content)",
            "        self.catalog.clearFindAndRebuild()",
            "        # This will add the missing item and also the document added",
            "        # in afterSetup",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testClearFindAndRebuildKeepsModificationDate(self):",
            "        # Index the doc for consistency",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setModificationDate(DateTime(0))",
            "        self.catalog.clearFindAndRebuild()",
            "        self.assertEquals(self.folder.doc.modified(), DateTime(0))",
            "        self.assertEquals(len(self.catalog(modified=DateTime(0))), 1)",
            "",
            "",
            "class TestCatalogSearching(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.workflow = self.portal.portal_workflow",
            "        self.groups = self.portal.portal_groups",
            "",
            "        self.portal.acl_users._doAddUser(user2, 'secret', [], [])",
            "",
            "        self.folder.invokeFactory('Document', id='doc', text='foo')",
            "        self.folder.invokeFactory('Folder', id='folder2')",
            "        self.folder.folder2.invokeFactory('Document', id='doc2', text='bar')",
            "        self.workflow.doActionFor(self.folder.doc, 'hide', comment='')",
            "        self.workflow.doActionFor(self.folder.folder2, 'hide', comment='')",
            "        self.workflow.doActionFor(self.folder.folder2.doc2, 'hide', comment='')",
            "",
            "        # Used for testing AND/OR search functionality below",
            "        self.folder.invokeFactory('Document', id='aaa', text='aaa',",
            "                                  title='ccc')",
            "        self.folder.invokeFactory('Document', id='bbb', text='bbb')",
            "",
            "        self.setupAuthenticator()",
            "",
            "    def addUser2ToGroup(self):",
            "        self.groups.groupWorkspacesCreationFlag = 0",
            "        self.groups.addGroup(group2, None, [], [])",
            "        group = self.groups.getGroupById(group2)",
            "        self.loginAsPortalOwner()  # GRUF 3.52",
            "        group.addMember(user2)",
            "        self.login(default_user)  # Back to normal",
            "        return group2",
            "",
            "    def testListAllowedRolesAndUsers(self):",
            "        # Should include the group in list of allowed users",
            "        groupname = self.addUser2ToGroup()",
            "        uf = self.portal.acl_users",
            "        self.assertTrue(('user:%s' % groupname) in",
            "                self.catalog._listAllowedRolesAndUsers(uf.getUser(user2)))",
            "",
            "    def testSearchReturnsDocument(self):",
            "        # Document should be found when owner does a search",
            "        self.assertEqual(self.catalog(SearchableText='aaa')[0].id, 'aaa')",
            "",
            "    def testSearchDoesNotReturnDocument(self):",
            "        # Document should not be found when user2 does a search",
            "        self.login(user2)",
            "        self.assertEqual(len(self.catalog(SearchableText='foo')), 0)",
            "",
            "    def testSearchReturnsDocumentUsing_DefaultAND(self):",
            "        # Documents should not be found when searching 'aaa bbb' (which should",
            "        # default to AND)",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa bbb')), 0)",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa ccc')), 1)",
            "",
            "    def testSearchReturnsDocumentUsing_AND(self):",
            "        # Documents should not be found when owner does a search using AND",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa AND bbb')), 0)",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa AND ccc')), 1)",
            "",
            "    def testSearchReturnsDocumentUsing_OR(self):",
            "        # Two documents (aaa, bbb)  should be found when owner does a search",
            "        # using OR",
            "        results = self.catalog(SearchableText='aaa OR bbb')",
            "        self.assertEqual(len(results), 2)",
            "    ",
            "    def testSearchIgnoresAccents(self):",
            "        #plip 12110",
            "        self.folder.invokeFactory('Document', id='docwithaccents1', description='Econom\u00e9trie')",
            "        self.folder.invokeFactory('Document', id='docwithaccents2', description='ECONOMETRIE')",
            "        self.folder.invokeFactory('Document', id='docwithaccents3', description='\u00e9conom\u00e9trie')",
            "        self.folder.invokeFactory('Document', id='docwithaccents4', description='\u00c9CONOM\u00c9TRIE')",
            "",
            "        self.assertEqual(len(self.catalog(SearchableText='econometrie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='\u00e9conom\u00e9trie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='Econom\u00e9trie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='\u00c9CONOM\u00c9TRIE')), 4)",
            "",
            "        self.assertEqual(len(self.catalog(SearchableText='econom?trie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='econometr*')), 4)",
            "",
            "        # non-regression with eastern language (use plone.i18n ja normalizer test)",
            "        self.folder.invokeFactory('Document', id='docwithjapanchars', description=\"\u30c6\u30b9\u30c8\u30da\u30fc\u30b8\")",
            "        self.assertEqual(len(self.catalog(SearchableText=\"\u30c6\u30b9\u30c8\u30da\u30fc\u30b8\")), 1)",
            "",
            "        # test with language specific char (fr)",
            "        self.folder.invokeFactory('Document', id='docwithfrenchlatinchar', description='\u0153uf')",
            "        self.assertEqual(len(self.catalog(SearchableText='\u0153uf')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='oeuf')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='\u0152uf')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='OEUF')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='uf')), 0)",
            "",
            "    def testSearchReturnsDocumentWhenPermissionIsTroughLocalRole(self):",
            "        # After adding a group with access rights and containing user2,",
            "        # a search must find the document.",
            "        groupname = self.addUser2ToGroup()",
            "        sharingView = self.folder.unrestrictedTraverse('@@sharing')",
            "        sharingView.update_role_settings([{'id':groupname,",
            "                                           'type':'group',",
            "                                           'roles':['Owner']}])",
            "        self.login(user2)",
            "        self.assertEqual(self.catalog(SearchableText='aaa')[0].id, 'aaa')",
            "",
            "    def testSearchRespectsLocalRoleAcquisition(self):",
            "        # After adding a group with access rights and containing user2,",
            "        # a search must find the document in subfolders.",
            "        groupname = self.addUser2ToGroup()",
            "        sharingView = self.folder.unrestrictedTraverse('@@sharing')",
            "        sharingView.update_role_settings([{'id':groupname,",
            "                                           'type':'group',",
            "                                           'roles':['Owner']}])",
            "        self.login(user2)",
            "        # Local Role works in subfolder",
            "        self.assertEqual(self.catalog(SearchableText='bbb')[0].id, 'bbb')",
            "",
            "    def testSearchRespectsLocalRoleAcquisitionDisabled(self):",
            "        # After adding a group with access rights and containing user2,",
            "        # a search should not find documents in subfolders which have",
            "        # disabled local role acquisition.",
            "        groupname = self.addUser2ToGroup()",
            "        sharingView = self.folder.unrestrictedTraverse('@@sharing')",
            "        sharingView.update_role_settings([{'id':groupname,",
            "                                           'type':'group',",
            "                                           'roles':['Owner']}])",
            "        # Acquisition off for folder2",
            "        self.folder.folder2.unrestrictedTraverse('@@sharing') \\",
            "            .update_inherit(False)",
            "        # Everything in subfolder should be invisible",
            "        self.login(user2)",
            "        self.assertFalse(self.catalog(SearchableText='bar'))",
            "",
            "    def testSearchIgnoreAccents(self):",
            "        \"\"\"PLIP 12110",
            "        \"\"\"",
            "        self.folder.invokeFactory('Document', id='docwithaccents-1', text='Econom\u00e9trie', title='foo')",
            "        self.folder.invokeFactory('Document', id='docwithaccents-2', text='\u00c9conom\u00e9trie')",
            "        self.folder.invokeFactory('Document', id='docwithout-accents', text='ECONOMETRIE')",
            "",
            "        self.assertEqual(len(self.catalog(SearchableText='\u00c9conom\u00e9trie')), 3)",
            "        self.assertEqual(len(self.catalog(SearchableText='Econom\u00e9trie')), 3)",
            "        self.assertEqual(len(self.catalog(SearchableText='ECONOMETRIE')), 3)",
            "                ",
            "                ",
            "",
            "        ",
            "class TestCatalogSorting(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "",
            "        self.folder.invokeFactory('Document', id='doc', text='foo')",
            "        self.folder.doc.setTitle('12 Document 25')",
            "        self.folder.invokeFactory('Document', id='doc2', text='foo')",
            "        self.folder.doc2.setTitle('3 Document 4')",
            "        self.folder.invokeFactory('Document', id='doc3', text='foo')",
            "        self.folder.doc3.setTitle('12 Document 4')",
            "",
            "        self.folder.invokeFactory('Document', id='doc4', text='bar')",
            "        self.folder.doc4.setTitle('document 12')",
            "        self.folder.invokeFactory('Document', id='doc5', text='bar')",
            "        self.folder.doc5.setTitle('Document 2')",
            "        self.folder.invokeFactory('Document', id='doc6', text='bar')",
            "        self.folder.doc6.setTitle('DOCUMENT 4')",
            "        self.folder.doc.reindexObject()",
            "        self.folder.doc2.reindexObject()",
            "        self.folder.doc3.reindexObject()",
            "        self.folder.doc4.reindexObject()",
            "        self.folder.doc5.reindexObject()",
            "        self.folder.doc6.reindexObject()",
            "",
            "    def testSortTitleReturnsProperOrderForNumbers(self):",
            "        # Documents should be returned in proper numeric order",
            "        results = self.catalog(SearchableText='foo', sort_on='sortable_title')",
            "        self.assertEqual(results[0].getId, 'doc2')",
            "        self.assertEqual(results[1].getId, 'doc3')",
            "        self.assertEqual(results[2].getId, 'doc')",
            "",
            "    def testSortTitleIgnoresCase(self):",
            "        # Documents should be returned in case insensitive order",
            "        results = self.catalog(SearchableText='bar', sort_on='sortable_title')",
            "        self.assertEqual(results[0].getId, 'doc5')",
            "        self.assertEqual(results[1].getId, 'doc6')",
            "        self.assertEqual(results[2].getId, 'doc4')",
            "",
            "    def testSortableTitleOutput(self):",
            "        doc = self.folder.doc",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "",
            "        self.assertEqual(wrapped.sortable_title, '0012 document 0025')",
            "",
            "    def testSortableNonASCIITitles(self):",
            "        #test a utf-8 encoded string gets properly unicode converted",
            "        #sort must ignore accents",
            "        title = 'La Pe\\xc3\\xb1a'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title, 'la pena')",
            "",
            "    def testSortableDate(self):",
            "        title = '2012-06-01 foo document'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         '2012-0006-0001 foo document')",
            "",
            "    def testSortableLongNumberPrefix(self):",
            "        title = '1.2.3 foo document'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         '0001.0002.0003 foo document')",
            "        title = '1.2.3 foo program'",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         '0001.0002.0003 foo program')",
            "",
            "    def testSortableLongCommonPrefix(self):",
            "        title = 'some documents have too long a name and only differ at ' \\",
            "            'the very end - like 1.jpeg'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         'some documents have too lon... 0001.jpeg')",
            "",
            "",
            "class TestFolderCataloging(PloneTestCase.PloneTestCase):",
            "    # Tests for http://dev.plone.org/plone/ticket/2876",
            "    # folder_rename must recatalog.",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Folder', id='foo')",
            "        self.setupAuthenticator()",
            "",
            "    def testFolderTitleIsUpdatedOnFolderTitleChange(self):",
            "        # The bug in fact talks about folder_rename",
            "        title = 'Test Folder - Snooze!'",
            "        foo_path = '/'.join(self.folder.foo.getPhysicalPath())",
            "        self.setRequestMethod('POST')",
            "        self.folder.folder_rename(paths=[foo_path], new_ids=['foo'],",
            "                                  new_titles=[title])",
            "        results = self.catalog(Title='Snooze')",
            "        self.assertTrue(results)",
            "        for result in results:",
            "            self.assertEqual(result.Title, title)",
            "            self.assertEqual(result.getId, 'foo')",
            "",
            "    def testFolderTitleIsUpdatedOnFolderRename(self):",
            "        # The bug in fact talks about folder_rename",
            "        title = 'Test Folder - Snooze!'",
            "        transaction.savepoint(optimistic=True)  # make rename work",
            "        foo_path = '/'.join(self.folder.foo.getPhysicalPath())",
            "        self.setRequestMethod('POST')",
            "        self.folder.folder_rename(paths=[foo_path], new_ids=['bar'],",
            "                                  new_titles=[title])",
            "        results = self.catalog(Title='Snooze')",
            "        self.assertTrue(results)",
            "        for result in results:",
            "            self.assertEqual(result.Title, title)",
            "            self.assertEqual(result.getId, 'bar')",
            "",
            "    def testSetTitleDoesNotUpdateCatalog(self):",
            "        # setTitle() should not update the catalog",
            "        title = 'Test Folder - Snooze!'",
            "        self.assertTrue(self.catalog(getId='foo'))",
            "        self.folder.foo.setTitle(title)",
            "        #Title is a TextIndex",
            "        self.assertFalse(self.catalog(Title='Snooze'))",
            "",
            "",
            "class TestCatalogOrdering(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Document', id='doc1', text='foo')",
            "        self.folder.invokeFactory('Document', id='doc2', text='bar')",
            "        self.folder.invokeFactory('Document', id='doc3', text='bloo')",
            "        self.folder.invokeFactory('Document', id='doc4', text='blee')",
            "",
            "    def testInitialOrder(self):",
            "        self.assertEqual(self.folder.getObjectPosition('doc1'), 0)",
            "        self.assertEqual(self.folder.getObjectPosition('doc2'), 1)",
            "        self.assertEqual(self.folder.getObjectPosition('doc3'), 2)",
            "        self.assertEqual(self.folder.getObjectPosition('doc4'), 3)",
            "",
            "    def testOrderIsUpdatedOnMoveDown(self):",
            "        self.folder.folder_position('down', 'doc1')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc2', 'doc1', 'doc3', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsUpdatedOnMoveUp(self):",
            "        self.folder.folder_position('up', 'doc3')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc3', 'doc2', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsUpdatedOnMoveTop(self):",
            "        self.folder.folder_position('top', 'doc3')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc3', 'doc1', 'doc2', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsUpdatedOnMoveBottom(self):",
            "        self.folder.folder_position('bottom', 'doc3')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc2', 'doc4', 'doc3']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsFineWithObjectCreation(self):",
            "        self.folder.invokeFactory('Document', id='doc5', text='blam')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc2', 'doc3', 'doc4', 'doc5']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsFineWithObjectDeletion(self):",
            "        self.folder.manage_delObjects(['doc3', ])",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc2', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsFineWithObjectRenaming(self):",
            "",
            "        # I don't know why this is failing. manage_renameObjects throws an",
            "        # error that blames permissions or lack of support by the obj. The",
            "        # obj is a # Plone Document, and the owner of doc2 is portal_owner.",
            "        # Harumph.",
            "",
            "        transaction.savepoint(optimistic=True)",
            "",
            "        self.folder.manage_renameObjects(['doc2'], ['buzz'])",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'buzz', 'doc3', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderAfterALotOfChanges(self):",
            "        # ['doc1','doc2','doc3','doc4']",
            "",
            "        self.folder.folder_position('down', 'doc1')",
            "        self.folder.folder_position('down', 'doc1')",
            "        # ['doc2','doc3','doc1','doc4']",
            "",
            "        self.folder.folder_position('top', 'doc3')",
            "        # ['doc3','doc2','doc1','doc4']",
            "",
            "        self.folder.invokeFactory('Document', id='doc5', text='blam')",
            "        self.folder.invokeFactory('Document', id='doc6', text='blam')",
            "        self.folder.invokeFactory('Document', id='doc7', text='blam')",
            "        self.folder.invokeFactory('Document', id='doc8', text='blam')",
            "        # ['doc3','doc2','doc1','doc4','doc5','doc6','doc7','doc8',]",
            "",
            "        #self.folder.manage_renameObjects('Document', id='doc5', text='blam')",
            "",
            "        self.folder.manage_delObjects(['doc3', 'doc4', 'doc5', 'doc7'])",
            "        expected = ['doc2', 'doc1', 'doc6', 'doc8']",
            "",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testAllObjectsHaveOrder(self):",
            "        #Make sure that a query with sort_on='getObjPositionInParent'",
            "        #returns the same number of results as one without, make sure",
            "        #the Members folder is in the catalog and has getObjPositionInParent",
            "        all_objs = self.catalog()",
            "        sorted_objs = self.catalog(sort_on='getObjPositionInParent')",
            "        self.assertEqual(len(all_objs), len(sorted_objs))",
            "",
            "        members = self.portal.Members",
            "        members_path = '/'.join(members.getPhysicalPath())",
            "        members_query = self.catalog(path=members_path)",
            "        members_sorted = self.catalog(",
            "                                path=members_path,",
            "                                sort_on='getObjPositionInParent')",
            "        self.assertTrue(len(members_query))",
            "        self.assertEqual(len(members_query), len(members_sorted))",
            "",
            "    def testGopipIndexer(self):",
            "        from Products.CMFPlone.CatalogTool import getObjPositionInParent",
            "        get_pos = getObjPositionInParent.callable",
            "        self.assertEqual(get_pos(self.folder.doc1), 0)",
            "        self.assertEqual(get_pos(self.folder.doc4), 3)",
            "",
            "",
            "class TestCatalogBugs(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        # Make the catalog tool paste-able",
            "        self._saved = CatalogTool.__replaceable__",
            "        CatalogTool.__replaceable__ = REPLACEABLE",
            "",
            "    def afterClear(self):",
            "        CatalogTool.__replaceable__ = self._saved",
            "",
            "    def testCanPasteCatalog(self):",
            "        # Should be able to copy/paste a portal_catalog. Triggers",
            "        # manage_afterAdd of portal_catalog thereby exposing another bug :-/",
            "        self.setRoles(['Manager'])",
            "        cb = self.portal.manage_copyObjects(['portal_catalog'])",
            "        self.folder.manage_pasteObjects(cb)",
            "        self.assertTrue(hasattr(aq_base(self.folder), 'portal_catalog'))",
            "",
            "    def testPastingCatalogPreservesTextIndexes(self):",
            "        # Pasting the catalog should not cause indexes to be removed.",
            "        self.setRoles(['Manager'])",
            "        cb = self.portal.manage_copyObjects(['portal_catalog'])",
            "        self.folder.manage_pasteObjects(cb)",
            "        self.assertTrue(hasattr(aq_base(self.folder), 'portal_catalog'))",
            "        cat = self.folder.portal_catalog",
            "        self.assertTrue('SearchableText' in cat.indexes())",
            "        # CMF added lexicons should stick around too",
            "        self.assertTrue(hasattr(aq_base(cat), 'plaintext_lexicon'))",
            "",
            "",
            "class TestCatalogUnindexing(PloneTestCase.PloneTestCase):",
            "    # Tests for http://dev.plone.org/plone/ticket/3547",
            "    # Published objects are not unindexed on delete?",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.workflow = self.portal.portal_workflow",
            "        self.folder.invokeFactory('Document', id='doc')",
            "        self.setupAuthenticator()",
            "",
            "    def testVisibleIsDefault(self):",
            "        state = self.workflow.getInfoFor(self.folder.doc, 'review_state')",
            "        self.assertEqual(state, 'visible')",
            "",
            "    def testVisibleCanBeFound(self):",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testVisibleIsUnindexed(self):",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPrivateCanBeFound(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'hide')",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testPrivateIsUnindexed(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'hide')",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPendingCanBeFound(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'submit')",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testPendingIsUnindexed(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'submit')",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedCanBeFound(self):",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexed(self):",
            "        # Works here!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexedIfOwnerDeletes(self):",
            "        # Works here!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.setRoles(['Member'])",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexedByFolderDeleteScript(self):",
            "        # Works here too!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.setRoles(['Member'])",
            "        doc_path = '/'.join(self.folder.doc.getPhysicalPath())",
            "        self.app.REQUEST.set('paths', [doc_path])",
            "        # folder_delete requires a non-GET request",
            "        self.setRequestMethod('POST')",
            "        self.folder.folder_delete()",
            "        self.setRequestMethod('GET')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexedWhenDeletingParentFolder(self):",
            "        # Works here too!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.setRoles(['Member'])",
            "        self.folder.aq_parent._delObject(self.folder.getId())",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "",
            "class TestCatalogExpirationFiltering(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Document', id='doc')",
            "",
            "    def nofx(self):",
            "        # Removes effective and expires to make sure we only test",
            "        # the DateRangeIndex.",
            "        self.catalog.delIndex('effective')",
            "        self.catalog.delIndex('expires')",
            "",
            "    def assertResults(self, result, expect):",
            "        # Verifies ids of catalog results against expected ids",
            "        lhs = [r.getId for r in result]",
            "        lhs.sort()",
            "        rhs = list(expect)",
            "        rhs.sort()",
            "        self.assertEqual(lhs, rhs)",
            "",
            "    def testCeilingPatch(self):",
            "        self.assertEqual(self.folder.doc.expires(), DateTime(2500, 0))",
            "",
            "    def testSearchResults(self):",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testCall(self):",
            "        res = self.catalog()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testSearchResultsExpired(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "    def testCallExpired(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog()",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "    def testSearchResultsExpiredWithExpiredDisabled(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog.searchResults(dict(show_inactive=True))",
            "        self.assertResults(res, base_content)",
            "",
            "    def testCallExpiredWithExpiredDisabled(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog(show_inactive=True)",
            "        self.assertResults(res, base_content)",
            "",
            "    def testSearchResultsExpiredWithPermission(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        self.setPermissions([AccessInactivePortalContent])",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testCallExpiredWithPermission(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        self.setPermissions([AccessInactivePortalContent])",
            "        res = self.catalog()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testSearchResultsWithAdditionalExpiryFilter(self):",
            "        # For this test we want the expires and effective indices in place,",
            "        # let's make sure everything still works",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content[:-1])",
            "        # Now make the object expire at some fixed date in the future",
            "        self.folder.doc.setExpirationDate(DateTime() + 2)",
            "        self.folder.doc.reindexObject()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "        # We should be able to further limit the search using the exipres",
            "        # and efective indices.",
            "        res = self.catalog.searchResults(dict(expires={",
            "                                            'query': DateTime() + 3,",
            "                                            'range': 'min'}))",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "    def testSearchResultsExpiredWithAdditionalExpiryFilter(self):",
            "        # Now make the object expire at some date in the recent past",
            "        self.folder.doc.setExpirationDate(DateTime() - 2)",
            "        self.folder.doc.reindexObject()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content[:-1])",
            "        # Even if we explicitly ask for it, we shouldn't get expired content",
            "        res = self.catalog.searchResults(dict(expires={",
            "                                            'query': DateTime() - 3,",
            "                                            'range': 'min'}))",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "",
            "def dummyMethod(obj, **kwargs):",
            "    return 'a dummy'",
            "",
            "",
            "class TestIndexers(PloneTestCase.PloneTestCase):",
            "    \"\"\"Tests for IIndexer adapters",
            "    \"\"\"",
            "",
            "    def afterSetUp(self):",
            "        self.folder.invokeFactory('Document', 'doc', title='document')",
            "        self.doc = self.folder.doc",
            "",
            "    def testSetup(self):",
            "        doc = self.doc",
            "        self.assertEqual(doc.getId(), 'doc')",
            "        self.assertEqual(doc.Title(), 'document')",
            "",
            "    def test_is_folderishWithNonFolder(self):",
            "        i = dummy.Item()",
            "        self.assertFalse(is_folderish(i)())",
            "",
            "    def test_is_folderishWithFolder(self):",
            "        f = dummy.Folder('struct_folder')",
            "        self.assertTrue(is_folderish(f)())",
            "",
            "    def test_is_folderishWithNonStructuralFolder(self):",
            "        f = dummy.NonStructuralFolder('ns_folder')",
            "        self.assertFalse(is_folderish(f)())",
            "",
            "    def test_provided(self):",
            "        from Products.CMFCore.interfaces import IContentish",
            "        from plone.indexer.interfaces import IIndexableObjectWrapper",
            "        from Products.CMFCore.tests.base.dummy import DummyContent",
            "",
            "        obj = DummyContent()",
            "        w = IndexableObjectWrapper(obj, self.portal.portal_catalog)",
            "",
            "        self.assertTrue(IIndexableObjectWrapper.providedBy(w))",
            "        self.assertTrue(IContentish.providedBy(w))",
            "",
            "    def test_getIcon(self):",
            "        doc = self.doc",
            "        iconname = doc.getIcon(relative_to_portal=1)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.getIcon, iconname)",
            "",
            "    def test_getObjSize(self):",
            "        from Products.CMFPlone.CatalogTool import getObjSize",
            "        get_size = getObjSize.callable",
            "        self.doc.setText(u'a' * 1000)",
            "        self.doc.reindexObject()",
            "        self.assertEqual(get_size(self.doc), '1 KB')",
            "",
            "    def test_uuid(self):",
            "        alsoProvides(self.doc, IAttributeUUID)",
            "        notify(ObjectCreatedEvent(self.doc))",
            "",
            "        uuid = IUUID(self.doc, None)",
            "        wrapped = IndexableObjectWrapper(self.doc, self.portal.portal_catalog)",
            "        self.assertTrue(wrapped.UID)",
            "        self.assertTrue(uuid == wrapped.UID)",
            "",
            "",
            "class TestMetadata(PloneTestCase.PloneTestCase):",
            "    \"\"\"",
            "    \"\"\"",
            "",
            "    def testLocationAddedToMetdata(self):",
            "        self.folder.invokeFactory('Document', 'doc', title='document', location=\"foobar\")",
            "        doc = self.folder.doc",
            "        catalog = self.portal.portal_catalog",
            "        brain = catalog(UID=doc.UID())[0]",
            "        self.assertEquals(brain.location, doc.getLocation())",
            "",
            "",
            "class TestObjectProvidedIndexExtender(unittest.TestCase):",
            "",
            "    def _index(self, object):",
            "        from Products.CMFPlone.CatalogTool import object_provides",
            "        return object_provides(object)()",
            "",
            "    def testNoInterfaces(self):",
            "        class Dummy(object):",
            "            pass",
            "        self.assertEqual(self._index(Dummy()), ())",
            "",
            "    def testSimpleInterface(self):",
            "        class IDummy(zope.interface.Interface):",
            "            pass",
            "",
            "        class Dummy(object):",
            "            zope.interface.implements(IDummy)",
            "        self.assertEqual(self._index(Dummy()),",
            "            ('Products.CMFPlone.tests.testCatalogTool.IDummy', ))"
        ],
        "afterPatchFile": [
            "# -*- encoding: utf-8 -*-",
            "#",
            "# CatalogTool tests",
            "#",
            "",
            "import unittest",
            "import zope.interface",
            "",
            "from Products.CMFPlone.tests import PloneTestCase",
            "",
            "from Acquisition import aq_base",
            "from DateTime import DateTime",
            "from OFS.ObjectManager import REPLACEABLE",
            "from Products.CMFCore.permissions import AccessInactivePortalContent",
            "import transaction",
            "",
            "from plone.indexer.wrapper import IndexableObjectWrapper",
            "from Products.CMFPlone.CatalogTool import CatalogTool",
            "",
            "from Products.CMFPlone.CatalogTool import is_folderish",
            "from Products.CMFPlone.tests import dummy",
            "from plone.uuid.interfaces import IUUID",
            "from plone.uuid.interfaces import IAttributeUUID",
            "",
            "from zope.event import notify",
            "from zope.lifecycleevent import ObjectCreatedEvent",
            "from zope.interface.declarations import alsoProvides",
            "",
            "portal_name = PloneTestCase.portal_name",
            "default_user = PloneTestCase.default_user",
            "",
            "user2 = 'u2'",
            "group2 = 'g2'",
            "",
            "base_content = ['Members', 'aggregator', 'aggregator',",
            "                'events', 'news', default_user, 'front-page', 'doc']",
            "",
            "",
            "class TestCatalogSetup(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "",
            "    def testSearchableTextIsZCTextIndex(self):",
            "        # SearchableText index should be a ZCTextIndex",
            "        itype = self.catalog.Indexes['SearchableText'].__class__.__name__",
            "        self.assertEqual(itype, 'ZCTextIndex')",
            "",
            "    def testDescriptionIsZCTextIndex(self):",
            "        # Description index should be a ZCTextIndex",
            "        itype = self.catalog.Indexes['Description'].__class__.__name__",
            "        self.assertEqual(itype, 'ZCTextIndex')",
            "",
            "    def testTitleIsZCTextIndex(self):",
            "        # Title index should be a ZCTextIndex",
            "        itype = self.catalog.Indexes['Title'].__class__.__name__",
            "        self.assertEqual(itype, 'ZCTextIndex')",
            "",
            "    def testPloneLexiconIsZCTextLexicon(self):",
            "        # Lexicon should be a ZCTextIndex lexicon",
            "        self.assertTrue(hasattr(aq_base(self.catalog), 'plone_lexicon'))",
            "        self.assertEqual(self.catalog.plone_lexicon.meta_type,\\",
            "                         'ZCTextIndex Lexicon')",
            "",
            "    def testPathIsExtendedPathIndex(self):",
            "        # path index should be an ExtendedPathIndex",
            "        self.assertEqual(self.catalog.Indexes['path'].__class__.__name__,",
            "                         'ExtendedPathIndex')",
            "",
            "    def testGetObjPositionInParentIsGopipIndex(self):",
            "        # getObjPositionInParent index should be a FieldIndex",
            "        # also see TestCatalogOrdering below",
            "        self.assertEqual(",
            "             self.catalog.Indexes['getObjPositionInParent'].__class__.__name__,",
            "             'GopipIndex')",
            "",
            "    def testGetObjSizeInSchema(self):",
            "        # getObjSize column should be in catalog schema",
            "        self.assertTrue('getObjSize' in self.catalog.schema())",
            "",
            "    def testExclude_from_navInSchema(self):",
            "        # exclude_from_nav column should be in catalog schema",
            "        self.assertTrue('exclude_from_nav' in self.catalog.schema())",
            "",
            "    def testIs_folderishInSchema(self):",
            "        # is_folderish should be in catalog schema",
            "        self.assertTrue('is_folderish' in self.catalog.schema())",
            "",
            "    def testIs_folderishIsBooleanIndex(self):",
            "        # is_folderish should be a BooleanIndex",
            "        self.assertTrue(",
            "             self.catalog.Indexes['is_folderish'].__class__.__name__,",
            "             'BooleanIndex')",
            "",
            "    def testDateIsDateIndex(self):",
            "        # Date should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['Date'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testCreatedIsDateIndex(self):",
            "        # created should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['created'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testEffectiveIsDateIndex(self):",
            "        # effective should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['effective'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testEndIsDateIndex(self):",
            "        # end should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['end'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testExpiresIsDateIndex(self):",
            "        # expires should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['expires'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testModifiedIsDateIndex(self):",
            "        # modified should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['modified'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testStartIsDateIndex(self):",
            "        # start should be a DateIndex",
            "        self.assertEqual(self.catalog.Indexes['start'].__class__.__name__,",
            "                         'DateIndex')",
            "",
            "    def testEffectiveRangeIsDateRangeIndex(self):",
            "        # effectiveRange should be a DateRangeIndex",
            "        self.assertEqual(",
            "             self.catalog.Indexes['effectiveRange'].__class__.__name__,",
            "             'DateRangeIndex')",
            "",
            "    def testSortable_TitleIsFieldIndex(self):",
            "        # sortable_title should be a FieldIndex",
            "        self.assertEqual(",
            "             self.catalog.Indexes['sortable_title'].__class__.__name__,",
            "             'FieldIndex')",
            "",
            "    def testExpirationDateInSchema(self):",
            "        # ExpirationDate column should be in catalog schema",
            "        self.assertTrue('ExpirationDate' in self.catalog.schema())",
            "",
            "    def testExpiresDateNotInSchema(self):",
            "        # ExpirationDate column should be in catalog schema",
            "        self.assertFalse('ExpiresDate' in self.catalog.schema())",
            "",
            "    def testIs_Default_PageIsBooleanIndex(self):",
            "        # sortable_title should be a BooleanIndex",
            "        self.assertEqual(",
            "             self.catalog.Indexes['is_default_page'].__class__.__name__,",
            "             'BooleanIndex')",
            "",
            "",
            "class TestCatalogIndexing(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Document', id='doc',",
            "                                  title='Foo', description='Bar')",
            "        self.catalog.unindexObject(self.folder.doc)",
            "",
            "    def assertResults(self, result, expect):",
            "        # Verifies ids of catalog results against expected ids",
            "        lhs = [r.getId for r in result]",
            "        lhs.sort()",
            "        rhs = list(expect)",
            "        rhs.sort()",
            "        self.assertEqual(lhs, rhs)",
            "",
            "    def testFixture(self):",
            "        self.assertEqual(self.folder.doc.getId(), 'doc')",
            "        self.assertEqual(self.folder.doc.Title(), 'Foo')",
            "        self.assertEqual(self.folder.doc.Description(), 'Bar')",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 0)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 0)",
            "",
            "    def testIndexObject(self):",
            "        # Object should be indexed",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 1)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 1)",
            "",
            "    def testReindexObject(self):",
            "        # Object should be indexed",
            "        self.catalog.reindexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 1)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 1)",
            "",
            "    def testUnindexObject(self):",
            "        # Object should be unindexed",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.catalog.unindexObject(self.folder.doc)",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)",
            "",
            "    def testIndexObjectUpdatesMetadata(self):",
            "        # Indexing should update metadata",
            "        self.catalog.indexObject(self.folder.doc)",
            "        brain = self.catalog(getId='doc')[0]",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Foo')",
            "        self.assertEqual(brain.Description, 'Bar')",
            "",
            "    def testReindexObjectUpdatesMetadata(self):",
            "        # Reindexing should update metadata",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc)",
            "        brain = self.catalog(getId='doc')[0]",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Fred')",
            "        self.assertEqual(brain.Description, 'BamBam')",
            "",
            "    def testReindexObjectSkipsMetadata(self):",
            "        # Reindexing should not update metadata when update_metadata=0",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, update_metadata=0)",
            "        brain = self.catalog(getId='doc')[0]",
            "        # Metadata did not change",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Foo')",
            "        self.assertEqual(brain.Description, 'Bar')",
            "",
            "    def testReindexTitleOnly(self):",
            "        # Reindexing should only index the Title",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, idxs=['Title'])",
            "        self.assertEqual(len(self.catalog(getId='doc')), 1)",
            "        self.assertEqual(len(self.catalog(Title='Fred')), 1)",
            "        # Description index did not change",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 1)",
            "        self.assertEqual(len(self.catalog(Description='BamBam')), 0)",
            "",
            "    def testReindexTitleOnlyUpdatesMetadata(self):",
            "        # Reindexing Title should update metadata",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, idxs=['Title'])",
            "        brain = self.catalog(getId='doc')[0]",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Fred')",
            "        self.assertEqual(brain.Description, 'BamBam')",
            "",
            "    def testReindexTitleOnlySkipsMetadata(self):",
            "        # Reindexing Title should not update metadata when update_metadata=0",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setTitle('Fred')",
            "        self.folder.doc.setDescription('BamBam')",
            "        self.catalog.reindexObject(self.folder.doc, idxs=['Title'],",
            "                                   update_metadata=0)",
            "        brain = self.catalog(getId='doc')[0]",
            "        # Metadata did not change",
            "        self.assertEqual(brain.getId, 'doc')",
            "        self.assertEqual(brain.Title, 'Foo')",
            "        self.assertEqual(brain.Description, 'Bar')",
            "",
            "    def testIndexTitleOnly(self):",
            "        # Indexing should only index the Title",
            "        #",
            "        # TODO: This does not work as expected. The object",
            "        # appears to be in the catalog but is not returned",
            "        # by searchResults()!?",
            "        #",
            "        self.catalog.indexObject(self.folder.doc, idxs=['Title'])",
            "        # The document is cataloged",
            "        path = self.catalog._CatalogTool__url(self.folder.doc)",
            "        self.assertTrue(path in self.catalog._catalog.paths.values())",
            "        # But it is not returned when searching...",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 0)  # <-- Should be 1",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 0)",
            "",
            "    def testIndexIdOnly(self):",
            "        # Indexing should only index the id",
            "        #",
            "        # TODO: Demonstrate that the behavior is independent",
            "        # of index type.",
            "        #",
            "        self.catalog.indexObject(self.folder.doc, idxs=['getId'])",
            "        # The document is cataloged",
            "        path = self.catalog._CatalogTool__url(self.folder.doc)",
            "        self.assertTrue(path in self.catalog._catalog.paths.values())",
            "        # But it is not returned when searching...",
            "        self.assertEqual(len(self.catalog(getId='doc')), 0)  # <-- Should be 1",
            "        self.assertEqual(len(self.catalog(Title='Foo')), 0)",
            "        self.assertEqual(len(self.catalog(Description='Bar')), 0)",
            "",
            "    def testClearFindAndRebuildRemovesBadContent(self):",
            "        # Index the doc for consistency",
            "        self.catalog.indexObject(self.folder.doc)",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "        # index an object which shouldn't be there",
            "        self.catalog.indexObject(self.portal.portal_skins)",
            "        res = self.catalog.searchResults()",
            "        # Since the introduction of the IIndexableObject interface, we cannot",
            "        # easily get bad content into the catalog anymore",
            "        self.assertResults(res, base_content)",
            "        self.catalog.clearFindAndRebuild()",
            "        # This will add the document added in afterSetup",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testClearFindAndRebuildAddsMissingContent(self):",
            "        # Index the doc for consistency",
            "        self.catalog.indexObject(self.folder.doc)",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "        # index an object which shouldn't be there",
            "        self.catalog.unindexObject(self.portal.Members)",
            "        altered_content = base_content[:]",
            "        altered_content.remove('Members')",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, altered_content)",
            "        self.catalog.clearFindAndRebuild()",
            "        # This will add the missing item and also the document added",
            "        # in afterSetup",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testClearFindAndRebuildKeepsModificationDate(self):",
            "        # Index the doc for consistency",
            "        self.catalog.indexObject(self.folder.doc)",
            "        self.folder.doc.setModificationDate(DateTime(0))",
            "        self.catalog.clearFindAndRebuild()",
            "        self.assertEquals(self.folder.doc.modified(), DateTime(0))",
            "        self.assertEquals(len(self.catalog(modified=DateTime(0))), 1)",
            "",
            "",
            "class TestCatalogSearching(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.workflow = self.portal.portal_workflow",
            "        self.groups = self.portal.portal_groups",
            "",
            "        self.portal.acl_users._doAddUser(user2, 'secret', [], [])",
            "",
            "        self.folder.invokeFactory('Document', id='doc', text='foo')",
            "        self.folder.invokeFactory('Folder', id='folder2')",
            "        self.folder.folder2.invokeFactory('Document', id='doc2', text='bar')",
            "        self.workflow.doActionFor(self.folder.doc, 'hide', comment='')",
            "        self.workflow.doActionFor(self.folder.folder2, 'hide', comment='')",
            "        self.workflow.doActionFor(self.folder.folder2.doc2, 'hide', comment='')",
            "",
            "        # Used for testing AND/OR search functionality below",
            "        self.folder.invokeFactory('Document', id='aaa', text='aaa',",
            "                                  title='ccc')",
            "        self.folder.invokeFactory('Document', id='bbb', text='bbb')",
            "",
            "        self.setupAuthenticator()",
            "",
            "    def addUser2ToGroup(self):",
            "        self.groups.groupWorkspacesCreationFlag = 0",
            "        self.groups.addGroup(group2, None, [], [])",
            "        group = self.groups.getGroupById(group2)",
            "        self.loginAsPortalOwner()  # GRUF 3.52",
            "        group.addMember(user2)",
            "        self.login(default_user)  # Back to normal",
            "        return group2",
            "",
            "    def testListAllowedRolesAndUsers(self):",
            "        # Should include the group in list of allowed users",
            "        groupname = self.addUser2ToGroup()",
            "        uf = self.portal.acl_users",
            "        self.assertTrue(('user:%s' % groupname) in",
            "                self.catalog._listAllowedRolesAndUsers(uf.getUser(user2)))",
            "",
            "    def testSearchReturnsDocument(self):",
            "        # Document should be found when owner does a search",
            "        self.assertEqual(self.catalog(SearchableText='aaa')[0].id, 'aaa')",
            "",
            "    def testSearchDoesNotReturnDocument(self):",
            "        # Document should not be found when user2 does a search",
            "        self.login(user2)",
            "        self.assertEqual(len(self.catalog(SearchableText='foo')), 0)",
            "",
            "    def testSearchReturnsDocumentUsing_DefaultAND(self):",
            "        # Documents should not be found when searching 'aaa bbb' (which should",
            "        # default to AND)",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa bbb')), 0)",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa ccc')), 1)",
            "",
            "    def testSearchReturnsDocumentUsing_AND(self):",
            "        # Documents should not be found when owner does a search using AND",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa AND bbb')), 0)",
            "        self.assertEqual(len(self.catalog(SearchableText='aaa AND ccc')), 1)",
            "",
            "    def testSearchReturnsDocumentUsing_OR(self):",
            "        # Two documents (aaa, bbb)  should be found when owner does a search",
            "        # using OR",
            "        results = self.catalog(SearchableText='aaa OR bbb')",
            "        self.assertEqual(len(results), 2)",
            "    ",
            "    def testSearchIgnoresAccents(self):",
            "        #plip 12110",
            "        self.folder.invokeFactory('Document', id='docwithaccents1', description='Econom\u00e9trie')",
            "        self.folder.invokeFactory('Document', id='docwithaccents2', description='ECONOMETRIE')",
            "        self.folder.invokeFactory('Document', id='docwithaccents3', description='\u00e9conom\u00e9trie')",
            "        self.folder.invokeFactory('Document', id='docwithaccents4', description='\u00c9CONOM\u00c9TRIE')",
            "",
            "        self.assertEqual(len(self.catalog(SearchableText='econometrie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='\u00e9conom\u00e9trie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='Econom\u00e9trie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='\u00c9CONOM\u00c9TRIE')), 4)",
            "",
            "        self.assertEqual(len(self.catalog(SearchableText='econom?trie')), 4)",
            "        self.assertEqual(len(self.catalog(SearchableText='econometr*')), 4)",
            "",
            "        # non-regression with eastern language (use plone.i18n ja normalizer test)",
            "        self.folder.invokeFactory('Document', id='docwithjapanchars', description=\"\u30c6\u30b9\u30c8\u30da\u30fc\u30b8\")",
            "        self.assertEqual(len(self.catalog(SearchableText=\"\u30c6\u30b9\u30c8\u30da\u30fc\u30b8\")), 1)",
            "",
            "        # test with language specific char (fr)",
            "        self.folder.invokeFactory('Document', id='docwithfrenchlatinchar', description='\u0153uf')",
            "        self.assertEqual(len(self.catalog(SearchableText='\u0153uf')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='oeuf')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='\u0152uf')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='OEUF')), 1)",
            "        self.assertEqual(len(self.catalog(SearchableText='uf')), 0)",
            "",
            "    def testSearchReturnsDocumentWhenPermissionIsTroughLocalRole(self):",
            "        # After adding a group with access rights and containing user2,",
            "        # a search must find the document.",
            "        groupname = self.addUser2ToGroup()",
            "        sharingView = self.folder.unrestrictedTraverse('@@sharing')",
            "        sharingView.update_role_settings([{'id':groupname,",
            "                                           'type':'group',",
            "                                           'roles':['Owner']}])",
            "        self.login(user2)",
            "        self.assertEqual(self.catalog(SearchableText='aaa')[0].id, 'aaa')",
            "",
            "    def testSearchRespectsLocalRoleAcquisition(self):",
            "        # After adding a group with access rights and containing user2,",
            "        # a search must find the document in subfolders.",
            "        groupname = self.addUser2ToGroup()",
            "        sharingView = self.folder.unrestrictedTraverse('@@sharing')",
            "        sharingView.update_role_settings([{'id':groupname,",
            "                                           'type':'group',",
            "                                           'roles':['Owner']}])",
            "        self.login(user2)",
            "        # Local Role works in subfolder",
            "        self.assertEqual(self.catalog(SearchableText='bbb')[0].id, 'bbb')",
            "",
            "    def testSearchRespectsLocalRoleAcquisitionDisabled(self):",
            "        # After adding a group with access rights and containing user2,",
            "        # a search should not find documents in subfolders which have",
            "        # disabled local role acquisition.",
            "        groupname = self.addUser2ToGroup()",
            "        sharingView = self.folder.unrestrictedTraverse('@@sharing')",
            "        sharingView.update_role_settings([{'id':groupname,",
            "                                           'type':'group',",
            "                                           'roles':['Owner']}])",
            "        # Acquisition off for folder2",
            "        self.folder.folder2.unrestrictedTraverse('@@sharing') \\",
            "            .update_inherit(False)",
            "        # Everything in subfolder should be invisible",
            "        self.login(user2)",
            "        self.assertFalse(self.catalog(SearchableText='bar'))",
            "",
            "    def testSearchIgnoreAccents(self):",
            "        \"\"\"PLIP 12110",
            "        \"\"\"",
            "        self.folder.invokeFactory('Document', id='docwithaccents-1', text='Econom\u00e9trie', title='foo')",
            "        self.folder.invokeFactory('Document', id='docwithaccents-2', text='\u00c9conom\u00e9trie')",
            "        self.folder.invokeFactory('Document', id='docwithout-accents', text='ECONOMETRIE')",
            "",
            "        self.assertEqual(len(self.catalog(SearchableText='\u00c9conom\u00e9trie')), 3)",
            "        self.assertEqual(len(self.catalog(SearchableText='Econom\u00e9trie')), 3)",
            "        self.assertEqual(len(self.catalog(SearchableText='ECONOMETRIE')), 3)",
            "",
            "    def testSearchIsProtected(self):",
            "        self.login()",
            "        self.folder.invokeFactory(\"Document\", \"sekretz\")",
            "        self.logout()",
            "        catalog = self.portal.portal_catalog",
            "        bogus = catalog.search({'portal_type': 'Document'})",
            "        real = catalog.portal_catalog.searchResults(portal_type='Document')",
            "        self.assertEqual(len(bogus), len(real))",
            "",
            "",
            "class TestCatalogSorting(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "",
            "        self.folder.invokeFactory('Document', id='doc', text='foo')",
            "        self.folder.doc.setTitle('12 Document 25')",
            "        self.folder.invokeFactory('Document', id='doc2', text='foo')",
            "        self.folder.doc2.setTitle('3 Document 4')",
            "        self.folder.invokeFactory('Document', id='doc3', text='foo')",
            "        self.folder.doc3.setTitle('12 Document 4')",
            "",
            "        self.folder.invokeFactory('Document', id='doc4', text='bar')",
            "        self.folder.doc4.setTitle('document 12')",
            "        self.folder.invokeFactory('Document', id='doc5', text='bar')",
            "        self.folder.doc5.setTitle('Document 2')",
            "        self.folder.invokeFactory('Document', id='doc6', text='bar')",
            "        self.folder.doc6.setTitle('DOCUMENT 4')",
            "        self.folder.doc.reindexObject()",
            "        self.folder.doc2.reindexObject()",
            "        self.folder.doc3.reindexObject()",
            "        self.folder.doc4.reindexObject()",
            "        self.folder.doc5.reindexObject()",
            "        self.folder.doc6.reindexObject()",
            "",
            "    def testSortTitleReturnsProperOrderForNumbers(self):",
            "        # Documents should be returned in proper numeric order",
            "        results = self.catalog(SearchableText='foo', sort_on='sortable_title')",
            "        self.assertEqual(results[0].getId, 'doc2')",
            "        self.assertEqual(results[1].getId, 'doc3')",
            "        self.assertEqual(results[2].getId, 'doc')",
            "",
            "    def testSortTitleIgnoresCase(self):",
            "        # Documents should be returned in case insensitive order",
            "        results = self.catalog(SearchableText='bar', sort_on='sortable_title')",
            "        self.assertEqual(results[0].getId, 'doc5')",
            "        self.assertEqual(results[1].getId, 'doc6')",
            "        self.assertEqual(results[2].getId, 'doc4')",
            "",
            "    def testSortableTitleOutput(self):",
            "        doc = self.folder.doc",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "",
            "        self.assertEqual(wrapped.sortable_title, '0012 document 0025')",
            "",
            "    def testSortableNonASCIITitles(self):",
            "        #test a utf-8 encoded string gets properly unicode converted",
            "        #sort must ignore accents",
            "        title = 'La Pe\\xc3\\xb1a'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title, 'la pena')",
            "",
            "    def testSortableDate(self):",
            "        title = '2012-06-01 foo document'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         '2012-0006-0001 foo document')",
            "",
            "    def testSortableLongNumberPrefix(self):",
            "        title = '1.2.3 foo document'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         '0001.0002.0003 foo document')",
            "        title = '1.2.3 foo program'",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         '0001.0002.0003 foo program')",
            "",
            "    def testSortableLongCommonPrefix(self):",
            "        title = 'some documents have too long a name and only differ at ' \\",
            "            'the very end - like 1.jpeg'",
            "        doc = self.folder.doc",
            "        doc.setTitle(title)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.sortable_title,",
            "                         'some documents have too lon... 0001.jpeg')",
            "",
            "",
            "class TestFolderCataloging(PloneTestCase.PloneTestCase):",
            "    # Tests for http://dev.plone.org/plone/ticket/2876",
            "    # folder_rename must recatalog.",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Folder', id='foo')",
            "        self.setupAuthenticator()",
            "",
            "    def testFolderTitleIsUpdatedOnFolderTitleChange(self):",
            "        # The bug in fact talks about folder_rename",
            "        title = 'Test Folder - Snooze!'",
            "        foo_path = '/'.join(self.folder.foo.getPhysicalPath())",
            "        self.setRequestMethod('POST')",
            "        self.folder.folder_rename(paths=[foo_path], new_ids=['foo'],",
            "                                  new_titles=[title])",
            "        results = self.catalog(Title='Snooze')",
            "        self.assertTrue(results)",
            "        for result in results:",
            "            self.assertEqual(result.Title, title)",
            "            self.assertEqual(result.getId, 'foo')",
            "",
            "    def testFolderTitleIsUpdatedOnFolderRename(self):",
            "        # The bug in fact talks about folder_rename",
            "        title = 'Test Folder - Snooze!'",
            "        transaction.savepoint(optimistic=True)  # make rename work",
            "        foo_path = '/'.join(self.folder.foo.getPhysicalPath())",
            "        self.setRequestMethod('POST')",
            "        self.folder.folder_rename(paths=[foo_path], new_ids=['bar'],",
            "                                  new_titles=[title])",
            "        results = self.catalog(Title='Snooze')",
            "        self.assertTrue(results)",
            "        for result in results:",
            "            self.assertEqual(result.Title, title)",
            "            self.assertEqual(result.getId, 'bar')",
            "",
            "    def testSetTitleDoesNotUpdateCatalog(self):",
            "        # setTitle() should not update the catalog",
            "        title = 'Test Folder - Snooze!'",
            "        self.assertTrue(self.catalog(getId='foo'))",
            "        self.folder.foo.setTitle(title)",
            "        #Title is a TextIndex",
            "        self.assertFalse(self.catalog(Title='Snooze'))",
            "",
            "",
            "class TestCatalogOrdering(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Document', id='doc1', text='foo')",
            "        self.folder.invokeFactory('Document', id='doc2', text='bar')",
            "        self.folder.invokeFactory('Document', id='doc3', text='bloo')",
            "        self.folder.invokeFactory('Document', id='doc4', text='blee')",
            "",
            "    def testInitialOrder(self):",
            "        self.assertEqual(self.folder.getObjectPosition('doc1'), 0)",
            "        self.assertEqual(self.folder.getObjectPosition('doc2'), 1)",
            "        self.assertEqual(self.folder.getObjectPosition('doc3'), 2)",
            "        self.assertEqual(self.folder.getObjectPosition('doc4'), 3)",
            "",
            "    def testOrderIsUpdatedOnMoveDown(self):",
            "        self.folder.folder_position('down', 'doc1')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc2', 'doc1', 'doc3', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsUpdatedOnMoveUp(self):",
            "        self.folder.folder_position('up', 'doc3')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc3', 'doc2', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsUpdatedOnMoveTop(self):",
            "        self.folder.folder_position('top', 'doc3')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc3', 'doc1', 'doc2', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsUpdatedOnMoveBottom(self):",
            "        self.folder.folder_position('bottom', 'doc3')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc2', 'doc4', 'doc3']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsFineWithObjectCreation(self):",
            "        self.folder.invokeFactory('Document', id='doc5', text='blam')",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc2', 'doc3', 'doc4', 'doc5']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsFineWithObjectDeletion(self):",
            "        self.folder.manage_delObjects(['doc3', ])",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'doc2', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderIsFineWithObjectRenaming(self):",
            "",
            "        # I don't know why this is failing. manage_renameObjects throws an",
            "        # error that blames permissions or lack of support by the obj. The",
            "        # obj is a # Plone Document, and the owner of doc2 is portal_owner.",
            "        # Harumph.",
            "",
            "        transaction.savepoint(optimistic=True)",
            "",
            "        self.folder.manage_renameObjects(['doc2'], ['buzz'])",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        expected = ['doc1', 'buzz', 'doc3', 'doc4']",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testOrderAfterALotOfChanges(self):",
            "        # ['doc1','doc2','doc3','doc4']",
            "",
            "        self.folder.folder_position('down', 'doc1')",
            "        self.folder.folder_position('down', 'doc1')",
            "        # ['doc2','doc3','doc1','doc4']",
            "",
            "        self.folder.folder_position('top', 'doc3')",
            "        # ['doc3','doc2','doc1','doc4']",
            "",
            "        self.folder.invokeFactory('Document', id='doc5', text='blam')",
            "        self.folder.invokeFactory('Document', id='doc6', text='blam')",
            "        self.folder.invokeFactory('Document', id='doc7', text='blam')",
            "        self.folder.invokeFactory('Document', id='doc8', text='blam')",
            "        # ['doc3','doc2','doc1','doc4','doc5','doc6','doc7','doc8',]",
            "",
            "        #self.folder.manage_renameObjects('Document', id='doc5', text='blam')",
            "",
            "        self.folder.manage_delObjects(['doc3', 'doc4', 'doc5', 'doc7'])",
            "        expected = ['doc2', 'doc1', 'doc6', 'doc8']",
            "",
            "        folder_docs = self.catalog(",
            "                            portal_type='Document',",
            "                            path='/'.join(self.folder.getPhysicalPath()),",
            "                            sort_on='getObjPositionInParent')",
            "        self.assertEqual([b.getId for b in folder_docs], expected)",
            "",
            "    def testAllObjectsHaveOrder(self):",
            "        #Make sure that a query with sort_on='getObjPositionInParent'",
            "        #returns the same number of results as one without, make sure",
            "        #the Members folder is in the catalog and has getObjPositionInParent",
            "        all_objs = self.catalog()",
            "        sorted_objs = self.catalog(sort_on='getObjPositionInParent')",
            "        self.assertEqual(len(all_objs), len(sorted_objs))",
            "",
            "        members = self.portal.Members",
            "        members_path = '/'.join(members.getPhysicalPath())",
            "        members_query = self.catalog(path=members_path)",
            "        members_sorted = self.catalog(",
            "                                path=members_path,",
            "                                sort_on='getObjPositionInParent')",
            "        self.assertTrue(len(members_query))",
            "        self.assertEqual(len(members_query), len(members_sorted))",
            "",
            "    def testGopipIndexer(self):",
            "        from Products.CMFPlone.CatalogTool import getObjPositionInParent",
            "        get_pos = getObjPositionInParent.callable",
            "        self.assertEqual(get_pos(self.folder.doc1), 0)",
            "        self.assertEqual(get_pos(self.folder.doc4), 3)",
            "",
            "",
            "class TestCatalogBugs(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        # Make the catalog tool paste-able",
            "        self._saved = CatalogTool.__replaceable__",
            "        CatalogTool.__replaceable__ = REPLACEABLE",
            "",
            "    def afterClear(self):",
            "        CatalogTool.__replaceable__ = self._saved",
            "",
            "    def testCanPasteCatalog(self):",
            "        # Should be able to copy/paste a portal_catalog. Triggers",
            "        # manage_afterAdd of portal_catalog thereby exposing another bug :-/",
            "        self.setRoles(['Manager'])",
            "        cb = self.portal.manage_copyObjects(['portal_catalog'])",
            "        self.folder.manage_pasteObjects(cb)",
            "        self.assertTrue(hasattr(aq_base(self.folder), 'portal_catalog'))",
            "",
            "    def testPastingCatalogPreservesTextIndexes(self):",
            "        # Pasting the catalog should not cause indexes to be removed.",
            "        self.setRoles(['Manager'])",
            "        cb = self.portal.manage_copyObjects(['portal_catalog'])",
            "        self.folder.manage_pasteObjects(cb)",
            "        self.assertTrue(hasattr(aq_base(self.folder), 'portal_catalog'))",
            "        cat = self.folder.portal_catalog",
            "        self.assertTrue('SearchableText' in cat.indexes())",
            "        # CMF added lexicons should stick around too",
            "        self.assertTrue(hasattr(aq_base(cat), 'plaintext_lexicon'))",
            "",
            "",
            "class TestCatalogUnindexing(PloneTestCase.PloneTestCase):",
            "    # Tests for http://dev.plone.org/plone/ticket/3547",
            "    # Published objects are not unindexed on delete?",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.workflow = self.portal.portal_workflow",
            "        self.folder.invokeFactory('Document', id='doc')",
            "        self.setupAuthenticator()",
            "",
            "    def testVisibleIsDefault(self):",
            "        state = self.workflow.getInfoFor(self.folder.doc, 'review_state')",
            "        self.assertEqual(state, 'visible')",
            "",
            "    def testVisibleCanBeFound(self):",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testVisibleIsUnindexed(self):",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPrivateCanBeFound(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'hide')",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testPrivateIsUnindexed(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'hide')",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPendingCanBeFound(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'submit')",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testPendingIsUnindexed(self):",
            "        self.workflow.doActionFor(self.folder.doc, 'submit')",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedCanBeFound(self):",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.assertTrue(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexed(self):",
            "        # Works here!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexedIfOwnerDeletes(self):",
            "        # Works here!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.setRoles(['Member'])",
            "        self.folder._delObject('doc')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexedByFolderDeleteScript(self):",
            "        # Works here too!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.setRoles(['Member'])",
            "        doc_path = '/'.join(self.folder.doc.getPhysicalPath())",
            "        self.app.REQUEST.set('paths', [doc_path])",
            "        # folder_delete requires a non-GET request",
            "        self.setRequestMethod('POST')",
            "        self.folder.folder_delete()",
            "        self.setRequestMethod('GET')",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "    def testPublishedIsUnindexedWhenDeletingParentFolder(self):",
            "        # Works here too!",
            "        self.setRoles(['Manager'])",
            "        self.workflow.doActionFor(self.folder.doc, 'publish')",
            "        self.setRoles(['Member'])",
            "        self.folder.aq_parent._delObject(self.folder.getId())",
            "        self.assertFalse(self.catalog(getId='doc'))",
            "",
            "",
            "class TestCatalogExpirationFiltering(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.catalog = self.portal.portal_catalog",
            "        self.folder.invokeFactory('Document', id='doc')",
            "",
            "    def nofx(self):",
            "        # Removes effective and expires to make sure we only test",
            "        # the DateRangeIndex.",
            "        self.catalog.delIndex('effective')",
            "        self.catalog.delIndex('expires')",
            "",
            "    def assertResults(self, result, expect):",
            "        # Verifies ids of catalog results against expected ids",
            "        lhs = [r.getId for r in result]",
            "        lhs.sort()",
            "        rhs = list(expect)",
            "        rhs.sort()",
            "        self.assertEqual(lhs, rhs)",
            "",
            "    def testCeilingPatch(self):",
            "        self.assertEqual(self.folder.doc.expires(), DateTime(2500, 0))",
            "",
            "    def testSearchResults(self):",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testCall(self):",
            "        res = self.catalog()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testSearchResultsExpired(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "    def testCallExpired(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog()",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "    def testSearchResultsExpiredWithExpiredDisabled(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog.searchResults(dict(show_inactive=True))",
            "        self.assertResults(res, base_content)",
            "",
            "    def testCallExpiredWithExpiredDisabled(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        res = self.catalog(show_inactive=True)",
            "        self.assertResults(res, base_content)",
            "",
            "    def testSearchResultsExpiredWithPermission(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        self.setPermissions([AccessInactivePortalContent])",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testCallExpiredWithPermission(self):",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        self.nofx()",
            "        self.setPermissions([AccessInactivePortalContent])",
            "        res = self.catalog()",
            "        self.assertResults(res, base_content)",
            "",
            "    def testSearchResultsWithAdditionalExpiryFilter(self):",
            "        # For this test we want the expires and effective indices in place,",
            "        # let's make sure everything still works",
            "        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))",
            "        self.folder.doc.reindexObject()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content[:-1])",
            "        # Now make the object expire at some fixed date in the future",
            "        self.folder.doc.setExpirationDate(DateTime() + 2)",
            "        self.folder.doc.reindexObject()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content)",
            "        # We should be able to further limit the search using the exipres",
            "        # and efective indices.",
            "        res = self.catalog.searchResults(dict(expires={",
            "                                            'query': DateTime() + 3,",
            "                                            'range': 'min'}))",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "    def testSearchResultsExpiredWithAdditionalExpiryFilter(self):",
            "        # Now make the object expire at some date in the recent past",
            "        self.folder.doc.setExpirationDate(DateTime() - 2)",
            "        self.folder.doc.reindexObject()",
            "        res = self.catalog.searchResults()",
            "        self.assertResults(res, base_content[:-1])",
            "        # Even if we explicitly ask for it, we shouldn't get expired content",
            "        res = self.catalog.searchResults(dict(expires={",
            "                                            'query': DateTime() - 3,",
            "                                            'range': 'min'}))",
            "        self.assertResults(res, base_content[:-1])",
            "",
            "",
            "def dummyMethod(obj, **kwargs):",
            "    return 'a dummy'",
            "",
            "",
            "class TestIndexers(PloneTestCase.PloneTestCase):",
            "    \"\"\"Tests for IIndexer adapters",
            "    \"\"\"",
            "",
            "    def afterSetUp(self):",
            "        self.folder.invokeFactory('Document', 'doc', title='document')",
            "        self.doc = self.folder.doc",
            "",
            "    def testSetup(self):",
            "        doc = self.doc",
            "        self.assertEqual(doc.getId(), 'doc')",
            "        self.assertEqual(doc.Title(), 'document')",
            "",
            "    def test_is_folderishWithNonFolder(self):",
            "        i = dummy.Item()",
            "        self.assertFalse(is_folderish(i)())",
            "",
            "    def test_is_folderishWithFolder(self):",
            "        f = dummy.Folder('struct_folder')",
            "        self.assertTrue(is_folderish(f)())",
            "",
            "    def test_is_folderishWithNonStructuralFolder(self):",
            "        f = dummy.NonStructuralFolder('ns_folder')",
            "        self.assertFalse(is_folderish(f)())",
            "",
            "    def test_provided(self):",
            "        from Products.CMFCore.interfaces import IContentish",
            "        from plone.indexer.interfaces import IIndexableObjectWrapper",
            "        from Products.CMFCore.tests.base.dummy import DummyContent",
            "",
            "        obj = DummyContent()",
            "        w = IndexableObjectWrapper(obj, self.portal.portal_catalog)",
            "",
            "        self.assertTrue(IIndexableObjectWrapper.providedBy(w))",
            "        self.assertTrue(IContentish.providedBy(w))",
            "",
            "    def test_getIcon(self):",
            "        doc = self.doc",
            "        iconname = doc.getIcon(relative_to_portal=1)",
            "        wrapped = IndexableObjectWrapper(doc, self.portal.portal_catalog)",
            "        self.assertEqual(wrapped.getIcon, iconname)",
            "",
            "    def test_getObjSize(self):",
            "        from Products.CMFPlone.CatalogTool import getObjSize",
            "        get_size = getObjSize.callable",
            "        self.doc.setText(u'a' * 1000)",
            "        self.doc.reindexObject()",
            "        self.assertEqual(get_size(self.doc), '1 KB')",
            "",
            "    def test_uuid(self):",
            "        alsoProvides(self.doc, IAttributeUUID)",
            "        notify(ObjectCreatedEvent(self.doc))",
            "",
            "        uuid = IUUID(self.doc, None)",
            "        wrapped = IndexableObjectWrapper(self.doc, self.portal.portal_catalog)",
            "        self.assertTrue(wrapped.UID)",
            "        self.assertTrue(uuid == wrapped.UID)",
            "",
            "",
            "class TestMetadata(PloneTestCase.PloneTestCase):",
            "    \"\"\"",
            "    \"\"\"",
            "",
            "    def testLocationAddedToMetdata(self):",
            "        self.folder.invokeFactory('Document', 'doc', title='document', location=\"foobar\")",
            "        doc = self.folder.doc",
            "        catalog = self.portal.portal_catalog",
            "        brain = catalog(UID=doc.UID())[0]",
            "        self.assertEquals(brain.location, doc.getLocation())",
            "",
            "",
            "class TestObjectProvidedIndexExtender(unittest.TestCase):",
            "",
            "    def _index(self, object):",
            "        from Products.CMFPlone.CatalogTool import object_provides",
            "        return object_provides(object)()",
            "",
            "    def testNoInterfaces(self):",
            "        class Dummy(object):",
            "            pass",
            "        self.assertEqual(self._index(Dummy()), ())",
            "",
            "    def testSimpleInterface(self):",
            "        class IDummy(zope.interface.Interface):",
            "            pass",
            "",
            "        class Dummy(object):",
            "            zope.interface.implements(IDummy)",
            "        self.assertEqual(self._index(Dummy()),",
            "            ('Products.CMFPlone.tests.testCatalogTool.IDummy', ))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "483": [],
            "484": [],
            "486": []
        },
        "addLocation": []
    },
    "Products/CMFPlone/tests/testPortalFactory.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import urlparse"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import os"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from Products.CMFPlone.tests import PloneTestCase"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from Products.CMFCore.permissions import AddPortalContent"
            },
            "5": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "         path = \"%s/++resource++plone-logo.png\" % self.tmp_obj_path"
            },
            "6": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         data = self.publish(path)"
            },
            "7": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "         self.assertEqual(data.getHeader('Content-Type'), 'image/png')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+    def testFactoryToolDocsFileNotPublishable(self):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        import Products.CMFPlone"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+        res = self.publish('/plone/portal_factory/f')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        plone_code = os.path.dirname(Products.CMFPlone.__file__)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        self.assertNotIn(plone_code, res.getBody())"
            }
        },
        "frontPatchFile": [
            "import urlparse",
            "from Products.CMFPlone.tests import PloneTestCase",
            "",
            "from Products.CMFCore.permissions import AddPortalContent",
            "from Products.CMFCore.permissions import ModifyPortalContent",
            "from Products.PluggableAuthService.interfaces.plugins import IChallengePlugin",
            "",
            "from AccessControl import Permissions",
            "from AccessControl import getSecurityManager",
            "default_user = PloneTestCase.default_user",
            "default_password = PloneTestCase.default_password",
            "",
            "",
            "def sortTuple(t):",
            "    l = list(t)",
            "    l.sort()",
            "    return tuple(l)",
            "",
            "ADD_DOC_PERM = 'ATContentTypes: Add Document'",
            "",
            "",
            "class TestPortalFactory(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.membership = self.portal.portal_membership",
            "        self.membership.addMember('member', 'secret', ['Member'], [])",
            "        self.membership.addMember('manager', 'secret', ['Manager'], [])",
            "",
            "    def testTraverse(self):",
            "        temp_doc = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(temp_doc.portal_type, 'Document')",
            "        self.assertEqual(temp_doc.getId(), 'tmp_id')",
            "",
            "    def testTraverseEditView(self):",
            "        edit_view = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id/edit')",
            "        self.assertEquals('tmp_id', edit_view.im_self.getId())",
            "        self.assertEquals('Document', edit_view.im_self.portal_type)",
            "",
            "    def testTraverseTwiceByDifferentContentTypes(self):",
            "        temp_doc = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(temp_doc.portal_type, 'Document')",
            "        self.assertEqual(temp_doc.getId(), 'tmp_id')",
            "        temp_img = self.folder.restrictedTraverse(",
            "                        'portal_factory/Image/tmp_id_image')",
            "        self.assertEqual(temp_img.portal_type, 'Image')",
            "        self.assertEqual(temp_img.getId(), 'tmp_id_image')",
            "",
            "    def testTempFolderLocalRoles(self):",
            "        # Temporary objects should \"inherit\" local roles from container",
            "        member = self.membership.getMemberById('member')",
            "        self.portal.acl_users.addRole('Foo')",
            "",
            "        self.folder.manage_addLocalRoles('member', ('Foo',))",
            "        self.folder.invokeFactory('Folder', id='folder2')",
            "        self.folder.folder2.manage_addLocalRoles('member', ('Reviewer',))",
            "",
            "        self.assertEqual(sortTuple(member.getRolesInContext(self.folder)),",
            "                         ('Authenticated', 'Foo', 'Member'))",
            "",
            "        temp_object = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object)),",
            "                         ('Authenticated', 'Foo', 'Member'))",
            "",
            "        temp_object2 = self.folder.folder2.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object2)),",
            "                         ('Authenticated', 'Foo', 'Member', 'Reviewer'))",
            "",
            "    def testTempFolderLocalRolesWithBlocking(self):",
            "        # Temporary objects should \"inherit\" local roles from container,",
            "        # but also need to respect PLIP 16 local role blocking",
            "        member = self.membership.getMemberById('member')",
            "        self.portal.acl_users.addRole('Foo')",
            "",
            "        self.folder.manage_addLocalRoles('member', ('Foo',))",
            "        self.folder.invokeFactory('Folder', id='folder2')",
            "        self.folder.folder2.manage_addLocalRoles('member', ('Reviewer',))",
            "        # make folder2 not inherit local roles",
            "        self.portal.plone_utils.acquireLocalRoles(self.folder.folder2,",
            "                                                  status=0)",
            "",
            "        self.assertEqual(",
            "                sortTuple(member.getRolesInContext(self.folder.folder2)),",
            "                ('Authenticated', 'Member', 'Reviewer'))",
            "",
            "        temp_object2 = self.folder.folder2.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object2)),",
            "                         ('Authenticated', 'Member', 'Reviewer'))",
            "",
            "    def testTempObjectLocalRolesBug(self):",
            "        # Evil monkey patch should not change all objects of a class",
            "        self.createMemberarea('member')",
            "        member = self.membership.getMemberById('member')",
            "",
            "        # Make an unrelated non-temporary object for comparison",
            "        self.login('manager')",
            "        self.portal.invokeFactory('Document', id='nontmp_id')",
            "        nontemp_object = getattr(self.portal, 'nontmp_id')",
            "",
            "        # Assume identify of the ordinary member",
            "        self.login('member')",
            "        folder = self.membership.getHomeFolder()",
            "        temp_object = \\",
            "                folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "",
            "        # Make sure member is owner of temporary object",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object)),",
            "                         ('Authenticated', 'Member', 'Owner'))",
            "        self.assertEqual(temp_object.Creator(), 'member')",
            "",
            "        # Make sure member is not owner of non-temporary object",
            "        # (i.e. make sure our evil monkey patch of the temporary instance has",
            "        # not resulted in our patching all instances of the class)",
            "        self.assertEqual(sortTuple(member.getRolesInContext(nontemp_object)),",
            "                         ('Authenticated', 'Member'))",
            "",
            "    def testTempFolderPermissions(self):",
            "        # TempFolder should \"inherit\" permission mappings from container",
            "        previous_roles = \\",
            "                [r for r in self.folder.rolesOfPermission(AddPortalContent)",
            "                    if r['name'] == 'Anonymous']",
            "        self.folder.manage_permission(AddPortalContent, ['Anonymous'], 1)",
            "        new_roles = [r for r in self.folder.rolesOfPermission(AddPortalContent)",
            "                        if r['name'] == 'Anonymous']",
            "        self.assertNotEqual(previous_roles, new_roles)",
            "",
            "        temp_folder = self.folder.restrictedTraverse(",
            "                                'portal_factory/Document/tmp_id').aq_parent",
            "        temp_roles = \\",
            "                [r for r in temp_folder.rolesOfPermission(AddPortalContent)",
            "                    if r['name'] == 'Anonymous']",
            "",
            "        self.assertEqual(temp_roles, new_roles)",
            "",
            "",
            "class TestCreateObject(PloneTestCase.PloneTestCase):",
            "",
            "    def testCreateObjectByDoCreate(self):",
            "        # doCreate should create the real object",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        foo = temp_object.portal_factory.doCreate(temp_object, 'foo')",
            "        self.assertTrue('foo' in self.folder)",
            "        self.assertEqual(foo.get_local_roles_for_userid(default_user),",
            "                         ('Owner',))",
            "",
            "    def testUnauthorizedToCreateObjectByDoCreate(self):",
            "        # Anonymous should not be able to create the (real) object",
            "        # Note that Anonymous used to be able to create the temp object...",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        self.logout()",
            "        self.assertRaises(ValueError, temp_object.portal_factory.doCreate,",
            "                          temp_object, 'foo')",
            "",
            "    def testCreateObjectByDocumentEdit(self):",
            "        # document_edit should create the real object",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        temp_object.document_edit(id='foo', title='Foo', text_format='plain',",
            "                                  text='')",
            "        self.assertTrue('foo' in self.folder)",
            "        self.assertEqual(self.folder.foo.Title(), 'Foo')",
            "        self.assertEqual(",
            "                self.folder.foo.get_local_roles_for_userid(default_user),",
            "                ('Owner',))",
            "",
            "    def testUnauthorizedToCreateObjectByDocumentEdit(self):",
            "        # Anonymous should not be able to create the (real) object",
            "        # Note that Anonymous used to be able to create the temp object...",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        self.logout()",
            "        self.assertRaises(ValueError, temp_object.document_edit,",
            "                          id='foo', title='Foo', text_format='plain', text='')",
            "",
            "    def testCopyPermission(self):",
            "        self.setRoles(['Manager'])",
            "        self.portal.invokeFactory('Folder', id='folder_to_copy')",
            "",
            "        pm = self.portal.portal_membership",
            "        pm.addMember('editor', 'secret', ['Editor'], [])",
            "        self.login('editor')",
            "        member = pm.getMemberById('editor')",
            "        self.assertTrue(member.checkPermission(Permissions.copy_or_move,",
            "                                               self.portal))",
            "        security = getSecurityManager()",
            "        self.assertTrue(security.validate(",
            "            self.portal, self.portal, 'manage_copyObjects'))",
            "",
            "    def testRenamePermission(self):",
            "        self.setRoles(['Manager'])",
            "        self.portal.invokeFactory('Folder', id='folder_to_copy')",
            "",
            "        pm = self.portal.portal_membership",
            "        pm.addMember('editor', 'secret', ['Editor'], [])",
            "        self.login('editor')",
            "        member = pm.getMemberById('editor')",
            "        self.assertTrue(member.checkPermission(ModifyPortalContent,",
            "                                               self.portal))",
            "        security = getSecurityManager()",
            "        self.assertTrue(security.validate(",
            "            self.portal, self.portal, 'manage_renameObjects'))",
            "",
            "",
            "class TestCreateObjectByURL(PloneTestCase.FunctionalTestCase):",
            "    '''Weeee, functional tests'''",
            "",
            "    def afterSetUp(self):",
            "        self.folder_url = self.folder.absolute_url()",
            "        self.folder_path = '/%s' % self.folder.absolute_url(1)",
            "        self.basic_auth = '%s:%s' % (default_user, default_password)",
            "        # We want 401 responses, not redirects to a login page",
            "        plugins = self.portal.acl_users.plugins",
            "        plugins.deactivatePlugin(IChallengePlugin, 'credentials_cookie_auth')",
            "",
            "        # Enable portal_factory for Document type",
            "        self.factory = self.portal.portal_factory",
            "        self.factory.manage_setPortalFactoryTypes(listOfTypeIds=['Document'])",
            "",
            "    def testCreateObject(self):",
            "        # createObject script should make a temp object",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                self.basic_auth)",
            "",
            "        # Redirect to document_edit_form",
            "        self.assertEqual(response.getStatus(), 302)",
            "",
            "        # The redirect URL should contain the factory parts",
            "        location = response.getHeader('Location')",
            "        self.assertTrue(location.startswith(",
            "                                self.folder_url + '/portal_factory/Document/'))",
            "        # CMFFormController redirects should not do alias translation",
            "        self.assertTrue(location.endswith('/edit'))",
            "",
            "        # Perform the redirect",
            "        edit_form_path = location[len(self.app.REQUEST.SERVER_URL):]",
            "        response = self.publish(edit_form_path, self.basic_auth)",
            "        self.assertEqual(response.getStatus(), 200)  # OK",
            "",
            "    def testCreateNonGloballyAllowedObject(self):",
            "        # TempFolder allows to create all portal types",
            "        self.portal.portal_types.Document.manage_changeProperties(",
            "                                                        global_allow=0)",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                self.basic_auth)",
            "",
            "        # Redirect to document_edit_form",
            "        self.assertEqual(response.getStatus(), 302)",
            "",
            "        # The redirect URL should contain the factory parts",
            "        location = response.getHeader('Location')",
            "        self.assertTrue(location.startswith(",
            "                                self.folder_url + '/portal_factory/Document/'))",
            "        self.assertTrue(location.endswith('/edit'))",
            "",
            "        # Perform the redirect",
            "        edit_form_path = location[len(self.app.REQUEST.SERVER_URL):]",
            "        response = self.publish(edit_form_path, self.basic_auth)",
            "        self.assertEqual(response.getStatus(), 200)  # OK",
            "",
            "    def testUnauthorizedToViewEditForm(self):",
            "        # Anonymous should not be able to see document_edit_form",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                )  # No basic out info",
            "        # We got redirected to the factory",
            "        self.assertEqual(response.getStatus(), 302)",
            "        newpath = response.getHeader('location')",
            "        proto, host, path, query, fragment = urlparse.urlsplit(newpath)",
            "        # Let's follow it",
            "        response = self.publish(path)",
            "        # And we are forbidden",
            "        self.assertEqual(response.getStatus(), 401)  # Unauthorized",
            "",
            "    def testUnauthorizedToViewEditFormOfNonFactoryObject(self):",
            "        # Anonymous should not be able to see newsitem_edit_form",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=News%20Item',",
            "                                )  # No basic out info",
            "",
            "        self.assertEqual(response.getStatus(), 401)  # Unauthorized",
            "",
            "    def testCreateObjectByDocumentEdit(self):",
            "        # document_edit should create the real object",
            "        response = self.publish(self.folder_path +",
            "            '/portal_factory/Document/tmp_id/document_edit?id=foo&title=Foo&text_format=plain&text=',",
            "            self.basic_auth)",
            "",
            "        # Redirect to document_view",
            "        self.assertEqual(response.getStatus(), 302)",
            "        viewAction = self.portal.portal_types['Document'].getActionInfo(",
            "                                'object/view',",
            "                                self.folder.foo)['url']",
            "        self.assertTrue(response.getHeader('Location').startswith(viewAction))",
            "",
            "        self.assertTrue('foo' in self.folder)",
            "        self.assertEqual(self.folder.foo.Title(), 'Foo')",
            "        self.assertEqual(",
            "                self.folder.foo.get_local_roles_for_userid(default_user),",
            "                ('Owner',))",
            "",
            "    def testUnauthorizedToCreateObjectByDocumentEdit(self):",
            "        # Anonymous should not be able to create the real object",
            "        response = self.publish(self.folder_path +",
            "            '/portal_factory/Document/tmp_id/document_edit?id=foo&title=Foo&text_format=plain&text=',",
            "            )  # No basic auth info",
            "",
            "        self.assertEqual(response.getStatus(), 500)  # ValueError",
            "",
            "",
            "class TestPortalFactoryTraverseByURL(PloneTestCase.FunctionalTestCase):",
            "    '''Weeee, functional tests'''",
            "",
            "    def afterSetUp(self):",
            "        self.folder_url = self.folder.absolute_url()",
            "        self.folder_path = '/%s' % self.folder.absolute_url(1)",
            "        self.basic_auth = '%s:%s' % (default_user, default_password)",
            "        # We want 401 responses, not redirects to a login page",
            "        plugins = self.portal.acl_users.plugins",
            "        plugins.deactivatePlugin(IChallengePlugin, 'credentials_cookie_auth')",
            "",
            "        # Enable portal_factory for Document type",
            "        self.factory = self.portal.portal_factory",
            "        self.factory.manage_setPortalFactoryTypes(listOfTypeIds=['Document'])",
            "",
            "        # setup a temp object",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                self.basic_auth",
            "                                )",
            "        # We got redirected to the factory",
            "        self.assertEqual(response.getStatus(), 302)",
            "        newpath = response.getHeader('location')",
            "        proto, host, path, query, fragment = urlparse.urlsplit(newpath)",
            "",
            "        self.tmp_obj_path = path.replace('/edit', '')",
            "",
            "    def testFSImage(self):",
            "        path = \"%s/logo.jpg\" % self.tmp_obj_path",
            "        data = self.publish(path)",
            "        self.assertEqual(data.getHeader('Content-Type'), 'image/jpeg')",
            "",
            "    def testBrowserResource(self):",
            "        path = \"%s/++resource++plone-logo.png\" % self.tmp_obj_path",
            "        data = self.publish(path)",
            "        self.assertEqual(data.getHeader('Content-Type'), 'image/png')"
        ],
        "afterPatchFile": [
            "import urlparse",
            "import os",
            "from Products.CMFPlone.tests import PloneTestCase",
            "",
            "from Products.CMFCore.permissions import AddPortalContent",
            "from Products.CMFCore.permissions import ModifyPortalContent",
            "from Products.PluggableAuthService.interfaces.plugins import IChallengePlugin",
            "",
            "from AccessControl import Permissions",
            "from AccessControl import getSecurityManager",
            "default_user = PloneTestCase.default_user",
            "default_password = PloneTestCase.default_password",
            "",
            "",
            "def sortTuple(t):",
            "    l = list(t)",
            "    l.sort()",
            "    return tuple(l)",
            "",
            "ADD_DOC_PERM = 'ATContentTypes: Add Document'",
            "",
            "",
            "class TestPortalFactory(PloneTestCase.PloneTestCase):",
            "",
            "    def afterSetUp(self):",
            "        self.membership = self.portal.portal_membership",
            "        self.membership.addMember('member', 'secret', ['Member'], [])",
            "        self.membership.addMember('manager', 'secret', ['Manager'], [])",
            "",
            "    def testTraverse(self):",
            "        temp_doc = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(temp_doc.portal_type, 'Document')",
            "        self.assertEqual(temp_doc.getId(), 'tmp_id')",
            "",
            "    def testTraverseEditView(self):",
            "        edit_view = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id/edit')",
            "        self.assertEquals('tmp_id', edit_view.im_self.getId())",
            "        self.assertEquals('Document', edit_view.im_self.portal_type)",
            "",
            "    def testTraverseTwiceByDifferentContentTypes(self):",
            "        temp_doc = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(temp_doc.portal_type, 'Document')",
            "        self.assertEqual(temp_doc.getId(), 'tmp_id')",
            "        temp_img = self.folder.restrictedTraverse(",
            "                        'portal_factory/Image/tmp_id_image')",
            "        self.assertEqual(temp_img.portal_type, 'Image')",
            "        self.assertEqual(temp_img.getId(), 'tmp_id_image')",
            "",
            "    def testTempFolderLocalRoles(self):",
            "        # Temporary objects should \"inherit\" local roles from container",
            "        member = self.membership.getMemberById('member')",
            "        self.portal.acl_users.addRole('Foo')",
            "",
            "        self.folder.manage_addLocalRoles('member', ('Foo',))",
            "        self.folder.invokeFactory('Folder', id='folder2')",
            "        self.folder.folder2.manage_addLocalRoles('member', ('Reviewer',))",
            "",
            "        self.assertEqual(sortTuple(member.getRolesInContext(self.folder)),",
            "                         ('Authenticated', 'Foo', 'Member'))",
            "",
            "        temp_object = self.folder.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object)),",
            "                         ('Authenticated', 'Foo', 'Member'))",
            "",
            "        temp_object2 = self.folder.folder2.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object2)),",
            "                         ('Authenticated', 'Foo', 'Member', 'Reviewer'))",
            "",
            "    def testTempFolderLocalRolesWithBlocking(self):",
            "        # Temporary objects should \"inherit\" local roles from container,",
            "        # but also need to respect PLIP 16 local role blocking",
            "        member = self.membership.getMemberById('member')",
            "        self.portal.acl_users.addRole('Foo')",
            "",
            "        self.folder.manage_addLocalRoles('member', ('Foo',))",
            "        self.folder.invokeFactory('Folder', id='folder2')",
            "        self.folder.folder2.manage_addLocalRoles('member', ('Reviewer',))",
            "        # make folder2 not inherit local roles",
            "        self.portal.plone_utils.acquireLocalRoles(self.folder.folder2,",
            "                                                  status=0)",
            "",
            "        self.assertEqual(",
            "                sortTuple(member.getRolesInContext(self.folder.folder2)),",
            "                ('Authenticated', 'Member', 'Reviewer'))",
            "",
            "        temp_object2 = self.folder.folder2.restrictedTraverse(",
            "                        'portal_factory/Document/tmp_id')",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object2)),",
            "                         ('Authenticated', 'Member', 'Reviewer'))",
            "",
            "    def testTempObjectLocalRolesBug(self):",
            "        # Evil monkey patch should not change all objects of a class",
            "        self.createMemberarea('member')",
            "        member = self.membership.getMemberById('member')",
            "",
            "        # Make an unrelated non-temporary object for comparison",
            "        self.login('manager')",
            "        self.portal.invokeFactory('Document', id='nontmp_id')",
            "        nontemp_object = getattr(self.portal, 'nontmp_id')",
            "",
            "        # Assume identify of the ordinary member",
            "        self.login('member')",
            "        folder = self.membership.getHomeFolder()",
            "        temp_object = \\",
            "                folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "",
            "        # Make sure member is owner of temporary object",
            "        self.assertEqual(sortTuple(member.getRolesInContext(temp_object)),",
            "                         ('Authenticated', 'Member', 'Owner'))",
            "        self.assertEqual(temp_object.Creator(), 'member')",
            "",
            "        # Make sure member is not owner of non-temporary object",
            "        # (i.e. make sure our evil monkey patch of the temporary instance has",
            "        # not resulted in our patching all instances of the class)",
            "        self.assertEqual(sortTuple(member.getRolesInContext(nontemp_object)),",
            "                         ('Authenticated', 'Member'))",
            "",
            "    def testTempFolderPermissions(self):",
            "        # TempFolder should \"inherit\" permission mappings from container",
            "        previous_roles = \\",
            "                [r for r in self.folder.rolesOfPermission(AddPortalContent)",
            "                    if r['name'] == 'Anonymous']",
            "        self.folder.manage_permission(AddPortalContent, ['Anonymous'], 1)",
            "        new_roles = [r for r in self.folder.rolesOfPermission(AddPortalContent)",
            "                        if r['name'] == 'Anonymous']",
            "        self.assertNotEqual(previous_roles, new_roles)",
            "",
            "        temp_folder = self.folder.restrictedTraverse(",
            "                                'portal_factory/Document/tmp_id').aq_parent",
            "        temp_roles = \\",
            "                [r for r in temp_folder.rolesOfPermission(AddPortalContent)",
            "                    if r['name'] == 'Anonymous']",
            "",
            "        self.assertEqual(temp_roles, new_roles)",
            "",
            "",
            "class TestCreateObject(PloneTestCase.PloneTestCase):",
            "",
            "    def testCreateObjectByDoCreate(self):",
            "        # doCreate should create the real object",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        foo = temp_object.portal_factory.doCreate(temp_object, 'foo')",
            "        self.assertTrue('foo' in self.folder)",
            "        self.assertEqual(foo.get_local_roles_for_userid(default_user),",
            "                         ('Owner',))",
            "",
            "    def testUnauthorizedToCreateObjectByDoCreate(self):",
            "        # Anonymous should not be able to create the (real) object",
            "        # Note that Anonymous used to be able to create the temp object...",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        self.logout()",
            "        self.assertRaises(ValueError, temp_object.portal_factory.doCreate,",
            "                          temp_object, 'foo')",
            "",
            "    def testCreateObjectByDocumentEdit(self):",
            "        # document_edit should create the real object",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        temp_object.document_edit(id='foo', title='Foo', text_format='plain',",
            "                                  text='')",
            "        self.assertTrue('foo' in self.folder)",
            "        self.assertEqual(self.folder.foo.Title(), 'Foo')",
            "        self.assertEqual(",
            "                self.folder.foo.get_local_roles_for_userid(default_user),",
            "                ('Owner',))",
            "",
            "    def testUnauthorizedToCreateObjectByDocumentEdit(self):",
            "        # Anonymous should not be able to create the (real) object",
            "        # Note that Anonymous used to be able to create the temp object...",
            "        temp_object = \\",
            "            self.folder.restrictedTraverse('portal_factory/Document/tmp_id')",
            "        self.logout()",
            "        self.assertRaises(ValueError, temp_object.document_edit,",
            "                          id='foo', title='Foo', text_format='plain', text='')",
            "",
            "    def testCopyPermission(self):",
            "        self.setRoles(['Manager'])",
            "        self.portal.invokeFactory('Folder', id='folder_to_copy')",
            "",
            "        pm = self.portal.portal_membership",
            "        pm.addMember('editor', 'secret', ['Editor'], [])",
            "        self.login('editor')",
            "        member = pm.getMemberById('editor')",
            "        self.assertTrue(member.checkPermission(Permissions.copy_or_move,",
            "                                               self.portal))",
            "        security = getSecurityManager()",
            "        self.assertTrue(security.validate(",
            "            self.portal, self.portal, 'manage_copyObjects'))",
            "",
            "    def testRenamePermission(self):",
            "        self.setRoles(['Manager'])",
            "        self.portal.invokeFactory('Folder', id='folder_to_copy')",
            "",
            "        pm = self.portal.portal_membership",
            "        pm.addMember('editor', 'secret', ['Editor'], [])",
            "        self.login('editor')",
            "        member = pm.getMemberById('editor')",
            "        self.assertTrue(member.checkPermission(ModifyPortalContent,",
            "                                               self.portal))",
            "        security = getSecurityManager()",
            "        self.assertTrue(security.validate(",
            "            self.portal, self.portal, 'manage_renameObjects'))",
            "",
            "",
            "class TestCreateObjectByURL(PloneTestCase.FunctionalTestCase):",
            "    '''Weeee, functional tests'''",
            "",
            "    def afterSetUp(self):",
            "        self.folder_url = self.folder.absolute_url()",
            "        self.folder_path = '/%s' % self.folder.absolute_url(1)",
            "        self.basic_auth = '%s:%s' % (default_user, default_password)",
            "        # We want 401 responses, not redirects to a login page",
            "        plugins = self.portal.acl_users.plugins",
            "        plugins.deactivatePlugin(IChallengePlugin, 'credentials_cookie_auth')",
            "",
            "        # Enable portal_factory for Document type",
            "        self.factory = self.portal.portal_factory",
            "        self.factory.manage_setPortalFactoryTypes(listOfTypeIds=['Document'])",
            "",
            "    def testCreateObject(self):",
            "        # createObject script should make a temp object",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                self.basic_auth)",
            "",
            "        # Redirect to document_edit_form",
            "        self.assertEqual(response.getStatus(), 302)",
            "",
            "        # The redirect URL should contain the factory parts",
            "        location = response.getHeader('Location')",
            "        self.assertTrue(location.startswith(",
            "                                self.folder_url + '/portal_factory/Document/'))",
            "        # CMFFormController redirects should not do alias translation",
            "        self.assertTrue(location.endswith('/edit'))",
            "",
            "        # Perform the redirect",
            "        edit_form_path = location[len(self.app.REQUEST.SERVER_URL):]",
            "        response = self.publish(edit_form_path, self.basic_auth)",
            "        self.assertEqual(response.getStatus(), 200)  # OK",
            "",
            "    def testCreateNonGloballyAllowedObject(self):",
            "        # TempFolder allows to create all portal types",
            "        self.portal.portal_types.Document.manage_changeProperties(",
            "                                                        global_allow=0)",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                self.basic_auth)",
            "",
            "        # Redirect to document_edit_form",
            "        self.assertEqual(response.getStatus(), 302)",
            "",
            "        # The redirect URL should contain the factory parts",
            "        location = response.getHeader('Location')",
            "        self.assertTrue(location.startswith(",
            "                                self.folder_url + '/portal_factory/Document/'))",
            "        self.assertTrue(location.endswith('/edit'))",
            "",
            "        # Perform the redirect",
            "        edit_form_path = location[len(self.app.REQUEST.SERVER_URL):]",
            "        response = self.publish(edit_form_path, self.basic_auth)",
            "        self.assertEqual(response.getStatus(), 200)  # OK",
            "",
            "    def testUnauthorizedToViewEditForm(self):",
            "        # Anonymous should not be able to see document_edit_form",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                )  # No basic out info",
            "        # We got redirected to the factory",
            "        self.assertEqual(response.getStatus(), 302)",
            "        newpath = response.getHeader('location')",
            "        proto, host, path, query, fragment = urlparse.urlsplit(newpath)",
            "        # Let's follow it",
            "        response = self.publish(path)",
            "        # And we are forbidden",
            "        self.assertEqual(response.getStatus(), 401)  # Unauthorized",
            "",
            "    def testUnauthorizedToViewEditFormOfNonFactoryObject(self):",
            "        # Anonymous should not be able to see newsitem_edit_form",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=News%20Item',",
            "                                )  # No basic out info",
            "",
            "        self.assertEqual(response.getStatus(), 401)  # Unauthorized",
            "",
            "    def testCreateObjectByDocumentEdit(self):",
            "        # document_edit should create the real object",
            "        response = self.publish(self.folder_path +",
            "            '/portal_factory/Document/tmp_id/document_edit?id=foo&title=Foo&text_format=plain&text=',",
            "            self.basic_auth)",
            "",
            "        # Redirect to document_view",
            "        self.assertEqual(response.getStatus(), 302)",
            "        viewAction = self.portal.portal_types['Document'].getActionInfo(",
            "                                'object/view',",
            "                                self.folder.foo)['url']",
            "        self.assertTrue(response.getHeader('Location').startswith(viewAction))",
            "",
            "        self.assertTrue('foo' in self.folder)",
            "        self.assertEqual(self.folder.foo.Title(), 'Foo')",
            "        self.assertEqual(",
            "                self.folder.foo.get_local_roles_for_userid(default_user),",
            "                ('Owner',))",
            "",
            "    def testUnauthorizedToCreateObjectByDocumentEdit(self):",
            "        # Anonymous should not be able to create the real object",
            "        response = self.publish(self.folder_path +",
            "            '/portal_factory/Document/tmp_id/document_edit?id=foo&title=Foo&text_format=plain&text=',",
            "            )  # No basic auth info",
            "",
            "        self.assertEqual(response.getStatus(), 500)  # ValueError",
            "",
            "",
            "class TestPortalFactoryTraverseByURL(PloneTestCase.FunctionalTestCase):",
            "    '''Weeee, functional tests'''",
            "",
            "    def afterSetUp(self):",
            "        self.folder_url = self.folder.absolute_url()",
            "        self.folder_path = '/%s' % self.folder.absolute_url(1)",
            "        self.basic_auth = '%s:%s' % (default_user, default_password)",
            "        # We want 401 responses, not redirects to a login page",
            "        plugins = self.portal.acl_users.plugins",
            "        plugins.deactivatePlugin(IChallengePlugin, 'credentials_cookie_auth')",
            "",
            "        # Enable portal_factory for Document type",
            "        self.factory = self.portal.portal_factory",
            "        self.factory.manage_setPortalFactoryTypes(listOfTypeIds=['Document'])",
            "",
            "        # setup a temp object",
            "        response = self.publish(self.folder_path +",
            "                                '/createObject?type_name=Document',",
            "                                self.basic_auth",
            "                                )",
            "        # We got redirected to the factory",
            "        self.assertEqual(response.getStatus(), 302)",
            "        newpath = response.getHeader('location')",
            "        proto, host, path, query, fragment = urlparse.urlsplit(newpath)",
            "",
            "        self.tmp_obj_path = path.replace('/edit', '')",
            "",
            "    def testFSImage(self):",
            "        path = \"%s/logo.jpg\" % self.tmp_obj_path",
            "        data = self.publish(path)",
            "        self.assertEqual(data.getHeader('Content-Type'), 'image/jpeg')",
            "",
            "    def testBrowserResource(self):",
            "        path = \"%s/++resource++plone-logo.png\" % self.tmp_obj_path",
            "        data = self.publish(path)",
            "        self.assertEqual(data.getHeader('Content-Type'), 'image/png')",
            "",
            "    def testFactoryToolDocsFileNotPublishable(self):",
            "        import Products.CMFPlone",
            "        res = self.publish('/plone/portal_factory/f')",
            "        plone_code = os.path.dirname(Products.CMFPlone.__file__)",
            "",
            "        self.assertNotIn(plone_code, res.getBody())"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "Products.CMFPlone.tests.testPortalFactory.TestPortalFactoryTraverseByURL.self",
            "trytond.res.user"
        ]
    }
}