{
    "synapse/api/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " # the maximum length for a user id is 255 characters"
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " MAX_USERID_LENGTH = 255"
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+# The maximum length for a group id is 255 characters"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+MAX_GROUPID_LENGTH = 255"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+MAX_GROUP_CATEGORYID_LENGTH = 255"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+MAX_GROUP_ROLEID_LENGTH = 255"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " class Membership:"
            },
            "10": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2017 Vector Creations Ltd",
            "# Copyright 2018-2019 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"Contains constants from the specification.\"\"\"",
            "",
            "# the \"depth\" field on events is limited to 2**63 - 1",
            "MAX_DEPTH = 2 ** 63 - 1",
            "",
            "# the maximum length for a room alias is 255 characters",
            "MAX_ALIAS_LENGTH = 255",
            "",
            "# the maximum length for a user id is 255 characters",
            "MAX_USERID_LENGTH = 255",
            "",
            "",
            "class Membership:",
            "",
            "    \"\"\"Represents the membership states of a user in a room.\"\"\"",
            "",
            "    INVITE = \"invite\"",
            "    JOIN = \"join\"",
            "    KNOCK = \"knock\"",
            "    LEAVE = \"leave\"",
            "    BAN = \"ban\"",
            "    LIST = (INVITE, JOIN, KNOCK, LEAVE, BAN)",
            "",
            "",
            "class PresenceState:",
            "    \"\"\"Represents the presence state of a user.\"\"\"",
            "",
            "    OFFLINE = \"offline\"",
            "    UNAVAILABLE = \"unavailable\"",
            "    ONLINE = \"online\"",
            "",
            "",
            "class JoinRules:",
            "    PUBLIC = \"public\"",
            "    KNOCK = \"knock\"",
            "    INVITE = \"invite\"",
            "    PRIVATE = \"private\"",
            "",
            "",
            "class LoginType:",
            "    PASSWORD = \"m.login.password\"",
            "    EMAIL_IDENTITY = \"m.login.email.identity\"",
            "    MSISDN = \"m.login.msisdn\"",
            "    RECAPTCHA = \"m.login.recaptcha\"",
            "    TERMS = \"m.login.terms\"",
            "    SSO = \"m.login.sso\"",
            "    DUMMY = \"m.login.dummy\"",
            "",
            "",
            "class EventTypes:",
            "    Member = \"m.room.member\"",
            "    Create = \"m.room.create\"",
            "    Tombstone = \"m.room.tombstone\"",
            "    JoinRules = \"m.room.join_rules\"",
            "    PowerLevels = \"m.room.power_levels\"",
            "    Aliases = \"m.room.aliases\"",
            "    Redaction = \"m.room.redaction\"",
            "    ThirdPartyInvite = \"m.room.third_party_invite\"",
            "    RelatedGroups = \"m.room.related_groups\"",
            "",
            "    RoomHistoryVisibility = \"m.room.history_visibility\"",
            "    CanonicalAlias = \"m.room.canonical_alias\"",
            "    Encrypted = \"m.room.encrypted\"",
            "    RoomAvatar = \"m.room.avatar\"",
            "    RoomEncryption = \"m.room.encryption\"",
            "    GuestAccess = \"m.room.guest_access\"",
            "",
            "    # These are used for validation",
            "    Message = \"m.room.message\"",
            "    Topic = \"m.room.topic\"",
            "    Name = \"m.room.name\"",
            "",
            "    ServerACL = \"m.room.server_acl\"",
            "    Pinned = \"m.room.pinned_events\"",
            "",
            "    Retention = \"m.room.retention\"",
            "",
            "    Presence = \"m.presence\"",
            "",
            "    Dummy = \"org.matrix.dummy_event\"",
            "",
            "",
            "class RejectedReason:",
            "    AUTH_ERROR = \"auth_error\"",
            "",
            "",
            "class RoomCreationPreset:",
            "    PRIVATE_CHAT = \"private_chat\"",
            "    PUBLIC_CHAT = \"public_chat\"",
            "    TRUSTED_PRIVATE_CHAT = \"trusted_private_chat\"",
            "",
            "",
            "class ThirdPartyEntityKind:",
            "    USER = \"user\"",
            "    LOCATION = \"location\"",
            "",
            "",
            "ServerNoticeMsgType = \"m.server_notice\"",
            "ServerNoticeLimitReached = \"m.server_notice.usage_limit_reached\"",
            "",
            "",
            "class UserTypes:",
            "    \"\"\"Allows for user type specific behaviour. With the benefit of hindsight",
            "    'admin' and 'guest' users should also be UserTypes. Normal users are type None",
            "    \"\"\"",
            "",
            "    SUPPORT = \"support\"",
            "    BOT = \"bot\"",
            "    ALL_USER_TYPES = (SUPPORT, BOT)",
            "",
            "",
            "class RelationTypes:",
            "    \"\"\"The types of relations known to this server.\"\"\"",
            "",
            "    ANNOTATION = \"m.annotation\"",
            "    REPLACE = \"m.replace\"",
            "    REFERENCE = \"m.reference\"",
            "",
            "",
            "class LimitBlockingTypes:",
            "    \"\"\"Reasons that a server may be blocked\"\"\"",
            "",
            "    MONTHLY_ACTIVE_USER = \"monthly_active_user\"",
            "    HS_DISABLED = \"hs_disabled\"",
            "",
            "",
            "class EventContentFields:",
            "    \"\"\"Fields found in events' content, regardless of type.\"\"\"",
            "",
            "    # Labels for the event, cf https://github.com/matrix-org/matrix-doc/pull/2326",
            "    LABELS = \"org.matrix.labels\"",
            "",
            "    # Timestamp to delete the event after",
            "    # cf https://github.com/matrix-org/matrix-doc/pull/2228",
            "    SELF_DESTRUCT_AFTER = \"org.matrix.self_destruct_after\"",
            "",
            "",
            "class RoomEncryptionAlgorithms:",
            "    MEGOLM_V1_AES_SHA2 = \"m.megolm.v1.aes-sha2\"",
            "    DEFAULT = MEGOLM_V1_AES_SHA2",
            "",
            "",
            "class AccountDataTypes:",
            "    DIRECT = \"m.direct\"",
            "    IGNORED_USER_LIST = \"m.ignored_user_list\"",
            "",
            "",
            "class HistoryVisibility:",
            "    INVITED = \"invited\"",
            "    JOINED = \"joined\"",
            "    SHARED = \"shared\"",
            "    WORLD_READABLE = \"world_readable\""
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2017 Vector Creations Ltd",
            "# Copyright 2018-2019 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"Contains constants from the specification.\"\"\"",
            "",
            "# the \"depth\" field on events is limited to 2**63 - 1",
            "MAX_DEPTH = 2 ** 63 - 1",
            "",
            "# the maximum length for a room alias is 255 characters",
            "MAX_ALIAS_LENGTH = 255",
            "",
            "# the maximum length for a user id is 255 characters",
            "MAX_USERID_LENGTH = 255",
            "",
            "# The maximum length for a group id is 255 characters",
            "MAX_GROUPID_LENGTH = 255",
            "MAX_GROUP_CATEGORYID_LENGTH = 255",
            "MAX_GROUP_ROLEID_LENGTH = 255",
            "",
            "",
            "class Membership:",
            "",
            "    \"\"\"Represents the membership states of a user in a room.\"\"\"",
            "",
            "    INVITE = \"invite\"",
            "    JOIN = \"join\"",
            "    KNOCK = \"knock\"",
            "    LEAVE = \"leave\"",
            "    BAN = \"ban\"",
            "    LIST = (INVITE, JOIN, KNOCK, LEAVE, BAN)",
            "",
            "",
            "class PresenceState:",
            "    \"\"\"Represents the presence state of a user.\"\"\"",
            "",
            "    OFFLINE = \"offline\"",
            "    UNAVAILABLE = \"unavailable\"",
            "    ONLINE = \"online\"",
            "",
            "",
            "class JoinRules:",
            "    PUBLIC = \"public\"",
            "    KNOCK = \"knock\"",
            "    INVITE = \"invite\"",
            "    PRIVATE = \"private\"",
            "",
            "",
            "class LoginType:",
            "    PASSWORD = \"m.login.password\"",
            "    EMAIL_IDENTITY = \"m.login.email.identity\"",
            "    MSISDN = \"m.login.msisdn\"",
            "    RECAPTCHA = \"m.login.recaptcha\"",
            "    TERMS = \"m.login.terms\"",
            "    SSO = \"m.login.sso\"",
            "    DUMMY = \"m.login.dummy\"",
            "",
            "",
            "class EventTypes:",
            "    Member = \"m.room.member\"",
            "    Create = \"m.room.create\"",
            "    Tombstone = \"m.room.tombstone\"",
            "    JoinRules = \"m.room.join_rules\"",
            "    PowerLevels = \"m.room.power_levels\"",
            "    Aliases = \"m.room.aliases\"",
            "    Redaction = \"m.room.redaction\"",
            "    ThirdPartyInvite = \"m.room.third_party_invite\"",
            "    RelatedGroups = \"m.room.related_groups\"",
            "",
            "    RoomHistoryVisibility = \"m.room.history_visibility\"",
            "    CanonicalAlias = \"m.room.canonical_alias\"",
            "    Encrypted = \"m.room.encrypted\"",
            "    RoomAvatar = \"m.room.avatar\"",
            "    RoomEncryption = \"m.room.encryption\"",
            "    GuestAccess = \"m.room.guest_access\"",
            "",
            "    # These are used for validation",
            "    Message = \"m.room.message\"",
            "    Topic = \"m.room.topic\"",
            "    Name = \"m.room.name\"",
            "",
            "    ServerACL = \"m.room.server_acl\"",
            "    Pinned = \"m.room.pinned_events\"",
            "",
            "    Retention = \"m.room.retention\"",
            "",
            "    Presence = \"m.presence\"",
            "",
            "    Dummy = \"org.matrix.dummy_event\"",
            "",
            "",
            "class RejectedReason:",
            "    AUTH_ERROR = \"auth_error\"",
            "",
            "",
            "class RoomCreationPreset:",
            "    PRIVATE_CHAT = \"private_chat\"",
            "    PUBLIC_CHAT = \"public_chat\"",
            "    TRUSTED_PRIVATE_CHAT = \"trusted_private_chat\"",
            "",
            "",
            "class ThirdPartyEntityKind:",
            "    USER = \"user\"",
            "    LOCATION = \"location\"",
            "",
            "",
            "ServerNoticeMsgType = \"m.server_notice\"",
            "ServerNoticeLimitReached = \"m.server_notice.usage_limit_reached\"",
            "",
            "",
            "class UserTypes:",
            "    \"\"\"Allows for user type specific behaviour. With the benefit of hindsight",
            "    'admin' and 'guest' users should also be UserTypes. Normal users are type None",
            "    \"\"\"",
            "",
            "    SUPPORT = \"support\"",
            "    BOT = \"bot\"",
            "    ALL_USER_TYPES = (SUPPORT, BOT)",
            "",
            "",
            "class RelationTypes:",
            "    \"\"\"The types of relations known to this server.\"\"\"",
            "",
            "    ANNOTATION = \"m.annotation\"",
            "    REPLACE = \"m.replace\"",
            "    REFERENCE = \"m.reference\"",
            "",
            "",
            "class LimitBlockingTypes:",
            "    \"\"\"Reasons that a server may be blocked\"\"\"",
            "",
            "    MONTHLY_ACTIVE_USER = \"monthly_active_user\"",
            "    HS_DISABLED = \"hs_disabled\"",
            "",
            "",
            "class EventContentFields:",
            "    \"\"\"Fields found in events' content, regardless of type.\"\"\"",
            "",
            "    # Labels for the event, cf https://github.com/matrix-org/matrix-doc/pull/2326",
            "    LABELS = \"org.matrix.labels\"",
            "",
            "    # Timestamp to delete the event after",
            "    # cf https://github.com/matrix-org/matrix-doc/pull/2228",
            "    SELF_DESTRUCT_AFTER = \"org.matrix.self_destruct_after\"",
            "",
            "",
            "class RoomEncryptionAlgorithms:",
            "    MEGOLM_V1_AES_SHA2 = \"m.megolm.v1.aes-sha2\"",
            "    DEFAULT = MEGOLM_V1_AES_SHA2",
            "",
            "",
            "class AccountDataTypes:",
            "    DIRECT = \"m.direct\"",
            "    IGNORED_USER_LIST = \"m.ignored_user_list\"",
            "",
            "",
            "class HistoryVisibility:",
            "    INVITED = \"invited\"",
            "    JOINED = \"joined\"",
            "    SHARED = \"shared\"",
            "    WORLD_READABLE = \"world_readable\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "synapse/federation/transport/server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from typing import Optional, Tuple, Type"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import synapse"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from synapse.api.constants import MAX_GROUP_CATEGORYID_LENGTH, MAX_GROUP_ROLEID_LENGTH"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from synapse.api.errors import Codes, FederationDeniedError, SynapseError"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from synapse.api.room_versions import RoomVersions"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from synapse.api.urls import ("
            },
            "7": {
                "beforePatchRowNumber": 1118,
                "afterPatchRowNumber": 1119,
                "PatchRowcode": "             raise SynapseError(403, \"requester_user_id doesn't match origin\")"
            },
            "8": {
                "beforePatchRowNumber": 1119,
                "afterPatchRowNumber": 1120,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 1120,
                "afterPatchRowNumber": 1121,
                "PatchRowcode": "         if category_id == \"\":"
            },
            "10": {
                "beforePatchRowNumber": 1121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise SynapseError(400, \"category_id cannot be empty string\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1122,
                "PatchRowcode": "+            raise SynapseError("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1123,
                "PatchRowcode": "+                400, \"category_id cannot be empty string\", Codes.INVALID_PARAM"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1124,
                "PatchRowcode": "+            )"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1125,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1126,
                "PatchRowcode": "+        if len(category_id) > MAX_GROUP_CATEGORYID_LENGTH:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1127,
                "PatchRowcode": "+            raise SynapseError("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1128,
                "PatchRowcode": "+                400,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1129,
                "PatchRowcode": "+                \"category_id may not be longer than %s characters\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1130,
                "PatchRowcode": "+                % (MAX_GROUP_CATEGORYID_LENGTH,),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1131,
                "PatchRowcode": "+                Codes.INVALID_PARAM,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1132,
                "PatchRowcode": "+            )"
            },
            "22": {
                "beforePatchRowNumber": 1122,
                "afterPatchRowNumber": 1133,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 1123,
                "afterPatchRowNumber": 1134,
                "PatchRowcode": "         resp = await self.handler.update_group_summary_room("
            },
            "24": {
                "beforePatchRowNumber": 1124,
                "afterPatchRowNumber": 1135,
                "PatchRowcode": "             group_id,"
            },
            "25": {
                "beforePatchRowNumber": 1184,
                "afterPatchRowNumber": 1195,
                "PatchRowcode": "         if category_id == \"\":"
            },
            "26": {
                "beforePatchRowNumber": 1185,
                "afterPatchRowNumber": 1196,
                "PatchRowcode": "             raise SynapseError(400, \"category_id cannot be empty string\")"
            },
            "27": {
                "beforePatchRowNumber": 1186,
                "afterPatchRowNumber": 1197,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1198,
                "PatchRowcode": "+        if len(category_id) > MAX_GROUP_CATEGORYID_LENGTH:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1199,
                "PatchRowcode": "+            raise SynapseError("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1200,
                "PatchRowcode": "+                400,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1201,
                "PatchRowcode": "+                \"category_id may not be longer than %s characters\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1202,
                "PatchRowcode": "+                % (MAX_GROUP_CATEGORYID_LENGTH,),"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1203,
                "PatchRowcode": "+                Codes.INVALID_PARAM,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1204,
                "PatchRowcode": "+            )"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1205,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": 1187,
                "afterPatchRowNumber": 1206,
                "PatchRowcode": "         resp = await self.handler.upsert_group_category("
            },
            "37": {
                "beforePatchRowNumber": 1188,
                "afterPatchRowNumber": 1207,
                "PatchRowcode": "             group_id, requester_user_id, category_id, content"
            },
            "38": {
                "beforePatchRowNumber": 1189,
                "afterPatchRowNumber": 1208,
                "PatchRowcode": "         )"
            },
            "39": {
                "beforePatchRowNumber": 1240,
                "afterPatchRowNumber": 1259,
                "PatchRowcode": "             raise SynapseError(403, \"requester_user_id doesn't match origin\")"
            },
            "40": {
                "beforePatchRowNumber": 1241,
                "afterPatchRowNumber": 1260,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 1242,
                "afterPatchRowNumber": 1261,
                "PatchRowcode": "         if role_id == \"\":"
            },
            "42": {
                "beforePatchRowNumber": 1243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise SynapseError(400, \"role_id cannot be empty string\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1262,
                "PatchRowcode": "+            raise SynapseError("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1263,
                "PatchRowcode": "+                400, \"role_id cannot be empty string\", Codes.INVALID_PARAM"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1264,
                "PatchRowcode": "+            )"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1265,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1266,
                "PatchRowcode": "+        if len(role_id) > MAX_GROUP_ROLEID_LENGTH:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1267,
                "PatchRowcode": "+            raise SynapseError("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1268,
                "PatchRowcode": "+                400,"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1269,
                "PatchRowcode": "+                \"role_id may not be longer than %s characters\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1270,
                "PatchRowcode": "+                % (MAX_GROUP_ROLEID_LENGTH,),"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1271,
                "PatchRowcode": "+                Codes.INVALID_PARAM,"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1272,
                "PatchRowcode": "+            )"
            },
            "54": {
                "beforePatchRowNumber": 1244,
                "afterPatchRowNumber": 1273,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 1245,
                "afterPatchRowNumber": 1274,
                "PatchRowcode": "         resp = await self.handler.update_group_role("
            },
            "56": {
                "beforePatchRowNumber": 1246,
                "afterPatchRowNumber": 1275,
                "PatchRowcode": "             group_id, requester_user_id, role_id, content"
            },
            "57": {
                "beforePatchRowNumber": 1285,
                "afterPatchRowNumber": 1314,
                "PatchRowcode": "         if role_id == \"\":"
            },
            "58": {
                "beforePatchRowNumber": 1286,
                "afterPatchRowNumber": 1315,
                "PatchRowcode": "             raise SynapseError(400, \"role_id cannot be empty string\")"
            },
            "59": {
                "beforePatchRowNumber": 1287,
                "afterPatchRowNumber": 1316,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1317,
                "PatchRowcode": "+        if len(role_id) > MAX_GROUP_ROLEID_LENGTH:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1318,
                "PatchRowcode": "+            raise SynapseError("
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1319,
                "PatchRowcode": "+                400,"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1320,
                "PatchRowcode": "+                \"role_id may not be longer than %s characters\""
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1321,
                "PatchRowcode": "+                % (MAX_GROUP_ROLEID_LENGTH,),"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1322,
                "PatchRowcode": "+                Codes.INVALID_PARAM,"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1323,
                "PatchRowcode": "+            )"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1324,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": 1288,
                "afterPatchRowNumber": 1325,
                "PatchRowcode": "         resp = await self.handler.update_group_summary_user("
            },
            "69": {
                "beforePatchRowNumber": 1289,
                "afterPatchRowNumber": 1326,
                "PatchRowcode": "             group_id,"
            },
            "70": {
                "beforePatchRowNumber": 1290,
                "afterPatchRowNumber": 1327,
                "PatchRowcode": "             requester_user_id,"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import functools",
            "import logging",
            "import re",
            "from typing import Optional, Tuple, Type",
            "",
            "import synapse",
            "from synapse.api.errors import Codes, FederationDeniedError, SynapseError",
            "from synapse.api.room_versions import RoomVersions",
            "from synapse.api.urls import (",
            "    FEDERATION_UNSTABLE_PREFIX,",
            "    FEDERATION_V1_PREFIX,",
            "    FEDERATION_V2_PREFIX,",
            ")",
            "from synapse.http.server import JsonResource",
            "from synapse.http.servlet import (",
            "    parse_boolean_from_args,",
            "    parse_integer_from_args,",
            "    parse_json_object_from_request,",
            "    parse_string_from_args,",
            ")",
            "from synapse.logging.context import run_in_background",
            "from synapse.logging.opentracing import (",
            "    start_active_span,",
            "    start_active_span_from_request,",
            "    tags,",
            "    whitelisted_homeserver,",
            ")",
            "from synapse.server import HomeServer",
            "from synapse.types import ThirdPartyInstanceID, get_domain_from_id",
            "from synapse.util.stringutils import parse_and_validate_server_name",
            "from synapse.util.versionstring import get_version_string",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class TransportLayerServer(JsonResource):",
            "    \"\"\"Handles incoming federation HTTP requests\"\"\"",
            "",
            "    def __init__(self, hs, servlet_groups=None):",
            "        \"\"\"Initialize the TransportLayerServer",
            "",
            "        Will by default register all servlets. For custom behaviour, pass in",
            "        a list of servlet_groups to register.",
            "",
            "        Args:",
            "            hs (synapse.server.HomeServer): homeserver",
            "            servlet_groups (list[str], optional): List of servlet groups to register.",
            "                Defaults to ``DEFAULT_SERVLET_GROUPS``.",
            "        \"\"\"",
            "        self.hs = hs",
            "        self.clock = hs.get_clock()",
            "        self.servlet_groups = servlet_groups",
            "",
            "        super().__init__(hs, canonical_json=False)",
            "",
            "        self.authenticator = Authenticator(hs)",
            "        self.ratelimiter = hs.get_federation_ratelimiter()",
            "",
            "        self.register_servlets()",
            "",
            "    def register_servlets(self):",
            "        register_servlets(",
            "            self.hs,",
            "            resource=self,",
            "            ratelimiter=self.ratelimiter,",
            "            authenticator=self.authenticator,",
            "            servlet_groups=self.servlet_groups,",
            "        )",
            "",
            "",
            "class AuthenticationError(SynapseError):",
            "    \"\"\"There was a problem authenticating the request\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class NoAuthenticationError(AuthenticationError):",
            "    \"\"\"The request had no authentication information\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class Authenticator:",
            "    def __init__(self, hs: HomeServer):",
            "        self._clock = hs.get_clock()",
            "        self.keyring = hs.get_keyring()",
            "        self.server_name = hs.hostname",
            "        self.store = hs.get_datastore()",
            "        self.federation_domain_whitelist = hs.config.federation_domain_whitelist",
            "        self.notifier = hs.get_notifier()",
            "",
            "        self.replication_client = None",
            "        if hs.config.worker.worker_app:",
            "            self.replication_client = hs.get_tcp_replication()",
            "",
            "    # A method just so we can pass 'self' as the authenticator to the Servlets",
            "    async def authenticate_request(self, request, content):",
            "        now = self._clock.time_msec()",
            "        json_request = {",
            "            \"method\": request.method.decode(\"ascii\"),",
            "            \"uri\": request.uri.decode(\"ascii\"),",
            "            \"destination\": self.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(b\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(",
            "                401, \"Missing Authorization headers\", Codes.UNAUTHORIZED",
            "            )",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(b\"X-Matrix\"):",
            "                (origin, key, sig) = _parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if (",
            "            self.federation_domain_whitelist is not None",
            "            and origin not in self.federation_domain_whitelist",
            "        ):",
            "            raise FederationDeniedError(origin)",
            "",
            "        if origin is None or not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(",
            "                401, \"Missing Authorization headers\", Codes.UNAUTHORIZED",
            "            )",
            "",
            "        await self.keyring.verify_json_for_server(",
            "            origin, json_request, now, \"Incoming request\"",
            "        )",
            "",
            "        logger.debug(\"Request from %s\", origin)",
            "        request.requester = origin",
            "",
            "        # If we get a valid signed request from the other side, its probably",
            "        # alive",
            "        retry_timings = await self.store.get_destination_retry_timings(origin)",
            "        if retry_timings and retry_timings[\"retry_last_ts\"]:",
            "            run_in_background(self._reset_retry_timings, origin)",
            "",
            "        return origin",
            "",
            "    async def _reset_retry_timings(self, origin):",
            "        try:",
            "            logger.info(\"Marking origin %r as up\", origin)",
            "            await self.store.set_destination_retry_timings(origin, None, 0, 0)",
            "",
            "            # Inform the relevant places that the remote server is back up.",
            "            self.notifier.notify_remote_server_up(origin)",
            "            if self.replication_client:",
            "                # If we're on a worker we try and inform master about this. The",
            "                # replication client doesn't hook into the notifier to avoid",
            "                # infinite loops where we send a `REMOTE_SERVER_UP` command to",
            "                # master, which then echoes it back to us which in turn pokes",
            "                # the notifier.",
            "                self.replication_client.send_remote_server_up(origin)",
            "",
            "        except Exception:",
            "            logger.exception(\"Error resetting retry timings on %s\", origin)",
            "",
            "",
            "def _parse_auth_header(header_bytes):",
            "    \"\"\"Parse an X-Matrix auth header",
            "",
            "    Args:",
            "        header_bytes (bytes): header value",
            "",
            "    Returns:",
            "        Tuple[str, str, str]: origin, key id, signature.",
            "",
            "    Raises:",
            "        AuthenticationError if the header could not be parsed",
            "    \"\"\"",
            "    try:",
            "        header_str = header_bytes.decode(\"utf-8\")",
            "        params = header_str.split(\" \")[1].split(\",\")",
            "        param_dict = dict(kv.split(\"=\") for kv in params)",
            "",
            "        def strip_quotes(value):",
            "            if value.startswith('\"'):",
            "                return value[1:-1]",
            "            else:",
            "                return value",
            "",
            "        origin = strip_quotes(param_dict[\"origin\"])",
            "",
            "        # ensure that the origin is a valid server name",
            "        parse_and_validate_server_name(origin)",
            "",
            "        key = strip_quotes(param_dict[\"key\"])",
            "        sig = strip_quotes(param_dict[\"sig\"])",
            "        return origin, key, sig",
            "    except Exception as e:",
            "        logger.warning(",
            "            \"Error parsing auth header '%s': %s\",",
            "            header_bytes.decode(\"ascii\", \"replace\"),",
            "            e,",
            "        )",
            "        raise AuthenticationError(",
            "            400, \"Malformed Authorization header\", Codes.UNAUTHORIZED",
            "        )",
            "",
            "",
            "class BaseFederationServlet:",
            "    \"\"\"Abstract base class for federation servlet classes.",
            "",
            "    The servlet object should have a PATH attribute which takes the form of a regexp to",
            "    match against the request path (excluding the /federation/v1 prefix).",
            "",
            "    The servlet should also implement one or more of on_GET, on_POST, on_PUT, to match",
            "    the appropriate HTTP method. These methods must be *asynchronous* and have the",
            "    signature:",
            "",
            "        on_<METHOD>(self, origin, content, query, **kwargs)",
            "",
            "        With arguments:",
            "",
            "            origin (unicode|None): The authenticated server_name of the calling server,",
            "                unless REQUIRE_AUTH is set to False and authentication failed.",
            "",
            "            content (unicode|None): decoded json body of the request. None if the",
            "                request was a GET.",
            "",
            "            query (dict[bytes, list[bytes]]): Query params from the request. url-decoded",
            "                (ie, '+' and '%xx' are decoded) but note that it is *not* utf8-decoded",
            "                yet.",
            "",
            "            **kwargs (dict[unicode, unicode]): the dict mapping keys to path",
            "                components as specified in the path match regexp.",
            "",
            "        Returns:",
            "            Optional[Tuple[int, object]]: either (response code, response object) to",
            "                 return a JSON response, or None if the request has already been handled.",
            "",
            "        Raises:",
            "            SynapseError: to return an error code",
            "",
            "            Exception: other exceptions will be caught, logged, and a 500 will be",
            "                returned.",
            "    \"\"\"",
            "",
            "    PATH = \"\"  # Overridden in subclasses, the regex to match against the path.",
            "",
            "    REQUIRE_AUTH = True",
            "",
            "    PREFIX = FEDERATION_V1_PREFIX  # Allows specifying the API version",
            "",
            "    RATELIMIT = True  # Whether to rate limit requests or not",
            "",
            "    def __init__(self, handler, authenticator, ratelimiter, server_name):",
            "        self.handler = handler",
            "        self.authenticator = authenticator",
            "        self.ratelimiter = ratelimiter",
            "",
            "    def _wrap(self, func):",
            "        authenticator = self.authenticator",
            "        ratelimiter = self.ratelimiter",
            "",
            "        @functools.wraps(func)",
            "        async def new_func(request, *args, **kwargs):",
            "            \"\"\"A callback which can be passed to HttpServer.RegisterPaths",
            "",
            "            Args:",
            "                request (twisted.web.http.Request):",
            "                *args: unused?",
            "                **kwargs (dict[unicode, unicode]): the dict mapping keys to path",
            "                    components as specified in the path match regexp.",
            "",
            "            Returns:",
            "                Tuple[int, object]|None: (response code, response object) as returned by",
            "                    the callback method. None if the request has already been handled.",
            "            \"\"\"",
            "            content = None",
            "            if request.method in [b\"PUT\", b\"POST\"]:",
            "                # TODO: Handle other method types? other content types?",
            "                content = parse_json_object_from_request(request)",
            "",
            "            try:",
            "                origin = await authenticator.authenticate_request(request, content)",
            "            except NoAuthenticationError:",
            "                origin = None",
            "                if self.REQUIRE_AUTH:",
            "                    logger.warning(",
            "                        \"authenticate_request failed: missing authentication\"",
            "                    )",
            "                    raise",
            "            except Exception as e:",
            "                logger.warning(\"authenticate_request failed: %s\", e)",
            "                raise",
            "",
            "            request_tags = {",
            "                \"request_id\": request.get_request_id(),",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_SERVER,",
            "                tags.HTTP_METHOD: request.get_method(),",
            "                tags.HTTP_URL: request.get_redacted_uri(),",
            "                tags.PEER_HOST_IPV6: request.getClientIP(),",
            "                \"authenticated_entity\": origin,",
            "                \"servlet_name\": request.request_metrics.name,",
            "            }",
            "",
            "            # Only accept the span context if the origin is authenticated",
            "            # and whitelisted",
            "            if origin and whitelisted_homeserver(origin):",
            "                scope = start_active_span_from_request(",
            "                    request, \"incoming-federation-request\", tags=request_tags",
            "                )",
            "            else:",
            "                scope = start_active_span(",
            "                    \"incoming-federation-request\", tags=request_tags",
            "                )",
            "",
            "            with scope:",
            "                if origin and self.RATELIMIT:",
            "                    with ratelimiter.ratelimit(origin) as d:",
            "                        await d",
            "                        if request._disconnected:",
            "                            logger.warning(",
            "                                \"client disconnected before we started processing \"",
            "                                \"request\"",
            "                            )",
            "                            return -1, None",
            "                        response = await func(",
            "                            origin, content, request.args, *args, **kwargs",
            "                        )",
            "                else:",
            "                    response = await func(",
            "                        origin, content, request.args, *args, **kwargs",
            "                    )",
            "",
            "            return response",
            "",
            "        return new_func",
            "",
            "    def register(self, server):",
            "        pattern = re.compile(\"^\" + self.PREFIX + self.PATH + \"$\")",
            "",
            "        for method in (\"GET\", \"PUT\", \"POST\"):",
            "            code = getattr(self, \"on_%s\" % (method), None)",
            "            if code is None:",
            "                continue",
            "",
            "            server.register_paths(",
            "                method,",
            "                (pattern,),",
            "                self._wrap(code),",
            "                self.__class__.__name__,",
            "            )",
            "",
            "",
            "class FederationSendServlet(BaseFederationServlet):",
            "    PATH = \"/send/(?P<transaction_id>[^/]*)/?\"",
            "",
            "    # We ratelimit manually in the handler as we queue up the requests and we",
            "    # don't want to fill up the ratelimiter with blocked requests.",
            "    RATELIMIT = False",
            "",
            "    def __init__(self, handler, server_name, **kwargs):",
            "        super().__init__(handler, server_name=server_name, **kwargs)",
            "        self.server_name = server_name",
            "",
            "    # This is when someone is trying to send us a bunch of data.",
            "    async def on_PUT(self, origin, content, query, transaction_id):",
            "        \"\"\"Called on PUT /send/<transaction_id>/",
            "",
            "        Args:",
            "            request (twisted.web.http.Request): The HTTP request.",
            "            transaction_id (str): The transaction_id associated with this",
            "                request. This is *not* None.",
            "",
            "        Returns:",
            "            Tuple of `(code, response)`, where",
            "            `response` is a python dict to be converted into JSON that is",
            "            used as the response body.",
            "        \"\"\"",
            "        # Parse the request",
            "        try:",
            "            transaction_data = content",
            "",
            "            logger.debug(\"Decoded %s: %s\", transaction_id, str(transaction_data))",
            "",
            "            logger.info(",
            "                \"Received txn %s from %s. (PDUs: %d, EDUs: %d)\",",
            "                transaction_id,",
            "                origin,",
            "                len(transaction_data.get(\"pdus\", [])),",
            "                len(transaction_data.get(\"edus\", [])),",
            "            )",
            "",
            "            # We should ideally be getting this from the security layer.",
            "            # origin = body[\"origin\"]",
            "",
            "            # Add some extra data to the transaction dict that isn't included",
            "            # in the request body.",
            "            transaction_data.update(",
            "                transaction_id=transaction_id, destination=self.server_name",
            "            )",
            "",
            "        except Exception as e:",
            "            logger.exception(e)",
            "            return 400, {\"error\": \"Invalid transaction\"}",
            "",
            "        try:",
            "            code, response = await self.handler.on_incoming_transaction(",
            "                origin, transaction_data",
            "            )",
            "        except Exception:",
            "            logger.exception(\"on_incoming_transaction failed\")",
            "            raise",
            "",
            "        return code, response",
            "",
            "",
            "class FederationEventServlet(BaseFederationServlet):",
            "    PATH = \"/event/(?P<event_id>[^/]*)/?\"",
            "",
            "    # This is when someone asks for a data item for a given server data_id pair.",
            "    async def on_GET(self, origin, content, query, event_id):",
            "        return await self.handler.on_pdu_request(origin, event_id)",
            "",
            "",
            "class FederationStateV1Servlet(BaseFederationServlet):",
            "    PATH = \"/state/(?P<room_id>[^/]*)/?\"",
            "",
            "    # This is when someone asks for all data for a given room.",
            "    async def on_GET(self, origin, content, query, room_id):",
            "        return await self.handler.on_room_state_request(",
            "            origin,",
            "            room_id,",
            "            parse_string_from_args(query, \"event_id\", None, required=False),",
            "        )",
            "",
            "",
            "class FederationStateIdsServlet(BaseFederationServlet):",
            "    PATH = \"/state_ids/(?P<room_id>[^/]*)/?\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id):",
            "        return await self.handler.on_state_ids_request(",
            "            origin,",
            "            room_id,",
            "            parse_string_from_args(query, \"event_id\", None, required=True),",
            "        )",
            "",
            "",
            "class FederationBackfillServlet(BaseFederationServlet):",
            "    PATH = \"/backfill/(?P<room_id>[^/]*)/?\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id):",
            "        versions = [x.decode(\"ascii\") for x in query[b\"v\"]]",
            "        limit = parse_integer_from_args(query, \"limit\", None)",
            "",
            "        if not limit:",
            "            return 400, {\"error\": \"Did not include limit param\"}",
            "",
            "        return await self.handler.on_backfill_request(origin, room_id, versions, limit)",
            "",
            "",
            "class FederationQueryServlet(BaseFederationServlet):",
            "    PATH = \"/query/(?P<query_type>[^/]*)\"",
            "",
            "    # This is when we receive a server-server Query",
            "    async def on_GET(self, origin, content, query, query_type):",
            "        return await self.handler.on_query_request(",
            "            query_type,",
            "            {k.decode(\"utf8\"): v[0].decode(\"utf-8\") for k, v in query.items()},",
            "        )",
            "",
            "",
            "class FederationMakeJoinServlet(BaseFederationServlet):",
            "    PATH = \"/make_join/(?P<room_id>[^/]*)/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, _content, query, room_id, user_id):",
            "        \"\"\"",
            "        Args:",
            "            origin (unicode): The authenticated server_name of the calling server",
            "",
            "            _content (None): (GETs don't have bodies)",
            "",
            "            query (dict[bytes, list[bytes]]): Query params from the request.",
            "",
            "            **kwargs (dict[unicode, unicode]): the dict mapping keys to path",
            "                components as specified in the path match regexp.",
            "",
            "        Returns:",
            "            Tuple[int, object]: (response code, response object)",
            "        \"\"\"",
            "        versions = query.get(b\"ver\")",
            "        if versions is not None:",
            "            supported_versions = [v.decode(\"utf-8\") for v in versions]",
            "        else:",
            "            supported_versions = [\"1\"]",
            "",
            "        content = await self.handler.on_make_join_request(",
            "            origin, room_id, user_id, supported_versions=supported_versions",
            "        )",
            "        return 200, content",
            "",
            "",
            "class FederationMakeLeaveServlet(BaseFederationServlet):",
            "    PATH = \"/make_leave/(?P<room_id>[^/]*)/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id, user_id):",
            "        content = await self.handler.on_make_leave_request(origin, room_id, user_id)",
            "        return 200, content",
            "",
            "",
            "class FederationV1SendLeaveServlet(BaseFederationServlet):",
            "    PATH = \"/send_leave/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        content = await self.handler.on_send_leave_request(origin, content)",
            "        return 200, (200, content)",
            "",
            "",
            "class FederationV2SendLeaveServlet(BaseFederationServlet):",
            "    PATH = \"/send_leave/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    PREFIX = FEDERATION_V2_PREFIX",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        content = await self.handler.on_send_leave_request(origin, content)",
            "        return 200, content",
            "",
            "",
            "class FederationEventAuthServlet(BaseFederationServlet):",
            "    PATH = \"/event_auth/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id, event_id):",
            "        return await self.handler.on_event_auth(origin, room_id, event_id)",
            "",
            "",
            "class FederationV1SendJoinServlet(BaseFederationServlet):",
            "    PATH = \"/send_join/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # TODO(paul): assert that room_id/event_id parsed from path actually",
            "        #   match those given in content",
            "        content = await self.handler.on_send_join_request(origin, content)",
            "        return 200, (200, content)",
            "",
            "",
            "class FederationV2SendJoinServlet(BaseFederationServlet):",
            "    PATH = \"/send_join/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    PREFIX = FEDERATION_V2_PREFIX",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # TODO(paul): assert that room_id/event_id parsed from path actually",
            "        #   match those given in content",
            "        content = await self.handler.on_send_join_request(origin, content)",
            "        return 200, content",
            "",
            "",
            "class FederationV1InviteServlet(BaseFederationServlet):",
            "    PATH = \"/invite/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # We don't get a room version, so we have to assume its EITHER v1 or",
            "        # v2. This is \"fine\" as the only difference between V1 and V2 is the",
            "        # state resolution algorithm, and we don't use that for processing",
            "        # invites",
            "        content = await self.handler.on_invite_request(",
            "            origin, content, room_version_id=RoomVersions.V1.identifier",
            "        )",
            "",
            "        # V1 federation API is defined to return a content of `[200, {...}]`",
            "        # due to a historical bug.",
            "        return 200, (200, content)",
            "",
            "",
            "class FederationV2InviteServlet(BaseFederationServlet):",
            "    PATH = \"/invite/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    PREFIX = FEDERATION_V2_PREFIX",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # TODO(paul): assert that room_id/event_id parsed from path actually",
            "        #   match those given in content",
            "",
            "        room_version = content[\"room_version\"]",
            "        event = content[\"event\"]",
            "        invite_room_state = content[\"invite_room_state\"]",
            "",
            "        # Synapse expects invite_room_state to be in unsigned, as it is in v1",
            "        # API",
            "",
            "        event.setdefault(\"unsigned\", {})[\"invite_room_state\"] = invite_room_state",
            "",
            "        content = await self.handler.on_invite_request(",
            "            origin, event, room_version_id=room_version",
            "        )",
            "        return 200, content",
            "",
            "",
            "class FederationThirdPartyInviteExchangeServlet(BaseFederationServlet):",
            "    PATH = \"/exchange_third_party_invite/(?P<room_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id):",
            "        content = await self.handler.on_exchange_third_party_invite_request(content)",
            "        return 200, content",
            "",
            "",
            "class FederationClientKeysQueryServlet(BaseFederationServlet):",
            "    PATH = \"/user/keys/query\"",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        return await self.handler.on_query_client_keys(origin, content)",
            "",
            "",
            "class FederationUserDevicesQueryServlet(BaseFederationServlet):",
            "    PATH = \"/user/devices/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, content, query, user_id):",
            "        return await self.handler.on_query_user_devices(origin, user_id)",
            "",
            "",
            "class FederationClientKeysClaimServlet(BaseFederationServlet):",
            "    PATH = \"/user/keys/claim\"",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        response = await self.handler.on_claim_client_keys(origin, content)",
            "        return 200, response",
            "",
            "",
            "class FederationGetMissingEventsServlet(BaseFederationServlet):",
            "    # TODO(paul): Why does this path alone end with \"/?\" optional?",
            "    PATH = \"/get_missing_events/(?P<room_id>[^/]*)/?\"",
            "",
            "    async def on_POST(self, origin, content, query, room_id):",
            "        limit = int(content.get(\"limit\", 10))",
            "        earliest_events = content.get(\"earliest_events\", [])",
            "        latest_events = content.get(\"latest_events\", [])",
            "",
            "        content = await self.handler.on_get_missing_events(",
            "            origin,",
            "            room_id=room_id,",
            "            earliest_events=earliest_events,",
            "            latest_events=latest_events,",
            "            limit=limit,",
            "        )",
            "",
            "        return 200, content",
            "",
            "",
            "class On3pidBindServlet(BaseFederationServlet):",
            "    PATH = \"/3pid/onbind\"",
            "",
            "    REQUIRE_AUTH = False",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        if \"invites\" in content:",
            "            last_exception = None",
            "            for invite in content[\"invites\"]:",
            "                try:",
            "                    if \"signed\" not in invite or \"token\" not in invite[\"signed\"]:",
            "                        message = (",
            "                            \"Rejecting received notification of third-\"",
            "                            \"party invite without signed: %s\" % (invite,)",
            "                        )",
            "                        logger.info(message)",
            "                        raise SynapseError(400, message)",
            "                    await self.handler.exchange_third_party_invite(",
            "                        invite[\"sender\"],",
            "                        invite[\"mxid\"],",
            "                        invite[\"room_id\"],",
            "                        invite[\"signed\"],",
            "                    )",
            "                except Exception as e:",
            "                    last_exception = e",
            "            if last_exception:",
            "                raise last_exception",
            "        return 200, {}",
            "",
            "",
            "class OpenIdUserInfo(BaseFederationServlet):",
            "    \"\"\"",
            "    Exchange a bearer token for information about a user.",
            "",
            "    The response format should be compatible with:",
            "        http://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse",
            "",
            "    GET /openid/userinfo?access_token=ABDEFGH HTTP/1.1",
            "",
            "    HTTP/1.1 200 OK",
            "    Content-Type: application/json",
            "",
            "    {",
            "        \"sub\": \"@userpart:example.org\",",
            "    }",
            "    \"\"\"",
            "",
            "    PATH = \"/openid/userinfo\"",
            "",
            "    REQUIRE_AUTH = False",
            "",
            "    async def on_GET(self, origin, content, query):",
            "        token = query.get(b\"access_token\", [None])[0]",
            "        if token is None:",
            "            return (",
            "                401,",
            "                {\"errcode\": \"M_MISSING_TOKEN\", \"error\": \"Access Token required\"},",
            "            )",
            "",
            "        user_id = await self.handler.on_openid_userinfo(token.decode(\"ascii\"))",
            "",
            "        if user_id is None:",
            "            return (",
            "                401,",
            "                {",
            "                    \"errcode\": \"M_UNKNOWN_TOKEN\",",
            "                    \"error\": \"Access Token unknown or expired\",",
            "                },",
            "            )",
            "",
            "        return 200, {\"sub\": user_id}",
            "",
            "",
            "class PublicRoomList(BaseFederationServlet):",
            "    \"\"\"",
            "    Fetch the public room list for this server.",
            "",
            "    This API returns information in the same format as /publicRooms on the",
            "    client API, but will only ever include local public rooms and hence is",
            "    intended for consumption by other homeservers.",
            "",
            "    GET /publicRooms HTTP/1.1",
            "",
            "    HTTP/1.1 200 OK",
            "    Content-Type: application/json",
            "",
            "    {",
            "        \"chunk\": [",
            "            {",
            "                \"aliases\": [",
            "                    \"#test:localhost\"",
            "                ],",
            "                \"guest_can_join\": false,",
            "                \"name\": \"test room\",",
            "                \"num_joined_members\": 3,",
            "                \"room_id\": \"!whkydVegtvatLfXmPN:localhost\",",
            "                \"world_readable\": false",
            "            }",
            "        ],",
            "        \"end\": \"END\",",
            "        \"start\": \"START\"",
            "    }",
            "    \"\"\"",
            "",
            "    PATH = \"/publicRooms\"",
            "",
            "    def __init__(self, handler, authenticator, ratelimiter, server_name, allow_access):",
            "        super().__init__(handler, authenticator, ratelimiter, server_name)",
            "        self.allow_access = allow_access",
            "",
            "    async def on_GET(self, origin, content, query):",
            "        if not self.allow_access:",
            "            raise FederationDeniedError(origin)",
            "",
            "        limit = parse_integer_from_args(query, \"limit\", 0)",
            "        since_token = parse_string_from_args(query, \"since\", None)",
            "        include_all_networks = parse_boolean_from_args(",
            "            query, \"include_all_networks\", False",
            "        )",
            "        third_party_instance_id = parse_string_from_args(",
            "            query, \"third_party_instance_id\", None",
            "        )",
            "",
            "        if include_all_networks:",
            "            network_tuple = None",
            "        elif third_party_instance_id:",
            "            network_tuple = ThirdPartyInstanceID.from_string(third_party_instance_id)",
            "        else:",
            "            network_tuple = ThirdPartyInstanceID(None, None)",
            "",
            "        if limit == 0:",
            "            # zero is a special value which corresponds to no limit.",
            "            limit = None",
            "",
            "        data = await self.handler.get_local_public_room_list(",
            "            limit, since_token, network_tuple=network_tuple, from_federation=True",
            "        )",
            "        return 200, data",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        # This implements MSC2197 (Search Filtering over Federation)",
            "        if not self.allow_access:",
            "            raise FederationDeniedError(origin)",
            "",
            "        limit = int(content.get(\"limit\", 100))  # type: Optional[int]",
            "        since_token = content.get(\"since\", None)",
            "        search_filter = content.get(\"filter\", None)",
            "",
            "        include_all_networks = content.get(\"include_all_networks\", False)",
            "        third_party_instance_id = content.get(\"third_party_instance_id\", None)",
            "",
            "        if include_all_networks:",
            "            network_tuple = None",
            "            if third_party_instance_id is not None:",
            "                raise SynapseError(",
            "                    400, \"Can't use include_all_networks with an explicit network\"",
            "                )",
            "        elif third_party_instance_id is None:",
            "            network_tuple = ThirdPartyInstanceID(None, None)",
            "        else:",
            "            network_tuple = ThirdPartyInstanceID.from_string(third_party_instance_id)",
            "",
            "        if search_filter is None:",
            "            logger.warning(\"Nonefilter\")",
            "",
            "        if limit == 0:",
            "            # zero is a special value which corresponds to no limit.",
            "            limit = None",
            "",
            "        data = await self.handler.get_local_public_room_list(",
            "            limit=limit,",
            "            since_token=since_token,",
            "            search_filter=search_filter,",
            "            network_tuple=network_tuple,",
            "            from_federation=True,",
            "        )",
            "",
            "        return 200, data",
            "",
            "",
            "class FederationVersionServlet(BaseFederationServlet):",
            "    PATH = \"/version\"",
            "",
            "    REQUIRE_AUTH = False",
            "",
            "    async def on_GET(self, origin, content, query):",
            "        return (",
            "            200,",
            "            {\"server\": {\"name\": \"Synapse\", \"version\": get_version_string(synapse)}},",
            "        )",
            "",
            "",
            "class FederationGroupsProfileServlet(BaseFederationServlet):",
            "    \"\"\"Get/set the basic profile of a group on behalf of a user\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/profile\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_group_profile(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "    async def on_POST(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.update_group_profile(",
            "            group_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsSummaryServlet(BaseFederationServlet):",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/summary\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_group_summary(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRoomsServlet(BaseFederationServlet):",
            "    \"\"\"Get the rooms in a group on behalf of a user\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/rooms\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_rooms_in_group(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsAddRoomsServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove room from group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/room/(?P<room_id>[^/]*)\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.add_room_to_group(",
            "            group_id, requester_user_id, room_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.remove_room_from_group(",
            "            group_id, requester_user_id, room_id",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsAddRoomsConfigServlet(BaseFederationServlet):",
            "    \"\"\"Update room config in group\"\"\"",
            "",
            "    PATH = (",
            "        \"/groups/(?P<group_id>[^/]*)/room/(?P<room_id>[^/]*)\"",
            "        \"/config/(?P<config_key>[^/]*)\"",
            "    )",
            "",
            "    async def on_POST(self, origin, content, query, group_id, room_id, config_key):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        result = await self.handler.update_room_in_group(",
            "            group_id, requester_user_id, room_id, config_key, content",
            "        )",
            "",
            "        return 200, result",
            "",
            "",
            "class FederationGroupsUsersServlet(BaseFederationServlet):",
            "    \"\"\"Get the users in a group on behalf of a user\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_users_in_group(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsInvitedUsersServlet(BaseFederationServlet):",
            "    \"\"\"Get the users that have been invited to a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/invited_users\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_invited_users_in_group(",
            "            group_id, requester_user_id",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsInviteServlet(BaseFederationServlet):",
            "    \"\"\"Ask a group server to invite someone to the group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/invite\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.invite_to_group(",
            "            group_id, user_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsAcceptInviteServlet(BaseFederationServlet):",
            "    \"\"\"Accept an invitation from the group server\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/accept_invite\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(user_id) != origin:",
            "            raise SynapseError(403, \"user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.accept_invite(group_id, user_id, content)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsJoinServlet(BaseFederationServlet):",
            "    \"\"\"Attempt to join a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/join\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(user_id) != origin:",
            "            raise SynapseError(403, \"user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.join_group(group_id, user_id, content)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRemoveUserServlet(BaseFederationServlet):",
            "    \"\"\"Leave or kick a user from the group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/remove\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.remove_user_from_group(",
            "            group_id, user_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsLocalInviteServlet(BaseFederationServlet):",
            "    \"\"\"A group server has invited a local user\"\"\"",
            "",
            "    PATH = \"/groups/local/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/invite\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(group_id) != origin:",
            "            raise SynapseError(403, \"group_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.on_invite(group_id, user_id, content)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRemoveLocalUserServlet(BaseFederationServlet):",
            "    \"\"\"A group server has removed a local user\"\"\"",
            "",
            "    PATH = \"/groups/local/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/remove\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(group_id) != origin:",
            "            raise SynapseError(403, \"user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.user_removed_from_group(",
            "            group_id, user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRenewAttestaionServlet(BaseFederationServlet):",
            "    \"\"\"A group or user's server renews their attestation\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/renew_attestation/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        # We don't need to check auth here as we check the attestation signatures",
            "",
            "        new_content = await self.handler.on_renew_attestation(",
            "            group_id, user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsSummaryRoomsServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove a room from the group summary, with optional category.",
            "",
            "    Matches both:",
            "        - /groups/:group/summary/rooms/:room_id",
            "        - /groups/:group/summary/categories/:category/rooms/:room_id",
            "    \"\"\"",
            "",
            "    PATH = (",
            "        \"/groups/(?P<group_id>[^/]*)/summary\"",
            "        \"(/categories/(?P<category_id>[^/]+))?\"",
            "        \"/rooms/(?P<room_id>[^/]*)\"",
            "    )",
            "",
            "    async def on_POST(self, origin, content, query, group_id, category_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(400, \"category_id cannot be empty string\")",
            "",
            "        resp = await self.handler.update_group_summary_room(",
            "            group_id,",
            "            requester_user_id,",
            "            room_id=room_id,",
            "            category_id=category_id,",
            "            content=content,",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, category_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(400, \"category_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_summary_room(",
            "            group_id, requester_user_id, room_id=room_id, category_id=category_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsCategoriesServlet(BaseFederationServlet):",
            "    \"\"\"Get all categories for a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/categories/?\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_categories(group_id, requester_user_id)",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsCategoryServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove/get a category in a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/categories/(?P<category_id>[^/]+)\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id, category_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_category(",
            "            group_id, requester_user_id, category_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_POST(self, origin, content, query, group_id, category_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(400, \"category_id cannot be empty string\")",
            "",
            "        resp = await self.handler.upsert_group_category(",
            "            group_id, requester_user_id, category_id, content",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, category_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(400, \"category_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_category(",
            "            group_id, requester_user_id, category_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsRolesServlet(BaseFederationServlet):",
            "    \"\"\"Get roles in a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/roles/?\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_roles(group_id, requester_user_id)",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsRoleServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove/get a role in a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/roles/(?P<role_id>[^/]+)\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id, role_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_role(group_id, requester_user_id, role_id)",
            "",
            "        return 200, resp",
            "",
            "    async def on_POST(self, origin, content, query, group_id, role_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(400, \"role_id cannot be empty string\")",
            "",
            "        resp = await self.handler.update_group_role(",
            "            group_id, requester_user_id, role_id, content",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, role_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(400, \"role_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_role(",
            "            group_id, requester_user_id, role_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsSummaryUsersServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove a user from the group summary, with optional role.",
            "",
            "    Matches both:",
            "        - /groups/:group/summary/users/:user_id",
            "        - /groups/:group/summary/roles/:role/users/:user_id",
            "    \"\"\"",
            "",
            "    PATH = (",
            "        \"/groups/(?P<group_id>[^/]*)/summary\"",
            "        \"(/roles/(?P<role_id>[^/]+))?\"",
            "        \"/users/(?P<user_id>[^/]*)\"",
            "    )",
            "",
            "    async def on_POST(self, origin, content, query, group_id, role_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(400, \"role_id cannot be empty string\")",
            "",
            "        resp = await self.handler.update_group_summary_user(",
            "            group_id,",
            "            requester_user_id,",
            "            user_id=user_id,",
            "            role_id=role_id,",
            "            content=content,",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, role_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(400, \"role_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_summary_user(",
            "            group_id, requester_user_id, user_id=user_id, role_id=role_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsBulkPublicisedServlet(BaseFederationServlet):",
            "    \"\"\"Get roles in a group\"\"\"",
            "",
            "    PATH = \"/get_groups_publicised\"",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        resp = await self.handler.bulk_get_publicised_groups(",
            "            content[\"user_ids\"], proxy=False",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsSettingJoinPolicyServlet(BaseFederationServlet):",
            "    \"\"\"Sets whether a group is joinable without an invite or knock\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/settings/m.join_policy\"",
            "",
            "    async def on_PUT(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.set_group_join_policy(",
            "            group_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class RoomComplexityServlet(BaseFederationServlet):",
            "    \"\"\"",
            "    Indicates to other servers how complex (and therefore likely",
            "    resource-intensive) a public room this server knows about is.",
            "    \"\"\"",
            "",
            "    PATH = \"/rooms/(?P<room_id>[^/]*)/complexity\"",
            "    PREFIX = FEDERATION_UNSTABLE_PREFIX",
            "",
            "    async def on_GET(self, origin, content, query, room_id):",
            "",
            "        store = self.handler.hs.get_datastore()",
            "",
            "        is_public = await store.is_room_world_readable_or_publicly_joinable(room_id)",
            "",
            "        if not is_public:",
            "            raise SynapseError(404, \"Room not found\", errcode=Codes.INVALID_PARAM)",
            "",
            "        complexity = await store.get_room_complexity(room_id)",
            "        return 200, complexity",
            "",
            "",
            "FEDERATION_SERVLET_CLASSES = (",
            "    FederationSendServlet,",
            "    FederationEventServlet,",
            "    FederationStateV1Servlet,",
            "    FederationStateIdsServlet,",
            "    FederationBackfillServlet,",
            "    FederationQueryServlet,",
            "    FederationMakeJoinServlet,",
            "    FederationMakeLeaveServlet,",
            "    FederationEventServlet,",
            "    FederationV1SendJoinServlet,",
            "    FederationV2SendJoinServlet,",
            "    FederationV1SendLeaveServlet,",
            "    FederationV2SendLeaveServlet,",
            "    FederationV1InviteServlet,",
            "    FederationV2InviteServlet,",
            "    FederationGetMissingEventsServlet,",
            "    FederationEventAuthServlet,",
            "    FederationClientKeysQueryServlet,",
            "    FederationUserDevicesQueryServlet,",
            "    FederationClientKeysClaimServlet,",
            "    FederationThirdPartyInviteExchangeServlet,",
            "    On3pidBindServlet,",
            "    FederationVersionServlet,",
            "    RoomComplexityServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "OPENID_SERVLET_CLASSES = (",
            "    OpenIdUserInfo,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "ROOM_LIST_CLASSES = (PublicRoomList,)  # type: Tuple[Type[PublicRoomList], ...]",
            "",
            "GROUP_SERVER_SERVLET_CLASSES = (",
            "    FederationGroupsProfileServlet,",
            "    FederationGroupsSummaryServlet,",
            "    FederationGroupsRoomsServlet,",
            "    FederationGroupsUsersServlet,",
            "    FederationGroupsInvitedUsersServlet,",
            "    FederationGroupsInviteServlet,",
            "    FederationGroupsAcceptInviteServlet,",
            "    FederationGroupsJoinServlet,",
            "    FederationGroupsRemoveUserServlet,",
            "    FederationGroupsSummaryRoomsServlet,",
            "    FederationGroupsCategoriesServlet,",
            "    FederationGroupsCategoryServlet,",
            "    FederationGroupsRolesServlet,",
            "    FederationGroupsRoleServlet,",
            "    FederationGroupsSummaryUsersServlet,",
            "    FederationGroupsAddRoomsServlet,",
            "    FederationGroupsAddRoomsConfigServlet,",
            "    FederationGroupsSettingJoinPolicyServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "",
            "GROUP_LOCAL_SERVLET_CLASSES = (",
            "    FederationGroupsLocalInviteServlet,",
            "    FederationGroupsRemoveLocalUserServlet,",
            "    FederationGroupsBulkPublicisedServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "",
            "GROUP_ATTESTATION_SERVLET_CLASSES = (",
            "    FederationGroupsRenewAttestaionServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "DEFAULT_SERVLET_GROUPS = (",
            "    \"federation\",",
            "    \"room_list\",",
            "    \"group_server\",",
            "    \"group_local\",",
            "    \"group_attestation\",",
            "    \"openid\",",
            ")",
            "",
            "",
            "def register_servlets(hs, resource, authenticator, ratelimiter, servlet_groups=None):",
            "    \"\"\"Initialize and register servlet classes.",
            "",
            "    Will by default register all servlets. For custom behaviour, pass in",
            "    a list of servlet_groups to register.",
            "",
            "    Args:",
            "        hs (synapse.server.HomeServer): homeserver",
            "        resource (JsonResource): resource class to register to",
            "        authenticator (Authenticator): authenticator to use",
            "        ratelimiter (util.ratelimitutils.FederationRateLimiter): ratelimiter to use",
            "        servlet_groups (list[str], optional): List of servlet groups to register.",
            "            Defaults to ``DEFAULT_SERVLET_GROUPS``.",
            "    \"\"\"",
            "    if not servlet_groups:",
            "        servlet_groups = DEFAULT_SERVLET_GROUPS",
            "",
            "    if \"federation\" in servlet_groups:",
            "        for servletclass in FEDERATION_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_federation_server(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"openid\" in servlet_groups:",
            "        for servletclass in OPENID_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_federation_server(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"room_list\" in servlet_groups:",
            "        for servletclass in ROOM_LIST_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_room_list_handler(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "                allow_access=hs.config.allow_public_rooms_over_federation,",
            "            ).register(resource)",
            "",
            "    if \"group_server\" in servlet_groups:",
            "        for servletclass in GROUP_SERVER_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_groups_server_handler(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"group_local\" in servlet_groups:",
            "        for servletclass in GROUP_LOCAL_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_groups_local_handler(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"group_attestation\" in servlet_groups:",
            "        for servletclass in GROUP_ATTESTATION_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_groups_attestation_renewer(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import functools",
            "import logging",
            "import re",
            "from typing import Optional, Tuple, Type",
            "",
            "import synapse",
            "from synapse.api.constants import MAX_GROUP_CATEGORYID_LENGTH, MAX_GROUP_ROLEID_LENGTH",
            "from synapse.api.errors import Codes, FederationDeniedError, SynapseError",
            "from synapse.api.room_versions import RoomVersions",
            "from synapse.api.urls import (",
            "    FEDERATION_UNSTABLE_PREFIX,",
            "    FEDERATION_V1_PREFIX,",
            "    FEDERATION_V2_PREFIX,",
            ")",
            "from synapse.http.server import JsonResource",
            "from synapse.http.servlet import (",
            "    parse_boolean_from_args,",
            "    parse_integer_from_args,",
            "    parse_json_object_from_request,",
            "    parse_string_from_args,",
            ")",
            "from synapse.logging.context import run_in_background",
            "from synapse.logging.opentracing import (",
            "    start_active_span,",
            "    start_active_span_from_request,",
            "    tags,",
            "    whitelisted_homeserver,",
            ")",
            "from synapse.server import HomeServer",
            "from synapse.types import ThirdPartyInstanceID, get_domain_from_id",
            "from synapse.util.stringutils import parse_and_validate_server_name",
            "from synapse.util.versionstring import get_version_string",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class TransportLayerServer(JsonResource):",
            "    \"\"\"Handles incoming federation HTTP requests\"\"\"",
            "",
            "    def __init__(self, hs, servlet_groups=None):",
            "        \"\"\"Initialize the TransportLayerServer",
            "",
            "        Will by default register all servlets. For custom behaviour, pass in",
            "        a list of servlet_groups to register.",
            "",
            "        Args:",
            "            hs (synapse.server.HomeServer): homeserver",
            "            servlet_groups (list[str], optional): List of servlet groups to register.",
            "                Defaults to ``DEFAULT_SERVLET_GROUPS``.",
            "        \"\"\"",
            "        self.hs = hs",
            "        self.clock = hs.get_clock()",
            "        self.servlet_groups = servlet_groups",
            "",
            "        super().__init__(hs, canonical_json=False)",
            "",
            "        self.authenticator = Authenticator(hs)",
            "        self.ratelimiter = hs.get_federation_ratelimiter()",
            "",
            "        self.register_servlets()",
            "",
            "    def register_servlets(self):",
            "        register_servlets(",
            "            self.hs,",
            "            resource=self,",
            "            ratelimiter=self.ratelimiter,",
            "            authenticator=self.authenticator,",
            "            servlet_groups=self.servlet_groups,",
            "        )",
            "",
            "",
            "class AuthenticationError(SynapseError):",
            "    \"\"\"There was a problem authenticating the request\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class NoAuthenticationError(AuthenticationError):",
            "    \"\"\"The request had no authentication information\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class Authenticator:",
            "    def __init__(self, hs: HomeServer):",
            "        self._clock = hs.get_clock()",
            "        self.keyring = hs.get_keyring()",
            "        self.server_name = hs.hostname",
            "        self.store = hs.get_datastore()",
            "        self.federation_domain_whitelist = hs.config.federation_domain_whitelist",
            "        self.notifier = hs.get_notifier()",
            "",
            "        self.replication_client = None",
            "        if hs.config.worker.worker_app:",
            "            self.replication_client = hs.get_tcp_replication()",
            "",
            "    # A method just so we can pass 'self' as the authenticator to the Servlets",
            "    async def authenticate_request(self, request, content):",
            "        now = self._clock.time_msec()",
            "        json_request = {",
            "            \"method\": request.method.decode(\"ascii\"),",
            "            \"uri\": request.uri.decode(\"ascii\"),",
            "            \"destination\": self.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(b\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(",
            "                401, \"Missing Authorization headers\", Codes.UNAUTHORIZED",
            "            )",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(b\"X-Matrix\"):",
            "                (origin, key, sig) = _parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if (",
            "            self.federation_domain_whitelist is not None",
            "            and origin not in self.federation_domain_whitelist",
            "        ):",
            "            raise FederationDeniedError(origin)",
            "",
            "        if origin is None or not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(",
            "                401, \"Missing Authorization headers\", Codes.UNAUTHORIZED",
            "            )",
            "",
            "        await self.keyring.verify_json_for_server(",
            "            origin, json_request, now, \"Incoming request\"",
            "        )",
            "",
            "        logger.debug(\"Request from %s\", origin)",
            "        request.requester = origin",
            "",
            "        # If we get a valid signed request from the other side, its probably",
            "        # alive",
            "        retry_timings = await self.store.get_destination_retry_timings(origin)",
            "        if retry_timings and retry_timings[\"retry_last_ts\"]:",
            "            run_in_background(self._reset_retry_timings, origin)",
            "",
            "        return origin",
            "",
            "    async def _reset_retry_timings(self, origin):",
            "        try:",
            "            logger.info(\"Marking origin %r as up\", origin)",
            "            await self.store.set_destination_retry_timings(origin, None, 0, 0)",
            "",
            "            # Inform the relevant places that the remote server is back up.",
            "            self.notifier.notify_remote_server_up(origin)",
            "            if self.replication_client:",
            "                # If we're on a worker we try and inform master about this. The",
            "                # replication client doesn't hook into the notifier to avoid",
            "                # infinite loops where we send a `REMOTE_SERVER_UP` command to",
            "                # master, which then echoes it back to us which in turn pokes",
            "                # the notifier.",
            "                self.replication_client.send_remote_server_up(origin)",
            "",
            "        except Exception:",
            "            logger.exception(\"Error resetting retry timings on %s\", origin)",
            "",
            "",
            "def _parse_auth_header(header_bytes):",
            "    \"\"\"Parse an X-Matrix auth header",
            "",
            "    Args:",
            "        header_bytes (bytes): header value",
            "",
            "    Returns:",
            "        Tuple[str, str, str]: origin, key id, signature.",
            "",
            "    Raises:",
            "        AuthenticationError if the header could not be parsed",
            "    \"\"\"",
            "    try:",
            "        header_str = header_bytes.decode(\"utf-8\")",
            "        params = header_str.split(\" \")[1].split(\",\")",
            "        param_dict = dict(kv.split(\"=\") for kv in params)",
            "",
            "        def strip_quotes(value):",
            "            if value.startswith('\"'):",
            "                return value[1:-1]",
            "            else:",
            "                return value",
            "",
            "        origin = strip_quotes(param_dict[\"origin\"])",
            "",
            "        # ensure that the origin is a valid server name",
            "        parse_and_validate_server_name(origin)",
            "",
            "        key = strip_quotes(param_dict[\"key\"])",
            "        sig = strip_quotes(param_dict[\"sig\"])",
            "        return origin, key, sig",
            "    except Exception as e:",
            "        logger.warning(",
            "            \"Error parsing auth header '%s': %s\",",
            "            header_bytes.decode(\"ascii\", \"replace\"),",
            "            e,",
            "        )",
            "        raise AuthenticationError(",
            "            400, \"Malformed Authorization header\", Codes.UNAUTHORIZED",
            "        )",
            "",
            "",
            "class BaseFederationServlet:",
            "    \"\"\"Abstract base class for federation servlet classes.",
            "",
            "    The servlet object should have a PATH attribute which takes the form of a regexp to",
            "    match against the request path (excluding the /federation/v1 prefix).",
            "",
            "    The servlet should also implement one or more of on_GET, on_POST, on_PUT, to match",
            "    the appropriate HTTP method. These methods must be *asynchronous* and have the",
            "    signature:",
            "",
            "        on_<METHOD>(self, origin, content, query, **kwargs)",
            "",
            "        With arguments:",
            "",
            "            origin (unicode|None): The authenticated server_name of the calling server,",
            "                unless REQUIRE_AUTH is set to False and authentication failed.",
            "",
            "            content (unicode|None): decoded json body of the request. None if the",
            "                request was a GET.",
            "",
            "            query (dict[bytes, list[bytes]]): Query params from the request. url-decoded",
            "                (ie, '+' and '%xx' are decoded) but note that it is *not* utf8-decoded",
            "                yet.",
            "",
            "            **kwargs (dict[unicode, unicode]): the dict mapping keys to path",
            "                components as specified in the path match regexp.",
            "",
            "        Returns:",
            "            Optional[Tuple[int, object]]: either (response code, response object) to",
            "                 return a JSON response, or None if the request has already been handled.",
            "",
            "        Raises:",
            "            SynapseError: to return an error code",
            "",
            "            Exception: other exceptions will be caught, logged, and a 500 will be",
            "                returned.",
            "    \"\"\"",
            "",
            "    PATH = \"\"  # Overridden in subclasses, the regex to match against the path.",
            "",
            "    REQUIRE_AUTH = True",
            "",
            "    PREFIX = FEDERATION_V1_PREFIX  # Allows specifying the API version",
            "",
            "    RATELIMIT = True  # Whether to rate limit requests or not",
            "",
            "    def __init__(self, handler, authenticator, ratelimiter, server_name):",
            "        self.handler = handler",
            "        self.authenticator = authenticator",
            "        self.ratelimiter = ratelimiter",
            "",
            "    def _wrap(self, func):",
            "        authenticator = self.authenticator",
            "        ratelimiter = self.ratelimiter",
            "",
            "        @functools.wraps(func)",
            "        async def new_func(request, *args, **kwargs):",
            "            \"\"\"A callback which can be passed to HttpServer.RegisterPaths",
            "",
            "            Args:",
            "                request (twisted.web.http.Request):",
            "                *args: unused?",
            "                **kwargs (dict[unicode, unicode]): the dict mapping keys to path",
            "                    components as specified in the path match regexp.",
            "",
            "            Returns:",
            "                Tuple[int, object]|None: (response code, response object) as returned by",
            "                    the callback method. None if the request has already been handled.",
            "            \"\"\"",
            "            content = None",
            "            if request.method in [b\"PUT\", b\"POST\"]:",
            "                # TODO: Handle other method types? other content types?",
            "                content = parse_json_object_from_request(request)",
            "",
            "            try:",
            "                origin = await authenticator.authenticate_request(request, content)",
            "            except NoAuthenticationError:",
            "                origin = None",
            "                if self.REQUIRE_AUTH:",
            "                    logger.warning(",
            "                        \"authenticate_request failed: missing authentication\"",
            "                    )",
            "                    raise",
            "            except Exception as e:",
            "                logger.warning(\"authenticate_request failed: %s\", e)",
            "                raise",
            "",
            "            request_tags = {",
            "                \"request_id\": request.get_request_id(),",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_SERVER,",
            "                tags.HTTP_METHOD: request.get_method(),",
            "                tags.HTTP_URL: request.get_redacted_uri(),",
            "                tags.PEER_HOST_IPV6: request.getClientIP(),",
            "                \"authenticated_entity\": origin,",
            "                \"servlet_name\": request.request_metrics.name,",
            "            }",
            "",
            "            # Only accept the span context if the origin is authenticated",
            "            # and whitelisted",
            "            if origin and whitelisted_homeserver(origin):",
            "                scope = start_active_span_from_request(",
            "                    request, \"incoming-federation-request\", tags=request_tags",
            "                )",
            "            else:",
            "                scope = start_active_span(",
            "                    \"incoming-federation-request\", tags=request_tags",
            "                )",
            "",
            "            with scope:",
            "                if origin and self.RATELIMIT:",
            "                    with ratelimiter.ratelimit(origin) as d:",
            "                        await d",
            "                        if request._disconnected:",
            "                            logger.warning(",
            "                                \"client disconnected before we started processing \"",
            "                                \"request\"",
            "                            )",
            "                            return -1, None",
            "                        response = await func(",
            "                            origin, content, request.args, *args, **kwargs",
            "                        )",
            "                else:",
            "                    response = await func(",
            "                        origin, content, request.args, *args, **kwargs",
            "                    )",
            "",
            "            return response",
            "",
            "        return new_func",
            "",
            "    def register(self, server):",
            "        pattern = re.compile(\"^\" + self.PREFIX + self.PATH + \"$\")",
            "",
            "        for method in (\"GET\", \"PUT\", \"POST\"):",
            "            code = getattr(self, \"on_%s\" % (method), None)",
            "            if code is None:",
            "                continue",
            "",
            "            server.register_paths(",
            "                method,",
            "                (pattern,),",
            "                self._wrap(code),",
            "                self.__class__.__name__,",
            "            )",
            "",
            "",
            "class FederationSendServlet(BaseFederationServlet):",
            "    PATH = \"/send/(?P<transaction_id>[^/]*)/?\"",
            "",
            "    # We ratelimit manually in the handler as we queue up the requests and we",
            "    # don't want to fill up the ratelimiter with blocked requests.",
            "    RATELIMIT = False",
            "",
            "    def __init__(self, handler, server_name, **kwargs):",
            "        super().__init__(handler, server_name=server_name, **kwargs)",
            "        self.server_name = server_name",
            "",
            "    # This is when someone is trying to send us a bunch of data.",
            "    async def on_PUT(self, origin, content, query, transaction_id):",
            "        \"\"\"Called on PUT /send/<transaction_id>/",
            "",
            "        Args:",
            "            request (twisted.web.http.Request): The HTTP request.",
            "            transaction_id (str): The transaction_id associated with this",
            "                request. This is *not* None.",
            "",
            "        Returns:",
            "            Tuple of `(code, response)`, where",
            "            `response` is a python dict to be converted into JSON that is",
            "            used as the response body.",
            "        \"\"\"",
            "        # Parse the request",
            "        try:",
            "            transaction_data = content",
            "",
            "            logger.debug(\"Decoded %s: %s\", transaction_id, str(transaction_data))",
            "",
            "            logger.info(",
            "                \"Received txn %s from %s. (PDUs: %d, EDUs: %d)\",",
            "                transaction_id,",
            "                origin,",
            "                len(transaction_data.get(\"pdus\", [])),",
            "                len(transaction_data.get(\"edus\", [])),",
            "            )",
            "",
            "            # We should ideally be getting this from the security layer.",
            "            # origin = body[\"origin\"]",
            "",
            "            # Add some extra data to the transaction dict that isn't included",
            "            # in the request body.",
            "            transaction_data.update(",
            "                transaction_id=transaction_id, destination=self.server_name",
            "            )",
            "",
            "        except Exception as e:",
            "            logger.exception(e)",
            "            return 400, {\"error\": \"Invalid transaction\"}",
            "",
            "        try:",
            "            code, response = await self.handler.on_incoming_transaction(",
            "                origin, transaction_data",
            "            )",
            "        except Exception:",
            "            logger.exception(\"on_incoming_transaction failed\")",
            "            raise",
            "",
            "        return code, response",
            "",
            "",
            "class FederationEventServlet(BaseFederationServlet):",
            "    PATH = \"/event/(?P<event_id>[^/]*)/?\"",
            "",
            "    # This is when someone asks for a data item for a given server data_id pair.",
            "    async def on_GET(self, origin, content, query, event_id):",
            "        return await self.handler.on_pdu_request(origin, event_id)",
            "",
            "",
            "class FederationStateV1Servlet(BaseFederationServlet):",
            "    PATH = \"/state/(?P<room_id>[^/]*)/?\"",
            "",
            "    # This is when someone asks for all data for a given room.",
            "    async def on_GET(self, origin, content, query, room_id):",
            "        return await self.handler.on_room_state_request(",
            "            origin,",
            "            room_id,",
            "            parse_string_from_args(query, \"event_id\", None, required=False),",
            "        )",
            "",
            "",
            "class FederationStateIdsServlet(BaseFederationServlet):",
            "    PATH = \"/state_ids/(?P<room_id>[^/]*)/?\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id):",
            "        return await self.handler.on_state_ids_request(",
            "            origin,",
            "            room_id,",
            "            parse_string_from_args(query, \"event_id\", None, required=True),",
            "        )",
            "",
            "",
            "class FederationBackfillServlet(BaseFederationServlet):",
            "    PATH = \"/backfill/(?P<room_id>[^/]*)/?\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id):",
            "        versions = [x.decode(\"ascii\") for x in query[b\"v\"]]",
            "        limit = parse_integer_from_args(query, \"limit\", None)",
            "",
            "        if not limit:",
            "            return 400, {\"error\": \"Did not include limit param\"}",
            "",
            "        return await self.handler.on_backfill_request(origin, room_id, versions, limit)",
            "",
            "",
            "class FederationQueryServlet(BaseFederationServlet):",
            "    PATH = \"/query/(?P<query_type>[^/]*)\"",
            "",
            "    # This is when we receive a server-server Query",
            "    async def on_GET(self, origin, content, query, query_type):",
            "        return await self.handler.on_query_request(",
            "            query_type,",
            "            {k.decode(\"utf8\"): v[0].decode(\"utf-8\") for k, v in query.items()},",
            "        )",
            "",
            "",
            "class FederationMakeJoinServlet(BaseFederationServlet):",
            "    PATH = \"/make_join/(?P<room_id>[^/]*)/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, _content, query, room_id, user_id):",
            "        \"\"\"",
            "        Args:",
            "            origin (unicode): The authenticated server_name of the calling server",
            "",
            "            _content (None): (GETs don't have bodies)",
            "",
            "            query (dict[bytes, list[bytes]]): Query params from the request.",
            "",
            "            **kwargs (dict[unicode, unicode]): the dict mapping keys to path",
            "                components as specified in the path match regexp.",
            "",
            "        Returns:",
            "            Tuple[int, object]: (response code, response object)",
            "        \"\"\"",
            "        versions = query.get(b\"ver\")",
            "        if versions is not None:",
            "            supported_versions = [v.decode(\"utf-8\") for v in versions]",
            "        else:",
            "            supported_versions = [\"1\"]",
            "",
            "        content = await self.handler.on_make_join_request(",
            "            origin, room_id, user_id, supported_versions=supported_versions",
            "        )",
            "        return 200, content",
            "",
            "",
            "class FederationMakeLeaveServlet(BaseFederationServlet):",
            "    PATH = \"/make_leave/(?P<room_id>[^/]*)/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id, user_id):",
            "        content = await self.handler.on_make_leave_request(origin, room_id, user_id)",
            "        return 200, content",
            "",
            "",
            "class FederationV1SendLeaveServlet(BaseFederationServlet):",
            "    PATH = \"/send_leave/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        content = await self.handler.on_send_leave_request(origin, content)",
            "        return 200, (200, content)",
            "",
            "",
            "class FederationV2SendLeaveServlet(BaseFederationServlet):",
            "    PATH = \"/send_leave/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    PREFIX = FEDERATION_V2_PREFIX",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        content = await self.handler.on_send_leave_request(origin, content)",
            "        return 200, content",
            "",
            "",
            "class FederationEventAuthServlet(BaseFederationServlet):",
            "    PATH = \"/event_auth/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, content, query, room_id, event_id):",
            "        return await self.handler.on_event_auth(origin, room_id, event_id)",
            "",
            "",
            "class FederationV1SendJoinServlet(BaseFederationServlet):",
            "    PATH = \"/send_join/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # TODO(paul): assert that room_id/event_id parsed from path actually",
            "        #   match those given in content",
            "        content = await self.handler.on_send_join_request(origin, content)",
            "        return 200, (200, content)",
            "",
            "",
            "class FederationV2SendJoinServlet(BaseFederationServlet):",
            "    PATH = \"/send_join/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    PREFIX = FEDERATION_V2_PREFIX",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # TODO(paul): assert that room_id/event_id parsed from path actually",
            "        #   match those given in content",
            "        content = await self.handler.on_send_join_request(origin, content)",
            "        return 200, content",
            "",
            "",
            "class FederationV1InviteServlet(BaseFederationServlet):",
            "    PATH = \"/invite/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # We don't get a room version, so we have to assume its EITHER v1 or",
            "        # v2. This is \"fine\" as the only difference between V1 and V2 is the",
            "        # state resolution algorithm, and we don't use that for processing",
            "        # invites",
            "        content = await self.handler.on_invite_request(",
            "            origin, content, room_version_id=RoomVersions.V1.identifier",
            "        )",
            "",
            "        # V1 federation API is defined to return a content of `[200, {...}]`",
            "        # due to a historical bug.",
            "        return 200, (200, content)",
            "",
            "",
            "class FederationV2InviteServlet(BaseFederationServlet):",
            "    PATH = \"/invite/(?P<room_id>[^/]*)/(?P<event_id>[^/]*)\"",
            "",
            "    PREFIX = FEDERATION_V2_PREFIX",
            "",
            "    async def on_PUT(self, origin, content, query, room_id, event_id):",
            "        # TODO(paul): assert that room_id/event_id parsed from path actually",
            "        #   match those given in content",
            "",
            "        room_version = content[\"room_version\"]",
            "        event = content[\"event\"]",
            "        invite_room_state = content[\"invite_room_state\"]",
            "",
            "        # Synapse expects invite_room_state to be in unsigned, as it is in v1",
            "        # API",
            "",
            "        event.setdefault(\"unsigned\", {})[\"invite_room_state\"] = invite_room_state",
            "",
            "        content = await self.handler.on_invite_request(",
            "            origin, event, room_version_id=room_version",
            "        )",
            "        return 200, content",
            "",
            "",
            "class FederationThirdPartyInviteExchangeServlet(BaseFederationServlet):",
            "    PATH = \"/exchange_third_party_invite/(?P<room_id>[^/]*)\"",
            "",
            "    async def on_PUT(self, origin, content, query, room_id):",
            "        content = await self.handler.on_exchange_third_party_invite_request(content)",
            "        return 200, content",
            "",
            "",
            "class FederationClientKeysQueryServlet(BaseFederationServlet):",
            "    PATH = \"/user/keys/query\"",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        return await self.handler.on_query_client_keys(origin, content)",
            "",
            "",
            "class FederationUserDevicesQueryServlet(BaseFederationServlet):",
            "    PATH = \"/user/devices/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_GET(self, origin, content, query, user_id):",
            "        return await self.handler.on_query_user_devices(origin, user_id)",
            "",
            "",
            "class FederationClientKeysClaimServlet(BaseFederationServlet):",
            "    PATH = \"/user/keys/claim\"",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        response = await self.handler.on_claim_client_keys(origin, content)",
            "        return 200, response",
            "",
            "",
            "class FederationGetMissingEventsServlet(BaseFederationServlet):",
            "    # TODO(paul): Why does this path alone end with \"/?\" optional?",
            "    PATH = \"/get_missing_events/(?P<room_id>[^/]*)/?\"",
            "",
            "    async def on_POST(self, origin, content, query, room_id):",
            "        limit = int(content.get(\"limit\", 10))",
            "        earliest_events = content.get(\"earliest_events\", [])",
            "        latest_events = content.get(\"latest_events\", [])",
            "",
            "        content = await self.handler.on_get_missing_events(",
            "            origin,",
            "            room_id=room_id,",
            "            earliest_events=earliest_events,",
            "            latest_events=latest_events,",
            "            limit=limit,",
            "        )",
            "",
            "        return 200, content",
            "",
            "",
            "class On3pidBindServlet(BaseFederationServlet):",
            "    PATH = \"/3pid/onbind\"",
            "",
            "    REQUIRE_AUTH = False",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        if \"invites\" in content:",
            "            last_exception = None",
            "            for invite in content[\"invites\"]:",
            "                try:",
            "                    if \"signed\" not in invite or \"token\" not in invite[\"signed\"]:",
            "                        message = (",
            "                            \"Rejecting received notification of third-\"",
            "                            \"party invite without signed: %s\" % (invite,)",
            "                        )",
            "                        logger.info(message)",
            "                        raise SynapseError(400, message)",
            "                    await self.handler.exchange_third_party_invite(",
            "                        invite[\"sender\"],",
            "                        invite[\"mxid\"],",
            "                        invite[\"room_id\"],",
            "                        invite[\"signed\"],",
            "                    )",
            "                except Exception as e:",
            "                    last_exception = e",
            "            if last_exception:",
            "                raise last_exception",
            "        return 200, {}",
            "",
            "",
            "class OpenIdUserInfo(BaseFederationServlet):",
            "    \"\"\"",
            "    Exchange a bearer token for information about a user.",
            "",
            "    The response format should be compatible with:",
            "        http://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse",
            "",
            "    GET /openid/userinfo?access_token=ABDEFGH HTTP/1.1",
            "",
            "    HTTP/1.1 200 OK",
            "    Content-Type: application/json",
            "",
            "    {",
            "        \"sub\": \"@userpart:example.org\",",
            "    }",
            "    \"\"\"",
            "",
            "    PATH = \"/openid/userinfo\"",
            "",
            "    REQUIRE_AUTH = False",
            "",
            "    async def on_GET(self, origin, content, query):",
            "        token = query.get(b\"access_token\", [None])[0]",
            "        if token is None:",
            "            return (",
            "                401,",
            "                {\"errcode\": \"M_MISSING_TOKEN\", \"error\": \"Access Token required\"},",
            "            )",
            "",
            "        user_id = await self.handler.on_openid_userinfo(token.decode(\"ascii\"))",
            "",
            "        if user_id is None:",
            "            return (",
            "                401,",
            "                {",
            "                    \"errcode\": \"M_UNKNOWN_TOKEN\",",
            "                    \"error\": \"Access Token unknown or expired\",",
            "                },",
            "            )",
            "",
            "        return 200, {\"sub\": user_id}",
            "",
            "",
            "class PublicRoomList(BaseFederationServlet):",
            "    \"\"\"",
            "    Fetch the public room list for this server.",
            "",
            "    This API returns information in the same format as /publicRooms on the",
            "    client API, but will only ever include local public rooms and hence is",
            "    intended for consumption by other homeservers.",
            "",
            "    GET /publicRooms HTTP/1.1",
            "",
            "    HTTP/1.1 200 OK",
            "    Content-Type: application/json",
            "",
            "    {",
            "        \"chunk\": [",
            "            {",
            "                \"aliases\": [",
            "                    \"#test:localhost\"",
            "                ],",
            "                \"guest_can_join\": false,",
            "                \"name\": \"test room\",",
            "                \"num_joined_members\": 3,",
            "                \"room_id\": \"!whkydVegtvatLfXmPN:localhost\",",
            "                \"world_readable\": false",
            "            }",
            "        ],",
            "        \"end\": \"END\",",
            "        \"start\": \"START\"",
            "    }",
            "    \"\"\"",
            "",
            "    PATH = \"/publicRooms\"",
            "",
            "    def __init__(self, handler, authenticator, ratelimiter, server_name, allow_access):",
            "        super().__init__(handler, authenticator, ratelimiter, server_name)",
            "        self.allow_access = allow_access",
            "",
            "    async def on_GET(self, origin, content, query):",
            "        if not self.allow_access:",
            "            raise FederationDeniedError(origin)",
            "",
            "        limit = parse_integer_from_args(query, \"limit\", 0)",
            "        since_token = parse_string_from_args(query, \"since\", None)",
            "        include_all_networks = parse_boolean_from_args(",
            "            query, \"include_all_networks\", False",
            "        )",
            "        third_party_instance_id = parse_string_from_args(",
            "            query, \"third_party_instance_id\", None",
            "        )",
            "",
            "        if include_all_networks:",
            "            network_tuple = None",
            "        elif third_party_instance_id:",
            "            network_tuple = ThirdPartyInstanceID.from_string(third_party_instance_id)",
            "        else:",
            "            network_tuple = ThirdPartyInstanceID(None, None)",
            "",
            "        if limit == 0:",
            "            # zero is a special value which corresponds to no limit.",
            "            limit = None",
            "",
            "        data = await self.handler.get_local_public_room_list(",
            "            limit, since_token, network_tuple=network_tuple, from_federation=True",
            "        )",
            "        return 200, data",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        # This implements MSC2197 (Search Filtering over Federation)",
            "        if not self.allow_access:",
            "            raise FederationDeniedError(origin)",
            "",
            "        limit = int(content.get(\"limit\", 100))  # type: Optional[int]",
            "        since_token = content.get(\"since\", None)",
            "        search_filter = content.get(\"filter\", None)",
            "",
            "        include_all_networks = content.get(\"include_all_networks\", False)",
            "        third_party_instance_id = content.get(\"third_party_instance_id\", None)",
            "",
            "        if include_all_networks:",
            "            network_tuple = None",
            "            if third_party_instance_id is not None:",
            "                raise SynapseError(",
            "                    400, \"Can't use include_all_networks with an explicit network\"",
            "                )",
            "        elif third_party_instance_id is None:",
            "            network_tuple = ThirdPartyInstanceID(None, None)",
            "        else:",
            "            network_tuple = ThirdPartyInstanceID.from_string(third_party_instance_id)",
            "",
            "        if search_filter is None:",
            "            logger.warning(\"Nonefilter\")",
            "",
            "        if limit == 0:",
            "            # zero is a special value which corresponds to no limit.",
            "            limit = None",
            "",
            "        data = await self.handler.get_local_public_room_list(",
            "            limit=limit,",
            "            since_token=since_token,",
            "            search_filter=search_filter,",
            "            network_tuple=network_tuple,",
            "            from_federation=True,",
            "        )",
            "",
            "        return 200, data",
            "",
            "",
            "class FederationVersionServlet(BaseFederationServlet):",
            "    PATH = \"/version\"",
            "",
            "    REQUIRE_AUTH = False",
            "",
            "    async def on_GET(self, origin, content, query):",
            "        return (",
            "            200,",
            "            {\"server\": {\"name\": \"Synapse\", \"version\": get_version_string(synapse)}},",
            "        )",
            "",
            "",
            "class FederationGroupsProfileServlet(BaseFederationServlet):",
            "    \"\"\"Get/set the basic profile of a group on behalf of a user\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/profile\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_group_profile(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "    async def on_POST(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.update_group_profile(",
            "            group_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsSummaryServlet(BaseFederationServlet):",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/summary\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_group_summary(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRoomsServlet(BaseFederationServlet):",
            "    \"\"\"Get the rooms in a group on behalf of a user\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/rooms\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_rooms_in_group(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsAddRoomsServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove room from group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/room/(?P<room_id>[^/]*)\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.add_room_to_group(",
            "            group_id, requester_user_id, room_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.remove_room_from_group(",
            "            group_id, requester_user_id, room_id",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsAddRoomsConfigServlet(BaseFederationServlet):",
            "    \"\"\"Update room config in group\"\"\"",
            "",
            "    PATH = (",
            "        \"/groups/(?P<group_id>[^/]*)/room/(?P<room_id>[^/]*)\"",
            "        \"/config/(?P<config_key>[^/]*)\"",
            "    )",
            "",
            "    async def on_POST(self, origin, content, query, group_id, room_id, config_key):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        result = await self.handler.update_room_in_group(",
            "            group_id, requester_user_id, room_id, config_key, content",
            "        )",
            "",
            "        return 200, result",
            "",
            "",
            "class FederationGroupsUsersServlet(BaseFederationServlet):",
            "    \"\"\"Get the users in a group on behalf of a user\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_users_in_group(group_id, requester_user_id)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsInvitedUsersServlet(BaseFederationServlet):",
            "    \"\"\"Get the users that have been invited to a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/invited_users\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.get_invited_users_in_group(",
            "            group_id, requester_user_id",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsInviteServlet(BaseFederationServlet):",
            "    \"\"\"Ask a group server to invite someone to the group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/invite\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.invite_to_group(",
            "            group_id, user_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsAcceptInviteServlet(BaseFederationServlet):",
            "    \"\"\"Accept an invitation from the group server\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/accept_invite\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(user_id) != origin:",
            "            raise SynapseError(403, \"user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.accept_invite(group_id, user_id, content)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsJoinServlet(BaseFederationServlet):",
            "    \"\"\"Attempt to join a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/join\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(user_id) != origin:",
            "            raise SynapseError(403, \"user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.join_group(group_id, user_id, content)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRemoveUserServlet(BaseFederationServlet):",
            "    \"\"\"Leave or kick a user from the group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/remove\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.remove_user_from_group(",
            "            group_id, user_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsLocalInviteServlet(BaseFederationServlet):",
            "    \"\"\"A group server has invited a local user\"\"\"",
            "",
            "    PATH = \"/groups/local/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/invite\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(group_id) != origin:",
            "            raise SynapseError(403, \"group_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.on_invite(group_id, user_id, content)",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRemoveLocalUserServlet(BaseFederationServlet):",
            "    \"\"\"A group server has removed a local user\"\"\"",
            "",
            "    PATH = \"/groups/local/(?P<group_id>[^/]*)/users/(?P<user_id>[^/]*)/remove\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        if get_domain_from_id(group_id) != origin:",
            "            raise SynapseError(403, \"user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.user_removed_from_group(",
            "            group_id, user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsRenewAttestaionServlet(BaseFederationServlet):",
            "    \"\"\"A group or user's server renews their attestation\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/renew_attestation/(?P<user_id>[^/]*)\"",
            "",
            "    async def on_POST(self, origin, content, query, group_id, user_id):",
            "        # We don't need to check auth here as we check the attestation signatures",
            "",
            "        new_content = await self.handler.on_renew_attestation(",
            "            group_id, user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class FederationGroupsSummaryRoomsServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove a room from the group summary, with optional category.",
            "",
            "    Matches both:",
            "        - /groups/:group/summary/rooms/:room_id",
            "        - /groups/:group/summary/categories/:category/rooms/:room_id",
            "    \"\"\"",
            "",
            "    PATH = (",
            "        \"/groups/(?P<group_id>[^/]*)/summary\"",
            "        \"(/categories/(?P<category_id>[^/]+))?\"",
            "        \"/rooms/(?P<room_id>[^/]*)\"",
            "    )",
            "",
            "    async def on_POST(self, origin, content, query, group_id, category_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(",
            "                400, \"category_id cannot be empty string\", Codes.INVALID_PARAM",
            "            )",
            "",
            "        if len(category_id) > MAX_GROUP_CATEGORYID_LENGTH:",
            "            raise SynapseError(",
            "                400,",
            "                \"category_id may not be longer than %s characters\"",
            "                % (MAX_GROUP_CATEGORYID_LENGTH,),",
            "                Codes.INVALID_PARAM,",
            "            )",
            "",
            "        resp = await self.handler.update_group_summary_room(",
            "            group_id,",
            "            requester_user_id,",
            "            room_id=room_id,",
            "            category_id=category_id,",
            "            content=content,",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, category_id, room_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(400, \"category_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_summary_room(",
            "            group_id, requester_user_id, room_id=room_id, category_id=category_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsCategoriesServlet(BaseFederationServlet):",
            "    \"\"\"Get all categories for a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/categories/?\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_categories(group_id, requester_user_id)",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsCategoryServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove/get a category in a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/categories/(?P<category_id>[^/]+)\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id, category_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_category(",
            "            group_id, requester_user_id, category_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_POST(self, origin, content, query, group_id, category_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(400, \"category_id cannot be empty string\")",
            "",
            "        if len(category_id) > MAX_GROUP_CATEGORYID_LENGTH:",
            "            raise SynapseError(",
            "                400,",
            "                \"category_id may not be longer than %s characters\"",
            "                % (MAX_GROUP_CATEGORYID_LENGTH,),",
            "                Codes.INVALID_PARAM,",
            "            )",
            "",
            "        resp = await self.handler.upsert_group_category(",
            "            group_id, requester_user_id, category_id, content",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, category_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if category_id == \"\":",
            "            raise SynapseError(400, \"category_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_category(",
            "            group_id, requester_user_id, category_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsRolesServlet(BaseFederationServlet):",
            "    \"\"\"Get roles in a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/roles/?\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_roles(group_id, requester_user_id)",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsRoleServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove/get a role in a group\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/roles/(?P<role_id>[^/]+)\"",
            "",
            "    async def on_GET(self, origin, content, query, group_id, role_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        resp = await self.handler.get_group_role(group_id, requester_user_id, role_id)",
            "",
            "        return 200, resp",
            "",
            "    async def on_POST(self, origin, content, query, group_id, role_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(",
            "                400, \"role_id cannot be empty string\", Codes.INVALID_PARAM",
            "            )",
            "",
            "        if len(role_id) > MAX_GROUP_ROLEID_LENGTH:",
            "            raise SynapseError(",
            "                400,",
            "                \"role_id may not be longer than %s characters\"",
            "                % (MAX_GROUP_ROLEID_LENGTH,),",
            "                Codes.INVALID_PARAM,",
            "            )",
            "",
            "        resp = await self.handler.update_group_role(",
            "            group_id, requester_user_id, role_id, content",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, role_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(400, \"role_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_role(",
            "            group_id, requester_user_id, role_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsSummaryUsersServlet(BaseFederationServlet):",
            "    \"\"\"Add/remove a user from the group summary, with optional role.",
            "",
            "    Matches both:",
            "        - /groups/:group/summary/users/:user_id",
            "        - /groups/:group/summary/roles/:role/users/:user_id",
            "    \"\"\"",
            "",
            "    PATH = (",
            "        \"/groups/(?P<group_id>[^/]*)/summary\"",
            "        \"(/roles/(?P<role_id>[^/]+))?\"",
            "        \"/users/(?P<user_id>[^/]*)\"",
            "    )",
            "",
            "    async def on_POST(self, origin, content, query, group_id, role_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(400, \"role_id cannot be empty string\")",
            "",
            "        if len(role_id) > MAX_GROUP_ROLEID_LENGTH:",
            "            raise SynapseError(",
            "                400,",
            "                \"role_id may not be longer than %s characters\"",
            "                % (MAX_GROUP_ROLEID_LENGTH,),",
            "                Codes.INVALID_PARAM,",
            "            )",
            "",
            "        resp = await self.handler.update_group_summary_user(",
            "            group_id,",
            "            requester_user_id,",
            "            user_id=user_id,",
            "            role_id=role_id,",
            "            content=content,",
            "        )",
            "",
            "        return 200, resp",
            "",
            "    async def on_DELETE(self, origin, content, query, group_id, role_id, user_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        if role_id == \"\":",
            "            raise SynapseError(400, \"role_id cannot be empty string\")",
            "",
            "        resp = await self.handler.delete_group_summary_user(",
            "            group_id, requester_user_id, user_id=user_id, role_id=role_id",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsBulkPublicisedServlet(BaseFederationServlet):",
            "    \"\"\"Get roles in a group\"\"\"",
            "",
            "    PATH = \"/get_groups_publicised\"",
            "",
            "    async def on_POST(self, origin, content, query):",
            "        resp = await self.handler.bulk_get_publicised_groups(",
            "            content[\"user_ids\"], proxy=False",
            "        )",
            "",
            "        return 200, resp",
            "",
            "",
            "class FederationGroupsSettingJoinPolicyServlet(BaseFederationServlet):",
            "    \"\"\"Sets whether a group is joinable without an invite or knock\"\"\"",
            "",
            "    PATH = \"/groups/(?P<group_id>[^/]*)/settings/m.join_policy\"",
            "",
            "    async def on_PUT(self, origin, content, query, group_id):",
            "        requester_user_id = parse_string_from_args(query, \"requester_user_id\")",
            "        if get_domain_from_id(requester_user_id) != origin:",
            "            raise SynapseError(403, \"requester_user_id doesn't match origin\")",
            "",
            "        new_content = await self.handler.set_group_join_policy(",
            "            group_id, requester_user_id, content",
            "        )",
            "",
            "        return 200, new_content",
            "",
            "",
            "class RoomComplexityServlet(BaseFederationServlet):",
            "    \"\"\"",
            "    Indicates to other servers how complex (and therefore likely",
            "    resource-intensive) a public room this server knows about is.",
            "    \"\"\"",
            "",
            "    PATH = \"/rooms/(?P<room_id>[^/]*)/complexity\"",
            "    PREFIX = FEDERATION_UNSTABLE_PREFIX",
            "",
            "    async def on_GET(self, origin, content, query, room_id):",
            "",
            "        store = self.handler.hs.get_datastore()",
            "",
            "        is_public = await store.is_room_world_readable_or_publicly_joinable(room_id)",
            "",
            "        if not is_public:",
            "            raise SynapseError(404, \"Room not found\", errcode=Codes.INVALID_PARAM)",
            "",
            "        complexity = await store.get_room_complexity(room_id)",
            "        return 200, complexity",
            "",
            "",
            "FEDERATION_SERVLET_CLASSES = (",
            "    FederationSendServlet,",
            "    FederationEventServlet,",
            "    FederationStateV1Servlet,",
            "    FederationStateIdsServlet,",
            "    FederationBackfillServlet,",
            "    FederationQueryServlet,",
            "    FederationMakeJoinServlet,",
            "    FederationMakeLeaveServlet,",
            "    FederationEventServlet,",
            "    FederationV1SendJoinServlet,",
            "    FederationV2SendJoinServlet,",
            "    FederationV1SendLeaveServlet,",
            "    FederationV2SendLeaveServlet,",
            "    FederationV1InviteServlet,",
            "    FederationV2InviteServlet,",
            "    FederationGetMissingEventsServlet,",
            "    FederationEventAuthServlet,",
            "    FederationClientKeysQueryServlet,",
            "    FederationUserDevicesQueryServlet,",
            "    FederationClientKeysClaimServlet,",
            "    FederationThirdPartyInviteExchangeServlet,",
            "    On3pidBindServlet,",
            "    FederationVersionServlet,",
            "    RoomComplexityServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "OPENID_SERVLET_CLASSES = (",
            "    OpenIdUserInfo,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "ROOM_LIST_CLASSES = (PublicRoomList,)  # type: Tuple[Type[PublicRoomList], ...]",
            "",
            "GROUP_SERVER_SERVLET_CLASSES = (",
            "    FederationGroupsProfileServlet,",
            "    FederationGroupsSummaryServlet,",
            "    FederationGroupsRoomsServlet,",
            "    FederationGroupsUsersServlet,",
            "    FederationGroupsInvitedUsersServlet,",
            "    FederationGroupsInviteServlet,",
            "    FederationGroupsAcceptInviteServlet,",
            "    FederationGroupsJoinServlet,",
            "    FederationGroupsRemoveUserServlet,",
            "    FederationGroupsSummaryRoomsServlet,",
            "    FederationGroupsCategoriesServlet,",
            "    FederationGroupsCategoryServlet,",
            "    FederationGroupsRolesServlet,",
            "    FederationGroupsRoleServlet,",
            "    FederationGroupsSummaryUsersServlet,",
            "    FederationGroupsAddRoomsServlet,",
            "    FederationGroupsAddRoomsConfigServlet,",
            "    FederationGroupsSettingJoinPolicyServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "",
            "GROUP_LOCAL_SERVLET_CLASSES = (",
            "    FederationGroupsLocalInviteServlet,",
            "    FederationGroupsRemoveLocalUserServlet,",
            "    FederationGroupsBulkPublicisedServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "",
            "GROUP_ATTESTATION_SERVLET_CLASSES = (",
            "    FederationGroupsRenewAttestaionServlet,",
            ")  # type: Tuple[Type[BaseFederationServlet], ...]",
            "",
            "DEFAULT_SERVLET_GROUPS = (",
            "    \"federation\",",
            "    \"room_list\",",
            "    \"group_server\",",
            "    \"group_local\",",
            "    \"group_attestation\",",
            "    \"openid\",",
            ")",
            "",
            "",
            "def register_servlets(hs, resource, authenticator, ratelimiter, servlet_groups=None):",
            "    \"\"\"Initialize and register servlet classes.",
            "",
            "    Will by default register all servlets. For custom behaviour, pass in",
            "    a list of servlet_groups to register.",
            "",
            "    Args:",
            "        hs (synapse.server.HomeServer): homeserver",
            "        resource (JsonResource): resource class to register to",
            "        authenticator (Authenticator): authenticator to use",
            "        ratelimiter (util.ratelimitutils.FederationRateLimiter): ratelimiter to use",
            "        servlet_groups (list[str], optional): List of servlet groups to register.",
            "            Defaults to ``DEFAULT_SERVLET_GROUPS``.",
            "    \"\"\"",
            "    if not servlet_groups:",
            "        servlet_groups = DEFAULT_SERVLET_GROUPS",
            "",
            "    if \"federation\" in servlet_groups:",
            "        for servletclass in FEDERATION_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_federation_server(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"openid\" in servlet_groups:",
            "        for servletclass in OPENID_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_federation_server(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"room_list\" in servlet_groups:",
            "        for servletclass in ROOM_LIST_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_room_list_handler(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "                allow_access=hs.config.allow_public_rooms_over_federation,",
            "            ).register(resource)",
            "",
            "    if \"group_server\" in servlet_groups:",
            "        for servletclass in GROUP_SERVER_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_groups_server_handler(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"group_local\" in servlet_groups:",
            "        for servletclass in GROUP_LOCAL_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_groups_local_handler(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)",
            "",
            "    if \"group_attestation\" in servlet_groups:",
            "        for servletclass in GROUP_ATTESTATION_SERVLET_CLASSES:",
            "            servletclass(",
            "                handler=hs.get_groups_attestation_renewer(),",
            "                authenticator=authenticator,",
            "                ratelimiter=ratelimiter,",
            "                server_name=hs.hostname,",
            "            ).register(resource)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1121": [
                "FederationGroupsSummaryRoomsServlet"
            ],
            "1243": [
                "FederationGroupsRoleServlet"
            ]
        },
        "addLocation": []
    },
    "synapse/groups/attestations.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " import random"
            },
            "3": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Tuple"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+from typing import TYPE_CHECKING, Optional, Tuple"
            },
            "5": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " from signedjson.sign import sign_json"
            },
            "7": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " from synapse.api.errors import HttpResponseException, RequestSendFailed, SynapseError"
            },
            "9": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " from synapse.metrics.background_process_metrics import run_as_background_process"
            },
            "10": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from synapse.types import get_domain_from_id"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+from synapse.types import JsonDict, get_domain_from_id"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+if TYPE_CHECKING:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    from synapse.app.homeserver import HomeServer"
            },
            "15": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "17": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " class GroupAttestationSigning:"
            },
            "19": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     \"\"\"Creates and verifies group attestations.\"\"\""
            },
            "20": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, hs):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    def __init__(self, hs: \"HomeServer\"):"
            },
            "23": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         self.keyring = hs.get_keyring()"
            },
            "24": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         self.clock = hs.get_clock()"
            },
            "25": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         self.server_name = hs.hostname"
            },
            "26": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         self.signing_key = hs.signing_key"
            },
            "27": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     async def verify_attestation("
            },
            "29": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self, attestation, group_id, user_id, server_name=None"
            },
            "30": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        self,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        attestation: JsonDict,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        group_id: str,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        user_id: str,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        server_name: Optional[str] = None,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    ) -> None:"
            },
            "37": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         \"\"\"Verifies that the given attestation matches the given parameters."
            },
            "38": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         An optional server_name can be supplied to explicitly set which server's"
            },
            "40": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         if valid_until_ms < now:"
            },
            "41": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             raise SynapseError(400, \"Attestation expired\")"
            },
            "42": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        assert server_name is not None"
            },
            "44": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         await self.keyring.verify_json_for_server("
            },
            "45": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "             server_name, attestation, now, \"Group attestation\""
            },
            "46": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         )"
            },
            "47": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def create_attestation(self, group_id, user_id):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    def create_attestation(self, group_id: str, user_id: str) -> JsonDict:"
            },
            "50": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         \"\"\"Create an attestation for the group_id and user_id with default"
            },
            "51": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         validity length."
            },
            "52": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         \"\"\""
            },
            "53": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validity_period = DEFAULT_ATTESTATION_LENGTH_MS"
            },
            "54": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validity_period *= random.uniform(*DEFAULT_ATTESTATION_JITTER)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        validity_period = DEFAULT_ATTESTATION_LENGTH_MS * random.uniform("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            *DEFAULT_ATTESTATION_JITTER"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        )"
            },
            "58": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         valid_until_ms = int(self.clock.time_msec() + validity_period)"
            },
            "59": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         return sign_json("
            },
            "61": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " class GroupAttestionRenewer:"
            },
            "62": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     \"\"\"Responsible for sending and receiving attestation updates.\"\"\""
            },
            "63": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, hs):"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    def __init__(self, hs: \"HomeServer\"):"
            },
            "66": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         self.clock = hs.get_clock()"
            },
            "67": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         self.store = hs.get_datastore()"
            },
            "68": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         self.assestations = hs.get_groups_attestation_signing()"
            },
            "69": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "                 self._start_renew_attestations, 30 * 60 * 1000"
            },
            "70": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "             )"
            },
            "71": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    async def on_renew_attestation(self, group_id, user_id, content):"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    async def on_renew_attestation("
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        self, group_id: str, user_id: str, content: JsonDict"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+    ) -> JsonDict:"
            },
            "76": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         \"\"\"When a remote updates an attestation\"\"\""
            },
            "77": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         attestation = content[\"attestation\"]"
            },
            "78": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         return {}"
            },
            "81": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "82": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _start_renew_attestations(self):"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    def _start_renew_attestations(self) -> None:"
            },
            "84": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         return run_as_background_process(\"renew_attestations\", self._renew_attestations)"
            },
            "85": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    async def _renew_attestations(self):"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+    async def _renew_attestations(self) -> None:"
            },
            "88": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         \"\"\"Called periodically to check if we need to update any of our attestations\"\"\""
            },
            "89": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "90": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         now = self.clock.time_msec()"
            },
            "91": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "             now + UPDATE_ATTESTATION_TIME_MS"
            },
            "92": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         )"
            },
            "93": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "94": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        async def _renew_attestation(group_user: Tuple[str, str]):"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        async def _renew_attestation(group_user: Tuple[str, str]) -> None:"
            },
            "96": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             group_id, user_id = group_user"
            },
            "97": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "             try:"
            },
            "98": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "                 if not self.is_mine_id(group_id):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2017 Vector Creations Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"Attestations ensure that users and groups can't lie about their memberships.",
            "",
            "When a user joins a group the HS and GS swap attestations, which allow them",
            "both to independently prove to third parties their membership.These",
            "attestations have a validity period so need to be periodically renewed.",
            "",
            "If a user leaves (or gets kicked out of) a group, either side can still use",
            "their attestation to \"prove\" their membership, until the attestation expires.",
            "Therefore attestations shouldn't be relied on to prove membership in important",
            "cases, but can for less important situations, e.g. showing a users membership",
            "of groups on their profile, showing flairs, etc.",
            "",
            "An attestation is a signed blob of json that looks like:",
            "",
            "    {",
            "        \"user_id\": \"@foo:a.example.com\",",
            "        \"group_id\": \"+bar:b.example.com\",",
            "        \"valid_until_ms\": 1507994728530,",
            "        \"signatures\":{\"matrix.org\":{\"ed25519:auto\":\"...\"}}",
            "    }",
            "\"\"\"",
            "",
            "import logging",
            "import random",
            "from typing import Tuple",
            "",
            "from signedjson.sign import sign_json",
            "",
            "from synapse.api.errors import HttpResponseException, RequestSendFailed, SynapseError",
            "from synapse.metrics.background_process_metrics import run_as_background_process",
            "from synapse.types import get_domain_from_id",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# Default validity duration for new attestations we create",
            "DEFAULT_ATTESTATION_LENGTH_MS = 3 * 24 * 60 * 60 * 1000",
            "",
            "# We add some jitter to the validity duration of attestations so that if we",
            "# add lots of users at once we don't need to renew them all at once.",
            "# The jitter is a multiplier picked randomly between the first and second number",
            "DEFAULT_ATTESTATION_JITTER = (0.9, 1.3)",
            "",
            "# Start trying to update our attestations when they come this close to expiring",
            "UPDATE_ATTESTATION_TIME_MS = 1 * 24 * 60 * 60 * 1000",
            "",
            "",
            "class GroupAttestationSigning:",
            "    \"\"\"Creates and verifies group attestations.\"\"\"",
            "",
            "    def __init__(self, hs):",
            "        self.keyring = hs.get_keyring()",
            "        self.clock = hs.get_clock()",
            "        self.server_name = hs.hostname",
            "        self.signing_key = hs.signing_key",
            "",
            "    async def verify_attestation(",
            "        self, attestation, group_id, user_id, server_name=None",
            "    ):",
            "        \"\"\"Verifies that the given attestation matches the given parameters.",
            "",
            "        An optional server_name can be supplied to explicitly set which server's",
            "        signature is expected. Otherwise assumes that either the group_id or user_id",
            "        is local and uses the other's server as the one to check.",
            "        \"\"\"",
            "",
            "        if not server_name:",
            "            if get_domain_from_id(group_id) == self.server_name:",
            "                server_name = get_domain_from_id(user_id)",
            "            elif get_domain_from_id(user_id) == self.server_name:",
            "                server_name = get_domain_from_id(group_id)",
            "            else:",
            "                raise Exception(\"Expected either group_id or user_id to be local\")",
            "",
            "        if user_id != attestation[\"user_id\"]:",
            "            raise SynapseError(400, \"Attestation has incorrect user_id\")",
            "",
            "        if group_id != attestation[\"group_id\"]:",
            "            raise SynapseError(400, \"Attestation has incorrect group_id\")",
            "        valid_until_ms = attestation[\"valid_until_ms\"]",
            "",
            "        # TODO: We also want to check that *new* attestations that people give",
            "        # us to store are valid for at least a little while.",
            "        now = self.clock.time_msec()",
            "        if valid_until_ms < now:",
            "            raise SynapseError(400, \"Attestation expired\")",
            "",
            "        await self.keyring.verify_json_for_server(",
            "            server_name, attestation, now, \"Group attestation\"",
            "        )",
            "",
            "    def create_attestation(self, group_id, user_id):",
            "        \"\"\"Create an attestation for the group_id and user_id with default",
            "        validity length.",
            "        \"\"\"",
            "        validity_period = DEFAULT_ATTESTATION_LENGTH_MS",
            "        validity_period *= random.uniform(*DEFAULT_ATTESTATION_JITTER)",
            "        valid_until_ms = int(self.clock.time_msec() + validity_period)",
            "",
            "        return sign_json(",
            "            {",
            "                \"group_id\": group_id,",
            "                \"user_id\": user_id,",
            "                \"valid_until_ms\": valid_until_ms,",
            "            },",
            "            self.server_name,",
            "            self.signing_key,",
            "        )",
            "",
            "",
            "class GroupAttestionRenewer:",
            "    \"\"\"Responsible for sending and receiving attestation updates.\"\"\"",
            "",
            "    def __init__(self, hs):",
            "        self.clock = hs.get_clock()",
            "        self.store = hs.get_datastore()",
            "        self.assestations = hs.get_groups_attestation_signing()",
            "        self.transport_client = hs.get_federation_transport_client()",
            "        self.is_mine_id = hs.is_mine_id",
            "        self.attestations = hs.get_groups_attestation_signing()",
            "",
            "        if not hs.config.worker_app:",
            "            self._renew_attestations_loop = self.clock.looping_call(",
            "                self._start_renew_attestations, 30 * 60 * 1000",
            "            )",
            "",
            "    async def on_renew_attestation(self, group_id, user_id, content):",
            "        \"\"\"When a remote updates an attestation\"\"\"",
            "        attestation = content[\"attestation\"]",
            "",
            "        if not self.is_mine_id(group_id) and not self.is_mine_id(user_id):",
            "            raise SynapseError(400, \"Neither user not group are on this server\")",
            "",
            "        await self.attestations.verify_attestation(",
            "            attestation, user_id=user_id, group_id=group_id",
            "        )",
            "",
            "        await self.store.update_remote_attestion(group_id, user_id, attestation)",
            "",
            "        return {}",
            "",
            "    def _start_renew_attestations(self):",
            "        return run_as_background_process(\"renew_attestations\", self._renew_attestations)",
            "",
            "    async def _renew_attestations(self):",
            "        \"\"\"Called periodically to check if we need to update any of our attestations\"\"\"",
            "",
            "        now = self.clock.time_msec()",
            "",
            "        rows = await self.store.get_attestations_need_renewals(",
            "            now + UPDATE_ATTESTATION_TIME_MS",
            "        )",
            "",
            "        async def _renew_attestation(group_user: Tuple[str, str]):",
            "            group_id, user_id = group_user",
            "            try:",
            "                if not self.is_mine_id(group_id):",
            "                    destination = get_domain_from_id(group_id)",
            "                elif not self.is_mine_id(user_id):",
            "                    destination = get_domain_from_id(user_id)",
            "                else:",
            "                    logger.warning(",
            "                        \"Incorrectly trying to do attestations for user: %r in %r\",",
            "                        user_id,",
            "                        group_id,",
            "                    )",
            "                    await self.store.remove_attestation_renewal(group_id, user_id)",
            "                    return",
            "",
            "                attestation = self.attestations.create_attestation(group_id, user_id)",
            "",
            "                await self.transport_client.renew_group_attestation(",
            "                    destination, group_id, user_id, content={\"attestation\": attestation}",
            "                )",
            "",
            "                await self.store.update_attestation_renewal(",
            "                    group_id, user_id, attestation",
            "                )",
            "            except (RequestSendFailed, HttpResponseException) as e:",
            "                logger.warning(",
            "                    \"Failed to renew attestation of %r in %r: %s\", user_id, group_id, e",
            "                )",
            "            except Exception:",
            "                logger.exception(",
            "                    \"Error renewing attestation of %r in %r\", user_id, group_id",
            "                )",
            "",
            "        for row in rows:",
            "            await _renew_attestation((row[\"group_id\"], row[\"user_id\"]))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2017 Vector Creations Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"Attestations ensure that users and groups can't lie about their memberships.",
            "",
            "When a user joins a group the HS and GS swap attestations, which allow them",
            "both to independently prove to third parties their membership.These",
            "attestations have a validity period so need to be periodically renewed.",
            "",
            "If a user leaves (or gets kicked out of) a group, either side can still use",
            "their attestation to \"prove\" their membership, until the attestation expires.",
            "Therefore attestations shouldn't be relied on to prove membership in important",
            "cases, but can for less important situations, e.g. showing a users membership",
            "of groups on their profile, showing flairs, etc.",
            "",
            "An attestation is a signed blob of json that looks like:",
            "",
            "    {",
            "        \"user_id\": \"@foo:a.example.com\",",
            "        \"group_id\": \"+bar:b.example.com\",",
            "        \"valid_until_ms\": 1507994728530,",
            "        \"signatures\":{\"matrix.org\":{\"ed25519:auto\":\"...\"}}",
            "    }",
            "\"\"\"",
            "",
            "import logging",
            "import random",
            "from typing import TYPE_CHECKING, Optional, Tuple",
            "",
            "from signedjson.sign import sign_json",
            "",
            "from synapse.api.errors import HttpResponseException, RequestSendFailed, SynapseError",
            "from synapse.metrics.background_process_metrics import run_as_background_process",
            "from synapse.types import JsonDict, get_domain_from_id",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.app.homeserver import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# Default validity duration for new attestations we create",
            "DEFAULT_ATTESTATION_LENGTH_MS = 3 * 24 * 60 * 60 * 1000",
            "",
            "# We add some jitter to the validity duration of attestations so that if we",
            "# add lots of users at once we don't need to renew them all at once.",
            "# The jitter is a multiplier picked randomly between the first and second number",
            "DEFAULT_ATTESTATION_JITTER = (0.9, 1.3)",
            "",
            "# Start trying to update our attestations when they come this close to expiring",
            "UPDATE_ATTESTATION_TIME_MS = 1 * 24 * 60 * 60 * 1000",
            "",
            "",
            "class GroupAttestationSigning:",
            "    \"\"\"Creates and verifies group attestations.\"\"\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.keyring = hs.get_keyring()",
            "        self.clock = hs.get_clock()",
            "        self.server_name = hs.hostname",
            "        self.signing_key = hs.signing_key",
            "",
            "    async def verify_attestation(",
            "        self,",
            "        attestation: JsonDict,",
            "        group_id: str,",
            "        user_id: str,",
            "        server_name: Optional[str] = None,",
            "    ) -> None:",
            "        \"\"\"Verifies that the given attestation matches the given parameters.",
            "",
            "        An optional server_name can be supplied to explicitly set which server's",
            "        signature is expected. Otherwise assumes that either the group_id or user_id",
            "        is local and uses the other's server as the one to check.",
            "        \"\"\"",
            "",
            "        if not server_name:",
            "            if get_domain_from_id(group_id) == self.server_name:",
            "                server_name = get_domain_from_id(user_id)",
            "            elif get_domain_from_id(user_id) == self.server_name:",
            "                server_name = get_domain_from_id(group_id)",
            "            else:",
            "                raise Exception(\"Expected either group_id or user_id to be local\")",
            "",
            "        if user_id != attestation[\"user_id\"]:",
            "            raise SynapseError(400, \"Attestation has incorrect user_id\")",
            "",
            "        if group_id != attestation[\"group_id\"]:",
            "            raise SynapseError(400, \"Attestation has incorrect group_id\")",
            "        valid_until_ms = attestation[\"valid_until_ms\"]",
            "",
            "        # TODO: We also want to check that *new* attestations that people give",
            "        # us to store are valid for at least a little while.",
            "        now = self.clock.time_msec()",
            "        if valid_until_ms < now:",
            "            raise SynapseError(400, \"Attestation expired\")",
            "",
            "        assert server_name is not None",
            "        await self.keyring.verify_json_for_server(",
            "            server_name, attestation, now, \"Group attestation\"",
            "        )",
            "",
            "    def create_attestation(self, group_id: str, user_id: str) -> JsonDict:",
            "        \"\"\"Create an attestation for the group_id and user_id with default",
            "        validity length.",
            "        \"\"\"",
            "        validity_period = DEFAULT_ATTESTATION_LENGTH_MS * random.uniform(",
            "            *DEFAULT_ATTESTATION_JITTER",
            "        )",
            "        valid_until_ms = int(self.clock.time_msec() + validity_period)",
            "",
            "        return sign_json(",
            "            {",
            "                \"group_id\": group_id,",
            "                \"user_id\": user_id,",
            "                \"valid_until_ms\": valid_until_ms,",
            "            },",
            "            self.server_name,",
            "            self.signing_key,",
            "        )",
            "",
            "",
            "class GroupAttestionRenewer:",
            "    \"\"\"Responsible for sending and receiving attestation updates.\"\"\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.clock = hs.get_clock()",
            "        self.store = hs.get_datastore()",
            "        self.assestations = hs.get_groups_attestation_signing()",
            "        self.transport_client = hs.get_federation_transport_client()",
            "        self.is_mine_id = hs.is_mine_id",
            "        self.attestations = hs.get_groups_attestation_signing()",
            "",
            "        if not hs.config.worker_app:",
            "            self._renew_attestations_loop = self.clock.looping_call(",
            "                self._start_renew_attestations, 30 * 60 * 1000",
            "            )",
            "",
            "    async def on_renew_attestation(",
            "        self, group_id: str, user_id: str, content: JsonDict",
            "    ) -> JsonDict:",
            "        \"\"\"When a remote updates an attestation\"\"\"",
            "        attestation = content[\"attestation\"]",
            "",
            "        if not self.is_mine_id(group_id) and not self.is_mine_id(user_id):",
            "            raise SynapseError(400, \"Neither user not group are on this server\")",
            "",
            "        await self.attestations.verify_attestation(",
            "            attestation, user_id=user_id, group_id=group_id",
            "        )",
            "",
            "        await self.store.update_remote_attestion(group_id, user_id, attestation)",
            "",
            "        return {}",
            "",
            "    def _start_renew_attestations(self) -> None:",
            "        return run_as_background_process(\"renew_attestations\", self._renew_attestations)",
            "",
            "    async def _renew_attestations(self) -> None:",
            "        \"\"\"Called periodically to check if we need to update any of our attestations\"\"\"",
            "",
            "        now = self.clock.time_msec()",
            "",
            "        rows = await self.store.get_attestations_need_renewals(",
            "            now + UPDATE_ATTESTATION_TIME_MS",
            "        )",
            "",
            "        async def _renew_attestation(group_user: Tuple[str, str]) -> None:",
            "            group_id, user_id = group_user",
            "            try:",
            "                if not self.is_mine_id(group_id):",
            "                    destination = get_domain_from_id(group_id)",
            "                elif not self.is_mine_id(user_id):",
            "                    destination = get_domain_from_id(user_id)",
            "                else:",
            "                    logger.warning(",
            "                        \"Incorrectly trying to do attestations for user: %r in %r\",",
            "                        user_id,",
            "                        group_id,",
            "                    )",
            "                    await self.store.remove_attestation_renewal(group_id, user_id)",
            "                    return",
            "",
            "                attestation = self.attestations.create_attestation(group_id, user_id)",
            "",
            "                await self.transport_client.renew_group_attestation(",
            "                    destination, group_id, user_id, content={\"attestation\": attestation}",
            "                )",
            "",
            "                await self.store.update_attestation_renewal(",
            "                    group_id, user_id, attestation",
            "                )",
            "            except (RequestSendFailed, HttpResponseException) as e:",
            "                logger.warning(",
            "                    \"Failed to renew attestation of %r in %r: %s\", user_id, group_id, e",
            "                )",
            "            except Exception:",
            "                logger.exception(",
            "                    \"Error renewing attestation of %r in %r\", user_id, group_id",
            "                )",
            "",
            "        for row in rows:",
            "            await _renew_attestation((row[\"group_id\"], row[\"user_id\"]))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "40": [],
            "46": [],
            "66": [
                "GroupAttestationSigning",
                "__init__"
            ],
            "73": [
                "GroupAttestationSigning"
            ],
            "74": [
                "GroupAttestationSigning"
            ],
            "107": [
                "GroupAttestationSigning",
                "create_attestation"
            ],
            "111": [
                "GroupAttestationSigning",
                "create_attestation"
            ],
            "112": [
                "GroupAttestationSigning",
                "create_attestation"
            ],
            "129": [
                "GroupAttestionRenewer",
                "__init__"
            ],
            "142": [
                "GroupAttestionRenewer"
            ],
            "157": [
                "GroupAttestionRenewer",
                "_start_renew_attestations"
            ],
            "160": [
                "GroupAttestionRenewer"
            ],
            "169": [
                "GroupAttestionRenewer"
            ]
        },
        "addLocation": []
    }
}