{
    "poetry/core/vcs/git.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import Any"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import Optional"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from poetry.core.utils._compat import PY36"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from poetry.core.utils._compat import WINDOWS"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from poetry.core.utils._compat import Path"
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from poetry.core.utils._compat import decode"
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\"])"
            },
            "9": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+_executable = None"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+def executable():"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+    global _executable"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    if _executable is not None:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        return _executable"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    if WINDOWS and PY36:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        # Finding git via where.exe"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        where = \"%WINDIR%\\\\System32\\\\where.exe\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        paths = decode("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            subprocess.check_output([where, \"git\"], shell=True, encoding=\"oem\")"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        ).split(\"\\n\")"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        for path in paths:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+            if not path:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+                continue"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            path = Path(path.strip())"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            try:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+                path.relative_to(Path.cwd())"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            except ValueError:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+                _executable = str(path)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+                break"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+    else:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        _executable = \"git\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+    if _executable is None:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        raise RuntimeError(\"Unable to find a valid git executable\")"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+    return _executable"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+def _reset_executable():"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+    global _executable"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+    _executable = None"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 200,
                "PatchRowcode": " class GitConfig:"
            },
            "53": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "     def __init__(self, requires_git_presence=False):  # type: (bool) -> None"
            },
            "54": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         self._config = {}"
            },
            "55": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 203,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         try:"
            },
            "57": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "             config_list = decode("
            },
            "58": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "                 subprocess.check_output("
            },
            "59": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    [\"git\", \"config\", \"-l\"], stderr=subprocess.STDOUT"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+                    [executable(), \"config\", \"-l\"], stderr=subprocess.STDOUT"
            },
            "61": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "                 )"
            },
            "62": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "             )"
            },
            "63": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "             ) + args"
            },
            "65": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 354,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "         return decode("
            },
            "67": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            subprocess.check_output([\"git\"] + list(args), stderr=subprocess.STDOUT)"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+            subprocess.check_output("
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+                [executable()] + list(args), stderr=subprocess.STDOUT"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+            )"
            },
            "71": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "         ).strip()"
            },
            "72": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 360,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "     def _check_parameter(self, parameter):  # type: (str) -> None"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import re",
            "import subprocess",
            "",
            "from collections import namedtuple",
            "from typing import Any",
            "from typing import Optional",
            "",
            "from poetry.core.utils._compat import Path",
            "from poetry.core.utils._compat import decode",
            "",
            "",
            "pattern_formats = {",
            "    \"protocol\": r\"\\w+\",",
            "    \"user\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"resource\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"port\": r\"\\d+\",",
            "    \"path\": r\"[\\w~.\\-/\\\\]+\",",
            "    \"name\": r\"[\\w~.\\-]+\",",
            "    \"rev\": r\"[^@#]+\",",
            "}",
            "",
            "PATTERNS = [",
            "    re.compile(",
            "        r\"^(git\\+)?\"",
            "        r\"(?P<protocol>https?|git|ssh|rsync|file)://\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})?\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>[:/\\\\]({path}[/\\\\])?\"",
            "        r\"((?P<name>{name}?)(\\.git|[/\\\\])?)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"(git\\+)?\"",
            "        r\"((?P<protocol>{protocol})://)\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource}:?)\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            protocol=pattern_formats[\"protocol\"],",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"^(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>([:/]{path}/)\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"((?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"[:/]{{1,2}}\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "]",
            "",
            "",
            "class GitError(RuntimeError):",
            "",
            "    pass",
            "",
            "",
            "class ParsedUrl:",
            "    def __init__(",
            "        self,",
            "        protocol,  # type: Optional[str]",
            "        resource,  # type: Optional[str]",
            "        pathname,  # type: Optional[str]",
            "        user,  # type: Optional[str]",
            "        port,  # type: Optional[str]",
            "        name,  # type: Optional[str]",
            "        rev,  # type: Optional[str]",
            "    ):",
            "        self.protocol = protocol",
            "        self.resource = resource",
            "        self.pathname = pathname",
            "        self.user = user",
            "        self.port = port",
            "        self.name = name",
            "        self.rev = rev",
            "",
            "    @classmethod",
            "    def parse(cls, url):  # type: (str) -> ParsedUrl",
            "        for pattern in PATTERNS:",
            "            m = pattern.match(url)",
            "            if m:",
            "                groups = m.groupdict()",
            "                return ParsedUrl(",
            "                    groups.get(\"protocol\"),",
            "                    groups.get(\"resource\"),",
            "                    groups.get(\"pathname\"),",
            "                    groups.get(\"user\"),",
            "                    groups.get(\"port\"),",
            "                    groups.get(\"name\"),",
            "                    groups.get(\"rev\"),",
            "                )",
            "",
            "        raise ValueError('Invalid git url \"{}\"'.format(url))",
            "",
            "    @property",
            "    def url(self):  # type: () -> str",
            "        return \"{}{}{}{}{}\".format(",
            "            \"{}://\".format(self.protocol) if self.protocol else \"\",",
            "            \"{}@\".format(self.user) if self.user else \"\",",
            "            self.resource,",
            "            \":{}\".format(self.port) if self.port else \"\",",
            "            \"/\" + self.pathname.lstrip(\":/\"),",
            "        )",
            "",
            "    def format(self):  # type: () -> str",
            "        return self.url",
            "",
            "    def __str__(self):  # type: () -> str",
            "        return self.format()",
            "",
            "",
            "GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\"])",
            "",
            "",
            "class GitConfig:",
            "    def __init__(self, requires_git_presence=False):  # type: (bool) -> None",
            "        self._config = {}",
            "",
            "        try:",
            "            config_list = decode(",
            "                subprocess.check_output(",
            "                    [\"git\", \"config\", \"-l\"], stderr=subprocess.STDOUT",
            "                )",
            "            )",
            "",
            "            m = re.findall(\"(?ms)^([^=]+)=(.*?)$\", config_list)",
            "            if m:",
            "                for group in m:",
            "                    self._config[group[0]] = group[1]",
            "        except (subprocess.CalledProcessError, OSError):",
            "            if requires_git_presence:",
            "                raise",
            "",
            "    def get(self, key, default=None):  # type: (Any, Optional[Any]) -> Any",
            "        return self._config.get(key, default)",
            "",
            "    def __getitem__(self, item):  # type: (Any) -> Any",
            "        return self._config[item]",
            "",
            "",
            "class Git:",
            "    def __init__(self, work_dir=None):  # type: (Optional[Path]) -> None",
            "        self._config = GitConfig(requires_git_presence=True)",
            "        self._work_dir = work_dir",
            "",
            "    @classmethod",
            "    def normalize_url(cls, url):  # type: (str) -> GitUrl",
            "        parsed = ParsedUrl.parse(url)",
            "",
            "        formatted = re.sub(r\"^git\\+\", \"\", url)",
            "        if parsed.rev:",
            "            formatted = re.sub(r\"[#@]{}$\".format(parsed.rev), \"\", formatted)",
            "",
            "        altered = parsed.format() != formatted",
            "",
            "        if altered:",
            "            if re.match(r\"^git\\+https?\", url) and re.match(",
            "                r\"^/?:[^0-9]\", parsed.pathname",
            "            ):",
            "                normalized = re.sub(r\"git\\+(.*:[^:]+):(.*)\", \"\\\\1/\\\\2\", url)",
            "            elif re.match(r\"^git\\+file\", url):",
            "                normalized = re.sub(r\"git\\+\", \"\", url)",
            "            else:",
            "                normalized = re.sub(r\"^(?:git\\+)?ssh://\", \"\", url)",
            "        else:",
            "            normalized = parsed.format()",
            "",
            "        return GitUrl(re.sub(r\"#[^#]*$\", \"\", normalized), parsed.rev)",
            "",
            "    @property",
            "    def config(self):  # type: () -> GitConfig",
            "        return self._config",
            "",
            "    def clone(self, repository, dest):  # type: (str, Path) -> str",
            "        self._check_parameter(repository)",
            "",
            "        return self.run(\"clone\", \"--recurse-submodules\", \"--\", repository, str(dest))",
            "",
            "    def checkout(self, rev, folder=None):  # type: (str, Optional[Path]) -> str",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        self._check_parameter(rev)",
            "",
            "        args += [\"checkout\", rev]",
            "",
            "        return self.run(*args)",
            "",
            "    def rev_parse(self, rev, folder=None):  # type: (str, Optional[Path]) -> str",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        self._check_parameter(rev)",
            "",
            "        # We need \"^0\" (an alternative to \"^{commit}\") to ensure that the",
            "        # commit SHA of the commit the tag points to is returned, even in",
            "        # the case of annotated tags.",
            "        #",
            "        # We deliberately avoid the \"^{commit}\" syntax itself as on some",
            "        # platforms (cygwin/msys to be specific), the braces are interpreted",
            "        # as special characters and would require escaping, while on others",
            "        # they should not be escaped.",
            "        args += [\"rev-parse\", rev + \"^0\"]",
            "",
            "        return self.run(*args)",
            "",
            "    def get_ignored_files(self, folder=None):  # type: (Optional[Path]) -> list",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        args += [\"ls-files\", \"--others\", \"-i\", \"--exclude-standard\"]",
            "        output = self.run(*args)",
            "",
            "        return output.strip().split(\"\\n\")",
            "",
            "    def remote_urls(self, folder=None):  # type: (Optional[Path]) -> dict",
            "        output = self.run(",
            "            \"config\", \"--get-regexp\", r\"remote\\..*\\.url\", folder=folder",
            "        ).strip()",
            "",
            "        urls = {}",
            "        for url in output.splitlines():",
            "            name, url = url.split(\" \", 1)",
            "            urls[name.strip()] = url.strip()",
            "",
            "        return urls",
            "",
            "    def remote_url(self, folder=None):  # type: (Optional[Path]) -> str",
            "        urls = self.remote_urls(folder=folder)",
            "",
            "        return urls.get(\"remote.origin.url\", urls[list(urls.keys())[0]])",
            "",
            "    def run(self, *args, **kwargs):  # type: (*Any, **Any) -> str",
            "        folder = kwargs.pop(\"folder\", None)",
            "        if folder:",
            "            args = (",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ) + args",
            "",
            "        return decode(",
            "            subprocess.check_output([\"git\"] + list(args), stderr=subprocess.STDOUT)",
            "        ).strip()",
            "",
            "    def _check_parameter(self, parameter):  # type: (str) -> None",
            "        \"\"\"",
            "        Checks a git parameter to avoid unwanted code execution.",
            "        \"\"\"",
            "        if parameter.strip().startswith(\"-\"):",
            "            raise GitError(\"Invalid Git parameter: {}\".format(parameter))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import re",
            "import subprocess",
            "",
            "from collections import namedtuple",
            "from typing import Any",
            "from typing import Optional",
            "",
            "from poetry.core.utils._compat import PY36",
            "from poetry.core.utils._compat import WINDOWS",
            "from poetry.core.utils._compat import Path",
            "from poetry.core.utils._compat import decode",
            "",
            "",
            "pattern_formats = {",
            "    \"protocol\": r\"\\w+\",",
            "    \"user\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"resource\": r\"[a-zA-Z0-9_.-]+\",",
            "    \"port\": r\"\\d+\",",
            "    \"path\": r\"[\\w~.\\-/\\\\]+\",",
            "    \"name\": r\"[\\w~.\\-]+\",",
            "    \"rev\": r\"[^@#]+\",",
            "}",
            "",
            "PATTERNS = [",
            "    re.compile(",
            "        r\"^(git\\+)?\"",
            "        r\"(?P<protocol>https?|git|ssh|rsync|file)://\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})?\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>[:/\\\\]({path}[/\\\\])?\"",
            "        r\"((?P<name>{name}?)(\\.git|[/\\\\])?)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"(git\\+)?\"",
            "        r\"((?P<protocol>{protocol})://)\"",
            "        r\"(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource}:?)\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            protocol=pattern_formats[\"protocol\"],",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"^(?:(?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"(:(?P<port>{port}))?\"",
            "        r\"(?P<pathname>([:/]{path}/)\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            port=pattern_formats[\"port\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "    re.compile(",
            "        r\"((?P<user>{user})@)?\"",
            "        r\"(?P<resource>{resource})\"",
            "        r\"[:/]{{1,2}}\"",
            "        r\"(?P<pathname>({path})\"",
            "        r\"(?P<name>{name})(\\.git|/)?)\"",
            "        r\"([@#](?P<rev>{rev}))?\"",
            "        r\"$\".format(",
            "            user=pattern_formats[\"user\"],",
            "            resource=pattern_formats[\"resource\"],",
            "            path=pattern_formats[\"path\"],",
            "            name=pattern_formats[\"name\"],",
            "            rev=pattern_formats[\"rev\"],",
            "        )",
            "    ),",
            "]",
            "",
            "",
            "class GitError(RuntimeError):",
            "",
            "    pass",
            "",
            "",
            "class ParsedUrl:",
            "    def __init__(",
            "        self,",
            "        protocol,  # type: Optional[str]",
            "        resource,  # type: Optional[str]",
            "        pathname,  # type: Optional[str]",
            "        user,  # type: Optional[str]",
            "        port,  # type: Optional[str]",
            "        name,  # type: Optional[str]",
            "        rev,  # type: Optional[str]",
            "    ):",
            "        self.protocol = protocol",
            "        self.resource = resource",
            "        self.pathname = pathname",
            "        self.user = user",
            "        self.port = port",
            "        self.name = name",
            "        self.rev = rev",
            "",
            "    @classmethod",
            "    def parse(cls, url):  # type: (str) -> ParsedUrl",
            "        for pattern in PATTERNS:",
            "            m = pattern.match(url)",
            "            if m:",
            "                groups = m.groupdict()",
            "                return ParsedUrl(",
            "                    groups.get(\"protocol\"),",
            "                    groups.get(\"resource\"),",
            "                    groups.get(\"pathname\"),",
            "                    groups.get(\"user\"),",
            "                    groups.get(\"port\"),",
            "                    groups.get(\"name\"),",
            "                    groups.get(\"rev\"),",
            "                )",
            "",
            "        raise ValueError('Invalid git url \"{}\"'.format(url))",
            "",
            "    @property",
            "    def url(self):  # type: () -> str",
            "        return \"{}{}{}{}{}\".format(",
            "            \"{}://\".format(self.protocol) if self.protocol else \"\",",
            "            \"{}@\".format(self.user) if self.user else \"\",",
            "            self.resource,",
            "            \":{}\".format(self.port) if self.port else \"\",",
            "            \"/\" + self.pathname.lstrip(\":/\"),",
            "        )",
            "",
            "    def format(self):  # type: () -> str",
            "        return self.url",
            "",
            "    def __str__(self):  # type: () -> str",
            "        return self.format()",
            "",
            "",
            "GitUrl = namedtuple(\"GitUrl\", [\"url\", \"revision\"])",
            "",
            "",
            "_executable = None",
            "",
            "",
            "def executable():",
            "    global _executable",
            "",
            "    if _executable is not None:",
            "        return _executable",
            "",
            "    if WINDOWS and PY36:",
            "        # Finding git via where.exe",
            "        where = \"%WINDIR%\\\\System32\\\\where.exe\"",
            "        paths = decode(",
            "            subprocess.check_output([where, \"git\"], shell=True, encoding=\"oem\")",
            "        ).split(\"\\n\")",
            "        for path in paths:",
            "            if not path:",
            "                continue",
            "",
            "            path = Path(path.strip())",
            "            try:",
            "                path.relative_to(Path.cwd())",
            "            except ValueError:",
            "                _executable = str(path)",
            "",
            "                break",
            "    else:",
            "        _executable = \"git\"",
            "",
            "    if _executable is None:",
            "        raise RuntimeError(\"Unable to find a valid git executable\")",
            "",
            "    return _executable",
            "",
            "",
            "def _reset_executable():",
            "    global _executable",
            "",
            "    _executable = None",
            "",
            "",
            "class GitConfig:",
            "    def __init__(self, requires_git_presence=False):  # type: (bool) -> None",
            "        self._config = {}",
            "",
            "        try:",
            "            config_list = decode(",
            "                subprocess.check_output(",
            "                    [executable(), \"config\", \"-l\"], stderr=subprocess.STDOUT",
            "                )",
            "            )",
            "",
            "            m = re.findall(\"(?ms)^([^=]+)=(.*?)$\", config_list)",
            "            if m:",
            "                for group in m:",
            "                    self._config[group[0]] = group[1]",
            "        except (subprocess.CalledProcessError, OSError):",
            "            if requires_git_presence:",
            "                raise",
            "",
            "    def get(self, key, default=None):  # type: (Any, Optional[Any]) -> Any",
            "        return self._config.get(key, default)",
            "",
            "    def __getitem__(self, item):  # type: (Any) -> Any",
            "        return self._config[item]",
            "",
            "",
            "class Git:",
            "    def __init__(self, work_dir=None):  # type: (Optional[Path]) -> None",
            "        self._config = GitConfig(requires_git_presence=True)",
            "        self._work_dir = work_dir",
            "",
            "    @classmethod",
            "    def normalize_url(cls, url):  # type: (str) -> GitUrl",
            "        parsed = ParsedUrl.parse(url)",
            "",
            "        formatted = re.sub(r\"^git\\+\", \"\", url)",
            "        if parsed.rev:",
            "            formatted = re.sub(r\"[#@]{}$\".format(parsed.rev), \"\", formatted)",
            "",
            "        altered = parsed.format() != formatted",
            "",
            "        if altered:",
            "            if re.match(r\"^git\\+https?\", url) and re.match(",
            "                r\"^/?:[^0-9]\", parsed.pathname",
            "            ):",
            "                normalized = re.sub(r\"git\\+(.*:[^:]+):(.*)\", \"\\\\1/\\\\2\", url)",
            "            elif re.match(r\"^git\\+file\", url):",
            "                normalized = re.sub(r\"git\\+\", \"\", url)",
            "            else:",
            "                normalized = re.sub(r\"^(?:git\\+)?ssh://\", \"\", url)",
            "        else:",
            "            normalized = parsed.format()",
            "",
            "        return GitUrl(re.sub(r\"#[^#]*$\", \"\", normalized), parsed.rev)",
            "",
            "    @property",
            "    def config(self):  # type: () -> GitConfig",
            "        return self._config",
            "",
            "    def clone(self, repository, dest):  # type: (str, Path) -> str",
            "        self._check_parameter(repository)",
            "",
            "        return self.run(\"clone\", \"--recurse-submodules\", \"--\", repository, str(dest))",
            "",
            "    def checkout(self, rev, folder=None):  # type: (str, Optional[Path]) -> str",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        self._check_parameter(rev)",
            "",
            "        args += [\"checkout\", rev]",
            "",
            "        return self.run(*args)",
            "",
            "    def rev_parse(self, rev, folder=None):  # type: (str, Optional[Path]) -> str",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        self._check_parameter(rev)",
            "",
            "        # We need \"^0\" (an alternative to \"^{commit}\") to ensure that the",
            "        # commit SHA of the commit the tag points to is returned, even in",
            "        # the case of annotated tags.",
            "        #",
            "        # We deliberately avoid the \"^{commit}\" syntax itself as on some",
            "        # platforms (cygwin/msys to be specific), the braces are interpreted",
            "        # as special characters and would require escaping, while on others",
            "        # they should not be escaped.",
            "        args += [\"rev-parse\", rev + \"^0\"]",
            "",
            "        return self.run(*args)",
            "",
            "    def get_ignored_files(self, folder=None):  # type: (Optional[Path]) -> list",
            "        args = []",
            "        if folder is None and self._work_dir:",
            "            folder = self._work_dir",
            "",
            "        if folder:",
            "            args += [",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ]",
            "",
            "        args += [\"ls-files\", \"--others\", \"-i\", \"--exclude-standard\"]",
            "        output = self.run(*args)",
            "",
            "        return output.strip().split(\"\\n\")",
            "",
            "    def remote_urls(self, folder=None):  # type: (Optional[Path]) -> dict",
            "        output = self.run(",
            "            \"config\", \"--get-regexp\", r\"remote\\..*\\.url\", folder=folder",
            "        ).strip()",
            "",
            "        urls = {}",
            "        for url in output.splitlines():",
            "            name, url = url.split(\" \", 1)",
            "            urls[name.strip()] = url.strip()",
            "",
            "        return urls",
            "",
            "    def remote_url(self, folder=None):  # type: (Optional[Path]) -> str",
            "        urls = self.remote_urls(folder=folder)",
            "",
            "        return urls.get(\"remote.origin.url\", urls[list(urls.keys())[0]])",
            "",
            "    def run(self, *args, **kwargs):  # type: (*Any, **Any) -> str",
            "        folder = kwargs.pop(\"folder\", None)",
            "        if folder:",
            "            args = (",
            "                \"--git-dir\",",
            "                (folder / \".git\").as_posix(),",
            "                \"--work-tree\",",
            "                folder.as_posix(),",
            "            ) + args",
            "",
            "        return decode(",
            "            subprocess.check_output(",
            "                [executable()] + list(args), stderr=subprocess.STDOUT",
            "            )",
            "        ).strip()",
            "",
            "    def _check_parameter(self, parameter):  # type: (str) -> None",
            "        \"\"\"",
            "        Checks a git parameter to avoid unwanted code execution.",
            "        \"\"\"",
            "        if parameter.strip().startswith(\"-\"):",
            "            raise GitError(\"Invalid Git parameter: {}\".format(parameter))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "164": [
                "GitConfig",
                "__init__"
            ],
            "313": [
                "Git",
                "run"
            ]
        },
        "addLocation": [
            "poetry.core.vcs.git.Git.run",
            "poetry.core.vcs.git.GitConfig.__init__",
            "knowledge_repo.app.routes.comment"
        ]
    }
}