{
    "sydent/hs_federation/verifier.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from signedjson.sign import SignatureVerifyException"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from sydent.http.httpclient import FederationHttpClient"
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sydent.util.stringutils import is_valid_hostname"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from sydent.util.stringutils import is_valid_matrix_server_name"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "8": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         if not json_request[\"signatures\"]:"
            },
            "9": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "             raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")"
            },
            "10": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not is_valid_hostname(json_request[\"origin\"]):"
            },
            "12": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid hostname\")"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        if not is_valid_matrix_server_name(json_request[\"origin\"]):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid Matrix server name\")"
            },
            "15": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         yield self.verifyServerSignedJson(json_request, [origin])"
            },
            "17": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 212,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import time",
            "",
            "from twisted.internet import defer",
            "from unpaddedbase64 import decode_base64",
            "import signedjson.sign",
            "import signedjson.key",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.httpclient import FederationHttpClient",
            "from sydent.util.stringutils import is_valid_hostname",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoAuthenticationError(Exception):",
            "    \"\"\"",
            "    Raised when no signature is provided that could be authenticated",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class InvalidServerName(Exception):",
            "    \"\"\"",
            "    Raised when the provided origin parameter is not a valid hostname (plus optional port).",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Verifier(object):",
            "    \"\"\"",
            "    Verifies signed json blobs from Matrix Homeservers by finding the",
            "    homeserver's address, contacting it, requesting its keys and",
            "    verifying that the signature on the json blob matches.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # Cache of server keys. These are cached until the 'valid_until_ts' time",
            "        # in the result.",
            "        self.cache = {",
            "            # server_name: <result from keys query>,",
            "        }",
            "",
            "    @defer.inlineCallbacks",
            "    def _getKeysForServer(self, server_name):",
            "        \"\"\"Get the signing key data from a homeserver.",
            "",
            "        :param server_name: The name of the server to request the keys from.",
            "        :type server_name: unicode",
            "",
            "        :return: The verification keys returned by the server.",
            "        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]",
            "        \"\"\"",
            "",
            "        if server_name in self.cache:",
            "            cached = self.cache[server_name]",
            "            now = int(time.time() * 1000)",
            "            if cached['valid_until_ts'] > now:",
            "                defer.returnValue(self.cache[server_name]['verify_keys'])",
            "",
            "        client = FederationHttpClient(self.sydent)",
            "        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)",
            "        if 'verify_keys' not in result:",
            "            raise SignatureVerifyException(\"No key found in response\")",
            "",
            "        if 'valid_until_ts' in result:",
            "            # Don't cache anything without a valid_until_ts or we wouldn't",
            "            # know when to expire it.",
            "            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])",
            "            self.cache[server_name] = result",
            "",
            "        defer.returnValue(result['verify_keys'])",
            "",
            "    @defer.inlineCallbacks",
            "    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):",
            "        \"\"\"Given a signed json object, try to verify any one",
            "        of the signatures on it",
            "",
            "        XXX: This contains a fairly noddy version of the home server",
            "        SRV lookup and signature verification. It does no caching (just",
            "        fetches the signature each time and does not contact any other",
            "        servers to do perspective checks).",
            "",
            "        :param acceptable_server_names: If provided and not None,",
            "        only signatures from servers in this list will be accepted.",
            "        :type acceptable_server_names: list[unicode] or None",
            "",
            "        :return a tuple of the server name and key name that was",
            "        successfully verified.",
            "        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]",
            "",
            "        :raise SignatureVerifyException: The json cannot be verified.",
            "        \"\"\"",
            "        if 'signatures' not in signed_json:",
            "            raise SignatureVerifyException(\"Signature missing\")",
            "        for server_name, sigs in signed_json['signatures'].items():",
            "            if acceptable_server_names is not None:",
            "                if server_name not in acceptable_server_names:",
            "                    continue",
            "",
            "            server_keys = yield self._getKeysForServer(server_name)",
            "            for key_name, sig in sigs.items():",
            "                if key_name in server_keys:",
            "                    if 'key' not in server_keys[key_name]:",
            "                        logger.warn(\"Ignoring key %s with no 'key'\")",
            "                        continue",
            "                    key_bytes = decode_base64(server_keys[key_name]['key'])",
            "                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)",
            "                    logger.info(\"verifying sig from key %r\", key_name)",
            "                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)",
            "                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)",
            "                    defer.returnValue((server_name, key_name))",
            "            logger.warn(",
            "                \"No matching key found for signature block %r in server keys %r\",",
            "                signed_json['signatures'], server_keys,",
            "            )",
            "        logger.warn(",
            "            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",",
            "            signed_json['signatures'], acceptable_server_names,",
            "        )",
            "        raise SignatureVerifyException(\"No matching signature found\")",
            "",
            "    @defer.inlineCallbacks",
            "    def authenticate_request(self, request, content):",
            "        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header",
            "        XXX: Copied largely from synapse",
            "",
            "        :param request: The request object to authenticate",
            "        :type request: twisted.web.server.Request",
            "        :param content: The content of the request, if any",
            "        :type content: bytes or None",
            "",
            "        :return: The origin of the server whose signature was validated",
            "        :rtype: twisted.internet.defer.Deferred[unicode]",
            "        \"\"\"",
            "        json_request = {",
            "            \"method\": request.method,",
            "            \"uri\": request.uri,",
            "            \"destination_is\": self.sydent.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        def parse_auth_header(header_str):",
            "            \"\"\"",
            "            Extracts a server name, signing key and payload signature from an",
            "            authentication header.",
            "",
            "            :param header_str: The content of the header",
            "            :type header_str: unicode",
            "",
            "            :return: The server name, the signing key, and the payload signature.",
            "            :rtype: tuple[unicode]",
            "            \"\"\"",
            "            try:",
            "                params = header_str.split(u\" \")[1].split(u\",\")",
            "                param_dict = dict(kv.split(u\"=\") for kv in params)",
            "",
            "                def strip_quotes(value):",
            "                    if value.startswith(u\"\\\"\"):",
            "                        return value[1:-1]",
            "                    else:",
            "                        return value",
            "",
            "                origin = strip_quotes(param_dict[\"origin\"])",
            "                key = strip_quotes(param_dict[\"key\"])",
            "                sig = strip_quotes(param_dict[\"sig\"])",
            "                return origin, key, sig",
            "            except Exception:",
            "                raise SignatureVerifyException(\"Malformed Authorization header\")",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(\"Missing Authorization headers\")",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(u\"X-Matrix\"):",
            "                (origin, key, sig) = parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")",
            "",
            "        if not is_valid_hostname(json_request[\"origin\"]):",
            "            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid hostname\")",
            "",
            "        yield self.verifyServerSignedJson(json_request, [origin])",
            "",
            "        logger.info(\"Verified request from HS %s\", origin)",
            "",
            "        defer.returnValue(origin)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import logging",
            "import time",
            "",
            "from twisted.internet import defer",
            "from unpaddedbase64 import decode_base64",
            "import signedjson.sign",
            "import signedjson.key",
            "from signedjson.sign import SignatureVerifyException",
            "",
            "from sydent.http.httpclient import FederationHttpClient",
            "from sydent.util.stringutils import is_valid_matrix_server_name",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoAuthenticationError(Exception):",
            "    \"\"\"",
            "    Raised when no signature is provided that could be authenticated",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class InvalidServerName(Exception):",
            "    \"\"\"",
            "    Raised when the provided origin parameter is not a valid hostname (plus optional port).",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Verifier(object):",
            "    \"\"\"",
            "    Verifies signed json blobs from Matrix Homeservers by finding the",
            "    homeserver's address, contacting it, requesting its keys and",
            "    verifying that the signature on the json blob matches.",
            "    \"\"\"",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        # Cache of server keys. These are cached until the 'valid_until_ts' time",
            "        # in the result.",
            "        self.cache = {",
            "            # server_name: <result from keys query>,",
            "        }",
            "",
            "    @defer.inlineCallbacks",
            "    def _getKeysForServer(self, server_name):",
            "        \"\"\"Get the signing key data from a homeserver.",
            "",
            "        :param server_name: The name of the server to request the keys from.",
            "        :type server_name: unicode",
            "",
            "        :return: The verification keys returned by the server.",
            "        :rtype: twisted.internet.defer.Deferred[dict[unicode, dict[unicode, unicode]]]",
            "        \"\"\"",
            "",
            "        if server_name in self.cache:",
            "            cached = self.cache[server_name]",
            "            now = int(time.time() * 1000)",
            "            if cached['valid_until_ts'] > now:",
            "                defer.returnValue(self.cache[server_name]['verify_keys'])",
            "",
            "        client = FederationHttpClient(self.sydent)",
            "        result = yield client.get_json(\"matrix://%s/_matrix/key/v2/server/\" % server_name, 1024 * 50)",
            "        if 'verify_keys' not in result:",
            "            raise SignatureVerifyException(\"No key found in response\")",
            "",
            "        if 'valid_until_ts' in result:",
            "            # Don't cache anything without a valid_until_ts or we wouldn't",
            "            # know when to expire it.",
            "            logger.info(\"Got keys for %s: caching until %s\", server_name, result['valid_until_ts'])",
            "            self.cache[server_name] = result",
            "",
            "        defer.returnValue(result['verify_keys'])",
            "",
            "    @defer.inlineCallbacks",
            "    def verifyServerSignedJson(self, signed_json, acceptable_server_names=None):",
            "        \"\"\"Given a signed json object, try to verify any one",
            "        of the signatures on it",
            "",
            "        XXX: This contains a fairly noddy version of the home server",
            "        SRV lookup and signature verification. It does no caching (just",
            "        fetches the signature each time and does not contact any other",
            "        servers to do perspective checks).",
            "",
            "        :param acceptable_server_names: If provided and not None,",
            "        only signatures from servers in this list will be accepted.",
            "        :type acceptable_server_names: list[unicode] or None",
            "",
            "        :return a tuple of the server name and key name that was",
            "        successfully verified.",
            "        :rtype: twisted.internet.defer.Deferred[tuple[unicode]]",
            "",
            "        :raise SignatureVerifyException: The json cannot be verified.",
            "        \"\"\"",
            "        if 'signatures' not in signed_json:",
            "            raise SignatureVerifyException(\"Signature missing\")",
            "        for server_name, sigs in signed_json['signatures'].items():",
            "            if acceptable_server_names is not None:",
            "                if server_name not in acceptable_server_names:",
            "                    continue",
            "",
            "            server_keys = yield self._getKeysForServer(server_name)",
            "            for key_name, sig in sigs.items():",
            "                if key_name in server_keys:",
            "                    if 'key' not in server_keys[key_name]:",
            "                        logger.warn(\"Ignoring key %s with no 'key'\")",
            "                        continue",
            "                    key_bytes = decode_base64(server_keys[key_name]['key'])",
            "                    verify_key = signedjson.key.decode_verify_key_bytes(key_name, key_bytes)",
            "                    logger.info(\"verifying sig from key %r\", key_name)",
            "                    signedjson.sign.verify_signed_json(signed_json, server_name, verify_key)",
            "                    logger.info(\"Verified signature with key %s from %s\", key_name, server_name)",
            "                    defer.returnValue((server_name, key_name))",
            "            logger.warn(",
            "                \"No matching key found for signature block %r in server keys %r\",",
            "                signed_json['signatures'], server_keys,",
            "            )",
            "        logger.warn(",
            "            \"Unable to verify any signatures from block %r. Acceptable server names: %r\",",
            "            signed_json['signatures'], acceptable_server_names,",
            "        )",
            "        raise SignatureVerifyException(\"No matching signature found\")",
            "",
            "    @defer.inlineCallbacks",
            "    def authenticate_request(self, request, content):",
            "        \"\"\"Authenticates a Matrix federation request based on the X-Matrix header",
            "        XXX: Copied largely from synapse",
            "",
            "        :param request: The request object to authenticate",
            "        :type request: twisted.web.server.Request",
            "        :param content: The content of the request, if any",
            "        :type content: bytes or None",
            "",
            "        :return: The origin of the server whose signature was validated",
            "        :rtype: twisted.internet.defer.Deferred[unicode]",
            "        \"\"\"",
            "        json_request = {",
            "            \"method\": request.method,",
            "            \"uri\": request.uri,",
            "            \"destination_is\": self.sydent.server_name,",
            "            \"signatures\": {},",
            "        }",
            "",
            "        if content is not None:",
            "            json_request[\"content\"] = content",
            "",
            "        origin = None",
            "",
            "        def parse_auth_header(header_str):",
            "            \"\"\"",
            "            Extracts a server name, signing key and payload signature from an",
            "            authentication header.",
            "",
            "            :param header_str: The content of the header",
            "            :type header_str: unicode",
            "",
            "            :return: The server name, the signing key, and the payload signature.",
            "            :rtype: tuple[unicode]",
            "            \"\"\"",
            "            try:",
            "                params = header_str.split(u\" \")[1].split(u\",\")",
            "                param_dict = dict(kv.split(u\"=\") for kv in params)",
            "",
            "                def strip_quotes(value):",
            "                    if value.startswith(u\"\\\"\"):",
            "                        return value[1:-1]",
            "                    else:",
            "                        return value",
            "",
            "                origin = strip_quotes(param_dict[\"origin\"])",
            "                key = strip_quotes(param_dict[\"key\"])",
            "                sig = strip_quotes(param_dict[\"sig\"])",
            "                return origin, key, sig",
            "            except Exception:",
            "                raise SignatureVerifyException(\"Malformed Authorization header\")",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(u\"Authorization\")",
            "",
            "        if not auth_headers:",
            "            raise NoAuthenticationError(\"Missing Authorization headers\")",
            "",
            "        for auth in auth_headers:",
            "            if auth.startswith(u\"X-Matrix\"):",
            "                (origin, key, sig) = parse_auth_header(auth)",
            "                json_request[\"origin\"] = origin",
            "                json_request[\"signatures\"].setdefault(origin, {})[key] = sig",
            "",
            "        if not json_request[\"signatures\"]:",
            "            raise NoAuthenticationError(\"Missing X-Matrix Authorization header\")",
            "",
            "        if not is_valid_matrix_server_name(json_request[\"origin\"]):",
            "            raise InvalidServerName(\"X-Matrix header's origin parameter must be a valid Matrix server name\")",
            "",
            "        yield self.verifyServerSignedJson(json_request, [origin])",
            "",
            "        logger.info(\"Verified request from HS %s\", origin)",
            "",
            "        defer.returnValue(origin)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [],
            "208": [
                "Verifier",
                "authenticate_request"
            ],
            "209": [
                "Verifier",
                "authenticate_request"
            ]
        },
        "addLocation": []
    },
    "sydent/http/servlets/registerservlet.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from sydent.http.servlets import get_args, jsonwrap, deferjsonwrap, send_cors"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from sydent.http.httpclient import FederationHttpClient"
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from sydent.users.tokens import issueToken"
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sydent.util.stringutils import is_valid_hostname"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from sydent.util.stringutils import is_valid_matrix_server_name"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         matrix_server = args['matrix_server_name'].lower()"
            },
            "10": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not is_valid_hostname(matrix_server):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        if not is_valid_matrix_server_name(matrix_server):"
            },
            "13": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             request.setResponseCode(400)"
            },
            "14": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             return {"
            },
            "15": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "                 'errcode': 'M_INVALID_PARAM',"
            },
            "16": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'error': 'matrix_server_name must be a valid hostname'"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                'error': 'matrix_server_name must be a valid Matrix server name (IP address or hostname)'"
            },
            "18": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             }"
            },
            "19": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         result = yield self.client.get_json("
            },
            "21": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         user_id_server = user_id_components[1]"
            },
            "23": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not is_valid_hostname(user_id_server):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        if not is_valid_matrix_server_name(user_id_server):"
            },
            "26": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             request.setResponseCode(500)"
            },
            "27": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "             return {"
            },
            "28": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "                 'errcode': 'M_UNKNOWN',"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.resource import Resource",
            "from twisted.internet import defer",
            "",
            "import logging",
            "import json",
            "from six.moves import urllib",
            "",
            "from sydent.http.servlets import get_args, jsonwrap, deferjsonwrap, send_cors",
            "from sydent.http.httpclient import FederationHttpClient",
            "from sydent.users.tokens import issueToken",
            "from sydent.util.stringutils import is_valid_hostname",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class RegisterServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd):",
            "        self.sydent = syd",
            "        self.client = FederationHttpClient(self.sydent)",
            "",
            "    @deferjsonwrap",
            "    @defer.inlineCallbacks",
            "    def render_POST(self, request):",
            "        \"\"\"",
            "        Register with the Identity Server",
            "        \"\"\"",
            "        send_cors(request)",
            "",
            "        args = get_args(request, ('matrix_server_name', 'access_token'))",
            "",
            "        matrix_server = args['matrix_server_name'].lower()",
            "",
            "        if not is_valid_hostname(matrix_server):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'matrix_server_name must be a valid hostname'",
            "            }",
            "",
            "        result = yield self.client.get_json(",
            "            \"matrix://%s/_matrix/federation/v1/openid/userinfo?access_token=%s\"",
            "            % (",
            "                matrix_server,",
            "                urllib.parse.quote(args['access_token']),",
            "            ),",
            "            1024 * 5,",
            "        )",
            "",
            "        if 'sub' not in result:",
            "            raise Exception(\"Invalid response from homeserver\")",
            "",
            "        user_id = result['sub']",
            "",
            "        if not isinstance(user_id, str):",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned a malformed reply'",
            "            }",
            "",
            "        user_id_components = user_id.split(':', 1)",
            "",
            "        # Ensure there's a localpart and domain in the returned user ID.",
            "        if len(user_id_components) != 2:",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned an invalid MXID'",
            "            }",
            "",
            "        user_id_server = user_id_components[1]",
            "",
            "        if not is_valid_hostname(user_id_server):",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned an invalid MXID'",
            "            }",
            "",
            "        if user_id_server != matrix_server:",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned a MXID belonging to another homeserver'",
            "            }",
            "",
            "        tok = yield issueToken(self.sydent, user_id)",
            "",
            "        # XXX: `token` is correct for the spec, but we released with `access_token`",
            "        # for a substantial amount of time. Serve both to make spec-compliant clients",
            "        # happy.",
            "        defer.returnValue({",
            "            \"access_token\": tok,",
            "            \"token\": tok,",
            "        })",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.resource import Resource",
            "from twisted.internet import defer",
            "",
            "import logging",
            "import json",
            "from six.moves import urllib",
            "",
            "from sydent.http.servlets import get_args, jsonwrap, deferjsonwrap, send_cors",
            "from sydent.http.httpclient import FederationHttpClient",
            "from sydent.users.tokens import issueToken",
            "from sydent.util.stringutils import is_valid_matrix_server_name",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class RegisterServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd):",
            "        self.sydent = syd",
            "        self.client = FederationHttpClient(self.sydent)",
            "",
            "    @deferjsonwrap",
            "    @defer.inlineCallbacks",
            "    def render_POST(self, request):",
            "        \"\"\"",
            "        Register with the Identity Server",
            "        \"\"\"",
            "        send_cors(request)",
            "",
            "        args = get_args(request, ('matrix_server_name', 'access_token'))",
            "",
            "        matrix_server = args['matrix_server_name'].lower()",
            "",
            "        if not is_valid_matrix_server_name(matrix_server):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'matrix_server_name must be a valid Matrix server name (IP address or hostname)'",
            "            }",
            "",
            "        result = yield self.client.get_json(",
            "            \"matrix://%s/_matrix/federation/v1/openid/userinfo?access_token=%s\"",
            "            % (",
            "                matrix_server,",
            "                urllib.parse.quote(args['access_token']),",
            "            ),",
            "            1024 * 5,",
            "        )",
            "",
            "        if 'sub' not in result:",
            "            raise Exception(\"Invalid response from homeserver\")",
            "",
            "        user_id = result['sub']",
            "",
            "        if not isinstance(user_id, str):",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned a malformed reply'",
            "            }",
            "",
            "        user_id_components = user_id.split(':', 1)",
            "",
            "        # Ensure there's a localpart and domain in the returned user ID.",
            "        if len(user_id_components) != 2:",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned an invalid MXID'",
            "            }",
            "",
            "        user_id_server = user_id_components[1]",
            "",
            "        if not is_valid_matrix_server_name(user_id_server):",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned an invalid MXID'",
            "            }",
            "",
            "        if user_id_server != matrix_server:",
            "            request.setResponseCode(500)",
            "            return {",
            "                'errcode': 'M_UNKNOWN',",
            "                'error': 'The Matrix homeserver returned a MXID belonging to another homeserver'",
            "            }",
            "",
            "        tok = yield issueToken(self.sydent, user_id)",
            "",
            "        # XXX: `token` is correct for the spec, but we released with `access_token`",
            "        # for a substantial amount of time. Serve both to make spec-compliant clients",
            "        # happy.",
            "        defer.returnValue({",
            "            \"access_token\": tok,",
            "            \"token\": tok,",
            "        })",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [],
            "52": [
                "RegisterServlet",
                "render_POST"
            ],
            "56": [
                "RegisterServlet",
                "render_POST"
            ],
            "92": [
                "RegisterServlet",
                "render_POST"
            ]
        },
        "addLocation": []
    },
    "sydent/threepid/bind.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from sydent.threepid import ThreepidAssociation"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sydent.util.stringutils import is_valid_hostname"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+from sydent.util.stringutils import is_valid_matrix_server_name"
            },
            "5": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " from twisted.internet import defer"
            },
            "7": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         matrix_server = mxid_parts[1]"
            },
            "10": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not is_valid_hostname(matrix_server):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        if not is_valid_matrix_server_name(matrix_server):"
            },
            "13": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             logger.error("
            },
            "14": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"MXID server part '%s' not a valid hostname. Not retrying.\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                \"MXID server part '%s' not a valid Matrix server name. Not retrying.\","
            },
            "16": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "                 matrix_server,"
            },
            "17": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "             )"
            },
            "18": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             return"
            },
            "19": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "                     \"Successfully deleted invite for %s from the store\","
            },
            "20": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "                     assoc[\"address\"],"
            },
            "21": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "                 )"
            },
            "22": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except Exception as e:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+            except Exception:"
            },
            "24": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "                 logger.exception("
            },
            "25": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "                     \"Couldn't remove invite for %s from the store\","
            },
            "26": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "                     assoc[\"address\"],"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import collections",
            "import logging",
            "import math",
            "import signedjson.sign",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "",
            "from sydent.db.threepid_associations import LocalAssociationStore",
            "",
            "from sydent.util import time_msec",
            "from sydent.util.hash import sha256_and_url_safe_base64",
            "from sydent.db.hashing_metadata import HashingMetadataStore",
            "from sydent.threepid.signer import Signer",
            "from sydent.http.httpclient import FederationHttpClient",
            "",
            "from sydent.threepid import ThreepidAssociation",
            "",
            "from sydent.util.stringutils import is_valid_hostname",
            "",
            "from twisted.internet import defer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ThreepidBinder:",
            "    # the lifetime of a 3pid association",
            "    THREEPID_ASSOCIATION_LIFETIME_MS = 100 * 365 * 24 * 60 * 60 * 1000",
            "",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        self.hashing_store = HashingMetadataStore(sydent)",
            "",
            "    def addBinding(self, medium, address, mxid):",
            "        \"\"\"",
            "        Binds the given 3pid to the given mxid.",
            "",
            "        It's assumed that we have somehow validated that the given user owns",
            "        the given 3pid",
            "",
            "        :param medium: The medium of the 3PID to bind.",
            "        :type medium: unicode",
            "        :param address: The address of the 3PID to bind.",
            "        :type address: unicode",
            "        :param mxid: The MXID to bind the 3PID to.",
            "        :type mxid: unicode",
            "",
            "        :return: The signed association.",
            "        :rtype: dict[str, any]",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "",
            "        # Fill out the association details",
            "        createdAt = time_msec()",
            "        expires = createdAt + ThreepidBinder.THREEPID_ASSOCIATION_LIFETIME_MS",
            "",
            "        # Hash the medium + address and store that hash for the purposes of",
            "        # later lookups",
            "        str_to_hash = u' '.join(",
            "            [address, medium, self.hashing_store.get_lookup_pepper()],",
            "        )",
            "        lookup_hash = sha256_and_url_safe_base64(str_to_hash)",
            "",
            "        assoc = ThreepidAssociation(",
            "            medium, address, lookup_hash, mxid, createdAt, createdAt, expires,",
            "        )",
            "",
            "        localAssocStore.addOrUpdateAssociation(assoc)",
            "",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "        joinTokenStore = JoinTokenStore(self.sydent)",
            "        pendingJoinTokens = joinTokenStore.getTokens(medium, address)",
            "        invites = []",
            "        for token in pendingJoinTokens:",
            "            token[\"mxid\"] = mxid",
            "            token[\"signed\"] = {",
            "                \"mxid\": mxid,",
            "                \"token\": token[\"token\"],",
            "            }",
            "            token[\"signed\"] = signedjson.sign.sign_json(token[\"signed\"], self.sydent.server_name, self.sydent.keyring.ed25519)",
            "            invites.append(token)",
            "        if invites:",
            "            assoc.extra_fields[\"invites\"] = invites",
            "            joinTokenStore.markTokensAsSent(medium, address)",
            "",
            "        signer = Signer(self.sydent)",
            "        sgassoc = signer.signedThreePidAssociation(assoc)",
            "",
            "        self._notify(sgassoc, 0)",
            "",
            "        return sgassoc",
            "",
            "    def removeBinding(self, threepid, mxid):",
            "        \"\"\"",
            "        Removes the binding between a given 3PID and a given MXID.",
            "",
            "        :param threepid: The 3PID of the binding to remove.",
            "        :type threepid: dict[unicode, unicode]",
            "        :param mxid: The MXID of the binding to remove.",
            "        :type mxid: unicode",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "        localAssocStore.removeAssociation(threepid, mxid)",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "    @defer.inlineCallbacks",
            "    def _notify(self, assoc, attempt):",
            "        \"\"\"",
            "        Sends data about a new association (and, if necessary, the associated invites)",
            "        to the associated MXID's homeserver.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        \"\"\"",
            "        mxid = assoc[\"mxid\"]",
            "        mxid_parts = mxid.split(\":\", 1)",
            "",
            "        if len(mxid_parts) != 2:",
            "            logger.error(",
            "                \"Can't notify on bind for unparseable mxid %s. Not retrying.\",",
            "                assoc[\"mxid\"],",
            "            )",
            "            return",
            "",
            "        matrix_server = mxid_parts[1]",
            "",
            "        if not is_valid_hostname(matrix_server):",
            "            logger.error(",
            "                \"MXID server part '%s' not a valid hostname. Not retrying.\",",
            "                matrix_server,",
            "            )",
            "            return",
            "",
            "        post_url = \"matrix://%s/_matrix/federation/v1/3pid/onbind\" % (",
            "            matrix_server,",
            "        )",
            "",
            "        logger.info(\"Making bind callback to: %s\", post_url)",
            "",
            "        # Make a POST to the chosen Synapse server",
            "        http_client = FederationHttpClient(self.sydent)",
            "        try:",
            "            response = yield http_client.post_json_get_nothing(post_url, assoc, {})",
            "        except Exception as e:",
            "            self._notifyErrback(assoc, attempt, e)",
            "            return",
            "",
            "        # If the request failed, try again with exponential backoff",
            "        if response.code != 200:",
            "            self._notifyErrback(",
            "                assoc, attempt, \"Non-OK error code received (%d)\" % response.code",
            "            )",
            "        else:",
            "            logger.info(\"Successfully notified on bind for %s\" % (mxid,))",
            "",
            "            # Skip the deletion step if instructed so by the config.",
            "            if not self.sydent.delete_tokens_on_bind:",
            "                return",
            "",
            "            # Only remove sent tokens when they've been successfully sent.",
            "            try:",
            "                joinTokenStore = JoinTokenStore(self.sydent)",
            "                joinTokenStore.deleteTokens(assoc[\"medium\"], assoc[\"address\"])",
            "                logger.info(",
            "                    \"Successfully deleted invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "            except Exception as e:",
            "                logger.exception(",
            "                    \"Couldn't remove invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "",
            "    def _notifyErrback(self, assoc, attempt, error):",
            "        \"\"\"",
            "        Handles errors when trying to send an association down to a homeserver by",
            "        logging the error and scheduling a new attempt.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        :param error: The error that was raised when trying to send the association.",
            "        :type error: Exception",
            "        \"\"\"",
            "        logger.warning(",
            "            \"Error notifying on bind for %s: %s - rescheduling\", assoc[\"mxid\"], error",
            "        )",
            "        self.sydent.reactor.callLater(",
            "            math.pow(2, attempt), self._notify, assoc, attempt + 1",
            "        )",
            "",
            "    # The below is lovingly ripped off of synapse/http/endpoint.py",
            "",
            "    _Server = collections.namedtuple(\"_Server\", \"priority weight host port\")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import collections",
            "import logging",
            "import math",
            "import signedjson.sign",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "",
            "from sydent.db.threepid_associations import LocalAssociationStore",
            "",
            "from sydent.util import time_msec",
            "from sydent.util.hash import sha256_and_url_safe_base64",
            "from sydent.db.hashing_metadata import HashingMetadataStore",
            "from sydent.threepid.signer import Signer",
            "from sydent.http.httpclient import FederationHttpClient",
            "",
            "from sydent.threepid import ThreepidAssociation",
            "",
            "from sydent.util.stringutils import is_valid_matrix_server_name",
            "",
            "from twisted.internet import defer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ThreepidBinder:",
            "    # the lifetime of a 3pid association",
            "    THREEPID_ASSOCIATION_LIFETIME_MS = 100 * 365 * 24 * 60 * 60 * 1000",
            "",
            "    def __init__(self, sydent):",
            "        self.sydent = sydent",
            "        self.hashing_store = HashingMetadataStore(sydent)",
            "",
            "    def addBinding(self, medium, address, mxid):",
            "        \"\"\"",
            "        Binds the given 3pid to the given mxid.",
            "",
            "        It's assumed that we have somehow validated that the given user owns",
            "        the given 3pid",
            "",
            "        :param medium: The medium of the 3PID to bind.",
            "        :type medium: unicode",
            "        :param address: The address of the 3PID to bind.",
            "        :type address: unicode",
            "        :param mxid: The MXID to bind the 3PID to.",
            "        :type mxid: unicode",
            "",
            "        :return: The signed association.",
            "        :rtype: dict[str, any]",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "",
            "        # Fill out the association details",
            "        createdAt = time_msec()",
            "        expires = createdAt + ThreepidBinder.THREEPID_ASSOCIATION_LIFETIME_MS",
            "",
            "        # Hash the medium + address and store that hash for the purposes of",
            "        # later lookups",
            "        str_to_hash = u' '.join(",
            "            [address, medium, self.hashing_store.get_lookup_pepper()],",
            "        )",
            "        lookup_hash = sha256_and_url_safe_base64(str_to_hash)",
            "",
            "        assoc = ThreepidAssociation(",
            "            medium, address, lookup_hash, mxid, createdAt, createdAt, expires,",
            "        )",
            "",
            "        localAssocStore.addOrUpdateAssociation(assoc)",
            "",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "        joinTokenStore = JoinTokenStore(self.sydent)",
            "        pendingJoinTokens = joinTokenStore.getTokens(medium, address)",
            "        invites = []",
            "        for token in pendingJoinTokens:",
            "            token[\"mxid\"] = mxid",
            "            token[\"signed\"] = {",
            "                \"mxid\": mxid,",
            "                \"token\": token[\"token\"],",
            "            }",
            "            token[\"signed\"] = signedjson.sign.sign_json(token[\"signed\"], self.sydent.server_name, self.sydent.keyring.ed25519)",
            "            invites.append(token)",
            "        if invites:",
            "            assoc.extra_fields[\"invites\"] = invites",
            "            joinTokenStore.markTokensAsSent(medium, address)",
            "",
            "        signer = Signer(self.sydent)",
            "        sgassoc = signer.signedThreePidAssociation(assoc)",
            "",
            "        self._notify(sgassoc, 0)",
            "",
            "        return sgassoc",
            "",
            "    def removeBinding(self, threepid, mxid):",
            "        \"\"\"",
            "        Removes the binding between a given 3PID and a given MXID.",
            "",
            "        :param threepid: The 3PID of the binding to remove.",
            "        :type threepid: dict[unicode, unicode]",
            "        :param mxid: The MXID of the binding to remove.",
            "        :type mxid: unicode",
            "        \"\"\"",
            "        localAssocStore = LocalAssociationStore(self.sydent)",
            "        localAssocStore.removeAssociation(threepid, mxid)",
            "        self.sydent.pusher.doLocalPush()",
            "",
            "    @defer.inlineCallbacks",
            "    def _notify(self, assoc, attempt):",
            "        \"\"\"",
            "        Sends data about a new association (and, if necessary, the associated invites)",
            "        to the associated MXID's homeserver.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        \"\"\"",
            "        mxid = assoc[\"mxid\"]",
            "        mxid_parts = mxid.split(\":\", 1)",
            "",
            "        if len(mxid_parts) != 2:",
            "            logger.error(",
            "                \"Can't notify on bind for unparseable mxid %s. Not retrying.\",",
            "                assoc[\"mxid\"],",
            "            )",
            "            return",
            "",
            "        matrix_server = mxid_parts[1]",
            "",
            "        if not is_valid_matrix_server_name(matrix_server):",
            "            logger.error(",
            "                \"MXID server part '%s' not a valid Matrix server name. Not retrying.\",",
            "                matrix_server,",
            "            )",
            "            return",
            "",
            "        post_url = \"matrix://%s/_matrix/federation/v1/3pid/onbind\" % (",
            "            matrix_server,",
            "        )",
            "",
            "        logger.info(\"Making bind callback to: %s\", post_url)",
            "",
            "        # Make a POST to the chosen Synapse server",
            "        http_client = FederationHttpClient(self.sydent)",
            "        try:",
            "            response = yield http_client.post_json_get_nothing(post_url, assoc, {})",
            "        except Exception as e:",
            "            self._notifyErrback(assoc, attempt, e)",
            "            return",
            "",
            "        # If the request failed, try again with exponential backoff",
            "        if response.code != 200:",
            "            self._notifyErrback(",
            "                assoc, attempt, \"Non-OK error code received (%d)\" % response.code",
            "            )",
            "        else:",
            "            logger.info(\"Successfully notified on bind for %s\" % (mxid,))",
            "",
            "            # Skip the deletion step if instructed so by the config.",
            "            if not self.sydent.delete_tokens_on_bind:",
            "                return",
            "",
            "            # Only remove sent tokens when they've been successfully sent.",
            "            try:",
            "                joinTokenStore = JoinTokenStore(self.sydent)",
            "                joinTokenStore.deleteTokens(assoc[\"medium\"], assoc[\"address\"])",
            "                logger.info(",
            "                    \"Successfully deleted invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "            except Exception:",
            "                logger.exception(",
            "                    \"Couldn't remove invite for %s from the store\",",
            "                    assoc[\"address\"],",
            "                )",
            "",
            "    def _notifyErrback(self, assoc, attempt, error):",
            "        \"\"\"",
            "        Handles errors when trying to send an association down to a homeserver by",
            "        logging the error and scheduling a new attempt.",
            "",
            "        :param assoc: The association to send down to the homeserver.",
            "        :type assoc: dict[str, any]",
            "        :param attempt: The number of previous attempts to send this association.",
            "        :type attempt: int",
            "        :param error: The error that was raised when trying to send the association.",
            "        :type error: Exception",
            "        \"\"\"",
            "        logger.warning(",
            "            \"Error notifying on bind for %s: %s - rescheduling\", assoc[\"mxid\"], error",
            "        )",
            "        self.sydent.reactor.callLater(",
            "            math.pow(2, attempt), self._notify, assoc, attempt + 1",
            "        )",
            "",
            "    # The below is lovingly ripped off of synapse/http/endpoint.py",
            "",
            "    _Server = collections.namedtuple(\"_Server\", \"priority weight host port\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "35": [],
            "146": [
                "ThreepidBinder",
                "_notify"
            ],
            "148": [
                "ThreepidBinder",
                "_notify"
            ],
            "187": [
                "ThreepidBinder",
                "_notify"
            ]
        },
        "addLocation": []
    },
    "sydent/util/stringutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " # See the License for the specific language governing permissions and"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " # limitations under the License."
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import re"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from typing import Optional, Tuple"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from twisted.internet.abstract import isIPAddress, isIPv6Address"
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " # https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken"
            },
            "8": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " client_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")"
            },
            "9": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# hostname/domain name + optional port"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+# hostname/domain name"
            },
            "12": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " # https://regex101.com/r/OyN1lg/2"
            },
            "13": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " hostname_regex = re.compile("
            },
            "14": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\","
            },
            "15": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " def is_valid_hostname(string: str) -> bool:"
            },
            "18": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\"Validate that a given string is a valid hostname or domain name, with an"
            },
            "19": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    optional port number."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    \"\"\"Validate that a given string is a valid hostname or domain name."
            },
            "21": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     For domain names, this only validates that the form is right (for"
            },
            "23": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    instance, it doesn't check that the TLD is valid). If a port is"
            },
            "24": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    specified, it has to be a valid port number."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    instance, it doesn't check that the TLD is valid)."
            },
            "26": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     :param string: The string to validate"
            },
            "28": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     :type string: str"
            },
            "29": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     :rtype: bool"
            },
            "30": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     \"\"\""
            },
            "31": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    host_parts = string.split(\":\", 1)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    return hostname_regex.match(string) is not None"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+def parse_server_name(server_name: str) -> Tuple[str, Optional[int]]:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    \"\"\"Split a server name into host/port parts."
            },
            "38": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if len(host_parts) == 1:"
            },
            "40": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return hostname_regex.match(string) is not None"
            },
            "41": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "42": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        host, port = host_parts"
            },
            "43": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        valid_hostname = hostname_regex.match(host) is not None"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    No validation is done on the host part. The port part is validated to be"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    a valid port number."
            },
            "46": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    Args:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        server_name: server name to parse"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    Returns:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        host/port parts."
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    Raises:"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        ValueError if the server name could not be parsed."
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    \"\"\""
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    try:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        if server_name[-1] == \"]\":"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+            # ipv6 literal, hopefully"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            return server_name, None"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        host_port = server_name.rsplit(\":\", 1)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        host = host_port[0]"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        port = host_port[1] if host_port[1:] else None"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        if port:"
            },
            "67": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "             port_num = int(port)"
            },
            "68": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            valid_port = ("
            },
            "69": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                port == str(port_num)  # exclude things like '08090' or ' 8090'"
            },
            "70": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and 1 <= port_num < 65536)"
            },
            "71": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except ValueError:"
            },
            "72": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            valid_port = False"
            },
            "73": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return valid_hostname and valid_port"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            # exclude things like '08090' or ' 8090'"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            if port != str(port_num) or not (1 <= port_num < 65536):"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                raise ValueError(\"Invalid port\")"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        return host, port"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+    except Exception:"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        raise ValueError(\"Invalid server name '%s'\" % server_name)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+def is_valid_matrix_server_name(string: str) -> bool:"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    \"\"\"Validate that the given string is a valid Matrix server name."
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    A string is a valid Matrix server name if it is one of the following, plus"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    an optional port:"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    a. IPv4 address"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    b. IPv6 literal (`[IPV6_ADDRESS]`)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+    c. A valid hostname"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    :param string: The string to validate"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    :type string: str"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    :return: Whether the input is a valid Matrix server name"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+    :rtype: bool"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+    \"\"\""
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+    try:"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        host, port = parse_server_name(string)"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    except ValueError:"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        return False"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+    valid_ipv4_addr = isIPAddress(host)"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    valid_ipv6_literal = host[0] == \"[\" and host[-1] == \"]\" and isIPv6Address(host[1:-1])"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    return valid_ipv4_addr or valid_ipv6_literal or is_valid_hostname(host)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2020 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import re",
            "",
            "# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken",
            "client_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")",
            "",
            "# hostname/domain name + optional port",
            "# https://regex101.com/r/OyN1lg/2",
            "hostname_regex = re.compile(",
            "    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",",
            "    flags=re.IGNORECASE)",
            "",
            "",
            "def is_valid_client_secret(client_secret):",
            "    \"\"\"Validate that a given string matches the client_secret regex defined by the spec",
            "",
            "    :param client_secret: The client_secret to validate",
            "    :type client_secret: str",
            "",
            "    :return: Whether the client_secret is valid",
            "    :rtype: bool",
            "    \"\"\"",
            "    return client_secret_regex.match(client_secret) is not None",
            "",
            "",
            "def is_valid_hostname(string: str) -> bool:",
            "    \"\"\"Validate that a given string is a valid hostname or domain name, with an",
            "    optional port number.",
            "",
            "    For domain names, this only validates that the form is right (for",
            "    instance, it doesn't check that the TLD is valid). If a port is",
            "    specified, it has to be a valid port number.",
            "",
            "    :param string: The string to validate",
            "    :type string: str",
            "",
            "    :return: Whether the input is a valid hostname",
            "    :rtype: bool",
            "    \"\"\"",
            "",
            "    host_parts = string.split(\":\", 1)",
            "",
            "    if len(host_parts) == 1:",
            "        return hostname_regex.match(string) is not None",
            "    else:",
            "        host, port = host_parts",
            "        valid_hostname = hostname_regex.match(host) is not None",
            "",
            "        try:",
            "            port_num = int(port)",
            "            valid_port = (",
            "                port == str(port_num)  # exclude things like '08090' or ' 8090'",
            "                and 1 <= port_num < 65536)",
            "        except ValueError:",
            "            valid_port = False",
            "",
            "        return valid_hostname and valid_port"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2020 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import re",
            "from typing import Optional, Tuple",
            "",
            "from twisted.internet.abstract import isIPAddress, isIPv6Address",
            "",
            "# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken",
            "client_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")",
            "",
            "# hostname/domain name",
            "# https://regex101.com/r/OyN1lg/2",
            "hostname_regex = re.compile(",
            "    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",",
            "    flags=re.IGNORECASE)",
            "",
            "",
            "def is_valid_client_secret(client_secret):",
            "    \"\"\"Validate that a given string matches the client_secret regex defined by the spec",
            "",
            "    :param client_secret: The client_secret to validate",
            "    :type client_secret: str",
            "",
            "    :return: Whether the client_secret is valid",
            "    :rtype: bool",
            "    \"\"\"",
            "    return client_secret_regex.match(client_secret) is not None",
            "",
            "",
            "def is_valid_hostname(string: str) -> bool:",
            "    \"\"\"Validate that a given string is a valid hostname or domain name.",
            "",
            "    For domain names, this only validates that the form is right (for",
            "    instance, it doesn't check that the TLD is valid).",
            "",
            "    :param string: The string to validate",
            "    :type string: str",
            "",
            "    :return: Whether the input is a valid hostname",
            "    :rtype: bool",
            "    \"\"\"",
            "",
            "    return hostname_regex.match(string) is not None",
            "",
            "",
            "def parse_server_name(server_name: str) -> Tuple[str, Optional[int]]:",
            "    \"\"\"Split a server name into host/port parts.",
            "",
            "    No validation is done on the host part. The port part is validated to be",
            "    a valid port number.",
            "",
            "    Args:",
            "        server_name: server name to parse",
            "",
            "    Returns:",
            "        host/port parts.",
            "",
            "    Raises:",
            "        ValueError if the server name could not be parsed.",
            "    \"\"\"",
            "    try:",
            "        if server_name[-1] == \"]\":",
            "            # ipv6 literal, hopefully",
            "            return server_name, None",
            "",
            "        host_port = server_name.rsplit(\":\", 1)",
            "        host = host_port[0]",
            "        port = host_port[1] if host_port[1:] else None",
            "",
            "        if port:",
            "            port_num = int(port)",
            "",
            "            # exclude things like '08090' or ' 8090'",
            "            if port != str(port_num) or not (1 <= port_num < 65536):",
            "                raise ValueError(\"Invalid port\")",
            "",
            "        return host, port",
            "    except Exception:",
            "        raise ValueError(\"Invalid server name '%s'\" % server_name)",
            "",
            "",
            "def is_valid_matrix_server_name(string: str) -> bool:",
            "    \"\"\"Validate that the given string is a valid Matrix server name.",
            "",
            "    A string is a valid Matrix server name if it is one of the following, plus",
            "    an optional port:",
            "",
            "    a. IPv4 address",
            "    b. IPv6 literal (`[IPV6_ADDRESS]`)",
            "    c. A valid hostname",
            "",
            "    :param string: The string to validate",
            "    :type string: str",
            "",
            "    :return: Whether the input is a valid Matrix server name",
            "    :rtype: bool",
            "    \"\"\"",
            "",
            "    try:",
            "        host, port = parse_server_name(string)",
            "    except ValueError:",
            "        return False",
            "",
            "    valid_ipv4_addr = isIPAddress(host)",
            "    valid_ipv6_literal = host[0] == \"[\" and host[-1] == \"]\" and isIPv6Address(host[1:-1])",
            "",
            "    return valid_ipv4_addr or valid_ipv6_literal or is_valid_hostname(host)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "20": [],
            "40": [
                "is_valid_hostname"
            ],
            "41": [
                "is_valid_hostname"
            ],
            "44": [
                "is_valid_hostname"
            ],
            "45": [
                "is_valid_hostname"
            ],
            "54": [
                "is_valid_hostname"
            ],
            "56": [
                "is_valid_hostname"
            ],
            "57": [
                "is_valid_hostname"
            ],
            "58": [
                "is_valid_hostname"
            ],
            "59": [
                "is_valid_hostname"
            ],
            "60": [
                "is_valid_hostname"
            ],
            "62": [
                "is_valid_hostname"
            ],
            "64": [
                "is_valid_hostname"
            ],
            "65": [
                "is_valid_hostname"
            ],
            "66": [
                "is_valid_hostname"
            ],
            "67": [
                "is_valid_hostname"
            ],
            "68": [
                "is_valid_hostname"
            ],
            "70": [
                "is_valid_hostname"
            ]
        },
        "addLocation": []
    }
}