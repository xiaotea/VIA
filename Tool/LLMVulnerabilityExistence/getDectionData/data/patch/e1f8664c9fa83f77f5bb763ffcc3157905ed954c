{
    "nova/tests/virt/vmwareapi/test_driver_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1482,
                "afterPatchRowNumber": 1482,
                "PatchRowcode": "             self.conn.destroy(self.context, self.instance,"
            },
            "1": {
                "beforePatchRowNumber": 1483,
                "afterPatchRowNumber": 1483,
                "PatchRowcode": "                               self.network_info,"
            },
            "2": {
                "beforePatchRowNumber": 1484,
                "afterPatchRowNumber": 1484,
                "PatchRowcode": "                               None, True)"
            },
            "3": {
                "beforePatchRowNumber": 1485,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            mock_get.assert_called_once_with(self.conn._vmops._session,"
            },
            "4": {
                "beforePatchRowNumber": 1486,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                             self.instance['uuid'])"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1485,
                "PatchRowcode": "+            mock_get.assert_called_with(self.conn._vmops._session,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1486,
                "PatchRowcode": "+                                        self.instance['uuid'])"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1487,
                "PatchRowcode": "+            expected_args = [((self.conn._vmops._session,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1488,
                "PatchRowcode": "+                               self.instance['uuid'] + '-orig'),),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1489,
                "PatchRowcode": "+                             ((self.conn._vmops._session,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1490,
                "PatchRowcode": "+                               self.instance['uuid']),)]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1491,
                "PatchRowcode": "+            # one for VM named uuid-orig, one for VM named uuid"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1492,
                "PatchRowcode": "+            self.assertEqual(expected_args, mock_get.call_args_list)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1493,
                "PatchRowcode": "+            self.assertEqual(2, mock_get.call_count)"
            },
            "14": {
                "beforePatchRowNumber": 1487,
                "afterPatchRowNumber": 1494,
                "PatchRowcode": "             self.assertFalse(mock_call.called)"
            },
            "15": {
                "beforePatchRowNumber": 1488,
                "afterPatchRowNumber": 1495,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 1489,
                "afterPatchRowNumber": 1496,
                "PatchRowcode": "     def _rescue(self, config_drive=False):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Test suite for VMwareAPI.",
            "\"\"\"",
            "",
            "import collections",
            "import contextlib",
            "import copy",
            "import datetime",
            "",
            "from eventlet import greenthread",
            "import mock",
            "import mox",
            "from oslo.config import cfg",
            "from oslo.vmware import exceptions as vexc",
            "from oslo.vmware import vim",
            "import suds",
            "",
            "from nova import block_device",
            "from nova.compute import api as compute_api",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import exception",
            "from nova.image import glance",
            "from nova.network import model as network_model",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import test",
            "from nova.tests import fake_instance",
            "import nova.tests.image.fake",
            "from nova.tests import matchers",
            "from nova.tests import test_flavors",
            "from nova.tests import utils",
            "from nova.tests.virt.vmwareapi import fake as vmwareapi_fake",
            "from nova.tests.virt.vmwareapi import stubs",
            "from nova import utils as nova_utils",
            "from nova.virt import driver as v_driver",
            "from nova.virt.vmwareapi import constants",
            "from nova.virt.vmwareapi import driver",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vif",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmops",
            "from nova.virt.vmwareapi import vmware_images",
            "from nova.virt.vmwareapi import volumeops",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('remove_unused_original_minimum_age_seconds',",
            "                'nova.virt.imagecache')",
            "",
            "",
            "class fake_vm_ref(object):",
            "    def __init__(self):",
            "        self.value = 4",
            "        self._type = 'VirtualMachine'",
            "",
            "",
            "class fake_service_content(object):",
            "    def __init__(self):",
            "        self.ServiceContent = vmwareapi_fake.DataObject()",
            "        self.ServiceContent.fake = 'fake'",
            "",
            "",
            "class VMwareSudsTest(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(VMwareSudsTest, self).setUp()",
            "",
            "        def new_client_init(self, url, **kwargs):",
            "            return",
            "",
            "        mock.patch.object(suds.client.Client,",
            "                          '__init__', new=new_client_init).start()",
            "        self.vim = self._vim_create()",
            "        self.addCleanup(mock.patch.stopall)",
            "",
            "    def _mock_getattr(self, attr_name):",
            "        self.assertEqual(\"RetrieveServiceContent\", attr_name)",
            "        return lambda obj, **kwargs: fake_service_content()",
            "",
            "    def _vim_create(self):",
            "        with mock.patch.object(vim.Vim, '__getattr__', self._mock_getattr):",
            "            return vim.Vim()",
            "",
            "    def test_exception_with_deepcopy(self):",
            "        self.assertIsNotNone(self.vim)",
            "        self.assertRaises(vexc.VimException,",
            "                          copy.deepcopy, self.vim)",
            "",
            "",
            "def _fake_create_session(inst):",
            "    session = vmwareapi_fake.DataObject()",
            "    session.key = 'fake_key'",
            "    session.userName = 'fake_username'",
            "    inst._session = session",
            "",
            "",
            "class VMwareDriverStartupTestCase(test.NoDBTestCase):",
            "    def _start_driver_with_flags(self, expected_exception_type, startup_flags):",
            "        self.flags(**startup_flags)",
            "        with mock.patch(",
            "                'nova.virt.vmwareapi.driver.VMwareAPISession.__init__'):",
            "            e = self.assertRaises(",
            "                    Exception, driver.VMwareVCDriver, None)  # noqa",
            "            self.assertIs(type(e), expected_exception_type)",
            "",
            "    def test_start_driver_no_user(self):",
            "        self._start_driver_with_flags(",
            "                Exception,",
            "                dict(host_ip='ip', host_password='password',",
            "                     group='vmware'))",
            "",
            "    def test_start_driver_no_host(self):",
            "        self._start_driver_with_flags(",
            "                Exception,",
            "                dict(host_username='username', host_password='password',",
            "                     group='vmware'))",
            "",
            "    def test_start_driver_no_password(self):",
            "        self._start_driver_with_flags(",
            "                Exception,",
            "                dict(host_ip='ip', host_username='username',",
            "                     group='vmware'))",
            "",
            "    def test_start_driver_with_user_host_password(self):",
            "        # Getting the InvalidInput exception signifies that no exception",
            "        # is raised regarding missing user/password/host",
            "        self._start_driver_with_flags(",
            "                nova.exception.InvalidInput,",
            "                dict(host_ip='ip', host_password='password',",
            "                     host_username=\"user\", datastore_regex=\"bad(regex\",",
            "                     group='vmware'))",
            "",
            "",
            "class VMwareSessionTestCase(test.NoDBTestCase):",
            "",
            "    @mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                       return_value=False)",
            "    def test_call_method(self, mock_is_vim):",
            "        with contextlib.nested(",
            "                mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                                  _fake_create_session),",
            "                mock.patch.object(driver.VMwareAPISession, 'invoke_api'),",
            "        ) as (fake_create, fake_invoke):",
            "            session = driver.VMwareAPISession()",
            "            session._vim = mock.Mock()",
            "            module = mock.Mock()",
            "            session._call_method(module, 'fira')",
            "            fake_invoke.assert_called_once_with(module, 'fira', session._vim)",
            "",
            "    @mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                       return_value=True)",
            "    def test_call_method_vim(self, mock_is_vim):",
            "        with contextlib.nested(",
            "                mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                                  _fake_create_session),",
            "                mock.patch.object(driver.VMwareAPISession, 'invoke_api'),",
            "        ) as (fake_create, fake_invoke):",
            "            session = driver.VMwareAPISession()",
            "            module = mock.Mock()",
            "            session._call_method(module, 'fira')",
            "            fake_invoke.assert_called_once_with(module, 'fira')",
            "",
            "",
            "class VMwareAPIVMTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for Vmware API connection calls.\"\"\"",
            "",
            "    def setUp(self, create_connection=True):",
            "        super(VMwareAPIVMTestCase, self).setUp()",
            "        vm_util.vm_refs_cache_reset()",
            "        self.context = context.RequestContext('fake', 'fake', is_admin=False)",
            "        cluster_name = 'test_cluster'",
            "        cluster_name2 = 'test_cluster2'",
            "        self.flags(cluster_name=[cluster_name, cluster_name2],",
            "                   host_ip='test_url',",
            "                   host_username='test_username',",
            "                   host_password='test_pass',",
            "                   api_retry_count=1,",
            "                   use_linked_clone=False, group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base',",
            "                   my_ip='')",
            "        self.user_id = 'fake'",
            "        self.project_id = 'fake'",
            "        self.context = context.RequestContext(self.user_id, self.project_id)",
            "        stubs.set_stubs(self.stubs)",
            "        vmwareapi_fake.reset()",
            "        nova.tests.image.fake.stub_out_image_service(self.stubs)",
            "        if create_connection:",
            "            self.conn = driver.VMwareVCDriver(None, False)",
            "            self._set_exception_vars()",
            "            self.node_name = self.conn._resources.keys()[0]",
            "            self.node_name2 = self.conn._resources.keys()[1]",
            "            if cluster_name2 in self.node_name2:",
            "                self.ds = 'ds1'",
            "            else:",
            "                self.ds = 'ds2'",
            "",
            "        self.vim = vmwareapi_fake.FakeVim()",
            "",
            "        # NOTE(vish): none of the network plugging code is actually",
            "        #             being tested",
            "        self.network_info = utils.get_test_network_info()",
            "        image_ref = nova.tests.image.fake.get_valid_image_id()",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "            self.context, image_ref)",
            "        metadata = image_service.show(self.context, image_id)",
            "        self.image = {",
            "            'id': image_ref,",
            "            'disk_format': 'vmdk',",
            "            'size': int(metadata['size']),",
            "        }",
            "        self.fake_image_uuid = self.image['id']",
            "        nova.tests.image.fake.stub_out_image_service(self.stubs)",
            "        self.vnc_host = 'ha-host'",
            "        self.instance_without_compute = {'node': None,",
            "                                         'vm_state': 'building',",
            "                                         'project_id': 'fake',",
            "                                         'user_id': 'fake',",
            "                                         'name': '1',",
            "                                         'display_description': '1',",
            "                                         'kernel_id': '1',",
            "                                         'ramdisk_id': '1',",
            "                                         'mac_addresses': [",
            "                                            {'address': 'de:ad:be:ef:be:ef'}",
            "                                         ],",
            "                                         'memory_mb': 8192,",
            "                                         'instance_type': 'm1.large',",
            "                                         'vcpus': 4,",
            "                                         'root_gb': 80,",
            "                                         'image_ref': self.image['id'],",
            "                                         'host': 'fake_host',",
            "                                         'task_state':",
            "                                         'scheduling',",
            "                                         'reservation_id': 'r-3t8muvr0',",
            "                                         'id': 1,",
            "                                         'uuid': 'fake-uuid',",
            "                                         'metadata': []}",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVMTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "        nova.tests.image.fake.FakeImageService_reset()",
            "",
            "    def test_get_host_ip_addr(self):",
            "        self.assertEqual('test_url', self.conn.get_host_ip_addr())",
            "",
            "    def test_init_host_with_no_session(self):",
            "        self.conn._session = mock.Mock()",
            "        self.conn._session.vim = None",
            "        self.conn.init_host('fake_host')",
            "        self.conn._session._create_session.assert_called_once_with()",
            "",
            "    def test_init_host(self):",
            "        try:",
            "            self.conn.init_host(\"fake_host\")",
            "        except Exception as ex:",
            "            self.fail(\"init_host raised: %s\" % ex)",
            "",
            "    def _set_exception_vars(self):",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        self.exception = False",
            "",
            "    def test_cleanup_host(self):",
            "        self.conn.init_host(\"fake_host\")",
            "        try:",
            "            self.conn.cleanup_host(\"fake_host\")",
            "        except Exception as ex:",
            "            self.fail(\"cleanup_host raised: %s\" % ex)",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_cleanup_host_direct(self, mock_init):",
            "        mock_init.return_value = None",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        vcdriver.cleanup_host(\"foo\")",
            "        vcdriver._session.vim.client.service.Logout.assert_called_once_with(",
            "            vcdriver._session.vim.service_content.sessionManager",
            "        )",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_cleanup_host_direct_with_bad_logout(self, mock_init):",
            "        mock_init.return_value = None",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        fault = suds.WebFault(mock.Mock(), mock.Mock())",
            "        vcdriver._session.vim.client.service.Logout.side_effect = fault",
            "        vcdriver.cleanup_host(\"foo\")",
            "",
            "    def test_driver_capabilities(self):",
            "        self.assertTrue(self.conn.capabilities['has_imagecache'])",
            "        self.assertFalse(self.conn.capabilities['supports_recreate'])",
            "",
            "    def test_login_retries(self):",
            "        self.attempts = 0",
            "        self.login_session = vmwareapi_fake.FakeVim()._login()",
            "",
            "        def _fake_login(_self):",
            "            self.attempts += 1",
            "            if self.attempts == 1:",
            "                raise vexc.VimConnectionException('Here is my fake exception')",
            "            return self.login_session",
            "",
            "        def _fake_check_session(_self):",
            "            return True",
            "",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_login', _fake_login)",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_check_session',",
            "                       _fake_check_session)",
            "",
            "        with mock.patch.object(greenthread, 'sleep'):",
            "            self.conn = driver.VMwareAPISession()",
            "        self.assertEqual(self.attempts, 2)",
            "",
            "    def _get_instance_type_by_name(self, type):",
            "        for instance_type in test_flavors.DEFAULT_FLAVORS:",
            "            if instance_type['name'] == type:",
            "                return instance_type",
            "        if type == 'm1.micro':",
            "            return {'memory_mb': 128, 'root_gb': 0, 'deleted_at': None,",
            "                    'name': 'm1.micro', 'deleted': 0, 'created_at': None,",
            "                    'ephemeral_gb': 0, 'updated_at': None,",
            "                    'disabled': False, 'vcpus': 1, 'extra_specs': {},",
            "                    'swap': 0, 'rxtx_factor': 1.0, 'is_public': True,",
            "                    'flavorid': '1', 'vcpu_weight': None, 'id': 2}",
            "",
            "    def _create_instance(self, node=None, set_image_ref=True,",
            "                         uuid=None, instance_type='m1.large'):",
            "        if not node:",
            "            node = self.node_name",
            "        if not uuid:",
            "            uuid = uuidutils.generate_uuid()",
            "        self.type_data = self._get_instance_type_by_name(instance_type)",
            "        values = {'name': 'fake_name',",
            "                  'id': 1,",
            "                  'uuid': uuid,",
            "                  'project_id': self.project_id,",
            "                  'user_id': self.user_id,",
            "                  'kernel_id': \"fake_kernel_uuid\",",
            "                  'ramdisk_id': \"fake_ramdisk_uuid\",",
            "                  'mac_address': \"de:ad:be:ef:be:ef\",",
            "                  'flavor': instance_type,",
            "                  'node': node,",
            "                  'memory_mb': self.type_data['memory_mb'],",
            "                  'root_gb': self.type_data['root_gb'],",
            "                  'ephemeral_gb': self.type_data['ephemeral_gb'],",
            "                  'vcpus': self.type_data['vcpus'],",
            "                  'swap': self.type_data['swap'],",
            "                  'expected_attrs': ['system_metadata'],",
            "        }",
            "        if set_image_ref:",
            "            values['image_ref'] = self.fake_image_uuid",
            "        self.instance_node = node",
            "        self.uuid = uuid",
            "        self.instance = fake_instance.fake_instance_obj(",
            "                self.context, **values)",
            "",
            "    def _create_vm(self, node=None, num_instances=1, uuid=None,",
            "                   instance_type='m1.large', powered_on=True):",
            "        \"\"\"Create and spawn the VM.\"\"\"",
            "        if not node:",
            "            node = self.node_name",
            "        self._create_instance(node=node, uuid=uuid,",
            "                              instance_type=instance_type)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=None)",
            "        self._check_vm_record(num_instances=num_instances,",
            "                              powered_on=powered_on)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def _get_vm_record(self):",
            "        # Get record for VM",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        for vm in vms.objects:",
            "            if vm.get('name') == self.uuid:",
            "                return vm",
            "        self.fail('Unable to find VM backing!')",
            "",
            "    def _check_vm_record(self, num_instances=1, powered_on=True):",
            "        \"\"\"Check if the spawned VM's properties correspond to the instance in",
            "        the db.",
            "        \"\"\"",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), num_instances)",
            "",
            "        # Get Nova record for VM",
            "        vm_info = self.conn.get_info({'uuid': self.uuid,",
            "                                      'name': 1,",
            "                                      'node': self.instance_node})",
            "",
            "        vm = self._get_vm_record()",
            "",
            "        # Check that m1.large above turned into the right thing.",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        vcpus = self.type_data['vcpus']",
            "        self.assertEqual(vm_info['max_mem'], mem_kib)",
            "        self.assertEqual(vm_info['mem'], mem_kib)",
            "        self.assertEqual(vm.get(\"summary.config.instanceUuid\"), self.uuid)",
            "        self.assertEqual(vm.get(\"summary.config.numCpu\"), vcpus)",
            "        self.assertEqual(vm.get(\"summary.config.memorySizeMB\"),",
            "                         self.type_data['memory_mb'])",
            "",
            "        self.assertEqual(",
            "            vm.get(\"config.hardware.device\").VirtualDevice[2].obj_name,",
            "            \"ns0:VirtualE1000\")",
            "        if powered_on:",
            "            # Check that the VM is running according to Nova",
            "            self.assertEqual(power_state.RUNNING, vm_info['state'])",
            "",
            "            # Check that the VM is running according to vSphere API.",
            "            self.assertEqual('poweredOn', vm.get(\"runtime.powerState\"))",
            "        else:",
            "            # Check that the VM is not running according to Nova",
            "            self.assertEqual(power_state.SHUTDOWN, vm_info['state'])",
            "",
            "            # Check that the VM is not running according to vSphere API.",
            "            self.assertEqual('poweredOff', vm.get(\"runtime.powerState\"))",
            "",
            "        found_vm_uuid = False",
            "        found_iface_id = False",
            "        extras = vm.get(\"config.extraConfig\")",
            "        for c in extras.OptionValue:",
            "            if (c.key == \"nvp.vm-uuid\" and c.value == self.instance['uuid']):",
            "                found_vm_uuid = True",
            "            if (c.key == \"nvp.iface-id.0\" and c.value == \"vif-xxx-yyy-zzz\"):",
            "                found_iface_id = True",
            "",
            "        self.assertTrue(found_vm_uuid)",
            "        self.assertTrue(found_iface_id)",
            "",
            "    def _check_vm_info(self, info, pwr_state=power_state.RUNNING):",
            "        \"\"\"Check if the get_info returned values correspond to the instance",
            "        object in the db.",
            "        \"\"\"",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        self.assertEqual(info[\"state\"], pwr_state)",
            "        self.assertEqual(info[\"max_mem\"], mem_kib)",
            "        self.assertEqual(info[\"mem\"], mem_kib)",
            "        self.assertEqual(info[\"num_cpu\"], self.type_data['vcpus'])",
            "",
            "    def test_instance_exists(self):",
            "        self._create_vm()",
            "        self.assertTrue(self.conn.instance_exists(self.instance))",
            "        invalid_instance = dict(uuid='foo', name='bar', node=self.node_name)",
            "        self.assertFalse(self.conn.instance_exists(invalid_instance))",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_list_instances_1(self):",
            "        self._create_vm()",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "",
            "    def test_list_instance_uuids(self):",
            "        self._create_vm()",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 1)",
            "",
            "    def test_list_instance_uuids_invalid_uuid(self):",
            "        self._create_vm(uuid='fake_id')",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 0)",
            "",
            "    def _cached_files_exist(self, exists=True):",
            "        cache = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                      self.fake_image_uuid,",
            "                                      '%s.vmdk' % self.fake_image_uuid)",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(str(cache)))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(str(cache)))",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_instance_dir_disk_created(self, mock_from_image):",
            "        \"\"\"Test image file is cached when even when use_linked_clone",
            "            is False",
            "        \"\"\"",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            linked_clone=False)",
            "",
            "        mock_from_image.return_value = img_props",
            "        self._create_vm()",
            "        path = ds_util.DatastorePath(self.ds, self.uuid, '%s.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "        self._cached_files_exist()",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_cache_dir_disk_created(self, mock_from_image):",
            "        \"\"\"Test image disk is cached when use_linked_clone is True.\"\"\"",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=1 * units.Ki,",
            "            disk_type=constants.DISK_TYPE_SPARSE)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        self._create_vm()",
            "        path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.vmdk' % self.fake_image_uuid)",
            "        root = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.80.vmdk' % self.fake_image_uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "        self.assertTrue(vmwareapi_fake.get_file(str(root)))",
            "",
            "    def _iso_disk_type_created(self, instance_type='m1.large'):",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm(instance_type=instance_type)",
            "        path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.iso' % self.fake_image_uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "",
            "    def test_iso_disk_type_created(self):",
            "        self._iso_disk_type_created()",
            "        path = ds_util.DatastorePath(self.ds, self.uuid, '%s.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "",
            "    def test_iso_disk_type_created_with_root_gb_0(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        path = ds_util.DatastorePath(self.ds, self.uuid, '%s.vmdk' % self.uuid)",
            "        self.assertFalse(vmwareapi_fake.get_file(str(path)))",
            "",
            "    def test_iso_disk_cdrom_attach(self):",
            "        iso_path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                         self.fake_image_uuid,",
            "                                         '%s.iso' % self.fake_image_uuid)",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, str(iso_path))",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_iso_disk_cdrom_attach_with_config_drive(self,",
            "                                                     mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=80 * units.Gi,",
            "            file_type='iso',",
            "            linked_clone=False)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        self.flags(force_config_drive=True)",
            "        iso_path = [",
            "            ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                  self.fake_image_uuid,",
            "                                  '%s.iso' % self.fake_image_uuid),",
            "            ds_util.DatastorePath(self.ds, 'fake-config-drive')]",
            "        self.iso_index = 0",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, str(iso_path[self.iso_index]))",
            "            self.iso_index += 1",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "        self.assertEqual(self.iso_index, 2)",
            "",
            "    def test_cdrom_attach_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "",
            "        iso_path = ds_util.DatastorePath(self.ds, 'fake-config-drive')",
            "        self.cd_attach_called = False",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, str(iso_path))",
            "            self.cd_attach_called = True",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "        self.assertTrue(self.cd_attach_called)",
            "",
            "    def test_spawn(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_vm_ref_cached(self):",
            "        uuid = uuidutils.generate_uuid()",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(uuid))",
            "        self._create_vm(uuid=uuid)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get(uuid))",
            "",
            "    def _spawn_power_state(self, power_on):",
            "        self._spawn = self.conn._vmops.spawn",
            "        self._power_on = power_on",
            "",
            "        def _fake_spawn(context, instance, image_meta, injected_files,",
            "            admin_password, network_info, block_device_info=None,",
            "            instance_name=None, power_on=True):",
            "            return self._spawn(context, instance, image_meta,",
            "                               injected_files, admin_password, network_info,",
            "                               block_device_info=block_device_info,",
            "                               instance_name=instance_name,",
            "                               power_on=self._power_on)",
            "",
            "        with (",
            "            mock.patch.object(self.conn._vmops, 'spawn', _fake_spawn)",
            "        ):",
            "            self._create_vm(powered_on=power_on)",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            if power_on:",
            "                self._check_vm_info(info, power_state.RUNNING)",
            "            else:",
            "                self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "    def test_spawn_no_power_on(self):",
            "        self._spawn_power_state(False)",
            "",
            "    def test_spawn_power_on(self):",
            "        self._spawn_power_state(True)",
            "",
            "    def test_spawn_root_size_0(self):",
            "        self._create_vm(instance_type='m1.micro')",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        cache = ('[%s] vmware_base/%s/%s.vmdk' %",
            "                 (self.ds, self.fake_image_uuid, self.fake_image_uuid))",
            "        gb_cache = ('[%s] vmware_base/%s/%s.0.vmdk' %",
            "                    (self.ds, self.fake_image_uuid, self.fake_image_uuid))",
            "        self.assertTrue(vmwareapi_fake.get_file(cache))",
            "        self.assertFalse(vmwareapi_fake.get_file(gb_cache))",
            "",
            "    def _spawn_with_delete_exception(self, fault=None):",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=fault)",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            if fault:",
            "                self._create_vm()",
            "                info = self.conn.get_info({'uuid': self.uuid,",
            "                                           'node': self.instance_node})",
            "                self._check_vm_info(info, power_state.RUNNING)",
            "            else:",
            "                self.assertRaises(vexc.VMwareDriverException, self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_delete_exception_not_found(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileNotFound())",
            "",
            "    def test_spawn_with_delete_exception_file_fault(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileFault())",
            "",
            "    def test_spawn_with_delete_exception_cannot_delete_file(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.CannotDeleteFile())",
            "",
            "    def test_spawn_with_delete_exception_file_locked(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileLocked())",
            "",
            "    def test_spawn_with_delete_exception_general(self):",
            "        self._spawn_with_delete_exception()",
            "",
            "    def test_spawn_disk_extend(self):",
            "        self.mox.StubOutWithMock(self.conn._vmops, '_extend_virtual_disk')",
            "        requested_size = 80 * units.Mi",
            "        self.conn._vmops._extend_virtual_disk(mox.IgnoreArg(),",
            "                requested_size, mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_disk_extend_exists(self):",
            "        root = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.80.vmdk' % self.fake_image_uuid)",
            "",
            "        def _fake_extend(instance, requested_size, name, dc_ref):",
            "            vmwareapi_fake._add_file(str(root))",
            "",
            "        self.stubs.Set(self.conn._vmops, '_extend_virtual_disk',",
            "                       _fake_extend)",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(root)))",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_disk_extend_sparse(self, mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=units.Ki,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=True)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._vmops, '_extend_virtual_disk'),",
            "            mock.patch.object(self.conn._vmops, 'get_datacenter_ref_and_name'),",
            "        ) as (mock_extend, mock_get_dc):",
            "            dc_val = mock.Mock()",
            "            dc_val.ref = \"fake_dc_ref\"",
            "            dc_val.name = \"dc1\"",
            "            mock_get_dc.return_value = dc_val",
            "            self._create_vm()",
            "            iid = img_props.image_id",
            "            cached_image = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                                 iid, '%s.80.vmdk' % iid)",
            "            mock_extend.assert_called_once_with(",
            "                    self.instance, self.instance.root_gb * units.Mi,",
            "                    str(cached_image), \"fake_dc_ref\")",
            "",
            "    def test_spawn_disk_extend_failed_copy(self):",
            "        # Spawn instance",
            "        # copy for extend fails without creating a file",
            "        #",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "",
            "        CopyError = vexc.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == 'fake-copy-task':",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                return 'fake-copy-task'",
            "",
            "            return self.call_method(module, method, *args, **kwargs)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaving a file behind",
            "        #",
            "        # Expect the file to be cleaned up",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.task_ref = None",
            "        uuid = self.fake_image_uuid",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = vexc.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "        self.assertFalse(vmwareapi_fake.get_file(cached_image))",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy_failed_cleanup(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaves file behind",
            "        # File cleanup fails",
            "        #",
            "        # Expect file to be left behind",
            "        # Expect file cleanup error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.task_ref = None",
            "        uuid = self.fake_image_uuid",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = vexc.FileFaultException",
            "        DeleteError = vexc.CannotDeleteFileException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            elif task_ref == 'fake-delete-task':",
            "                raise DeleteError('Delete failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                return 'fake-delete-task'",
            "",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method)):",
            "            self.assertRaises(DeleteError, self._create_vm)",
            "        self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_disk_invalid_disk_size(self, mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=82 * units.Gi,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=True)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        self.assertRaises(exception.InstanceUnacceptable,",
            "                          self._create_vm)",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_disk_extend_insufficient_disk_space(self, mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=1024,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=True)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        cached_image = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                             self.fake_image_uuid,",
            "                                             '%s.80.vmdk' %",
            "                                              self.fake_image_uuid)",
            "        tmp_file = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                         self.fake_image_uuid,",
            "                                         '%s.80-flat.vmdk' %",
            "                                          self.fake_image_uuid)",
            "",
            "        NoDiskSpace = vexc.get_fault_class('NoDiskSpace')",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                raise NoDiskSpace()",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == 'ExtendVirtualDisk_Task':",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (mock_wait_for_task, mock_call_method):",
            "            self.assertRaises(NoDiskSpace, self._create_vm)",
            "            self.assertFalse(vmwareapi_fake.get_file(str(cached_image)))",
            "            self.assertFalse(vmwareapi_fake.get_file(str(tmp_file)))",
            "",
            "    def test_spawn_with_move_file_exists_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise an file exists exception. The flag",
            "        # self.exception will be checked to see that",
            "        # the exception has indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise vexc.FileAlreadyExistsException()",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_general_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a general exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise vexc.VMwareDriverException('Exception!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self.assertRaises(vexc.VMwareDriverException,",
            "                              self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_poll_exception(self):",
            "        self.call_method = self.conn._session._call_method",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\")",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self.assertRaises(vexc.VMwareDriverException,",
            "                              self._create_vm)",
            "",
            "    def test_spawn_with_move_file_exists_poll_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a file exists exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=vmwareapi_fake.FileAlreadyExists())",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def _spawn_attach_volume_vmdk(self, set_image_ref=True, vc_support=False):",
            "        self._create_instance(set_image_ref=set_image_ref)",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        if vc_support:",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_get_res_pool_of_vm')",
            "            volumeops.VMwareVolumeOps._get_res_pool_of_vm(",
            "                     mox.IgnoreArg()).AndReturn('fake_res_pool')",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_relocate_vmdk_volume')",
            "            volumeops.VMwareVolumeOps._relocate_vmdk_volume(mox.IgnoreArg(),",
            "                     'fake_res_pool', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def test_spawn_attach_volume_iscsi(self):",
            "        self._create_instance()",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def mock_upload_image(self, context, image, instance, **kwargs):",
            "        self.assertEqual(image, 'Test-Snapshot')",
            "        self.assertEqual(instance, self.instance)",
            "        self.assertEqual(kwargs['disk_type'], 'preallocated')",
            "",
            "    def test_get_vm_ref_using_extra_config(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        # Disrupt the fake Virtual Machine object so that extraConfig",
            "        # cannot be matched.",
            "        fake_vm = self._get_vm_record()",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"\"",
            "        # We should not get a Virtual Machine through extraConfig.",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNone(vm_ref, 'VM Reference should be none')",
            "        # Check if we can find the Virtual Machine using the name.",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def test_search_vm_ref_by_identifier(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self.conn._session,",
            "                                            self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        fake_vm = self._get_vm_record()",
            "        fake_vm.set(\"summary.config.instanceUuid\", \"foo\")",
            "        fake_vm.set(\"name\", \"foo\")",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"foo\"",
            "        self.assertIsNone(vm_util.search_vm_ref_by_identifier(",
            "                                    self.conn._session, self.instance['uuid']),",
            "                          \"VM Reference should be none\")",
            "        self.assertIsNotNone(",
            "                vm_util.search_vm_ref_by_identifier(self.conn._session, \"foo\"),",
            "                \"VM Reference should not be none\")",
            "",
            "    def test_get_object_for_optionvalue(self):",
            "        self._create_vm()",
            "        vms = self.conn._session._call_method(vim_util, \"get_objects\",",
            "                \"VirtualMachine\", ['config.extraConfig[\"nvp.vm-uuid\"]'])",
            "        vm_ref = vm_util._get_object_for_optionvalue(vms,",
            "                                                     self.instance[\"uuid\"])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def _test_snapshot(self):",
            "        expected_calls = [",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_PENDING_UPLOAD}},",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_UPLOADING,",
            "                  'expected_state': task_states.IMAGE_PENDING_UPLOAD}}]",
            "        func_call_matcher = matchers.FunctionCallMatcher(expected_calls)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        with mock.patch.object(vmware_images, 'upload_image',",
            "                               self.mock_upload_image):",
            "            self.conn.snapshot(self.context, self.instance, \"Test-Snapshot\",",
            "                               func_call_matcher.call)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertIsNone(func_call_matcher.match())",
            "",
            "    def test_snapshot(self):",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_no_root_disk(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        self.assertRaises(error_util.NoRootDiskDefined, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_delete_vm_snapshot(self):",
            "        self._create_vm()",
            "        fake_vm = self._get_vm_record()",
            "        snapshot_ref = vmwareapi_fake.ManagedObjectReference(",
            "                               value=\"Snapshot-123\",",
            "                               name=\"VirtualMachineSnapshot\")",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_create_vm_snapshot')",
            "        self.conn._vmops._create_vm_snapshot(",
            "                self.instance, fake_vm.obj).AndReturn(snapshot_ref)",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_delete_vm_snapshot')",
            "        self.conn._vmops._delete_vm_snapshot(",
            "                self.instance, fake_vm.obj, snapshot_ref).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        self._test_snapshot()",
            "",
            "    def _snapshot_delete_vm_snapshot_exception(self, exception, call_count=1):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0].obj",
            "        snapshot_ref = vmwareapi_fake.ManagedObjectReference(",
            "                               value=\"Snapshot-123\",",
            "                               name=\"VirtualMachineSnapshot\")",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              side_effect=exception),",
            "            mock.patch.object(vmops, '_time_sleep_wrapper')",
            "        ) as (_fake_wait, _fake_sleep):",
            "            if exception != error_util.TaskInProgress:",
            "                self.assertRaises(exception,",
            "                                  self.conn._vmops._delete_vm_snapshot,",
            "                                  self.instance, fake_vm, snapshot_ref)",
            "                self.assertEqual(0, _fake_sleep.call_count)",
            "            else:",
            "                self.conn._vmops._delete_vm_snapshot(self.instance, fake_vm,",
            "                                                     snapshot_ref)",
            "                self.assertEqual(call_count - 1, _fake_sleep.call_count)",
            "            self.assertEqual(call_count, _fake_wait.call_count)",
            "",
            "    def test_snapshot_delete_vm_snapshot_exception(self):",
            "        self._snapshot_delete_vm_snapshot_exception(exception.NovaException)",
            "",
            "    def test_snapshot_delete_vm_snapshot_exception_retry(self):",
            "        self.flags(api_retry_count=5, group='vmware')",
            "        self._snapshot_delete_vm_snapshot_exception(error_util.TaskInProgress,",
            "                                                    5)",
            "",
            "    def test_reboot(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_with_uuid(self):",
            "        \"\"\"Test fall back to use name when can't find by uuid.\"\"\"",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_poll_rebooting_instances(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'reboot')",
            "        compute_api.API.reboot(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                               mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        instances = [self.instance]",
            "        self.conn.poll_rebooting_instances(60, instances)",
            "",
            "    def test_reboot_not_poweredon(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.assertRaises(exception.InstanceRebootFailure, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_suspend(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "",
            "    def test_suspend_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.suspend,",
            "                          self.instance)",
            "",
            "    def test_resume(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.conn.resume(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_resume_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_resume_not_suspended(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertRaises(exception.InstanceResumeFailure, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_on(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.conn.power_on(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_power_on_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_on,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_off(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "    def test_power_off_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_off,",
            "                          self.instance)",
            "",
            "    def test_resume_state_on_host_boot(self):",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, \"reboot\")",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOff\")",
            "        self.conn.reboot(self.context, self.instance, 'network_info',",
            "            'hard', None)",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_1(self):",
            "        \"\"\"Don't call reboot on instance which is poweredon.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOn\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_2(self):",
            "        \"\"\"Don't call reboot on instance which is suspended.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"suspended\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def destroy_rescued(self, fake_method):",
            "        self._rescue()",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              fake_method),",
            "            mock.patch.object(vm_util, \"power_on_instance\"),",
            "        ) as (fake_detach, fake_power_on):",
            "            self.instance['vm_state'] = vm_states.RESCUED",
            "            self.conn.destroy(self.context, self.instance, self.network_info)",
            "            inst_path = ds_util.DatastorePath(self.ds, self.uuid,",
            "                                              '%s.vmdk' % self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(str(inst_path)))",
            "            rescue_file_path = ds_util.DatastorePath(",
            "                self.ds, '%s-rescue' % self.uuid, '%s-rescue.vmdk' % self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(str(rescue_file_path)))",
            "            # Unrescue does not power on with destroy",
            "            self.assertFalse(fake_power_on.called)",
            "",
            "    def test_destroy_rescued(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            pass",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy_rescued_with_exception(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            raise exception.NovaException('Here is my fake exception')",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        # Overwrite the vmPathName",
            "        vm = self._get_vm_record()",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)",
            "",
            "    def test_destroy_instance_without_vm_ref(self):",
            "        self._create_instance()",
            "        with contextlib.nested(",
            "             mock.patch.object(vm_util, 'get_vm_ref_from_name',",
            "                               return_value=None),",
            "             mock.patch.object(self.conn._session,",
            "                               '_call_method')",
            "        ) as (mock_get, mock_call):",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, True)",
            "            mock_get.assert_called_once_with(self.conn._vmops._session,",
            "                                             self.instance['uuid'])",
            "            self.assertFalse(mock_call.called)",
            "",
            "    def _rescue(self, config_drive=False):",
            "        # validate that the power on is only called once",
            "        self._power_on = vm_util.power_on_instance",
            "        self._power_on_called = 0",
            "",
            "        def fake_attach_disk_to_vm(vm_ref, instance,",
            "                                   adapter_type, disk_type, vmdk_path=None,",
            "                                   disk_size=None, linked_clone=False,",
            "                                   controller_key=None, unit_number=None,",
            "                                   device_name=None):",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        if config_drive:",
            "            def fake_create_config_drive(instance, injected_files, password,",
            "                                         data_store_name, folder,",
            "                                         instance_uuid, cookies):",
            "                self.assertTrue(uuidutils.is_uuid_like(instance['uuid']))",
            "                return str(ds_util.DatastorePath(data_store_name,",
            "                                                 instance_uuid, 'fake.iso'))",
            "",
            "            self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                           fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "",
            "        def fake_power_on_instance(session, instance, vm_ref=None):",
            "            self._power_on_called += 1",
            "            return self._power_on(session, instance, vm_ref=vm_ref)",
            "",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.stubs.Set(vm_util, \"power_on_instance\",",
            "                       fake_power_on_instance)",
            "        self.stubs.Set(self.conn._volumeops, \"attach_disk_to_vm\",",
            "                       fake_attach_disk_to_vm)",
            "",
            "        self.conn.rescue(self.context, self.instance, self.network_info,",
            "                         self.image, 'fake-password')",
            "",
            "        info = self.conn.get_info({'name': '1-rescue',",
            "                                   'uuid': '%s-rescue' % self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get('%s-rescue' % self.uuid))",
            "        self.assertEqual(1, self._power_on_called)",
            "",
            "    def test_rescue(self):",
            "        self._rescue()",
            "        inst_file_path = ds_util.DatastorePath(self.ds, self.uuid,",
            "                                               '%s.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(inst_file_path)))",
            "        rescue_file_path = ds_util.DatastorePath(self.ds,",
            "                                                 '%s-rescue' % self.uuid,",
            "                                                 '%s-rescue.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(rescue_file_path)))",
            "",
            "    def test_rescue_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self._rescue(config_drive=True)",
            "",
            "    def test_unrescue(self):",
            "        # NOTE(dims): driver unrescue ends up eventually in vmops.unrescue",
            "        # with power_on=True, the test_destroy_rescued tests the",
            "        # vmops.unrescue with power_on=False",
            "        self._rescue()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session,",
            "                                    self.instance)",
            "        vm_rescue_ref = vm_util.get_vm_ref_from_name(self.conn._session,",
            "                                                     '%s-rescue' % self.uuid)",
            "",
            "        self.poweroff_instance = vm_util.power_off_instance",
            "",
            "        def fake_power_off_instance(session, instance, vm_ref):",
            "            # This is called so that we actually poweroff the simulated vm.",
            "            # The reason for this is that there is a validation in destroy",
            "            # that the instance is not powered on.",
            "            self.poweroff_instance(session, instance, vm_ref)",
            "",
            "        def fake_detach_disk_from_vm(vm_ref, instance,",
            "                                     device_name, destroy_disk=False):",
            "            self.test_device_name = device_name",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(vm_util, \"power_off_instance\",",
            "                              side_effect=fake_power_off_instance),",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              side_effect=fake_detach_disk_from_vm),",
            "            mock.patch.object(vm_util, \"power_on_instance\"),",
            "        ) as (poweroff, detach, fake_power_on):",
            "            self.conn.unrescue(self.instance, None)",
            "            poweroff.assert_called_once_with(self.conn._session, mock.ANY,",
            "                                             vm_rescue_ref)",
            "            detach.assert_called_once_with(vm_rescue_ref, mock.ANY,",
            "                                           self.test_device_name)",
            "            fake_power_on.assert_called_once_with(self.conn._session,",
            "                                                  self.instance,",
            "                                                  vm_ref=vm_ref)",
            "            self.test_vm_ref = None",
            "            self.test_device_name = None",
            "",
            "    def test_get_diagnostics(self):",
            "        self._create_vm()",
            "        expected = {'memoryReservation': 0, 'suspendInterval': 0,",
            "                    'maxCpuUsage': 2000, 'toolsInstallerMounted': False,",
            "                    'consumedOverheadMemory': 20, 'numEthernetCards': 1,",
            "                    'numCpu': 1, 'featureRequirement': [{'key': 'cpuid.AES'}],",
            "                    'memoryOverhead': 21417984,",
            "                    'guestMemoryUsage': 0, 'connectionState': 'connected',",
            "                    'memorySizeMB': 512, 'balloonedMemory': 0,",
            "                    'vmPathName': 'fake_path', 'template': False,",
            "                    'overallCpuUsage': 0, 'powerState': 'poweredOn',",
            "                    'cpuReservation': 0, 'overallCpuDemand': 0,",
            "                    'numVirtualDisks': 1, 'hostMemoryUsage': 141}",
            "        expected = dict([('vmware:' + k, v) for k, v in expected.items()])",
            "        self.assertThat(",
            "                self.conn.get_diagnostics({'name': 1, 'uuid': self.uuid,",
            "                                           'node': self.instance_node}),",
            "                matchers.DictMatches(expected))",
            "",
            "    def test_get_instance_diagnostics(self):",
            "        self._create_vm()",
            "        expected = {'uptime': 0,",
            "                    'memory_details': {'used': 0, 'maximum': 512},",
            "                    'nic_details': [],",
            "                    'driver': 'vmwareapi',",
            "                    'state': 'running',",
            "                    'version': '1.0',",
            "                    'cpu_details': [],",
            "                    'disk_details': [],",
            "                    'hypervisor_os': 'esxi',",
            "                    'config_drive': False}",
            "        actual = self.conn.get_instance_diagnostics(",
            "                {'name': 1, 'uuid': self.uuid, 'node': self.instance_node})",
            "        self.assertThat(actual.serialize(), matchers.DictMatches(expected))",
            "",
            "    def test_get_console_output(self):",
            "        self.assertRaises(NotImplementedError, self.conn.get_console_output,",
            "            None, None)",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        self._create_vm()",
            "        self.conn.finish_migration(context=self.context,",
            "                                   migration=None,",
            "                                   instance=self.instance,",
            "                                   disk_info=None,",
            "                                   network_info=None,",
            "                                   block_device_info=None,",
            "                                   resize_instance=resize_instance,",
            "                                   image_meta=None,",
            "                                   power_on=power_on)",
            "",
            "    def _test_finish_revert_migration(self, power_on):",
            "        self._create_vm()",
            "        # Ensure ESX driver throws an error",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.finish_revert_migration,",
            "                          self.context,",
            "                          instance=self.instance,",
            "                          network_info=None)",
            "",
            "    def test_get_vnc_console_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def _test_get_vnc_console(self):",
            "        self._create_vm()",
            "        fake_vm = self._get_vm_record()",
            "        OptionValue = collections.namedtuple('OptionValue', ['key', 'value'])",
            "        opt_val = OptionValue(key='', value=5906)",
            "        fake_vm.set(vm_util.VNC_CONFIG_KEY, opt_val)",
            "        vnc_console = self.conn.get_vnc_console(self.context, self.instance)",
            "        self.assertEqual(self.vnc_host, vnc_console.host)",
            "        self.assertEqual(5906, vnc_console.port)",
            "",
            "    def test_get_vnc_console(self):",
            "        self._test_get_vnc_console()",
            "",
            "    def test_get_vnc_console_noport(self):",
            "        self._create_vm()",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def test_get_volume_connector(self):",
            "        self._create_vm()",
            "        connector_dict = self.conn.get_volume_connector(self.instance)",
            "        fake_vm = self._get_vm_record()",
            "        fake_vm_id = fake_vm.obj.value",
            "        self.assertEqual(connector_dict['ip'], 'test_url')",
            "        self.assertEqual(connector_dict['initiator'], 'iscsi-name')",
            "        self.assertEqual(connector_dict['host'], 'test_url')",
            "        self.assertEqual(connector_dict['instance'], fake_vm_id)",
            "",
            "    def _test_vmdk_connection_info(self, type):",
            "        return {'driver_volume_type': type,",
            "                'serial': 'volume-fake-id',",
            "                'data': {'volume': 'vm-10',",
            "                         'volume_id': 'volume-fake-id'}}",
            "",
            "    def test_volume_attach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._attach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._detach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_vmdk_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "",
            "        # create fake backing info",
            "        volume_device = vmwareapi_fake.DataObject()",
            "        volume_device.backing = vmwareapi_fake.DataObject()",
            "        volume_device.backing.fileName = 'fake_path'",
            "",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_vmdk_base_volume_device')",
            "        volumeops.VMwareVolumeOps._get_vmdk_base_volume_device(",
            "                mox.IgnoreArg()).AndReturn(volume_device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), mox.IgnoreArg(),",
            "                vmdk_path='fake_path')",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_detach_vmdk_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_volume_uuid')",
            "        volumeops.VMwareVolumeOps._get_volume_uuid(mox.IgnoreArg(),",
            "                'volume-fake-id').AndReturn('fake_disk_uuid')",
            "        self.mox.StubOutWithMock(vm_util, 'get_vmdk_backed_disk_device')",
            "        vm_util.get_vmdk_backed_disk_device(mox.IgnoreArg(),",
            "                'fake_disk_uuid').AndReturn('fake_device')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_consolidate_vmdk_volume')",
            "        volumeops.VMwareVolumeOps._consolidate_vmdk_volume(self.instance,",
            "                 mox.IgnoreArg(), 'fake_device', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_volume_attach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._attach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._detach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_iscsi_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_host:port'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        discover = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_get_target')",
            "        # simulate target not found",
            "        volumeops.VMwareVolumeOps._iscsi_get_target(",
            "            connection_info['data']).AndReturn((None, None))",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_add_send_target_host')",
            "        # rescan gets called with target portal",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_rescan_hba')",
            "        volumeops.VMwareVolumeOps._iscsi_rescan_hba(",
            "            connection_info['data']['target_portal'])",
            "        # simulate target found",
            "        volumeops.VMwareVolumeOps._iscsi_get_target(",
            "            connection_info['data']).AndReturn(discover)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), 'rdmp',",
            "                device_name=mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_iscsi_rescan_hba(self):",
            "        fake_target_portal = 'fake_target_host:port'",
            "        host_storage_sys = vmwareapi_fake._get_objects(",
            "            \"HostStorageSystem\").objects[0]",
            "        iscsi_hba_array = host_storage_sys.get('storageDeviceInfo'",
            "                                               '.hostBusAdapter')",
            "        iscsi_hba = iscsi_hba_array.HostHostBusAdapter[0]",
            "        # Check the host system does not have the send target",
            "        self.assertRaises(AttributeError, getattr, iscsi_hba,",
            "                          'configuredSendTarget')",
            "        # Rescan HBA with the target portal",
            "        vops = volumeops.VMwareVolumeOps(self.conn._session)",
            "        vops._iscsi_rescan_hba(fake_target_portal)",
            "        # Check if HBA has the target portal configured",
            "        self.assertEqual('fake_target_host',",
            "                          iscsi_hba.configuredSendTarget[0].address)",
            "        # Rescan HBA with same portal",
            "        vops._iscsi_rescan_hba(fake_target_portal)",
            "        self.assertEqual(1, len(iscsi_hba.configuredSendTarget))",
            "",
            "    def test_iscsi_get_target(self):",
            "        data = {'target_portal': 'fake_target_host:port',",
            "                'target_iqn': 'fake_target_iqn'}",
            "        host = vmwareapi_fake._get_objects('HostSystem').objects[0]",
            "        host._add_iscsi_target(data)",
            "        vops = volumeops.VMwareVolumeOps(self.conn._session)",
            "        result = vops._iscsi_get_target(data)",
            "        self.assertEqual(('fake-device', 'fake-uuid'), result)",
            "",
            "    def test_detach_iscsi_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_portal'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        find = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_get_target')",
            "        volumeops.VMwareVolumeOps._iscsi_get_target(",
            "            connection_info['data']).AndReturn(find)",
            "        self.mox.StubOutWithMock(vm_util, 'get_rdm_disk')",
            "        device = 'fake_device'",
            "        vm_util.get_rdm_disk(mox.IgnoreArg(), 'fake_uuid').AndReturn(device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, device, destroy_disk=True)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_connection_info_get(self):",
            "        self._create_vm()",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertIn('instance', connector)",
            "",
            "    def test_connection_info_get_after_destroy(self):",
            "        self._create_vm()",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertNotIn('instance', connector)",
            "",
            "    def test_refresh_instance_security_rules(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.refresh_instance_security_rules,",
            "                          instance=None)",
            "",
            "    def test_image_aging_image_used(self):",
            "        self._create_vm()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "",
            "    def _get_timestamp_filename(self):",
            "        return '%s%s' % (imagecache.TIMESTAMP_PREFIX,",
            "                         timeutils.strtime(at=self.old_time,",
            "                                           fmt=imagecache.TIMESTAMP_FORMAT))",
            "",
            "    def _override_time(self):",
            "        self.old_time = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "",
            "        def _fake_get_timestamp_filename(fake):",
            "            return self._get_timestamp_filename()",
            "",
            "        self.stubs.Set(imagecache.ImageCacheManager, '_get_timestamp_filename',",
            "                       _fake_get_timestamp_filename)",
            "",
            "    def _timestamp_file_exists(self, exists=True):",
            "        timestamp = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                          self.fake_image_uuid,",
            "                                          self._get_timestamp_filename() + '/')",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(str(timestamp)))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(str(timestamp)))",
            "",
            "    def _image_aging_image_marked_for_deletion(self):",
            "        self._create_vm(uuid=uuidutils.generate_uuid())",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "        self._timestamp_file_exists()",
            "",
            "    def test_image_aging_image_marked_for_deletion(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "",
            "    def _timestamp_file_removed(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "        self._create_vm(num_instances=2,",
            "                        uuid=uuidutils.generate_uuid())",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_timestamp_file_removed_spawn(self):",
            "        self._timestamp_file_removed()",
            "",
            "    def test_timestamp_file_removed_aging(self):",
            "        self._timestamp_file_removed()",
            "        ts = self._get_timestamp_filename()",
            "        ts_path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                        self.fake_image_uuid, ts + '/')",
            "        vmwareapi_fake._add_file(str(ts_path))",
            "        self._timestamp_file_exists()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_image_aging_disabled(self):",
            "        self._override_time()",
            "        self.flags(remove_unused_base_images=False)",
            "        self._create_vm()",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist(exists=True)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def _image_aging_aged(self, aging_time=100):",
            "        self._override_time()",
            "        cur_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.flags(remove_unused_original_minimum_age_seconds=aging_time)",
            "        self._image_aging_image_marked_for_deletion()",
            "        all_instances = []",
            "        timeutils.set_time_override(cur_time)",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "",
            "    def test_image_aging_aged(self):",
            "        self._image_aging_aged(aging_time=8)",
            "        self._cached_files_exist(exists=False)",
            "",
            "    def test_image_aging_not_aged(self):",
            "        self._image_aging_aged()",
            "        self._cached_files_exist()",
            "",
            "",
            "class VMwareAPIVCDriverTestCase(VMwareAPIVMTestCase):",
            "",
            "    def setUp(self):",
            "",
            "        super(VMwareAPIVCDriverTestCase, self).setUp(create_connection=False)",
            "        cluster_name = 'test_cluster'",
            "        cluster_name2 = 'test_cluster2'",
            "        self.flags(cluster_name=[cluster_name, cluster_name2],",
            "                   api_retry_count=1,",
            "                   task_poll_interval=10, datastore_regex='.*', group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base')",
            "        vmwareapi_fake.reset()",
            "        self.conn = driver.VMwareVCDriver(None, False)",
            "        self._set_exception_vars()",
            "        self.node_name = self.conn._resources.keys()[0]",
            "        self.node_name2 = self.conn._resources.keys()[1]",
            "        if cluster_name2 in self.node_name2:",
            "            self.ds = 'ds1'",
            "        else:",
            "            self.ds = 'ds2'",
            "        self.vnc_host = 'ha-host'",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVCDriverTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "",
            "    def test_public_api_signatures(self):",
            "        self.assertPublicAPISignatures(v_driver.ComputeDriver(None), self.conn)",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_list_instances_from_nodes(self):",
            "        # Create instance on node1",
            "        self._create_vm(self.node_name)",
            "        # Create instances on the other node",
            "        self._create_vm(self.node_name2, num_instances=2)",
            "        self._create_vm(self.node_name2, num_instances=3)",
            "        node1_vmops = self.conn._get_vmops_for_compute_node(self.node_name)",
            "        node2_vmops = self.conn._get_vmops_for_compute_node(self.node_name2)",
            "        self.assertEqual(1, len(node1_vmops.list_instances()))",
            "        self.assertEqual(2, len(node2_vmops.list_instances()))",
            "        self.assertEqual(3, len(self.conn.list_instances()))",
            "",
            "    def _setup_mocks_for_session(self, mock_init):",
            "        mock_init.return_value = None",
            "",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        vcdriver._session.vim = None",
            "",
            "        def side_effect():",
            "            vcdriver._session.vim = mock.Mock()",
            "        vcdriver._session._create_session.side_effect = side_effect",
            "        return vcdriver",
            "",
            "    def test_host_power_action(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_power_action, 'host', 'action')",
            "",
            "    def test_host_maintenance_mode(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_maintenance_mode, 'host', 'mode')",
            "",
            "    def test_set_host_enabled(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.set_host_enabled, 'host', 'state')",
            "",
            "    def test_datastore_regex_configured(self):",
            "        for node in self.conn._resources.keys():",
            "            self.assertEqual(self.conn._datastore_regex,",
            "                    self.conn._resources[node]['vmops']._datastore_regex)",
            "",
            "    def test_get_available_resource(self):",
            "        stats = self.conn.get_available_resource(self.node_name)",
            "        cpu_info = {\"model\": [\"Intel(R) Xeon(R)\", \"Intel(R) Xeon(R)\"],",
            "                    \"vendor\": [\"Intel\", \"Intel\"],",
            "                    \"topology\": {\"cores\": 16,",
            "                                 \"threads\": 32}}",
            "        self.assertEqual(stats['vcpus'], 32)",
            "        self.assertEqual(stats['local_gb'], 1024)",
            "        self.assertEqual(stats['local_gb_used'], 1024 - 500)",
            "        self.assertEqual(stats['memory_mb'], 1000)",
            "        self.assertEqual(stats['memory_mb_used'], 500)",
            "        self.assertEqual(stats['hypervisor_type'], 'VMware vCenter Server')",
            "        self.assertEqual(stats['hypervisor_version'], 5001000)",
            "        self.assertEqual(stats['hypervisor_hostname'], self.node_name)",
            "        self.assertEqual(stats['cpu_info'], jsonutils.dumps(cpu_info))",
            "        self.assertEqual(stats['supported_instances'],",
            "                '[[\"i686\", \"vmware\", \"hvm\"], [\"x86_64\", \"vmware\", \"hvm\"]]')",
            "",
            "    def test_invalid_datastore_regex(self):",
            "",
            "        # Tests if we raise an exception for Invalid Regular Expression in",
            "        # vmware_datastore_regex",
            "        self.flags(cluster_name=['test_cluster'], datastore_regex='fake-ds(01',",
            "                   group='vmware')",
            "        self.assertRaises(exception.InvalidInput, driver.VMwareVCDriver, None)",
            "",
            "    def test_get_available_nodes(self):",
            "        nodelist = self.conn.get_available_nodes()",
            "        self.assertEqual(len(nodelist), 2)",
            "        self.assertIn(self.node_name, nodelist)",
            "        self.assertIn(self.node_name2, nodelist)",
            "",
            "    def test_spawn_multiple_node(self):",
            "",
            "        def fake_is_neutron():",
            "            return False",
            "",
            "        self.stubs.Set(nova_utils, 'is_neutron', fake_is_neutron)",
            "        uuid1 = uuidutils.generate_uuid()",
            "        uuid2 = uuidutils.generate_uuid()",
            "        self._create_vm(node=self.node_name, num_instances=1,",
            "                        uuid=uuid1)",
            "        info = self.conn.get_info({'uuid': uuid1,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        self._create_vm(node=self.node_name2, num_instances=1,",
            "                        uuid=uuid2)",
            "        info = self.conn.get_info({'uuid': uuid2,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_snapshot(self):",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_using_file_manager(self):",
            "        self._create_vm()",
            "        uuid_str = uuidutils.generate_uuid()",
            "        self.mox.StubOutWithMock(uuidutils,",
            "                                 'generate_uuid')",
            "        uuidutils.generate_uuid().AndReturn(uuid_str)",
            "",
            "        self.mox.StubOutWithMock(ds_util, 'file_delete')",
            "        disk_ds_path = ds_util.DatastorePath(",
            "                self.ds, \"vmware_temp\", \"%s.vmdk\" % uuid_str)",
            "        disk_ds_flat_path = ds_util.DatastorePath(",
            "                self.ds, \"vmware_temp\", \"%s-flat.vmdk\" % uuid_str)",
            "        # Check calls for delete vmdk and -flat.vmdk pair",
            "        ds_util.file_delete(",
            "                mox.IgnoreArg(), disk_ds_flat_path,",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        ds_util.file_delete(",
            "                mox.IgnoreArg(), disk_ds_path, mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "        self._test_snapshot()",
            "",
            "    def test_spawn_invalid_node(self):",
            "        self._create_instance(node='InvalidNodeName')",
            "        self.assertRaises(exception.NotFound, self.conn.spawn,",
            "                          self.context, self.instance, self.image,",
            "                          injected_files=[], admin_password=None,",
            "                          network_info=self.network_info,",
            "                          block_device_info=None)",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_with_sparse_image(self, mock_from_image):",
            "        img_info = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=1024,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=False)",
            "",
            "        mock_from_image.return_value = img_info",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_plug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.plug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def test_unplug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.unplug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def _create_vif(self):",
            "        gw_4 = network_model.IP(address='101.168.1.1', type='gateway')",
            "        dns_4 = network_model.IP(address='8.8.8.8', type=None)",
            "        subnet_4 = network_model.Subnet(cidr='101.168.1.0/24',",
            "                                        dns=[dns_4],",
            "                                        gateway=gw_4,",
            "                                        routes=None,",
            "                                        dhcp_server='191.168.1.1')",
            "",
            "        gw_6 = network_model.IP(address='101:1db9::1', type='gateway')",
            "        subnet_6 = network_model.Subnet(cidr='101:1db9::/64',",
            "                                        dns=None,",
            "                                        gateway=gw_6,",
            "                                        ips=None,",
            "                                        routes=None)",
            "",
            "        network_neutron = network_model.Network(id='network-id-xxx-yyy-zzz',",
            "                                                bridge=None,",
            "                                                label=None,",
            "                                                subnets=[subnet_4,",
            "                                                         subnet_6],",
            "                                                bridge_interface='eth0',",
            "                                                vlan=99)",
            "",
            "        vif_bridge_neutron = network_model.VIF(id='new-vif-xxx-yyy-zzz',",
            "                                               address='ca:fe:de:ad:be:ef',",
            "                                               network=network_neutron,",
            "                                               type=None,",
            "                                               devname='tap-xxx-yyy-zzz',",
            "                                               ovs_interfaceid='aaa-bbb-ccc')",
            "        return vif_bridge_neutron",
            "",
            "    def _validate_interfaces(self, id, index, num_iface_ids):",
            "        vm = self._get_vm_record()",
            "        found_iface_id = False",
            "        extras = vm.get(\"config.extraConfig\")",
            "        key = \"nvp.iface-id.%s\" % index",
            "        num_found = 0",
            "        for c in extras.OptionValue:",
            "            if c.key.startswith(\"nvp.iface-id.\"):",
            "                num_found += 1",
            "                if c.key == key and c.value == id:",
            "                    found_iface_id = True",
            "        self.assertTrue(found_iface_id)",
            "        self.assertEqual(num_found, num_iface_ids)",
            "",
            "    def _attach_interface(self, vif):",
            "        self.conn.attach_interface(self.instance, self.image, vif)",
            "        self._validate_interfaces(vif['id'], 1, 2)",
            "",
            "    def test_attach_interface(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "",
            "    def test_attach_interface_with_exception(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "",
            "        with mock.patch.object(self.conn._session, '_wait_for_task',",
            "                               side_effect=Exception):",
            "            self.assertRaises(exception.InterfaceAttachFailed,",
            "                              self.conn.attach_interface,",
            "                              self.instance, self.image, vif)",
            "",
            "    @mock.patch.object(vif, 'get_network_device',",
            "                       return_value='fake_device')",
            "    def _detach_interface(self, vif, mock_get_device):",
            "        self._create_vm()",
            "        self._attach_interface(vif)",
            "        self.conn.detach_interface(self.instance, vif)",
            "        self._validate_interfaces('free', 1, 2)",
            "",
            "    def test_detach_interface(self):",
            "        vif = self._create_vif()",
            "        self._detach_interface(vif)",
            "",
            "    def test_detach_interface_and_attach(self):",
            "        vif = self._create_vif()",
            "        self._detach_interface(vif)",
            "        self.conn.attach_interface(self.instance, self.image, vif)",
            "        self._validate_interfaces(vif['id'], 1, 2)",
            "",
            "    def test_detach_interface_no_device(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "        self.assertRaises(exception.NotFound, self.conn.detach_interface,",
            "                          self.instance, vif)",
            "",
            "    def test_detach_interface_no_vif_match(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "        vif['id'] = 'bad-id'",
            "        self.assertRaises(exception.NotFound, self.conn.detach_interface,",
            "                          self.instance, vif)",
            "",
            "    @mock.patch.object(vif, 'get_network_device',",
            "                       return_value='fake_device')",
            "    def test_detach_interface_with_exception(self, mock_get_device):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "",
            "        with mock.patch.object(self.conn._session, '_wait_for_task',",
            "                               side_effect=Exception):",
            "            self.assertRaises(exception.InterfaceDetachFailed,",
            "                              self.conn.detach_interface,",
            "                              self.instance, vif)",
            "",
            "    def test_migrate_disk_and_power_off(self):",
            "        def fake_update_instance_progress(context, instance, step,",
            "                                          total_steps):",
            "            pass",
            "",
            "        def fake_get_host_ref_from_name(dest):",
            "            return None",
            "",
            "        self._create_vm(instance_type='m1.large')",
            "        vm_ref_orig = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        flavor = self._get_instance_type_by_name('m1.large')",
            "        self.stubs.Set(self.conn._vmops, \"_update_instance_progress\",",
            "                       fake_update_instance_progress)",
            "        self.stubs.Set(self.conn._vmops, \"_get_host_ref_from_name\",",
            "                       fake_get_host_ref_from_name)",
            "        self.conn.migrate_disk_and_power_off(self.context, self.instance,",
            "                                             'fake_dest', flavor,",
            "                                             None)",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref_orig.value, vm_ref.value,",
            "                             \"These should be different\")",
            "",
            "    def test_disassociate_vmref_from_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                        self.instance, vm_ref, \"-backup\")",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "",
            "    def test_clone_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        host_ref = vmwareapi_fake._get_object_refs(\"HostSystem\")[0]",
            "        ds_ref = vmwareapi_fake._get_object_refs(\"Datastore\")[0]",
            "        dc_obj = vmwareapi_fake._get_objects(\"Datacenter\").objects[0]",
            "        vm_util.clone_vmref_for_instance(self.conn._session, self.instance,",
            "                                         vm_ref, host_ref, ds_ref,",
            "                                         dc_obj.get(\"vmFolder\"))",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "        cloned_vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref.value, cloned_vm_ref.value,",
            "                            \"Reference for the cloned VM should be different\")",
            "        vm_obj = vmwareapi_fake._get_vm_mdo(vm_ref)",
            "        cloned_vm_obj = vmwareapi_fake._get_vm_mdo(cloned_vm_ref)",
            "        self.assertEqual(vm_obj.name, self.instance['uuid'] + \"-backup\",",
            "                       \"Original VM name should be with suffix -backup\")",
            "        self.assertEqual(cloned_vm_obj.name, self.instance['uuid'],",
            "                       \"VM name does not match instance['uuid']\")",
            "        self.assertRaises(vexc.MissingParameter,",
            "                          vm_util.clone_vmref_for_instance, self.conn._session,",
            "                          self.instance, None, host_ref, ds_ref,",
            "                          dc_obj.get(\"vmFolder\"))",
            "",
            "    def test_associate_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        # First disassociate the VM from the instance so that we have a VM",
            "        # to later associate using the associate_vmref_for_instance method",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        # Ensure that the VM is indeed disassociated and that we cannot find",
            "        # the VM using the get_vm_ref method",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "        # Associate the VM back to the instance",
            "        vm_util.associate_vmref_for_instance(self.conn._session, self.instance,",
            "                                             suffix=\"-backup\")",
            "        # Verify if we can get the VM reference",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "",
            "    def test_confirm_migration(self):",
            "        self._create_vm()",
            "        self.conn.confirm_migration(self.context, self.instance, None)",
            "",
            "    def test_resize_to_smaller_disk(self):",
            "        self._create_vm(instance_type='m1.large')",
            "        flavor = self._get_instance_type_by_name('m1.small')",
            "        self.assertRaises(exception.InstanceFaultRollback,",
            "                          self.conn.migrate_disk_and_power_off, self.context,",
            "                          self.instance, 'fake_dest', flavor, None)",
            "",
            "    def test_spawn_attach_volume_vmdk(self):",
            "        self._spawn_attach_volume_vmdk(vc_support=True)",
            "",
            "    def test_spawn_attach_volume_vmdk_no_image_ref(self):",
            "        self._spawn_attach_volume_vmdk(set_image_ref=False, vc_support=True)",
            "",
            "    def test_pause(self):",
            "        # Tests that the VMwareVCDriver does not implement the pause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.pause, self.instance)",
            "",
            "    def test_unpause(self):",
            "        # Tests that the VMwareVCDriver does not implement the unpause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.unpause,",
            "                          self.instance)",
            "",
            "    def test_datastore_dc_map(self):",
            "        vmops = self.conn._resources[self.node_name]['vmops']",
            "        self.assertEqual({}, vmops._datastore_dc_mapping)",
            "        self._create_vm()",
            "        # currently there are 2 data stores",
            "        self.assertEqual(2, len(vmops._datastore_dc_mapping))",
            "",
            "    def test_rollback_live_migration_at_destination(self):",
            "        with mock.patch.object(self.conn, \"destroy\") as mock_destroy:",
            "            self.conn.rollback_live_migration_at_destination(self.context,",
            "                    \"instance\", [], None)",
            "            mock_destroy.assert_called_once_with(self.context,",
            "                    \"instance\", [], None)",
            "",
            "    def test_get_instance_disk_info_is_implemented(self):",
            "        # Ensure that the method has been implemented in the driver",
            "        try:",
            "            disk_info = self.conn.get_instance_disk_info('fake_instance_name')",
            "            self.assertIsNone(disk_info)",
            "        except NotImplementedError:",
            "            self.fail(\"test_get_instance_disk_info() should not raise \"",
            "                      \"NotImplementedError\")",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        # Overwrite the vmPathName",
            "        vm = self._get_vm_record()",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)",
            "",
            "    def test_get_host_uptime(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.get_host_uptime, 'host')",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        \"\"\"Tests the finish_migration method on VC Driver.\"\"\"",
            "        # setup the test instance in the database",
            "        self._create_vm()",
            "        if resize_instance:",
            "            self.instance.system_metadata = {'old_instance_type_root_gb': '0'}",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        datastore = ds_util.Datastore(ref='fake-ref', name='fake')",
            "        dc_info = vmops.DcInfo(ref='fake_ref', name='fake',",
            "                               vmFolder='fake_folder')",
            "        with contextlib.nested(",
            "                mock.patch.object(self.conn._session, \"_call_method\",",
            "                                  return_value='fake-task'),",
            "                mock.patch.object(self.conn._vmops,",
            "                                  \"_update_instance_progress\"),",
            "                mock.patch.object(self.conn._session, \"_wait_for_task\"),",
            "                mock.patch.object(vm_util, \"get_vm_resize_spec\",",
            "                                  return_value='fake-spec'),",
            "                mock.patch.object(ds_util, \"get_datastore\",",
            "                                  return_value=datastore),",
            "                mock.patch.object(self.conn._vmops,",
            "                                  'get_datacenter_ref_and_name',",
            "                                  return_value=dc_info),",
            "                mock.patch.object(self.conn._vmops, '_extend_virtual_disk'),",
            "                mock.patch.object(vm_util, \"power_on_instance\")",
            "        ) as (fake_call_method, fake_update_instance_progress,",
            "              fake_wait_for_task, fake_vm_resize_spec,",
            "              fake_get_datastore, fake_get_datacenter_ref_and_name,",
            "              fake_extend_virtual_disk, fake_power_on):",
            "            self.conn.finish_migration(context=self.context,",
            "                                       migration=None,",
            "                                       instance=self.instance,",
            "                                       disk_info=None,",
            "                                       network_info=None,",
            "                                       block_device_info=None,",
            "                                       resize_instance=resize_instance,",
            "                                       image_meta=None,",
            "                                       power_on=power_on)",
            "            if resize_instance:",
            "                fake_vm_resize_spec.assert_called_once_with(",
            "                    self.conn._session._get_vim().client.factory,",
            "                    self.instance)",
            "                fake_call_method.assert_any_call(",
            "                    self.conn._session._get_vim(),",
            "                    \"ReconfigVM_Task\",",
            "                    vm_ref,",
            "                    spec='fake-spec')",
            "                fake_wait_for_task.assert_called_once_with('fake-task')",
            "                fake_extend_virtual_disk.assert_called_once_with(",
            "                    self.instance, self.instance['root_gb'] * units.Mi,",
            "                    None, dc_info.ref)",
            "            else:",
            "                self.assertFalse(fake_vm_resize_spec.called)",
            "                self.assertFalse(fake_call_method.called)",
            "                self.assertFalse(fake_wait_for_task.called)",
            "                self.assertFalse(fake_extend_virtual_disk.called)",
            "",
            "            if power_on:",
            "                fake_power_on.assert_called_once_with(self.conn._session,",
            "                                                      self.instance,",
            "                                                      vm_ref=vm_ref)",
            "            else:",
            "                self.assertFalse(fake_power_on.called)",
            "            fake_update_instance_progress.called_once_with(",
            "                self.context, self.instance, 4, vmops.RESIZE_TOTAL_STEPS)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self._test_finish_migration(power_on=True)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self._test_finish_migration(power_on=False)",
            "",
            "    def test_finish_migration_power_on_resize(self):",
            "        self._test_finish_migration(power_on=True,",
            "                                    resize_instance=True)",
            "",
            "    @mock.patch.object(vm_util, 'associate_vmref_for_instance')",
            "    @mock.patch.object(vm_util, 'power_on_instance')",
            "    def _test_finish_revert_migration(self, fake_power_on,",
            "                                      fake_associate_vmref, power_on):",
            "        \"\"\"Tests the finish_revert_migration method on VC Driver.\"\"\"",
            "",
            "        # setup the test instance in the database",
            "        self._create_instance()",
            "        self.conn.finish_revert_migration(self.context,",
            "                                          instance=self.instance,",
            "                                          network_info=None,",
            "                                          block_device_info=None,",
            "                                          power_on=power_on)",
            "        fake_associate_vmref.assert_called_once_with(self.conn._session,",
            "                                                     self.instance,",
            "                                                     suffix='-orig')",
            "        if power_on:",
            "            fake_power_on.assert_called_once_with(self.conn._session,",
            "                                                  self.instance)",
            "        else:",
            "            self.assertFalse(fake_power_on.called)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self._test_finish_revert_migration(power_on=True)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self._test_finish_revert_migration(power_on=False)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Test suite for VMwareAPI.",
            "\"\"\"",
            "",
            "import collections",
            "import contextlib",
            "import copy",
            "import datetime",
            "",
            "from eventlet import greenthread",
            "import mock",
            "import mox",
            "from oslo.config import cfg",
            "from oslo.vmware import exceptions as vexc",
            "from oslo.vmware import vim",
            "import suds",
            "",
            "from nova import block_device",
            "from nova.compute import api as compute_api",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import exception",
            "from nova.image import glance",
            "from nova.network import model as network_model",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import test",
            "from nova.tests import fake_instance",
            "import nova.tests.image.fake",
            "from nova.tests import matchers",
            "from nova.tests import test_flavors",
            "from nova.tests import utils",
            "from nova.tests.virt.vmwareapi import fake as vmwareapi_fake",
            "from nova.tests.virt.vmwareapi import stubs",
            "from nova import utils as nova_utils",
            "from nova.virt import driver as v_driver",
            "from nova.virt.vmwareapi import constants",
            "from nova.virt.vmwareapi import driver",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vif",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmops",
            "from nova.virt.vmwareapi import vmware_images",
            "from nova.virt.vmwareapi import volumeops",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('remove_unused_original_minimum_age_seconds',",
            "                'nova.virt.imagecache')",
            "",
            "",
            "class fake_vm_ref(object):",
            "    def __init__(self):",
            "        self.value = 4",
            "        self._type = 'VirtualMachine'",
            "",
            "",
            "class fake_service_content(object):",
            "    def __init__(self):",
            "        self.ServiceContent = vmwareapi_fake.DataObject()",
            "        self.ServiceContent.fake = 'fake'",
            "",
            "",
            "class VMwareSudsTest(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(VMwareSudsTest, self).setUp()",
            "",
            "        def new_client_init(self, url, **kwargs):",
            "            return",
            "",
            "        mock.patch.object(suds.client.Client,",
            "                          '__init__', new=new_client_init).start()",
            "        self.vim = self._vim_create()",
            "        self.addCleanup(mock.patch.stopall)",
            "",
            "    def _mock_getattr(self, attr_name):",
            "        self.assertEqual(\"RetrieveServiceContent\", attr_name)",
            "        return lambda obj, **kwargs: fake_service_content()",
            "",
            "    def _vim_create(self):",
            "        with mock.patch.object(vim.Vim, '__getattr__', self._mock_getattr):",
            "            return vim.Vim()",
            "",
            "    def test_exception_with_deepcopy(self):",
            "        self.assertIsNotNone(self.vim)",
            "        self.assertRaises(vexc.VimException,",
            "                          copy.deepcopy, self.vim)",
            "",
            "",
            "def _fake_create_session(inst):",
            "    session = vmwareapi_fake.DataObject()",
            "    session.key = 'fake_key'",
            "    session.userName = 'fake_username'",
            "    inst._session = session",
            "",
            "",
            "class VMwareDriverStartupTestCase(test.NoDBTestCase):",
            "    def _start_driver_with_flags(self, expected_exception_type, startup_flags):",
            "        self.flags(**startup_flags)",
            "        with mock.patch(",
            "                'nova.virt.vmwareapi.driver.VMwareAPISession.__init__'):",
            "            e = self.assertRaises(",
            "                    Exception, driver.VMwareVCDriver, None)  # noqa",
            "            self.assertIs(type(e), expected_exception_type)",
            "",
            "    def test_start_driver_no_user(self):",
            "        self._start_driver_with_flags(",
            "                Exception,",
            "                dict(host_ip='ip', host_password='password',",
            "                     group='vmware'))",
            "",
            "    def test_start_driver_no_host(self):",
            "        self._start_driver_with_flags(",
            "                Exception,",
            "                dict(host_username='username', host_password='password',",
            "                     group='vmware'))",
            "",
            "    def test_start_driver_no_password(self):",
            "        self._start_driver_with_flags(",
            "                Exception,",
            "                dict(host_ip='ip', host_username='username',",
            "                     group='vmware'))",
            "",
            "    def test_start_driver_with_user_host_password(self):",
            "        # Getting the InvalidInput exception signifies that no exception",
            "        # is raised regarding missing user/password/host",
            "        self._start_driver_with_flags(",
            "                nova.exception.InvalidInput,",
            "                dict(host_ip='ip', host_password='password',",
            "                     host_username=\"user\", datastore_regex=\"bad(regex\",",
            "                     group='vmware'))",
            "",
            "",
            "class VMwareSessionTestCase(test.NoDBTestCase):",
            "",
            "    @mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                       return_value=False)",
            "    def test_call_method(self, mock_is_vim):",
            "        with contextlib.nested(",
            "                mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                                  _fake_create_session),",
            "                mock.patch.object(driver.VMwareAPISession, 'invoke_api'),",
            "        ) as (fake_create, fake_invoke):",
            "            session = driver.VMwareAPISession()",
            "            session._vim = mock.Mock()",
            "            module = mock.Mock()",
            "            session._call_method(module, 'fira')",
            "            fake_invoke.assert_called_once_with(module, 'fira', session._vim)",
            "",
            "    @mock.patch.object(driver.VMwareAPISession, '_is_vim_object',",
            "                       return_value=True)",
            "    def test_call_method_vim(self, mock_is_vim):",
            "        with contextlib.nested(",
            "                mock.patch.object(driver.VMwareAPISession, '_create_session',",
            "                                  _fake_create_session),",
            "                mock.patch.object(driver.VMwareAPISession, 'invoke_api'),",
            "        ) as (fake_create, fake_invoke):",
            "            session = driver.VMwareAPISession()",
            "            module = mock.Mock()",
            "            session._call_method(module, 'fira')",
            "            fake_invoke.assert_called_once_with(module, 'fira')",
            "",
            "",
            "class VMwareAPIVMTestCase(test.NoDBTestCase):",
            "    \"\"\"Unit tests for Vmware API connection calls.\"\"\"",
            "",
            "    def setUp(self, create_connection=True):",
            "        super(VMwareAPIVMTestCase, self).setUp()",
            "        vm_util.vm_refs_cache_reset()",
            "        self.context = context.RequestContext('fake', 'fake', is_admin=False)",
            "        cluster_name = 'test_cluster'",
            "        cluster_name2 = 'test_cluster2'",
            "        self.flags(cluster_name=[cluster_name, cluster_name2],",
            "                   host_ip='test_url',",
            "                   host_username='test_username',",
            "                   host_password='test_pass',",
            "                   api_retry_count=1,",
            "                   use_linked_clone=False, group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base',",
            "                   my_ip='')",
            "        self.user_id = 'fake'",
            "        self.project_id = 'fake'",
            "        self.context = context.RequestContext(self.user_id, self.project_id)",
            "        stubs.set_stubs(self.stubs)",
            "        vmwareapi_fake.reset()",
            "        nova.tests.image.fake.stub_out_image_service(self.stubs)",
            "        if create_connection:",
            "            self.conn = driver.VMwareVCDriver(None, False)",
            "            self._set_exception_vars()",
            "            self.node_name = self.conn._resources.keys()[0]",
            "            self.node_name2 = self.conn._resources.keys()[1]",
            "            if cluster_name2 in self.node_name2:",
            "                self.ds = 'ds1'",
            "            else:",
            "                self.ds = 'ds2'",
            "",
            "        self.vim = vmwareapi_fake.FakeVim()",
            "",
            "        # NOTE(vish): none of the network plugging code is actually",
            "        #             being tested",
            "        self.network_info = utils.get_test_network_info()",
            "        image_ref = nova.tests.image.fake.get_valid_image_id()",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "            self.context, image_ref)",
            "        metadata = image_service.show(self.context, image_id)",
            "        self.image = {",
            "            'id': image_ref,",
            "            'disk_format': 'vmdk',",
            "            'size': int(metadata['size']),",
            "        }",
            "        self.fake_image_uuid = self.image['id']",
            "        nova.tests.image.fake.stub_out_image_service(self.stubs)",
            "        self.vnc_host = 'ha-host'",
            "        self.instance_without_compute = {'node': None,",
            "                                         'vm_state': 'building',",
            "                                         'project_id': 'fake',",
            "                                         'user_id': 'fake',",
            "                                         'name': '1',",
            "                                         'display_description': '1',",
            "                                         'kernel_id': '1',",
            "                                         'ramdisk_id': '1',",
            "                                         'mac_addresses': [",
            "                                            {'address': 'de:ad:be:ef:be:ef'}",
            "                                         ],",
            "                                         'memory_mb': 8192,",
            "                                         'instance_type': 'm1.large',",
            "                                         'vcpus': 4,",
            "                                         'root_gb': 80,",
            "                                         'image_ref': self.image['id'],",
            "                                         'host': 'fake_host',",
            "                                         'task_state':",
            "                                         'scheduling',",
            "                                         'reservation_id': 'r-3t8muvr0',",
            "                                         'id': 1,",
            "                                         'uuid': 'fake-uuid',",
            "                                         'metadata': []}",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVMTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "        nova.tests.image.fake.FakeImageService_reset()",
            "",
            "    def test_get_host_ip_addr(self):",
            "        self.assertEqual('test_url', self.conn.get_host_ip_addr())",
            "",
            "    def test_init_host_with_no_session(self):",
            "        self.conn._session = mock.Mock()",
            "        self.conn._session.vim = None",
            "        self.conn.init_host('fake_host')",
            "        self.conn._session._create_session.assert_called_once_with()",
            "",
            "    def test_init_host(self):",
            "        try:",
            "            self.conn.init_host(\"fake_host\")",
            "        except Exception as ex:",
            "            self.fail(\"init_host raised: %s\" % ex)",
            "",
            "    def _set_exception_vars(self):",
            "        self.wait_task = self.conn._session._wait_for_task",
            "        self.call_method = self.conn._session._call_method",
            "        self.task_ref = None",
            "        self.exception = False",
            "",
            "    def test_cleanup_host(self):",
            "        self.conn.init_host(\"fake_host\")",
            "        try:",
            "            self.conn.cleanup_host(\"fake_host\")",
            "        except Exception as ex:",
            "            self.fail(\"cleanup_host raised: %s\" % ex)",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_cleanup_host_direct(self, mock_init):",
            "        mock_init.return_value = None",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        vcdriver.cleanup_host(\"foo\")",
            "        vcdriver._session.vim.client.service.Logout.assert_called_once_with(",
            "            vcdriver._session.vim.service_content.sessionManager",
            "        )",
            "",
            "    @mock.patch('nova.virt.vmwareapi.driver.VMwareVCDriver.__init__')",
            "    def test_cleanup_host_direct_with_bad_logout(self, mock_init):",
            "        mock_init.return_value = None",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        fault = suds.WebFault(mock.Mock(), mock.Mock())",
            "        vcdriver._session.vim.client.service.Logout.side_effect = fault",
            "        vcdriver.cleanup_host(\"foo\")",
            "",
            "    def test_driver_capabilities(self):",
            "        self.assertTrue(self.conn.capabilities['has_imagecache'])",
            "        self.assertFalse(self.conn.capabilities['supports_recreate'])",
            "",
            "    def test_login_retries(self):",
            "        self.attempts = 0",
            "        self.login_session = vmwareapi_fake.FakeVim()._login()",
            "",
            "        def _fake_login(_self):",
            "            self.attempts += 1",
            "            if self.attempts == 1:",
            "                raise vexc.VimConnectionException('Here is my fake exception')",
            "            return self.login_session",
            "",
            "        def _fake_check_session(_self):",
            "            return True",
            "",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_login', _fake_login)",
            "        self.stubs.Set(vmwareapi_fake.FakeVim, '_check_session',",
            "                       _fake_check_session)",
            "",
            "        with mock.patch.object(greenthread, 'sleep'):",
            "            self.conn = driver.VMwareAPISession()",
            "        self.assertEqual(self.attempts, 2)",
            "",
            "    def _get_instance_type_by_name(self, type):",
            "        for instance_type in test_flavors.DEFAULT_FLAVORS:",
            "            if instance_type['name'] == type:",
            "                return instance_type",
            "        if type == 'm1.micro':",
            "            return {'memory_mb': 128, 'root_gb': 0, 'deleted_at': None,",
            "                    'name': 'm1.micro', 'deleted': 0, 'created_at': None,",
            "                    'ephemeral_gb': 0, 'updated_at': None,",
            "                    'disabled': False, 'vcpus': 1, 'extra_specs': {},",
            "                    'swap': 0, 'rxtx_factor': 1.0, 'is_public': True,",
            "                    'flavorid': '1', 'vcpu_weight': None, 'id': 2}",
            "",
            "    def _create_instance(self, node=None, set_image_ref=True,",
            "                         uuid=None, instance_type='m1.large'):",
            "        if not node:",
            "            node = self.node_name",
            "        if not uuid:",
            "            uuid = uuidutils.generate_uuid()",
            "        self.type_data = self._get_instance_type_by_name(instance_type)",
            "        values = {'name': 'fake_name',",
            "                  'id': 1,",
            "                  'uuid': uuid,",
            "                  'project_id': self.project_id,",
            "                  'user_id': self.user_id,",
            "                  'kernel_id': \"fake_kernel_uuid\",",
            "                  'ramdisk_id': \"fake_ramdisk_uuid\",",
            "                  'mac_address': \"de:ad:be:ef:be:ef\",",
            "                  'flavor': instance_type,",
            "                  'node': node,",
            "                  'memory_mb': self.type_data['memory_mb'],",
            "                  'root_gb': self.type_data['root_gb'],",
            "                  'ephemeral_gb': self.type_data['ephemeral_gb'],",
            "                  'vcpus': self.type_data['vcpus'],",
            "                  'swap': self.type_data['swap'],",
            "                  'expected_attrs': ['system_metadata'],",
            "        }",
            "        if set_image_ref:",
            "            values['image_ref'] = self.fake_image_uuid",
            "        self.instance_node = node",
            "        self.uuid = uuid",
            "        self.instance = fake_instance.fake_instance_obj(",
            "                self.context, **values)",
            "",
            "    def _create_vm(self, node=None, num_instances=1, uuid=None,",
            "                   instance_type='m1.large', powered_on=True):",
            "        \"\"\"Create and spawn the VM.\"\"\"",
            "        if not node:",
            "            node = self.node_name",
            "        self._create_instance(node=node, uuid=uuid,",
            "                              instance_type=instance_type)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=None)",
            "        self._check_vm_record(num_instances=num_instances,",
            "                              powered_on=powered_on)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def _get_vm_record(self):",
            "        # Get record for VM",
            "        vms = vmwareapi_fake._get_objects(\"VirtualMachine\")",
            "        for vm in vms.objects:",
            "            if vm.get('name') == self.uuid:",
            "                return vm",
            "        self.fail('Unable to find VM backing!')",
            "",
            "    def _check_vm_record(self, num_instances=1, powered_on=True):",
            "        \"\"\"Check if the spawned VM's properties correspond to the instance in",
            "        the db.",
            "        \"\"\"",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), num_instances)",
            "",
            "        # Get Nova record for VM",
            "        vm_info = self.conn.get_info({'uuid': self.uuid,",
            "                                      'name': 1,",
            "                                      'node': self.instance_node})",
            "",
            "        vm = self._get_vm_record()",
            "",
            "        # Check that m1.large above turned into the right thing.",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        vcpus = self.type_data['vcpus']",
            "        self.assertEqual(vm_info['max_mem'], mem_kib)",
            "        self.assertEqual(vm_info['mem'], mem_kib)",
            "        self.assertEqual(vm.get(\"summary.config.instanceUuid\"), self.uuid)",
            "        self.assertEqual(vm.get(\"summary.config.numCpu\"), vcpus)",
            "        self.assertEqual(vm.get(\"summary.config.memorySizeMB\"),",
            "                         self.type_data['memory_mb'])",
            "",
            "        self.assertEqual(",
            "            vm.get(\"config.hardware.device\").VirtualDevice[2].obj_name,",
            "            \"ns0:VirtualE1000\")",
            "        if powered_on:",
            "            # Check that the VM is running according to Nova",
            "            self.assertEqual(power_state.RUNNING, vm_info['state'])",
            "",
            "            # Check that the VM is running according to vSphere API.",
            "            self.assertEqual('poweredOn', vm.get(\"runtime.powerState\"))",
            "        else:",
            "            # Check that the VM is not running according to Nova",
            "            self.assertEqual(power_state.SHUTDOWN, vm_info['state'])",
            "",
            "            # Check that the VM is not running according to vSphere API.",
            "            self.assertEqual('poweredOff', vm.get(\"runtime.powerState\"))",
            "",
            "        found_vm_uuid = False",
            "        found_iface_id = False",
            "        extras = vm.get(\"config.extraConfig\")",
            "        for c in extras.OptionValue:",
            "            if (c.key == \"nvp.vm-uuid\" and c.value == self.instance['uuid']):",
            "                found_vm_uuid = True",
            "            if (c.key == \"nvp.iface-id.0\" and c.value == \"vif-xxx-yyy-zzz\"):",
            "                found_iface_id = True",
            "",
            "        self.assertTrue(found_vm_uuid)",
            "        self.assertTrue(found_iface_id)",
            "",
            "    def _check_vm_info(self, info, pwr_state=power_state.RUNNING):",
            "        \"\"\"Check if the get_info returned values correspond to the instance",
            "        object in the db.",
            "        \"\"\"",
            "        mem_kib = long(self.type_data['memory_mb']) << 10",
            "        self.assertEqual(info[\"state\"], pwr_state)",
            "        self.assertEqual(info[\"max_mem\"], mem_kib)",
            "        self.assertEqual(info[\"mem\"], mem_kib)",
            "        self.assertEqual(info[\"num_cpu\"], self.type_data['vcpus'])",
            "",
            "    def test_instance_exists(self):",
            "        self._create_vm()",
            "        self.assertTrue(self.conn.instance_exists(self.instance))",
            "        invalid_instance = dict(uuid='foo', name='bar', node=self.node_name)",
            "        self.assertFalse(self.conn.instance_exists(invalid_instance))",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_list_instances_1(self):",
            "        self._create_vm()",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "",
            "    def test_list_instance_uuids(self):",
            "        self._create_vm()",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 1)",
            "",
            "    def test_list_instance_uuids_invalid_uuid(self):",
            "        self._create_vm(uuid='fake_id')",
            "        uuids = self.conn.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 0)",
            "",
            "    def _cached_files_exist(self, exists=True):",
            "        cache = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                      self.fake_image_uuid,",
            "                                      '%s.vmdk' % self.fake_image_uuid)",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(str(cache)))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(str(cache)))",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_instance_dir_disk_created(self, mock_from_image):",
            "        \"\"\"Test image file is cached when even when use_linked_clone",
            "            is False",
            "        \"\"\"",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            linked_clone=False)",
            "",
            "        mock_from_image.return_value = img_props",
            "        self._create_vm()",
            "        path = ds_util.DatastorePath(self.ds, self.uuid, '%s.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "        self._cached_files_exist()",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_cache_dir_disk_created(self, mock_from_image):",
            "        \"\"\"Test image disk is cached when use_linked_clone is True.\"\"\"",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=1 * units.Ki,",
            "            disk_type=constants.DISK_TYPE_SPARSE)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        self._create_vm()",
            "        path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.vmdk' % self.fake_image_uuid)",
            "        root = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.80.vmdk' % self.fake_image_uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "        self.assertTrue(vmwareapi_fake.get_file(str(root)))",
            "",
            "    def _iso_disk_type_created(self, instance_type='m1.large'):",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm(instance_type=instance_type)",
            "        path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.iso' % self.fake_image_uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "",
            "    def test_iso_disk_type_created(self):",
            "        self._iso_disk_type_created()",
            "        path = ds_util.DatastorePath(self.ds, self.uuid, '%s.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(path)))",
            "",
            "    def test_iso_disk_type_created_with_root_gb_0(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        path = ds_util.DatastorePath(self.ds, self.uuid, '%s.vmdk' % self.uuid)",
            "        self.assertFalse(vmwareapi_fake.get_file(str(path)))",
            "",
            "    def test_iso_disk_cdrom_attach(self):",
            "        iso_path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                         self.fake_image_uuid,",
            "                                         '%s.iso' % self.fake_image_uuid)",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, str(iso_path))",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_iso_disk_cdrom_attach_with_config_drive(self,",
            "                                                     mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=80 * units.Gi,",
            "            file_type='iso',",
            "            linked_clone=False)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        self.flags(force_config_drive=True)",
            "        iso_path = [",
            "            ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                  self.fake_image_uuid,",
            "                                  '%s.iso' % self.fake_image_uuid),",
            "            ds_util.DatastorePath(self.ds, 'fake-config-drive')]",
            "        self.iso_index = 0",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, str(iso_path[self.iso_index]))",
            "            self.iso_index += 1",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self.image['disk_format'] = 'iso'",
            "        self._create_vm()",
            "        self.assertEqual(self.iso_index, 2)",
            "",
            "    def test_cdrom_attach_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "",
            "        iso_path = ds_util.DatastorePath(self.ds, 'fake-config-drive')",
            "        self.cd_attach_called = False",
            "",
            "        def fake_create_config_drive(instance, injected_files, password,",
            "                                     data_store_name, folder, uuid, cookies):",
            "            return 'fake-config-drive'",
            "",
            "        def fake_attach_cdrom(vm_ref, instance, data_store_ref,",
            "                              iso_uploaded_path):",
            "            self.assertEqual(iso_uploaded_path, str(iso_path))",
            "            self.cd_attach_called = True",
            "",
            "        self.stubs.Set(self.conn._vmops, \"_attach_cdrom_to_vm\",",
            "                       fake_attach_cdrom)",
            "        self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                       fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "        self.assertTrue(self.cd_attach_called)",
            "",
            "    def test_spawn(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_vm_ref_cached(self):",
            "        uuid = uuidutils.generate_uuid()",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(uuid))",
            "        self._create_vm(uuid=uuid)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get(uuid))",
            "",
            "    def _spawn_power_state(self, power_on):",
            "        self._spawn = self.conn._vmops.spawn",
            "        self._power_on = power_on",
            "",
            "        def _fake_spawn(context, instance, image_meta, injected_files,",
            "            admin_password, network_info, block_device_info=None,",
            "            instance_name=None, power_on=True):",
            "            return self._spawn(context, instance, image_meta,",
            "                               injected_files, admin_password, network_info,",
            "                               block_device_info=block_device_info,",
            "                               instance_name=instance_name,",
            "                               power_on=self._power_on)",
            "",
            "        with (",
            "            mock.patch.object(self.conn._vmops, 'spawn', _fake_spawn)",
            "        ):",
            "            self._create_vm(powered_on=power_on)",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            if power_on:",
            "                self._check_vm_info(info, power_state.RUNNING)",
            "            else:",
            "                self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "    def test_spawn_no_power_on(self):",
            "        self._spawn_power_state(False)",
            "",
            "    def test_spawn_power_on(self):",
            "        self._spawn_power_state(True)",
            "",
            "    def test_spawn_root_size_0(self):",
            "        self._create_vm(instance_type='m1.micro')",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        cache = ('[%s] vmware_base/%s/%s.vmdk' %",
            "                 (self.ds, self.fake_image_uuid, self.fake_image_uuid))",
            "        gb_cache = ('[%s] vmware_base/%s/%s.0.vmdk' %",
            "                    (self.ds, self.fake_image_uuid, self.fake_image_uuid))",
            "        self.assertTrue(vmwareapi_fake.get_file(cache))",
            "        self.assertFalse(vmwareapi_fake.get_file(gb_cache))",
            "",
            "    def _spawn_with_delete_exception(self, fault=None):",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=fault)",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            if fault:",
            "                self._create_vm()",
            "                info = self.conn.get_info({'uuid': self.uuid,",
            "                                           'node': self.instance_node})",
            "                self._check_vm_info(info, power_state.RUNNING)",
            "            else:",
            "                self.assertRaises(vexc.VMwareDriverException, self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_delete_exception_not_found(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileNotFound())",
            "",
            "    def test_spawn_with_delete_exception_file_fault(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileFault())",
            "",
            "    def test_spawn_with_delete_exception_cannot_delete_file(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.CannotDeleteFile())",
            "",
            "    def test_spawn_with_delete_exception_file_locked(self):",
            "        self._spawn_with_delete_exception(vmwareapi_fake.FileLocked())",
            "",
            "    def test_spawn_with_delete_exception_general(self):",
            "        self._spawn_with_delete_exception()",
            "",
            "    def test_spawn_disk_extend(self):",
            "        self.mox.StubOutWithMock(self.conn._vmops, '_extend_virtual_disk')",
            "        requested_size = 80 * units.Mi",
            "        self.conn._vmops._extend_virtual_disk(mox.IgnoreArg(),",
            "                requested_size, mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_spawn_disk_extend_exists(self):",
            "        root = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                     self.fake_image_uuid,",
            "                                     '%s.80.vmdk' % self.fake_image_uuid)",
            "",
            "        def _fake_extend(instance, requested_size, name, dc_ref):",
            "            vmwareapi_fake._add_file(str(root))",
            "",
            "        self.stubs.Set(self.conn._vmops, '_extend_virtual_disk',",
            "                       _fake_extend)",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(root)))",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_disk_extend_sparse(self, mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=units.Ki,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=True)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._vmops, '_extend_virtual_disk'),",
            "            mock.patch.object(self.conn._vmops, 'get_datacenter_ref_and_name'),",
            "        ) as (mock_extend, mock_get_dc):",
            "            dc_val = mock.Mock()",
            "            dc_val.ref = \"fake_dc_ref\"",
            "            dc_val.name = \"dc1\"",
            "            mock_get_dc.return_value = dc_val",
            "            self._create_vm()",
            "            iid = img_props.image_id",
            "            cached_image = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                                 iid, '%s.80.vmdk' % iid)",
            "            mock_extend.assert_called_once_with(",
            "                    self.instance, self.instance.root_gb * units.Mi,",
            "                    str(cached_image), \"fake_dc_ref\")",
            "",
            "    def test_spawn_disk_extend_failed_copy(self):",
            "        # Spawn instance",
            "        # copy for extend fails without creating a file",
            "        #",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "",
            "        CopyError = vexc.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == 'fake-copy-task':",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                return 'fake-copy-task'",
            "",
            "            return self.call_method(module, method, *args, **kwargs)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaving a file behind",
            "        #",
            "        # Expect the file to be cleaned up",
            "        # Expect the copy error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.task_ref = None",
            "        uuid = self.fake_image_uuid",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = vexc.FileFaultException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method),",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task)):",
            "            self.assertRaises(CopyError, self._create_vm)",
            "        self.assertFalse(vmwareapi_fake.get_file(cached_image))",
            "",
            "    def test_spawn_disk_extend_failed_partial_copy_failed_cleanup(self):",
            "        # Spawn instance",
            "        # Copy for extend fails, leaves file behind",
            "        # File cleanup fails",
            "        #",
            "        # Expect file to be left behind",
            "        # Expect file cleanup error to be raised",
            "        self.flags(use_linked_clone=True, group='vmware')",
            "        self.task_ref = None",
            "        uuid = self.fake_image_uuid",
            "        cached_image = '[%s] vmware_base/%s/%s.80.vmdk' % (self.ds,",
            "                                                           uuid, uuid)",
            "",
            "        CopyError = vexc.FileFaultException",
            "        DeleteError = vexc.CannotDeleteFileException",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "                # N.B. We don't test for -flat here because real",
            "                # CopyVirtualDisk_Task doesn't actually create it",
            "                raise CopyError('Copy failed!')",
            "            elif task_ref == 'fake-delete-task':",
            "                raise DeleteError('Delete failed!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            if method == \"DeleteDatastoreFile_Task\":",
            "                return 'fake-delete-task'",
            "",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"CopyVirtualDisk_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              new=fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              new=fake_call_method)):",
            "            self.assertRaises(DeleteError, self._create_vm)",
            "        self.assertTrue(vmwareapi_fake.get_file(cached_image))",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_disk_invalid_disk_size(self, mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=82 * units.Gi,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=True)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        self.assertRaises(exception.InstanceUnacceptable,",
            "                          self._create_vm)",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_disk_extend_insufficient_disk_space(self, mock_from_image):",
            "        img_props = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=1024,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=True)",
            "",
            "        mock_from_image.return_value = img_props",
            "",
            "        cached_image = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                             self.fake_image_uuid,",
            "                                             '%s.80.vmdk' %",
            "                                              self.fake_image_uuid)",
            "        tmp_file = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                         self.fake_image_uuid,",
            "                                         '%s.80-flat.vmdk' %",
            "                                          self.fake_image_uuid)",
            "",
            "        NoDiskSpace = vexc.get_fault_class('NoDiskSpace')",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                raise NoDiskSpace()",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == 'ExtendVirtualDisk_Task':",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (mock_wait_for_task, mock_call_method):",
            "            self.assertRaises(NoDiskSpace, self._create_vm)",
            "            self.assertFalse(vmwareapi_fake.get_file(str(cached_image)))",
            "            self.assertFalse(vmwareapi_fake.get_file(str(tmp_file)))",
            "",
            "    def test_spawn_with_move_file_exists_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise an file exists exception. The flag",
            "        # self.exception will be checked to see that",
            "        # the exception has indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise vexc.FileAlreadyExistsException()",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_general_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a general exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_wait_for_task(task_ref):",
            "            if task_ref == self.task_ref:",
            "                self.task_ref = None",
            "                self.exception = True",
            "                raise vexc.VMwareDriverException('Exception!')",
            "            return self.wait_task(task_ref)",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.task_ref = task_ref",
            "            return task_ref",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              fake_wait_for_task),",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ) as (_wait_for_task, _call_method):",
            "            self.assertRaises(vexc.VMwareDriverException,",
            "                              self._create_vm)",
            "            self.assertTrue(self.exception)",
            "",
            "    def test_spawn_with_move_poll_exception(self):",
            "        self.call_method = self.conn._session._call_method",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\")",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self.assertRaises(vexc.VMwareDriverException,",
            "                              self._create_vm)",
            "",
            "    def test_spawn_with_move_file_exists_poll_exception(self):",
            "        # The test will validate that the spawn completes",
            "        # successfully. The \"MoveDatastoreFile_Task\" will",
            "        # raise a file exists exception. The flag self.exception",
            "        # will be checked to see that the exception has",
            "        # indeed been raised.",
            "",
            "        def fake_call_method(module, method, *args, **kwargs):",
            "            task_ref = self.call_method(module, method, *args, **kwargs)",
            "            if method == \"MoveDatastoreFile_Task\":",
            "                self.exception = True",
            "                task_mdo = vmwareapi_fake.create_task(method, \"error\",",
            "                        error_fault=vmwareapi_fake.FileAlreadyExists())",
            "                return task_mdo.obj",
            "            return task_ref",
            "",
            "        with (",
            "            mock.patch.object(self.conn._session, '_call_method',",
            "                              fake_call_method)",
            "        ):",
            "            self._create_vm()",
            "            info = self.conn.get_info({'uuid': self.uuid,",
            "                                       'node': self.instance_node})",
            "            self._check_vm_info(info, power_state.RUNNING)",
            "            self.assertTrue(self.exception)",
            "",
            "    def _spawn_attach_volume_vmdk(self, set_image_ref=True, vc_support=False):",
            "        self._create_instance(set_image_ref=set_image_ref)",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        if vc_support:",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_get_res_pool_of_vm')",
            "            volumeops.VMwareVolumeOps._get_res_pool_of_vm(",
            "                     mox.IgnoreArg()).AndReturn('fake_res_pool')",
            "            self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                     '_relocate_vmdk_volume')",
            "            volumeops.VMwareVolumeOps._relocate_vmdk_volume(mox.IgnoreArg(),",
            "                     'fake_res_pool', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def test_spawn_attach_volume_iscsi(self):",
            "        self._create_instance()",
            "        self.mox.StubOutWithMock(block_device, 'volume_in_mapping')",
            "        self.mox.StubOutWithMock(v_driver, 'block_device_info_get_mapping')",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        root_disk = [{'connection_info': connection_info}]",
            "        v_driver.block_device_info_get_mapping(",
            "                mox.IgnoreArg()).AndReturn(root_disk)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_volume')",
            "        volumeops.VMwareVolumeOps.attach_volume(connection_info,",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        block_device_info = {'mount_device': 'vda'}",
            "        self.conn.spawn(self.context, self.instance, self.image,",
            "                        injected_files=[], admin_password=None,",
            "                        network_info=self.network_info,",
            "                        block_device_info=block_device_info)",
            "",
            "    def mock_upload_image(self, context, image, instance, **kwargs):",
            "        self.assertEqual(image, 'Test-Snapshot')",
            "        self.assertEqual(instance, self.instance)",
            "        self.assertEqual(kwargs['disk_type'], 'preallocated')",
            "",
            "    def test_get_vm_ref_using_extra_config(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        # Disrupt the fake Virtual Machine object so that extraConfig",
            "        # cannot be matched.",
            "        fake_vm = self._get_vm_record()",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"\"",
            "        # We should not get a Virtual Machine through extraConfig.",
            "        vm_ref = vm_util._get_vm_ref_from_extraconfig(self.conn._session,",
            "                                                     self.instance['uuid'])",
            "        self.assertIsNone(vm_ref, 'VM Reference should be none')",
            "        # Check if we can find the Virtual Machine using the name.",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def test_search_vm_ref_by_identifier(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self.conn._session,",
            "                                            self.instance['uuid'])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "        fake_vm = self._get_vm_record()",
            "        fake_vm.set(\"summary.config.instanceUuid\", \"foo\")",
            "        fake_vm.set(\"name\", \"foo\")",
            "        fake_vm.get('config.extraConfig[\"nvp.vm-uuid\"]').value = \"foo\"",
            "        self.assertIsNone(vm_util.search_vm_ref_by_identifier(",
            "                                    self.conn._session, self.instance['uuid']),",
            "                          \"VM Reference should be none\")",
            "        self.assertIsNotNone(",
            "                vm_util.search_vm_ref_by_identifier(self.conn._session, \"foo\"),",
            "                \"VM Reference should not be none\")",
            "",
            "    def test_get_object_for_optionvalue(self):",
            "        self._create_vm()",
            "        vms = self.conn._session._call_method(vim_util, \"get_objects\",",
            "                \"VirtualMachine\", ['config.extraConfig[\"nvp.vm-uuid\"]'])",
            "        vm_ref = vm_util._get_object_for_optionvalue(vms,",
            "                                                     self.instance[\"uuid\"])",
            "        self.assertIsNotNone(vm_ref, 'VM Reference cannot be none')",
            "",
            "    def _test_snapshot(self):",
            "        expected_calls = [",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_PENDING_UPLOAD}},",
            "            {'args': (),",
            "             'kwargs':",
            "                 {'task_state': task_states.IMAGE_UPLOADING,",
            "                  'expected_state': task_states.IMAGE_PENDING_UPLOAD}}]",
            "        func_call_matcher = matchers.FunctionCallMatcher(expected_calls)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        with mock.patch.object(vmware_images, 'upload_image',",
            "                               self.mock_upload_image):",
            "            self.conn.snapshot(self.context, self.instance, \"Test-Snapshot\",",
            "                               func_call_matcher.call)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertIsNone(func_call_matcher.match())",
            "",
            "    def test_snapshot(self):",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_no_root_disk(self):",
            "        self._iso_disk_type_created(instance_type='m1.micro')",
            "        self.assertRaises(error_util.NoRootDiskDefined, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.snapshot,",
            "                          self.context, self.instance, \"Test-Snapshot\",",
            "                          lambda *args, **kwargs: None)",
            "",
            "    def test_snapshot_delete_vm_snapshot(self):",
            "        self._create_vm()",
            "        fake_vm = self._get_vm_record()",
            "        snapshot_ref = vmwareapi_fake.ManagedObjectReference(",
            "                               value=\"Snapshot-123\",",
            "                               name=\"VirtualMachineSnapshot\")",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_create_vm_snapshot')",
            "        self.conn._vmops._create_vm_snapshot(",
            "                self.instance, fake_vm.obj).AndReturn(snapshot_ref)",
            "",
            "        self.mox.StubOutWithMock(vmops.VMwareVMOps,",
            "                                 '_delete_vm_snapshot')",
            "        self.conn._vmops._delete_vm_snapshot(",
            "                self.instance, fake_vm.obj, snapshot_ref).AndReturn(None)",
            "        self.mox.ReplayAll()",
            "",
            "        self._test_snapshot()",
            "",
            "    def _snapshot_delete_vm_snapshot_exception(self, exception, call_count=1):",
            "        self._create_vm()",
            "        fake_vm = vmwareapi_fake._get_objects(\"VirtualMachine\").objects[0].obj",
            "        snapshot_ref = vmwareapi_fake.ManagedObjectReference(",
            "                               value=\"Snapshot-123\",",
            "                               name=\"VirtualMachineSnapshot\")",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._session, '_wait_for_task',",
            "                              side_effect=exception),",
            "            mock.patch.object(vmops, '_time_sleep_wrapper')",
            "        ) as (_fake_wait, _fake_sleep):",
            "            if exception != error_util.TaskInProgress:",
            "                self.assertRaises(exception,",
            "                                  self.conn._vmops._delete_vm_snapshot,",
            "                                  self.instance, fake_vm, snapshot_ref)",
            "                self.assertEqual(0, _fake_sleep.call_count)",
            "            else:",
            "                self.conn._vmops._delete_vm_snapshot(self.instance, fake_vm,",
            "                                                     snapshot_ref)",
            "                self.assertEqual(call_count - 1, _fake_sleep.call_count)",
            "            self.assertEqual(call_count, _fake_wait.call_count)",
            "",
            "    def test_snapshot_delete_vm_snapshot_exception(self):",
            "        self._snapshot_delete_vm_snapshot_exception(exception.NovaException)",
            "",
            "    def test_snapshot_delete_vm_snapshot_exception_retry(self):",
            "        self.flags(api_retry_count=5, group='vmware')",
            "        self._snapshot_delete_vm_snapshot_exception(error_util.TaskInProgress,",
            "                                                    5)",
            "",
            "    def test_reboot(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_with_uuid(self):",
            "        \"\"\"Test fall back to use name when can't find by uuid.\"\"\"",
            "        self._create_vm()",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        reboot_type = \"SOFT\"",
            "        self.conn.reboot(self.context, self.instance, self.network_info,",
            "                         reboot_type)",
            "        info = self.conn.get_info({'name': 'fake-name', 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_reboot_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_poll_rebooting_instances(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'reboot')",
            "        compute_api.API.reboot(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                               mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self._create_vm()",
            "        instances = [self.instance]",
            "        self.conn.poll_rebooting_instances(60, instances)",
            "",
            "    def test_reboot_not_poweredon(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.assertRaises(exception.InstanceRebootFailure, self.conn.reboot,",
            "                          self.context, self.instance, self.network_info,",
            "                          'SOFT')",
            "",
            "    def test_suspend(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "",
            "    def test_suspend_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.suspend,",
            "                          self.instance)",
            "",
            "    def test_resume(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.suspend(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SUSPENDED)",
            "        self.conn.resume(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_resume_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_resume_not_suspended(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.assertRaises(exception.InstanceResumeFailure, self.conn.resume,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_on(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.conn.power_on(self.context, self.instance, self.network_info)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_power_on_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_on,",
            "                          self.context, self.instance, self.network_info)",
            "",
            "    def test_power_off(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.power_off(self.instance)",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "    def test_power_off_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound, self.conn.power_off,",
            "                          self.instance)",
            "",
            "    def test_resume_state_on_host_boot(self):",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, \"reboot\")",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOff\")",
            "        self.conn.reboot(self.context, self.instance, 'network_info',",
            "            'hard', None)",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_1(self):",
            "        \"\"\"Don't call reboot on instance which is poweredon.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"poweredOn\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def test_resume_state_on_host_boot_no_reboot_2(self):",
            "        \"\"\"Don't call reboot on instance which is suspended.\"\"\"",
            "        self._create_vm()",
            "        self.mox.StubOutWithMock(vm_util, 'get_vm_state_from_name')",
            "        self.mox.StubOutWithMock(self.conn, 'reboot')",
            "        vm_util.get_vm_state_from_name(mox.IgnoreArg(),",
            "            self.instance['uuid']).AndReturn(\"suspended\")",
            "        self.mox.ReplayAll()",
            "        self.conn.resume_state_on_host_boot(self.context, self.instance,",
            "            'network_info')",
            "",
            "    def destroy_rescued(self, fake_method):",
            "        self._rescue()",
            "        with contextlib.nested(",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              fake_method),",
            "            mock.patch.object(vm_util, \"power_on_instance\"),",
            "        ) as (fake_detach, fake_power_on):",
            "            self.instance['vm_state'] = vm_states.RESCUED",
            "            self.conn.destroy(self.context, self.instance, self.network_info)",
            "            inst_path = ds_util.DatastorePath(self.ds, self.uuid,",
            "                                              '%s.vmdk' % self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(str(inst_path)))",
            "            rescue_file_path = ds_util.DatastorePath(",
            "                self.ds, '%s-rescue' % self.uuid, '%s-rescue.vmdk' % self.uuid)",
            "            self.assertFalse(vmwareapi_fake.get_file(str(rescue_file_path)))",
            "            # Unrescue does not power on with destroy",
            "            self.assertFalse(fake_power_on.called)",
            "",
            "    def test_destroy_rescued(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            pass",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy_rescued_with_exception(self):",
            "        def fake_detach_disk_from_vm(*args, **kwargs):",
            "            raise exception.NovaException('Here is my fake exception')",
            "        self.destroy_rescued(fake_detach_disk_from_vm)",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 1)",
            "        # Overwrite the vmPathName",
            "        vm = self._get_vm_record()",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(len(instances), 0)",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)",
            "",
            "    def test_destroy_instance_without_vm_ref(self):",
            "        self._create_instance()",
            "        with contextlib.nested(",
            "             mock.patch.object(vm_util, 'get_vm_ref_from_name',",
            "                               return_value=None),",
            "             mock.patch.object(self.conn._session,",
            "                               '_call_method')",
            "        ) as (mock_get, mock_call):",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, True)",
            "            mock_get.assert_called_with(self.conn._vmops._session,",
            "                                        self.instance['uuid'])",
            "            expected_args = [((self.conn._vmops._session,",
            "                               self.instance['uuid'] + '-orig'),),",
            "                             ((self.conn._vmops._session,",
            "                               self.instance['uuid']),)]",
            "            # one for VM named uuid-orig, one for VM named uuid",
            "            self.assertEqual(expected_args, mock_get.call_args_list)",
            "            self.assertEqual(2, mock_get.call_count)",
            "            self.assertFalse(mock_call.called)",
            "",
            "    def _rescue(self, config_drive=False):",
            "        # validate that the power on is only called once",
            "        self._power_on = vm_util.power_on_instance",
            "        self._power_on_called = 0",
            "",
            "        def fake_attach_disk_to_vm(vm_ref, instance,",
            "                                   adapter_type, disk_type, vmdk_path=None,",
            "                                   disk_size=None, linked_clone=False,",
            "                                   controller_key=None, unit_number=None,",
            "                                   device_name=None):",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        if config_drive:",
            "            def fake_create_config_drive(instance, injected_files, password,",
            "                                         data_store_name, folder,",
            "                                         instance_uuid, cookies):",
            "                self.assertTrue(uuidutils.is_uuid_like(instance['uuid']))",
            "                return str(ds_util.DatastorePath(data_store_name,",
            "                                                 instance_uuid, 'fake.iso'))",
            "",
            "            self.stubs.Set(self.conn._vmops, '_create_config_drive',",
            "                           fake_create_config_drive)",
            "",
            "        self._create_vm()",
            "",
            "        def fake_power_on_instance(session, instance, vm_ref=None):",
            "            self._power_on_called += 1",
            "            return self._power_on(session, instance, vm_ref=vm_ref)",
            "",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.stubs.Set(vm_util, \"power_on_instance\",",
            "                       fake_power_on_instance)",
            "        self.stubs.Set(self.conn._volumeops, \"attach_disk_to_vm\",",
            "                       fake_attach_disk_to_vm)",
            "",
            "        self.conn.rescue(self.context, self.instance, self.network_info,",
            "                         self.image, 'fake-password')",
            "",
            "        info = self.conn.get_info({'name': '1-rescue',",
            "                                   'uuid': '%s-rescue' % self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        info = self.conn.get_info({'name': 1, 'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.SHUTDOWN)",
            "        self.assertIsNotNone(vm_util.vm_ref_cache_get('%s-rescue' % self.uuid))",
            "        self.assertEqual(1, self._power_on_called)",
            "",
            "    def test_rescue(self):",
            "        self._rescue()",
            "        inst_file_path = ds_util.DatastorePath(self.ds, self.uuid,",
            "                                               '%s.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(inst_file_path)))",
            "        rescue_file_path = ds_util.DatastorePath(self.ds,",
            "                                                 '%s-rescue' % self.uuid,",
            "                                                 '%s-rescue.vmdk' % self.uuid)",
            "        self.assertTrue(vmwareapi_fake.get_file(str(rescue_file_path)))",
            "",
            "    def test_rescue_with_config_drive(self):",
            "        self.flags(force_config_drive=True)",
            "        self._rescue(config_drive=True)",
            "",
            "    def test_unrescue(self):",
            "        # NOTE(dims): driver unrescue ends up eventually in vmops.unrescue",
            "        # with power_on=True, the test_destroy_rescued tests the",
            "        # vmops.unrescue with power_on=False",
            "        self._rescue()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session,",
            "                                    self.instance)",
            "        vm_rescue_ref = vm_util.get_vm_ref_from_name(self.conn._session,",
            "                                                     '%s-rescue' % self.uuid)",
            "",
            "        self.poweroff_instance = vm_util.power_off_instance",
            "",
            "        def fake_power_off_instance(session, instance, vm_ref):",
            "            # This is called so that we actually poweroff the simulated vm.",
            "            # The reason for this is that there is a validation in destroy",
            "            # that the instance is not powered on.",
            "            self.poweroff_instance(session, instance, vm_ref)",
            "",
            "        def fake_detach_disk_from_vm(vm_ref, instance,",
            "                                     device_name, destroy_disk=False):",
            "            self.test_device_name = device_name",
            "            info = self.conn.get_info(instance)",
            "            self._check_vm_info(info, power_state.SHUTDOWN)",
            "",
            "        with contextlib.nested(",
            "            mock.patch.object(vm_util, \"power_off_instance\",",
            "                              side_effect=fake_power_off_instance),",
            "            mock.patch.object(self.conn._volumeops, \"detach_disk_from_vm\",",
            "                              side_effect=fake_detach_disk_from_vm),",
            "            mock.patch.object(vm_util, \"power_on_instance\"),",
            "        ) as (poweroff, detach, fake_power_on):",
            "            self.conn.unrescue(self.instance, None)",
            "            poweroff.assert_called_once_with(self.conn._session, mock.ANY,",
            "                                             vm_rescue_ref)",
            "            detach.assert_called_once_with(vm_rescue_ref, mock.ANY,",
            "                                           self.test_device_name)",
            "            fake_power_on.assert_called_once_with(self.conn._session,",
            "                                                  self.instance,",
            "                                                  vm_ref=vm_ref)",
            "            self.test_vm_ref = None",
            "            self.test_device_name = None",
            "",
            "    def test_get_diagnostics(self):",
            "        self._create_vm()",
            "        expected = {'memoryReservation': 0, 'suspendInterval': 0,",
            "                    'maxCpuUsage': 2000, 'toolsInstallerMounted': False,",
            "                    'consumedOverheadMemory': 20, 'numEthernetCards': 1,",
            "                    'numCpu': 1, 'featureRequirement': [{'key': 'cpuid.AES'}],",
            "                    'memoryOverhead': 21417984,",
            "                    'guestMemoryUsage': 0, 'connectionState': 'connected',",
            "                    'memorySizeMB': 512, 'balloonedMemory': 0,",
            "                    'vmPathName': 'fake_path', 'template': False,",
            "                    'overallCpuUsage': 0, 'powerState': 'poweredOn',",
            "                    'cpuReservation': 0, 'overallCpuDemand': 0,",
            "                    'numVirtualDisks': 1, 'hostMemoryUsage': 141}",
            "        expected = dict([('vmware:' + k, v) for k, v in expected.items()])",
            "        self.assertThat(",
            "                self.conn.get_diagnostics({'name': 1, 'uuid': self.uuid,",
            "                                           'node': self.instance_node}),",
            "                matchers.DictMatches(expected))",
            "",
            "    def test_get_instance_diagnostics(self):",
            "        self._create_vm()",
            "        expected = {'uptime': 0,",
            "                    'memory_details': {'used': 0, 'maximum': 512},",
            "                    'nic_details': [],",
            "                    'driver': 'vmwareapi',",
            "                    'state': 'running',",
            "                    'version': '1.0',",
            "                    'cpu_details': [],",
            "                    'disk_details': [],",
            "                    'hypervisor_os': 'esxi',",
            "                    'config_drive': False}",
            "        actual = self.conn.get_instance_diagnostics(",
            "                {'name': 1, 'uuid': self.uuid, 'node': self.instance_node})",
            "        self.assertThat(actual.serialize(), matchers.DictMatches(expected))",
            "",
            "    def test_get_console_output(self):",
            "        self.assertRaises(NotImplementedError, self.conn.get_console_output,",
            "            None, None)",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        self._create_vm()",
            "        self.conn.finish_migration(context=self.context,",
            "                                   migration=None,",
            "                                   instance=self.instance,",
            "                                   disk_info=None,",
            "                                   network_info=None,",
            "                                   block_device_info=None,",
            "                                   resize_instance=resize_instance,",
            "                                   image_meta=None,",
            "                                   power_on=power_on)",
            "",
            "    def _test_finish_revert_migration(self, power_on):",
            "        self._create_vm()",
            "        # Ensure ESX driver throws an error",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.finish_revert_migration,",
            "                          self.context,",
            "                          instance=self.instance,",
            "                          network_info=None)",
            "",
            "    def test_get_vnc_console_non_existent(self):",
            "        self._create_instance()",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def _test_get_vnc_console(self):",
            "        self._create_vm()",
            "        fake_vm = self._get_vm_record()",
            "        OptionValue = collections.namedtuple('OptionValue', ['key', 'value'])",
            "        opt_val = OptionValue(key='', value=5906)",
            "        fake_vm.set(vm_util.VNC_CONFIG_KEY, opt_val)",
            "        vnc_console = self.conn.get_vnc_console(self.context, self.instance)",
            "        self.assertEqual(self.vnc_host, vnc_console.host)",
            "        self.assertEqual(5906, vnc_console.port)",
            "",
            "    def test_get_vnc_console(self):",
            "        self._test_get_vnc_console()",
            "",
            "    def test_get_vnc_console_noport(self):",
            "        self._create_vm()",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          self.conn.get_vnc_console,",
            "                          self.context,",
            "                          self.instance)",
            "",
            "    def test_get_volume_connector(self):",
            "        self._create_vm()",
            "        connector_dict = self.conn.get_volume_connector(self.instance)",
            "        fake_vm = self._get_vm_record()",
            "        fake_vm_id = fake_vm.obj.value",
            "        self.assertEqual(connector_dict['ip'], 'test_url')",
            "        self.assertEqual(connector_dict['initiator'], 'iscsi-name')",
            "        self.assertEqual(connector_dict['host'], 'test_url')",
            "        self.assertEqual(connector_dict['instance'], fake_vm_id)",
            "",
            "    def _test_vmdk_connection_info(self, type):",
            "        return {'driver_volume_type': type,",
            "                'serial': 'volume-fake-id',",
            "                'data': {'volume': 'vm-10',",
            "                         'volume_id': 'volume-fake-id'}}",
            "",
            "    def test_volume_attach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._attach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_vmdk(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_vmdk')",
            "        volumeops.VMwareVolumeOps._detach_volume_vmdk(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_vmdk_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "",
            "        # create fake backing info",
            "        volume_device = vmwareapi_fake.DataObject()",
            "        volume_device.backing = vmwareapi_fake.DataObject()",
            "        volume_device.backing.fileName = 'fake_path'",
            "",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_vmdk_base_volume_device')",
            "        volumeops.VMwareVolumeOps._get_vmdk_base_volume_device(",
            "                mox.IgnoreArg()).AndReturn(volume_device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), mox.IgnoreArg(),",
            "                vmdk_path='fake_path')",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_detach_vmdk_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('vmdk')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_get_volume_uuid')",
            "        volumeops.VMwareVolumeOps._get_volume_uuid(mox.IgnoreArg(),",
            "                'volume-fake-id').AndReturn('fake_disk_uuid')",
            "        self.mox.StubOutWithMock(vm_util, 'get_vmdk_backed_disk_device')",
            "        vm_util.get_vmdk_backed_disk_device(mox.IgnoreArg(),",
            "                'fake_disk_uuid').AndReturn('fake_device')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_consolidate_vmdk_volume')",
            "        volumeops.VMwareVolumeOps._consolidate_vmdk_volume(self.instance,",
            "                 mox.IgnoreArg(), 'fake_device', mox.IgnoreArg())",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_volume_attach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_attach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._attach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_volume_detach_iscsi(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        mount_point = '/dev/vdc'",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_detach_volume_iscsi')",
            "        volumeops.VMwareVolumeOps._detach_volume_iscsi(connection_info,",
            "                self.instance, mount_point)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_attach_iscsi_disk_to_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_host:port'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        discover = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_get_target')",
            "        # simulate target not found",
            "        volumeops.VMwareVolumeOps._iscsi_get_target(",
            "            connection_info['data']).AndReturn((None, None))",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_add_send_target_host')",
            "        # rescan gets called with target portal",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_rescan_hba')",
            "        volumeops.VMwareVolumeOps._iscsi_rescan_hba(",
            "            connection_info['data']['target_portal'])",
            "        # simulate target found",
            "        volumeops.VMwareVolumeOps._iscsi_get_target(",
            "            connection_info['data']).AndReturn(discover)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'attach_disk_to_vm')",
            "        volumeops.VMwareVolumeOps.attach_disk_to_vm(mox.IgnoreArg(),",
            "                self.instance, mox.IgnoreArg(), 'rdmp',",
            "                device_name=mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "        self.conn.attach_volume(None, connection_info, self.instance,",
            "                                mount_point)",
            "",
            "    def test_iscsi_rescan_hba(self):",
            "        fake_target_portal = 'fake_target_host:port'",
            "        host_storage_sys = vmwareapi_fake._get_objects(",
            "            \"HostStorageSystem\").objects[0]",
            "        iscsi_hba_array = host_storage_sys.get('storageDeviceInfo'",
            "                                               '.hostBusAdapter')",
            "        iscsi_hba = iscsi_hba_array.HostHostBusAdapter[0]",
            "        # Check the host system does not have the send target",
            "        self.assertRaises(AttributeError, getattr, iscsi_hba,",
            "                          'configuredSendTarget')",
            "        # Rescan HBA with the target portal",
            "        vops = volumeops.VMwareVolumeOps(self.conn._session)",
            "        vops._iscsi_rescan_hba(fake_target_portal)",
            "        # Check if HBA has the target portal configured",
            "        self.assertEqual('fake_target_host',",
            "                          iscsi_hba.configuredSendTarget[0].address)",
            "        # Rescan HBA with same portal",
            "        vops._iscsi_rescan_hba(fake_target_portal)",
            "        self.assertEqual(1, len(iscsi_hba.configuredSendTarget))",
            "",
            "    def test_iscsi_get_target(self):",
            "        data = {'target_portal': 'fake_target_host:port',",
            "                'target_iqn': 'fake_target_iqn'}",
            "        host = vmwareapi_fake._get_objects('HostSystem').objects[0]",
            "        host._add_iscsi_target(data)",
            "        vops = volumeops.VMwareVolumeOps(self.conn._session)",
            "        result = vops._iscsi_get_target(data)",
            "        self.assertEqual(('fake-device', 'fake-uuid'), result)",
            "",
            "    def test_detach_iscsi_disk_from_vm(self):",
            "        self._create_vm()",
            "        connection_info = self._test_vmdk_connection_info('iscsi')",
            "        connection_info['data']['target_portal'] = 'fake_target_portal'",
            "        connection_info['data']['target_iqn'] = 'fake_target_iqn'",
            "        mount_point = '/dev/vdc'",
            "        find = ('fake_name', 'fake_uuid')",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 '_iscsi_get_target')",
            "        volumeops.VMwareVolumeOps._iscsi_get_target(",
            "            connection_info['data']).AndReturn(find)",
            "        self.mox.StubOutWithMock(vm_util, 'get_rdm_disk')",
            "        device = 'fake_device'",
            "        vm_util.get_rdm_disk(mox.IgnoreArg(), 'fake_uuid').AndReturn(device)",
            "        self.mox.StubOutWithMock(volumeops.VMwareVolumeOps,",
            "                                 'detach_disk_from_vm')",
            "        volumeops.VMwareVolumeOps.detach_disk_from_vm(mox.IgnoreArg(),",
            "                self.instance, device, destroy_disk=True)",
            "        self.mox.ReplayAll()",
            "        self.conn.detach_volume(connection_info, self.instance, mount_point,",
            "                                encryption=None)",
            "",
            "    def test_connection_info_get(self):",
            "        self._create_vm()",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertIn('instance', connector)",
            "",
            "    def test_connection_info_get_after_destroy(self):",
            "        self._create_vm()",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        connector = self.conn.get_volume_connector(self.instance)",
            "        self.assertEqual(connector['ip'], 'test_url')",
            "        self.assertEqual(connector['host'], 'test_url')",
            "        self.assertEqual(connector['initiator'], 'iscsi-name')",
            "        self.assertNotIn('instance', connector)",
            "",
            "    def test_refresh_instance_security_rules(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.refresh_instance_security_rules,",
            "                          instance=None)",
            "",
            "    def test_image_aging_image_used(self):",
            "        self._create_vm()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "",
            "    def _get_timestamp_filename(self):",
            "        return '%s%s' % (imagecache.TIMESTAMP_PREFIX,",
            "                         timeutils.strtime(at=self.old_time,",
            "                                           fmt=imagecache.TIMESTAMP_FORMAT))",
            "",
            "    def _override_time(self):",
            "        self.old_time = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "",
            "        def _fake_get_timestamp_filename(fake):",
            "            return self._get_timestamp_filename()",
            "",
            "        self.stubs.Set(imagecache.ImageCacheManager, '_get_timestamp_filename',",
            "                       _fake_get_timestamp_filename)",
            "",
            "    def _timestamp_file_exists(self, exists=True):",
            "        timestamp = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                          self.fake_image_uuid,",
            "                                          self._get_timestamp_filename() + '/')",
            "        if exists:",
            "            self.assertTrue(vmwareapi_fake.get_file(str(timestamp)))",
            "        else:",
            "            self.assertFalse(vmwareapi_fake.get_file(str(timestamp)))",
            "",
            "    def _image_aging_image_marked_for_deletion(self):",
            "        self._create_vm(uuid=uuidutils.generate_uuid())",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist()",
            "        self._timestamp_file_exists()",
            "",
            "    def test_image_aging_image_marked_for_deletion(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "",
            "    def _timestamp_file_removed(self):",
            "        self._override_time()",
            "        self._image_aging_image_marked_for_deletion()",
            "        self._create_vm(num_instances=2,",
            "                        uuid=uuidutils.generate_uuid())",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_timestamp_file_removed_spawn(self):",
            "        self._timestamp_file_removed()",
            "",
            "    def test_timestamp_file_removed_aging(self):",
            "        self._timestamp_file_removed()",
            "        ts = self._get_timestamp_filename()",
            "        ts_path = ds_util.DatastorePath(self.ds, 'vmware_base',",
            "                                        self.fake_image_uuid, ts + '/')",
            "        vmwareapi_fake._add_file(str(ts_path))",
            "        self._timestamp_file_exists()",
            "        all_instances = [self.instance]",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def test_image_aging_disabled(self):",
            "        self._override_time()",
            "        self.flags(remove_unused_base_images=False)",
            "        self._create_vm()",
            "        self._cached_files_exist()",
            "        all_instances = []",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "        self._cached_files_exist(exists=True)",
            "        self._timestamp_file_exists(exists=False)",
            "",
            "    def _image_aging_aged(self, aging_time=100):",
            "        self._override_time()",
            "        cur_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.flags(remove_unused_original_minimum_age_seconds=aging_time)",
            "        self._image_aging_image_marked_for_deletion()",
            "        all_instances = []",
            "        timeutils.set_time_override(cur_time)",
            "        self.conn.manage_image_cache(self.context, all_instances)",
            "",
            "    def test_image_aging_aged(self):",
            "        self._image_aging_aged(aging_time=8)",
            "        self._cached_files_exist(exists=False)",
            "",
            "    def test_image_aging_not_aged(self):",
            "        self._image_aging_aged()",
            "        self._cached_files_exist()",
            "",
            "",
            "class VMwareAPIVCDriverTestCase(VMwareAPIVMTestCase):",
            "",
            "    def setUp(self):",
            "",
            "        super(VMwareAPIVCDriverTestCase, self).setUp(create_connection=False)",
            "        cluster_name = 'test_cluster'",
            "        cluster_name2 = 'test_cluster2'",
            "        self.flags(cluster_name=[cluster_name, cluster_name2],",
            "                   api_retry_count=1,",
            "                   task_poll_interval=10, datastore_regex='.*', group='vmware')",
            "        self.flags(vnc_enabled=False,",
            "                   image_cache_subdirectory_name='vmware_base')",
            "        vmwareapi_fake.reset()",
            "        self.conn = driver.VMwareVCDriver(None, False)",
            "        self._set_exception_vars()",
            "        self.node_name = self.conn._resources.keys()[0]",
            "        self.node_name2 = self.conn._resources.keys()[1]",
            "        if cluster_name2 in self.node_name2:",
            "            self.ds = 'ds1'",
            "        else:",
            "            self.ds = 'ds2'",
            "        self.vnc_host = 'ha-host'",
            "",
            "    def tearDown(self):",
            "        super(VMwareAPIVCDriverTestCase, self).tearDown()",
            "        vmwareapi_fake.cleanup()",
            "",
            "    def test_public_api_signatures(self):",
            "        self.assertPublicAPISignatures(v_driver.ComputeDriver(None), self.conn)",
            "",
            "    def test_list_instances(self):",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_list_instances_from_nodes(self):",
            "        # Create instance on node1",
            "        self._create_vm(self.node_name)",
            "        # Create instances on the other node",
            "        self._create_vm(self.node_name2, num_instances=2)",
            "        self._create_vm(self.node_name2, num_instances=3)",
            "        node1_vmops = self.conn._get_vmops_for_compute_node(self.node_name)",
            "        node2_vmops = self.conn._get_vmops_for_compute_node(self.node_name2)",
            "        self.assertEqual(1, len(node1_vmops.list_instances()))",
            "        self.assertEqual(2, len(node2_vmops.list_instances()))",
            "        self.assertEqual(3, len(self.conn.list_instances()))",
            "",
            "    def _setup_mocks_for_session(self, mock_init):",
            "        mock_init.return_value = None",
            "",
            "        vcdriver = driver.VMwareVCDriver(None, False)",
            "        vcdriver._session = mock.Mock()",
            "        vcdriver._session.vim = None",
            "",
            "        def side_effect():",
            "            vcdriver._session.vim = mock.Mock()",
            "        vcdriver._session._create_session.side_effect = side_effect",
            "        return vcdriver",
            "",
            "    def test_host_power_action(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_power_action, 'host', 'action')",
            "",
            "    def test_host_maintenance_mode(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.host_maintenance_mode, 'host', 'mode')",
            "",
            "    def test_set_host_enabled(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.set_host_enabled, 'host', 'state')",
            "",
            "    def test_datastore_regex_configured(self):",
            "        for node in self.conn._resources.keys():",
            "            self.assertEqual(self.conn._datastore_regex,",
            "                    self.conn._resources[node]['vmops']._datastore_regex)",
            "",
            "    def test_get_available_resource(self):",
            "        stats = self.conn.get_available_resource(self.node_name)",
            "        cpu_info = {\"model\": [\"Intel(R) Xeon(R)\", \"Intel(R) Xeon(R)\"],",
            "                    \"vendor\": [\"Intel\", \"Intel\"],",
            "                    \"topology\": {\"cores\": 16,",
            "                                 \"threads\": 32}}",
            "        self.assertEqual(stats['vcpus'], 32)",
            "        self.assertEqual(stats['local_gb'], 1024)",
            "        self.assertEqual(stats['local_gb_used'], 1024 - 500)",
            "        self.assertEqual(stats['memory_mb'], 1000)",
            "        self.assertEqual(stats['memory_mb_used'], 500)",
            "        self.assertEqual(stats['hypervisor_type'], 'VMware vCenter Server')",
            "        self.assertEqual(stats['hypervisor_version'], 5001000)",
            "        self.assertEqual(stats['hypervisor_hostname'], self.node_name)",
            "        self.assertEqual(stats['cpu_info'], jsonutils.dumps(cpu_info))",
            "        self.assertEqual(stats['supported_instances'],",
            "                '[[\"i686\", \"vmware\", \"hvm\"], [\"x86_64\", \"vmware\", \"hvm\"]]')",
            "",
            "    def test_invalid_datastore_regex(self):",
            "",
            "        # Tests if we raise an exception for Invalid Regular Expression in",
            "        # vmware_datastore_regex",
            "        self.flags(cluster_name=['test_cluster'], datastore_regex='fake-ds(01',",
            "                   group='vmware')",
            "        self.assertRaises(exception.InvalidInput, driver.VMwareVCDriver, None)",
            "",
            "    def test_get_available_nodes(self):",
            "        nodelist = self.conn.get_available_nodes()",
            "        self.assertEqual(len(nodelist), 2)",
            "        self.assertIn(self.node_name, nodelist)",
            "        self.assertIn(self.node_name2, nodelist)",
            "",
            "    def test_spawn_multiple_node(self):",
            "",
            "        def fake_is_neutron():",
            "            return False",
            "",
            "        self.stubs.Set(nova_utils, 'is_neutron', fake_is_neutron)",
            "        uuid1 = uuidutils.generate_uuid()",
            "        uuid2 = uuidutils.generate_uuid()",
            "        self._create_vm(node=self.node_name, num_instances=1,",
            "                        uuid=uuid1)",
            "        info = self.conn.get_info({'uuid': uuid1,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        self._create_vm(node=self.node_name2, num_instances=1,",
            "                        uuid=uuid2)",
            "        info = self.conn.get_info({'uuid': uuid2,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_snapshot(self):",
            "        self._create_vm()",
            "        self._test_snapshot()",
            "",
            "    def test_snapshot_using_file_manager(self):",
            "        self._create_vm()",
            "        uuid_str = uuidutils.generate_uuid()",
            "        self.mox.StubOutWithMock(uuidutils,",
            "                                 'generate_uuid')",
            "        uuidutils.generate_uuid().AndReturn(uuid_str)",
            "",
            "        self.mox.StubOutWithMock(ds_util, 'file_delete')",
            "        disk_ds_path = ds_util.DatastorePath(",
            "                self.ds, \"vmware_temp\", \"%s.vmdk\" % uuid_str)",
            "        disk_ds_flat_path = ds_util.DatastorePath(",
            "                self.ds, \"vmware_temp\", \"%s-flat.vmdk\" % uuid_str)",
            "        # Check calls for delete vmdk and -flat.vmdk pair",
            "        ds_util.file_delete(",
            "                mox.IgnoreArg(), disk_ds_flat_path,",
            "                mox.IgnoreArg()).AndReturn(None)",
            "        ds_util.file_delete(",
            "                mox.IgnoreArg(), disk_ds_path, mox.IgnoreArg()).AndReturn(None)",
            "",
            "        self.mox.ReplayAll()",
            "        self._test_snapshot()",
            "",
            "    def test_spawn_invalid_node(self):",
            "        self._create_instance(node='InvalidNodeName')",
            "        self.assertRaises(exception.NotFound, self.conn.spawn,",
            "                          self.context, self.instance, self.image,",
            "                          injected_files=[], admin_password=None,",
            "                          network_info=self.network_info,",
            "                          block_device_info=None)",
            "",
            "    @mock.patch.object(nova.virt.vmwareapi.vmware_images.VMwareImage,",
            "                       'from_image')",
            "    def test_spawn_with_sparse_image(self, mock_from_image):",
            "        img_info = vmware_images.VMwareImage(",
            "            image_id=self.fake_image_uuid,",
            "            file_size=1024,",
            "            disk_type=constants.DISK_TYPE_SPARSE,",
            "            linked_clone=False)",
            "",
            "        mock_from_image.return_value = img_info",
            "",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "",
            "    def test_plug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.plug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def test_unplug_vifs(self):",
            "        # Check to make sure the method raises NotImplementedError.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.unplug_vifs,",
            "                          instance=self.instance, network_info=None)",
            "",
            "    def _create_vif(self):",
            "        gw_4 = network_model.IP(address='101.168.1.1', type='gateway')",
            "        dns_4 = network_model.IP(address='8.8.8.8', type=None)",
            "        subnet_4 = network_model.Subnet(cidr='101.168.1.0/24',",
            "                                        dns=[dns_4],",
            "                                        gateway=gw_4,",
            "                                        routes=None,",
            "                                        dhcp_server='191.168.1.1')",
            "",
            "        gw_6 = network_model.IP(address='101:1db9::1', type='gateway')",
            "        subnet_6 = network_model.Subnet(cidr='101:1db9::/64',",
            "                                        dns=None,",
            "                                        gateway=gw_6,",
            "                                        ips=None,",
            "                                        routes=None)",
            "",
            "        network_neutron = network_model.Network(id='network-id-xxx-yyy-zzz',",
            "                                                bridge=None,",
            "                                                label=None,",
            "                                                subnets=[subnet_4,",
            "                                                         subnet_6],",
            "                                                bridge_interface='eth0',",
            "                                                vlan=99)",
            "",
            "        vif_bridge_neutron = network_model.VIF(id='new-vif-xxx-yyy-zzz',",
            "                                               address='ca:fe:de:ad:be:ef',",
            "                                               network=network_neutron,",
            "                                               type=None,",
            "                                               devname='tap-xxx-yyy-zzz',",
            "                                               ovs_interfaceid='aaa-bbb-ccc')",
            "        return vif_bridge_neutron",
            "",
            "    def _validate_interfaces(self, id, index, num_iface_ids):",
            "        vm = self._get_vm_record()",
            "        found_iface_id = False",
            "        extras = vm.get(\"config.extraConfig\")",
            "        key = \"nvp.iface-id.%s\" % index",
            "        num_found = 0",
            "        for c in extras.OptionValue:",
            "            if c.key.startswith(\"nvp.iface-id.\"):",
            "                num_found += 1",
            "                if c.key == key and c.value == id:",
            "                    found_iface_id = True",
            "        self.assertTrue(found_iface_id)",
            "        self.assertEqual(num_found, num_iface_ids)",
            "",
            "    def _attach_interface(self, vif):",
            "        self.conn.attach_interface(self.instance, self.image, vif)",
            "        self._validate_interfaces(vif['id'], 1, 2)",
            "",
            "    def test_attach_interface(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "",
            "    def test_attach_interface_with_exception(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "",
            "        with mock.patch.object(self.conn._session, '_wait_for_task',",
            "                               side_effect=Exception):",
            "            self.assertRaises(exception.InterfaceAttachFailed,",
            "                              self.conn.attach_interface,",
            "                              self.instance, self.image, vif)",
            "",
            "    @mock.patch.object(vif, 'get_network_device',",
            "                       return_value='fake_device')",
            "    def _detach_interface(self, vif, mock_get_device):",
            "        self._create_vm()",
            "        self._attach_interface(vif)",
            "        self.conn.detach_interface(self.instance, vif)",
            "        self._validate_interfaces('free', 1, 2)",
            "",
            "    def test_detach_interface(self):",
            "        vif = self._create_vif()",
            "        self._detach_interface(vif)",
            "",
            "    def test_detach_interface_and_attach(self):",
            "        vif = self._create_vif()",
            "        self._detach_interface(vif)",
            "        self.conn.attach_interface(self.instance, self.image, vif)",
            "        self._validate_interfaces(vif['id'], 1, 2)",
            "",
            "    def test_detach_interface_no_device(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "        self.assertRaises(exception.NotFound, self.conn.detach_interface,",
            "                          self.instance, vif)",
            "",
            "    def test_detach_interface_no_vif_match(self):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "        vif['id'] = 'bad-id'",
            "        self.assertRaises(exception.NotFound, self.conn.detach_interface,",
            "                          self.instance, vif)",
            "",
            "    @mock.patch.object(vif, 'get_network_device',",
            "                       return_value='fake_device')",
            "    def test_detach_interface_with_exception(self, mock_get_device):",
            "        self._create_vm()",
            "        vif = self._create_vif()",
            "        self._attach_interface(vif)",
            "",
            "        with mock.patch.object(self.conn._session, '_wait_for_task',",
            "                               side_effect=Exception):",
            "            self.assertRaises(exception.InterfaceDetachFailed,",
            "                              self.conn.detach_interface,",
            "                              self.instance, vif)",
            "",
            "    def test_migrate_disk_and_power_off(self):",
            "        def fake_update_instance_progress(context, instance, step,",
            "                                          total_steps):",
            "            pass",
            "",
            "        def fake_get_host_ref_from_name(dest):",
            "            return None",
            "",
            "        self._create_vm(instance_type='m1.large')",
            "        vm_ref_orig = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        flavor = self._get_instance_type_by_name('m1.large')",
            "        self.stubs.Set(self.conn._vmops, \"_update_instance_progress\",",
            "                       fake_update_instance_progress)",
            "        self.stubs.Set(self.conn._vmops, \"_get_host_ref_from_name\",",
            "                       fake_get_host_ref_from_name)",
            "        self.conn.migrate_disk_and_power_off(self.context, self.instance,",
            "                                             'fake_dest', flavor,",
            "                                             None)",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref_orig.value, vm_ref.value,",
            "                             \"These should be different\")",
            "",
            "    def test_disassociate_vmref_from_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                        self.instance, vm_ref, \"-backup\")",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "",
            "    def test_clone_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        host_ref = vmwareapi_fake._get_object_refs(\"HostSystem\")[0]",
            "        ds_ref = vmwareapi_fake._get_object_refs(\"Datastore\")[0]",
            "        dc_obj = vmwareapi_fake._get_objects(\"Datacenter\").objects[0]",
            "        vm_util.clone_vmref_for_instance(self.conn._session, self.instance,",
            "                                         vm_ref, host_ref, ds_ref,",
            "                                         dc_obj.get(\"vmFolder\"))",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "        cloned_vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        self.assertNotEqual(vm_ref.value, cloned_vm_ref.value,",
            "                            \"Reference for the cloned VM should be different\")",
            "        vm_obj = vmwareapi_fake._get_vm_mdo(vm_ref)",
            "        cloned_vm_obj = vmwareapi_fake._get_vm_mdo(cloned_vm_ref)",
            "        self.assertEqual(vm_obj.name, self.instance['uuid'] + \"-backup\",",
            "                       \"Original VM name should be with suffix -backup\")",
            "        self.assertEqual(cloned_vm_obj.name, self.instance['uuid'],",
            "                       \"VM name does not match instance['uuid']\")",
            "        self.assertRaises(vexc.MissingParameter,",
            "                          vm_util.clone_vmref_for_instance, self.conn._session,",
            "                          self.instance, None, host_ref, ds_ref,",
            "                          dc_obj.get(\"vmFolder\"))",
            "",
            "    def test_associate_vmref_for_instance(self):",
            "        self._create_vm()",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        # First disassociate the VM from the instance so that we have a VM",
            "        # to later associate using the associate_vmref_for_instance method",
            "        vm_util.disassociate_vmref_from_instance(self.conn._session,",
            "                                            self.instance, vm_ref, \"-backup\")",
            "        # Ensure that the VM is indeed disassociated and that we cannot find",
            "        # the VM using the get_vm_ref method",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                    vm_util.get_vm_ref, self.conn._session, self.instance)",
            "        # Associate the VM back to the instance",
            "        vm_util.associate_vmref_for_instance(self.conn._session, self.instance,",
            "                                             suffix=\"-backup\")",
            "        # Verify if we can get the VM reference",
            "        self.assertIsNotNone(",
            "                        vm_util.get_vm_ref(self.conn._session, self.instance),",
            "                        \"No VM found\")",
            "",
            "    def test_confirm_migration(self):",
            "        self._create_vm()",
            "        self.conn.confirm_migration(self.context, self.instance, None)",
            "",
            "    def test_resize_to_smaller_disk(self):",
            "        self._create_vm(instance_type='m1.large')",
            "        flavor = self._get_instance_type_by_name('m1.small')",
            "        self.assertRaises(exception.InstanceFaultRollback,",
            "                          self.conn.migrate_disk_and_power_off, self.context,",
            "                          self.instance, 'fake_dest', flavor, None)",
            "",
            "    def test_spawn_attach_volume_vmdk(self):",
            "        self._spawn_attach_volume_vmdk(vc_support=True)",
            "",
            "    def test_spawn_attach_volume_vmdk_no_image_ref(self):",
            "        self._spawn_attach_volume_vmdk(set_image_ref=False, vc_support=True)",
            "",
            "    def test_pause(self):",
            "        # Tests that the VMwareVCDriver does not implement the pause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.pause, self.instance)",
            "",
            "    def test_unpause(self):",
            "        # Tests that the VMwareVCDriver does not implement the unpause method.",
            "        self._create_instance()",
            "        self.assertRaises(NotImplementedError, self.conn.unpause,",
            "                          self.instance)",
            "",
            "    def test_datastore_dc_map(self):",
            "        vmops = self.conn._resources[self.node_name]['vmops']",
            "        self.assertEqual({}, vmops._datastore_dc_mapping)",
            "        self._create_vm()",
            "        # currently there are 2 data stores",
            "        self.assertEqual(2, len(vmops._datastore_dc_mapping))",
            "",
            "    def test_rollback_live_migration_at_destination(self):",
            "        with mock.patch.object(self.conn, \"destroy\") as mock_destroy:",
            "            self.conn.rollback_live_migration_at_destination(self.context,",
            "                    \"instance\", [], None)",
            "            mock_destroy.assert_called_once_with(self.context,",
            "                    \"instance\", [], None)",
            "",
            "    def test_get_instance_disk_info_is_implemented(self):",
            "        # Ensure that the method has been implemented in the driver",
            "        try:",
            "            disk_info = self.conn.get_instance_disk_info('fake_instance_name')",
            "            self.assertIsNone(disk_info)",
            "        except NotImplementedError:",
            "            self.fail(\"test_get_instance_disk_info() should not raise \"",
            "                      \"NotImplementedError\")",
            "",
            "    def test_destroy(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "        self.assertIsNone(vm_util.vm_ref_cache_get(self.uuid))",
            "",
            "    def test_destroy_no_datastore(self):",
            "        self._create_vm()",
            "        info = self.conn.get_info({'uuid': self.uuid,",
            "                                   'node': self.instance_node})",
            "        self._check_vm_info(info, power_state.RUNNING)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(1, len(instances))",
            "        # Overwrite the vmPathName",
            "        vm = self._get_vm_record()",
            "        vm.set(\"config.files.vmPathName\", None)",
            "        self.conn.destroy(self.context, self.instance, self.network_info)",
            "        instances = self.conn.list_instances()",
            "        self.assertEqual(0, len(instances))",
            "",
            "    def test_destroy_non_existent(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self._create_instance()",
            "            self.conn.destroy(self.context, self.instance,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            mock_destroy.assert_called_once_with(self.instance,",
            "                                                 self.destroy_disks)",
            "",
            "    def test_destroy_instance_without_compute(self):",
            "        self.destroy_disks = True",
            "        with mock.patch.object(self.conn._vmops,",
            "                               \"destroy\") as mock_destroy:",
            "            self.conn.destroy(self.context, self.instance_without_compute,",
            "                              self.network_info,",
            "                              None, self.destroy_disks)",
            "            self.assertFalse(mock_destroy.called)",
            "",
            "    def test_get_host_uptime(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          self.conn.get_host_uptime, 'host')",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        \"\"\"Tests the finish_migration method on VC Driver.\"\"\"",
            "        # setup the test instance in the database",
            "        self._create_vm()",
            "        if resize_instance:",
            "            self.instance.system_metadata = {'old_instance_type_root_gb': '0'}",
            "        vm_ref = vm_util.get_vm_ref(self.conn._session, self.instance)",
            "        datastore = ds_util.Datastore(ref='fake-ref', name='fake')",
            "        dc_info = vmops.DcInfo(ref='fake_ref', name='fake',",
            "                               vmFolder='fake_folder')",
            "        with contextlib.nested(",
            "                mock.patch.object(self.conn._session, \"_call_method\",",
            "                                  return_value='fake-task'),",
            "                mock.patch.object(self.conn._vmops,",
            "                                  \"_update_instance_progress\"),",
            "                mock.patch.object(self.conn._session, \"_wait_for_task\"),",
            "                mock.patch.object(vm_util, \"get_vm_resize_spec\",",
            "                                  return_value='fake-spec'),",
            "                mock.patch.object(ds_util, \"get_datastore\",",
            "                                  return_value=datastore),",
            "                mock.patch.object(self.conn._vmops,",
            "                                  'get_datacenter_ref_and_name',",
            "                                  return_value=dc_info),",
            "                mock.patch.object(self.conn._vmops, '_extend_virtual_disk'),",
            "                mock.patch.object(vm_util, \"power_on_instance\")",
            "        ) as (fake_call_method, fake_update_instance_progress,",
            "              fake_wait_for_task, fake_vm_resize_spec,",
            "              fake_get_datastore, fake_get_datacenter_ref_and_name,",
            "              fake_extend_virtual_disk, fake_power_on):",
            "            self.conn.finish_migration(context=self.context,",
            "                                       migration=None,",
            "                                       instance=self.instance,",
            "                                       disk_info=None,",
            "                                       network_info=None,",
            "                                       block_device_info=None,",
            "                                       resize_instance=resize_instance,",
            "                                       image_meta=None,",
            "                                       power_on=power_on)",
            "            if resize_instance:",
            "                fake_vm_resize_spec.assert_called_once_with(",
            "                    self.conn._session._get_vim().client.factory,",
            "                    self.instance)",
            "                fake_call_method.assert_any_call(",
            "                    self.conn._session._get_vim(),",
            "                    \"ReconfigVM_Task\",",
            "                    vm_ref,",
            "                    spec='fake-spec')",
            "                fake_wait_for_task.assert_called_once_with('fake-task')",
            "                fake_extend_virtual_disk.assert_called_once_with(",
            "                    self.instance, self.instance['root_gb'] * units.Mi,",
            "                    None, dc_info.ref)",
            "            else:",
            "                self.assertFalse(fake_vm_resize_spec.called)",
            "                self.assertFalse(fake_call_method.called)",
            "                self.assertFalse(fake_wait_for_task.called)",
            "                self.assertFalse(fake_extend_virtual_disk.called)",
            "",
            "            if power_on:",
            "                fake_power_on.assert_called_once_with(self.conn._session,",
            "                                                      self.instance,",
            "                                                      vm_ref=vm_ref)",
            "            else:",
            "                self.assertFalse(fake_power_on.called)",
            "            fake_update_instance_progress.called_once_with(",
            "                self.context, self.instance, 4, vmops.RESIZE_TOTAL_STEPS)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self._test_finish_migration(power_on=True)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self._test_finish_migration(power_on=False)",
            "",
            "    def test_finish_migration_power_on_resize(self):",
            "        self._test_finish_migration(power_on=True,",
            "                                    resize_instance=True)",
            "",
            "    @mock.patch.object(vm_util, 'associate_vmref_for_instance')",
            "    @mock.patch.object(vm_util, 'power_on_instance')",
            "    def _test_finish_revert_migration(self, fake_power_on,",
            "                                      fake_associate_vmref, power_on):",
            "        \"\"\"Tests the finish_revert_migration method on VC Driver.\"\"\"",
            "",
            "        # setup the test instance in the database",
            "        self._create_instance()",
            "        self.conn.finish_revert_migration(self.context,",
            "                                          instance=self.instance,",
            "                                          network_info=None,",
            "                                          block_device_info=None,",
            "                                          power_on=power_on)",
            "        fake_associate_vmref.assert_called_once_with(self.conn._session,",
            "                                                     self.instance,",
            "                                                     suffix='-orig')",
            "        if power_on:",
            "            fake_power_on.assert_called_once_with(self.conn._session,",
            "                                                  self.instance)",
            "        else:",
            "            self.assertFalse(fake_power_on.called)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self._test_finish_revert_migration(power_on=True)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self._test_finish_revert_migration(power_on=False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1485": [
                "VMwareAPIVMTestCase",
                "test_destroy_instance_without_vm_ref"
            ],
            "1486": [
                "VMwareAPIVMTestCase",
                "test_destroy_instance_without_vm_ref"
            ]
        },
        "addLocation": []
    },
    "nova/virt/vmwareapi/vmops.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 839,
                "afterPatchRowNumber": 839,
                "PatchRowcode": "                 self._destroy_instance(instance,"
            },
            "1": {
                "beforePatchRowNumber": 840,
                "afterPatchRowNumber": 840,
                "PatchRowcode": "                                        destroy_disks=destroy_disks,"
            },
            "2": {
                "beforePatchRowNumber": 841,
                "afterPatchRowNumber": 841,
                "PatchRowcode": "                                        instance_name=rescue_name)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+        # When VM deletion is triggered in middle of VM resize before VM"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 843,
                "PatchRowcode": "+        # arrive RESIZED state, uuid-orig VM need to deleted to avoid"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 844,
                "PatchRowcode": "+        # VM leak. Within method _destroy_instance it will check vmref"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 845,
                "PatchRowcode": "+        # exist or not before attempt deletion."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 846,
                "PatchRowcode": "+        resize_orig_vmname = instance['uuid'] + self._migrate_suffix"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 847,
                "PatchRowcode": "+        vm_orig_ref = vm_util.get_vm_ref_from_name(self._session,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 848,
                "PatchRowcode": "+                                                   resize_orig_vmname)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 849,
                "PatchRowcode": "+        if vm_orig_ref:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 850,
                "PatchRowcode": "+            self._destroy_instance(instance,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 851,
                "PatchRowcode": "+                                   destroy_disks=destroy_disks,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 852,
                "PatchRowcode": "+                                   instance_name=resize_orig_vmname)"
            },
            "14": {
                "beforePatchRowNumber": 842,
                "afterPatchRowNumber": 853,
                "PatchRowcode": "         self._destroy_instance(instance, destroy_disks=destroy_disks)"
            },
            "15": {
                "beforePatchRowNumber": 843,
                "afterPatchRowNumber": 854,
                "PatchRowcode": "         LOG.debug(\"Instance destroyed\", instance=instance)"
            },
            "16": {
                "beforePatchRowNumber": 844,
                "afterPatchRowNumber": 855,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Class for VM tasks like spawn, snapshot, suspend, resume etc.",
            "\"\"\"",
            "",
            "import collections",
            "import copy",
            "import os",
            "import time",
            "",
            "import decorator",
            "from oslo.config import cfg",
            "from oslo.vmware import exceptions as vexc",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova import compute",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova.console import type as ctype",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova.i18n import _, _LE, _LW",
            "from nova import objects",
            "from nova.openstack.common import excutils",
            "from nova.openstack.common import lockutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import utils",
            "from nova.virt import configdrive",
            "from nova.virt import diagnostics",
            "from nova.virt import driver",
            "from nova.virt.vmwareapi import constants",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vif as vmwarevif",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmware_images",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_cache_subdirectory_name', 'nova.virt.imagecache')",
            "CONF.import_opt('remove_unused_base_images', 'nova.virt.imagecache')",
            "CONF.import_opt('vnc_enabled', 'nova.vnc')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "VMWARE_POWER_STATES = {",
            "                   'poweredOff': power_state.SHUTDOWN,",
            "                    'poweredOn': power_state.RUNNING,",
            "                    'suspended': power_state.SUSPENDED}",
            "",
            "RESIZE_TOTAL_STEPS = 4",
            "",
            "DcInfo = collections.namedtuple('DcInfo',",
            "                                ['ref', 'name', 'vmFolder'])",
            "",
            "",
            "class VirtualMachineInstanceConfigInfo(object):",
            "    \"\"\"Parameters needed to create and configure a new instance.\"\"\"",
            "",
            "    def __init__(self, instance, instance_name, image_info,",
            "                 datastore, dc_info, image_cache):",
            "",
            "        # Some methods called during spawn take the instance parameter purely",
            "        # for logging purposes.",
            "        # TODO(vui) Clean them up, so we no longer need to keep this variable",
            "        self.instance = instance",
            "",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        self.instance_name = instance_name or instance.uuid",
            "",
            "        self.ii = image_info",
            "        self.root_gb = instance.root_gb",
            "        self.datastore = datastore",
            "        self.dc_info = dc_info",
            "        self._image_cache = image_cache",
            "",
            "    @property",
            "    def cache_image_folder(self):",
            "        if self.ii.image_id is None:",
            "            return",
            "        return self._image_cache.get_image_cache_folder(",
            "                   self.datastore, self.ii.image_id)",
            "",
            "    @property",
            "    def cache_image_path(self):",
            "        if self.ii.image_id is None:",
            "            return",
            "        cached_image_file_name = \"%s.%s\" % (self.ii.image_id,",
            "                                            self.ii.file_type)",
            "        return self.cache_image_folder.join(cached_image_file_name)",
            "",
            "",
            "# Note(vui): See https://bugs.launchpad.net/nova/+bug/1363349",
            "# for cases where mocking time.sleep() can have unintended effects on code",
            "# not under test. For now, unblock the affected test cases by providing",
            "# a wrapper function to work around needing to mock time.sleep()",
            "def _time_sleep_wrapper(delay):",
            "    time.sleep(delay)",
            "",
            "",
            "@decorator.decorator",
            "def retry_if_task_in_progress(f, *args, **kwargs):",
            "    retries = max(CONF.vmware.api_retry_count, 1)",
            "    delay = 1",
            "    for attempt in range(1, retries + 1):",
            "        if attempt != 1:",
            "            _time_sleep_wrapper(delay)",
            "            delay = min(2 * delay, 60)",
            "        try:",
            "            f(*args, **kwargs)",
            "            return",
            "        except error_util.TaskInProgress:",
            "            pass",
            "",
            "",
            "class VMwareVMOps(object):",
            "    \"\"\"Management class for VM-related tasks.\"\"\"",
            "",
            "    def __init__(self, session, virtapi, volumeops, cluster=None,",
            "                 datastore_regex=None):",
            "        \"\"\"Initializer.\"\"\"",
            "        self.compute_api = compute.API()",
            "        self._session = session",
            "        self._virtapi = virtapi",
            "        self._volumeops = volumeops",
            "        self._cluster = cluster",
            "        self._datastore_regex = datastore_regex",
            "        # Ensure that the base folder is unique per compute node",
            "        if CONF.remove_unused_base_images:",
            "            self._base_folder = '%s%s' % (CONF.my_ip,",
            "                                          CONF.image_cache_subdirectory_name)",
            "        else:",
            "            # Aging disable ensures backward compatibility",
            "            self._base_folder = CONF.image_cache_subdirectory_name",
            "        self._tmp_folder = 'vmware_temp'",
            "        self._default_root_device = 'vda'",
            "        self._rescue_suffix = '-rescue'",
            "        self._migrate_suffix = '-orig'",
            "        self._datastore_dc_mapping = {}",
            "        self._datastore_browser_mapping = {}",
            "        self._imagecache = imagecache.ImageCacheManager(self._session,",
            "                                                        self._base_folder)",
            "",
            "    def _extend_virtual_disk(self, instance, requested_size, name, dc_ref):",
            "        service_content = self._session._get_vim().service_content",
            "        LOG.debug(\"Extending root virtual disk to %s\", requested_size)",
            "        vmdk_extend_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"ExtendVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                name=name,",
            "                datacenter=dc_ref,",
            "                newCapacityKb=requested_size,",
            "                eagerZero=False)",
            "        try:",
            "            self._session._wait_for_task(vmdk_extend_task)",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Extending virtual disk failed with error: %s'),",
            "                          e, instance=instance)",
            "                # Clean up files created during the extend operation",
            "                files = [name.replace(\".vmdk\", \"-flat.vmdk\"), name]",
            "                for file in files:",
            "                    ds_path = ds_util.DatastorePath.parse(file)",
            "                    self._delete_datastore_file(instance, ds_path, dc_ref)",
            "",
            "        LOG.debug(\"Extended root virtual disk\")",
            "",
            "    def _delete_datastore_file(self, instance, datastore_path, dc_ref):",
            "        try:",
            "            ds_util.file_delete(self._session, datastore_path, dc_ref)",
            "        except (vexc.CannotDeleteFileException,",
            "                vexc.FileFaultException,",
            "                vexc.FileLockedException,",
            "                vexc.FileNotFoundException):",
            "            LOG.debug(\"Unable to delete %(ds)s. There may be more than \"",
            "                      \"one process or thread trying to delete the file\",",
            "                      {'ds': datastore_path},",
            "                      exc_info=True)",
            "",
            "    def _extend_if_required(self, dc_info, image_info, instance,",
            "                            root_vmdk_path):",
            "        \"\"\"Increase the size of the root vmdk if necessary.\"\"\"",
            "        if instance.root_gb > image_info.file_size_in_gb:",
            "            size_in_kb = instance.root_gb * units.Mi",
            "            self._extend_virtual_disk(instance, size_in_kb,",
            "                                      root_vmdk_path, dc_info.ref)",
            "",
            "    def _configure_config_drive(self, instance, vm_ref, dc_info, datastore,",
            "                                injected_files, admin_password):",
            "        session_vim = self._session._get_vim()",
            "        cookies = session_vim.client.options.transport.cookiejar",
            "",
            "        uploaded_iso_path = self._create_config_drive(instance,",
            "                                                      injected_files,",
            "                                                      admin_password,",
            "                                                      datastore.name,",
            "                                                      dc_info.name,",
            "                                                      instance['uuid'],",
            "                                                      cookies)",
            "        uploaded_iso_path = datastore.build_path(uploaded_iso_path)",
            "        self._attach_cdrom_to_vm(",
            "            vm_ref, instance,",
            "            datastore.ref,",
            "            str(uploaded_iso_path))",
            "",
            "    def build_virtual_machine(self, instance, instance_name, image_info,",
            "                              dc_info, datastore, network_info):",
            "        node_mo_id = vm_util.get_mo_id_from_instance(instance)",
            "        res_pool_ref = vm_util.get_res_pool_ref(self._session,",
            "                                                self._cluster, node_mo_id)",
            "        vif_infos = vmwarevif.get_vif_info(self._session,",
            "                                           self._cluster,",
            "                                           utils.is_neutron(),",
            "                                           image_info.vif_model,",
            "                                           network_info)",
            "",
            "        allocations = self._get_cpu_allocations(instance.instance_type_id)",
            "",
            "        # Get the create vm config spec",
            "        client_factory = self._session._get_vim().client.factory",
            "        config_spec = vm_util.get_vm_create_spec(client_factory,",
            "                                                 instance,",
            "                                                 instance_name,",
            "                                                 datastore.name,",
            "                                                 vif_infos,",
            "                                                 image_info.os_type,",
            "                                                 allocations=allocations)",
            "        # Create the VM",
            "        vm_ref = vm_util.create_vm(self._session, instance, dc_info.vmFolder,",
            "                                   config_spec, res_pool_ref)",
            "        return vm_ref",
            "",
            "    def _get_cpu_allocations(self, instance_type_id):",
            "        # Read flavors for allocations",
            "        flavor = objects.Flavor.get_by_id(",
            "            nova_context.get_admin_context(read_deleted='yes'),",
            "            instance_type_id)",
            "        allocations = {}",
            "        for (key, type) in (('cpu_limit', int),",
            "                            ('cpu_reservation', int),",
            "                            ('cpu_shares_level', str),",
            "                            ('cpu_shares_share', int)):",
            "            value = flavor.extra_specs.get('quota:' + key)",
            "            if value:",
            "                allocations[key] = type(value)",
            "        return allocations",
            "",
            "    def _fetch_image_as_file(self, context, vi, image_ds_loc):",
            "        \"\"\"Download image as an individual file to host via HTTP PUT.\"\"\"",
            "        session = self._session",
            "        session_vim = session._get_vim()",
            "        cookies = session_vim.client.options.transport.cookiejar",
            "",
            "        LOG.debug(\"Downloading image file data %(image_id)s to \"",
            "                  \"%(file_path)s on the data store \"",
            "                  \"%(datastore_name)s\",",
            "                  {'image_id': vi.ii.image_id,",
            "                   'file_path': image_ds_loc,",
            "                   'datastore_name': vi.datastore.name},",
            "                  instance=vi.instance)",
            "",
            "        vmware_images.fetch_image(",
            "            context,",
            "            vi.instance,",
            "            session._host,",
            "            vi.dc_info.name,",
            "            vi.datastore.name,",
            "            image_ds_loc.rel_path,",
            "            cookies=cookies)",
            "",
            "    def _prepare_sparse_image(self, vi):",
            "        tmp_dir_loc = vi.datastore.build_path(",
            "                self._tmp_folder, uuidutils.generate_uuid())",
            "        tmp_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, \"tmp-sparse.vmdk\")",
            "        return tmp_dir_loc, tmp_image_ds_loc",
            "",
            "    def _prepare_flat_image(self, vi):",
            "        tmp_dir_loc = vi.datastore.build_path(",
            "                self._tmp_folder, uuidutils.generate_uuid())",
            "        tmp_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, vi.cache_image_path.basename)",
            "        ds_util.mkdir(self._session, tmp_image_ds_loc.parent, vi.dc_info.ref)",
            "        vm_util.create_virtual_disk(",
            "                self._session, vi.dc_info.ref,",
            "                vi.ii.adapter_type,",
            "                vi.ii.disk_type,",
            "                str(tmp_image_ds_loc),",
            "                vi.ii.file_size_in_kb)",
            "        flat_vmdk_name = vi.cache_image_path.basename.replace('.vmdk',",
            "                                                              '-flat.vmdk')",
            "        flat_vmdk_ds_loc = tmp_dir_loc.join(vi.ii.image_id, flat_vmdk_name)",
            "        self._delete_datastore_file(vi.instance, str(flat_vmdk_ds_loc),",
            "                                    vi.dc_info.ref)",
            "        return tmp_dir_loc, flat_vmdk_ds_loc",
            "",
            "    def _prepare_iso_image(self, vi):",
            "        tmp_dir_loc = vi.datastore.build_path(",
            "                self._tmp_folder, uuidutils.generate_uuid())",
            "        tmp_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, vi.cache_image_path.basename)",
            "        return tmp_dir_loc, tmp_image_ds_loc",
            "",
            "    def _move_to_cache(self, dc_ref, src_folder_ds_path, dst_folder_ds_path):",
            "        try:",
            "            ds_util.file_move(self._session, dc_ref,",
            "                              src_folder_ds_path, dst_folder_ds_path)",
            "        except vexc.FileAlreadyExistsException:",
            "            # Folder move has failed. This may be due to the fact that a",
            "            # process or thread has already completed the operation.",
            "            # Since image caching is synchronized, this can only happen",
            "            # due to action external to the process.",
            "            # In the event of a FileAlreadyExists we continue,",
            "            # all other exceptions will be raised.",
            "            LOG.warning(_LW(\"Destination %s already exists! Concurrent moves \"",
            "                            \"can lead to unexpected results.\"),",
            "                      dst_folder_ds_path)",
            "",
            "    def _cache_sparse_image(self, vi, tmp_image_ds_loc):",
            "        tmp_dir_loc = tmp_image_ds_loc.parent.parent",
            "        converted_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, vi.cache_image_path.basename)",
            "        # converts fetched image to preallocated disk",
            "        vm_util.copy_virtual_disk(",
            "                self._session,",
            "                vi.dc_info.ref,",
            "                str(tmp_image_ds_loc),",
            "                str(converted_image_ds_loc))",
            "",
            "        self._delete_datastore_file(vi.instance, str(tmp_image_ds_loc),",
            "                                    vi.dc_info.ref)",
            "",
            "        self._move_to_cache(vi.dc_info.ref,",
            "                            tmp_image_ds_loc.parent,",
            "                            vi.cache_image_folder)",
            "",
            "    def _cache_flat_image(self, vi, tmp_image_ds_loc):",
            "        self._move_to_cache(vi.dc_info.ref,",
            "                            tmp_image_ds_loc.parent,",
            "                            vi.cache_image_folder)",
            "",
            "    def _cache_iso_image(self, vi, tmp_image_ds_loc):",
            "        self._move_to_cache(vi.dc_info.ref,",
            "                            tmp_image_ds_loc.parent,",
            "                            vi.cache_image_folder)",
            "",
            "    def _get_vm_config_info(self, instance, image_info, instance_name=None):",
            "        \"\"\"Captures all relevant information from the spawn parameters.\"\"\"",
            "",
            "        if (instance.root_gb != 0 and",
            "                image_info.file_size_in_gb > instance.root_gb):",
            "            reason = _(\"Image disk size greater than requested disk size\")",
            "            raise exception.InstanceUnacceptable(instance_id=instance.uuid,",
            "                                                 reason=reason)",
            "        datastore = ds_util.get_datastore(",
            "                self._session, self._cluster, self._datastore_regex)",
            "        dc_info = self.get_datacenter_ref_and_name(datastore.ref)",
            "",
            "        return VirtualMachineInstanceConfigInfo(instance,",
            "                                                instance_name,",
            "                                                image_info,",
            "                                                datastore,",
            "                                                dc_info,",
            "                                                self._imagecache)",
            "",
            "    def _get_image_callbacks(self, vi):",
            "        disk_type = vi.ii.disk_type",
            "",
            "        image_fetch = self._fetch_image_as_file",
            "",
            "        if vi.ii.is_iso:",
            "            image_prepare = self._prepare_iso_image",
            "            image_cache = self._cache_iso_image",
            "        elif disk_type == constants.DISK_TYPE_SPARSE:",
            "            image_prepare = self._prepare_sparse_image",
            "            image_cache = self._cache_sparse_image",
            "        elif disk_type in constants.SUPPORTED_FLAT_VARIANTS:",
            "            image_prepare = self._prepare_flat_image",
            "            image_cache = self._cache_flat_image",
            "        else:",
            "            reason = _(\"disk type '%s' not supported\") % disk_type",
            "            raise exception.InvalidDiskInfo(reason=reason)",
            "        return image_prepare, image_fetch, image_cache",
            "",
            "    def _fetch_image_if_missing(self, context, vi):",
            "        image_prepare, image_fetch, image_cache = self._get_image_callbacks(vi)",
            "        LOG.debug(\"Processing image %s\", vi.ii.image_id)",
            "",
            "        with lockutils.lock(str(vi.cache_image_path),",
            "                            lock_file_prefix='nova-vmware-fetch_image'):",
            "            self.check_cache_folder(vi.datastore.name, vi.datastore.ref)",
            "            ds_browser = self._get_ds_browser(vi.datastore.ref)",
            "            if not ds_util.file_exists(self._session, ds_browser,",
            "                                       vi.cache_image_folder,",
            "                                       vi.cache_image_path.basename):",
            "                LOG.debug(\"Preparing fetch location\")",
            "                tmp_dir_loc, tmp_image_ds_loc = image_prepare(vi)",
            "                LOG.debug(\"Fetch image to %s\", tmp_image_ds_loc)",
            "                image_fetch(context, vi, tmp_image_ds_loc)",
            "                LOG.debug(\"Caching image\")",
            "                image_cache(vi, tmp_image_ds_loc)",
            "                LOG.debug(\"Cleaning up location %s\", str(tmp_dir_loc))",
            "                self._delete_datastore_file(vi.instance, str(tmp_dir_loc),",
            "                                            vi.dc_info.ref)",
            "",
            "    def spawn(self, context, instance, image_meta, injected_files,",
            "              admin_password, network_info, block_device_info=None,",
            "              instance_name=None, power_on=True):",
            "",
            "        client_factory = self._session._get_vim().client.factory",
            "        image_info = vmware_images.VMwareImage.from_image(instance.image_ref,",
            "                                                          image_meta)",
            "        vi = self._get_vm_config_info(instance, image_info, instance_name)",
            "",
            "        # Creates the virtual machine. The virtual machine reference returned",
            "        # is unique within Virtual Center.",
            "        vm_ref = self.build_virtual_machine(instance,",
            "                                            vi.instance_name,",
            "                                            image_info,",
            "                                            vi.dc_info,",
            "                                            vi.datastore,",
            "                                            network_info)",
            "",
            "        # Cache the vm_ref. This saves a remote call to the VC. This uses the",
            "        # instance_name. This covers all use cases including rescue and resize.",
            "        vm_util.vm_ref_cache_update(vi.instance_name, vm_ref)",
            "",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        if CONF.flat_injected:",
            "            self._set_machine_id(client_factory, instance, network_info)",
            "",
            "        # Set the vnc configuration of the instance, vnc port starts from 5900",
            "        if CONF.vnc_enabled:",
            "            vnc_port = vm_util.get_vnc_port(self._session)",
            "            self._set_vnc_config(client_factory, instance, vnc_port)",
            "",
            "        block_device_mapping = []",
            "        if block_device_info is not None:",
            "            block_device_mapping = driver.block_device_info_get_mapping(",
            "                block_device_info)",
            "",
            "        # NOTE(mdbooth): the logic here is that we ignore the image if there",
            "        # are block device mappings. This behaviour is incorrect, and a bug in",
            "        # the driver.  We should be able to accept an image and block device",
            "        # mappings.",
            "        if len(block_device_mapping) > 0:",
            "            msg = \"Block device information present: %s\" % block_device_info",
            "            # NOTE(mriedem): block_device_info can contain an auth_password",
            "            # so we have to scrub the message before logging it.",
            "            LOG.debug(logging.mask_password(msg), instance=instance)",
            "",
            "            for root_disk in block_device_mapping:",
            "                connection_info = root_disk['connection_info']",
            "                # TODO(hartsocks): instance is unnecessary, remove it",
            "                # we still use instance in many locations for no other purpose",
            "                # than logging, can we simplify this?",
            "                self._volumeops.attach_root_volume(connection_info, instance,",
            "                                                   self._default_root_device,",
            "                                                   vi.datastore.ref)",
            "        else:",
            "            self._imagecache.enlist_image(",
            "                    image_info.image_id, vi.datastore, vi.dc_info.ref)",
            "            self._fetch_image_if_missing(context, vi)",
            "",
            "            if image_info.is_iso:",
            "                self._use_iso_image(vm_ref, vi)",
            "            elif image_info.linked_clone:",
            "                self._use_disk_image_as_linked_clone(vm_ref, vi)",
            "            else:",
            "                self._use_disk_image_as_full_clone(vm_ref, vi)",
            "",
            "            if configdrive.required_by(instance):",
            "                self._configure_config_drive(",
            "                        instance, vm_ref, vi.dc_info, vi.datastore,",
            "                        injected_files, admin_password)",
            "",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance, vm_ref=vm_ref)",
            "",
            "    def _create_config_drive(self, instance, injected_files, admin_password,",
            "                             data_store_name, dc_name, upload_folder, cookies):",
            "        if CONF.config_drive_format != 'iso9660':",
            "            reason = (_('Invalid config_drive_format \"%s\"') %",
            "                      CONF.config_drive_format)",
            "            raise exception.InstancePowerOnFailure(reason=reason)",
            "",
            "        LOG.info(_('Using config drive for instance'), instance=instance)",
            "        extra_md = {}",
            "        if admin_password:",
            "            extra_md['admin_pass'] = admin_password",
            "",
            "        inst_md = instance_metadata.InstanceMetadata(instance,",
            "                                                     content=injected_files,",
            "                                                     extra_md=extra_md)",
            "        try:",
            "            with configdrive.ConfigDriveBuilder(instance_md=inst_md) as cdb:",
            "                with utils.tempdir() as tmp_path:",
            "                    tmp_file = os.path.join(tmp_path, 'configdrive.iso')",
            "                    cdb.make_drive(tmp_file)",
            "                    upload_iso_path = \"%s/configdrive.iso\" % (",
            "                        upload_folder)",
            "                    vmware_images.upload_iso_to_datastore(",
            "                        tmp_file, instance,",
            "                        host=self._session._host,",
            "                        data_center_name=dc_name,",
            "                        datastore_name=data_store_name,",
            "                        cookies=cookies,",
            "                        file_path=upload_iso_path)",
            "                    return upload_iso_path",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Creating config drive failed with error: %s'),",
            "                          e, instance=instance)",
            "",
            "    def _attach_cdrom_to_vm(self, vm_ref, instance,",
            "                            datastore, file_path):",
            "        \"\"\"Attach cdrom to VM by reconfiguration.\"\"\"",
            "        client_factory = self._session._get_vim().client.factory",
            "        devices = self._session._call_method(vim_util,",
            "                                    \"get_dynamic_property\", vm_ref,",
            "                                    \"VirtualMachine\", \"config.hardware.device\")",
            "        (controller_key, unit_number,",
            "         controller_spec) = vm_util.allocate_controller_key_and_unit_number(",
            "                                                              client_factory,",
            "                                                              devices,",
            "                                                              'ide')",
            "        cdrom_attach_config_spec = vm_util.get_cdrom_attach_config_spec(",
            "                                    client_factory, datastore, file_path,",
            "                                    controller_key, unit_number)",
            "        if controller_spec:",
            "            cdrom_attach_config_spec.deviceChange.append(controller_spec)",
            "",
            "        LOG.debug(\"Reconfiguring VM instance to attach cdrom %s\",",
            "                  file_path, instance=instance)",
            "        vm_util.reconfigure_vm(self._session, vm_ref, cdrom_attach_config_spec)",
            "        LOG.debug(\"Reconfigured VM instance to attach cdrom %s\",",
            "                  file_path, instance=instance)",
            "",
            "    def _create_vm_snapshot(self, instance, vm_ref):",
            "        LOG.debug(\"Creating Snapshot of the VM instance\", instance=instance)",
            "        snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"CreateSnapshot_Task\", vm_ref,",
            "                    name=\"%s-snapshot\" % instance.uuid,",
            "                    description=\"Taking Snapshot of the VM\",",
            "                    memory=False,",
            "                    quiesce=True)",
            "        self._session._wait_for_task(snapshot_task)",
            "        LOG.debug(\"Created Snapshot of the VM instance\", instance=instance)",
            "        task_info = self._session._call_method(vim_util,",
            "                                               \"get_dynamic_property\",",
            "                                               snapshot_task, \"Task\", \"info\")",
            "        snapshot = task_info.result",
            "        return snapshot",
            "",
            "    @retry_if_task_in_progress",
            "    def _delete_vm_snapshot(self, instance, vm_ref, snapshot):",
            "        LOG.debug(\"Deleting Snapshot of the VM instance\", instance=instance)",
            "        delete_snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"RemoveSnapshot_Task\", snapshot,",
            "                    removeChildren=False, consolidate=True)",
            "        self._session._wait_for_task(delete_snapshot_task)",
            "        LOG.debug(\"Deleted Snapshot of the VM instance\", instance=instance)",
            "",
            "    def snapshot(self, context, instance, image_id, update_task_state):",
            "        \"\"\"Create snapshot from a running VM instance.",
            "",
            "        Steps followed are:",
            "",
            "        1. Get the name of the vmdk file which the VM points to right now.",
            "           Can be a chain of snapshots, so we need to know the last in the",
            "           chain.",
            "        2. Create the snapshot. A new vmdk is created which the VM points to",
            "           now. The earlier vmdk becomes read-only.",
            "        3. Call CopyVirtualDisk which coalesces the disk chain to form a single",
            "           vmdk, rather a .vmdk metadata file and a -flat.vmdk disk data file.",
            "        4. Now upload the -flat.vmdk file to the image store.",
            "        5. Delete the coalesced .vmdk and -flat.vmdk created.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        service_content = self._session._get_vim().service_content",
            "",
            "        def _get_vm_and_vmdk_attribs():",
            "            # Get the vmdk file name that the VM is pointing to",
            "            hw_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "            (vmdk_file_path_before_snapshot, adapter_type,",
            "             disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                                        hw_devices, uuid=instance.uuid)",
            "            if not vmdk_file_path_before_snapshot:",
            "                LOG.debug(\"No root disk defined. Unable to snapshot.\")",
            "                raise error_util.NoRootDiskDefined()",
            "",
            "            datastore_name = ds_util.DatastorePath.parse(",
            "                    vmdk_file_path_before_snapshot).datastore",
            "            os_type = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"summary.config.guestId\")",
            "            return (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "                    datastore_name, os_type)",
            "",
            "        (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "         datastore_name, os_type) = _get_vm_and_vmdk_attribs()",
            "",
            "        snapshot = self._create_vm_snapshot(instance, vm_ref)",
            "        update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD)",
            "",
            "        def _check_if_tmp_folder_exists():",
            "            # Copy the contents of the VM that were there just before the",
            "            # snapshot was taken",
            "            ds_ref_ret = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", vm_ref, \"VirtualMachine\",",
            "                \"datastore\")",
            "            if ds_ref_ret is None:",
            "                raise exception.DatastoreNotFound()",
            "            ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "            self.check_temp_folder(datastore_name, ds_ref)",
            "            return ds_ref",
            "",
            "        ds_ref = _check_if_tmp_folder_exists()",
            "",
            "        # Generate a random vmdk file name to which the coalesced vmdk content",
            "        # will be copied to. A random name is chosen so that we don't have",
            "        # name clashes.",
            "        random_name = uuidutils.generate_uuid()",
            "        dest_vmdk_file_path = ds_util.DatastorePath(",
            "                datastore_name, self._tmp_folder, \"%s.vmdk\" % random_name)",
            "        dest_vmdk_data_file_path = ds_util.DatastorePath(",
            "                datastore_name, self._tmp_folder, \"%s-flat.vmdk\" % random_name)",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "",
            "        def _copy_vmdk_content():",
            "            # Consolidate the snapshotted disk to a temporary vmdk.",
            "            LOG.debug('Copying snapshotted disk %s.',",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "            copy_disk_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CopyVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                sourceName=vmdk_file_path_before_snapshot,",
            "                sourceDatacenter=dc_info.ref,",
            "                destName=str(dest_vmdk_file_path),",
            "                destDatacenter=dc_info.ref,",
            "                force=False)",
            "            self._session._wait_for_task(copy_disk_task)",
            "            LOG.debug('Copied snapshotted disk %s.',",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "",
            "        _copy_vmdk_content()",
            "        self._delete_vm_snapshot(instance, vm_ref, snapshot)",
            "",
            "        cookies = self._session._get_vim().client.options.transport.cookiejar",
            "",
            "        def _upload_vmdk_to_image_repository():",
            "            # Upload the contents of -flat.vmdk file which has the disk data.",
            "            LOG.debug(\"Uploading image %s\", image_id,",
            "                      instance=instance)",
            "            vmware_images.upload_image(",
            "                context,",
            "                image_id,",
            "                instance,",
            "                os_type=os_type,",
            "                disk_type=constants.DEFAULT_DISK_TYPE,",
            "                adapter_type=adapter_type,",
            "                image_version=1,",
            "                host=self._session._host,",
            "                data_center_name=dc_info.name,",
            "                datastore_name=datastore_name,",
            "                cookies=cookies,",
            "                file_path=\"%s/%s-flat.vmdk\" % (self._tmp_folder, random_name))",
            "            LOG.debug(\"Uploaded image %s\", image_id,",
            "                      instance=instance)",
            "",
            "        update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                          expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "        _upload_vmdk_to_image_repository()",
            "",
            "        def _clean_temp_data():",
            "            \"\"\"Delete temporary vmdk files generated in image handling",
            "            operations.",
            "            \"\"\"",
            "            # The data file is the one occupying space, and likelier to see",
            "            # deletion problems, so prioritize its deletion first. In the",
            "            # unlikely event that its deletion fails, the small descriptor file",
            "            # is retained too by design since it makes little sense to remove",
            "            # it when the data disk it refers to still lingers.",
            "            for f in dest_vmdk_data_file_path, dest_vmdk_file_path:",
            "                self._delete_datastore_file(instance, f, dc_info.ref)",
            "",
            "        _clean_temp_data()",
            "",
            "    def reboot(self, instance, network_info):",
            "        \"\"\"Reboot a VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.guest.toolsStatus\", \"runtime.powerState\",",
            "                          \"summary.guest.toolsRunningStatus\"]",
            "        props = self._session._call_method(vim_util, \"get_object_properties\",",
            "                           None, vm_ref, \"VirtualMachine\",",
            "                           lst_properties)",
            "        query = vm_util.get_values_from_object_properties(self._session, props)",
            "        pwr_state = query['runtime.powerState']",
            "        tools_status = query['summary.guest.toolsStatus']",
            "        tools_running_status = query['summary.guest.toolsRunningStatus']",
            "",
            "        # Raise an exception if the VM is not powered On.",
            "        if pwr_state not in [\"poweredOn\"]:",
            "            reason = _(\"instance is not powered on\")",
            "            raise exception.InstanceRebootFailure(reason=reason)",
            "",
            "        # If latest vmware tools are installed in the VM, and that the tools",
            "        # are running, then only do a guest reboot. Otherwise do a hard reset.",
            "        if (tools_status == \"toolsOk\" and",
            "                tools_running_status == \"guestToolsRunning\"):",
            "            LOG.debug(\"Rebooting guest OS of VM\", instance=instance)",
            "            self._session._call_method(self._session._get_vim(), \"RebootGuest\",",
            "                                       vm_ref)",
            "            LOG.debug(\"Rebooted guest OS of VM\", instance=instance)",
            "        else:",
            "            LOG.debug(\"Doing hard reboot of VM\", instance=instance)",
            "            reset_task = self._session._call_method(self._session._get_vim(),",
            "                                                    \"ResetVM_Task\", vm_ref)",
            "            self._session._wait_for_task(reset_task)",
            "            LOG.debug(\"Did hard reboot of VM\", instance=instance)",
            "",
            "    def _destroy_instance(self, instance, destroy_disks=True,",
            "                          instance_name=None):",
            "        # Destroy a VM instance",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        if instance_name is None:",
            "            instance_name = instance['uuid']",
            "        try:",
            "            vm_ref = vm_util.get_vm_ref_from_name(self._session, instance_name)",
            "            if vm_ref is None:",
            "                LOG.warning(_('Instance does not exist on backend'),",
            "                            instance=instance)",
            "                return",
            "            lst_properties = [\"config.files.vmPathName\", \"runtime.powerState\",",
            "                              \"datastore\"]",
            "            props = self._session._call_method(vim_util,",
            "                        \"get_object_properties\",",
            "                        None, vm_ref, \"VirtualMachine\", lst_properties)",
            "            query = vm_util.get_values_from_object_properties(",
            "                    self._session, props)",
            "            pwr_state = query['runtime.powerState']",
            "            vm_config_pathname = query['config.files.vmPathName']",
            "            vm_ds_path = None",
            "            if vm_config_pathname:",
            "                vm_ds_path = ds_util.DatastorePath.parse(vm_config_pathname)",
            "",
            "            # Power off the VM if it is in PoweredOn state.",
            "            if pwr_state == \"poweredOn\":",
            "                vm_util.power_off_instance(self._session, instance, vm_ref)",
            "",
            "            # Un-register the VM",
            "            try:",
            "                LOG.debug(\"Unregistering the VM\", instance=instance)",
            "                self._session._call_method(self._session._get_vim(),",
            "                                           \"UnregisterVM\", vm_ref)",
            "                LOG.debug(\"Unregistered the VM\", instance=instance)",
            "            except Exception as excep:",
            "                LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, got this \"",
            "                           \"exception while un-registering the VM: %s\"),",
            "                         excep)",
            "            # Delete the folder holding the VM related content on",
            "            # the datastore.",
            "            if destroy_disks and vm_ds_path:",
            "                try:",
            "                    dir_ds_compliant_path = vm_ds_path.parent",
            "                    LOG.debug(\"Deleting contents of the VM from \"",
            "                              \"datastore %(datastore_name)s\",",
            "                              {'datastore_name': vm_ds_path.datastore},",
            "                              instance=instance)",
            "                    ds_ref_ret = query['datastore']",
            "                    ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "                    dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "                    ds_util.file_delete(self._session,",
            "                                        dir_ds_compliant_path,",
            "                                        dc_info.ref)",
            "                    LOG.debug(\"Deleted contents of the VM from \"",
            "                              \"datastore %(datastore_name)s\",",
            "                              {'datastore_name': vm_ds_path.datastore},",
            "                              instance=instance)",
            "                except Exception:",
            "                    LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, \"",
            "                               \"exception while deleting the VM contents from \"",
            "                               \"the disk\"), exc_info=True)",
            "        except Exception as exc:",
            "            LOG.exception(exc, instance=instance)",
            "        finally:",
            "            vm_util.vm_ref_cache_delete(instance_name)",
            "",
            "    def destroy(self, instance, destroy_disks=True):",
            "        \"\"\"Destroy a VM instance.",
            "",
            "        Steps followed for each VM are:",
            "        1. Power off, if it is in poweredOn state.",
            "        2. Un-register.",
            "        3. Delete the contents of the folder holding the VM related data.",
            "        \"\"\"",
            "        # If there is a rescue VM then we need to destroy that one too.",
            "        LOG.debug(\"Destroying instance\", instance=instance)",
            "        if instance['vm_state'] == vm_states.RESCUED:",
            "            LOG.debug(\"Rescue VM configured\", instance=instance)",
            "            try:",
            "                self.unrescue(instance, power_on=False)",
            "                LOG.debug(\"Rescue VM destroyed\", instance=instance)",
            "            except Exception:",
            "                rescue_name = instance['uuid'] + self._rescue_suffix",
            "                self._destroy_instance(instance,",
            "                                       destroy_disks=destroy_disks,",
            "                                       instance_name=rescue_name)",
            "        self._destroy_instance(instance, destroy_disks=destroy_disks)",
            "        LOG.debug(\"Instance destroyed\", instance=instance)",
            "",
            "    def pause(self, instance):",
            "        msg = _(\"pause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def unpause(self, instance):",
            "        msg = _(\"unpause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def suspend(self, instance):",
            "        \"\"\"Suspend the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                    \"get_dynamic_property\", vm_ref,",
            "                    \"VirtualMachine\", \"runtime.powerState\")",
            "        # Only PoweredOn VMs can be suspended.",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(\"Suspending the VM\", instance=instance)",
            "            suspend_task = self._session._call_method(self._session._get_vim(),",
            "                    \"SuspendVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(\"Suspended the VM\", instance=instance)",
            "        # Raise Exception if VM is poweredOff",
            "        elif pwr_state == \"poweredOff\":",
            "            reason = _(\"instance is powered off and cannot be suspended.\")",
            "            raise exception.InstanceSuspendFailure(reason=reason)",
            "        else:",
            "            LOG.debug(\"VM was already in suspended state. So returning \"",
            "                      \"without doing anything\", instance=instance)",
            "",
            "    def resume(self, instance):",
            "        \"\"\"Resume the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                                     \"get_dynamic_property\", vm_ref,",
            "                                     \"VirtualMachine\", \"runtime.powerState\")",
            "        if pwr_state.lower() == \"suspended\":",
            "            LOG.debug(\"Resuming the VM\", instance=instance)",
            "            suspend_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                       \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(\"Resumed the VM\", instance=instance)",
            "        else:",
            "            reason = _(\"instance is not in a suspended state\")",
            "            raise exception.InstanceResumeFailure(reason=reason)",
            "",
            "    def rescue(self, context, instance, network_info, image_meta):",
            "        \"\"\"Rescue the specified instance.",
            "",
            "            - shutdown the instance VM.",
            "            - spawn a rescue VM (the vm name-label will be instance-N-rescue).",
            "",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        self.power_off(instance)",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance.uuid + self._rescue_suffix",
            "        self.spawn(context, r_instance, image_meta,",
            "                   None, None, network_info,",
            "                   instance_name=instance_name,",
            "                   power_on=False)",
            "",
            "        # Attach vmdk to the rescue VM",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance.uuid)",
            "        rescue_vm_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        self._volumeops.attach_disk_to_vm(",
            "                                rescue_vm_ref, r_instance,",
            "                                adapter_type, disk_type, vmdk_path)",
            "        vm_util.power_on_instance(self._session, r_instance,",
            "                                  vm_ref=rescue_vm_ref)",
            "",
            "    def unrescue(self, instance, power_on=True):",
            "        \"\"\"Unrescue the specified instance.\"\"\"",
            "        # Get the original vmdk_path",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance.uuid)",
            "",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance.uuid + self._rescue_suffix",
            "        # detach the original instance disk from the rescue disk",
            "        vm_rescue_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_rescue_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        device = vm_util.get_vmdk_volume_disk(hardware_devices, path=vmdk_path)",
            "        vm_util.power_off_instance(self._session, r_instance, vm_rescue_ref)",
            "        self._volumeops.detach_disk_from_vm(vm_rescue_ref, r_instance, device)",
            "        self._destroy_instance(r_instance, instance_name=instance_name)",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance, vm_ref=vm_ref)",
            "",
            "    def power_off(self, instance):",
            "        \"\"\"Power off the specified instance.",
            "",
            "        :param instance: nova.objects.instance.Instance",
            "        \"\"\"",
            "        vm_util.power_off_instance(self._session, instance)",
            "",
            "    def power_on(self, instance):",
            "        vm_util.power_on_instance(self._session, instance)",
            "",
            "    def _get_orig_vm_name_label(self, instance):",
            "        return instance.uuid + '-orig'",
            "",
            "    def _update_instance_progress(self, context, instance, step, total_steps):",
            "        \"\"\"Update instance progress percent to reflect current step number",
            "        \"\"\"",
            "        # Divide the action's workflow into discrete steps and \"bump\" the",
            "        # instance's progress field as each step is completed.",
            "        #",
            "        # For a first cut this should be fine, however, for large VM images,",
            "        # the clone disk step begins to dominate the equation. A",
            "        # better approximation would use the percentage of the VM image that",
            "        # has been streamed to the destination host.",
            "        progress = round(float(step) / total_steps * 100)",
            "        instance_uuid = instance.uuid",
            "        LOG.debug(\"Updating instance '%(instance_uuid)s' progress to\"",
            "                  \" %(progress)d\",",
            "                  {'instance_uuid': instance_uuid, 'progress': progress},",
            "                  instance=instance)",
            "        instance.progress = progress",
            "        instance.save()",
            "",
            "    def migrate_disk_and_power_off(self, context, instance, dest,",
            "                                   flavor):",
            "        \"\"\"Transfers the disk of a running instance in multiple phases, turning",
            "        off the instance before the end.",
            "        \"\"\"",
            "        # Checks if the migration needs a disk resize down.",
            "        if flavor['root_gb'] < instance['root_gb']:",
            "            reason = _(\"Unable to shrink disk.\")",
            "            raise exception.InstanceFaultRollback(",
            "                exception.ResizeError(reason=reason))",
            "",
            "        # 0. Zero out the progress to begin",
            "        self._update_instance_progress(context, instance,",
            "                                       step=0,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Read the host_ref for the destination. If this is None then the",
            "        # VC will decide on placement",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "",
            "        # 1. Power off the instance",
            "        self.power_off(instance)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=1,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        # 2. Disassociate the linked vsphere VM from the instance",
            "        vm_util.disassociate_vmref_from_instance(self._session, instance,",
            "                                                 vm_ref,",
            "                                                 suffix=self._migrate_suffix)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=2,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        ds_ref = ds_util.get_datastore(",
            "                            self._session, self._cluster,",
            "                            datastore_regex=self._datastore_regex).ref",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        # 3. Clone the VM for instance",
            "        vm_util.clone_vmref_for_instance(self._session, instance, vm_ref,",
            "                                         host_ref, ds_ref, dc_info.vmFolder)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=3,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def confirm_migration(self, migration, instance, network_info):",
            "        \"\"\"Confirms a resize, destroying the source VM.\"\"\"",
            "        # Destroy the original VM. The vm_ref needs to be searched using the",
            "        # instance.uuid + self._migrate_suffix as the identifier. We will",
            "        # not get the vm when searched using the instanceUuid but rather will",
            "        # be found using the uuid buried in the extraConfig",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self._session,",
            "                                    instance.uuid + self._migrate_suffix)",
            "        if vm_ref is None:",
            "            LOG.debug(\"instance not present\", instance=instance)",
            "            return",
            "",
            "        try:",
            "            LOG.debug(\"Destroying the VM\", instance=instance)",
            "            destroy_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"Destroy_Task\", vm_ref)",
            "            self._session._wait_for_task(destroy_task)",
            "            LOG.debug(\"Destroyed the VM\", instance=instance)",
            "        except Exception as excep:",
            "            LOG.warn(_(\"In vmwareapi:vmops:confirm_migration, got this \"",
            "                     \"exception while destroying the VM: %s\"), excep)",
            "",
            "    def finish_revert_migration(self, context, instance, network_info,",
            "                                block_device_info, power_on=True):",
            "        \"\"\"Finish reverting a resize.\"\"\"",
            "        vm_util.associate_vmref_for_instance(self._session, instance,",
            "                                             suffix=self._migrate_suffix)",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance)",
            "",
            "    def finish_migration(self, context, migration, instance, disk_info,",
            "                         network_info, image_meta, resize_instance=False,",
            "                         block_device_info=None, power_on=True):",
            "        \"\"\"Completes a resize, turning on the migrated instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        if resize_instance:",
            "            client_factory = self._session._get_vim().client.factory",
            "            vm_resize_spec = vm_util.get_vm_resize_spec(client_factory,",
            "                                                        instance)",
            "            vm_util.reconfigure_vm(self._session, vm_ref, vm_resize_spec)",
            "",
            "            # Resize the disk (if larger)",
            "            old_root_gb = instance.system_metadata['old_instance_type_root_gb']",
            "            if instance['root_gb'] > int(old_root_gb):",
            "                root_disk_in_kb = instance['root_gb'] * units.Mi",
            "                vmdk_path = vm_util.get_vmdk_path(self._session, vm_ref,",
            "                                                  instance)",
            "                data_store_ref = ds_util.get_datastore(self._session,",
            "                    self._cluster, datastore_regex=self._datastore_regex).ref",
            "                dc_info = self.get_datacenter_ref_and_name(data_store_ref)",
            "                self._extend_virtual_disk(instance, root_disk_in_kb, vmdk_path,",
            "                                          dc_info.ref)",
            "",
            "            # TODO(ericwb): add extend for ephemeral disk",
            "",
            "        # 4. Start VM",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance, vm_ref=vm_ref)",
            "",
            "        self._update_instance_progress(context, instance,",
            "                                       step=4,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def live_migration(self, context, instance_ref, dest,",
            "                       post_method, recover_method, block_migration=False):",
            "        \"\"\"Spawning live_migration operation for distributing high-load.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance_ref)",
            "",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "        if host_ref is None:",
            "            raise exception.HostNotFound(host=dest)",
            "",
            "        LOG.debug(\"Migrating VM to host %s\", dest, instance=instance_ref)",
            "        try:",
            "            vm_migrate_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"MigrateVM_Task\", vm_ref,",
            "                                    host=host_ref,",
            "                                    priority=\"defaultPriority\")",
            "            self._session._wait_for_task(vm_migrate_task)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                recover_method(context, instance_ref, dest, block_migration)",
            "        post_method(context, instance_ref, dest, block_migration)",
            "        LOG.debug(\"Migrated VM to host %s\", dest, instance=instance_ref)",
            "",
            "    def poll_rebooting_instances(self, timeout, instances):",
            "        \"\"\"Poll for rebooting instances.\"\"\"",
            "        ctxt = nova_context.get_admin_context()",
            "",
            "        instances_info = dict(instance_count=len(instances),",
            "                timeout=timeout)",
            "",
            "        if instances_info[\"instance_count\"] > 0:",
            "            LOG.info(_(\"Found %(instance_count)d hung reboots \"",
            "                    \"older than %(timeout)d seconds\") % instances_info)",
            "",
            "        for instance in instances:",
            "            LOG.info(_(\"Automatically hard rebooting\"), instance=instance)",
            "            self.compute_api.reboot(ctxt, instance, \"HARD\")",
            "",
            "    def get_info(self, instance):",
            "        \"\"\"Return data about the VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        lst_properties = [\"summary.config.numCpu\",",
            "                    \"summary.config.memorySizeMB\",",
            "                    \"runtime.powerState\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        query = vm_util.get_values_from_object_properties(",
            "                self._session, vm_props)",
            "        max_mem = int(query['summary.config.memorySizeMB']) * 1024",
            "        return {'state': VMWARE_POWER_STATES[query['runtime.powerState']],",
            "                'max_mem': max_mem,",
            "                'mem': max_mem,",
            "                'num_cpu': int(query['summary.config.numCpu']),",
            "                'cpu_time': 0}",
            "",
            "    def _get_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.config\",",
            "                          \"summary.quickStats\",",
            "                          \"summary.runtime\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        query = vm_util.get_values_from_object_properties(self._session,",
            "                                                          vm_props)",
            "        data = {}",
            "        # All of values received are objects. Convert them to dictionaries",
            "        for value in query.values():",
            "            prop_dict = vim_util.object_to_dict(value, list_depth=1)",
            "            data.update(prop_dict)",
            "        return data",
            "",
            "    def get_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        data = self._get_diagnostics(instance)",
            "        # Add a namespace to all of the diagnostsics",
            "        return dict([('vmware:' + k, v) for k, v in data.items()])",
            "",
            "    def get_instance_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        data = self._get_diagnostics(instance)",
            "        state = data.get('powerState')",
            "        if state:",
            "            state = power_state.STATE_MAP[VMWARE_POWER_STATES[state]]",
            "        uptime = data.get('uptimeSeconds', 0)",
            "        config_drive = configdrive.required_by(instance)",
            "        diags = diagnostics.Diagnostics(state=state,",
            "                                        driver='vmwareapi',",
            "                                        config_drive=config_drive,",
            "                                        hypervisor_os='esxi',",
            "                                        uptime=uptime)",
            "        diags.memory_details.maximum = data.get('memorySizeMB', 0)",
            "        diags.memory_details.used = data.get('guestMemoryUsage', 0)",
            "        # TODO(garyk): add in cpu, nic and disk stats",
            "        return diags",
            "",
            "    def _get_vnc_console_connection(self, instance):",
            "        \"\"\"Return connection info for a vnc console.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        opt_value = self._session._call_method(vim_util,",
            "                               'get_dynamic_property',",
            "                               vm_ref, 'VirtualMachine',",
            "                               vm_util.VNC_CONFIG_KEY)",
            "        if opt_value:",
            "            port = int(opt_value.value)",
            "        else:",
            "            raise exception.ConsoleTypeUnavailable(console_type='vnc')",
            "",
            "        return {'port': port,",
            "                'internal_access_path': None}",
            "",
            "    @staticmethod",
            "    def _get_machine_id_str(network_info):",
            "        machine_id_str = ''",
            "        for vif in network_info:",
            "            # TODO(vish): add support for dns2",
            "            # TODO(sateesh): add support for injection of ipv6 configuration",
            "            network = vif['network']",
            "            ip_v4 = netmask_v4 = gateway_v4 = broadcast_v4 = dns = None",
            "            subnets_v4 = [s for s in network['subnets'] if s['version'] == 4]",
            "            if len(subnets_v4) > 0:",
            "                if len(subnets_v4[0]['ips']) > 0:",
            "                    ip_v4 = subnets_v4[0]['ips'][0]",
            "                if len(subnets_v4[0]['dns']) > 0:",
            "                    dns = subnets_v4[0]['dns'][0]['address']",
            "",
            "                netmask_v4 = str(subnets_v4[0].as_netaddr().netmask)",
            "                gateway_v4 = subnets_v4[0]['gateway']['address']",
            "                broadcast_v4 = str(subnets_v4[0].as_netaddr().broadcast)",
            "",
            "            interface_str = \";\".join([vif['address'],",
            "                                      ip_v4 and ip_v4['address'] or '',",
            "                                      netmask_v4 or '',",
            "                                      gateway_v4 or '',",
            "                                      broadcast_v4 or '',",
            "                                      dns or ''])",
            "            machine_id_str = machine_id_str + interface_str + '#'",
            "        return machine_id_str",
            "",
            "    def _set_machine_id(self, client_factory, instance, network_info):",
            "        \"\"\"Set the machine id of the VM for guest tools to pick up",
            "        and reconfigure the network interfaces.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        machine_id_change_spec = vm_util.get_machine_id_change_spec(",
            "                                 client_factory,",
            "                                 self._get_machine_id_str(network_info))",
            "",
            "        LOG.debug(\"Reconfiguring VM instance to set the machine id\",",
            "                  instance=instance)",
            "        vm_util.reconfigure_vm(self._session, vm_ref, machine_id_change_spec)",
            "        LOG.debug(\"Reconfigured VM instance to set the machine id\",",
            "                  instance=instance)",
            "",
            "    def _set_vnc_config(self, client_factory, instance, port):",
            "        \"\"\"Set the vnc configuration of the VM.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        vnc_config_spec = vm_util.get_vnc_config_spec(",
            "                                      client_factory, port)",
            "",
            "        LOG.debug(\"Reconfiguring VM instance to enable vnc on \"",
            "                  \"port - %(port)s\", {'port': port},",
            "                  instance=instance)",
            "        vm_util.reconfigure_vm(self._session, vm_ref, vnc_config_spec)",
            "        LOG.debug(\"Reconfigured VM instance to enable vnc on \"",
            "                  \"port - %(port)s\", {'port': port},",
            "                  instance=instance)",
            "",
            "    def _get_ds_browser(self, ds_ref):",
            "        ds_browser = self._datastore_browser_mapping.get(ds_ref.value)",
            "        if not ds_browser:",
            "            ds_browser = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", ds_ref, \"Datastore\",",
            "                \"browser\")",
            "            self._datastore_browser_mapping[ds_ref.value] = ds_browser",
            "        return ds_browser",
            "",
            "    def _get_host_ref_from_name(self, host_name):",
            "        \"\"\"Get reference to the host with the name specified.\"\"\"",
            "        host_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"HostSystem\", [\"name\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, host_objs)",
            "        for host in host_objs:",
            "            if hasattr(host, 'propSet'):",
            "                if host.propSet[0].val == host_name:",
            "                    return host.obj",
            "        return None",
            "",
            "    def _get_vmfolder_ref(self):",
            "        \"\"\"Get the Vm folder ref from the datacenter.\"\"\"",
            "        dc_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                                             \"Datacenter\", [\"vmFolder\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, dc_objs)",
            "        # There is only one default datacenter in a standalone ESX host",
            "        vm_folder_ref = dc_objs.objects[0].propSet[0].val",
            "        return vm_folder_ref",
            "",
            "    def _create_folder_if_missing(self, ds_name, ds_ref, folder):",
            "        \"\"\"Create a folder if it does not exist.",
            "",
            "        Currently there are two folder that are required on the datastore",
            "         - base folder - the folder to store cached images",
            "         - temp folder - the folder used for snapshot management and",
            "                         image uploading",
            "        This method is aimed to be used for the management of those",
            "        folders to ensure that they are created if they are missing.",
            "        The ds_util method mkdir will be used to check if the folder",
            "        exists. If this throws and exception 'FileAlreadyExistsException'",
            "        then the folder already exists on the datastore.",
            "        \"\"\"",
            "        path = ds_util.DatastorePath(ds_name, folder)",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        try:",
            "            ds_util.mkdir(self._session, path, dc_info.ref)",
            "            LOG.debug(\"Folder %s created.\", path)",
            "        except vexc.FileAlreadyExistsException:",
            "            # NOTE(hartsocks): if the folder already exists, that",
            "            # just means the folder was prepped by another process.",
            "            pass",
            "",
            "    def check_cache_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the cache folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._base_folder)",
            "",
            "    def check_temp_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the temp folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._tmp_folder)",
            "",
            "    def _check_if_folder_file_exists(self, ds_browser, ds_ref, ds_name,",
            "                                     folder_name, file_name):",
            "        # Ensure that the cache folder exists",
            "        self.check_cache_folder(ds_name, ds_ref)",
            "        # Check if the file exists or not.",
            "        folder_ds_path = ds_util.DatastorePath(ds_name, folder_name)",
            "        return ds_util.file_exists(",
            "                self._session, ds_browser, folder_ds_path, file_name)",
            "",
            "    def inject_network_info(self, instance, network_info):",
            "        \"\"\"inject network info for specified instance.\"\"\"",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        client_factory = self._session._get_vim().client.factory",
            "        self._set_machine_id(client_factory, instance, network_info)",
            "",
            "    def manage_image_cache(self, context, instances):",
            "        if not CONF.remove_unused_base_images:",
            "            LOG.debug(\"Image aging disabled. Aging will not be done.\")",
            "            return",
            "",
            "        datastores = ds_util.get_available_datastores(self._session,",
            "                                                      self._cluster,",
            "                                                      self._datastore_regex)",
            "        datastores_info = []",
            "        for ds in datastores:",
            "            dc_info = self.get_datacenter_ref_and_name(ds.ref)",
            "            datastores_info.append((ds, dc_info))",
            "        self._imagecache.update(context, instances, datastores_info)",
            "",
            "    def _get_valid_vms_from_retrieve_result(self, retrieve_result):",
            "        \"\"\"Returns list of valid vms from RetrieveResult object.\"\"\"",
            "        lst_vm_names = []",
            "",
            "        while retrieve_result:",
            "            token = vm_util._get_token(retrieve_result)",
            "            for vm in retrieve_result.objects:",
            "                vm_name = None",
            "                conn_state = None",
            "                for prop in vm.propSet:",
            "                    if prop.name == \"name\":",
            "                        vm_name = prop.val",
            "                    elif prop.name == \"runtime.connectionState\":",
            "                        conn_state = prop.val",
            "                # Ignoring the orphaned or inaccessible VMs",
            "                if conn_state not in [\"orphaned\", \"inaccessible\"]:",
            "                    lst_vm_names.append(vm_name)",
            "            if token:",
            "                retrieve_result = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "        return lst_vm_names",
            "",
            "    def instance_exists(self, instance):",
            "        try:",
            "            vm_util.get_vm_ref(self._session, instance)",
            "            return True",
            "        except exception.InstanceNotFound:",
            "            return False",
            "",
            "    def attach_interface(self, instance, image_meta, vif):",
            "        \"\"\"Attach an interface to the instance.\"\"\"",
            "        vif_model = image_meta.get(\"hw_vif_model\",",
            "                                   constants.DEFAULT_VIF_MODEL)",
            "        vif_model = vm_util.convert_vif_model(vif_model)",
            "        vif_info = vmwarevif.get_vif_dict(self._session, self._cluster,",
            "                                          vif_model, utils.is_neutron(), vif)",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Ensure that there is not a race with the port index management",
            "        with lockutils.lock(instance.uuid,",
            "                            lock_file_prefix='nova-vmware-hot-plug'):",
            "            port_index = vm_util.get_attach_port_index(self._session, vm_ref)",
            "            client_factory = self._session._get_vim().client.factory",
            "            attach_config_spec = vm_util.get_network_attach_config_spec(",
            "                                        client_factory, vif_info, port_index)",
            "            LOG.debug(\"Reconfiguring VM to attach interface\",",
            "                      instance=instance)",
            "            try:",
            "                vm_util.reconfigure_vm(self._session, vm_ref,",
            "                                       attach_config_spec)",
            "            except Exception as e:",
            "                LOG.error(_LE('Attaching network adapter failed. Exception: '",
            "                              ' %s'),",
            "                          e, instance=instance)",
            "                raise exception.InterfaceAttachFailed(",
            "                        instance_uuid=instance['uuid'])",
            "        LOG.debug(\"Reconfigured VM to attach interface\", instance=instance)",
            "",
            "    def detach_interface(self, instance, vif):",
            "        \"\"\"Detach an interface from the instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Ensure that there is not a race with the port index management",
            "        with lockutils.lock(instance.uuid,",
            "                            lock_file_prefix='nova-vmware-hot-plug'):",
            "            port_index = vm_util.get_vm_detach_port_index(self._session,",
            "                                                          vm_ref,",
            "                                                          vif['id'])",
            "            if port_index is None:",
            "                msg = _(\"No device with interface-id %s exists on \"",
            "                        \"VM\") % vif['id']",
            "                raise exception.NotFound(msg)",
            "",
            "            hardware_devices = self._session._call_method(vim_util,",
            "                            \"get_dynamic_property\", vm_ref,",
            "                            \"VirtualMachine\", \"config.hardware.device\")",
            "            device = vmwarevif.get_network_device(hardware_devices,",
            "                                                  vif['address'])",
            "            if device is None:",
            "                msg = _(\"No device with MAC address %s exists on the \"",
            "                        \"VM\") % vif['address']",
            "                raise exception.NotFound(msg)",
            "",
            "            client_factory = self._session._get_vim().client.factory",
            "            detach_config_spec = vm_util.get_network_detach_config_spec(",
            "                                        client_factory, device, port_index)",
            "            LOG.debug(\"Reconfiguring VM to detach interface\",",
            "                      instance=instance)",
            "            try:",
            "                vm_util.reconfigure_vm(self._session, vm_ref,",
            "                                       detach_config_spec)",
            "            except Exception as e:",
            "                LOG.error(_LE('Detaching network adapter failed. Exception: '",
            "                              '%s'),",
            "                          e, instance=instance)",
            "                raise exception.InterfaceDetachFailed(",
            "                        instance_uuid=instance['uuid'])",
            "        LOG.debug(\"Reconfigured VM to detach interface\", instance=instance)",
            "",
            "    def _use_disk_image_as_full_clone(self, vm_ref, vi):",
            "        \"\"\"Uses cached image disk by copying it into the VM directory.\"\"\"",
            "",
            "        instance_folder = vi.instance_name",
            "        root_disk_name = \"%s.vmdk\" % vi.instance_name",
            "        root_disk_ds_loc = vi.datastore.build_path(instance_folder,",
            "                                                   root_disk_name)",
            "",
            "        vm_util.copy_virtual_disk(",
            "                self._session,",
            "                vi.dc_info.ref,",
            "                str(vi.cache_image_path),",
            "                str(root_disk_ds_loc))",
            "",
            "        self._extend_if_required(",
            "                vi.dc_info, vi.ii, vi.instance, str(root_disk_ds_loc))",
            "",
            "        self._volumeops.attach_disk_to_vm(",
            "                vm_ref, vi.instance,",
            "                vi.ii.adapter_type, vi.ii.disk_type,",
            "                str(root_disk_ds_loc),",
            "                vi.root_gb * units.Mi, False)",
            "",
            "    def _sized_image_exists(self, sized_disk_ds_loc, ds_ref):",
            "        ds_browser = self._get_ds_browser(ds_ref)",
            "        return ds_util.file_exists(",
            "                self._session, ds_browser, sized_disk_ds_loc.parent,",
            "                sized_disk_ds_loc.basename)",
            "",
            "    def _use_disk_image_as_linked_clone(self, vm_ref, vi):",
            "        \"\"\"Uses cached image as parent of a COW child in the VM directory.\"\"\"",
            "",
            "        sized_image_disk_name = \"%s.vmdk\" % vi.ii.image_id",
            "        if vi.root_gb > 0:",
            "            sized_image_disk_name = \"%s.%s.vmdk\" % (vi.ii.image_id, vi.root_gb)",
            "        sized_disk_ds_loc = vi.cache_image_folder.join(sized_image_disk_name)",
            "",
            "        # Ensure only a single thread extends the image at once.",
            "        # We do this by taking a lock on the name of the extended",
            "        # image. This allows multiple threads to create resized",
            "        # copies simultaneously, as long as they are different",
            "        # sizes. Threads attempting to create the same resized copy",
            "        # will be serialized, with only the first actually creating",
            "        # the copy.",
            "        #",
            "        # Note that the object is in a per-nova cache directory,",
            "        # so inter-nova locking is not a concern. Consequently we",
            "        # can safely use simple thread locks.",
            "",
            "        with lockutils.lock(str(sized_disk_ds_loc),",
            "                            lock_file_prefix='nova-vmware-image'):",
            "",
            "            if not self._sized_image_exists(sized_disk_ds_loc,",
            "                                            vi.datastore.ref):",
            "                LOG.debug(\"Copying root disk of size %sGb\", vi.root_gb)",
            "                try:",
            "                    vm_util.copy_virtual_disk(",
            "                            self._session,",
            "                            vi.dc_info.ref,",
            "                            str(vi.cache_image_path),",
            "                            str(sized_disk_ds_loc))",
            "                except Exception as e:",
            "                    LOG.warning(_(\"Root disk file creation \"",
            "                                  \"failed - %s\"), e)",
            "                    with excutils.save_and_reraise_exception():",
            "                        LOG.error(_LE('Failed to copy cached '",
            "                                      'image %(source)s to '",
            "                                      '%(dest)s for resize: '",
            "                                      '%(error)s'),",
            "                                  {'source': vi.cache_image_path,",
            "                                   'dest': sized_disk_ds_loc,",
            "                                   'error': e.message})",
            "                        try:",
            "                            ds_util.file_delete(self._session,",
            "                                                sized_disk_ds_loc,",
            "                                                vi.dc_info.ref)",
            "                        except vexc.FileNotFoundException:",
            "                            # File was never created: cleanup not",
            "                            # required",
            "                            pass",
            "",
            "                # Resize the copy to the appropriate size. No need",
            "                # for cleanup up here, as _extend_virtual_disk",
            "                # already does it",
            "                self._extend_if_required(",
            "                        vi.dc_info, vi.ii, vi.instance, str(sized_disk_ds_loc))",
            "",
            "        # Associate the sized image disk to the VM by attaching to the VM a",
            "        # COW child of said disk.",
            "        self._volumeops.attach_disk_to_vm(",
            "                vm_ref, vi.instance,",
            "                vi.ii.adapter_type, vi.ii.disk_type,",
            "                str(sized_disk_ds_loc),",
            "                vi.root_gb * units.Mi, vi.ii.linked_clone)",
            "",
            "    def _use_iso_image(self, vm_ref, vi):",
            "        \"\"\"Uses cached image as a bootable virtual cdrom.\"\"\"",
            "",
            "        self._attach_cdrom_to_vm(",
            "                vm_ref, vi.instance, vi.datastore.ref,",
            "                str(vi.cache_image_path))",
            "",
            "        # Optionally create and attach blank disk",
            "        if vi.root_gb > 0:",
            "            instance_folder = vi.instance_name",
            "            root_disk_name = \"%s.vmdk\" % vi.instance_name",
            "            root_disk_ds_loc = vi.datastore.build_path(instance_folder,",
            "                                                       root_disk_name)",
            "",
            "            # It is pointless to COW a blank disk",
            "            linked_clone = False",
            "",
            "            vm_util.create_virtual_disk(",
            "                    self._session, vi.dc_info.ref,",
            "                    vi.ii.adapter_type,",
            "                    vi.ii.disk_type,",
            "                    str(root_disk_ds_loc),",
            "                    vi.root_gb * units.Mi)",
            "",
            "            self._volumeops.attach_disk_to_vm(",
            "                    vm_ref, vi.instance,",
            "                    vi.ii.adapter_type, vi.ii.disk_type,",
            "                    str(root_disk_ds_loc),",
            "                    vi.root_gb * units.Mi, linked_clone)",
            "",
            "    def _update_datacenter_cache_from_objects(self, dcs):",
            "        \"\"\"Updates the datastore/datacenter cache.\"\"\"",
            "",
            "        while dcs:",
            "            token = vm_util._get_token(dcs)",
            "            for dco in dcs.objects:",
            "                dc_ref = dco.obj",
            "                ds_refs = []",
            "                prop_dict = vm_util.propset_dict(dco.propSet)",
            "                name = prop_dict.get('name')",
            "                vmFolder = prop_dict.get('vmFolder')",
            "                datastore_refs = prop_dict.get('datastore')",
            "                if datastore_refs:",
            "                    datastore_refs = datastore_refs.ManagedObjectReference",
            "                    for ds in datastore_refs:",
            "                        ds_refs.append(ds.value)",
            "                else:",
            "                    LOG.debug(\"Datacenter %s doesn't have any datastore \"",
            "                              \"associated with it, ignoring it\", name)",
            "                for ds_ref in ds_refs:",
            "                    self._datastore_dc_mapping[ds_ref] = DcInfo(ref=dc_ref,",
            "                            name=name, vmFolder=vmFolder)",
            "",
            "            if token:",
            "                dcs = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "",
            "    def get_datacenter_ref_and_name(self, ds_ref):",
            "        \"\"\"Get the datacenter name and the reference.\"\"\"",
            "        dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        if not dc_info:",
            "            dcs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"Datacenter\", [\"name\", \"datastore\", \"vmFolder\"])",
            "            self._update_datacenter_cache_from_objects(dcs)",
            "            dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        return dc_info",
            "",
            "    def list_instances(self):",
            "        \"\"\"Lists the VM instances that are registered with vCenter cluster.\"\"\"",
            "        properties = ['name', 'runtime.connectionState']",
            "        LOG.debug(\"Getting list of instances from cluster %s\",",
            "                  self._cluster)",
            "        vms = []",
            "        root_res_pool = self._session._call_method(",
            "            vim_util, \"get_dynamic_property\", self._cluster,",
            "            'ClusterComputeResource', 'resourcePool')",
            "        if root_res_pool:",
            "            vms = self._session._call_method(",
            "                vim_util, 'get_inner_objects', root_res_pool, 'vm',",
            "                'VirtualMachine', properties)",
            "        lst_vm_names = self._get_valid_vms_from_retrieve_result(vms)",
            "",
            "        LOG.debug(\"Got total of %s instances\", str(len(lst_vm_names)))",
            "        return lst_vm_names",
            "",
            "    def get_vnc_console(self, instance):",
            "        \"\"\"Return connection info for a vnc console using vCenter logic.\"\"\"",
            "",
            "        # vCenter does not run virtual machines and does not run",
            "        # a VNC proxy. Instead, you need to tell OpenStack to talk",
            "        # directly to the ESX host running the VM you are attempting",
            "        # to connect to via VNC.",
            "",
            "        vnc_console = self._get_vnc_console_connection(instance)",
            "        host_name = vm_util.get_host_name_for_vm(",
            "                        self._session,",
            "                        instance)",
            "        vnc_console['host'] = host_name",
            "",
            "        # NOTE: VM can move hosts in some situations. Debug for admins.",
            "        LOG.debug(\"VM %(uuid)s is currently on host %(host_name)s\",",
            "                  {'uuid': instance.name, 'host_name': host_name},",
            "                  instance=instance)",
            "        return ctype.ConsoleVNC(**vnc_console)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.",
            "# Copyright (c) 2012 VMware, Inc.",
            "# Copyright (c) 2011 Citrix Systems, Inc.",
            "# Copyright 2011 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Class for VM tasks like spawn, snapshot, suspend, resume etc.",
            "\"\"\"",
            "",
            "import collections",
            "import copy",
            "import os",
            "import time",
            "",
            "import decorator",
            "from oslo.config import cfg",
            "from oslo.vmware import exceptions as vexc",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova import compute",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova.console import type as ctype",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova.i18n import _, _LE, _LW",
            "from nova import objects",
            "from nova.openstack.common import excutils",
            "from nova.openstack.common import lockutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common import units",
            "from nova.openstack.common import uuidutils",
            "from nova import utils",
            "from nova.virt import configdrive",
            "from nova.virt import diagnostics",
            "from nova.virt import driver",
            "from nova.virt.vmwareapi import constants",
            "from nova.virt.vmwareapi import ds_util",
            "from nova.virt.vmwareapi import error_util",
            "from nova.virt.vmwareapi import imagecache",
            "from nova.virt.vmwareapi import vif as vmwarevif",
            "from nova.virt.vmwareapi import vim_util",
            "from nova.virt.vmwareapi import vm_util",
            "from nova.virt.vmwareapi import vmware_images",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_cache_subdirectory_name', 'nova.virt.imagecache')",
            "CONF.import_opt('remove_unused_base_images', 'nova.virt.imagecache')",
            "CONF.import_opt('vnc_enabled', 'nova.vnc')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "VMWARE_POWER_STATES = {",
            "                   'poweredOff': power_state.SHUTDOWN,",
            "                    'poweredOn': power_state.RUNNING,",
            "                    'suspended': power_state.SUSPENDED}",
            "",
            "RESIZE_TOTAL_STEPS = 4",
            "",
            "DcInfo = collections.namedtuple('DcInfo',",
            "                                ['ref', 'name', 'vmFolder'])",
            "",
            "",
            "class VirtualMachineInstanceConfigInfo(object):",
            "    \"\"\"Parameters needed to create and configure a new instance.\"\"\"",
            "",
            "    def __init__(self, instance, instance_name, image_info,",
            "                 datastore, dc_info, image_cache):",
            "",
            "        # Some methods called during spawn take the instance parameter purely",
            "        # for logging purposes.",
            "        # TODO(vui) Clean them up, so we no longer need to keep this variable",
            "        self.instance = instance",
            "",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        self.instance_name = instance_name or instance.uuid",
            "",
            "        self.ii = image_info",
            "        self.root_gb = instance.root_gb",
            "        self.datastore = datastore",
            "        self.dc_info = dc_info",
            "        self._image_cache = image_cache",
            "",
            "    @property",
            "    def cache_image_folder(self):",
            "        if self.ii.image_id is None:",
            "            return",
            "        return self._image_cache.get_image_cache_folder(",
            "                   self.datastore, self.ii.image_id)",
            "",
            "    @property",
            "    def cache_image_path(self):",
            "        if self.ii.image_id is None:",
            "            return",
            "        cached_image_file_name = \"%s.%s\" % (self.ii.image_id,",
            "                                            self.ii.file_type)",
            "        return self.cache_image_folder.join(cached_image_file_name)",
            "",
            "",
            "# Note(vui): See https://bugs.launchpad.net/nova/+bug/1363349",
            "# for cases where mocking time.sleep() can have unintended effects on code",
            "# not under test. For now, unblock the affected test cases by providing",
            "# a wrapper function to work around needing to mock time.sleep()",
            "def _time_sleep_wrapper(delay):",
            "    time.sleep(delay)",
            "",
            "",
            "@decorator.decorator",
            "def retry_if_task_in_progress(f, *args, **kwargs):",
            "    retries = max(CONF.vmware.api_retry_count, 1)",
            "    delay = 1",
            "    for attempt in range(1, retries + 1):",
            "        if attempt != 1:",
            "            _time_sleep_wrapper(delay)",
            "            delay = min(2 * delay, 60)",
            "        try:",
            "            f(*args, **kwargs)",
            "            return",
            "        except error_util.TaskInProgress:",
            "            pass",
            "",
            "",
            "class VMwareVMOps(object):",
            "    \"\"\"Management class for VM-related tasks.\"\"\"",
            "",
            "    def __init__(self, session, virtapi, volumeops, cluster=None,",
            "                 datastore_regex=None):",
            "        \"\"\"Initializer.\"\"\"",
            "        self.compute_api = compute.API()",
            "        self._session = session",
            "        self._virtapi = virtapi",
            "        self._volumeops = volumeops",
            "        self._cluster = cluster",
            "        self._datastore_regex = datastore_regex",
            "        # Ensure that the base folder is unique per compute node",
            "        if CONF.remove_unused_base_images:",
            "            self._base_folder = '%s%s' % (CONF.my_ip,",
            "                                          CONF.image_cache_subdirectory_name)",
            "        else:",
            "            # Aging disable ensures backward compatibility",
            "            self._base_folder = CONF.image_cache_subdirectory_name",
            "        self._tmp_folder = 'vmware_temp'",
            "        self._default_root_device = 'vda'",
            "        self._rescue_suffix = '-rescue'",
            "        self._migrate_suffix = '-orig'",
            "        self._datastore_dc_mapping = {}",
            "        self._datastore_browser_mapping = {}",
            "        self._imagecache = imagecache.ImageCacheManager(self._session,",
            "                                                        self._base_folder)",
            "",
            "    def _extend_virtual_disk(self, instance, requested_size, name, dc_ref):",
            "        service_content = self._session._get_vim().service_content",
            "        LOG.debug(\"Extending root virtual disk to %s\", requested_size)",
            "        vmdk_extend_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"ExtendVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                name=name,",
            "                datacenter=dc_ref,",
            "                newCapacityKb=requested_size,",
            "                eagerZero=False)",
            "        try:",
            "            self._session._wait_for_task(vmdk_extend_task)",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Extending virtual disk failed with error: %s'),",
            "                          e, instance=instance)",
            "                # Clean up files created during the extend operation",
            "                files = [name.replace(\".vmdk\", \"-flat.vmdk\"), name]",
            "                for file in files:",
            "                    ds_path = ds_util.DatastorePath.parse(file)",
            "                    self._delete_datastore_file(instance, ds_path, dc_ref)",
            "",
            "        LOG.debug(\"Extended root virtual disk\")",
            "",
            "    def _delete_datastore_file(self, instance, datastore_path, dc_ref):",
            "        try:",
            "            ds_util.file_delete(self._session, datastore_path, dc_ref)",
            "        except (vexc.CannotDeleteFileException,",
            "                vexc.FileFaultException,",
            "                vexc.FileLockedException,",
            "                vexc.FileNotFoundException):",
            "            LOG.debug(\"Unable to delete %(ds)s. There may be more than \"",
            "                      \"one process or thread trying to delete the file\",",
            "                      {'ds': datastore_path},",
            "                      exc_info=True)",
            "",
            "    def _extend_if_required(self, dc_info, image_info, instance,",
            "                            root_vmdk_path):",
            "        \"\"\"Increase the size of the root vmdk if necessary.\"\"\"",
            "        if instance.root_gb > image_info.file_size_in_gb:",
            "            size_in_kb = instance.root_gb * units.Mi",
            "            self._extend_virtual_disk(instance, size_in_kb,",
            "                                      root_vmdk_path, dc_info.ref)",
            "",
            "    def _configure_config_drive(self, instance, vm_ref, dc_info, datastore,",
            "                                injected_files, admin_password):",
            "        session_vim = self._session._get_vim()",
            "        cookies = session_vim.client.options.transport.cookiejar",
            "",
            "        uploaded_iso_path = self._create_config_drive(instance,",
            "                                                      injected_files,",
            "                                                      admin_password,",
            "                                                      datastore.name,",
            "                                                      dc_info.name,",
            "                                                      instance['uuid'],",
            "                                                      cookies)",
            "        uploaded_iso_path = datastore.build_path(uploaded_iso_path)",
            "        self._attach_cdrom_to_vm(",
            "            vm_ref, instance,",
            "            datastore.ref,",
            "            str(uploaded_iso_path))",
            "",
            "    def build_virtual_machine(self, instance, instance_name, image_info,",
            "                              dc_info, datastore, network_info):",
            "        node_mo_id = vm_util.get_mo_id_from_instance(instance)",
            "        res_pool_ref = vm_util.get_res_pool_ref(self._session,",
            "                                                self._cluster, node_mo_id)",
            "        vif_infos = vmwarevif.get_vif_info(self._session,",
            "                                           self._cluster,",
            "                                           utils.is_neutron(),",
            "                                           image_info.vif_model,",
            "                                           network_info)",
            "",
            "        allocations = self._get_cpu_allocations(instance.instance_type_id)",
            "",
            "        # Get the create vm config spec",
            "        client_factory = self._session._get_vim().client.factory",
            "        config_spec = vm_util.get_vm_create_spec(client_factory,",
            "                                                 instance,",
            "                                                 instance_name,",
            "                                                 datastore.name,",
            "                                                 vif_infos,",
            "                                                 image_info.os_type,",
            "                                                 allocations=allocations)",
            "        # Create the VM",
            "        vm_ref = vm_util.create_vm(self._session, instance, dc_info.vmFolder,",
            "                                   config_spec, res_pool_ref)",
            "        return vm_ref",
            "",
            "    def _get_cpu_allocations(self, instance_type_id):",
            "        # Read flavors for allocations",
            "        flavor = objects.Flavor.get_by_id(",
            "            nova_context.get_admin_context(read_deleted='yes'),",
            "            instance_type_id)",
            "        allocations = {}",
            "        for (key, type) in (('cpu_limit', int),",
            "                            ('cpu_reservation', int),",
            "                            ('cpu_shares_level', str),",
            "                            ('cpu_shares_share', int)):",
            "            value = flavor.extra_specs.get('quota:' + key)",
            "            if value:",
            "                allocations[key] = type(value)",
            "        return allocations",
            "",
            "    def _fetch_image_as_file(self, context, vi, image_ds_loc):",
            "        \"\"\"Download image as an individual file to host via HTTP PUT.\"\"\"",
            "        session = self._session",
            "        session_vim = session._get_vim()",
            "        cookies = session_vim.client.options.transport.cookiejar",
            "",
            "        LOG.debug(\"Downloading image file data %(image_id)s to \"",
            "                  \"%(file_path)s on the data store \"",
            "                  \"%(datastore_name)s\",",
            "                  {'image_id': vi.ii.image_id,",
            "                   'file_path': image_ds_loc,",
            "                   'datastore_name': vi.datastore.name},",
            "                  instance=vi.instance)",
            "",
            "        vmware_images.fetch_image(",
            "            context,",
            "            vi.instance,",
            "            session._host,",
            "            vi.dc_info.name,",
            "            vi.datastore.name,",
            "            image_ds_loc.rel_path,",
            "            cookies=cookies)",
            "",
            "    def _prepare_sparse_image(self, vi):",
            "        tmp_dir_loc = vi.datastore.build_path(",
            "                self._tmp_folder, uuidutils.generate_uuid())",
            "        tmp_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, \"tmp-sparse.vmdk\")",
            "        return tmp_dir_loc, tmp_image_ds_loc",
            "",
            "    def _prepare_flat_image(self, vi):",
            "        tmp_dir_loc = vi.datastore.build_path(",
            "                self._tmp_folder, uuidutils.generate_uuid())",
            "        tmp_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, vi.cache_image_path.basename)",
            "        ds_util.mkdir(self._session, tmp_image_ds_loc.parent, vi.dc_info.ref)",
            "        vm_util.create_virtual_disk(",
            "                self._session, vi.dc_info.ref,",
            "                vi.ii.adapter_type,",
            "                vi.ii.disk_type,",
            "                str(tmp_image_ds_loc),",
            "                vi.ii.file_size_in_kb)",
            "        flat_vmdk_name = vi.cache_image_path.basename.replace('.vmdk',",
            "                                                              '-flat.vmdk')",
            "        flat_vmdk_ds_loc = tmp_dir_loc.join(vi.ii.image_id, flat_vmdk_name)",
            "        self._delete_datastore_file(vi.instance, str(flat_vmdk_ds_loc),",
            "                                    vi.dc_info.ref)",
            "        return tmp_dir_loc, flat_vmdk_ds_loc",
            "",
            "    def _prepare_iso_image(self, vi):",
            "        tmp_dir_loc = vi.datastore.build_path(",
            "                self._tmp_folder, uuidutils.generate_uuid())",
            "        tmp_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, vi.cache_image_path.basename)",
            "        return tmp_dir_loc, tmp_image_ds_loc",
            "",
            "    def _move_to_cache(self, dc_ref, src_folder_ds_path, dst_folder_ds_path):",
            "        try:",
            "            ds_util.file_move(self._session, dc_ref,",
            "                              src_folder_ds_path, dst_folder_ds_path)",
            "        except vexc.FileAlreadyExistsException:",
            "            # Folder move has failed. This may be due to the fact that a",
            "            # process or thread has already completed the operation.",
            "            # Since image caching is synchronized, this can only happen",
            "            # due to action external to the process.",
            "            # In the event of a FileAlreadyExists we continue,",
            "            # all other exceptions will be raised.",
            "            LOG.warning(_LW(\"Destination %s already exists! Concurrent moves \"",
            "                            \"can lead to unexpected results.\"),",
            "                      dst_folder_ds_path)",
            "",
            "    def _cache_sparse_image(self, vi, tmp_image_ds_loc):",
            "        tmp_dir_loc = tmp_image_ds_loc.parent.parent",
            "        converted_image_ds_loc = tmp_dir_loc.join(",
            "                vi.ii.image_id, vi.cache_image_path.basename)",
            "        # converts fetched image to preallocated disk",
            "        vm_util.copy_virtual_disk(",
            "                self._session,",
            "                vi.dc_info.ref,",
            "                str(tmp_image_ds_loc),",
            "                str(converted_image_ds_loc))",
            "",
            "        self._delete_datastore_file(vi.instance, str(tmp_image_ds_loc),",
            "                                    vi.dc_info.ref)",
            "",
            "        self._move_to_cache(vi.dc_info.ref,",
            "                            tmp_image_ds_loc.parent,",
            "                            vi.cache_image_folder)",
            "",
            "    def _cache_flat_image(self, vi, tmp_image_ds_loc):",
            "        self._move_to_cache(vi.dc_info.ref,",
            "                            tmp_image_ds_loc.parent,",
            "                            vi.cache_image_folder)",
            "",
            "    def _cache_iso_image(self, vi, tmp_image_ds_loc):",
            "        self._move_to_cache(vi.dc_info.ref,",
            "                            tmp_image_ds_loc.parent,",
            "                            vi.cache_image_folder)",
            "",
            "    def _get_vm_config_info(self, instance, image_info, instance_name=None):",
            "        \"\"\"Captures all relevant information from the spawn parameters.\"\"\"",
            "",
            "        if (instance.root_gb != 0 and",
            "                image_info.file_size_in_gb > instance.root_gb):",
            "            reason = _(\"Image disk size greater than requested disk size\")",
            "            raise exception.InstanceUnacceptable(instance_id=instance.uuid,",
            "                                                 reason=reason)",
            "        datastore = ds_util.get_datastore(",
            "                self._session, self._cluster, self._datastore_regex)",
            "        dc_info = self.get_datacenter_ref_and_name(datastore.ref)",
            "",
            "        return VirtualMachineInstanceConfigInfo(instance,",
            "                                                instance_name,",
            "                                                image_info,",
            "                                                datastore,",
            "                                                dc_info,",
            "                                                self._imagecache)",
            "",
            "    def _get_image_callbacks(self, vi):",
            "        disk_type = vi.ii.disk_type",
            "",
            "        image_fetch = self._fetch_image_as_file",
            "",
            "        if vi.ii.is_iso:",
            "            image_prepare = self._prepare_iso_image",
            "            image_cache = self._cache_iso_image",
            "        elif disk_type == constants.DISK_TYPE_SPARSE:",
            "            image_prepare = self._prepare_sparse_image",
            "            image_cache = self._cache_sparse_image",
            "        elif disk_type in constants.SUPPORTED_FLAT_VARIANTS:",
            "            image_prepare = self._prepare_flat_image",
            "            image_cache = self._cache_flat_image",
            "        else:",
            "            reason = _(\"disk type '%s' not supported\") % disk_type",
            "            raise exception.InvalidDiskInfo(reason=reason)",
            "        return image_prepare, image_fetch, image_cache",
            "",
            "    def _fetch_image_if_missing(self, context, vi):",
            "        image_prepare, image_fetch, image_cache = self._get_image_callbacks(vi)",
            "        LOG.debug(\"Processing image %s\", vi.ii.image_id)",
            "",
            "        with lockutils.lock(str(vi.cache_image_path),",
            "                            lock_file_prefix='nova-vmware-fetch_image'):",
            "            self.check_cache_folder(vi.datastore.name, vi.datastore.ref)",
            "            ds_browser = self._get_ds_browser(vi.datastore.ref)",
            "            if not ds_util.file_exists(self._session, ds_browser,",
            "                                       vi.cache_image_folder,",
            "                                       vi.cache_image_path.basename):",
            "                LOG.debug(\"Preparing fetch location\")",
            "                tmp_dir_loc, tmp_image_ds_loc = image_prepare(vi)",
            "                LOG.debug(\"Fetch image to %s\", tmp_image_ds_loc)",
            "                image_fetch(context, vi, tmp_image_ds_loc)",
            "                LOG.debug(\"Caching image\")",
            "                image_cache(vi, tmp_image_ds_loc)",
            "                LOG.debug(\"Cleaning up location %s\", str(tmp_dir_loc))",
            "                self._delete_datastore_file(vi.instance, str(tmp_dir_loc),",
            "                                            vi.dc_info.ref)",
            "",
            "    def spawn(self, context, instance, image_meta, injected_files,",
            "              admin_password, network_info, block_device_info=None,",
            "              instance_name=None, power_on=True):",
            "",
            "        client_factory = self._session._get_vim().client.factory",
            "        image_info = vmware_images.VMwareImage.from_image(instance.image_ref,",
            "                                                          image_meta)",
            "        vi = self._get_vm_config_info(instance, image_info, instance_name)",
            "",
            "        # Creates the virtual machine. The virtual machine reference returned",
            "        # is unique within Virtual Center.",
            "        vm_ref = self.build_virtual_machine(instance,",
            "                                            vi.instance_name,",
            "                                            image_info,",
            "                                            vi.dc_info,",
            "                                            vi.datastore,",
            "                                            network_info)",
            "",
            "        # Cache the vm_ref. This saves a remote call to the VC. This uses the",
            "        # instance_name. This covers all use cases including rescue and resize.",
            "        vm_util.vm_ref_cache_update(vi.instance_name, vm_ref)",
            "",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        if CONF.flat_injected:",
            "            self._set_machine_id(client_factory, instance, network_info)",
            "",
            "        # Set the vnc configuration of the instance, vnc port starts from 5900",
            "        if CONF.vnc_enabled:",
            "            vnc_port = vm_util.get_vnc_port(self._session)",
            "            self._set_vnc_config(client_factory, instance, vnc_port)",
            "",
            "        block_device_mapping = []",
            "        if block_device_info is not None:",
            "            block_device_mapping = driver.block_device_info_get_mapping(",
            "                block_device_info)",
            "",
            "        # NOTE(mdbooth): the logic here is that we ignore the image if there",
            "        # are block device mappings. This behaviour is incorrect, and a bug in",
            "        # the driver.  We should be able to accept an image and block device",
            "        # mappings.",
            "        if len(block_device_mapping) > 0:",
            "            msg = \"Block device information present: %s\" % block_device_info",
            "            # NOTE(mriedem): block_device_info can contain an auth_password",
            "            # so we have to scrub the message before logging it.",
            "            LOG.debug(logging.mask_password(msg), instance=instance)",
            "",
            "            for root_disk in block_device_mapping:",
            "                connection_info = root_disk['connection_info']",
            "                # TODO(hartsocks): instance is unnecessary, remove it",
            "                # we still use instance in many locations for no other purpose",
            "                # than logging, can we simplify this?",
            "                self._volumeops.attach_root_volume(connection_info, instance,",
            "                                                   self._default_root_device,",
            "                                                   vi.datastore.ref)",
            "        else:",
            "            self._imagecache.enlist_image(",
            "                    image_info.image_id, vi.datastore, vi.dc_info.ref)",
            "            self._fetch_image_if_missing(context, vi)",
            "",
            "            if image_info.is_iso:",
            "                self._use_iso_image(vm_ref, vi)",
            "            elif image_info.linked_clone:",
            "                self._use_disk_image_as_linked_clone(vm_ref, vi)",
            "            else:",
            "                self._use_disk_image_as_full_clone(vm_ref, vi)",
            "",
            "            if configdrive.required_by(instance):",
            "                self._configure_config_drive(",
            "                        instance, vm_ref, vi.dc_info, vi.datastore,",
            "                        injected_files, admin_password)",
            "",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance, vm_ref=vm_ref)",
            "",
            "    def _create_config_drive(self, instance, injected_files, admin_password,",
            "                             data_store_name, dc_name, upload_folder, cookies):",
            "        if CONF.config_drive_format != 'iso9660':",
            "            reason = (_('Invalid config_drive_format \"%s\"') %",
            "                      CONF.config_drive_format)",
            "            raise exception.InstancePowerOnFailure(reason=reason)",
            "",
            "        LOG.info(_('Using config drive for instance'), instance=instance)",
            "        extra_md = {}",
            "        if admin_password:",
            "            extra_md['admin_pass'] = admin_password",
            "",
            "        inst_md = instance_metadata.InstanceMetadata(instance,",
            "                                                     content=injected_files,",
            "                                                     extra_md=extra_md)",
            "        try:",
            "            with configdrive.ConfigDriveBuilder(instance_md=inst_md) as cdb:",
            "                with utils.tempdir() as tmp_path:",
            "                    tmp_file = os.path.join(tmp_path, 'configdrive.iso')",
            "                    cdb.make_drive(tmp_file)",
            "                    upload_iso_path = \"%s/configdrive.iso\" % (",
            "                        upload_folder)",
            "                    vmware_images.upload_iso_to_datastore(",
            "                        tmp_file, instance,",
            "                        host=self._session._host,",
            "                        data_center_name=dc_name,",
            "                        datastore_name=data_store_name,",
            "                        cookies=cookies,",
            "                        file_path=upload_iso_path)",
            "                    return upload_iso_path",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_('Creating config drive failed with error: %s'),",
            "                          e, instance=instance)",
            "",
            "    def _attach_cdrom_to_vm(self, vm_ref, instance,",
            "                            datastore, file_path):",
            "        \"\"\"Attach cdrom to VM by reconfiguration.\"\"\"",
            "        client_factory = self._session._get_vim().client.factory",
            "        devices = self._session._call_method(vim_util,",
            "                                    \"get_dynamic_property\", vm_ref,",
            "                                    \"VirtualMachine\", \"config.hardware.device\")",
            "        (controller_key, unit_number,",
            "         controller_spec) = vm_util.allocate_controller_key_and_unit_number(",
            "                                                              client_factory,",
            "                                                              devices,",
            "                                                              'ide')",
            "        cdrom_attach_config_spec = vm_util.get_cdrom_attach_config_spec(",
            "                                    client_factory, datastore, file_path,",
            "                                    controller_key, unit_number)",
            "        if controller_spec:",
            "            cdrom_attach_config_spec.deviceChange.append(controller_spec)",
            "",
            "        LOG.debug(\"Reconfiguring VM instance to attach cdrom %s\",",
            "                  file_path, instance=instance)",
            "        vm_util.reconfigure_vm(self._session, vm_ref, cdrom_attach_config_spec)",
            "        LOG.debug(\"Reconfigured VM instance to attach cdrom %s\",",
            "                  file_path, instance=instance)",
            "",
            "    def _create_vm_snapshot(self, instance, vm_ref):",
            "        LOG.debug(\"Creating Snapshot of the VM instance\", instance=instance)",
            "        snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"CreateSnapshot_Task\", vm_ref,",
            "                    name=\"%s-snapshot\" % instance.uuid,",
            "                    description=\"Taking Snapshot of the VM\",",
            "                    memory=False,",
            "                    quiesce=True)",
            "        self._session._wait_for_task(snapshot_task)",
            "        LOG.debug(\"Created Snapshot of the VM instance\", instance=instance)",
            "        task_info = self._session._call_method(vim_util,",
            "                                               \"get_dynamic_property\",",
            "                                               snapshot_task, \"Task\", \"info\")",
            "        snapshot = task_info.result",
            "        return snapshot",
            "",
            "    @retry_if_task_in_progress",
            "    def _delete_vm_snapshot(self, instance, vm_ref, snapshot):",
            "        LOG.debug(\"Deleting Snapshot of the VM instance\", instance=instance)",
            "        delete_snapshot_task = self._session._call_method(",
            "                    self._session._get_vim(),",
            "                    \"RemoveSnapshot_Task\", snapshot,",
            "                    removeChildren=False, consolidate=True)",
            "        self._session._wait_for_task(delete_snapshot_task)",
            "        LOG.debug(\"Deleted Snapshot of the VM instance\", instance=instance)",
            "",
            "    def snapshot(self, context, instance, image_id, update_task_state):",
            "        \"\"\"Create snapshot from a running VM instance.",
            "",
            "        Steps followed are:",
            "",
            "        1. Get the name of the vmdk file which the VM points to right now.",
            "           Can be a chain of snapshots, so we need to know the last in the",
            "           chain.",
            "        2. Create the snapshot. A new vmdk is created which the VM points to",
            "           now. The earlier vmdk becomes read-only.",
            "        3. Call CopyVirtualDisk which coalesces the disk chain to form a single",
            "           vmdk, rather a .vmdk metadata file and a -flat.vmdk disk data file.",
            "        4. Now upload the -flat.vmdk file to the image store.",
            "        5. Delete the coalesced .vmdk and -flat.vmdk created.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        service_content = self._session._get_vim().service_content",
            "",
            "        def _get_vm_and_vmdk_attribs():",
            "            # Get the vmdk file name that the VM is pointing to",
            "            hw_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "            (vmdk_file_path_before_snapshot, adapter_type,",
            "             disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                                        hw_devices, uuid=instance.uuid)",
            "            if not vmdk_file_path_before_snapshot:",
            "                LOG.debug(\"No root disk defined. Unable to snapshot.\")",
            "                raise error_util.NoRootDiskDefined()",
            "",
            "            datastore_name = ds_util.DatastorePath.parse(",
            "                    vmdk_file_path_before_snapshot).datastore",
            "            os_type = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"summary.config.guestId\")",
            "            return (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "                    datastore_name, os_type)",
            "",
            "        (vmdk_file_path_before_snapshot, adapter_type, disk_type,",
            "         datastore_name, os_type) = _get_vm_and_vmdk_attribs()",
            "",
            "        snapshot = self._create_vm_snapshot(instance, vm_ref)",
            "        update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD)",
            "",
            "        def _check_if_tmp_folder_exists():",
            "            # Copy the contents of the VM that were there just before the",
            "            # snapshot was taken",
            "            ds_ref_ret = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", vm_ref, \"VirtualMachine\",",
            "                \"datastore\")",
            "            if ds_ref_ret is None:",
            "                raise exception.DatastoreNotFound()",
            "            ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "            self.check_temp_folder(datastore_name, ds_ref)",
            "            return ds_ref",
            "",
            "        ds_ref = _check_if_tmp_folder_exists()",
            "",
            "        # Generate a random vmdk file name to which the coalesced vmdk content",
            "        # will be copied to. A random name is chosen so that we don't have",
            "        # name clashes.",
            "        random_name = uuidutils.generate_uuid()",
            "        dest_vmdk_file_path = ds_util.DatastorePath(",
            "                datastore_name, self._tmp_folder, \"%s.vmdk\" % random_name)",
            "        dest_vmdk_data_file_path = ds_util.DatastorePath(",
            "                datastore_name, self._tmp_folder, \"%s-flat.vmdk\" % random_name)",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "",
            "        def _copy_vmdk_content():",
            "            # Consolidate the snapshotted disk to a temporary vmdk.",
            "            LOG.debug('Copying snapshotted disk %s.',",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "            copy_disk_task = self._session._call_method(",
            "                self._session._get_vim(),",
            "                \"CopyVirtualDisk_Task\",",
            "                service_content.virtualDiskManager,",
            "                sourceName=vmdk_file_path_before_snapshot,",
            "                sourceDatacenter=dc_info.ref,",
            "                destName=str(dest_vmdk_file_path),",
            "                destDatacenter=dc_info.ref,",
            "                force=False)",
            "            self._session._wait_for_task(copy_disk_task)",
            "            LOG.debug('Copied snapshotted disk %s.',",
            "                      vmdk_file_path_before_snapshot,",
            "                      instance=instance)",
            "",
            "        _copy_vmdk_content()",
            "        self._delete_vm_snapshot(instance, vm_ref, snapshot)",
            "",
            "        cookies = self._session._get_vim().client.options.transport.cookiejar",
            "",
            "        def _upload_vmdk_to_image_repository():",
            "            # Upload the contents of -flat.vmdk file which has the disk data.",
            "            LOG.debug(\"Uploading image %s\", image_id,",
            "                      instance=instance)",
            "            vmware_images.upload_image(",
            "                context,",
            "                image_id,",
            "                instance,",
            "                os_type=os_type,",
            "                disk_type=constants.DEFAULT_DISK_TYPE,",
            "                adapter_type=adapter_type,",
            "                image_version=1,",
            "                host=self._session._host,",
            "                data_center_name=dc_info.name,",
            "                datastore_name=datastore_name,",
            "                cookies=cookies,",
            "                file_path=\"%s/%s-flat.vmdk\" % (self._tmp_folder, random_name))",
            "            LOG.debug(\"Uploaded image %s\", image_id,",
            "                      instance=instance)",
            "",
            "        update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                          expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "        _upload_vmdk_to_image_repository()",
            "",
            "        def _clean_temp_data():",
            "            \"\"\"Delete temporary vmdk files generated in image handling",
            "            operations.",
            "            \"\"\"",
            "            # The data file is the one occupying space, and likelier to see",
            "            # deletion problems, so prioritize its deletion first. In the",
            "            # unlikely event that its deletion fails, the small descriptor file",
            "            # is retained too by design since it makes little sense to remove",
            "            # it when the data disk it refers to still lingers.",
            "            for f in dest_vmdk_data_file_path, dest_vmdk_file_path:",
            "                self._delete_datastore_file(instance, f, dc_info.ref)",
            "",
            "        _clean_temp_data()",
            "",
            "    def reboot(self, instance, network_info):",
            "        \"\"\"Reboot a VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.guest.toolsStatus\", \"runtime.powerState\",",
            "                          \"summary.guest.toolsRunningStatus\"]",
            "        props = self._session._call_method(vim_util, \"get_object_properties\",",
            "                           None, vm_ref, \"VirtualMachine\",",
            "                           lst_properties)",
            "        query = vm_util.get_values_from_object_properties(self._session, props)",
            "        pwr_state = query['runtime.powerState']",
            "        tools_status = query['summary.guest.toolsStatus']",
            "        tools_running_status = query['summary.guest.toolsRunningStatus']",
            "",
            "        # Raise an exception if the VM is not powered On.",
            "        if pwr_state not in [\"poweredOn\"]:",
            "            reason = _(\"instance is not powered on\")",
            "            raise exception.InstanceRebootFailure(reason=reason)",
            "",
            "        # If latest vmware tools are installed in the VM, and that the tools",
            "        # are running, then only do a guest reboot. Otherwise do a hard reset.",
            "        if (tools_status == \"toolsOk\" and",
            "                tools_running_status == \"guestToolsRunning\"):",
            "            LOG.debug(\"Rebooting guest OS of VM\", instance=instance)",
            "            self._session._call_method(self._session._get_vim(), \"RebootGuest\",",
            "                                       vm_ref)",
            "            LOG.debug(\"Rebooted guest OS of VM\", instance=instance)",
            "        else:",
            "            LOG.debug(\"Doing hard reboot of VM\", instance=instance)",
            "            reset_task = self._session._call_method(self._session._get_vim(),",
            "                                                    \"ResetVM_Task\", vm_ref)",
            "            self._session._wait_for_task(reset_task)",
            "            LOG.debug(\"Did hard reboot of VM\", instance=instance)",
            "",
            "    def _destroy_instance(self, instance, destroy_disks=True,",
            "                          instance_name=None):",
            "        # Destroy a VM instance",
            "        # Get the instance name. In some cases this may differ from the 'uuid',",
            "        # for example when the spawn of a rescue instance takes place.",
            "        if instance_name is None:",
            "            instance_name = instance['uuid']",
            "        try:",
            "            vm_ref = vm_util.get_vm_ref_from_name(self._session, instance_name)",
            "            if vm_ref is None:",
            "                LOG.warning(_('Instance does not exist on backend'),",
            "                            instance=instance)",
            "                return",
            "            lst_properties = [\"config.files.vmPathName\", \"runtime.powerState\",",
            "                              \"datastore\"]",
            "            props = self._session._call_method(vim_util,",
            "                        \"get_object_properties\",",
            "                        None, vm_ref, \"VirtualMachine\", lst_properties)",
            "            query = vm_util.get_values_from_object_properties(",
            "                    self._session, props)",
            "            pwr_state = query['runtime.powerState']",
            "            vm_config_pathname = query['config.files.vmPathName']",
            "            vm_ds_path = None",
            "            if vm_config_pathname:",
            "                vm_ds_path = ds_util.DatastorePath.parse(vm_config_pathname)",
            "",
            "            # Power off the VM if it is in PoweredOn state.",
            "            if pwr_state == \"poweredOn\":",
            "                vm_util.power_off_instance(self._session, instance, vm_ref)",
            "",
            "            # Un-register the VM",
            "            try:",
            "                LOG.debug(\"Unregistering the VM\", instance=instance)",
            "                self._session._call_method(self._session._get_vim(),",
            "                                           \"UnregisterVM\", vm_ref)",
            "                LOG.debug(\"Unregistered the VM\", instance=instance)",
            "            except Exception as excep:",
            "                LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, got this \"",
            "                           \"exception while un-registering the VM: %s\"),",
            "                         excep)",
            "            # Delete the folder holding the VM related content on",
            "            # the datastore.",
            "            if destroy_disks and vm_ds_path:",
            "                try:",
            "                    dir_ds_compliant_path = vm_ds_path.parent",
            "                    LOG.debug(\"Deleting contents of the VM from \"",
            "                              \"datastore %(datastore_name)s\",",
            "                              {'datastore_name': vm_ds_path.datastore},",
            "                              instance=instance)",
            "                    ds_ref_ret = query['datastore']",
            "                    ds_ref = ds_ref_ret.ManagedObjectReference[0]",
            "                    dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "                    ds_util.file_delete(self._session,",
            "                                        dir_ds_compliant_path,",
            "                                        dc_info.ref)",
            "                    LOG.debug(\"Deleted contents of the VM from \"",
            "                              \"datastore %(datastore_name)s\",",
            "                              {'datastore_name': vm_ds_path.datastore},",
            "                              instance=instance)",
            "                except Exception:",
            "                    LOG.warn(_(\"In vmwareapi:vmops:_destroy_instance, \"",
            "                               \"exception while deleting the VM contents from \"",
            "                               \"the disk\"), exc_info=True)",
            "        except Exception as exc:",
            "            LOG.exception(exc, instance=instance)",
            "        finally:",
            "            vm_util.vm_ref_cache_delete(instance_name)",
            "",
            "    def destroy(self, instance, destroy_disks=True):",
            "        \"\"\"Destroy a VM instance.",
            "",
            "        Steps followed for each VM are:",
            "        1. Power off, if it is in poweredOn state.",
            "        2. Un-register.",
            "        3. Delete the contents of the folder holding the VM related data.",
            "        \"\"\"",
            "        # If there is a rescue VM then we need to destroy that one too.",
            "        LOG.debug(\"Destroying instance\", instance=instance)",
            "        if instance['vm_state'] == vm_states.RESCUED:",
            "            LOG.debug(\"Rescue VM configured\", instance=instance)",
            "            try:",
            "                self.unrescue(instance, power_on=False)",
            "                LOG.debug(\"Rescue VM destroyed\", instance=instance)",
            "            except Exception:",
            "                rescue_name = instance['uuid'] + self._rescue_suffix",
            "                self._destroy_instance(instance,",
            "                                       destroy_disks=destroy_disks,",
            "                                       instance_name=rescue_name)",
            "        # When VM deletion is triggered in middle of VM resize before VM",
            "        # arrive RESIZED state, uuid-orig VM need to deleted to avoid",
            "        # VM leak. Within method _destroy_instance it will check vmref",
            "        # exist or not before attempt deletion.",
            "        resize_orig_vmname = instance['uuid'] + self._migrate_suffix",
            "        vm_orig_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                   resize_orig_vmname)",
            "        if vm_orig_ref:",
            "            self._destroy_instance(instance,",
            "                                   destroy_disks=destroy_disks,",
            "                                   instance_name=resize_orig_vmname)",
            "        self._destroy_instance(instance, destroy_disks=destroy_disks)",
            "        LOG.debug(\"Instance destroyed\", instance=instance)",
            "",
            "    def pause(self, instance):",
            "        msg = _(\"pause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def unpause(self, instance):",
            "        msg = _(\"unpause not supported for vmwareapi\")",
            "        raise NotImplementedError(msg)",
            "",
            "    def suspend(self, instance):",
            "        \"\"\"Suspend the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                    \"get_dynamic_property\", vm_ref,",
            "                    \"VirtualMachine\", \"runtime.powerState\")",
            "        # Only PoweredOn VMs can be suspended.",
            "        if pwr_state == \"poweredOn\":",
            "            LOG.debug(\"Suspending the VM\", instance=instance)",
            "            suspend_task = self._session._call_method(self._session._get_vim(),",
            "                    \"SuspendVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(\"Suspended the VM\", instance=instance)",
            "        # Raise Exception if VM is poweredOff",
            "        elif pwr_state == \"poweredOff\":",
            "            reason = _(\"instance is powered off and cannot be suspended.\")",
            "            raise exception.InstanceSuspendFailure(reason=reason)",
            "        else:",
            "            LOG.debug(\"VM was already in suspended state. So returning \"",
            "                      \"without doing anything\", instance=instance)",
            "",
            "    def resume(self, instance):",
            "        \"\"\"Resume the specified instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        pwr_state = self._session._call_method(vim_util,",
            "                                     \"get_dynamic_property\", vm_ref,",
            "                                     \"VirtualMachine\", \"runtime.powerState\")",
            "        if pwr_state.lower() == \"suspended\":",
            "            LOG.debug(\"Resuming the VM\", instance=instance)",
            "            suspend_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                       \"PowerOnVM_Task\", vm_ref)",
            "            self._session._wait_for_task(suspend_task)",
            "            LOG.debug(\"Resumed the VM\", instance=instance)",
            "        else:",
            "            reason = _(\"instance is not in a suspended state\")",
            "            raise exception.InstanceResumeFailure(reason=reason)",
            "",
            "    def rescue(self, context, instance, network_info, image_meta):",
            "        \"\"\"Rescue the specified instance.",
            "",
            "            - shutdown the instance VM.",
            "            - spawn a rescue VM (the vm name-label will be instance-N-rescue).",
            "",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        self.power_off(instance)",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance.uuid + self._rescue_suffix",
            "        self.spawn(context, r_instance, image_meta,",
            "                   None, None, network_info,",
            "                   instance_name=instance_name,",
            "                   power_on=False)",
            "",
            "        # Attach vmdk to the rescue VM",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance.uuid)",
            "        rescue_vm_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        self._volumeops.attach_disk_to_vm(",
            "                                rescue_vm_ref, r_instance,",
            "                                adapter_type, disk_type, vmdk_path)",
            "        vm_util.power_on_instance(self._session, r_instance,",
            "                                  vm_ref=rescue_vm_ref)",
            "",
            "    def unrescue(self, instance, power_on=True):",
            "        \"\"\"Unrescue the specified instance.\"\"\"",
            "        # Get the original vmdk_path",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        (vmdk_path, adapter_type,",
            "         disk_type) = vm_util.get_vmdk_path_and_adapter_type(",
            "                hardware_devices, uuid=instance.uuid)",
            "",
            "        r_instance = copy.deepcopy(instance)",
            "        instance_name = r_instance.uuid + self._rescue_suffix",
            "        # detach the original instance disk from the rescue disk",
            "        vm_rescue_ref = vm_util.get_vm_ref_from_name(self._session,",
            "                                                     instance_name)",
            "        hardware_devices = self._session._call_method(vim_util,",
            "                        \"get_dynamic_property\", vm_rescue_ref,",
            "                        \"VirtualMachine\", \"config.hardware.device\")",
            "        device = vm_util.get_vmdk_volume_disk(hardware_devices, path=vmdk_path)",
            "        vm_util.power_off_instance(self._session, r_instance, vm_rescue_ref)",
            "        self._volumeops.detach_disk_from_vm(vm_rescue_ref, r_instance, device)",
            "        self._destroy_instance(r_instance, instance_name=instance_name)",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance, vm_ref=vm_ref)",
            "",
            "    def power_off(self, instance):",
            "        \"\"\"Power off the specified instance.",
            "",
            "        :param instance: nova.objects.instance.Instance",
            "        \"\"\"",
            "        vm_util.power_off_instance(self._session, instance)",
            "",
            "    def power_on(self, instance):",
            "        vm_util.power_on_instance(self._session, instance)",
            "",
            "    def _get_orig_vm_name_label(self, instance):",
            "        return instance.uuid + '-orig'",
            "",
            "    def _update_instance_progress(self, context, instance, step, total_steps):",
            "        \"\"\"Update instance progress percent to reflect current step number",
            "        \"\"\"",
            "        # Divide the action's workflow into discrete steps and \"bump\" the",
            "        # instance's progress field as each step is completed.",
            "        #",
            "        # For a first cut this should be fine, however, for large VM images,",
            "        # the clone disk step begins to dominate the equation. A",
            "        # better approximation would use the percentage of the VM image that",
            "        # has been streamed to the destination host.",
            "        progress = round(float(step) / total_steps * 100)",
            "        instance_uuid = instance.uuid",
            "        LOG.debug(\"Updating instance '%(instance_uuid)s' progress to\"",
            "                  \" %(progress)d\",",
            "                  {'instance_uuid': instance_uuid, 'progress': progress},",
            "                  instance=instance)",
            "        instance.progress = progress",
            "        instance.save()",
            "",
            "    def migrate_disk_and_power_off(self, context, instance, dest,",
            "                                   flavor):",
            "        \"\"\"Transfers the disk of a running instance in multiple phases, turning",
            "        off the instance before the end.",
            "        \"\"\"",
            "        # Checks if the migration needs a disk resize down.",
            "        if flavor['root_gb'] < instance['root_gb']:",
            "            reason = _(\"Unable to shrink disk.\")",
            "            raise exception.InstanceFaultRollback(",
            "                exception.ResizeError(reason=reason))",
            "",
            "        # 0. Zero out the progress to begin",
            "        self._update_instance_progress(context, instance,",
            "                                       step=0,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Read the host_ref for the destination. If this is None then the",
            "        # VC will decide on placement",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "",
            "        # 1. Power off the instance",
            "        self.power_off(instance)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=1,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        # 2. Disassociate the linked vsphere VM from the instance",
            "        vm_util.disassociate_vmref_from_instance(self._session, instance,",
            "                                                 vm_ref,",
            "                                                 suffix=self._migrate_suffix)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=2,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "        ds_ref = ds_util.get_datastore(",
            "                            self._session, self._cluster,",
            "                            datastore_regex=self._datastore_regex).ref",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        # 3. Clone the VM for instance",
            "        vm_util.clone_vmref_for_instance(self._session, instance, vm_ref,",
            "                                         host_ref, ds_ref, dc_info.vmFolder)",
            "        self._update_instance_progress(context, instance,",
            "                                       step=3,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def confirm_migration(self, migration, instance, network_info):",
            "        \"\"\"Confirms a resize, destroying the source VM.\"\"\"",
            "        # Destroy the original VM. The vm_ref needs to be searched using the",
            "        # instance.uuid + self._migrate_suffix as the identifier. We will",
            "        # not get the vm when searched using the instanceUuid but rather will",
            "        # be found using the uuid buried in the extraConfig",
            "        vm_ref = vm_util.search_vm_ref_by_identifier(self._session,",
            "                                    instance.uuid + self._migrate_suffix)",
            "        if vm_ref is None:",
            "            LOG.debug(\"instance not present\", instance=instance)",
            "            return",
            "",
            "        try:",
            "            LOG.debug(\"Destroying the VM\", instance=instance)",
            "            destroy_task = self._session._call_method(",
            "                                        self._session._get_vim(),",
            "                                        \"Destroy_Task\", vm_ref)",
            "            self._session._wait_for_task(destroy_task)",
            "            LOG.debug(\"Destroyed the VM\", instance=instance)",
            "        except Exception as excep:",
            "            LOG.warn(_(\"In vmwareapi:vmops:confirm_migration, got this \"",
            "                     \"exception while destroying the VM: %s\"), excep)",
            "",
            "    def finish_revert_migration(self, context, instance, network_info,",
            "                                block_device_info, power_on=True):",
            "        \"\"\"Finish reverting a resize.\"\"\"",
            "        vm_util.associate_vmref_for_instance(self._session, instance,",
            "                                             suffix=self._migrate_suffix)",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance)",
            "",
            "    def finish_migration(self, context, migration, instance, disk_info,",
            "                         network_info, image_meta, resize_instance=False,",
            "                         block_device_info=None, power_on=True):",
            "        \"\"\"Completes a resize, turning on the migrated instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        if resize_instance:",
            "            client_factory = self._session._get_vim().client.factory",
            "            vm_resize_spec = vm_util.get_vm_resize_spec(client_factory,",
            "                                                        instance)",
            "            vm_util.reconfigure_vm(self._session, vm_ref, vm_resize_spec)",
            "",
            "            # Resize the disk (if larger)",
            "            old_root_gb = instance.system_metadata['old_instance_type_root_gb']",
            "            if instance['root_gb'] > int(old_root_gb):",
            "                root_disk_in_kb = instance['root_gb'] * units.Mi",
            "                vmdk_path = vm_util.get_vmdk_path(self._session, vm_ref,",
            "                                                  instance)",
            "                data_store_ref = ds_util.get_datastore(self._session,",
            "                    self._cluster, datastore_regex=self._datastore_regex).ref",
            "                dc_info = self.get_datacenter_ref_and_name(data_store_ref)",
            "                self._extend_virtual_disk(instance, root_disk_in_kb, vmdk_path,",
            "                                          dc_info.ref)",
            "",
            "            # TODO(ericwb): add extend for ephemeral disk",
            "",
            "        # 4. Start VM",
            "        if power_on:",
            "            vm_util.power_on_instance(self._session, instance, vm_ref=vm_ref)",
            "",
            "        self._update_instance_progress(context, instance,",
            "                                       step=4,",
            "                                       total_steps=RESIZE_TOTAL_STEPS)",
            "",
            "    def live_migration(self, context, instance_ref, dest,",
            "                       post_method, recover_method, block_migration=False):",
            "        \"\"\"Spawning live_migration operation for distributing high-load.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance_ref)",
            "",
            "        host_ref = self._get_host_ref_from_name(dest)",
            "        if host_ref is None:",
            "            raise exception.HostNotFound(host=dest)",
            "",
            "        LOG.debug(\"Migrating VM to host %s\", dest, instance=instance_ref)",
            "        try:",
            "            vm_migrate_task = self._session._call_method(",
            "                                    self._session._get_vim(),",
            "                                    \"MigrateVM_Task\", vm_ref,",
            "                                    host=host_ref,",
            "                                    priority=\"defaultPriority\")",
            "            self._session._wait_for_task(vm_migrate_task)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                recover_method(context, instance_ref, dest, block_migration)",
            "        post_method(context, instance_ref, dest, block_migration)",
            "        LOG.debug(\"Migrated VM to host %s\", dest, instance=instance_ref)",
            "",
            "    def poll_rebooting_instances(self, timeout, instances):",
            "        \"\"\"Poll for rebooting instances.\"\"\"",
            "        ctxt = nova_context.get_admin_context()",
            "",
            "        instances_info = dict(instance_count=len(instances),",
            "                timeout=timeout)",
            "",
            "        if instances_info[\"instance_count\"] > 0:",
            "            LOG.info(_(\"Found %(instance_count)d hung reboots \"",
            "                    \"older than %(timeout)d seconds\") % instances_info)",
            "",
            "        for instance in instances:",
            "            LOG.info(_(\"Automatically hard rebooting\"), instance=instance)",
            "            self.compute_api.reboot(ctxt, instance, \"HARD\")",
            "",
            "    def get_info(self, instance):",
            "        \"\"\"Return data about the VM instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        lst_properties = [\"summary.config.numCpu\",",
            "                    \"summary.config.memorySizeMB\",",
            "                    \"runtime.powerState\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        query = vm_util.get_values_from_object_properties(",
            "                self._session, vm_props)",
            "        max_mem = int(query['summary.config.memorySizeMB']) * 1024",
            "        return {'state': VMWARE_POWER_STATES[query['runtime.powerState']],",
            "                'max_mem': max_mem,",
            "                'mem': max_mem,",
            "                'num_cpu': int(query['summary.config.numCpu']),",
            "                'cpu_time': 0}",
            "",
            "    def _get_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        lst_properties = [\"summary.config\",",
            "                          \"summary.quickStats\",",
            "                          \"summary.runtime\"]",
            "        vm_props = self._session._call_method(vim_util,",
            "                    \"get_object_properties\", None, vm_ref, \"VirtualMachine\",",
            "                    lst_properties)",
            "        query = vm_util.get_values_from_object_properties(self._session,",
            "                                                          vm_props)",
            "        data = {}",
            "        # All of values received are objects. Convert them to dictionaries",
            "        for value in query.values():",
            "            prop_dict = vim_util.object_to_dict(value, list_depth=1)",
            "            data.update(prop_dict)",
            "        return data",
            "",
            "    def get_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        data = self._get_diagnostics(instance)",
            "        # Add a namespace to all of the diagnostsics",
            "        return dict([('vmware:' + k, v) for k, v in data.items()])",
            "",
            "    def get_instance_diagnostics(self, instance):",
            "        \"\"\"Return data about VM diagnostics.\"\"\"",
            "        data = self._get_diagnostics(instance)",
            "        state = data.get('powerState')",
            "        if state:",
            "            state = power_state.STATE_MAP[VMWARE_POWER_STATES[state]]",
            "        uptime = data.get('uptimeSeconds', 0)",
            "        config_drive = configdrive.required_by(instance)",
            "        diags = diagnostics.Diagnostics(state=state,",
            "                                        driver='vmwareapi',",
            "                                        config_drive=config_drive,",
            "                                        hypervisor_os='esxi',",
            "                                        uptime=uptime)",
            "        diags.memory_details.maximum = data.get('memorySizeMB', 0)",
            "        diags.memory_details.used = data.get('guestMemoryUsage', 0)",
            "        # TODO(garyk): add in cpu, nic and disk stats",
            "        return diags",
            "",
            "    def _get_vnc_console_connection(self, instance):",
            "        \"\"\"Return connection info for a vnc console.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        opt_value = self._session._call_method(vim_util,",
            "                               'get_dynamic_property',",
            "                               vm_ref, 'VirtualMachine',",
            "                               vm_util.VNC_CONFIG_KEY)",
            "        if opt_value:",
            "            port = int(opt_value.value)",
            "        else:",
            "            raise exception.ConsoleTypeUnavailable(console_type='vnc')",
            "",
            "        return {'port': port,",
            "                'internal_access_path': None}",
            "",
            "    @staticmethod",
            "    def _get_machine_id_str(network_info):",
            "        machine_id_str = ''",
            "        for vif in network_info:",
            "            # TODO(vish): add support for dns2",
            "            # TODO(sateesh): add support for injection of ipv6 configuration",
            "            network = vif['network']",
            "            ip_v4 = netmask_v4 = gateway_v4 = broadcast_v4 = dns = None",
            "            subnets_v4 = [s for s in network['subnets'] if s['version'] == 4]",
            "            if len(subnets_v4) > 0:",
            "                if len(subnets_v4[0]['ips']) > 0:",
            "                    ip_v4 = subnets_v4[0]['ips'][0]",
            "                if len(subnets_v4[0]['dns']) > 0:",
            "                    dns = subnets_v4[0]['dns'][0]['address']",
            "",
            "                netmask_v4 = str(subnets_v4[0].as_netaddr().netmask)",
            "                gateway_v4 = subnets_v4[0]['gateway']['address']",
            "                broadcast_v4 = str(subnets_v4[0].as_netaddr().broadcast)",
            "",
            "            interface_str = \";\".join([vif['address'],",
            "                                      ip_v4 and ip_v4['address'] or '',",
            "                                      netmask_v4 or '',",
            "                                      gateway_v4 or '',",
            "                                      broadcast_v4 or '',",
            "                                      dns or ''])",
            "            machine_id_str = machine_id_str + interface_str + '#'",
            "        return machine_id_str",
            "",
            "    def _set_machine_id(self, client_factory, instance, network_info):",
            "        \"\"\"Set the machine id of the VM for guest tools to pick up",
            "        and reconfigure the network interfaces.",
            "        \"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        machine_id_change_spec = vm_util.get_machine_id_change_spec(",
            "                                 client_factory,",
            "                                 self._get_machine_id_str(network_info))",
            "",
            "        LOG.debug(\"Reconfiguring VM instance to set the machine id\",",
            "                  instance=instance)",
            "        vm_util.reconfigure_vm(self._session, vm_ref, machine_id_change_spec)",
            "        LOG.debug(\"Reconfigured VM instance to set the machine id\",",
            "                  instance=instance)",
            "",
            "    def _set_vnc_config(self, client_factory, instance, port):",
            "        \"\"\"Set the vnc configuration of the VM.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "",
            "        vnc_config_spec = vm_util.get_vnc_config_spec(",
            "                                      client_factory, port)",
            "",
            "        LOG.debug(\"Reconfiguring VM instance to enable vnc on \"",
            "                  \"port - %(port)s\", {'port': port},",
            "                  instance=instance)",
            "        vm_util.reconfigure_vm(self._session, vm_ref, vnc_config_spec)",
            "        LOG.debug(\"Reconfigured VM instance to enable vnc on \"",
            "                  \"port - %(port)s\", {'port': port},",
            "                  instance=instance)",
            "",
            "    def _get_ds_browser(self, ds_ref):",
            "        ds_browser = self._datastore_browser_mapping.get(ds_ref.value)",
            "        if not ds_browser:",
            "            ds_browser = self._session._call_method(",
            "                vim_util, \"get_dynamic_property\", ds_ref, \"Datastore\",",
            "                \"browser\")",
            "            self._datastore_browser_mapping[ds_ref.value] = ds_browser",
            "        return ds_browser",
            "",
            "    def _get_host_ref_from_name(self, host_name):",
            "        \"\"\"Get reference to the host with the name specified.\"\"\"",
            "        host_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"HostSystem\", [\"name\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, host_objs)",
            "        for host in host_objs:",
            "            if hasattr(host, 'propSet'):",
            "                if host.propSet[0].val == host_name:",
            "                    return host.obj",
            "        return None",
            "",
            "    def _get_vmfolder_ref(self):",
            "        \"\"\"Get the Vm folder ref from the datacenter.\"\"\"",
            "        dc_objs = self._session._call_method(vim_util, \"get_objects\",",
            "                                             \"Datacenter\", [\"vmFolder\"])",
            "        vm_util._cancel_retrieve_if_necessary(self._session, dc_objs)",
            "        # There is only one default datacenter in a standalone ESX host",
            "        vm_folder_ref = dc_objs.objects[0].propSet[0].val",
            "        return vm_folder_ref",
            "",
            "    def _create_folder_if_missing(self, ds_name, ds_ref, folder):",
            "        \"\"\"Create a folder if it does not exist.",
            "",
            "        Currently there are two folder that are required on the datastore",
            "         - base folder - the folder to store cached images",
            "         - temp folder - the folder used for snapshot management and",
            "                         image uploading",
            "        This method is aimed to be used for the management of those",
            "        folders to ensure that they are created if they are missing.",
            "        The ds_util method mkdir will be used to check if the folder",
            "        exists. If this throws and exception 'FileAlreadyExistsException'",
            "        then the folder already exists on the datastore.",
            "        \"\"\"",
            "        path = ds_util.DatastorePath(ds_name, folder)",
            "        dc_info = self.get_datacenter_ref_and_name(ds_ref)",
            "        try:",
            "            ds_util.mkdir(self._session, path, dc_info.ref)",
            "            LOG.debug(\"Folder %s created.\", path)",
            "        except vexc.FileAlreadyExistsException:",
            "            # NOTE(hartsocks): if the folder already exists, that",
            "            # just means the folder was prepped by another process.",
            "            pass",
            "",
            "    def check_cache_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the cache folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._base_folder)",
            "",
            "    def check_temp_folder(self, ds_name, ds_ref):",
            "        \"\"\"Check that the temp folder exists.\"\"\"",
            "        self._create_folder_if_missing(ds_name, ds_ref, self._tmp_folder)",
            "",
            "    def _check_if_folder_file_exists(self, ds_browser, ds_ref, ds_name,",
            "                                     folder_name, file_name):",
            "        # Ensure that the cache folder exists",
            "        self.check_cache_folder(ds_name, ds_ref)",
            "        # Check if the file exists or not.",
            "        folder_ds_path = ds_util.DatastorePath(ds_name, folder_name)",
            "        return ds_util.file_exists(",
            "                self._session, ds_browser, folder_ds_path, file_name)",
            "",
            "    def inject_network_info(self, instance, network_info):",
            "        \"\"\"inject network info for specified instance.\"\"\"",
            "        # Set the machine.id parameter of the instance to inject",
            "        # the NIC configuration inside the VM",
            "        client_factory = self._session._get_vim().client.factory",
            "        self._set_machine_id(client_factory, instance, network_info)",
            "",
            "    def manage_image_cache(self, context, instances):",
            "        if not CONF.remove_unused_base_images:",
            "            LOG.debug(\"Image aging disabled. Aging will not be done.\")",
            "            return",
            "",
            "        datastores = ds_util.get_available_datastores(self._session,",
            "                                                      self._cluster,",
            "                                                      self._datastore_regex)",
            "        datastores_info = []",
            "        for ds in datastores:",
            "            dc_info = self.get_datacenter_ref_and_name(ds.ref)",
            "            datastores_info.append((ds, dc_info))",
            "        self._imagecache.update(context, instances, datastores_info)",
            "",
            "    def _get_valid_vms_from_retrieve_result(self, retrieve_result):",
            "        \"\"\"Returns list of valid vms from RetrieveResult object.\"\"\"",
            "        lst_vm_names = []",
            "",
            "        while retrieve_result:",
            "            token = vm_util._get_token(retrieve_result)",
            "            for vm in retrieve_result.objects:",
            "                vm_name = None",
            "                conn_state = None",
            "                for prop in vm.propSet:",
            "                    if prop.name == \"name\":",
            "                        vm_name = prop.val",
            "                    elif prop.name == \"runtime.connectionState\":",
            "                        conn_state = prop.val",
            "                # Ignoring the orphaned or inaccessible VMs",
            "                if conn_state not in [\"orphaned\", \"inaccessible\"]:",
            "                    lst_vm_names.append(vm_name)",
            "            if token:",
            "                retrieve_result = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "        return lst_vm_names",
            "",
            "    def instance_exists(self, instance):",
            "        try:",
            "            vm_util.get_vm_ref(self._session, instance)",
            "            return True",
            "        except exception.InstanceNotFound:",
            "            return False",
            "",
            "    def attach_interface(self, instance, image_meta, vif):",
            "        \"\"\"Attach an interface to the instance.\"\"\"",
            "        vif_model = image_meta.get(\"hw_vif_model\",",
            "                                   constants.DEFAULT_VIF_MODEL)",
            "        vif_model = vm_util.convert_vif_model(vif_model)",
            "        vif_info = vmwarevif.get_vif_dict(self._session, self._cluster,",
            "                                          vif_model, utils.is_neutron(), vif)",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Ensure that there is not a race with the port index management",
            "        with lockutils.lock(instance.uuid,",
            "                            lock_file_prefix='nova-vmware-hot-plug'):",
            "            port_index = vm_util.get_attach_port_index(self._session, vm_ref)",
            "            client_factory = self._session._get_vim().client.factory",
            "            attach_config_spec = vm_util.get_network_attach_config_spec(",
            "                                        client_factory, vif_info, port_index)",
            "            LOG.debug(\"Reconfiguring VM to attach interface\",",
            "                      instance=instance)",
            "            try:",
            "                vm_util.reconfigure_vm(self._session, vm_ref,",
            "                                       attach_config_spec)",
            "            except Exception as e:",
            "                LOG.error(_LE('Attaching network adapter failed. Exception: '",
            "                              ' %s'),",
            "                          e, instance=instance)",
            "                raise exception.InterfaceAttachFailed(",
            "                        instance_uuid=instance['uuid'])",
            "        LOG.debug(\"Reconfigured VM to attach interface\", instance=instance)",
            "",
            "    def detach_interface(self, instance, vif):",
            "        \"\"\"Detach an interface from the instance.\"\"\"",
            "        vm_ref = vm_util.get_vm_ref(self._session, instance)",
            "        # Ensure that there is not a race with the port index management",
            "        with lockutils.lock(instance.uuid,",
            "                            lock_file_prefix='nova-vmware-hot-plug'):",
            "            port_index = vm_util.get_vm_detach_port_index(self._session,",
            "                                                          vm_ref,",
            "                                                          vif['id'])",
            "            if port_index is None:",
            "                msg = _(\"No device with interface-id %s exists on \"",
            "                        \"VM\") % vif['id']",
            "                raise exception.NotFound(msg)",
            "",
            "            hardware_devices = self._session._call_method(vim_util,",
            "                            \"get_dynamic_property\", vm_ref,",
            "                            \"VirtualMachine\", \"config.hardware.device\")",
            "            device = vmwarevif.get_network_device(hardware_devices,",
            "                                                  vif['address'])",
            "            if device is None:",
            "                msg = _(\"No device with MAC address %s exists on the \"",
            "                        \"VM\") % vif['address']",
            "                raise exception.NotFound(msg)",
            "",
            "            client_factory = self._session._get_vim().client.factory",
            "            detach_config_spec = vm_util.get_network_detach_config_spec(",
            "                                        client_factory, device, port_index)",
            "            LOG.debug(\"Reconfiguring VM to detach interface\",",
            "                      instance=instance)",
            "            try:",
            "                vm_util.reconfigure_vm(self._session, vm_ref,",
            "                                       detach_config_spec)",
            "            except Exception as e:",
            "                LOG.error(_LE('Detaching network adapter failed. Exception: '",
            "                              '%s'),",
            "                          e, instance=instance)",
            "                raise exception.InterfaceDetachFailed(",
            "                        instance_uuid=instance['uuid'])",
            "        LOG.debug(\"Reconfigured VM to detach interface\", instance=instance)",
            "",
            "    def _use_disk_image_as_full_clone(self, vm_ref, vi):",
            "        \"\"\"Uses cached image disk by copying it into the VM directory.\"\"\"",
            "",
            "        instance_folder = vi.instance_name",
            "        root_disk_name = \"%s.vmdk\" % vi.instance_name",
            "        root_disk_ds_loc = vi.datastore.build_path(instance_folder,",
            "                                                   root_disk_name)",
            "",
            "        vm_util.copy_virtual_disk(",
            "                self._session,",
            "                vi.dc_info.ref,",
            "                str(vi.cache_image_path),",
            "                str(root_disk_ds_loc))",
            "",
            "        self._extend_if_required(",
            "                vi.dc_info, vi.ii, vi.instance, str(root_disk_ds_loc))",
            "",
            "        self._volumeops.attach_disk_to_vm(",
            "                vm_ref, vi.instance,",
            "                vi.ii.adapter_type, vi.ii.disk_type,",
            "                str(root_disk_ds_loc),",
            "                vi.root_gb * units.Mi, False)",
            "",
            "    def _sized_image_exists(self, sized_disk_ds_loc, ds_ref):",
            "        ds_browser = self._get_ds_browser(ds_ref)",
            "        return ds_util.file_exists(",
            "                self._session, ds_browser, sized_disk_ds_loc.parent,",
            "                sized_disk_ds_loc.basename)",
            "",
            "    def _use_disk_image_as_linked_clone(self, vm_ref, vi):",
            "        \"\"\"Uses cached image as parent of a COW child in the VM directory.\"\"\"",
            "",
            "        sized_image_disk_name = \"%s.vmdk\" % vi.ii.image_id",
            "        if vi.root_gb > 0:",
            "            sized_image_disk_name = \"%s.%s.vmdk\" % (vi.ii.image_id, vi.root_gb)",
            "        sized_disk_ds_loc = vi.cache_image_folder.join(sized_image_disk_name)",
            "",
            "        # Ensure only a single thread extends the image at once.",
            "        # We do this by taking a lock on the name of the extended",
            "        # image. This allows multiple threads to create resized",
            "        # copies simultaneously, as long as they are different",
            "        # sizes. Threads attempting to create the same resized copy",
            "        # will be serialized, with only the first actually creating",
            "        # the copy.",
            "        #",
            "        # Note that the object is in a per-nova cache directory,",
            "        # so inter-nova locking is not a concern. Consequently we",
            "        # can safely use simple thread locks.",
            "",
            "        with lockutils.lock(str(sized_disk_ds_loc),",
            "                            lock_file_prefix='nova-vmware-image'):",
            "",
            "            if not self._sized_image_exists(sized_disk_ds_loc,",
            "                                            vi.datastore.ref):",
            "                LOG.debug(\"Copying root disk of size %sGb\", vi.root_gb)",
            "                try:",
            "                    vm_util.copy_virtual_disk(",
            "                            self._session,",
            "                            vi.dc_info.ref,",
            "                            str(vi.cache_image_path),",
            "                            str(sized_disk_ds_loc))",
            "                except Exception as e:",
            "                    LOG.warning(_(\"Root disk file creation \"",
            "                                  \"failed - %s\"), e)",
            "                    with excutils.save_and_reraise_exception():",
            "                        LOG.error(_LE('Failed to copy cached '",
            "                                      'image %(source)s to '",
            "                                      '%(dest)s for resize: '",
            "                                      '%(error)s'),",
            "                                  {'source': vi.cache_image_path,",
            "                                   'dest': sized_disk_ds_loc,",
            "                                   'error': e.message})",
            "                        try:",
            "                            ds_util.file_delete(self._session,",
            "                                                sized_disk_ds_loc,",
            "                                                vi.dc_info.ref)",
            "                        except vexc.FileNotFoundException:",
            "                            # File was never created: cleanup not",
            "                            # required",
            "                            pass",
            "",
            "                # Resize the copy to the appropriate size. No need",
            "                # for cleanup up here, as _extend_virtual_disk",
            "                # already does it",
            "                self._extend_if_required(",
            "                        vi.dc_info, vi.ii, vi.instance, str(sized_disk_ds_loc))",
            "",
            "        # Associate the sized image disk to the VM by attaching to the VM a",
            "        # COW child of said disk.",
            "        self._volumeops.attach_disk_to_vm(",
            "                vm_ref, vi.instance,",
            "                vi.ii.adapter_type, vi.ii.disk_type,",
            "                str(sized_disk_ds_loc),",
            "                vi.root_gb * units.Mi, vi.ii.linked_clone)",
            "",
            "    def _use_iso_image(self, vm_ref, vi):",
            "        \"\"\"Uses cached image as a bootable virtual cdrom.\"\"\"",
            "",
            "        self._attach_cdrom_to_vm(",
            "                vm_ref, vi.instance, vi.datastore.ref,",
            "                str(vi.cache_image_path))",
            "",
            "        # Optionally create and attach blank disk",
            "        if vi.root_gb > 0:",
            "            instance_folder = vi.instance_name",
            "            root_disk_name = \"%s.vmdk\" % vi.instance_name",
            "            root_disk_ds_loc = vi.datastore.build_path(instance_folder,",
            "                                                       root_disk_name)",
            "",
            "            # It is pointless to COW a blank disk",
            "            linked_clone = False",
            "",
            "            vm_util.create_virtual_disk(",
            "                    self._session, vi.dc_info.ref,",
            "                    vi.ii.adapter_type,",
            "                    vi.ii.disk_type,",
            "                    str(root_disk_ds_loc),",
            "                    vi.root_gb * units.Mi)",
            "",
            "            self._volumeops.attach_disk_to_vm(",
            "                    vm_ref, vi.instance,",
            "                    vi.ii.adapter_type, vi.ii.disk_type,",
            "                    str(root_disk_ds_loc),",
            "                    vi.root_gb * units.Mi, linked_clone)",
            "",
            "    def _update_datacenter_cache_from_objects(self, dcs):",
            "        \"\"\"Updates the datastore/datacenter cache.\"\"\"",
            "",
            "        while dcs:",
            "            token = vm_util._get_token(dcs)",
            "            for dco in dcs.objects:",
            "                dc_ref = dco.obj",
            "                ds_refs = []",
            "                prop_dict = vm_util.propset_dict(dco.propSet)",
            "                name = prop_dict.get('name')",
            "                vmFolder = prop_dict.get('vmFolder')",
            "                datastore_refs = prop_dict.get('datastore')",
            "                if datastore_refs:",
            "                    datastore_refs = datastore_refs.ManagedObjectReference",
            "                    for ds in datastore_refs:",
            "                        ds_refs.append(ds.value)",
            "                else:",
            "                    LOG.debug(\"Datacenter %s doesn't have any datastore \"",
            "                              \"associated with it, ignoring it\", name)",
            "                for ds_ref in ds_refs:",
            "                    self._datastore_dc_mapping[ds_ref] = DcInfo(ref=dc_ref,",
            "                            name=name, vmFolder=vmFolder)",
            "",
            "            if token:",
            "                dcs = self._session._call_method(vim_util,",
            "                                                 \"continue_to_get_objects\",",
            "                                                 token)",
            "            else:",
            "                break",
            "",
            "    def get_datacenter_ref_and_name(self, ds_ref):",
            "        \"\"\"Get the datacenter name and the reference.\"\"\"",
            "        dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        if not dc_info:",
            "            dcs = self._session._call_method(vim_util, \"get_objects\",",
            "                    \"Datacenter\", [\"name\", \"datastore\", \"vmFolder\"])",
            "            self._update_datacenter_cache_from_objects(dcs)",
            "            dc_info = self._datastore_dc_mapping.get(ds_ref.value)",
            "        return dc_info",
            "",
            "    def list_instances(self):",
            "        \"\"\"Lists the VM instances that are registered with vCenter cluster.\"\"\"",
            "        properties = ['name', 'runtime.connectionState']",
            "        LOG.debug(\"Getting list of instances from cluster %s\",",
            "                  self._cluster)",
            "        vms = []",
            "        root_res_pool = self._session._call_method(",
            "            vim_util, \"get_dynamic_property\", self._cluster,",
            "            'ClusterComputeResource', 'resourcePool')",
            "        if root_res_pool:",
            "            vms = self._session._call_method(",
            "                vim_util, 'get_inner_objects', root_res_pool, 'vm',",
            "                'VirtualMachine', properties)",
            "        lst_vm_names = self._get_valid_vms_from_retrieve_result(vms)",
            "",
            "        LOG.debug(\"Got total of %s instances\", str(len(lst_vm_names)))",
            "        return lst_vm_names",
            "",
            "    def get_vnc_console(self, instance):",
            "        \"\"\"Return connection info for a vnc console using vCenter logic.\"\"\"",
            "",
            "        # vCenter does not run virtual machines and does not run",
            "        # a VNC proxy. Instead, you need to tell OpenStack to talk",
            "        # directly to the ESX host running the VM you are attempting",
            "        # to connect to via VNC.",
            "",
            "        vnc_console = self._get_vnc_console_connection(instance)",
            "        host_name = vm_util.get_host_name_for_vm(",
            "                        self._session,",
            "                        instance)",
            "        vnc_console['host'] = host_name",
            "",
            "        # NOTE: VM can move hosts in some situations. Debug for admins.",
            "        LOG.debug(\"VM %(uuid)s is currently on host %(host_name)s\",",
            "                  {'uuid': instance.name, 'host_name': host_name},",
            "                  instance=instance)",
            "        return ctype.ConsoleVNC(**vnc_console)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "python.paddle.tensor.linalg"
        ]
    }
}