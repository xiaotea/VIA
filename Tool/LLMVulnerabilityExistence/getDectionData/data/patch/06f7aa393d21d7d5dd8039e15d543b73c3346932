{
    "pylib/anki/latex.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import html"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import re"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from dataclasses import dataclass"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import anki"
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import anki.collection"
            },
            "8": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from anki import card_rendering_pb2, hooks"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+from anki.config import Config"
            },
            "10": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from anki.models import NotetypeDict"
            },
            "11": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from anki.template import TemplateRenderContext, TemplateRenderOutput"
            },
            "12": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from anki.utils import call, is_mac, namedtmp, tmpdir"
            },
            "13": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     [\"dvisvgm\", \"--no-fonts\", \"--exact\", \"-Z\", \"2\", \"tmp.dvi\", \"-o\", \"tmp.svg\"],"
            },
            "14": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " ]"
            },
            "15": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# if off, use existing media but don't create new"
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-build = True  # pylint: disable=invalid-name"
            },
            "18": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "19": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " # add standard tex install location to osx"
            },
            "20": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " if is_mac:"
            },
            "21": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     os.environ[\"PATH\"] += \":/usr/texbin:/Library/TeX/texbin\""
            },
            "22": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "     out = ExtractedLatexOutput.from_proto(proto)"
            },
            "23": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     errors = []"
            },
            "24": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     html = out.html"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    render_latex = col.get_config_bool(Config.Bool.RENDER_LATEX)"
            },
            "26": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "     for latex in out.latex:"
            },
            "28": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         # don't need to render?"
            },
            "29": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not build or col.media.have(latex.filename):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        if col.media.have(latex.filename):"
            },
            "31": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             continue"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        if not render_latex:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            errors.append(col.tr.preferences_latex_generation_disabled())"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+            return html, errors"
            },
            "35": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         err = _save_latex_image(col, latex, header, footer, svg)"
            },
            "37": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         if err is not None:"
            },
            "38": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " ) -> str | None:"
            },
            "39": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     # add header/footer"
            },
            "40": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     latex = f\"{header}\\n{extracted.latex_body}\\n{footer}\""
            },
            "41": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # it's only really secure if run in a jail, but these are the most common"
            },
            "42": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    tmplatex = latex.replace(\"\\\\includegraphics\", \"\")"
            },
            "43": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for bad in ("
            },
            "44": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\write18\","
            },
            "45": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\readline\","
            },
            "46": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\input\","
            },
            "47": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\include\","
            },
            "48": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\catcode\","
            },
            "49": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\openout\","
            },
            "50": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\write\","
            },
            "51": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\loop\","
            },
            "52": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\def\","
            },
            "53": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\\\\shipout\","
            },
            "54": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ):"
            },
            "55": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # don't mind if the sequence is only part of a command"
            },
            "56": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        bad_re = f\"\\\\{bad}[^a-zA-Z]\""
            },
            "57": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if re.search(bad_re, tmplatex):"
            },
            "58": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return col.tr.media_for_security_reasons_is_not(val=bad)"
            },
            "59": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     # commands to use"
            },
            "61": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "     if svg:"
            }
        },
        "frontPatchFile": [
            "# Copyright: Ankitects Pty Ltd and contributors",
            "# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html",
            "",
            "from __future__ import annotations",
            "",
            "import html",
            "import os",
            "import re",
            "from dataclasses import dataclass",
            "",
            "import anki",
            "import anki.collection",
            "from anki import card_rendering_pb2, hooks",
            "from anki.models import NotetypeDict",
            "from anki.template import TemplateRenderContext, TemplateRenderOutput",
            "from anki.utils import call, is_mac, namedtmp, tmpdir",
            "",
            "pngCommands = [",
            "    [\"latex\", \"-interaction=nonstopmode\", \"tmp.tex\"],",
            "    [",
            "        \"dvipng\",",
            "        \"-bg\",",
            "        \"Transparent\",",
            "        \"-D\",",
            "        \"200\",",
            "        \"-T\",",
            "        \"tight\",",
            "        \"tmp.dvi\",",
            "        \"-o\",",
            "        \"tmp.png\",",
            "    ],",
            "]",
            "",
            "svgCommands = [",
            "    [\"latex\", \"-interaction=nonstopmode\", \"tmp.tex\"],",
            "    [\"dvisvgm\", \"--no-fonts\", \"--exact\", \"-Z\", \"2\", \"tmp.dvi\", \"-o\", \"tmp.svg\"],",
            "]",
            "",
            "# if off, use existing media but don't create new",
            "build = True  # pylint: disable=invalid-name",
            "",
            "# add standard tex install location to osx",
            "if is_mac:",
            "    os.environ[\"PATH\"] += \":/usr/texbin:/Library/TeX/texbin\"",
            "",
            "",
            "@dataclass",
            "class ExtractedLatex:",
            "    filename: str",
            "    latex_body: str",
            "",
            "",
            "@dataclass",
            "class ExtractedLatexOutput:",
            "    html: str",
            "    latex: list[ExtractedLatex]",
            "",
            "    @staticmethod",
            "    def from_proto(",
            "        proto: card_rendering_pb2.ExtractLatexResponse,",
            "    ) -> ExtractedLatexOutput:",
            "        return ExtractedLatexOutput(",
            "            html=proto.text,",
            "            latex=[",
            "                ExtractedLatex(filename=l.filename, latex_body=l.latex_body)",
            "                for l in proto.latex",
            "            ],",
            "        )",
            "",
            "",
            "def on_card_did_render(",
            "    output: TemplateRenderOutput, ctx: TemplateRenderContext",
            ") -> None:",
            "    output.question_text = render_latex(",
            "        output.question_text, ctx.note_type(), ctx.col()",
            "    )",
            "    output.answer_text = render_latex(output.answer_text, ctx.note_type(), ctx.col())",
            "",
            "",
            "def render_latex(",
            "    html: str, model: NotetypeDict, col: anki.collection.Collection",
            ") -> str:",
            "    \"Convert embedded latex tags in text to image links.\"",
            "    html, err = render_latex_returning_errors(html, model, col)",
            "    if err:",
            "        html += \"\\n\".join(err)",
            "    return html",
            "",
            "",
            "def render_latex_returning_errors(",
            "    html: str,",
            "    model: NotetypeDict,",
            "    col: anki.collection.Collection,",
            "    expand_clozes: bool = False,",
            ") -> tuple[str, list[str]]:",
            "    \"\"\"Returns (text, errors).",
            "",
            "    errors will be non-empty if LaTeX failed to render.\"\"\"",
            "    svg = model.get(\"latexsvg\", False)",
            "    header = model[\"latexPre\"]",
            "    footer = model[\"latexPost\"]",
            "",
            "    proto = col._backend.extract_latex(text=html, svg=svg, expand_clozes=expand_clozes)",
            "    out = ExtractedLatexOutput.from_proto(proto)",
            "    errors = []",
            "    html = out.html",
            "",
            "    for latex in out.latex:",
            "        # don't need to render?",
            "        if not build or col.media.have(latex.filename):",
            "            continue",
            "",
            "        err = _save_latex_image(col, latex, header, footer, svg)",
            "        if err is not None:",
            "            errors.append(err)",
            "",
            "    return html, errors",
            "",
            "",
            "def _save_latex_image(",
            "    col: anki.collection.Collection,",
            "    extracted: ExtractedLatex,",
            "    header: str,",
            "    footer: str,",
            "    svg: bool,",
            ") -> str | None:",
            "    # add header/footer",
            "    latex = f\"{header}\\n{extracted.latex_body}\\n{footer}\"",
            "    # it's only really secure if run in a jail, but these are the most common",
            "    tmplatex = latex.replace(\"\\\\includegraphics\", \"\")",
            "    for bad in (",
            "        \"\\\\write18\",",
            "        \"\\\\readline\",",
            "        \"\\\\input\",",
            "        \"\\\\include\",",
            "        \"\\\\catcode\",",
            "        \"\\\\openout\",",
            "        \"\\\\write\",",
            "        \"\\\\loop\",",
            "        \"\\\\def\",",
            "        \"\\\\shipout\",",
            "    ):",
            "        # don't mind if the sequence is only part of a command",
            "        bad_re = f\"\\\\{bad}[^a-zA-Z]\"",
            "        if re.search(bad_re, tmplatex):",
            "            return col.tr.media_for_security_reasons_is_not(val=bad)",
            "",
            "    # commands to use",
            "    if svg:",
            "        latex_cmds = svgCommands",
            "        ext = \"svg\"",
            "    else:",
            "        latex_cmds = pngCommands",
            "        ext = \"png\"",
            "",
            "    # write into a temp file",
            "    log = open(namedtmp(\"latex_log.txt\"), \"w\", encoding=\"utf8\")",
            "    texpath = namedtmp(\"tmp.tex\")",
            "    texfile = open(texpath, \"w\", encoding=\"utf8\")",
            "    texfile.write(latex)",
            "    texfile.close()",
            "    oldcwd = os.getcwd()",
            "    png_or_svg = namedtmp(f\"tmp.{ext}\")",
            "    try:",
            "        # generate png/svg",
            "        os.chdir(tmpdir())",
            "        for latex_cmd in latex_cmds:",
            "            if call(latex_cmd, stdout=log, stderr=log):",
            "                return _err_msg(col, latex_cmd[0], texpath)",
            "        # add to media",
            "        with open(png_or_svg, \"rb\") as file:",
            "            data = file.read()",
            "        col.media.write_data(extracted.filename, data)",
            "        os.unlink(png_or_svg)",
            "        return None",
            "    finally:",
            "        os.chdir(oldcwd)",
            "        log.close()",
            "",
            "",
            "def _err_msg(col: anki.collection.Collection, type: str, texpath: str) -> str:",
            "    msg = f\"{col.tr.media_error_executing(val=type)}<br>\"",
            "    msg += f\"{col.tr.media_generated_file(val=texpath)}<br>\"",
            "    try:",
            "        with open(namedtmp(\"latex_log.txt\", remove=False), encoding=\"utf8\") as file:",
            "            log = file.read()",
            "        if not log:",
            "            raise Exception()",
            "        msg += f\"<small><pre>{html.escape(log)}</pre></small>\"",
            "    except:",
            "        msg += col.tr.media_have_you_installed_latex_and_dvipngdvisvgm()",
            "    return msg",
            "",
            "",
            "def setup_hook() -> None:",
            "    hooks.card_did_render.append(on_card_did_render)"
        ],
        "afterPatchFile": [
            "# Copyright: Ankitects Pty Ltd and contributors",
            "# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html",
            "",
            "from __future__ import annotations",
            "",
            "import html",
            "import os",
            "from dataclasses import dataclass",
            "",
            "import anki",
            "import anki.collection",
            "from anki import card_rendering_pb2, hooks",
            "from anki.config import Config",
            "from anki.models import NotetypeDict",
            "from anki.template import TemplateRenderContext, TemplateRenderOutput",
            "from anki.utils import call, is_mac, namedtmp, tmpdir",
            "",
            "pngCommands = [",
            "    [\"latex\", \"-interaction=nonstopmode\", \"tmp.tex\"],",
            "    [",
            "        \"dvipng\",",
            "        \"-bg\",",
            "        \"Transparent\",",
            "        \"-D\",",
            "        \"200\",",
            "        \"-T\",",
            "        \"tight\",",
            "        \"tmp.dvi\",",
            "        \"-o\",",
            "        \"tmp.png\",",
            "    ],",
            "]",
            "",
            "svgCommands = [",
            "    [\"latex\", \"-interaction=nonstopmode\", \"tmp.tex\"],",
            "    [\"dvisvgm\", \"--no-fonts\", \"--exact\", \"-Z\", \"2\", \"tmp.dvi\", \"-o\", \"tmp.svg\"],",
            "]",
            "",
            "# add standard tex install location to osx",
            "if is_mac:",
            "    os.environ[\"PATH\"] += \":/usr/texbin:/Library/TeX/texbin\"",
            "",
            "",
            "@dataclass",
            "class ExtractedLatex:",
            "    filename: str",
            "    latex_body: str",
            "",
            "",
            "@dataclass",
            "class ExtractedLatexOutput:",
            "    html: str",
            "    latex: list[ExtractedLatex]",
            "",
            "    @staticmethod",
            "    def from_proto(",
            "        proto: card_rendering_pb2.ExtractLatexResponse,",
            "    ) -> ExtractedLatexOutput:",
            "        return ExtractedLatexOutput(",
            "            html=proto.text,",
            "            latex=[",
            "                ExtractedLatex(filename=l.filename, latex_body=l.latex_body)",
            "                for l in proto.latex",
            "            ],",
            "        )",
            "",
            "",
            "def on_card_did_render(",
            "    output: TemplateRenderOutput, ctx: TemplateRenderContext",
            ") -> None:",
            "    output.question_text = render_latex(",
            "        output.question_text, ctx.note_type(), ctx.col()",
            "    )",
            "    output.answer_text = render_latex(output.answer_text, ctx.note_type(), ctx.col())",
            "",
            "",
            "def render_latex(",
            "    html: str, model: NotetypeDict, col: anki.collection.Collection",
            ") -> str:",
            "    \"Convert embedded latex tags in text to image links.\"",
            "    html, err = render_latex_returning_errors(html, model, col)",
            "    if err:",
            "        html += \"\\n\".join(err)",
            "    return html",
            "",
            "",
            "def render_latex_returning_errors(",
            "    html: str,",
            "    model: NotetypeDict,",
            "    col: anki.collection.Collection,",
            "    expand_clozes: bool = False,",
            ") -> tuple[str, list[str]]:",
            "    \"\"\"Returns (text, errors).",
            "",
            "    errors will be non-empty if LaTeX failed to render.\"\"\"",
            "    svg = model.get(\"latexsvg\", False)",
            "    header = model[\"latexPre\"]",
            "    footer = model[\"latexPost\"]",
            "",
            "    proto = col._backend.extract_latex(text=html, svg=svg, expand_clozes=expand_clozes)",
            "    out = ExtractedLatexOutput.from_proto(proto)",
            "    errors = []",
            "    html = out.html",
            "    render_latex = col.get_config_bool(Config.Bool.RENDER_LATEX)",
            "",
            "    for latex in out.latex:",
            "        # don't need to render?",
            "        if col.media.have(latex.filename):",
            "            continue",
            "        if not render_latex:",
            "            errors.append(col.tr.preferences_latex_generation_disabled())",
            "            return html, errors",
            "",
            "        err = _save_latex_image(col, latex, header, footer, svg)",
            "        if err is not None:",
            "            errors.append(err)",
            "",
            "    return html, errors",
            "",
            "",
            "def _save_latex_image(",
            "    col: anki.collection.Collection,",
            "    extracted: ExtractedLatex,",
            "    header: str,",
            "    footer: str,",
            "    svg: bool,",
            ") -> str | None:",
            "    # add header/footer",
            "    latex = f\"{header}\\n{extracted.latex_body}\\n{footer}\"",
            "",
            "    # commands to use",
            "    if svg:",
            "        latex_cmds = svgCommands",
            "        ext = \"svg\"",
            "    else:",
            "        latex_cmds = pngCommands",
            "        ext = \"png\"",
            "",
            "    # write into a temp file",
            "    log = open(namedtmp(\"latex_log.txt\"), \"w\", encoding=\"utf8\")",
            "    texpath = namedtmp(\"tmp.tex\")",
            "    texfile = open(texpath, \"w\", encoding=\"utf8\")",
            "    texfile.write(latex)",
            "    texfile.close()",
            "    oldcwd = os.getcwd()",
            "    png_or_svg = namedtmp(f\"tmp.{ext}\")",
            "    try:",
            "        # generate png/svg",
            "        os.chdir(tmpdir())",
            "        for latex_cmd in latex_cmds:",
            "            if call(latex_cmd, stdout=log, stderr=log):",
            "                return _err_msg(col, latex_cmd[0], texpath)",
            "        # add to media",
            "        with open(png_or_svg, \"rb\") as file:",
            "            data = file.read()",
            "        col.media.write_data(extracted.filename, data)",
            "        os.unlink(png_or_svg)",
            "        return None",
            "    finally:",
            "        os.chdir(oldcwd)",
            "        log.close()",
            "",
            "",
            "def _err_msg(col: anki.collection.Collection, type: str, texpath: str) -> str:",
            "    msg = f\"{col.tr.media_error_executing(val=type)}<br>\"",
            "    msg += f\"{col.tr.media_generated_file(val=texpath)}<br>\"",
            "    try:",
            "        with open(namedtmp(\"latex_log.txt\", remove=False), encoding=\"utf8\") as file:",
            "            log = file.read()",
            "        if not log:",
            "            raise Exception()",
            "        msg += f\"<small><pre>{html.escape(log)}</pre></small>\"",
            "    except:",
            "        msg += col.tr.media_have_you_installed_latex_and_dvipngdvisvgm()",
            "    return msg",
            "",
            "",
            "def setup_hook() -> None:",
            "    hooks.card_did_render.append(on_card_did_render)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": [],
            "39": [],
            "40": [
                "build"
            ],
            "41": [],
            "110": [
                "render_latex_returning_errors"
            ],
            "129": [
                "_save_latex_image"
            ],
            "130": [
                "_save_latex_image"
            ],
            "131": [
                "_save_latex_image"
            ],
            "132": [
                "_save_latex_image"
            ],
            "133": [
                "_save_latex_image"
            ],
            "134": [
                "_save_latex_image"
            ],
            "135": [
                "_save_latex_image"
            ],
            "136": [
                "_save_latex_image"
            ],
            "137": [
                "_save_latex_image"
            ],
            "138": [
                "_save_latex_image"
            ],
            "139": [
                "_save_latex_image"
            ],
            "140": [
                "_save_latex_image"
            ],
            "141": [
                "_save_latex_image"
            ],
            "142": [
                "_save_latex_image"
            ],
            "143": [
                "_save_latex_image"
            ],
            "144": [
                "_save_latex_image"
            ],
            "145": [
                "_save_latex_image"
            ],
            "146": [
                "_save_latex_image"
            ]
        },
        "addLocation": []
    },
    "pylib/tests/test_latex.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import os"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import shutil"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from anki.config import Config"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from anki.lang import without_unicode_isolation"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from tests.shared import getEmptyCol"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " def test_latex():"
            },
            "9": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     col = getEmptyCol()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    col.set_config_bool(Config.Bool.RENDER_LATEX, True)"
            },
            "11": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     # change latex cmd to simulate broken build"
            },
            "12": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     import anki.latex"
            },
            "13": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     assert \".png\" in oldcard.question()"
            },
            "15": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     # if we turn off building, then previous cards should work, but cards with"
            },
            "16": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     # missing media will show a broken image"
            },
            "17": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    anki.latex.build = False"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    col.set_config_bool(Config.Bool.RENDER_LATEX, False)"
            },
            "19": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     note = col.newNote()"
            },
            "20": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     note[\"Front\"] = \"[latex]foo[/latex]\""
            },
            "21": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     col.addNote(note)"
            },
            "22": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     assert len(os.listdir(col.media.dir())) == 2"
            },
            "23": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     assert \".png\" in oldcard.question()"
            },
            "24": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # turn it on again so other test don't suffer"
            },
            "25": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    anki.latex.build = True"
            },
            "26": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "27": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # bad commands"
            },
            "28": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\write18\")"
            },
            "29": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "30": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\readline\")"
            },
            "31": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "32": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\input\")"
            },
            "33": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "34": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\include\")"
            },
            "35": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "36": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\catcode\")"
            },
            "37": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "38": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\openout\")"
            },
            "39": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "40": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\write\")"
            },
            "41": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "42": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\loop\")"
            },
            "43": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "44": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\def\")"
            },
            "45": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "46": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\shipout\")"
            },
            "47": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert result, msg"
            },
            "48": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "49": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # inserting commands beginning with a bad name should not raise an error"
            },
            "50": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\defeq\")"
            },
            "51": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert not result, msg"
            },
            "52": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # normal commands should not either"
            },
            "53": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (result, msg) = _test_includes_bad_command(\"\\\\emph\")"
            },
            "54": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert not result, msg"
            },
            "55": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "56": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "57": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def _test_includes_bad_command(bad):"
            },
            "58": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    col = getEmptyCol()"
            },
            "59": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    note = col.newNote()"
            },
            "60": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    note[\"Front\"] = f\"[latex]{bad}[/latex]\""
            },
            "61": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    col.addNote(note)"
            },
            "62": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    q = without_unicode_isolation(note.cards()[0].question())"
            },
            "63": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return (f\"'{bad}' is not allowed on cards\" in q, f\"Card content: {q}\")"
            }
        },
        "frontPatchFile": [
            "# Copyright: Ankitects Pty Ltd and contributors",
            "# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html",
            "",
            "# coding: utf-8",
            "",
            "import os",
            "import shutil",
            "",
            "from anki.lang import without_unicode_isolation",
            "from tests.shared import getEmptyCol",
            "",
            "",
            "def test_latex():",
            "    col = getEmptyCol()",
            "    # change latex cmd to simulate broken build",
            "    import anki.latex",
            "",
            "    anki.latex.pngCommands[0][0] = \"nolatex\"",
            "    # add a note with latex",
            "    note = col.newNote()",
            "    note[\"Front\"] = \"[latex]hello[/latex]\"",
            "    col.addNote(note)",
            "    # but since latex couldn't run, there's nothing there",
            "    assert len(os.listdir(col.media.dir())) == 0",
            "    # check the error message",
            "    msg = note.cards()[0].question()",
            "    assert \"executing nolatex\" in without_unicode_isolation(msg)",
            "    assert \"installed\" in msg",
            "    # check if we have latex installed, and abort test if we don't",
            "    if not shutil.which(\"latex\") or not shutil.which(\"dvipng\"):",
            "        print(\"aborting test; latex or dvipng is not installed\")",
            "        return",
            "    # fix path",
            "    anki.latex.pngCommands[0][0] = \"latex\"",
            "    # check media db should cause latex to be generated",
            "    col.media.render_all_latex()",
            "    assert len(os.listdir(col.media.dir())) == 1",
            "    assert \".png\" in note.cards()[0].question()",
            "    # adding new notes should cause generation on question display",
            "    note = col.newNote()",
            "    note[\"Front\"] = \"[latex]world[/latex]\"",
            "    col.addNote(note)",
            "    note.cards()[0].question()",
            "    assert len(os.listdir(col.media.dir())) == 2",
            "    # another note with the same media should reuse",
            "    note = col.newNote()",
            "    note[\"Front\"] = \" [latex]world[/latex]\"",
            "    col.addNote(note)",
            "    assert len(os.listdir(col.media.dir())) == 2",
            "    oldcard = note.cards()[0]",
            "    assert \".png\" in oldcard.question()",
            "    # if we turn off building, then previous cards should work, but cards with",
            "    # missing media will show a broken image",
            "    anki.latex.build = False",
            "    note = col.newNote()",
            "    note[\"Front\"] = \"[latex]foo[/latex]\"",
            "    col.addNote(note)",
            "    assert len(os.listdir(col.media.dir())) == 2",
            "    assert \".png\" in oldcard.question()",
            "    # turn it on again so other test don't suffer",
            "    anki.latex.build = True",
            "",
            "    # bad commands",
            "    (result, msg) = _test_includes_bad_command(\"\\\\write18\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\readline\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\input\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\include\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\catcode\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\openout\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\write\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\loop\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\def\")",
            "    assert result, msg",
            "    (result, msg) = _test_includes_bad_command(\"\\\\shipout\")",
            "    assert result, msg",
            "",
            "    # inserting commands beginning with a bad name should not raise an error",
            "    (result, msg) = _test_includes_bad_command(\"\\\\defeq\")",
            "    assert not result, msg",
            "    # normal commands should not either",
            "    (result, msg) = _test_includes_bad_command(\"\\\\emph\")",
            "    assert not result, msg",
            "",
            "",
            "def _test_includes_bad_command(bad):",
            "    col = getEmptyCol()",
            "    note = col.newNote()",
            "    note[\"Front\"] = f\"[latex]{bad}[/latex]\"",
            "    col.addNote(note)",
            "    q = without_unicode_isolation(note.cards()[0].question())",
            "    return (f\"'{bad}' is not allowed on cards\" in q, f\"Card content: {q}\")"
        ],
        "afterPatchFile": [
            "# Copyright: Ankitects Pty Ltd and contributors",
            "# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html",
            "",
            "# coding: utf-8",
            "",
            "import os",
            "import shutil",
            "",
            "from anki.config import Config",
            "from anki.lang import without_unicode_isolation",
            "from tests.shared import getEmptyCol",
            "",
            "",
            "def test_latex():",
            "    col = getEmptyCol()",
            "    col.set_config_bool(Config.Bool.RENDER_LATEX, True)",
            "    # change latex cmd to simulate broken build",
            "    import anki.latex",
            "",
            "    anki.latex.pngCommands[0][0] = \"nolatex\"",
            "    # add a note with latex",
            "    note = col.newNote()",
            "    note[\"Front\"] = \"[latex]hello[/latex]\"",
            "    col.addNote(note)",
            "    # but since latex couldn't run, there's nothing there",
            "    assert len(os.listdir(col.media.dir())) == 0",
            "    # check the error message",
            "    msg = note.cards()[0].question()",
            "    assert \"executing nolatex\" in without_unicode_isolation(msg)",
            "    assert \"installed\" in msg",
            "    # check if we have latex installed, and abort test if we don't",
            "    if not shutil.which(\"latex\") or not shutil.which(\"dvipng\"):",
            "        print(\"aborting test; latex or dvipng is not installed\")",
            "        return",
            "    # fix path",
            "    anki.latex.pngCommands[0][0] = \"latex\"",
            "    # check media db should cause latex to be generated",
            "    col.media.render_all_latex()",
            "    assert len(os.listdir(col.media.dir())) == 1",
            "    assert \".png\" in note.cards()[0].question()",
            "    # adding new notes should cause generation on question display",
            "    note = col.newNote()",
            "    note[\"Front\"] = \"[latex]world[/latex]\"",
            "    col.addNote(note)",
            "    note.cards()[0].question()",
            "    assert len(os.listdir(col.media.dir())) == 2",
            "    # another note with the same media should reuse",
            "    note = col.newNote()",
            "    note[\"Front\"] = \" [latex]world[/latex]\"",
            "    col.addNote(note)",
            "    assert len(os.listdir(col.media.dir())) == 2",
            "    oldcard = note.cards()[0]",
            "    assert \".png\" in oldcard.question()",
            "    # if we turn off building, then previous cards should work, but cards with",
            "    # missing media will show a broken image",
            "    col.set_config_bool(Config.Bool.RENDER_LATEX, False)",
            "    note = col.newNote()",
            "    note[\"Front\"] = \"[latex]foo[/latex]\"",
            "    col.addNote(note)",
            "    assert len(os.listdir(col.media.dir())) == 2",
            "    assert \".png\" in oldcard.question()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "54": [
                "test_latex"
            ],
            "60": [
                "test_latex"
            ],
            "61": [
                "test_latex"
            ],
            "62": [
                "test_latex"
            ],
            "63": [
                "test_latex"
            ],
            "64": [
                "test_latex"
            ],
            "65": [
                "test_latex"
            ],
            "66": [
                "test_latex"
            ],
            "67": [
                "test_latex"
            ],
            "68": [
                "test_latex"
            ],
            "69": [
                "test_latex"
            ],
            "70": [
                "test_latex"
            ],
            "71": [
                "test_latex"
            ],
            "72": [
                "test_latex"
            ],
            "73": [
                "test_latex"
            ],
            "74": [
                "test_latex"
            ],
            "75": [
                "test_latex"
            ],
            "76": [
                "test_latex"
            ],
            "77": [
                "test_latex"
            ],
            "78": [
                "test_latex"
            ],
            "79": [
                "test_latex"
            ],
            "80": [
                "test_latex"
            ],
            "81": [
                "test_latex"
            ],
            "82": [
                "test_latex"
            ],
            "83": [
                "test_latex"
            ],
            "84": [
                "test_latex"
            ],
            "85": [
                "test_latex"
            ],
            "86": [
                "test_latex"
            ],
            "87": [
                "test_latex"
            ],
            "88": [
                "test_latex"
            ],
            "89": [
                "test_latex"
            ],
            "90": [
                "test_latex"
            ],
            "91": [],
            "92": [],
            "93": [
                "_test_includes_bad_command"
            ],
            "94": [
                "_test_includes_bad_command"
            ],
            "95": [
                "_test_includes_bad_command"
            ],
            "96": [
                "_test_includes_bad_command"
            ],
            "97": [
                "_test_includes_bad_command"
            ],
            "98": [
                "_test_includes_bad_command"
            ],
            "99": [
                "_test_includes_bad_command"
            ]
        },
        "addLocation": [
            "urllib3.util.retry"
        ]
    },
    "qt/aqt/preferences.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         form.paste_strips_formatting.setChecked(editing.paste_strips_formatting)"
            },
            "1": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         form.ignore_accents_in_search.setChecked(editing.ignore_accents_in_search)"
            },
            "2": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         form.pastePNG.setChecked(editing.paste_images_as_png)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        form.render_latex.setChecked(editing.render_latex)"
            },
            "4": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         form.default_search_text.setText(editing.default_search_text)"
            },
            "5": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         form.backup_explanation.setText("
            },
            "7": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         editing.adding_defaults_to_current_deck = not form.useCurrent.currentIndex()"
            },
            "8": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         editing.paste_images_as_png = self.form.pastePNG.isChecked()"
            },
            "9": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         editing.paste_strips_formatting = self.form.paste_strips_formatting.isChecked()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        editing.render_latex = self.form.render_latex.isChecked()"
            },
            "11": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         editing.default_search_text = self.form.default_search_text.text()"
            },
            "12": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         editing.ignore_accents_in_search = ("
            },
            "13": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "             self.form.ignore_accents_in_search.isChecked()"
            }
        },
        "frontPatchFile": [
            "# Copyright: Ankitects Pty Ltd and contributors",
            "# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html",
            "",
            "from __future__ import annotations",
            "",
            "import functools",
            "import re",
            "",
            "import anki.lang",
            "import aqt",
            "import aqt.forms",
            "import aqt.operations",
            "from anki.collection import OpChanges",
            "from aqt import AnkiQt",
            "from aqt.operations.collection import set_preferences",
            "from aqt.profiles import VideoDriver",
            "from aqt.qt import *",
            "from aqt.sync import sync_login",
            "from aqt.theme import Theme",
            "from aqt.utils import (",
            "    HelpPage,",
            "    askUser,",
            "    disable_help_button,",
            "    is_win,",
            "    openHelp,",
            "    showInfo,",
            "    showWarning,",
            "    tr,",
            ")",
            "",
            "",
            "class Preferences(QDialog):",
            "    def __init__(self, mw: AnkiQt) -> None:",
            "        QDialog.__init__(self, mw, Qt.WindowType.Window)",
            "        self.mw = mw",
            "        self.prof = self.mw.pm.profile",
            "        self.form = aqt.forms.preferences.Ui_Preferences()",
            "        self.form.setupUi(self)",
            "        disable_help_button(self)",
            "        self.form.buttonBox.button(QDialogButtonBox.StandardButton.Help).setAutoDefault(",
            "            False",
            "        )",
            "        self.form.buttonBox.button(",
            "            QDialogButtonBox.StandardButton.Close",
            "        ).setAutoDefault(False)",
            "        qconnect(",
            "            self.form.buttonBox.helpRequested, lambda: openHelp(HelpPage.PREFERENCES)",
            "        )",
            "        self.silentlyClose = True",
            "        self.setup_collection()",
            "        self.setup_profile()",
            "        self.setup_global()",
            "        self.setup_configurable_answer_keys()",
            "        self.show()",
            "",
            "    def setup_configurable_answer_keys(self):",
            "        \"\"\"",
            "        Create a group box in Preferences with widgets that let the user edit answer keys.",
            "        \"\"\"",
            "        ease_labels = (",
            "            (1, tr.studying_again()),",
            "            (2, tr.studying_hard()),",
            "            (3, tr.studying_good()),",
            "            (4, tr.studying_easy()),",
            "        )",
            "        group = self.form.preferences_answer_keys",
            "        group.setLayout(layout := QFormLayout())",
            "        for ease, label in ease_labels:",
            "            layout.addRow(",
            "                label,",
            "                line_edit := QLineEdit(self.mw.pm.get_answer_key(ease) or \"\"),",
            "            )",
            "            qconnect(",
            "                line_edit.textChanged,",
            "                functools.partial(self.mw.pm.set_answer_key, ease),",
            "            )",
            "            line_edit.setPlaceholderText(tr.preferences_shortcut_placeholder())",
            "",
            "    def accept(self) -> None:",
            "        self.accept_with_callback()",
            "",
            "    def accept_with_callback(self, callback: Callable[[], None] | None = None) -> None:",
            "        # avoid exception if main window is already closed",
            "        if not self.mw.col:",
            "            return",
            "",
            "        def after_collection_update() -> None:",
            "            self.update_profile()",
            "            self.update_global()",
            "            self.mw.pm.save()",
            "            self.done(0)",
            "            aqt.dialogs.markClosed(\"Preferences\")",
            "",
            "            if callback:",
            "                callback()",
            "",
            "        self.update_collection(after_collection_update)",
            "",
            "    def reject(self) -> None:",
            "        self.accept()",
            "",
            "    # Preferences stored in the collection",
            "    ######################################################################",
            "",
            "    def setup_collection(self) -> None:",
            "        self.prefs = self.mw.col.get_preferences()",
            "",
            "        form = self.form",
            "",
            "        scheduling = self.prefs.scheduling",
            "",
            "        form.lrnCutoff.setValue(int(scheduling.learn_ahead_secs / 60.0))",
            "        form.dayOffset.setValue(scheduling.rollover)",
            "",
            "        reviewing = self.prefs.reviewing",
            "        form.timeLimit.setValue(int(reviewing.time_limit_secs / 60.0))",
            "        form.showEstimates.setChecked(reviewing.show_intervals_on_buttons)",
            "        form.showProgress.setChecked(reviewing.show_remaining_due_counts)",
            "        form.showPlayButtons.setChecked(not reviewing.hide_audio_play_buttons)",
            "        form.interrupt_audio.setChecked(reviewing.interrupt_audio_when_answering)",
            "",
            "        editing = self.prefs.editing",
            "        form.useCurrent.setCurrentIndex(",
            "            0 if editing.adding_defaults_to_current_deck else 1",
            "        )",
            "        form.paste_strips_formatting.setChecked(editing.paste_strips_formatting)",
            "        form.ignore_accents_in_search.setChecked(editing.ignore_accents_in_search)",
            "        form.pastePNG.setChecked(editing.paste_images_as_png)",
            "        form.default_search_text.setText(editing.default_search_text)",
            "",
            "        form.backup_explanation.setText(",
            "            anki.lang.with_collapsed_whitespace(tr.preferences_backup_explanation())",
            "        )",
            "        form.daily_backups.setValue(self.prefs.backups.daily)",
            "        form.weekly_backups.setValue(self.prefs.backups.weekly)",
            "        form.monthly_backups.setValue(self.prefs.backups.monthly)",
            "        form.minutes_between_backups.setValue(self.prefs.backups.minimum_interval_mins)",
            "",
            "    def update_collection(self, on_done: Callable[[], None]) -> None:",
            "        form = self.form",
            "",
            "        scheduling = self.prefs.scheduling",
            "        scheduling.learn_ahead_secs = form.lrnCutoff.value() * 60",
            "        scheduling.rollover = form.dayOffset.value()",
            "",
            "        reviewing = self.prefs.reviewing",
            "        reviewing.show_remaining_due_counts = form.showProgress.isChecked()",
            "        reviewing.show_intervals_on_buttons = form.showEstimates.isChecked()",
            "        reviewing.time_limit_secs = form.timeLimit.value() * 60",
            "        reviewing.hide_audio_play_buttons = not self.form.showPlayButtons.isChecked()",
            "        reviewing.interrupt_audio_when_answering = self.form.interrupt_audio.isChecked()",
            "",
            "        editing = self.prefs.editing",
            "        editing.adding_defaults_to_current_deck = not form.useCurrent.currentIndex()",
            "        editing.paste_images_as_png = self.form.pastePNG.isChecked()",
            "        editing.paste_strips_formatting = self.form.paste_strips_formatting.isChecked()",
            "        editing.default_search_text = self.form.default_search_text.text()",
            "        editing.ignore_accents_in_search = (",
            "            self.form.ignore_accents_in_search.isChecked()",
            "        )",
            "",
            "        self.prefs.backups.daily = form.daily_backups.value()",
            "        self.prefs.backups.weekly = form.weekly_backups.value()",
            "        self.prefs.backups.monthly = form.monthly_backups.value()",
            "        self.prefs.backups.minimum_interval_mins = form.minutes_between_backups.value()",
            "",
            "        def after_prefs_update(changes: OpChanges) -> None:",
            "            self.mw.apply_collection_options()",
            "            on_done()",
            "",
            "        set_preferences(parent=self, preferences=self.prefs).success(",
            "            after_prefs_update",
            "        ).run_in_background()",
            "",
            "    # Preferences stored in the profile",
            "    ######################################################################",
            "",
            "    def setup_profile(self) -> None:",
            "        \"Setup options stored in the user profile.\"",
            "        self.setup_network()",
            "",
            "    def update_profile(self) -> None:",
            "        self.update_network()",
            "",
            "    # Profile: network",
            "    ######################################################################",
            "",
            "    def setup_network(self) -> None:",
            "        self.form.media_log.setText(tr.sync_media_log_button())",
            "        qconnect(self.form.media_log.clicked, self.on_media_log)",
            "        self.form.syncOnProgramOpen.setChecked(self.mw.pm.auto_syncing_enabled())",
            "        self.form.syncMedia.setChecked(self.mw.pm.media_syncing_enabled())",
            "        self.form.autoSyncMedia.setChecked(",
            "            self.mw.pm.periodic_sync_media_minutes() != 0",
            "        )",
            "        self.form.custom_sync_url.setText(self.mw.pm.custom_sync_url())",
            "        self.form.network_timeout.setValue(self.mw.pm.network_timeout())",
            "",
            "        self.update_login_status()",
            "        qconnect(self.form.syncLogout.clicked, self.sync_logout)",
            "        qconnect(self.form.syncLogin.clicked, self.sync_login)",
            "",
            "    def update_login_status(self) -> None:",
            "        if not self.prof.get(\"syncKey\"):",
            "            self.form.syncUser.setText(tr.preferences_not_logged_in())",
            "            self.form.syncLogin.setVisible(True)",
            "            self.form.syncLogout.setVisible(False)",
            "        else:",
            "            self.form.syncUser.setText(self.prof.get(\"syncUser\", \"\"))",
            "            self.form.syncLogin.setVisible(False)",
            "            self.form.syncLogout.setVisible(True)",
            "",
            "    def on_media_log(self) -> None:",
            "        self.mw.media_syncer.show_sync_log()",
            "",
            "    def sync_login(self) -> None:",
            "        def on_success():",
            "            if self.prof.get(\"syncKey\"):",
            "                self.update_login_status()",
            "                self.confirm_sync_after_login()",
            "",
            "        sync_login(self.mw, on_success)",
            "",
            "    def sync_logout(self) -> None:",
            "        if self.mw.media_syncer.is_syncing():",
            "            showWarning(\"Can't log out while sync in progress.\")",
            "            return",
            "        self.prof[\"syncKey\"] = None",
            "        self.mw.col.media.force_resync()",
            "        self.update_login_status()",
            "",
            "    def confirm_sync_after_login(self) -> None:",
            "        from aqt import mw",
            "",
            "        if askUser(tr.preferences_login_successful_sync_now(), parent=mw):",
            "            self.accept_with_callback(self.mw.on_sync_button_clicked)",
            "",
            "    def update_network(self) -> None:",
            "        self.prof[\"autoSync\"] = self.form.syncOnProgramOpen.isChecked()",
            "        self.prof[\"syncMedia\"] = self.form.syncMedia.isChecked()",
            "        self.mw.pm.set_periodic_sync_media_minutes(",
            "            self.form.autoSyncMedia.isChecked() and 15 or 0",
            "        )",
            "        if self.form.fullSync.isChecked():",
            "            self.mw.col.mod_schema(check=False)",
            "        self.mw.pm.set_custom_sync_url(self.form.custom_sync_url.text())",
            "        self.mw.pm.set_network_timeout(self.form.network_timeout.value())",
            "",
            "    # Global preferences",
            "    ######################################################################",
            "",
            "    def setup_global(self) -> None:",
            "        \"Setup options global to all profiles.\"",
            "        self.form.reduce_motion.setChecked(self.mw.pm.reduce_motion())",
            "        qconnect(self.form.reduce_motion.stateChanged, self.mw.pm.set_reduce_motion)",
            "",
            "        self.form.minimalist_mode.setChecked(self.mw.pm.minimalist_mode())",
            "        qconnect(self.form.minimalist_mode.stateChanged, self.mw.pm.set_minimalist_mode)",
            "",
            "        self.form.spacebar_rates_card.setChecked(self.mw.pm.spacebar_rates_card())",
            "        qconnect(",
            "            self.form.spacebar_rates_card.stateChanged,",
            "            self.mw.pm.set_spacebar_rates_card,",
            "        )",
            "",
            "        hide_choices = [tr.preferences_full_screen_only(), tr.preferences_always()]",
            "",
            "        self.form.hide_top_bar.setChecked(self.mw.pm.hide_top_bar())",
            "        qconnect(self.form.hide_top_bar.stateChanged, self.mw.pm.set_hide_top_bar)",
            "        qconnect(",
            "            self.form.hide_top_bar.stateChanged,",
            "            self.form.topBarComboBox.setVisible,",
            "        )",
            "        self.form.topBarComboBox.addItems(hide_choices)",
            "        self.form.topBarComboBox.setCurrentIndex(self.mw.pm.top_bar_hide_mode())",
            "        self.form.topBarComboBox.setVisible(self.form.hide_top_bar.isChecked())",
            "",
            "        qconnect(",
            "            self.form.topBarComboBox.currentIndexChanged,",
            "            self.mw.pm.set_top_bar_hide_mode,",
            "        )",
            "",
            "        self.form.hide_bottom_bar.setChecked(self.mw.pm.hide_bottom_bar())",
            "        qconnect(self.form.hide_bottom_bar.stateChanged, self.mw.pm.set_hide_bottom_bar)",
            "        qconnect(",
            "            self.form.hide_bottom_bar.stateChanged,",
            "            self.form.bottomBarComboBox.setVisible,",
            "        )",
            "        self.form.bottomBarComboBox.addItems(hide_choices)",
            "        self.form.bottomBarComboBox.setCurrentIndex(self.mw.pm.bottom_bar_hide_mode())",
            "        self.form.bottomBarComboBox.setVisible(self.form.hide_bottom_bar.isChecked())",
            "",
            "        qconnect(",
            "            self.form.bottomBarComboBox.currentIndexChanged,",
            "            self.mw.pm.set_bottom_bar_hide_mode,",
            "        )",
            "",
            "        self.form.uiScale.setValue(int(self.mw.pm.uiScale() * 100))",
            "        themes = [",
            "            tr.preferences_theme_follow_system(),",
            "            tr.preferences_theme_light(),",
            "            tr.preferences_theme_dark(),",
            "        ]",
            "        self.form.theme.addItems(themes)",
            "        self.form.theme.setCurrentIndex(self.mw.pm.theme().value)",
            "        qconnect(self.form.theme.currentIndexChanged, self.on_theme_changed)",
            "",
            "        self.form.styleComboBox.addItems([\"Anki\"] + ([\"Native\"] if not is_win else []))",
            "        self.form.styleComboBox.setCurrentIndex(self.mw.pm.get_widget_style())",
            "        qconnect(",
            "            self.form.styleComboBox.currentIndexChanged,",
            "            self.mw.pm.set_widget_style,",
            "        )",
            "        self.form.styleLabel.setVisible(not is_win)",
            "        self.form.styleComboBox.setVisible(not is_win)",
            "        self.form.legacy_import_export.setChecked(self.mw.pm.legacy_import_export())",
            "        qconnect(self.form.resetWindowSizes.clicked, self.on_reset_window_sizes)",
            "",
            "        self.setup_language()",
            "        self.setup_video_driver()",
            "",
            "        self.setupOptions()",
            "",
            "    def update_global(self) -> None:",
            "        restart_required = False",
            "",
            "        self.update_video_driver()",
            "",
            "        newScale = self.form.uiScale.value() / 100",
            "        if newScale != self.mw.pm.uiScale():",
            "            self.mw.pm.setUiScale(newScale)",
            "            restart_required = True",
            "",
            "        self.mw.pm.set_legacy_import_export(self.form.legacy_import_export.isChecked())",
            "",
            "        if restart_required:",
            "            showInfo(tr.preferences_changes_will_take_effect_when_you())",
            "",
            "        self.updateOptions()",
            "",
            "    def on_theme_changed(self, index: int) -> None:",
            "        self.mw.set_theme(Theme(index))",
            "",
            "    def on_reset_window_sizes(self) -> None:",
            "        regexp = re.compile(r\"(Geom(etry)?|State|Splitter|Header)(\\d+.\\d+)?$\")",
            "        for key in list(self.prof.keys()):",
            "            if regexp.search(key):",
            "                del self.prof[key]",
            "        showInfo(tr.preferences_reset_window_sizes_complete())",
            "",
            "    # legacy - one of Henrik's add-ons is currently wrapping them",
            "",
            "    def setupOptions(self) -> None:",
            "        pass",
            "",
            "    def updateOptions(self) -> None:",
            "        pass",
            "",
            "    # Global: language",
            "    ######################################################################",
            "",
            "    def setup_language(self) -> None:",
            "        f = self.form",
            "        f.lang.addItems([x[0] for x in anki.lang.langs])",
            "        f.lang.setCurrentIndex(self.current_lang_index())",
            "        qconnect(f.lang.currentIndexChanged, self.on_language_index_changed)",
            "",
            "    def current_lang_index(self) -> int:",
            "        codes = [x[1] for x in anki.lang.langs]",
            "        lang = anki.lang.current_lang",
            "        if lang in anki.lang.compatMap:",
            "            lang = anki.lang.compatMap[lang]",
            "        else:",
            "            lang = lang.replace(\"-\", \"_\")",
            "        try:",
            "            return codes.index(lang)",
            "        except:",
            "            return codes.index(\"en_US\")",
            "",
            "    def on_language_index_changed(self, idx: int) -> None:",
            "        code = anki.lang.langs[idx][1]",
            "        self.mw.pm.setLang(code)",
            "        showInfo(tr.preferences_please_restart_anki_to_complete_language(), parent=self)",
            "",
            "    # Global: video driver",
            "    ######################################################################",
            "",
            "    def setup_video_driver(self) -> None:",
            "        self.video_drivers = VideoDriver.all_for_platform()",
            "        names = [video_driver_name_for_platform(d) for d in self.video_drivers]",
            "        self.form.video_driver.addItems(names)",
            "        self.form.video_driver.setCurrentIndex(",
            "            self.video_drivers.index(self.mw.pm.video_driver())",
            "        )",
            "",
            "    def update_video_driver(self) -> None:",
            "        new_driver = self.video_drivers[self.form.video_driver.currentIndex()]",
            "        if new_driver != self.mw.pm.video_driver():",
            "            self.mw.pm.set_video_driver(new_driver)",
            "            showInfo(tr.preferences_changes_will_take_effect_when_you())",
            "",
            "",
            "def video_driver_name_for_platform(driver: VideoDriver) -> str:",
            "    if qtmajor < 6:",
            "        if driver == VideoDriver.ANGLE:",
            "            return tr.preferences_video_driver_angle()",
            "        elif driver == VideoDriver.Software:",
            "            if is_mac:",
            "                return tr.preferences_video_driver_software_mac()",
            "            else:",
            "                return tr.preferences_video_driver_software_other()",
            "        elif driver == VideoDriver.OpenGL:",
            "            if is_mac:",
            "                return tr.preferences_video_driver_opengl_mac()",
            "            else:",
            "                return tr.preferences_video_driver_opengl_other()",
            "",
            "    label = driver.name",
            "    if driver == VideoDriver.default_for_platform():",
            "        label += f\" ({tr.preferences_video_driver_default()})\"",
            "",
            "    return label"
        ],
        "afterPatchFile": [
            "# Copyright: Ankitects Pty Ltd and contributors",
            "# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html",
            "",
            "from __future__ import annotations",
            "",
            "import functools",
            "import re",
            "",
            "import anki.lang",
            "import aqt",
            "import aqt.forms",
            "import aqt.operations",
            "from anki.collection import OpChanges",
            "from aqt import AnkiQt",
            "from aqt.operations.collection import set_preferences",
            "from aqt.profiles import VideoDriver",
            "from aqt.qt import *",
            "from aqt.sync import sync_login",
            "from aqt.theme import Theme",
            "from aqt.utils import (",
            "    HelpPage,",
            "    askUser,",
            "    disable_help_button,",
            "    is_win,",
            "    openHelp,",
            "    showInfo,",
            "    showWarning,",
            "    tr,",
            ")",
            "",
            "",
            "class Preferences(QDialog):",
            "    def __init__(self, mw: AnkiQt) -> None:",
            "        QDialog.__init__(self, mw, Qt.WindowType.Window)",
            "        self.mw = mw",
            "        self.prof = self.mw.pm.profile",
            "        self.form = aqt.forms.preferences.Ui_Preferences()",
            "        self.form.setupUi(self)",
            "        disable_help_button(self)",
            "        self.form.buttonBox.button(QDialogButtonBox.StandardButton.Help).setAutoDefault(",
            "            False",
            "        )",
            "        self.form.buttonBox.button(",
            "            QDialogButtonBox.StandardButton.Close",
            "        ).setAutoDefault(False)",
            "        qconnect(",
            "            self.form.buttonBox.helpRequested, lambda: openHelp(HelpPage.PREFERENCES)",
            "        )",
            "        self.silentlyClose = True",
            "        self.setup_collection()",
            "        self.setup_profile()",
            "        self.setup_global()",
            "        self.setup_configurable_answer_keys()",
            "        self.show()",
            "",
            "    def setup_configurable_answer_keys(self):",
            "        \"\"\"",
            "        Create a group box in Preferences with widgets that let the user edit answer keys.",
            "        \"\"\"",
            "        ease_labels = (",
            "            (1, tr.studying_again()),",
            "            (2, tr.studying_hard()),",
            "            (3, tr.studying_good()),",
            "            (4, tr.studying_easy()),",
            "        )",
            "        group = self.form.preferences_answer_keys",
            "        group.setLayout(layout := QFormLayout())",
            "        for ease, label in ease_labels:",
            "            layout.addRow(",
            "                label,",
            "                line_edit := QLineEdit(self.mw.pm.get_answer_key(ease) or \"\"),",
            "            )",
            "            qconnect(",
            "                line_edit.textChanged,",
            "                functools.partial(self.mw.pm.set_answer_key, ease),",
            "            )",
            "            line_edit.setPlaceholderText(tr.preferences_shortcut_placeholder())",
            "",
            "    def accept(self) -> None:",
            "        self.accept_with_callback()",
            "",
            "    def accept_with_callback(self, callback: Callable[[], None] | None = None) -> None:",
            "        # avoid exception if main window is already closed",
            "        if not self.mw.col:",
            "            return",
            "",
            "        def after_collection_update() -> None:",
            "            self.update_profile()",
            "            self.update_global()",
            "            self.mw.pm.save()",
            "            self.done(0)",
            "            aqt.dialogs.markClosed(\"Preferences\")",
            "",
            "            if callback:",
            "                callback()",
            "",
            "        self.update_collection(after_collection_update)",
            "",
            "    def reject(self) -> None:",
            "        self.accept()",
            "",
            "    # Preferences stored in the collection",
            "    ######################################################################",
            "",
            "    def setup_collection(self) -> None:",
            "        self.prefs = self.mw.col.get_preferences()",
            "",
            "        form = self.form",
            "",
            "        scheduling = self.prefs.scheduling",
            "",
            "        form.lrnCutoff.setValue(int(scheduling.learn_ahead_secs / 60.0))",
            "        form.dayOffset.setValue(scheduling.rollover)",
            "",
            "        reviewing = self.prefs.reviewing",
            "        form.timeLimit.setValue(int(reviewing.time_limit_secs / 60.0))",
            "        form.showEstimates.setChecked(reviewing.show_intervals_on_buttons)",
            "        form.showProgress.setChecked(reviewing.show_remaining_due_counts)",
            "        form.showPlayButtons.setChecked(not reviewing.hide_audio_play_buttons)",
            "        form.interrupt_audio.setChecked(reviewing.interrupt_audio_when_answering)",
            "",
            "        editing = self.prefs.editing",
            "        form.useCurrent.setCurrentIndex(",
            "            0 if editing.adding_defaults_to_current_deck else 1",
            "        )",
            "        form.paste_strips_formatting.setChecked(editing.paste_strips_formatting)",
            "        form.ignore_accents_in_search.setChecked(editing.ignore_accents_in_search)",
            "        form.pastePNG.setChecked(editing.paste_images_as_png)",
            "        form.render_latex.setChecked(editing.render_latex)",
            "        form.default_search_text.setText(editing.default_search_text)",
            "",
            "        form.backup_explanation.setText(",
            "            anki.lang.with_collapsed_whitespace(tr.preferences_backup_explanation())",
            "        )",
            "        form.daily_backups.setValue(self.prefs.backups.daily)",
            "        form.weekly_backups.setValue(self.prefs.backups.weekly)",
            "        form.monthly_backups.setValue(self.prefs.backups.monthly)",
            "        form.minutes_between_backups.setValue(self.prefs.backups.minimum_interval_mins)",
            "",
            "    def update_collection(self, on_done: Callable[[], None]) -> None:",
            "        form = self.form",
            "",
            "        scheduling = self.prefs.scheduling",
            "        scheduling.learn_ahead_secs = form.lrnCutoff.value() * 60",
            "        scheduling.rollover = form.dayOffset.value()",
            "",
            "        reviewing = self.prefs.reviewing",
            "        reviewing.show_remaining_due_counts = form.showProgress.isChecked()",
            "        reviewing.show_intervals_on_buttons = form.showEstimates.isChecked()",
            "        reviewing.time_limit_secs = form.timeLimit.value() * 60",
            "        reviewing.hide_audio_play_buttons = not self.form.showPlayButtons.isChecked()",
            "        reviewing.interrupt_audio_when_answering = self.form.interrupt_audio.isChecked()",
            "",
            "        editing = self.prefs.editing",
            "        editing.adding_defaults_to_current_deck = not form.useCurrent.currentIndex()",
            "        editing.paste_images_as_png = self.form.pastePNG.isChecked()",
            "        editing.paste_strips_formatting = self.form.paste_strips_formatting.isChecked()",
            "        editing.render_latex = self.form.render_latex.isChecked()",
            "        editing.default_search_text = self.form.default_search_text.text()",
            "        editing.ignore_accents_in_search = (",
            "            self.form.ignore_accents_in_search.isChecked()",
            "        )",
            "",
            "        self.prefs.backups.daily = form.daily_backups.value()",
            "        self.prefs.backups.weekly = form.weekly_backups.value()",
            "        self.prefs.backups.monthly = form.monthly_backups.value()",
            "        self.prefs.backups.minimum_interval_mins = form.minutes_between_backups.value()",
            "",
            "        def after_prefs_update(changes: OpChanges) -> None:",
            "            self.mw.apply_collection_options()",
            "            on_done()",
            "",
            "        set_preferences(parent=self, preferences=self.prefs).success(",
            "            after_prefs_update",
            "        ).run_in_background()",
            "",
            "    # Preferences stored in the profile",
            "    ######################################################################",
            "",
            "    def setup_profile(self) -> None:",
            "        \"Setup options stored in the user profile.\"",
            "        self.setup_network()",
            "",
            "    def update_profile(self) -> None:",
            "        self.update_network()",
            "",
            "    # Profile: network",
            "    ######################################################################",
            "",
            "    def setup_network(self) -> None:",
            "        self.form.media_log.setText(tr.sync_media_log_button())",
            "        qconnect(self.form.media_log.clicked, self.on_media_log)",
            "        self.form.syncOnProgramOpen.setChecked(self.mw.pm.auto_syncing_enabled())",
            "        self.form.syncMedia.setChecked(self.mw.pm.media_syncing_enabled())",
            "        self.form.autoSyncMedia.setChecked(",
            "            self.mw.pm.periodic_sync_media_minutes() != 0",
            "        )",
            "        self.form.custom_sync_url.setText(self.mw.pm.custom_sync_url())",
            "        self.form.network_timeout.setValue(self.mw.pm.network_timeout())",
            "",
            "        self.update_login_status()",
            "        qconnect(self.form.syncLogout.clicked, self.sync_logout)",
            "        qconnect(self.form.syncLogin.clicked, self.sync_login)",
            "",
            "    def update_login_status(self) -> None:",
            "        if not self.prof.get(\"syncKey\"):",
            "            self.form.syncUser.setText(tr.preferences_not_logged_in())",
            "            self.form.syncLogin.setVisible(True)",
            "            self.form.syncLogout.setVisible(False)",
            "        else:",
            "            self.form.syncUser.setText(self.prof.get(\"syncUser\", \"\"))",
            "            self.form.syncLogin.setVisible(False)",
            "            self.form.syncLogout.setVisible(True)",
            "",
            "    def on_media_log(self) -> None:",
            "        self.mw.media_syncer.show_sync_log()",
            "",
            "    def sync_login(self) -> None:",
            "        def on_success():",
            "            if self.prof.get(\"syncKey\"):",
            "                self.update_login_status()",
            "                self.confirm_sync_after_login()",
            "",
            "        sync_login(self.mw, on_success)",
            "",
            "    def sync_logout(self) -> None:",
            "        if self.mw.media_syncer.is_syncing():",
            "            showWarning(\"Can't log out while sync in progress.\")",
            "            return",
            "        self.prof[\"syncKey\"] = None",
            "        self.mw.col.media.force_resync()",
            "        self.update_login_status()",
            "",
            "    def confirm_sync_after_login(self) -> None:",
            "        from aqt import mw",
            "",
            "        if askUser(tr.preferences_login_successful_sync_now(), parent=mw):",
            "            self.accept_with_callback(self.mw.on_sync_button_clicked)",
            "",
            "    def update_network(self) -> None:",
            "        self.prof[\"autoSync\"] = self.form.syncOnProgramOpen.isChecked()",
            "        self.prof[\"syncMedia\"] = self.form.syncMedia.isChecked()",
            "        self.mw.pm.set_periodic_sync_media_minutes(",
            "            self.form.autoSyncMedia.isChecked() and 15 or 0",
            "        )",
            "        if self.form.fullSync.isChecked():",
            "            self.mw.col.mod_schema(check=False)",
            "        self.mw.pm.set_custom_sync_url(self.form.custom_sync_url.text())",
            "        self.mw.pm.set_network_timeout(self.form.network_timeout.value())",
            "",
            "    # Global preferences",
            "    ######################################################################",
            "",
            "    def setup_global(self) -> None:",
            "        \"Setup options global to all profiles.\"",
            "        self.form.reduce_motion.setChecked(self.mw.pm.reduce_motion())",
            "        qconnect(self.form.reduce_motion.stateChanged, self.mw.pm.set_reduce_motion)",
            "",
            "        self.form.minimalist_mode.setChecked(self.mw.pm.minimalist_mode())",
            "        qconnect(self.form.minimalist_mode.stateChanged, self.mw.pm.set_minimalist_mode)",
            "",
            "        self.form.spacebar_rates_card.setChecked(self.mw.pm.spacebar_rates_card())",
            "        qconnect(",
            "            self.form.spacebar_rates_card.stateChanged,",
            "            self.mw.pm.set_spacebar_rates_card,",
            "        )",
            "",
            "        hide_choices = [tr.preferences_full_screen_only(), tr.preferences_always()]",
            "",
            "        self.form.hide_top_bar.setChecked(self.mw.pm.hide_top_bar())",
            "        qconnect(self.form.hide_top_bar.stateChanged, self.mw.pm.set_hide_top_bar)",
            "        qconnect(",
            "            self.form.hide_top_bar.stateChanged,",
            "            self.form.topBarComboBox.setVisible,",
            "        )",
            "        self.form.topBarComboBox.addItems(hide_choices)",
            "        self.form.topBarComboBox.setCurrentIndex(self.mw.pm.top_bar_hide_mode())",
            "        self.form.topBarComboBox.setVisible(self.form.hide_top_bar.isChecked())",
            "",
            "        qconnect(",
            "            self.form.topBarComboBox.currentIndexChanged,",
            "            self.mw.pm.set_top_bar_hide_mode,",
            "        )",
            "",
            "        self.form.hide_bottom_bar.setChecked(self.mw.pm.hide_bottom_bar())",
            "        qconnect(self.form.hide_bottom_bar.stateChanged, self.mw.pm.set_hide_bottom_bar)",
            "        qconnect(",
            "            self.form.hide_bottom_bar.stateChanged,",
            "            self.form.bottomBarComboBox.setVisible,",
            "        )",
            "        self.form.bottomBarComboBox.addItems(hide_choices)",
            "        self.form.bottomBarComboBox.setCurrentIndex(self.mw.pm.bottom_bar_hide_mode())",
            "        self.form.bottomBarComboBox.setVisible(self.form.hide_bottom_bar.isChecked())",
            "",
            "        qconnect(",
            "            self.form.bottomBarComboBox.currentIndexChanged,",
            "            self.mw.pm.set_bottom_bar_hide_mode,",
            "        )",
            "",
            "        self.form.uiScale.setValue(int(self.mw.pm.uiScale() * 100))",
            "        themes = [",
            "            tr.preferences_theme_follow_system(),",
            "            tr.preferences_theme_light(),",
            "            tr.preferences_theme_dark(),",
            "        ]",
            "        self.form.theme.addItems(themes)",
            "        self.form.theme.setCurrentIndex(self.mw.pm.theme().value)",
            "        qconnect(self.form.theme.currentIndexChanged, self.on_theme_changed)",
            "",
            "        self.form.styleComboBox.addItems([\"Anki\"] + ([\"Native\"] if not is_win else []))",
            "        self.form.styleComboBox.setCurrentIndex(self.mw.pm.get_widget_style())",
            "        qconnect(",
            "            self.form.styleComboBox.currentIndexChanged,",
            "            self.mw.pm.set_widget_style,",
            "        )",
            "        self.form.styleLabel.setVisible(not is_win)",
            "        self.form.styleComboBox.setVisible(not is_win)",
            "        self.form.legacy_import_export.setChecked(self.mw.pm.legacy_import_export())",
            "        qconnect(self.form.resetWindowSizes.clicked, self.on_reset_window_sizes)",
            "",
            "        self.setup_language()",
            "        self.setup_video_driver()",
            "",
            "        self.setupOptions()",
            "",
            "    def update_global(self) -> None:",
            "        restart_required = False",
            "",
            "        self.update_video_driver()",
            "",
            "        newScale = self.form.uiScale.value() / 100",
            "        if newScale != self.mw.pm.uiScale():",
            "            self.mw.pm.setUiScale(newScale)",
            "            restart_required = True",
            "",
            "        self.mw.pm.set_legacy_import_export(self.form.legacy_import_export.isChecked())",
            "",
            "        if restart_required:",
            "            showInfo(tr.preferences_changes_will_take_effect_when_you())",
            "",
            "        self.updateOptions()",
            "",
            "    def on_theme_changed(self, index: int) -> None:",
            "        self.mw.set_theme(Theme(index))",
            "",
            "    def on_reset_window_sizes(self) -> None:",
            "        regexp = re.compile(r\"(Geom(etry)?|State|Splitter|Header)(\\d+.\\d+)?$\")",
            "        for key in list(self.prof.keys()):",
            "            if regexp.search(key):",
            "                del self.prof[key]",
            "        showInfo(tr.preferences_reset_window_sizes_complete())",
            "",
            "    # legacy - one of Henrik's add-ons is currently wrapping them",
            "",
            "    def setupOptions(self) -> None:",
            "        pass",
            "",
            "    def updateOptions(self) -> None:",
            "        pass",
            "",
            "    # Global: language",
            "    ######################################################################",
            "",
            "    def setup_language(self) -> None:",
            "        f = self.form",
            "        f.lang.addItems([x[0] for x in anki.lang.langs])",
            "        f.lang.setCurrentIndex(self.current_lang_index())",
            "        qconnect(f.lang.currentIndexChanged, self.on_language_index_changed)",
            "",
            "    def current_lang_index(self) -> int:",
            "        codes = [x[1] for x in anki.lang.langs]",
            "        lang = anki.lang.current_lang",
            "        if lang in anki.lang.compatMap:",
            "            lang = anki.lang.compatMap[lang]",
            "        else:",
            "            lang = lang.replace(\"-\", \"_\")",
            "        try:",
            "            return codes.index(lang)",
            "        except:",
            "            return codes.index(\"en_US\")",
            "",
            "    def on_language_index_changed(self, idx: int) -> None:",
            "        code = anki.lang.langs[idx][1]",
            "        self.mw.pm.setLang(code)",
            "        showInfo(tr.preferences_please_restart_anki_to_complete_language(), parent=self)",
            "",
            "    # Global: video driver",
            "    ######################################################################",
            "",
            "    def setup_video_driver(self) -> None:",
            "        self.video_drivers = VideoDriver.all_for_platform()",
            "        names = [video_driver_name_for_platform(d) for d in self.video_drivers]",
            "        self.form.video_driver.addItems(names)",
            "        self.form.video_driver.setCurrentIndex(",
            "            self.video_drivers.index(self.mw.pm.video_driver())",
            "        )",
            "",
            "    def update_video_driver(self) -> None:",
            "        new_driver = self.video_drivers[self.form.video_driver.currentIndex()]",
            "        if new_driver != self.mw.pm.video_driver():",
            "            self.mw.pm.set_video_driver(new_driver)",
            "            showInfo(tr.preferences_changes_will_take_effect_when_you())",
            "",
            "",
            "def video_driver_name_for_platform(driver: VideoDriver) -> str:",
            "    if qtmajor < 6:",
            "        if driver == VideoDriver.ANGLE:",
            "            return tr.preferences_video_driver_angle()",
            "        elif driver == VideoDriver.Software:",
            "            if is_mac:",
            "                return tr.preferences_video_driver_software_mac()",
            "            else:",
            "                return tr.preferences_video_driver_software_other()",
            "        elif driver == VideoDriver.OpenGL:",
            "            if is_mac:",
            "                return tr.preferences_video_driver_opengl_mac()",
            "            else:",
            "                return tr.preferences_video_driver_opengl_other()",
            "",
            "    label = driver.name",
            "    if driver == VideoDriver.default_for_platform():",
            "        label += f\" ({tr.preferences_video_driver_default()})\"",
            "",
            "    return label"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "urllib3.util.retry",
            "qt.aqt.preferences.Preferences.accept_with_callback",
            "qt.aqt.preferences.Preferences.__init__"
        ]
    }
}