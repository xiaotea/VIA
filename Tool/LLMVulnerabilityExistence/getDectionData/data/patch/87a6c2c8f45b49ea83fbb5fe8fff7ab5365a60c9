{
    "src/zenml/zen_server/rate_limit.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import inspect"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import time"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from collections import defaultdict"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from contextlib import contextmanager"
            },
            "4": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from functools import wraps"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from typing import ("
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     Any,"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     Callable,"
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     Dict,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    Generator,"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     List,"
            },
            "11": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     Optional,"
            },
            "12": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     TypeVar,"
            },
            "13": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "             return request.client.host"
            },
            "15": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    @contextmanager"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    def limit_failed_requests("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        self, request: Request"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    ) -> Generator[None, Any, Any]:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        \"\"\"Limits the number of failed requests."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        Args:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            request: Request object."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        Yields:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            None"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        \"\"\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        self.hit_limiter(request)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        yield"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        # if request was successful - reset limiter"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        self.reset_limiter(request)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " def rate_limit_requests("
            },
            "37": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "     day_limit: Optional[int] = None,"
            },
            "38": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "                 request = kwargs[request_kwarg]"
            },
            "39": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "             else:"
            },
            "40": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "                 request = args[request_arg]"
            },
            "41": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            limiter.hit_limiter(request)"
            },
            "42": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "43": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ret = func(*args, **kwargs)"
            },
            "44": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "45": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # if request was successful - reset limiter"
            },
            "46": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            limiter.reset_limiter(request)"
            },
            "47": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return ret"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            with limiter.limit_failed_requests(request):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                return func(*args, **kwargs)"
            },
            "50": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 197,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         return cast(F, decorated)"
            },
            "52": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 199,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2024. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Rate limiting for the ZenML Server.\"\"\"",
            "",
            "import inspect",
            "import time",
            "from collections import defaultdict",
            "from functools import wraps",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    TypeVar,",
            "    cast,",
            ")",
            "",
            "from starlette.requests import Request",
            "",
            "from zenml.logger import get_logger",
            "from zenml.zen_server.utils import server_config",
            "",
            "logger = get_logger(__name__)",
            "F = TypeVar(\"F\", bound=Callable[..., Any])",
            "",
            "",
            "class RequestLimiter:",
            "    \"\"\"Simple in-memory rate limiter.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        day_limit: Optional[int] = None,",
            "        minute_limit: Optional[int] = None,",
            "    ):",
            "        \"\"\"Initializes the limiter.",
            "",
            "        Args:",
            "            day_limit: The number of requests allowed per day.",
            "            minute_limit: The number of requests allowed per minute.",
            "",
            "        Raises:",
            "            ValueError: If both day_limit and minute_limit are None.",
            "        \"\"\"",
            "        self.limiting_enabled = server_config().rate_limit_enabled",
            "        if not self.limiting_enabled:",
            "            return",
            "        if day_limit is None and minute_limit is None:",
            "            raise ValueError(\"Pass either day or minuter limits, or both.\")",
            "        self.day_limit = day_limit",
            "        self.minute_limit = minute_limit",
            "        self.limiter: Dict[str, List[float]] = defaultdict(list)",
            "",
            "    def hit_limiter(self, request: Request) -> None:",
            "        \"\"\"Increase the number of hits in the limiter.",
            "",
            "        Args:",
            "            request: Request object.",
            "",
            "        Raises:",
            "            HTTPException: If the request limit is exceeded.",
            "        \"\"\"",
            "        if not self.limiting_enabled:",
            "            return",
            "        from fastapi import HTTPException",
            "",
            "        requester = self._get_ipaddr(request)",
            "        now = time.time()",
            "        minute_ago = now - 60",
            "        day_ago = now - 60 * 60 * 24",
            "        self.limiter[requester].append(now)",
            "",
            "        from bisect import bisect_left",
            "",
            "        # remove failures older than a day",
            "        older_index = bisect_left(self.limiter[requester], day_ago)",
            "        self.limiter[requester] = self.limiter[requester][older_index:]",
            "",
            "        if self.day_limit and len(self.limiter[requester]) > self.day_limit:",
            "            raise HTTPException(",
            "                status_code=429, detail=\"Daily request limit exceeded.\"",
            "            )",
            "        minute_requests = len(",
            "            [",
            "                limiter_hit",
            "                for limiter_hit in self.limiter[requester][::-1]",
            "                if limiter_hit >= minute_ago",
            "            ]",
            "        )",
            "        if self.minute_limit and minute_requests > self.minute_limit:",
            "            raise HTTPException(",
            "                status_code=429, detail=\"Minute request limit exceeded.\"",
            "            )",
            "",
            "    def reset_limiter(self, request: Request) -> None:",
            "        \"\"\"Resets the limiter on successful request.",
            "",
            "        Args:",
            "            request: Request object.",
            "        \"\"\"",
            "        if self.limiting_enabled:",
            "            requester = self._get_ipaddr(request)",
            "            if requester in self.limiter:",
            "                del self.limiter[requester]",
            "",
            "    def _get_ipaddr(self, request: Request) -> str:",
            "        \"\"\"Returns the IP address for the current request.",
            "",
            "        Based on the X-Forwarded-For headers or client information.",
            "",
            "        Args:",
            "            request: The request object.",
            "",
            "        Returns:",
            "            The ip address for the current request (or 127.0.0.1 if none found).",
            "        \"\"\"",
            "        if \"X_FORWARDED_FOR\" in request.headers:",
            "            return request.headers[\"X_FORWARDED_FOR\"]",
            "        else:",
            "            if not request.client or not request.client.host:",
            "                return \"127.0.0.1\"",
            "",
            "            return request.client.host",
            "",
            "",
            "def rate_limit_requests(",
            "    day_limit: Optional[int] = None,",
            "    minute_limit: Optional[int] = None,",
            ") -> Callable[..., Any]:",
            "    \"\"\"Decorator to handle exceptions in the API.",
            "",
            "    Args:",
            "        day_limit: Number of requests allowed per day.",
            "        minute_limit: Number of requests allowed per minute.",
            "",
            "    Returns:",
            "        Decorated function.",
            "    \"\"\"",
            "    limiter = RequestLimiter(day_limit=day_limit, minute_limit=minute_limit)",
            "",
            "    def decorator(func: F) -> F:",
            "        request_arg, request_kwarg = None, None",
            "        parameters = inspect.signature(func).parameters",
            "        for arg_num, arg_name in enumerate(parameters):",
            "            if parameters[arg_name].annotation == Request:",
            "                request_arg = arg_num",
            "                request_kwarg = arg_name",
            "                break",
            "        if request_arg is None or request_kwarg is None:",
            "            raise ValueError(",
            "                \"Rate limiting APIs must have argument of `Request` type.\"",
            "            )",
            "",
            "        @wraps(func)",
            "        def decorated(",
            "            *args: Any,",
            "            **kwargs: Any,",
            "        ) -> Any:",
            "            if request_kwarg in kwargs:",
            "                request = kwargs[request_kwarg]",
            "            else:",
            "                request = args[request_arg]",
            "            limiter.hit_limiter(request)",
            "",
            "            ret = func(*args, **kwargs)",
            "",
            "            # if request was successful - reset limiter",
            "            limiter.reset_limiter(request)",
            "            return ret",
            "",
            "        return cast(F, decorated)",
            "",
            "    return decorator"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2024. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Rate limiting for the ZenML Server.\"\"\"",
            "",
            "import inspect",
            "import time",
            "from collections import defaultdict",
            "from contextlib import contextmanager",
            "from functools import wraps",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    Generator,",
            "    List,",
            "    Optional,",
            "    TypeVar,",
            "    cast,",
            ")",
            "",
            "from starlette.requests import Request",
            "",
            "from zenml.logger import get_logger",
            "from zenml.zen_server.utils import server_config",
            "",
            "logger = get_logger(__name__)",
            "F = TypeVar(\"F\", bound=Callable[..., Any])",
            "",
            "",
            "class RequestLimiter:",
            "    \"\"\"Simple in-memory rate limiter.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        day_limit: Optional[int] = None,",
            "        minute_limit: Optional[int] = None,",
            "    ):",
            "        \"\"\"Initializes the limiter.",
            "",
            "        Args:",
            "            day_limit: The number of requests allowed per day.",
            "            minute_limit: The number of requests allowed per minute.",
            "",
            "        Raises:",
            "            ValueError: If both day_limit and minute_limit are None.",
            "        \"\"\"",
            "        self.limiting_enabled = server_config().rate_limit_enabled",
            "        if not self.limiting_enabled:",
            "            return",
            "        if day_limit is None and minute_limit is None:",
            "            raise ValueError(\"Pass either day or minuter limits, or both.\")",
            "        self.day_limit = day_limit",
            "        self.minute_limit = minute_limit",
            "        self.limiter: Dict[str, List[float]] = defaultdict(list)",
            "",
            "    def hit_limiter(self, request: Request) -> None:",
            "        \"\"\"Increase the number of hits in the limiter.",
            "",
            "        Args:",
            "            request: Request object.",
            "",
            "        Raises:",
            "            HTTPException: If the request limit is exceeded.",
            "        \"\"\"",
            "        if not self.limiting_enabled:",
            "            return",
            "        from fastapi import HTTPException",
            "",
            "        requester = self._get_ipaddr(request)",
            "        now = time.time()",
            "        minute_ago = now - 60",
            "        day_ago = now - 60 * 60 * 24",
            "        self.limiter[requester].append(now)",
            "",
            "        from bisect import bisect_left",
            "",
            "        # remove failures older than a day",
            "        older_index = bisect_left(self.limiter[requester], day_ago)",
            "        self.limiter[requester] = self.limiter[requester][older_index:]",
            "",
            "        if self.day_limit and len(self.limiter[requester]) > self.day_limit:",
            "            raise HTTPException(",
            "                status_code=429, detail=\"Daily request limit exceeded.\"",
            "            )",
            "        minute_requests = len(",
            "            [",
            "                limiter_hit",
            "                for limiter_hit in self.limiter[requester][::-1]",
            "                if limiter_hit >= minute_ago",
            "            ]",
            "        )",
            "        if self.minute_limit and minute_requests > self.minute_limit:",
            "            raise HTTPException(",
            "                status_code=429, detail=\"Minute request limit exceeded.\"",
            "            )",
            "",
            "    def reset_limiter(self, request: Request) -> None:",
            "        \"\"\"Resets the limiter on successful request.",
            "",
            "        Args:",
            "            request: Request object.",
            "        \"\"\"",
            "        if self.limiting_enabled:",
            "            requester = self._get_ipaddr(request)",
            "            if requester in self.limiter:",
            "                del self.limiter[requester]",
            "",
            "    def _get_ipaddr(self, request: Request) -> str:",
            "        \"\"\"Returns the IP address for the current request.",
            "",
            "        Based on the X-Forwarded-For headers or client information.",
            "",
            "        Args:",
            "            request: The request object.",
            "",
            "        Returns:",
            "            The ip address for the current request (or 127.0.0.1 if none found).",
            "        \"\"\"",
            "        if \"X_FORWARDED_FOR\" in request.headers:",
            "            return request.headers[\"X_FORWARDED_FOR\"]",
            "        else:",
            "            if not request.client or not request.client.host:",
            "                return \"127.0.0.1\"",
            "",
            "            return request.client.host",
            "",
            "    @contextmanager",
            "    def limit_failed_requests(",
            "        self, request: Request",
            "    ) -> Generator[None, Any, Any]:",
            "        \"\"\"Limits the number of failed requests.",
            "",
            "        Args:",
            "            request: Request object.",
            "",
            "        Yields:",
            "            None",
            "        \"\"\"",
            "        self.hit_limiter(request)",
            "",
            "        yield",
            "",
            "        # if request was successful - reset limiter",
            "        self.reset_limiter(request)",
            "",
            "",
            "def rate_limit_requests(",
            "    day_limit: Optional[int] = None,",
            "    minute_limit: Optional[int] = None,",
            ") -> Callable[..., Any]:",
            "    \"\"\"Decorator to handle exceptions in the API.",
            "",
            "    Args:",
            "        day_limit: Number of requests allowed per day.",
            "        minute_limit: Number of requests allowed per minute.",
            "",
            "    Returns:",
            "        Decorated function.",
            "    \"\"\"",
            "    limiter = RequestLimiter(day_limit=day_limit, minute_limit=minute_limit)",
            "",
            "    def decorator(func: F) -> F:",
            "        request_arg, request_kwarg = None, None",
            "        parameters = inspect.signature(func).parameters",
            "        for arg_num, arg_name in enumerate(parameters):",
            "            if parameters[arg_name].annotation == Request:",
            "                request_arg = arg_num",
            "                request_kwarg = arg_name",
            "                break",
            "        if request_arg is None or request_kwarg is None:",
            "            raise ValueError(",
            "                \"Rate limiting APIs must have argument of `Request` type.\"",
            "            )",
            "",
            "        @wraps(func)",
            "        def decorated(",
            "            *args: Any,",
            "            **kwargs: Any,",
            "        ) -> Any:",
            "            if request_kwarg in kwargs:",
            "                request = kwargs[request_kwarg]",
            "            else:",
            "                request = args[request_arg]",
            "            with limiter.limit_failed_requests(request):",
            "                return func(*args, **kwargs)",
            "",
            "        return cast(F, decorated)",
            "",
            "    return decorator"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "174": [
                "rate_limit_requests",
                "decorator",
                "decorated"
            ],
            "175": [
                "rate_limit_requests",
                "decorator",
                "decorated"
            ],
            "176": [
                "rate_limit_requests",
                "decorator",
                "decorated"
            ],
            "177": [
                "rate_limit_requests",
                "decorator",
                "decorated"
            ],
            "178": [
                "rate_limit_requests",
                "decorator",
                "decorated"
            ],
            "179": [
                "rate_limit_requests",
                "decorator",
                "decorated"
            ],
            "180": [
                "rate_limit_requests",
                "decorator",
                "decorated"
            ]
        },
        "addLocation": [
            "src.zenml.zen_server.rate_limit.RequestLimiter.self",
            "flask_cors.extension",
            "src.zenml.zen_server.rate_limit.rate_limit_requests.limiter"
        ]
    },
    "src/zenml/zen_server/routers/users_endpoints.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from uuid import UUID"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from fastapi import APIRouter, Depends, Security"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from starlette.requests import Request"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from zenml.analytics.utils import email_opt_int"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from zenml.constants import ("
            },
            "7": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     authorize,"
            },
            "8": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " )"
            },
            "9": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " from zenml.zen_server.exceptions import error_response"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+from zenml.zen_server.rate_limit import RequestLimiter"
            },
            "11": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " from zenml.zen_server.rbac.endpoint_utils import ("
            },
            "12": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     verify_permissions_and_create_entity,"
            },
            "13": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " )"
            },
            "14": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " # When the auth scheme is set to EXTERNAL, users cannot be updated via the"
            },
            "15": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 229,
                "PatchRowcode": " # API."
            },
            "16": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " if server_config().auth_scheme != AuthScheme.EXTERNAL:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+    pass_change_limiter = RequestLimiter("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        day_limit=server_config().login_rate_limit_day,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        minute_limit=server_config().login_rate_limit_minute,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+    )"
            },
            "21": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 235,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "     @router.put("
            },
            "23": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         \"/{user_name_or_id}\","
            },
            "24": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     def update_user("
            },
            "25": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "         user_name_or_id: Union[str, UUID],"
            },
            "26": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         user_update: UserUpdate,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        request: Request,"
            },
            "28": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         auth_context: AuthContext = Security(authorize),"
            },
            "29": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "     ) -> UserResponse:"
            },
            "30": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         \"\"\"Updates a specific user."
            },
            "31": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 253,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "         Args:"
            },
            "33": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "             user_name_or_id: Name or ID of the user."
            },
            "34": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "             user_update: the user to use for the update."
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+            request: The request object."
            },
            "36": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "             auth_context: Authentication context."
            },
            "37": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         Returns:"
            },
            "39": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "                     \"The current password must be supplied when changing the \""
            },
            "40": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "                     \"password.\""
            },
            "41": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "                 )"
            },
            "42": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            auth_user = zen_store().get_auth_user(user_name_or_id)"
            },
            "43": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not UserAuthModel.verify_password("
            },
            "44": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                user_update.old_password, auth_user"
            },
            "45": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ):"
            },
            "46": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise IllegalOperationError("
            },
            "47": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"The current password is incorrect.\""
            },
            "48": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+            with pass_change_limiter.limit_failed_requests(request):"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+                auth_user = zen_store().get_auth_user(user_name_or_id)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+                if not UserAuthModel.verify_password("
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+                    user_update.old_password, auth_user"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+                ):"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+                    raise IllegalOperationError("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+                        \"The current password is incorrect.\""
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+                    )"
            },
            "58": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 303,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "         if ("
            },
            "60": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "             user_update.is_admin is not None"
            },
            "61": {
                "beforePatchRowNumber": 529,
                "afterPatchRowNumber": 539,
                "PatchRowcode": "     @handle_exceptions"
            },
            "62": {
                "beforePatchRowNumber": 530,
                "afterPatchRowNumber": 540,
                "PatchRowcode": "     def update_myself("
            },
            "63": {
                "beforePatchRowNumber": 531,
                "afterPatchRowNumber": 541,
                "PatchRowcode": "         user: UserUpdate,"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 542,
                "PatchRowcode": "+        request: Request,"
            },
            "65": {
                "beforePatchRowNumber": 532,
                "afterPatchRowNumber": 543,
                "PatchRowcode": "         auth_context: AuthContext = Security(authorize),"
            },
            "66": {
                "beforePatchRowNumber": 533,
                "afterPatchRowNumber": 544,
                "PatchRowcode": "     ) -> UserResponse:"
            },
            "67": {
                "beforePatchRowNumber": 534,
                "afterPatchRowNumber": 545,
                "PatchRowcode": "         \"\"\"Updates a specific user."
            },
            "68": {
                "beforePatchRowNumber": 535,
                "afterPatchRowNumber": 546,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": 536,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "         Args:"
            },
            "70": {
                "beforePatchRowNumber": 537,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "             user: the user to use for the update."
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+            request: The request object."
            },
            "72": {
                "beforePatchRowNumber": 538,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "             auth_context: The authentication context."
            },
            "73": {
                "beforePatchRowNumber": 539,
                "afterPatchRowNumber": 551,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 540,
                "afterPatchRowNumber": 552,
                "PatchRowcode": "         Returns:"
            },
            "75": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "                     \"The current password must be supplied when changing the \""
            },
            "76": {
                "beforePatchRowNumber": 555,
                "afterPatchRowNumber": 567,
                "PatchRowcode": "                     \"password.\""
            },
            "77": {
                "beforePatchRowNumber": 556,
                "afterPatchRowNumber": 568,
                "PatchRowcode": "                 )"
            },
            "78": {
                "beforePatchRowNumber": 557,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            auth_user = zen_store().get_auth_user(auth_context.user.id)"
            },
            "79": {
                "beforePatchRowNumber": 558,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not UserAuthModel.verify_password(user.old_password, auth_user):"
            },
            "80": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise IllegalOperationError("
            },
            "81": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"The current password is incorrect.\""
            },
            "82": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 569,
                "PatchRowcode": "+            with pass_change_limiter.limit_failed_requests(request):"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+                auth_user = zen_store().get_auth_user(auth_context.user.id)"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 571,
                "PatchRowcode": "+                if not UserAuthModel.verify_password("
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 572,
                "PatchRowcode": "+                    user.old_password, auth_user"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 573,
                "PatchRowcode": "+                ):"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 574,
                "PatchRowcode": "+                    raise IllegalOperationError("
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 575,
                "PatchRowcode": "+                        \"The current password is incorrect.\""
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+                    )"
            },
            "91": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 577,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": 578,
                "PatchRowcode": "         user.activation_token = current_user.activation_token"
            },
            "93": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 579,
                "PatchRowcode": "         user.active = current_user.active"
            }
        },
        "frontPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Endpoint definitions for users.\"\"\"",
            "",
            "from typing import List, Optional, Union",
            "from uuid import UUID",
            "",
            "from fastapi import APIRouter, Depends, Security",
            "",
            "from zenml.analytics.utils import email_opt_int",
            "from zenml.constants import (",
            "    ACTIVATE,",
            "    API,",
            "    DEACTIVATE,",
            "    EMAIL_ANALYTICS,",
            "    USERS,",
            "    VERSION_1,",
            ")",
            "from zenml.enums import AuthScheme",
            "from zenml.exceptions import AuthorizationException, IllegalOperationError",
            "from zenml.logger import get_logger",
            "from zenml.models import (",
            "    Page,",
            "    UserAuthModel,",
            "    UserFilter,",
            "    UserRequest,",
            "    UserResponse,",
            "    UserUpdate,",
            ")",
            "from zenml.zen_server.auth import (",
            "    AuthContext,",
            "    authenticate_credentials,",
            "    authorize,",
            ")",
            "from zenml.zen_server.exceptions import error_response",
            "from zenml.zen_server.rbac.endpoint_utils import (",
            "    verify_permissions_and_create_entity,",
            ")",
            "from zenml.zen_server.rbac.models import Action, Resource, ResourceType",
            "from zenml.zen_server.rbac.utils import (",
            "    dehydrate_page,",
            "    dehydrate_response_model,",
            "    get_allowed_resource_ids,",
            "    get_schema_for_resource_type,",
            "    update_resource_membership,",
            "    verify_permission_for_model,",
            ")",
            "from zenml.zen_server.utils import (",
            "    handle_exceptions,",
            "    make_dependable,",
            "    server_config,",
            "    verify_admin_status_if_no_rbac,",
            "    zen_store,",
            ")",
            "",
            "logger = get_logger(__name__)",
            "",
            "router = APIRouter(",
            "    prefix=API + VERSION_1 + USERS,",
            "    tags=[\"users\"],",
            "    responses={401: error_response},",
            ")",
            "",
            "",
            "activation_router = APIRouter(",
            "    prefix=API + VERSION_1 + USERS,",
            "    tags=[\"users\"],",
            "    responses={401: error_response},",
            ")",
            "",
            "",
            "current_user_router = APIRouter(",
            "    prefix=API + VERSION_1,",
            "    tags=[\"users\"],",
            "    responses={401: error_response},",
            ")",
            "",
            "",
            "@router.get(",
            "    \"\",",
            "    response_model=Page[UserResponse],",
            "    responses={401: error_response, 404: error_response, 422: error_response},",
            ")",
            "@handle_exceptions",
            "def list_users(",
            "    user_filter_model: UserFilter = Depends(make_dependable(UserFilter)),",
            "    hydrate: bool = False,",
            "    auth_context: AuthContext = Security(authorize),",
            ") -> Page[UserResponse]:",
            "    \"\"\"Returns a list of all users.",
            "",
            "    Args:",
            "        user_filter_model: Model that takes care of filtering, sorting and",
            "            pagination.",
            "        hydrate: Flag deciding whether to hydrate the output model(s)",
            "            by including metadata fields in the response.",
            "        auth_context: Authentication context.",
            "",
            "    Returns:",
            "        A list of all users.",
            "    \"\"\"",
            "    allowed_ids = get_allowed_resource_ids(resource_type=ResourceType.USER)",
            "    if allowed_ids is not None:",
            "        # Make sure users can see themselves",
            "        allowed_ids.add(auth_context.user.id)",
            "    else:",
            "        if not auth_context.user.is_admin and not server_config().rbac_enabled:",
            "            allowed_ids = {auth_context.user.id}",
            "",
            "    user_filter_model.configure_rbac(",
            "        authenticated_user_id=auth_context.user.id, id=allowed_ids",
            "    )",
            "",
            "    page = zen_store().list_users(",
            "        user_filter_model=user_filter_model, hydrate=hydrate",
            "    )",
            "    return dehydrate_page(page)",
            "",
            "",
            "# When the auth scheme is set to EXTERNAL, users cannot be created via the",
            "# API.",
            "if server_config().auth_scheme != AuthScheme.EXTERNAL:",
            "",
            "    @router.post(",
            "        \"\",",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            409: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def create_user(",
            "        user: UserRequest,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Creates a user.",
            "",
            "        # noqa: DAR401",
            "",
            "        Args:",
            "            user: User to create.",
            "            auth_context: Authentication context.",
            "",
            "        Returns:",
            "            The created user.",
            "        \"\"\"",
            "        # Two ways of creating a new user:",
            "        # 1. Create a new user with a password and have it immediately active",
            "        # 2. Create a new user without a password and have it activated at a",
            "        # later time with an activation token",
            "",
            "        token: Optional[str] = None",
            "        if user.password is None:",
            "            user.active = False",
            "            token = user.generate_activation_token()",
            "        else:",
            "            user.active = True",
            "",
            "        verify_admin_status_if_no_rbac(",
            "            auth_context.user.is_admin, \"create user\"",
            "        )",
            "",
            "        new_user = verify_permissions_and_create_entity(",
            "            request_model=user,",
            "            resource_type=ResourceType.USER,",
            "            create_method=zen_store().create_user,",
            "        )",
            "",
            "        # add back the original unhashed activation token, if generated, to",
            "        # send it back to the client",
            "        if token:",
            "            new_user.get_body().activation_token = token",
            "        return new_user",
            "",
            "",
            "@router.get(",
            "    \"/{user_name_or_id}\",",
            "    response_model=UserResponse,",
            "    responses={401: error_response, 404: error_response, 422: error_response},",
            ")",
            "@handle_exceptions",
            "def get_user(",
            "    user_name_or_id: Union[str, UUID],",
            "    hydrate: bool = True,",
            "    auth_context: AuthContext = Security(authorize),",
            ") -> UserResponse:",
            "    \"\"\"Returns a specific user.",
            "",
            "    Args:",
            "        user_name_or_id: Name or ID of the user.",
            "        hydrate: Flag deciding whether to hydrate the output model(s)",
            "            by including metadata fields in the response.",
            "        auth_context: Authentication context.",
            "",
            "    Returns:",
            "        A specific user.",
            "    \"\"\"",
            "    user = zen_store().get_user(",
            "        user_name_or_id=user_name_or_id, hydrate=hydrate",
            "    )",
            "    if user.id != auth_context.user.id:",
            "        verify_admin_status_if_no_rbac(",
            "            auth_context.user.is_admin, \"get other user\"",
            "        )",
            "        verify_permission_for_model(",
            "            user,",
            "            action=Action.READ,",
            "        )",
            "",
            "    return dehydrate_response_model(user)",
            "",
            "",
            "# When the auth scheme is set to EXTERNAL, users cannot be updated via the",
            "# API.",
            "if server_config().auth_scheme != AuthScheme.EXTERNAL:",
            "",
            "    @router.put(",
            "        \"/{user_name_or_id}\",",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def update_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        user_update: UserUpdate,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Updates a specific user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            user_update: the user to use for the update.",
            "            auth_context: Authentication context.",
            "",
            "        Returns:",
            "            The updated user.",
            "",
            "        Raises:",
            "            IllegalOperationError: if the user tries change admin status,",
            "                while not an admin, if the user tries to change the password",
            "                of another user, or if the user tries to change their own",
            "                password without providing the old password or providing",
            "                an incorrect old password.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "        if user.id != auth_context.user.id:",
            "            verify_admin_status_if_no_rbac(",
            "                auth_context.user.is_admin, \"update other user\"",
            "            )",
            "            verify_permission_for_model(",
            "                user,",
            "                action=Action.UPDATE,",
            "            )",
            "",
            "            if user_update.password is not None:",
            "                raise IllegalOperationError(",
            "                    \"Users cannot change the password of other users. Use the \"",
            "                    \"account deactivation and activation flow instead.\"",
            "                )",
            "",
            "        elif user_update.password is not None:",
            "            # If the user is updating their own password, we need to verify",
            "            # the old password",
            "            if user_update.old_password is None:",
            "                raise IllegalOperationError(",
            "                    \"The current password must be supplied when changing the \"",
            "                    \"password.\"",
            "                )",
            "            auth_user = zen_store().get_auth_user(user_name_or_id)",
            "            if not UserAuthModel.verify_password(",
            "                user_update.old_password, auth_user",
            "            ):",
            "                raise IllegalOperationError(",
            "                    \"The current password is incorrect.\"",
            "                )",
            "",
            "        if (",
            "            user_update.is_admin is not None",
            "            and user.is_admin != user_update.is_admin",
            "            and not auth_context.user.is_admin",
            "        ):",
            "            raise IllegalOperationError(",
            "                \"Only admins can change the admin status of other users.\"",
            "            )",
            "",
            "        user_update.activation_token = user.activation_token",
            "        if not auth_context.user.is_admin or user.id == auth_context.user.id:",
            "            user_update.active = user.active",
            "        updated_user = zen_store().update_user(",
            "            user_id=user.id,",
            "            user_update=user_update,",
            "        )",
            "        return dehydrate_response_model(updated_user)",
            "",
            "    @activation_router.put(",
            "        \"/{user_name_or_id}\" + ACTIVATE,",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def activate_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        user_update: UserUpdate,",
            "    ) -> UserResponse:",
            "        \"\"\"Activates a specific user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            user_update: the user to use for the update.",
            "",
            "        Returns:",
            "            The updated user.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "",
            "        # NOTE: if the activation token is not set, this will raise an",
            "        # exception",
            "        authenticate_credentials(",
            "            user_name_or_id=user_name_or_id,",
            "            activation_token=user_update.activation_token,",
            "        )",
            "        user_update.active = True",
            "        user_update.activation_token = None",
            "        user_update.is_admin = user.is_admin",
            "        return zen_store().update_user(",
            "            user_id=user.id, user_update=user_update",
            "        )",
            "",
            "    @router.put(",
            "        \"/{user_name_or_id}\" + DEACTIVATE,",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def deactivate_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Deactivates a user and generates a new activation token for it.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            auth_context: Authentication context.",
            "",
            "        Returns:",
            "            The generated activation token.",
            "",
            "        Raises:",
            "            IllegalOperationError: if the user is trying to deactivate",
            "                themselves.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "        if user.id == auth_context.user.id:",
            "            raise IllegalOperationError(\"Cannot deactivate yourself.\")",
            "        verify_admin_status_if_no_rbac(",
            "            auth_context.user.is_admin, \"deactivate user\"",
            "        )",
            "        verify_permission_for_model(",
            "            user,",
            "            action=Action.UPDATE,",
            "        )",
            "",
            "        user_update = UserUpdate(",
            "            name=user.name,",
            "            active=False,",
            "        )",
            "        token = user_update.generate_activation_token()",
            "        user = zen_store().update_user(",
            "            user_id=user.id, user_update=user_update",
            "        )",
            "        # add back the original unhashed activation token",
            "        user.get_body().activation_token = token",
            "        return dehydrate_response_model(user)",
            "",
            "    @router.delete(",
            "        \"/{user_name_or_id}\",",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def delete_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> None:",
            "        \"\"\"Deletes a specific user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            auth_context: The authentication context.",
            "",
            "        Raises:",
            "            IllegalOperationError: If the user is not authorized to delete the user.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "",
            "        if auth_context.user.id == user.id:",
            "            raise IllegalOperationError(",
            "                \"You cannot delete the user account currently used to authenticate \"",
            "                \"to the ZenML server. If you wish to delete this account, \"",
            "                \"please authenticate with another account or contact your ZenML \"",
            "                \"administrator.\"",
            "            )",
            "        else:",
            "            verify_admin_status_if_no_rbac(",
            "                auth_context.user.is_admin, \"delete user\"",
            "            )",
            "            verify_permission_for_model(",
            "                user,",
            "                action=Action.DELETE,",
            "            )",
            "",
            "        zen_store().delete_user(user_name_or_id=user_name_or_id)",
            "",
            "    @router.put(",
            "        \"/{user_name_or_id}\" + EMAIL_ANALYTICS,",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def email_opt_in_response(",
            "        user_name_or_id: Union[str, UUID],",
            "        user_response: UserUpdate,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Sets the response of the user to the email prompt.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            user_response: User Response to email prompt",
            "            auth_context: The authentication context of the user",
            "",
            "        Returns:",
            "            The updated user.",
            "",
            "        Raises:",
            "            AuthorizationException: if the user does not have the required",
            "                permissions",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "",
            "        if str(auth_context.user.id) == str(user_name_or_id):",
            "            user_update = UserUpdate(",
            "                name=user.name,",
            "                email=user_response.email,",
            "                email_opted_in=user_response.email_opted_in,",
            "            )",
            "",
            "            if user_response.email_opted_in is not None:",
            "                email_opt_int(",
            "                    opted_in=user_response.email_opted_in,",
            "                    email=user_response.email,",
            "                    source=\"zenml server\",",
            "                )",
            "            updated_user = zen_store().update_user(",
            "                user_id=user.id, user_update=user_update",
            "            )",
            "            return dehydrate_response_model(updated_user)",
            "        else:",
            "            raise AuthorizationException(",
            "                \"Users can not opt in on behalf of another user.\"",
            "            )",
            "",
            "",
            "@current_user_router.get(",
            "    \"/current-user\",",
            "    response_model=UserResponse,",
            "    responses={401: error_response, 404: error_response, 422: error_response},",
            ")",
            "@handle_exceptions",
            "def get_current_user(",
            "    auth_context: AuthContext = Security(authorize),",
            ") -> UserResponse:",
            "    \"\"\"Returns the model of the authenticated user.",
            "",
            "    Args:",
            "        auth_context: The authentication context.",
            "",
            "    Returns:",
            "        The model of the authenticated user.",
            "    \"\"\"",
            "    return dehydrate_response_model(auth_context.user)",
            "",
            "",
            "# When the auth scheme is set to EXTERNAL, users cannot be managed via the",
            "# API.",
            "if server_config().auth_scheme != AuthScheme.EXTERNAL:",
            "",
            "    @current_user_router.put(",
            "        \"/current-user\",",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def update_myself(",
            "        user: UserUpdate,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Updates a specific user.",
            "",
            "        Args:",
            "            user: the user to use for the update.",
            "            auth_context: The authentication context.",
            "",
            "        Returns:",
            "            The updated user.",
            "",
            "        Raises:",
            "            IllegalOperationError: if the current password is not supplied when",
            "                changing the password or if the current password is incorrect.",
            "        \"\"\"",
            "        current_user = zen_store().get_user(auth_context.user.id)",
            "",
            "        if user.password is not None:",
            "            # If the user is updating their password, we need to verify",
            "            # the old password",
            "            if user.old_password is None:",
            "                raise IllegalOperationError(",
            "                    \"The current password must be supplied when changing the \"",
            "                    \"password.\"",
            "                )",
            "            auth_user = zen_store().get_auth_user(auth_context.user.id)",
            "            if not UserAuthModel.verify_password(user.old_password, auth_user):",
            "                raise IllegalOperationError(",
            "                    \"The current password is incorrect.\"",
            "                )",
            "",
            "        user.activation_token = current_user.activation_token",
            "        user.active = current_user.active",
            "        user.is_admin = current_user.is_admin",
            "",
            "        updated_user = zen_store().update_user(",
            "            user_id=auth_context.user.id, user_update=user",
            "        )",
            "        return dehydrate_response_model(updated_user)",
            "",
            "",
            "if server_config().rbac_enabled:",
            "",
            "    @router.post(",
            "        \"/{user_name_or_id}/resource_membership\",",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def update_user_resource_membership(",
            "        user_name_or_id: Union[str, UUID],",
            "        resource_type: str,",
            "        resource_id: UUID,",
            "        actions: List[str],",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> None:",
            "        \"\"\"Updates resource memberships of a user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            resource_type: Type of the resource for which to update the",
            "                membership.",
            "            resource_id: ID of the resource for which to update the membership.",
            "            actions: List of actions that the user should be able to perform on",
            "                the resource. If the user currently has permissions to perform",
            "                actions which are not passed in this list, the permissions will",
            "                be removed.",
            "            auth_context: Authentication context.",
            "",
            "        Raises:",
            "            ValueError: If a user tries to update their own membership.",
            "            KeyError: If no resource with the given type and ID exists.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "        verify_permission_for_model(user, action=Action.READ)",
            "",
            "        if user.id == auth_context.user.id:",
            "            raise ValueError(",
            "                \"Not allowed to call endpoint with the authenticated user.\"",
            "            )",
            "",
            "        resource_type = ResourceType(resource_type)",
            "        resource = Resource(type=resource_type, id=resource_id)",
            "",
            "        schema_class = get_schema_for_resource_type(resource_type)",
            "        model = zen_store().get_entity_by_id(",
            "            entity_id=resource_id, schema_class=schema_class",
            "        )",
            "",
            "        if not model:",
            "            raise KeyError(",
            "                f\"Resource of type {resource_type} with ID {resource_id} does \"",
            "                \"not exist.\"",
            "            )",
            "",
            "        verify_permission_for_model(model=model, action=Action.SHARE)",
            "        for action in actions:",
            "            # Make sure users aren't able to share permissions they don't have",
            "            # themselves",
            "            verify_permission_for_model(model=model, action=Action(action))",
            "",
            "        update_resource_membership(",
            "            user=user,",
            "            resource=resource,",
            "            actions=[Action(action) for action in actions],",
            "        )"
        ],
        "afterPatchFile": [
            "#  Copyright (c) ZenML GmbH 2022. All Rights Reserved.",
            "#",
            "#  Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#  you may not use this file except in compliance with the License.",
            "#  You may obtain a copy of the License at:",
            "#",
            "#       https://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#  Unless required by applicable law or agreed to in writing, software",
            "#  distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express",
            "#  or implied. See the License for the specific language governing",
            "#  permissions and limitations under the License.",
            "\"\"\"Endpoint definitions for users.\"\"\"",
            "",
            "from typing import List, Optional, Union",
            "from uuid import UUID",
            "",
            "from fastapi import APIRouter, Depends, Security",
            "from starlette.requests import Request",
            "",
            "from zenml.analytics.utils import email_opt_int",
            "from zenml.constants import (",
            "    ACTIVATE,",
            "    API,",
            "    DEACTIVATE,",
            "    EMAIL_ANALYTICS,",
            "    USERS,",
            "    VERSION_1,",
            ")",
            "from zenml.enums import AuthScheme",
            "from zenml.exceptions import AuthorizationException, IllegalOperationError",
            "from zenml.logger import get_logger",
            "from zenml.models import (",
            "    Page,",
            "    UserAuthModel,",
            "    UserFilter,",
            "    UserRequest,",
            "    UserResponse,",
            "    UserUpdate,",
            ")",
            "from zenml.zen_server.auth import (",
            "    AuthContext,",
            "    authenticate_credentials,",
            "    authorize,",
            ")",
            "from zenml.zen_server.exceptions import error_response",
            "from zenml.zen_server.rate_limit import RequestLimiter",
            "from zenml.zen_server.rbac.endpoint_utils import (",
            "    verify_permissions_and_create_entity,",
            ")",
            "from zenml.zen_server.rbac.models import Action, Resource, ResourceType",
            "from zenml.zen_server.rbac.utils import (",
            "    dehydrate_page,",
            "    dehydrate_response_model,",
            "    get_allowed_resource_ids,",
            "    get_schema_for_resource_type,",
            "    update_resource_membership,",
            "    verify_permission_for_model,",
            ")",
            "from zenml.zen_server.utils import (",
            "    handle_exceptions,",
            "    make_dependable,",
            "    server_config,",
            "    verify_admin_status_if_no_rbac,",
            "    zen_store,",
            ")",
            "",
            "logger = get_logger(__name__)",
            "",
            "router = APIRouter(",
            "    prefix=API + VERSION_1 + USERS,",
            "    tags=[\"users\"],",
            "    responses={401: error_response},",
            ")",
            "",
            "",
            "activation_router = APIRouter(",
            "    prefix=API + VERSION_1 + USERS,",
            "    tags=[\"users\"],",
            "    responses={401: error_response},",
            ")",
            "",
            "",
            "current_user_router = APIRouter(",
            "    prefix=API + VERSION_1,",
            "    tags=[\"users\"],",
            "    responses={401: error_response},",
            ")",
            "",
            "",
            "@router.get(",
            "    \"\",",
            "    response_model=Page[UserResponse],",
            "    responses={401: error_response, 404: error_response, 422: error_response},",
            ")",
            "@handle_exceptions",
            "def list_users(",
            "    user_filter_model: UserFilter = Depends(make_dependable(UserFilter)),",
            "    hydrate: bool = False,",
            "    auth_context: AuthContext = Security(authorize),",
            ") -> Page[UserResponse]:",
            "    \"\"\"Returns a list of all users.",
            "",
            "    Args:",
            "        user_filter_model: Model that takes care of filtering, sorting and",
            "            pagination.",
            "        hydrate: Flag deciding whether to hydrate the output model(s)",
            "            by including metadata fields in the response.",
            "        auth_context: Authentication context.",
            "",
            "    Returns:",
            "        A list of all users.",
            "    \"\"\"",
            "    allowed_ids = get_allowed_resource_ids(resource_type=ResourceType.USER)",
            "    if allowed_ids is not None:",
            "        # Make sure users can see themselves",
            "        allowed_ids.add(auth_context.user.id)",
            "    else:",
            "        if not auth_context.user.is_admin and not server_config().rbac_enabled:",
            "            allowed_ids = {auth_context.user.id}",
            "",
            "    user_filter_model.configure_rbac(",
            "        authenticated_user_id=auth_context.user.id, id=allowed_ids",
            "    )",
            "",
            "    page = zen_store().list_users(",
            "        user_filter_model=user_filter_model, hydrate=hydrate",
            "    )",
            "    return dehydrate_page(page)",
            "",
            "",
            "# When the auth scheme is set to EXTERNAL, users cannot be created via the",
            "# API.",
            "if server_config().auth_scheme != AuthScheme.EXTERNAL:",
            "",
            "    @router.post(",
            "        \"\",",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            409: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def create_user(",
            "        user: UserRequest,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Creates a user.",
            "",
            "        # noqa: DAR401",
            "",
            "        Args:",
            "            user: User to create.",
            "            auth_context: Authentication context.",
            "",
            "        Returns:",
            "            The created user.",
            "        \"\"\"",
            "        # Two ways of creating a new user:",
            "        # 1. Create a new user with a password and have it immediately active",
            "        # 2. Create a new user without a password and have it activated at a",
            "        # later time with an activation token",
            "",
            "        token: Optional[str] = None",
            "        if user.password is None:",
            "            user.active = False",
            "            token = user.generate_activation_token()",
            "        else:",
            "            user.active = True",
            "",
            "        verify_admin_status_if_no_rbac(",
            "            auth_context.user.is_admin, \"create user\"",
            "        )",
            "",
            "        new_user = verify_permissions_and_create_entity(",
            "            request_model=user,",
            "            resource_type=ResourceType.USER,",
            "            create_method=zen_store().create_user,",
            "        )",
            "",
            "        # add back the original unhashed activation token, if generated, to",
            "        # send it back to the client",
            "        if token:",
            "            new_user.get_body().activation_token = token",
            "        return new_user",
            "",
            "",
            "@router.get(",
            "    \"/{user_name_or_id}\",",
            "    response_model=UserResponse,",
            "    responses={401: error_response, 404: error_response, 422: error_response},",
            ")",
            "@handle_exceptions",
            "def get_user(",
            "    user_name_or_id: Union[str, UUID],",
            "    hydrate: bool = True,",
            "    auth_context: AuthContext = Security(authorize),",
            ") -> UserResponse:",
            "    \"\"\"Returns a specific user.",
            "",
            "    Args:",
            "        user_name_or_id: Name or ID of the user.",
            "        hydrate: Flag deciding whether to hydrate the output model(s)",
            "            by including metadata fields in the response.",
            "        auth_context: Authentication context.",
            "",
            "    Returns:",
            "        A specific user.",
            "    \"\"\"",
            "    user = zen_store().get_user(",
            "        user_name_or_id=user_name_or_id, hydrate=hydrate",
            "    )",
            "    if user.id != auth_context.user.id:",
            "        verify_admin_status_if_no_rbac(",
            "            auth_context.user.is_admin, \"get other user\"",
            "        )",
            "        verify_permission_for_model(",
            "            user,",
            "            action=Action.READ,",
            "        )",
            "",
            "    return dehydrate_response_model(user)",
            "",
            "",
            "# When the auth scheme is set to EXTERNAL, users cannot be updated via the",
            "# API.",
            "if server_config().auth_scheme != AuthScheme.EXTERNAL:",
            "    pass_change_limiter = RequestLimiter(",
            "        day_limit=server_config().login_rate_limit_day,",
            "        minute_limit=server_config().login_rate_limit_minute,",
            "    )",
            "",
            "    @router.put(",
            "        \"/{user_name_or_id}\",",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def update_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        user_update: UserUpdate,",
            "        request: Request,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Updates a specific user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            user_update: the user to use for the update.",
            "            request: The request object.",
            "            auth_context: Authentication context.",
            "",
            "        Returns:",
            "            The updated user.",
            "",
            "        Raises:",
            "            IllegalOperationError: if the user tries change admin status,",
            "                while not an admin, if the user tries to change the password",
            "                of another user, or if the user tries to change their own",
            "                password without providing the old password or providing",
            "                an incorrect old password.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "        if user.id != auth_context.user.id:",
            "            verify_admin_status_if_no_rbac(",
            "                auth_context.user.is_admin, \"update other user\"",
            "            )",
            "            verify_permission_for_model(",
            "                user,",
            "                action=Action.UPDATE,",
            "            )",
            "",
            "            if user_update.password is not None:",
            "                raise IllegalOperationError(",
            "                    \"Users cannot change the password of other users. Use the \"",
            "                    \"account deactivation and activation flow instead.\"",
            "                )",
            "",
            "        elif user_update.password is not None:",
            "            # If the user is updating their own password, we need to verify",
            "            # the old password",
            "            if user_update.old_password is None:",
            "                raise IllegalOperationError(",
            "                    \"The current password must be supplied when changing the \"",
            "                    \"password.\"",
            "                )",
            "",
            "            with pass_change_limiter.limit_failed_requests(request):",
            "                auth_user = zen_store().get_auth_user(user_name_or_id)",
            "                if not UserAuthModel.verify_password(",
            "                    user_update.old_password, auth_user",
            "                ):",
            "                    raise IllegalOperationError(",
            "                        \"The current password is incorrect.\"",
            "                    )",
            "",
            "        if (",
            "            user_update.is_admin is not None",
            "            and user.is_admin != user_update.is_admin",
            "            and not auth_context.user.is_admin",
            "        ):",
            "            raise IllegalOperationError(",
            "                \"Only admins can change the admin status of other users.\"",
            "            )",
            "",
            "        user_update.activation_token = user.activation_token",
            "        if not auth_context.user.is_admin or user.id == auth_context.user.id:",
            "            user_update.active = user.active",
            "        updated_user = zen_store().update_user(",
            "            user_id=user.id,",
            "            user_update=user_update,",
            "        )",
            "        return dehydrate_response_model(updated_user)",
            "",
            "    @activation_router.put(",
            "        \"/{user_name_or_id}\" + ACTIVATE,",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def activate_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        user_update: UserUpdate,",
            "    ) -> UserResponse:",
            "        \"\"\"Activates a specific user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            user_update: the user to use for the update.",
            "",
            "        Returns:",
            "            The updated user.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "",
            "        # NOTE: if the activation token is not set, this will raise an",
            "        # exception",
            "        authenticate_credentials(",
            "            user_name_or_id=user_name_or_id,",
            "            activation_token=user_update.activation_token,",
            "        )",
            "        user_update.active = True",
            "        user_update.activation_token = None",
            "        user_update.is_admin = user.is_admin",
            "        return zen_store().update_user(",
            "            user_id=user.id, user_update=user_update",
            "        )",
            "",
            "    @router.put(",
            "        \"/{user_name_or_id}\" + DEACTIVATE,",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def deactivate_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Deactivates a user and generates a new activation token for it.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            auth_context: Authentication context.",
            "",
            "        Returns:",
            "            The generated activation token.",
            "",
            "        Raises:",
            "            IllegalOperationError: if the user is trying to deactivate",
            "                themselves.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "        if user.id == auth_context.user.id:",
            "            raise IllegalOperationError(\"Cannot deactivate yourself.\")",
            "        verify_admin_status_if_no_rbac(",
            "            auth_context.user.is_admin, \"deactivate user\"",
            "        )",
            "        verify_permission_for_model(",
            "            user,",
            "            action=Action.UPDATE,",
            "        )",
            "",
            "        user_update = UserUpdate(",
            "            name=user.name,",
            "            active=False,",
            "        )",
            "        token = user_update.generate_activation_token()",
            "        user = zen_store().update_user(",
            "            user_id=user.id, user_update=user_update",
            "        )",
            "        # add back the original unhashed activation token",
            "        user.get_body().activation_token = token",
            "        return dehydrate_response_model(user)",
            "",
            "    @router.delete(",
            "        \"/{user_name_or_id}\",",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def delete_user(",
            "        user_name_or_id: Union[str, UUID],",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> None:",
            "        \"\"\"Deletes a specific user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            auth_context: The authentication context.",
            "",
            "        Raises:",
            "            IllegalOperationError: If the user is not authorized to delete the user.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "",
            "        if auth_context.user.id == user.id:",
            "            raise IllegalOperationError(",
            "                \"You cannot delete the user account currently used to authenticate \"",
            "                \"to the ZenML server. If you wish to delete this account, \"",
            "                \"please authenticate with another account or contact your ZenML \"",
            "                \"administrator.\"",
            "            )",
            "        else:",
            "            verify_admin_status_if_no_rbac(",
            "                auth_context.user.is_admin, \"delete user\"",
            "            )",
            "            verify_permission_for_model(",
            "                user,",
            "                action=Action.DELETE,",
            "            )",
            "",
            "        zen_store().delete_user(user_name_or_id=user_name_or_id)",
            "",
            "    @router.put(",
            "        \"/{user_name_or_id}\" + EMAIL_ANALYTICS,",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def email_opt_in_response(",
            "        user_name_or_id: Union[str, UUID],",
            "        user_response: UserUpdate,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Sets the response of the user to the email prompt.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            user_response: User Response to email prompt",
            "            auth_context: The authentication context of the user",
            "",
            "        Returns:",
            "            The updated user.",
            "",
            "        Raises:",
            "            AuthorizationException: if the user does not have the required",
            "                permissions",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "",
            "        if str(auth_context.user.id) == str(user_name_or_id):",
            "            user_update = UserUpdate(",
            "                name=user.name,",
            "                email=user_response.email,",
            "                email_opted_in=user_response.email_opted_in,",
            "            )",
            "",
            "            if user_response.email_opted_in is not None:",
            "                email_opt_int(",
            "                    opted_in=user_response.email_opted_in,",
            "                    email=user_response.email,",
            "                    source=\"zenml server\",",
            "                )",
            "            updated_user = zen_store().update_user(",
            "                user_id=user.id, user_update=user_update",
            "            )",
            "            return dehydrate_response_model(updated_user)",
            "        else:",
            "            raise AuthorizationException(",
            "                \"Users can not opt in on behalf of another user.\"",
            "            )",
            "",
            "",
            "@current_user_router.get(",
            "    \"/current-user\",",
            "    response_model=UserResponse,",
            "    responses={401: error_response, 404: error_response, 422: error_response},",
            ")",
            "@handle_exceptions",
            "def get_current_user(",
            "    auth_context: AuthContext = Security(authorize),",
            ") -> UserResponse:",
            "    \"\"\"Returns the model of the authenticated user.",
            "",
            "    Args:",
            "        auth_context: The authentication context.",
            "",
            "    Returns:",
            "        The model of the authenticated user.",
            "    \"\"\"",
            "    return dehydrate_response_model(auth_context.user)",
            "",
            "",
            "# When the auth scheme is set to EXTERNAL, users cannot be managed via the",
            "# API.",
            "if server_config().auth_scheme != AuthScheme.EXTERNAL:",
            "",
            "    @current_user_router.put(",
            "        \"/current-user\",",
            "        response_model=UserResponse,",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def update_myself(",
            "        user: UserUpdate,",
            "        request: Request,",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> UserResponse:",
            "        \"\"\"Updates a specific user.",
            "",
            "        Args:",
            "            user: the user to use for the update.",
            "            request: The request object.",
            "            auth_context: The authentication context.",
            "",
            "        Returns:",
            "            The updated user.",
            "",
            "        Raises:",
            "            IllegalOperationError: if the current password is not supplied when",
            "                changing the password or if the current password is incorrect.",
            "        \"\"\"",
            "        current_user = zen_store().get_user(auth_context.user.id)",
            "",
            "        if user.password is not None:",
            "            # If the user is updating their password, we need to verify",
            "            # the old password",
            "            if user.old_password is None:",
            "                raise IllegalOperationError(",
            "                    \"The current password must be supplied when changing the \"",
            "                    \"password.\"",
            "                )",
            "            with pass_change_limiter.limit_failed_requests(request):",
            "                auth_user = zen_store().get_auth_user(auth_context.user.id)",
            "                if not UserAuthModel.verify_password(",
            "                    user.old_password, auth_user",
            "                ):",
            "                    raise IllegalOperationError(",
            "                        \"The current password is incorrect.\"",
            "                    )",
            "",
            "        user.activation_token = current_user.activation_token",
            "        user.active = current_user.active",
            "        user.is_admin = current_user.is_admin",
            "",
            "        updated_user = zen_store().update_user(",
            "            user_id=auth_context.user.id, user_update=user",
            "        )",
            "        return dehydrate_response_model(updated_user)",
            "",
            "",
            "if server_config().rbac_enabled:",
            "",
            "    @router.post(",
            "        \"/{user_name_or_id}/resource_membership\",",
            "        responses={",
            "            401: error_response,",
            "            404: error_response,",
            "            422: error_response,",
            "        },",
            "    )",
            "    @handle_exceptions",
            "    def update_user_resource_membership(",
            "        user_name_or_id: Union[str, UUID],",
            "        resource_type: str,",
            "        resource_id: UUID,",
            "        actions: List[str],",
            "        auth_context: AuthContext = Security(authorize),",
            "    ) -> None:",
            "        \"\"\"Updates resource memberships of a user.",
            "",
            "        Args:",
            "            user_name_or_id: Name or ID of the user.",
            "            resource_type: Type of the resource for which to update the",
            "                membership.",
            "            resource_id: ID of the resource for which to update the membership.",
            "            actions: List of actions that the user should be able to perform on",
            "                the resource. If the user currently has permissions to perform",
            "                actions which are not passed in this list, the permissions will",
            "                be removed.",
            "            auth_context: Authentication context.",
            "",
            "        Raises:",
            "            ValueError: If a user tries to update their own membership.",
            "            KeyError: If no resource with the given type and ID exists.",
            "        \"\"\"",
            "        user = zen_store().get_user(user_name_or_id)",
            "        verify_permission_for_model(user, action=Action.READ)",
            "",
            "        if user.id == auth_context.user.id:",
            "            raise ValueError(",
            "                \"Not allowed to call endpoint with the authenticated user.\"",
            "            )",
            "",
            "        resource_type = ResourceType(resource_type)",
            "        resource = Resource(type=resource_type, id=resource_id)",
            "",
            "        schema_class = get_schema_for_resource_type(resource_type)",
            "        model = zen_store().get_entity_by_id(",
            "            entity_id=resource_id, schema_class=schema_class",
            "        )",
            "",
            "        if not model:",
            "            raise KeyError(",
            "                f\"Resource of type {resource_type} with ID {resource_id} does \"",
            "                \"not exist.\"",
            "            )",
            "",
            "        verify_permission_for_model(model=model, action=Action.SHARE)",
            "        for action in actions:",
            "            # Make sure users aren't able to share permissions they don't have",
            "            # themselves",
            "            verify_permission_for_model(model=model, action=Action(action))",
            "",
            "        update_resource_membership(",
            "            user=user,",
            "            resource=resource,",
            "            actions=[Action(action) for action in actions],",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "286": [
                "update_user"
            ],
            "287": [
                "update_user"
            ],
            "288": [
                "update_user"
            ],
            "289": [
                "update_user"
            ],
            "290": [
                "update_user"
            ],
            "291": [
                "update_user"
            ],
            "292": [
                "update_user"
            ],
            "557": [
                "update_myself"
            ],
            "558": [
                "update_myself"
            ],
            "559": [
                "update_myself"
            ],
            "560": [
                "update_myself"
            ],
            "561": [
                "update_myself"
            ]
        },
        "addLocation": [
            "flask_cors.extension"
        ]
    }
}