{
    "jwt/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " )"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from .jwks_client import PyJWKClient"
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = \"2.3.0\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+__version__ = \"2.4.0\""
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " __title__ = \"PyJWT\""
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " __description__ = \"JSON Web Token implementation in Python\""
            }
        },
        "frontPatchFile": [
            "from .api_jwk import PyJWK, PyJWKSet",
            "from .api_jws import (",
            "    PyJWS,",
            "    get_unverified_header,",
            "    register_algorithm,",
            "    unregister_algorithm,",
            ")",
            "from .api_jwt import PyJWT, decode, encode",
            "from .exceptions import (",
            "    DecodeError,",
            "    ExpiredSignatureError,",
            "    ImmatureSignatureError,",
            "    InvalidAlgorithmError,",
            "    InvalidAudienceError,",
            "    InvalidIssuedAtError,",
            "    InvalidIssuerError,",
            "    InvalidKeyError,",
            "    InvalidSignatureError,",
            "    InvalidTokenError,",
            "    MissingRequiredClaimError,",
            "    PyJWKClientError,",
            "    PyJWKError,",
            "    PyJWKSetError,",
            "    PyJWTError,",
            ")",
            "from .jwks_client import PyJWKClient",
            "",
            "__version__ = \"2.3.0\"",
            "",
            "__title__ = \"PyJWT\"",
            "__description__ = \"JSON Web Token implementation in Python\"",
            "__url__ = \"https://pyjwt.readthedocs.io\"",
            "__uri__ = __url__",
            "__doc__ = f\"{__description__} <{__uri__}>\"",
            "",
            "__author__ = \"Jos\u00e9 Padilla\"",
            "__email__ = \"hello@jpadilla.com\"",
            "",
            "__license__ = \"MIT\"",
            "__copyright__ = \"Copyright 2015-2022 Jos\u00e9 Padilla\"",
            "",
            "",
            "__all__ = [",
            "    \"PyJWS\",",
            "    \"PyJWT\",",
            "    \"PyJWKClient\",",
            "    \"PyJWK\",",
            "    \"PyJWKSet\",",
            "    \"decode\",",
            "    \"encode\",",
            "    \"get_unverified_header\",",
            "    \"register_algorithm\",",
            "    \"unregister_algorithm\",",
            "    # Exceptions",
            "    \"DecodeError\",",
            "    \"ExpiredSignatureError\",",
            "    \"ImmatureSignatureError\",",
            "    \"InvalidAlgorithmError\",",
            "    \"InvalidAudienceError\",",
            "    \"InvalidIssuedAtError\",",
            "    \"InvalidIssuerError\",",
            "    \"InvalidKeyError\",",
            "    \"InvalidSignatureError\",",
            "    \"InvalidTokenError\",",
            "    \"MissingRequiredClaimError\",",
            "    \"PyJWKClientError\",",
            "    \"PyJWKError\",",
            "    \"PyJWKSetError\",",
            "    \"PyJWTError\",",
            "]"
        ],
        "afterPatchFile": [
            "from .api_jwk import PyJWK, PyJWKSet",
            "from .api_jws import (",
            "    PyJWS,",
            "    get_unverified_header,",
            "    register_algorithm,",
            "    unregister_algorithm,",
            ")",
            "from .api_jwt import PyJWT, decode, encode",
            "from .exceptions import (",
            "    DecodeError,",
            "    ExpiredSignatureError,",
            "    ImmatureSignatureError,",
            "    InvalidAlgorithmError,",
            "    InvalidAudienceError,",
            "    InvalidIssuedAtError,",
            "    InvalidIssuerError,",
            "    InvalidKeyError,",
            "    InvalidSignatureError,",
            "    InvalidTokenError,",
            "    MissingRequiredClaimError,",
            "    PyJWKClientError,",
            "    PyJWKError,",
            "    PyJWKSetError,",
            "    PyJWTError,",
            ")",
            "from .jwks_client import PyJWKClient",
            "",
            "__version__ = \"2.4.0\"",
            "",
            "__title__ = \"PyJWT\"",
            "__description__ = \"JSON Web Token implementation in Python\"",
            "__url__ = \"https://pyjwt.readthedocs.io\"",
            "__uri__ = __url__",
            "__doc__ = f\"{__description__} <{__uri__}>\"",
            "",
            "__author__ = \"Jos\u00e9 Padilla\"",
            "__email__ = \"hello@jpadilla.com\"",
            "",
            "__license__ = \"MIT\"",
            "__copyright__ = \"Copyright 2015-2022 Jos\u00e9 Padilla\"",
            "",
            "",
            "__all__ = [",
            "    \"PyJWS\",",
            "    \"PyJWT\",",
            "    \"PyJWKClient\",",
            "    \"PyJWK\",",
            "    \"PyJWKSet\",",
            "    \"decode\",",
            "    \"encode\",",
            "    \"get_unverified_header\",",
            "    \"register_algorithm\",",
            "    \"unregister_algorithm\",",
            "    # Exceptions",
            "    \"DecodeError\",",
            "    \"ExpiredSignatureError\",",
            "    \"ImmatureSignatureError\",",
            "    \"InvalidAlgorithmError\",",
            "    \"InvalidAudienceError\",",
            "    \"InvalidIssuedAtError\",",
            "    \"InvalidIssuerError\",",
            "    \"InvalidKeyError\",",
            "    \"InvalidSignatureError\",",
            "    \"InvalidTokenError\",",
            "    \"MissingRequiredClaimError\",",
            "    \"PyJWKClientError\",",
            "    \"PyJWKError\",",
            "    \"PyJWKSetError\",",
            "    \"PyJWTError\",",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [
                "__version__"
            ]
        },
        "addLocation": []
    },
    "jwt/algorithms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     der_to_raw_signature,"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     force_bytes,"
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     from_base64url_uint,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+    is_pem_format,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    is_ssh_key,"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     raw_to_der_signature,"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     to_base64url_uint,"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " )"
            },
            "8": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     def prepare_key(self, key):"
            },
            "9": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         key = force_bytes(key)"
            },
            "10": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        invalid_strings = ["
            },
            "12": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            b\"-----BEGIN PUBLIC KEY-----\","
            },
            "13": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            b\"-----BEGIN CERTIFICATE-----\","
            },
            "14": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            b\"-----BEGIN RSA PUBLIC KEY-----\","
            },
            "15": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            b\"ssh-rsa\","
            },
            "16": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ]"
            },
            "17": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "18": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if any(string_value in key for string_value in invalid_strings):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        if is_pem_format(key) or is_ssh_key(key):"
            },
            "20": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             raise InvalidKeyError("
            },
            "21": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "                 \"The specified key is an asymmetric key or x509 certificate and\""
            },
            "22": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "                 \" should not be used as an HMAC secret.\""
            },
            "23": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "             pass"
            },
            "24": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 547,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "         def prepare_key(self, key):"
            },
            "26": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "27": {
                "beforePatchRowNumber": 555,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if isinstance("
            },
            "28": {
                "beforePatchRowNumber": 556,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                key,"
            },
            "29": {
                "beforePatchRowNumber": 557,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),"
            },
            "30": {
                "beforePatchRowNumber": 558,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ):"
            },
            "31": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return key"
            },
            "32": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "33": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": 549,
                "PatchRowcode": "             if isinstance(key, (bytes, str)):"
            },
            "34": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "                 if isinstance(key, str):"
            },
            "35": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "                     key = key.encode(\"utf-8\")"
            },
            "36": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 552,
                "PatchRowcode": "                 str_key = key.decode(\"utf-8\")"
            },
            "37": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 553,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 554,
                "PatchRowcode": "                 if \"-----BEGIN PUBLIC\" in str_key:"
            },
            "39": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return load_pem_public_key(key)"
            },
            "40": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if \"-----BEGIN PRIVATE\" in str_key:"
            },
            "41": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return load_pem_private_key(key, password=None)"
            },
            "42": {
                "beforePatchRowNumber": 570,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if str_key[0:4] == \"ssh-\":"
            },
            "43": {
                "beforePatchRowNumber": 571,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return load_ssh_public_key(key)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 555,
                "PatchRowcode": "+                    key = load_pem_public_key(key)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 556,
                "PatchRowcode": "+                elif \"-----BEGIN PRIVATE\" in str_key:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 557,
                "PatchRowcode": "+                    key = load_pem_private_key(key, password=None)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 558,
                "PatchRowcode": "+                elif str_key[0:4] == \"ssh-\":"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 559,
                "PatchRowcode": "+                    key = load_ssh_public_key(key)"
            },
            "49": {
                "beforePatchRowNumber": 572,
                "afterPatchRowNumber": 560,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 573,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise TypeError(\"Expecting a PEM-formatted or OpenSSH key.\")"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 561,
                "PatchRowcode": "+            # Explicit check the key to prevent confusing errors from cryptography"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 562,
                "PatchRowcode": "+            if not isinstance("
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 563,
                "PatchRowcode": "+                key,"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 564,
                "PatchRowcode": "+                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 565,
                "PatchRowcode": "+            ):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 566,
                "PatchRowcode": "+                raise InvalidKeyError("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for EdDSA algorithms\""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+                )"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 569,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+            return key"
            },
            "61": {
                "beforePatchRowNumber": 574,
                "afterPatchRowNumber": 571,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 575,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "         def sign(self, msg, key):"
            },
            "63": {
                "beforePatchRowNumber": 576,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "             \"\"\""
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "import hmac",
            "import json",
            "",
            "from .exceptions import InvalidKeyError",
            "from .utils import (",
            "    base64url_decode,",
            "    base64url_encode,",
            "    der_to_raw_signature,",
            "    force_bytes,",
            "    from_base64url_uint,",
            "    raw_to_der_signature,",
            "    to_base64url_uint,",
            ")",
            "",
            "try:",
            "    import cryptography.exceptions",
            "    from cryptography.exceptions import InvalidSignature",
            "    from cryptography.hazmat.primitives import hashes",
            "    from cryptography.hazmat.primitives.asymmetric import ec, padding",
            "    from cryptography.hazmat.primitives.asymmetric.ec import (",
            "        EllipticCurvePrivateKey,",
            "        EllipticCurvePublicKey,",
            "    )",
            "    from cryptography.hazmat.primitives.asymmetric.ed448 import (",
            "        Ed448PrivateKey,",
            "        Ed448PublicKey,",
            "    )",
            "    from cryptography.hazmat.primitives.asymmetric.ed25519 import (",
            "        Ed25519PrivateKey,",
            "        Ed25519PublicKey,",
            "    )",
            "    from cryptography.hazmat.primitives.asymmetric.rsa import (",
            "        RSAPrivateKey,",
            "        RSAPrivateNumbers,",
            "        RSAPublicKey,",
            "        RSAPublicNumbers,",
            "        rsa_crt_dmp1,",
            "        rsa_crt_dmq1,",
            "        rsa_crt_iqmp,",
            "        rsa_recover_prime_factors,",
            "    )",
            "    from cryptography.hazmat.primitives.serialization import (",
            "        Encoding,",
            "        NoEncryption,",
            "        PrivateFormat,",
            "        PublicFormat,",
            "        load_pem_private_key,",
            "        load_pem_public_key,",
            "        load_ssh_public_key,",
            "    )",
            "",
            "    has_crypto = True",
            "except ModuleNotFoundError:",
            "    has_crypto = False",
            "",
            "requires_cryptography = {",
            "    \"RS256\",",
            "    \"RS384\",",
            "    \"RS512\",",
            "    \"ES256\",",
            "    \"ES256K\",",
            "    \"ES384\",",
            "    \"ES521\",",
            "    \"ES512\",",
            "    \"PS256\",",
            "    \"PS384\",",
            "    \"PS512\",",
            "    \"EdDSA\",",
            "}",
            "",
            "",
            "def get_default_algorithms():",
            "    \"\"\"",
            "    Returns the algorithms that are implemented by the library.",
            "    \"\"\"",
            "    default_algorithms = {",
            "        \"none\": NoneAlgorithm(),",
            "        \"HS256\": HMACAlgorithm(HMACAlgorithm.SHA256),",
            "        \"HS384\": HMACAlgorithm(HMACAlgorithm.SHA384),",
            "        \"HS512\": HMACAlgorithm(HMACAlgorithm.SHA512),",
            "    }",
            "",
            "    if has_crypto:",
            "        default_algorithms.update(",
            "            {",
            "                \"RS256\": RSAAlgorithm(RSAAlgorithm.SHA256),",
            "                \"RS384\": RSAAlgorithm(RSAAlgorithm.SHA384),",
            "                \"RS512\": RSAAlgorithm(RSAAlgorithm.SHA512),",
            "                \"ES256\": ECAlgorithm(ECAlgorithm.SHA256),",
            "                \"ES256K\": ECAlgorithm(ECAlgorithm.SHA256),",
            "                \"ES384\": ECAlgorithm(ECAlgorithm.SHA384),",
            "                \"ES521\": ECAlgorithm(ECAlgorithm.SHA512),",
            "                \"ES512\": ECAlgorithm(",
            "                    ECAlgorithm.SHA512",
            "                ),  # Backward compat for #219 fix",
            "                \"PS256\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),",
            "                \"PS384\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),",
            "                \"PS512\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),",
            "                \"EdDSA\": OKPAlgorithm(),",
            "            }",
            "        )",
            "",
            "    return default_algorithms",
            "",
            "",
            "class Algorithm:",
            "    \"\"\"",
            "    The interface for an algorithm used to sign and verify tokens.",
            "    \"\"\"",
            "",
            "    def prepare_key(self, key):",
            "        \"\"\"",
            "        Performs necessary validation and conversions on the key and returns",
            "        the key value in the proper format for sign() and verify().",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def sign(self, msg, key):",
            "        \"\"\"",
            "        Returns a digital signature for the specified message",
            "        using the specified key value.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def verify(self, msg, key, sig):",
            "        \"\"\"",
            "        Verifies that the specified digital signature is valid",
            "        for the specified message and key values.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    def to_jwk(key_obj):",
            "        \"\"\"",
            "        Serializes a given RSA key into a JWK",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    def from_jwk(jwk):",
            "        \"\"\"",
            "        Deserializes a given RSA key from JWK back into a PublicKey or PrivateKey object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class NoneAlgorithm(Algorithm):",
            "    \"\"\"",
            "    Placeholder for use when no signing or verification",
            "    operations are required.",
            "    \"\"\"",
            "",
            "    def prepare_key(self, key):",
            "        if key == \"\":",
            "            key = None",
            "",
            "        if key is not None:",
            "            raise InvalidKeyError('When alg = \"none\", key value must be None.')",
            "",
            "        return key",
            "",
            "    def sign(self, msg, key):",
            "        return b\"\"",
            "",
            "    def verify(self, msg, key, sig):",
            "        return False",
            "",
            "",
            "class HMACAlgorithm(Algorithm):",
            "    \"\"\"",
            "    Performs signing and verification operations using HMAC",
            "    and the specified hash function.",
            "    \"\"\"",
            "",
            "    SHA256 = hashlib.sha256",
            "    SHA384 = hashlib.sha384",
            "    SHA512 = hashlib.sha512",
            "",
            "    def __init__(self, hash_alg):",
            "        self.hash_alg = hash_alg",
            "",
            "    def prepare_key(self, key):",
            "        key = force_bytes(key)",
            "",
            "        invalid_strings = [",
            "            b\"-----BEGIN PUBLIC KEY-----\",",
            "            b\"-----BEGIN CERTIFICATE-----\",",
            "            b\"-----BEGIN RSA PUBLIC KEY-----\",",
            "            b\"ssh-rsa\",",
            "        ]",
            "",
            "        if any(string_value in key for string_value in invalid_strings):",
            "            raise InvalidKeyError(",
            "                \"The specified key is an asymmetric key or x509 certificate and\"",
            "                \" should not be used as an HMAC secret.\"",
            "            )",
            "",
            "        return key",
            "",
            "    @staticmethod",
            "    def to_jwk(key_obj):",
            "        return json.dumps(",
            "            {",
            "                \"k\": base64url_encode(force_bytes(key_obj)).decode(),",
            "                \"kty\": \"oct\",",
            "            }",
            "        )",
            "",
            "    @staticmethod",
            "    def from_jwk(jwk):",
            "        try:",
            "            if isinstance(jwk, str):",
            "                obj = json.loads(jwk)",
            "            elif isinstance(jwk, dict):",
            "                obj = jwk",
            "            else:",
            "                raise ValueError",
            "        except ValueError:",
            "            raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "        if obj.get(\"kty\") != \"oct\":",
            "            raise InvalidKeyError(\"Not an HMAC key\")",
            "",
            "        return base64url_decode(obj[\"k\"])",
            "",
            "    def sign(self, msg, key):",
            "        return hmac.new(key, msg, self.hash_alg).digest()",
            "",
            "    def verify(self, msg, key, sig):",
            "        return hmac.compare_digest(sig, self.sign(msg, key))",
            "",
            "",
            "if has_crypto:",
            "",
            "    class RSAAlgorithm(Algorithm):",
            "        \"\"\"",
            "        Performs signing and verification operations using",
            "        RSASSA-PKCS-v1_5 and the specified hash function.",
            "        \"\"\"",
            "",
            "        SHA256 = hashes.SHA256",
            "        SHA384 = hashes.SHA384",
            "        SHA512 = hashes.SHA512",
            "",
            "        def __init__(self, hash_alg):",
            "            self.hash_alg = hash_alg",
            "",
            "        def prepare_key(self, key):",
            "            if isinstance(key, (RSAPrivateKey, RSAPublicKey)):",
            "                return key",
            "",
            "            if not isinstance(key, (bytes, str)):",
            "                raise TypeError(\"Expecting a PEM-formatted key.\")",
            "",
            "            key = force_bytes(key)",
            "",
            "            try:",
            "                if key.startswith(b\"ssh-rsa\"):",
            "                    key = load_ssh_public_key(key)",
            "                else:",
            "                    key = load_pem_private_key(key, password=None)",
            "            except ValueError:",
            "                key = load_pem_public_key(key)",
            "            return key",
            "",
            "        @staticmethod",
            "        def to_jwk(key_obj):",
            "            obj = None",
            "",
            "            if getattr(key_obj, \"private_numbers\", None):",
            "                # Private key",
            "                numbers = key_obj.private_numbers()",
            "",
            "                obj = {",
            "                    \"kty\": \"RSA\",",
            "                    \"key_ops\": [\"sign\"],",
            "                    \"n\": to_base64url_uint(numbers.public_numbers.n).decode(),",
            "                    \"e\": to_base64url_uint(numbers.public_numbers.e).decode(),",
            "                    \"d\": to_base64url_uint(numbers.d).decode(),",
            "                    \"p\": to_base64url_uint(numbers.p).decode(),",
            "                    \"q\": to_base64url_uint(numbers.q).decode(),",
            "                    \"dp\": to_base64url_uint(numbers.dmp1).decode(),",
            "                    \"dq\": to_base64url_uint(numbers.dmq1).decode(),",
            "                    \"qi\": to_base64url_uint(numbers.iqmp).decode(),",
            "                }",
            "",
            "            elif getattr(key_obj, \"verify\", None):",
            "                # Public key",
            "                numbers = key_obj.public_numbers()",
            "",
            "                obj = {",
            "                    \"kty\": \"RSA\",",
            "                    \"key_ops\": [\"verify\"],",
            "                    \"n\": to_base64url_uint(numbers.n).decode(),",
            "                    \"e\": to_base64url_uint(numbers.e).decode(),",
            "                }",
            "            else:",
            "                raise InvalidKeyError(\"Not a public or private key\")",
            "",
            "            return json.dumps(obj)",
            "",
            "        @staticmethod",
            "        def from_jwk(jwk):",
            "            try:",
            "                if isinstance(jwk, str):",
            "                    obj = json.loads(jwk)",
            "                elif isinstance(jwk, dict):",
            "                    obj = jwk",
            "                else:",
            "                    raise ValueError",
            "            except ValueError:",
            "                raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "            if obj.get(\"kty\") != \"RSA\":",
            "                raise InvalidKeyError(\"Not an RSA key\")",
            "",
            "            if \"d\" in obj and \"e\" in obj and \"n\" in obj:",
            "                # Private key",
            "                if \"oth\" in obj:",
            "                    raise InvalidKeyError(",
            "                        \"Unsupported RSA private key: > 2 primes not supported\"",
            "                    )",
            "",
            "                other_props = [\"p\", \"q\", \"dp\", \"dq\", \"qi\"]",
            "                props_found = [prop in obj for prop in other_props]",
            "                any_props_found = any(props_found)",
            "",
            "                if any_props_found and not all(props_found):",
            "                    raise InvalidKeyError(",
            "                        \"RSA key must include all parameters if any are present besides d\"",
            "                    )",
            "",
            "                public_numbers = RSAPublicNumbers(",
            "                    from_base64url_uint(obj[\"e\"]),",
            "                    from_base64url_uint(obj[\"n\"]),",
            "                )",
            "",
            "                if any_props_found:",
            "                    numbers = RSAPrivateNumbers(",
            "                        d=from_base64url_uint(obj[\"d\"]),",
            "                        p=from_base64url_uint(obj[\"p\"]),",
            "                        q=from_base64url_uint(obj[\"q\"]),",
            "                        dmp1=from_base64url_uint(obj[\"dp\"]),",
            "                        dmq1=from_base64url_uint(obj[\"dq\"]),",
            "                        iqmp=from_base64url_uint(obj[\"qi\"]),",
            "                        public_numbers=public_numbers,",
            "                    )",
            "                else:",
            "                    d = from_base64url_uint(obj[\"d\"])",
            "                    p, q = rsa_recover_prime_factors(",
            "                        public_numbers.n, d, public_numbers.e",
            "                    )",
            "",
            "                    numbers = RSAPrivateNumbers(",
            "                        d=d,",
            "                        p=p,",
            "                        q=q,",
            "                        dmp1=rsa_crt_dmp1(d, p),",
            "                        dmq1=rsa_crt_dmq1(d, q),",
            "                        iqmp=rsa_crt_iqmp(p, q),",
            "                        public_numbers=public_numbers,",
            "                    )",
            "",
            "                return numbers.private_key()",
            "            elif \"n\" in obj and \"e\" in obj:",
            "                # Public key",
            "                numbers = RSAPublicNumbers(",
            "                    from_base64url_uint(obj[\"e\"]),",
            "                    from_base64url_uint(obj[\"n\"]),",
            "                )",
            "",
            "                return numbers.public_key()",
            "            else:",
            "                raise InvalidKeyError(\"Not a public or private key\")",
            "",
            "        def sign(self, msg, key):",
            "            return key.sign(msg, padding.PKCS1v15(), self.hash_alg())",
            "",
            "        def verify(self, msg, key, sig):",
            "            try:",
            "                key.verify(sig, msg, padding.PKCS1v15(), self.hash_alg())",
            "                return True",
            "            except InvalidSignature:",
            "                return False",
            "",
            "    class ECAlgorithm(Algorithm):",
            "        \"\"\"",
            "        Performs signing and verification operations using",
            "        ECDSA and the specified hash function",
            "        \"\"\"",
            "",
            "        SHA256 = hashes.SHA256",
            "        SHA384 = hashes.SHA384",
            "        SHA512 = hashes.SHA512",
            "",
            "        def __init__(self, hash_alg):",
            "            self.hash_alg = hash_alg",
            "",
            "        def prepare_key(self, key):",
            "            if isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):",
            "                return key",
            "",
            "            if not isinstance(key, (bytes, str)):",
            "                raise TypeError(\"Expecting a PEM-formatted key.\")",
            "",
            "            key = force_bytes(key)",
            "",
            "            # Attempt to load key. We don't know if it's",
            "            # a Signing Key or a Verifying Key, so we try",
            "            # the Verifying Key first.",
            "            try:",
            "                if key.startswith(b\"ecdsa-sha2-\"):",
            "                    key = load_ssh_public_key(key)",
            "                else:",
            "                    key = load_pem_public_key(key)",
            "            except ValueError:",
            "                key = load_pem_private_key(key, password=None)",
            "",
            "            # Explicit check the key to prevent confusing errors from cryptography",
            "            if not isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):",
            "                raise InvalidKeyError(",
            "                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for ECDSA algorithms\"",
            "                )",
            "",
            "            return key",
            "",
            "        def sign(self, msg, key):",
            "            der_sig = key.sign(msg, ec.ECDSA(self.hash_alg()))",
            "",
            "            return der_to_raw_signature(der_sig, key.curve)",
            "",
            "        def verify(self, msg, key, sig):",
            "            try:",
            "                der_sig = raw_to_der_signature(sig, key.curve)",
            "            except ValueError:",
            "                return False",
            "",
            "            try:",
            "                if isinstance(key, EllipticCurvePrivateKey):",
            "                    key = key.public_key()",
            "                key.verify(der_sig, msg, ec.ECDSA(self.hash_alg()))",
            "                return True",
            "            except InvalidSignature:",
            "                return False",
            "",
            "        @staticmethod",
            "        def from_jwk(jwk):",
            "            try:",
            "                if isinstance(jwk, str):",
            "                    obj = json.loads(jwk)",
            "                elif isinstance(jwk, dict):",
            "                    obj = jwk",
            "                else:",
            "                    raise ValueError",
            "            except ValueError:",
            "                raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "            if obj.get(\"kty\") != \"EC\":",
            "                raise InvalidKeyError(\"Not an Elliptic curve key\")",
            "",
            "            if \"x\" not in obj or \"y\" not in obj:",
            "                raise InvalidKeyError(\"Not an Elliptic curve key\")",
            "",
            "            x = base64url_decode(obj.get(\"x\"))",
            "            y = base64url_decode(obj.get(\"y\"))",
            "",
            "            curve = obj.get(\"crv\")",
            "            if curve == \"P-256\":",
            "                if len(x) == len(y) == 32:",
            "                    curve_obj = ec.SECP256R1()",
            "                else:",
            "                    raise InvalidKeyError(\"Coords should be 32 bytes for curve P-256\")",
            "            elif curve == \"P-384\":",
            "                if len(x) == len(y) == 48:",
            "                    curve_obj = ec.SECP384R1()",
            "                else:",
            "                    raise InvalidKeyError(\"Coords should be 48 bytes for curve P-384\")",
            "            elif curve == \"P-521\":",
            "                if len(x) == len(y) == 66:",
            "                    curve_obj = ec.SECP521R1()",
            "                else:",
            "                    raise InvalidKeyError(\"Coords should be 66 bytes for curve P-521\")",
            "            elif curve == \"secp256k1\":",
            "                if len(x) == len(y) == 32:",
            "                    curve_obj = ec.SECP256K1()",
            "                else:",
            "                    raise InvalidKeyError(",
            "                        \"Coords should be 32 bytes for curve secp256k1\"",
            "                    )",
            "            else:",
            "                raise InvalidKeyError(f\"Invalid curve: {curve}\")",
            "",
            "            public_numbers = ec.EllipticCurvePublicNumbers(",
            "                x=int.from_bytes(x, byteorder=\"big\"),",
            "                y=int.from_bytes(y, byteorder=\"big\"),",
            "                curve=curve_obj,",
            "            )",
            "",
            "            if \"d\" not in obj:",
            "                return public_numbers.public_key()",
            "",
            "            d = base64url_decode(obj.get(\"d\"))",
            "            if len(d) != len(x):",
            "                raise InvalidKeyError(",
            "                    \"D should be {} bytes for curve {}\", len(x), curve",
            "                )",
            "",
            "            return ec.EllipticCurvePrivateNumbers(",
            "                int.from_bytes(d, byteorder=\"big\"), public_numbers",
            "            ).private_key()",
            "",
            "    class RSAPSSAlgorithm(RSAAlgorithm):",
            "        \"\"\"",
            "        Performs a signature using RSASSA-PSS with MGF1",
            "        \"\"\"",
            "",
            "        def sign(self, msg, key):",
            "            return key.sign(",
            "                msg,",
            "                padding.PSS(",
            "                    mgf=padding.MGF1(self.hash_alg()),",
            "                    salt_length=self.hash_alg.digest_size,",
            "                ),",
            "                self.hash_alg(),",
            "            )",
            "",
            "        def verify(self, msg, key, sig):",
            "            try:",
            "                key.verify(",
            "                    sig,",
            "                    msg,",
            "                    padding.PSS(",
            "                        mgf=padding.MGF1(self.hash_alg()),",
            "                        salt_length=self.hash_alg.digest_size,",
            "                    ),",
            "                    self.hash_alg(),",
            "                )",
            "                return True",
            "            except InvalidSignature:",
            "                return False",
            "",
            "    class OKPAlgorithm(Algorithm):",
            "        \"\"\"",
            "        Performs signing and verification operations using EdDSA",
            "",
            "        This class requires ``cryptography>=2.6`` to be installed.",
            "        \"\"\"",
            "",
            "        def __init__(self, **kwargs):",
            "            pass",
            "",
            "        def prepare_key(self, key):",
            "",
            "            if isinstance(",
            "                key,",
            "                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),",
            "            ):",
            "                return key",
            "",
            "            if isinstance(key, (bytes, str)):",
            "                if isinstance(key, str):",
            "                    key = key.encode(\"utf-8\")",
            "                str_key = key.decode(\"utf-8\")",
            "",
            "                if \"-----BEGIN PUBLIC\" in str_key:",
            "                    return load_pem_public_key(key)",
            "                if \"-----BEGIN PRIVATE\" in str_key:",
            "                    return load_pem_private_key(key, password=None)",
            "                if str_key[0:4] == \"ssh-\":",
            "                    return load_ssh_public_key(key)",
            "",
            "            raise TypeError(\"Expecting a PEM-formatted or OpenSSH key.\")",
            "",
            "        def sign(self, msg, key):",
            "            \"\"\"",
            "            Sign a message ``msg`` using the EdDSA private key ``key``",
            "            :param str|bytes msg: Message to sign",
            "            :param Ed25519PrivateKey}Ed448PrivateKey key: A :class:`.Ed25519PrivateKey`",
            "                or :class:`.Ed448PrivateKey` iinstance",
            "            :return bytes signature: The signature, as bytes",
            "            \"\"\"",
            "            msg = bytes(msg, \"utf-8\") if type(msg) is not bytes else msg",
            "            return key.sign(msg)",
            "",
            "        def verify(self, msg, key, sig):",
            "            \"\"\"",
            "            Verify a given ``msg`` against a signature ``sig`` using the EdDSA key ``key``",
            "",
            "            :param str|bytes sig: EdDSA signature to check ``msg`` against",
            "            :param str|bytes msg: Message to sign",
            "            :param Ed25519PrivateKey|Ed25519PublicKey|Ed448PrivateKey|Ed448PublicKey key:",
            "                A private or public EdDSA key instance",
            "            :return bool verified: True if signature is valid, False if not.",
            "            \"\"\"",
            "            try:",
            "                msg = bytes(msg, \"utf-8\") if type(msg) is not bytes else msg",
            "                sig = bytes(sig, \"utf-8\") if type(sig) is not bytes else sig",
            "",
            "                if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey)):",
            "                    key = key.public_key()",
            "                key.verify(sig, msg)",
            "                return True  # If no exception was raised, the signature is valid.",
            "            except cryptography.exceptions.InvalidSignature:",
            "                return False",
            "",
            "        @staticmethod",
            "        def to_jwk(key):",
            "            if isinstance(key, (Ed25519PublicKey, Ed448PublicKey)):",
            "                x = key.public_bytes(",
            "                    encoding=Encoding.Raw,",
            "                    format=PublicFormat.Raw,",
            "                )",
            "                crv = \"Ed25519\" if isinstance(key, Ed25519PublicKey) else \"Ed448\"",
            "                return json.dumps(",
            "                    {",
            "                        \"x\": base64url_encode(force_bytes(x)).decode(),",
            "                        \"kty\": \"OKP\",",
            "                        \"crv\": crv,",
            "                    }",
            "                )",
            "",
            "            if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey)):",
            "                d = key.private_bytes(",
            "                    encoding=Encoding.Raw,",
            "                    format=PrivateFormat.Raw,",
            "                    encryption_algorithm=NoEncryption(),",
            "                )",
            "",
            "                x = key.public_key().public_bytes(",
            "                    encoding=Encoding.Raw,",
            "                    format=PublicFormat.Raw,",
            "                )",
            "",
            "                crv = \"Ed25519\" if isinstance(key, Ed25519PrivateKey) else \"Ed448\"",
            "                return json.dumps(",
            "                    {",
            "                        \"x\": base64url_encode(force_bytes(x)).decode(),",
            "                        \"d\": base64url_encode(force_bytes(d)).decode(),",
            "                        \"kty\": \"OKP\",",
            "                        \"crv\": crv,",
            "                    }",
            "                )",
            "",
            "            raise InvalidKeyError(\"Not a public or private key\")",
            "",
            "        @staticmethod",
            "        def from_jwk(jwk):",
            "            try:",
            "                if isinstance(jwk, str):",
            "                    obj = json.loads(jwk)",
            "                elif isinstance(jwk, dict):",
            "                    obj = jwk",
            "                else:",
            "                    raise ValueError",
            "            except ValueError:",
            "                raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "            if obj.get(\"kty\") != \"OKP\":",
            "                raise InvalidKeyError(\"Not an Octet Key Pair\")",
            "",
            "            curve = obj.get(\"crv\")",
            "            if curve != \"Ed25519\" and curve != \"Ed448\":",
            "                raise InvalidKeyError(f\"Invalid curve: {curve}\")",
            "",
            "            if \"x\" not in obj:",
            "                raise InvalidKeyError('OKP should have \"x\" parameter')",
            "            x = base64url_decode(obj.get(\"x\"))",
            "",
            "            try:",
            "                if \"d\" not in obj:",
            "                    if curve == \"Ed25519\":",
            "                        return Ed25519PublicKey.from_public_bytes(x)",
            "                    return Ed448PublicKey.from_public_bytes(x)",
            "                d = base64url_decode(obj.get(\"d\"))",
            "                if curve == \"Ed25519\":",
            "                    return Ed25519PrivateKey.from_private_bytes(d)",
            "                return Ed448PrivateKey.from_private_bytes(d)",
            "            except ValueError as err:",
            "                raise InvalidKeyError(\"Invalid key parameter\") from err"
        ],
        "afterPatchFile": [
            "import hashlib",
            "import hmac",
            "import json",
            "",
            "from .exceptions import InvalidKeyError",
            "from .utils import (",
            "    base64url_decode,",
            "    base64url_encode,",
            "    der_to_raw_signature,",
            "    force_bytes,",
            "    from_base64url_uint,",
            "    is_pem_format,",
            "    is_ssh_key,",
            "    raw_to_der_signature,",
            "    to_base64url_uint,",
            ")",
            "",
            "try:",
            "    import cryptography.exceptions",
            "    from cryptography.exceptions import InvalidSignature",
            "    from cryptography.hazmat.primitives import hashes",
            "    from cryptography.hazmat.primitives.asymmetric import ec, padding",
            "    from cryptography.hazmat.primitives.asymmetric.ec import (",
            "        EllipticCurvePrivateKey,",
            "        EllipticCurvePublicKey,",
            "    )",
            "    from cryptography.hazmat.primitives.asymmetric.ed448 import (",
            "        Ed448PrivateKey,",
            "        Ed448PublicKey,",
            "    )",
            "    from cryptography.hazmat.primitives.asymmetric.ed25519 import (",
            "        Ed25519PrivateKey,",
            "        Ed25519PublicKey,",
            "    )",
            "    from cryptography.hazmat.primitives.asymmetric.rsa import (",
            "        RSAPrivateKey,",
            "        RSAPrivateNumbers,",
            "        RSAPublicKey,",
            "        RSAPublicNumbers,",
            "        rsa_crt_dmp1,",
            "        rsa_crt_dmq1,",
            "        rsa_crt_iqmp,",
            "        rsa_recover_prime_factors,",
            "    )",
            "    from cryptography.hazmat.primitives.serialization import (",
            "        Encoding,",
            "        NoEncryption,",
            "        PrivateFormat,",
            "        PublicFormat,",
            "        load_pem_private_key,",
            "        load_pem_public_key,",
            "        load_ssh_public_key,",
            "    )",
            "",
            "    has_crypto = True",
            "except ModuleNotFoundError:",
            "    has_crypto = False",
            "",
            "requires_cryptography = {",
            "    \"RS256\",",
            "    \"RS384\",",
            "    \"RS512\",",
            "    \"ES256\",",
            "    \"ES256K\",",
            "    \"ES384\",",
            "    \"ES521\",",
            "    \"ES512\",",
            "    \"PS256\",",
            "    \"PS384\",",
            "    \"PS512\",",
            "    \"EdDSA\",",
            "}",
            "",
            "",
            "def get_default_algorithms():",
            "    \"\"\"",
            "    Returns the algorithms that are implemented by the library.",
            "    \"\"\"",
            "    default_algorithms = {",
            "        \"none\": NoneAlgorithm(),",
            "        \"HS256\": HMACAlgorithm(HMACAlgorithm.SHA256),",
            "        \"HS384\": HMACAlgorithm(HMACAlgorithm.SHA384),",
            "        \"HS512\": HMACAlgorithm(HMACAlgorithm.SHA512),",
            "    }",
            "",
            "    if has_crypto:",
            "        default_algorithms.update(",
            "            {",
            "                \"RS256\": RSAAlgorithm(RSAAlgorithm.SHA256),",
            "                \"RS384\": RSAAlgorithm(RSAAlgorithm.SHA384),",
            "                \"RS512\": RSAAlgorithm(RSAAlgorithm.SHA512),",
            "                \"ES256\": ECAlgorithm(ECAlgorithm.SHA256),",
            "                \"ES256K\": ECAlgorithm(ECAlgorithm.SHA256),",
            "                \"ES384\": ECAlgorithm(ECAlgorithm.SHA384),",
            "                \"ES521\": ECAlgorithm(ECAlgorithm.SHA512),",
            "                \"ES512\": ECAlgorithm(",
            "                    ECAlgorithm.SHA512",
            "                ),  # Backward compat for #219 fix",
            "                \"PS256\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),",
            "                \"PS384\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),",
            "                \"PS512\": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),",
            "                \"EdDSA\": OKPAlgorithm(),",
            "            }",
            "        )",
            "",
            "    return default_algorithms",
            "",
            "",
            "class Algorithm:",
            "    \"\"\"",
            "    The interface for an algorithm used to sign and verify tokens.",
            "    \"\"\"",
            "",
            "    def prepare_key(self, key):",
            "        \"\"\"",
            "        Performs necessary validation and conversions on the key and returns",
            "        the key value in the proper format for sign() and verify().",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def sign(self, msg, key):",
            "        \"\"\"",
            "        Returns a digital signature for the specified message",
            "        using the specified key value.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def verify(self, msg, key, sig):",
            "        \"\"\"",
            "        Verifies that the specified digital signature is valid",
            "        for the specified message and key values.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    def to_jwk(key_obj):",
            "        \"\"\"",
            "        Serializes a given RSA key into a JWK",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    def from_jwk(jwk):",
            "        \"\"\"",
            "        Deserializes a given RSA key from JWK back into a PublicKey or PrivateKey object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class NoneAlgorithm(Algorithm):",
            "    \"\"\"",
            "    Placeholder for use when no signing or verification",
            "    operations are required.",
            "    \"\"\"",
            "",
            "    def prepare_key(self, key):",
            "        if key == \"\":",
            "            key = None",
            "",
            "        if key is not None:",
            "            raise InvalidKeyError('When alg = \"none\", key value must be None.')",
            "",
            "        return key",
            "",
            "    def sign(self, msg, key):",
            "        return b\"\"",
            "",
            "    def verify(self, msg, key, sig):",
            "        return False",
            "",
            "",
            "class HMACAlgorithm(Algorithm):",
            "    \"\"\"",
            "    Performs signing and verification operations using HMAC",
            "    and the specified hash function.",
            "    \"\"\"",
            "",
            "    SHA256 = hashlib.sha256",
            "    SHA384 = hashlib.sha384",
            "    SHA512 = hashlib.sha512",
            "",
            "    def __init__(self, hash_alg):",
            "        self.hash_alg = hash_alg",
            "",
            "    def prepare_key(self, key):",
            "        key = force_bytes(key)",
            "",
            "        if is_pem_format(key) or is_ssh_key(key):",
            "            raise InvalidKeyError(",
            "                \"The specified key is an asymmetric key or x509 certificate and\"",
            "                \" should not be used as an HMAC secret.\"",
            "            )",
            "",
            "        return key",
            "",
            "    @staticmethod",
            "    def to_jwk(key_obj):",
            "        return json.dumps(",
            "            {",
            "                \"k\": base64url_encode(force_bytes(key_obj)).decode(),",
            "                \"kty\": \"oct\",",
            "            }",
            "        )",
            "",
            "    @staticmethod",
            "    def from_jwk(jwk):",
            "        try:",
            "            if isinstance(jwk, str):",
            "                obj = json.loads(jwk)",
            "            elif isinstance(jwk, dict):",
            "                obj = jwk",
            "            else:",
            "                raise ValueError",
            "        except ValueError:",
            "            raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "        if obj.get(\"kty\") != \"oct\":",
            "            raise InvalidKeyError(\"Not an HMAC key\")",
            "",
            "        return base64url_decode(obj[\"k\"])",
            "",
            "    def sign(self, msg, key):",
            "        return hmac.new(key, msg, self.hash_alg).digest()",
            "",
            "    def verify(self, msg, key, sig):",
            "        return hmac.compare_digest(sig, self.sign(msg, key))",
            "",
            "",
            "if has_crypto:",
            "",
            "    class RSAAlgorithm(Algorithm):",
            "        \"\"\"",
            "        Performs signing and verification operations using",
            "        RSASSA-PKCS-v1_5 and the specified hash function.",
            "        \"\"\"",
            "",
            "        SHA256 = hashes.SHA256",
            "        SHA384 = hashes.SHA384",
            "        SHA512 = hashes.SHA512",
            "",
            "        def __init__(self, hash_alg):",
            "            self.hash_alg = hash_alg",
            "",
            "        def prepare_key(self, key):",
            "            if isinstance(key, (RSAPrivateKey, RSAPublicKey)):",
            "                return key",
            "",
            "            if not isinstance(key, (bytes, str)):",
            "                raise TypeError(\"Expecting a PEM-formatted key.\")",
            "",
            "            key = force_bytes(key)",
            "",
            "            try:",
            "                if key.startswith(b\"ssh-rsa\"):",
            "                    key = load_ssh_public_key(key)",
            "                else:",
            "                    key = load_pem_private_key(key, password=None)",
            "            except ValueError:",
            "                key = load_pem_public_key(key)",
            "            return key",
            "",
            "        @staticmethod",
            "        def to_jwk(key_obj):",
            "            obj = None",
            "",
            "            if getattr(key_obj, \"private_numbers\", None):",
            "                # Private key",
            "                numbers = key_obj.private_numbers()",
            "",
            "                obj = {",
            "                    \"kty\": \"RSA\",",
            "                    \"key_ops\": [\"sign\"],",
            "                    \"n\": to_base64url_uint(numbers.public_numbers.n).decode(),",
            "                    \"e\": to_base64url_uint(numbers.public_numbers.e).decode(),",
            "                    \"d\": to_base64url_uint(numbers.d).decode(),",
            "                    \"p\": to_base64url_uint(numbers.p).decode(),",
            "                    \"q\": to_base64url_uint(numbers.q).decode(),",
            "                    \"dp\": to_base64url_uint(numbers.dmp1).decode(),",
            "                    \"dq\": to_base64url_uint(numbers.dmq1).decode(),",
            "                    \"qi\": to_base64url_uint(numbers.iqmp).decode(),",
            "                }",
            "",
            "            elif getattr(key_obj, \"verify\", None):",
            "                # Public key",
            "                numbers = key_obj.public_numbers()",
            "",
            "                obj = {",
            "                    \"kty\": \"RSA\",",
            "                    \"key_ops\": [\"verify\"],",
            "                    \"n\": to_base64url_uint(numbers.n).decode(),",
            "                    \"e\": to_base64url_uint(numbers.e).decode(),",
            "                }",
            "            else:",
            "                raise InvalidKeyError(\"Not a public or private key\")",
            "",
            "            return json.dumps(obj)",
            "",
            "        @staticmethod",
            "        def from_jwk(jwk):",
            "            try:",
            "                if isinstance(jwk, str):",
            "                    obj = json.loads(jwk)",
            "                elif isinstance(jwk, dict):",
            "                    obj = jwk",
            "                else:",
            "                    raise ValueError",
            "            except ValueError:",
            "                raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "            if obj.get(\"kty\") != \"RSA\":",
            "                raise InvalidKeyError(\"Not an RSA key\")",
            "",
            "            if \"d\" in obj and \"e\" in obj and \"n\" in obj:",
            "                # Private key",
            "                if \"oth\" in obj:",
            "                    raise InvalidKeyError(",
            "                        \"Unsupported RSA private key: > 2 primes not supported\"",
            "                    )",
            "",
            "                other_props = [\"p\", \"q\", \"dp\", \"dq\", \"qi\"]",
            "                props_found = [prop in obj for prop in other_props]",
            "                any_props_found = any(props_found)",
            "",
            "                if any_props_found and not all(props_found):",
            "                    raise InvalidKeyError(",
            "                        \"RSA key must include all parameters if any are present besides d\"",
            "                    )",
            "",
            "                public_numbers = RSAPublicNumbers(",
            "                    from_base64url_uint(obj[\"e\"]),",
            "                    from_base64url_uint(obj[\"n\"]),",
            "                )",
            "",
            "                if any_props_found:",
            "                    numbers = RSAPrivateNumbers(",
            "                        d=from_base64url_uint(obj[\"d\"]),",
            "                        p=from_base64url_uint(obj[\"p\"]),",
            "                        q=from_base64url_uint(obj[\"q\"]),",
            "                        dmp1=from_base64url_uint(obj[\"dp\"]),",
            "                        dmq1=from_base64url_uint(obj[\"dq\"]),",
            "                        iqmp=from_base64url_uint(obj[\"qi\"]),",
            "                        public_numbers=public_numbers,",
            "                    )",
            "                else:",
            "                    d = from_base64url_uint(obj[\"d\"])",
            "                    p, q = rsa_recover_prime_factors(",
            "                        public_numbers.n, d, public_numbers.e",
            "                    )",
            "",
            "                    numbers = RSAPrivateNumbers(",
            "                        d=d,",
            "                        p=p,",
            "                        q=q,",
            "                        dmp1=rsa_crt_dmp1(d, p),",
            "                        dmq1=rsa_crt_dmq1(d, q),",
            "                        iqmp=rsa_crt_iqmp(p, q),",
            "                        public_numbers=public_numbers,",
            "                    )",
            "",
            "                return numbers.private_key()",
            "            elif \"n\" in obj and \"e\" in obj:",
            "                # Public key",
            "                numbers = RSAPublicNumbers(",
            "                    from_base64url_uint(obj[\"e\"]),",
            "                    from_base64url_uint(obj[\"n\"]),",
            "                )",
            "",
            "                return numbers.public_key()",
            "            else:",
            "                raise InvalidKeyError(\"Not a public or private key\")",
            "",
            "        def sign(self, msg, key):",
            "            return key.sign(msg, padding.PKCS1v15(), self.hash_alg())",
            "",
            "        def verify(self, msg, key, sig):",
            "            try:",
            "                key.verify(sig, msg, padding.PKCS1v15(), self.hash_alg())",
            "                return True",
            "            except InvalidSignature:",
            "                return False",
            "",
            "    class ECAlgorithm(Algorithm):",
            "        \"\"\"",
            "        Performs signing and verification operations using",
            "        ECDSA and the specified hash function",
            "        \"\"\"",
            "",
            "        SHA256 = hashes.SHA256",
            "        SHA384 = hashes.SHA384",
            "        SHA512 = hashes.SHA512",
            "",
            "        def __init__(self, hash_alg):",
            "            self.hash_alg = hash_alg",
            "",
            "        def prepare_key(self, key):",
            "            if isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):",
            "                return key",
            "",
            "            if not isinstance(key, (bytes, str)):",
            "                raise TypeError(\"Expecting a PEM-formatted key.\")",
            "",
            "            key = force_bytes(key)",
            "",
            "            # Attempt to load key. We don't know if it's",
            "            # a Signing Key or a Verifying Key, so we try",
            "            # the Verifying Key first.",
            "            try:",
            "                if key.startswith(b\"ecdsa-sha2-\"):",
            "                    key = load_ssh_public_key(key)",
            "                else:",
            "                    key = load_pem_public_key(key)",
            "            except ValueError:",
            "                key = load_pem_private_key(key, password=None)",
            "",
            "            # Explicit check the key to prevent confusing errors from cryptography",
            "            if not isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):",
            "                raise InvalidKeyError(",
            "                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for ECDSA algorithms\"",
            "                )",
            "",
            "            return key",
            "",
            "        def sign(self, msg, key):",
            "            der_sig = key.sign(msg, ec.ECDSA(self.hash_alg()))",
            "",
            "            return der_to_raw_signature(der_sig, key.curve)",
            "",
            "        def verify(self, msg, key, sig):",
            "            try:",
            "                der_sig = raw_to_der_signature(sig, key.curve)",
            "            except ValueError:",
            "                return False",
            "",
            "            try:",
            "                if isinstance(key, EllipticCurvePrivateKey):",
            "                    key = key.public_key()",
            "                key.verify(der_sig, msg, ec.ECDSA(self.hash_alg()))",
            "                return True",
            "            except InvalidSignature:",
            "                return False",
            "",
            "        @staticmethod",
            "        def from_jwk(jwk):",
            "            try:",
            "                if isinstance(jwk, str):",
            "                    obj = json.loads(jwk)",
            "                elif isinstance(jwk, dict):",
            "                    obj = jwk",
            "                else:",
            "                    raise ValueError",
            "            except ValueError:",
            "                raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "            if obj.get(\"kty\") != \"EC\":",
            "                raise InvalidKeyError(\"Not an Elliptic curve key\")",
            "",
            "            if \"x\" not in obj or \"y\" not in obj:",
            "                raise InvalidKeyError(\"Not an Elliptic curve key\")",
            "",
            "            x = base64url_decode(obj.get(\"x\"))",
            "            y = base64url_decode(obj.get(\"y\"))",
            "",
            "            curve = obj.get(\"crv\")",
            "            if curve == \"P-256\":",
            "                if len(x) == len(y) == 32:",
            "                    curve_obj = ec.SECP256R1()",
            "                else:",
            "                    raise InvalidKeyError(\"Coords should be 32 bytes for curve P-256\")",
            "            elif curve == \"P-384\":",
            "                if len(x) == len(y) == 48:",
            "                    curve_obj = ec.SECP384R1()",
            "                else:",
            "                    raise InvalidKeyError(\"Coords should be 48 bytes for curve P-384\")",
            "            elif curve == \"P-521\":",
            "                if len(x) == len(y) == 66:",
            "                    curve_obj = ec.SECP521R1()",
            "                else:",
            "                    raise InvalidKeyError(\"Coords should be 66 bytes for curve P-521\")",
            "            elif curve == \"secp256k1\":",
            "                if len(x) == len(y) == 32:",
            "                    curve_obj = ec.SECP256K1()",
            "                else:",
            "                    raise InvalidKeyError(",
            "                        \"Coords should be 32 bytes for curve secp256k1\"",
            "                    )",
            "            else:",
            "                raise InvalidKeyError(f\"Invalid curve: {curve}\")",
            "",
            "            public_numbers = ec.EllipticCurvePublicNumbers(",
            "                x=int.from_bytes(x, byteorder=\"big\"),",
            "                y=int.from_bytes(y, byteorder=\"big\"),",
            "                curve=curve_obj,",
            "            )",
            "",
            "            if \"d\" not in obj:",
            "                return public_numbers.public_key()",
            "",
            "            d = base64url_decode(obj.get(\"d\"))",
            "            if len(d) != len(x):",
            "                raise InvalidKeyError(",
            "                    \"D should be {} bytes for curve {}\", len(x), curve",
            "                )",
            "",
            "            return ec.EllipticCurvePrivateNumbers(",
            "                int.from_bytes(d, byteorder=\"big\"), public_numbers",
            "            ).private_key()",
            "",
            "    class RSAPSSAlgorithm(RSAAlgorithm):",
            "        \"\"\"",
            "        Performs a signature using RSASSA-PSS with MGF1",
            "        \"\"\"",
            "",
            "        def sign(self, msg, key):",
            "            return key.sign(",
            "                msg,",
            "                padding.PSS(",
            "                    mgf=padding.MGF1(self.hash_alg()),",
            "                    salt_length=self.hash_alg.digest_size,",
            "                ),",
            "                self.hash_alg(),",
            "            )",
            "",
            "        def verify(self, msg, key, sig):",
            "            try:",
            "                key.verify(",
            "                    sig,",
            "                    msg,",
            "                    padding.PSS(",
            "                        mgf=padding.MGF1(self.hash_alg()),",
            "                        salt_length=self.hash_alg.digest_size,",
            "                    ),",
            "                    self.hash_alg(),",
            "                )",
            "                return True",
            "            except InvalidSignature:",
            "                return False",
            "",
            "    class OKPAlgorithm(Algorithm):",
            "        \"\"\"",
            "        Performs signing and verification operations using EdDSA",
            "",
            "        This class requires ``cryptography>=2.6`` to be installed.",
            "        \"\"\"",
            "",
            "        def __init__(self, **kwargs):",
            "            pass",
            "",
            "        def prepare_key(self, key):",
            "            if isinstance(key, (bytes, str)):",
            "                if isinstance(key, str):",
            "                    key = key.encode(\"utf-8\")",
            "                str_key = key.decode(\"utf-8\")",
            "",
            "                if \"-----BEGIN PUBLIC\" in str_key:",
            "                    key = load_pem_public_key(key)",
            "                elif \"-----BEGIN PRIVATE\" in str_key:",
            "                    key = load_pem_private_key(key, password=None)",
            "                elif str_key[0:4] == \"ssh-\":",
            "                    key = load_ssh_public_key(key)",
            "",
            "            # Explicit check the key to prevent confusing errors from cryptography",
            "            if not isinstance(",
            "                key,",
            "                (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),",
            "            ):",
            "                raise InvalidKeyError(",
            "                    \"Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for EdDSA algorithms\"",
            "                )",
            "",
            "            return key",
            "",
            "        def sign(self, msg, key):",
            "            \"\"\"",
            "            Sign a message ``msg`` using the EdDSA private key ``key``",
            "            :param str|bytes msg: Message to sign",
            "            :param Ed25519PrivateKey}Ed448PrivateKey key: A :class:`.Ed25519PrivateKey`",
            "                or :class:`.Ed448PrivateKey` iinstance",
            "            :return bytes signature: The signature, as bytes",
            "            \"\"\"",
            "            msg = bytes(msg, \"utf-8\") if type(msg) is not bytes else msg",
            "            return key.sign(msg)",
            "",
            "        def verify(self, msg, key, sig):",
            "            \"\"\"",
            "            Verify a given ``msg`` against a signature ``sig`` using the EdDSA key ``key``",
            "",
            "            :param str|bytes sig: EdDSA signature to check ``msg`` against",
            "            :param str|bytes msg: Message to sign",
            "            :param Ed25519PrivateKey|Ed25519PublicKey|Ed448PrivateKey|Ed448PublicKey key:",
            "                A private or public EdDSA key instance",
            "            :return bool verified: True if signature is valid, False if not.",
            "            \"\"\"",
            "            try:",
            "                msg = bytes(msg, \"utf-8\") if type(msg) is not bytes else msg",
            "                sig = bytes(sig, \"utf-8\") if type(sig) is not bytes else sig",
            "",
            "                if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey)):",
            "                    key = key.public_key()",
            "                key.verify(sig, msg)",
            "                return True  # If no exception was raised, the signature is valid.",
            "            except cryptography.exceptions.InvalidSignature:",
            "                return False",
            "",
            "        @staticmethod",
            "        def to_jwk(key):",
            "            if isinstance(key, (Ed25519PublicKey, Ed448PublicKey)):",
            "                x = key.public_bytes(",
            "                    encoding=Encoding.Raw,",
            "                    format=PublicFormat.Raw,",
            "                )",
            "                crv = \"Ed25519\" if isinstance(key, Ed25519PublicKey) else \"Ed448\"",
            "                return json.dumps(",
            "                    {",
            "                        \"x\": base64url_encode(force_bytes(x)).decode(),",
            "                        \"kty\": \"OKP\",",
            "                        \"crv\": crv,",
            "                    }",
            "                )",
            "",
            "            if isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey)):",
            "                d = key.private_bytes(",
            "                    encoding=Encoding.Raw,",
            "                    format=PrivateFormat.Raw,",
            "                    encryption_algorithm=NoEncryption(),",
            "                )",
            "",
            "                x = key.public_key().public_bytes(",
            "                    encoding=Encoding.Raw,",
            "                    format=PublicFormat.Raw,",
            "                )",
            "",
            "                crv = \"Ed25519\" if isinstance(key, Ed25519PrivateKey) else \"Ed448\"",
            "                return json.dumps(",
            "                    {",
            "                        \"x\": base64url_encode(force_bytes(x)).decode(),",
            "                        \"d\": base64url_encode(force_bytes(d)).decode(),",
            "                        \"kty\": \"OKP\",",
            "                        \"crv\": crv,",
            "                    }",
            "                )",
            "",
            "            raise InvalidKeyError(\"Not a public or private key\")",
            "",
            "        @staticmethod",
            "        def from_jwk(jwk):",
            "            try:",
            "                if isinstance(jwk, str):",
            "                    obj = json.loads(jwk)",
            "                elif isinstance(jwk, dict):",
            "                    obj = jwk",
            "                else:",
            "                    raise ValueError",
            "            except ValueError:",
            "                raise InvalidKeyError(\"Key is not valid JSON\")",
            "",
            "            if obj.get(\"kty\") != \"OKP\":",
            "                raise InvalidKeyError(\"Not an Octet Key Pair\")",
            "",
            "            curve = obj.get(\"crv\")",
            "            if curve != \"Ed25519\" and curve != \"Ed448\":",
            "                raise InvalidKeyError(f\"Invalid curve: {curve}\")",
            "",
            "            if \"x\" not in obj:",
            "                raise InvalidKeyError('OKP should have \"x\" parameter')",
            "            x = base64url_decode(obj.get(\"x\"))",
            "",
            "            try:",
            "                if \"d\" not in obj:",
            "                    if curve == \"Ed25519\":",
            "                        return Ed25519PublicKey.from_public_bytes(x)",
            "                    return Ed448PublicKey.from_public_bytes(x)",
            "                d = base64url_decode(obj.get(\"d\"))",
            "                if curve == \"Ed25519\":",
            "                    return Ed25519PrivateKey.from_private_bytes(d)",
            "                return Ed448PrivateKey.from_private_bytes(d)",
            "            except ValueError as err:",
            "                raise InvalidKeyError(\"Invalid key parameter\") from err"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "186": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "187": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "188": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "189": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "190": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "191": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "192": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "193": [
                "HMACAlgorithm",
                "prepare_key"
            ],
            "554": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "555": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "556": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "557": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "558": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "559": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "560": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "567": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "568": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "569": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "570": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "571": [
                "OKPAlgorithm",
                "prepare_key"
            ],
            "573": [
                "OKPAlgorithm",
                "prepare_key"
            ]
        },
        "addLocation": []
    },
    "jwt/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import base64"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import binascii"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import re"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from typing import Any, Union"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " try:"
            },
            "6": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     s = bytes_to_number(raw_sig[num_bytes:])"
            },
            "7": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     return encode_dss_signature(r, s)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+_PEMS = {"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    b\"CERTIFICATE\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    b\"TRUSTED CERTIFICATE\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    b\"PRIVATE KEY\","
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+    b\"PUBLIC KEY\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+    b\"ENCRYPTED PRIVATE KEY\","
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    b\"OPENSSH PRIVATE KEY\","
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+    b\"DSA PRIVATE KEY\","
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    b\"RSA PRIVATE KEY\","
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    b\"RSA PUBLIC KEY\","
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+    b\"EC PRIVATE KEY\","
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    b\"DH PARAMETERS\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+    b\"NEW CERTIFICATE REQUEST\","
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    b\"CERTIFICATE REQUEST\","
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    b\"SSH2 PUBLIC KEY\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    b\"SSH2 ENCRYPTED PRIVATE KEY\","
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    b\"X509 CRL\","
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+}"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+_PEM_RE = re.compile("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    b\"----[- ]BEGIN (\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    + b\"|\".join(_PEMS)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    + b\"\"\")[- ]----\\r?"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+.+?\\r?"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+----[- ]END \\\\1[- ]----\\r?\\n?\"\"\","
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+    re.DOTALL,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+def is_pem_format(key: bytes) -> bool:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    return bool(_PEM_RE.search(key))"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+_CERT_SUFFIX = b\"-cert-v01@openssh.com\""
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+_SSH_PUBKEY_RC = re.compile(br\"\\A(\\S+)[ \\t]+(\\S+)\")"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+_SSH_KEY_FORMATS = ["
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    b\"ssh-ed25519\","
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    b\"ssh-rsa\","
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    b\"ssh-dss\","
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    b\"ecdsa-sha2-nistp256\","
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    b\"ecdsa-sha2-nistp384\","
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    b\"ecdsa-sha2-nistp521\","
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+]"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+def is_ssh_key(key: bytes) -> bool:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    if any(string_value in key for string_value in _SSH_KEY_FORMATS):"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        return True"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+    ssh_pubkey_match = _SSH_PUBKEY_RC.match(key)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+    if ssh_pubkey_match:"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        key_type = ssh_pubkey_match.group(1)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            return True"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    return False"
            }
        },
        "frontPatchFile": [
            "import base64",
            "import binascii",
            "from typing import Any, Union",
            "",
            "try:",
            "    from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurve",
            "    from cryptography.hazmat.primitives.asymmetric.utils import (",
            "        decode_dss_signature,",
            "        encode_dss_signature,",
            "    )",
            "except ModuleNotFoundError:",
            "    EllipticCurve = Any  # type: ignore",
            "",
            "",
            "def force_bytes(value: Union[str, bytes]) -> bytes:",
            "    if isinstance(value, str):",
            "        return value.encode(\"utf-8\")",
            "    elif isinstance(value, bytes):",
            "        return value",
            "    else:",
            "        raise TypeError(\"Expected a string value\")",
            "",
            "",
            "def base64url_decode(input: Union[str, bytes]) -> bytes:",
            "    if isinstance(input, str):",
            "        input = input.encode(\"ascii\")",
            "",
            "    rem = len(input) % 4",
            "",
            "    if rem > 0:",
            "        input += b\"=\" * (4 - rem)",
            "",
            "    return base64.urlsafe_b64decode(input)",
            "",
            "",
            "def base64url_encode(input: bytes) -> bytes:",
            "    return base64.urlsafe_b64encode(input).replace(b\"=\", b\"\")",
            "",
            "",
            "def to_base64url_uint(val: int) -> bytes:",
            "    if val < 0:",
            "        raise ValueError(\"Must be a positive integer\")",
            "",
            "    int_bytes = bytes_from_int(val)",
            "",
            "    if len(int_bytes) == 0:",
            "        int_bytes = b\"\\x00\"",
            "",
            "    return base64url_encode(int_bytes)",
            "",
            "",
            "def from_base64url_uint(val: Union[str, bytes]) -> int:",
            "    if isinstance(val, str):",
            "        val = val.encode(\"ascii\")",
            "",
            "    data = base64url_decode(val)",
            "    return int.from_bytes(data, byteorder=\"big\")",
            "",
            "",
            "def number_to_bytes(num: int, num_bytes: int) -> bytes:",
            "    padded_hex = \"%0*x\" % (2 * num_bytes, num)",
            "    return binascii.a2b_hex(padded_hex.encode(\"ascii\"))",
            "",
            "",
            "def bytes_to_number(string: bytes) -> int:",
            "    return int(binascii.b2a_hex(string), 16)",
            "",
            "",
            "def bytes_from_int(val: int) -> bytes:",
            "    remaining = val",
            "    byte_length = 0",
            "",
            "    while remaining != 0:",
            "        remaining >>= 8",
            "        byte_length += 1",
            "",
            "    return val.to_bytes(byte_length, \"big\", signed=False)",
            "",
            "",
            "def der_to_raw_signature(der_sig: bytes, curve: EllipticCurve) -> bytes:",
            "    num_bits = curve.key_size",
            "    num_bytes = (num_bits + 7) // 8",
            "",
            "    r, s = decode_dss_signature(der_sig)",
            "",
            "    return number_to_bytes(r, num_bytes) + number_to_bytes(s, num_bytes)",
            "",
            "",
            "def raw_to_der_signature(raw_sig: bytes, curve: EllipticCurve) -> bytes:",
            "    num_bits = curve.key_size",
            "    num_bytes = (num_bits + 7) // 8",
            "",
            "    if len(raw_sig) != 2 * num_bytes:",
            "        raise ValueError(\"Invalid signature\")",
            "",
            "    r = bytes_to_number(raw_sig[:num_bytes])",
            "    s = bytes_to_number(raw_sig[num_bytes:])",
            "",
            "    return encode_dss_signature(r, s)"
        ],
        "afterPatchFile": [
            "import base64",
            "import binascii",
            "import re",
            "from typing import Any, Union",
            "",
            "try:",
            "    from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurve",
            "    from cryptography.hazmat.primitives.asymmetric.utils import (",
            "        decode_dss_signature,",
            "        encode_dss_signature,",
            "    )",
            "except ModuleNotFoundError:",
            "    EllipticCurve = Any  # type: ignore",
            "",
            "",
            "def force_bytes(value: Union[str, bytes]) -> bytes:",
            "    if isinstance(value, str):",
            "        return value.encode(\"utf-8\")",
            "    elif isinstance(value, bytes):",
            "        return value",
            "    else:",
            "        raise TypeError(\"Expected a string value\")",
            "",
            "",
            "def base64url_decode(input: Union[str, bytes]) -> bytes:",
            "    if isinstance(input, str):",
            "        input = input.encode(\"ascii\")",
            "",
            "    rem = len(input) % 4",
            "",
            "    if rem > 0:",
            "        input += b\"=\" * (4 - rem)",
            "",
            "    return base64.urlsafe_b64decode(input)",
            "",
            "",
            "def base64url_encode(input: bytes) -> bytes:",
            "    return base64.urlsafe_b64encode(input).replace(b\"=\", b\"\")",
            "",
            "",
            "def to_base64url_uint(val: int) -> bytes:",
            "    if val < 0:",
            "        raise ValueError(\"Must be a positive integer\")",
            "",
            "    int_bytes = bytes_from_int(val)",
            "",
            "    if len(int_bytes) == 0:",
            "        int_bytes = b\"\\x00\"",
            "",
            "    return base64url_encode(int_bytes)",
            "",
            "",
            "def from_base64url_uint(val: Union[str, bytes]) -> int:",
            "    if isinstance(val, str):",
            "        val = val.encode(\"ascii\")",
            "",
            "    data = base64url_decode(val)",
            "    return int.from_bytes(data, byteorder=\"big\")",
            "",
            "",
            "def number_to_bytes(num: int, num_bytes: int) -> bytes:",
            "    padded_hex = \"%0*x\" % (2 * num_bytes, num)",
            "    return binascii.a2b_hex(padded_hex.encode(\"ascii\"))",
            "",
            "",
            "def bytes_to_number(string: bytes) -> int:",
            "    return int(binascii.b2a_hex(string), 16)",
            "",
            "",
            "def bytes_from_int(val: int) -> bytes:",
            "    remaining = val",
            "    byte_length = 0",
            "",
            "    while remaining != 0:",
            "        remaining >>= 8",
            "        byte_length += 1",
            "",
            "    return val.to_bytes(byte_length, \"big\", signed=False)",
            "",
            "",
            "def der_to_raw_signature(der_sig: bytes, curve: EllipticCurve) -> bytes:",
            "    num_bits = curve.key_size",
            "    num_bytes = (num_bits + 7) // 8",
            "",
            "    r, s = decode_dss_signature(der_sig)",
            "",
            "    return number_to_bytes(r, num_bytes) + number_to_bytes(s, num_bytes)",
            "",
            "",
            "def raw_to_der_signature(raw_sig: bytes, curve: EllipticCurve) -> bytes:",
            "    num_bits = curve.key_size",
            "    num_bytes = (num_bits + 7) // 8",
            "",
            "    if len(raw_sig) != 2 * num_bytes:",
            "        raise ValueError(\"Invalid signature\")",
            "",
            "    r = bytes_to_number(raw_sig[:num_bytes])",
            "    s = bytes_to_number(raw_sig[num_bytes:])",
            "",
            "    return encode_dss_signature(r, s)",
            "",
            "",
            "# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252",
            "_PEMS = {",
            "    b\"CERTIFICATE\",",
            "    b\"TRUSTED CERTIFICATE\",",
            "    b\"PRIVATE KEY\",",
            "    b\"PUBLIC KEY\",",
            "    b\"ENCRYPTED PRIVATE KEY\",",
            "    b\"OPENSSH PRIVATE KEY\",",
            "    b\"DSA PRIVATE KEY\",",
            "    b\"RSA PRIVATE KEY\",",
            "    b\"RSA PUBLIC KEY\",",
            "    b\"EC PRIVATE KEY\",",
            "    b\"DH PARAMETERS\",",
            "    b\"NEW CERTIFICATE REQUEST\",",
            "    b\"CERTIFICATE REQUEST\",",
            "    b\"SSH2 PUBLIC KEY\",",
            "    b\"SSH2 ENCRYPTED PRIVATE KEY\",",
            "    b\"X509 CRL\",",
            "}",
            "",
            "_PEM_RE = re.compile(",
            "    b\"----[- ]BEGIN (\"",
            "    + b\"|\".join(_PEMS)",
            "    + b\"\"\")[- ]----\\r?",
            ".+?\\r?",
            "----[- ]END \\\\1[- ]----\\r?\\n?\"\"\",",
            "    re.DOTALL,",
            ")",
            "",
            "",
            "def is_pem_format(key: bytes) -> bool:",
            "    return bool(_PEM_RE.search(key))",
            "",
            "",
            "# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46",
            "_CERT_SUFFIX = b\"-cert-v01@openssh.com\"",
            "_SSH_PUBKEY_RC = re.compile(br\"\\A(\\S+)[ \\t]+(\\S+)\")",
            "_SSH_KEY_FORMATS = [",
            "    b\"ssh-ed25519\",",
            "    b\"ssh-rsa\",",
            "    b\"ssh-dss\",",
            "    b\"ecdsa-sha2-nistp256\",",
            "    b\"ecdsa-sha2-nistp384\",",
            "    b\"ecdsa-sha2-nistp521\",",
            "]",
            "",
            "",
            "def is_ssh_key(key: bytes) -> bool:",
            "    if any(string_value in key for string_value in _SSH_KEY_FORMATS):",
            "        return True",
            "",
            "    ssh_pubkey_match = _SSH_PUBKEY_RC.match(key)",
            "    if ssh_pubkey_match:",
            "        key_type = ssh_pubkey_match.group(1)",
            "        if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:",
            "            return True",
            "",
            "    return False"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tuf.client.updater.Updater._get_target_from_targets_role"
        ]
    }
}