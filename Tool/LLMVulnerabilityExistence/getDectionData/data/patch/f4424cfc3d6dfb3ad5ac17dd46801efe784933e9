{
    "lollms/security.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     return sanitized_code"
            },
            "1": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " def sanitize_path(path:str, allow_absolute_path:bool=False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal. Are you kidding me?\"):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    if not allow_absolute_path and path.strip().startswith(\"/\"):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        raise HTTPException(status_code=400, detail=exception_text)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     if path is None:"
            },
            "7": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         return path"
            },
            "8": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     "
            },
            "9": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     return path"
            },
            "10": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     "
            },
            "11": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " def sanitize_path_from_endpoint(path: str, error_text=\"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text=\"Invalid path!\"):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    if path.strip().startswith(\"/\"):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        raise HTTPException(status_code=400, detail=exception_text)"
            },
            "14": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     # Fix the case of \"/\" at the beginning on the path"
            },
            "15": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     if path is None:"
            },
            "16": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         return path"
            }
        },
        "frontPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "def sanitize_code(code):",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Keep only the first non-empty line and remove any potential malicious commands",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            # Check for potential malicious commands",
            "            if platform.system() == \"Windows\":",
            "                if \"&\" in line:",
            "                    line = line.split(\"&\")[0]  # Keep only the first command before the ampersand",
            "                if \"|\" in line:",
            "                    line = line.split(\"|\")[0]  # Keep only the first command before the pipe",
            "            else:  # Linux",
            "                if \";\" in line:",
            "                    line = line.split(\";\")[0]  # Keep only the first command before the semicolon",
            "                if \"|\" in line:",
            "                    line = line.split(\"|\")[0]  # Keep only the first command before the pipe",
            "            sanitized_code = line",
            "            break",
            "    ",
            "    return sanitized_code",
            "",
            "def sanitize_path(path:str, allow_absolute_path:bool=False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal. Are you kidding me?\"):",
            "    if path is None:",
            "        return path",
            "    ",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "    ",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text=\"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text=\"Invalid path!\"):",
            "    # Fix the case of \"/\" at the beginning on the path",
            "    if path is None:",
            "        return path",
            "    ",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "    ",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "    ",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "afterPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "def sanitize_code(code):",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Keep only the first non-empty line and remove any potential malicious commands",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            # Check for potential malicious commands",
            "            if platform.system() == \"Windows\":",
            "                if \"&\" in line:",
            "                    line = line.split(\"&\")[0]  # Keep only the first command before the ampersand",
            "                if \"|\" in line:",
            "                    line = line.split(\"|\")[0]  # Keep only the first command before the pipe",
            "            else:  # Linux",
            "                if \";\" in line:",
            "                    line = line.split(\";\")[0]  # Keep only the first command before the semicolon",
            "                if \"|\" in line:",
            "                    line = line.split(\"|\")[0]  # Keep only the first command before the pipe",
            "            sanitized_code = line",
            "            break",
            "    ",
            "    return sanitized_code",
            "",
            "def sanitize_path(path:str, allow_absolute_path:bool=False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal. Are you kidding me?\"):",
            "    if not allow_absolute_path and path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if path is None:",
            "        return path",
            "    ",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "    ",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text=\"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text=\"Invalid path!\"):",
            "    if path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "    # Fix the case of \"/\" at the beginning on the path",
            "    if path is None:",
            "        return path",
            "    ",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "    ",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "    ",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lollms.security",
            "saleor.graphql.core.tests.test_view"
        ]
    }
}