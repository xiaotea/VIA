{
    "Tests/test_decompression_bomb.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "             with Image.open(TEST_FILE):"
            },
            "1": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "                 pass"
            },
            "2": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    @pytest.mark.xfail(reason=\"different exception\")"
            },
            "4": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     def test_exception_ico(self):"
            },
            "5": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         with pytest.raises(Image.DecompressionBombError):"
            },
            "6": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             with Image.open(\"Tests/images/decompression_bomb.ico\"):"
            }
        },
        "frontPatchFile": [
            "import pytest",
            "",
            "from PIL import Image",
            "",
            "from .helper import hopper",
            "",
            "TEST_FILE = \"Tests/images/hopper.ppm\"",
            "",
            "ORIGINAL_LIMIT = Image.MAX_IMAGE_PIXELS",
            "",
            "",
            "class TestDecompressionBomb:",
            "    @classmethod",
            "    def teardown_class(cls):",
            "        Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT",
            "",
            "    def test_no_warning_small_file(self):",
            "        # Implicit assert: no warning.",
            "        # A warning would cause a failure.",
            "        with Image.open(TEST_FILE):",
            "            pass",
            "",
            "    def test_no_warning_no_limit(self):",
            "        # Arrange",
            "        # Turn limit off",
            "        Image.MAX_IMAGE_PIXELS = None",
            "        assert Image.MAX_IMAGE_PIXELS is None",
            "",
            "        # Act / Assert",
            "        # Implicit assert: no warning.",
            "        # A warning would cause a failure.",
            "        with Image.open(TEST_FILE):",
            "            pass",
            "",
            "    def test_warning(self):",
            "        # Set limit to trigger warning on the test file",
            "        Image.MAX_IMAGE_PIXELS = 128 * 128 - 1",
            "        assert Image.MAX_IMAGE_PIXELS == 128 * 128 - 1",
            "",
            "        def open():",
            "            with Image.open(TEST_FILE):",
            "                pass",
            "",
            "        pytest.warns(Image.DecompressionBombWarning, open)",
            "",
            "    def test_exception(self):",
            "        # Set limit to trigger exception on the test file",
            "        Image.MAX_IMAGE_PIXELS = 64 * 128 - 1",
            "        assert Image.MAX_IMAGE_PIXELS == 64 * 128 - 1",
            "",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(TEST_FILE):",
            "                pass",
            "",
            "    def test_exception_ico(self):",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(\"Tests/images/decompression_bomb.ico\"):",
            "                pass",
            "",
            "    def test_exception_gif(self):",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(\"Tests/images/decompression_bomb.gif\"):",
            "                pass",
            "",
            "    def test_exception_bmp(self):",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(\"Tests/images/bmp/b/reallybig.bmp\"):",
            "                pass",
            "",
            "",
            "class TestDecompressionCrop:",
            "    @classmethod",
            "    def setup_class(self):",
            "        width, height = 128, 128",
            "        Image.MAX_IMAGE_PIXELS = height * width * 4 - 1",
            "",
            "    @classmethod",
            "    def teardown_class(self):",
            "        Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT",
            "",
            "    def testEnlargeCrop(self):",
            "        # Crops can extend the extents, therefore we should have the",
            "        # same decompression bomb warnings on them.",
            "        with hopper() as src:",
            "            box = (0, 0, src.width * 2, src.height * 2)",
            "            pytest.warns(Image.DecompressionBombWarning, src.crop, box)",
            "",
            "    def test_crop_decompression_checks(self):",
            "",
            "        im = Image.new(\"RGB\", (100, 100))",
            "",
            "        good_values = ((-9999, -9999, -9990, -9990), (-999, -999, -990, -990))",
            "",
            "        warning_values = ((-160, -160, 99, 99), (160, 160, -99, -99))",
            "",
            "        error_values = ((-99909, -99990, 99999, 99999), (99909, 99990, -99999, -99999))",
            "",
            "        for value in good_values:",
            "            assert im.crop(value).size == (9, 9)",
            "",
            "        for value in warning_values:",
            "            pytest.warns(Image.DecompressionBombWarning, im.crop, value)",
            "",
            "        for value in error_values:",
            "            with pytest.raises(Image.DecompressionBombError):",
            "                im.crop(value)"
        ],
        "afterPatchFile": [
            "import pytest",
            "",
            "from PIL import Image",
            "",
            "from .helper import hopper",
            "",
            "TEST_FILE = \"Tests/images/hopper.ppm\"",
            "",
            "ORIGINAL_LIMIT = Image.MAX_IMAGE_PIXELS",
            "",
            "",
            "class TestDecompressionBomb:",
            "    @classmethod",
            "    def teardown_class(cls):",
            "        Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT",
            "",
            "    def test_no_warning_small_file(self):",
            "        # Implicit assert: no warning.",
            "        # A warning would cause a failure.",
            "        with Image.open(TEST_FILE):",
            "            pass",
            "",
            "    def test_no_warning_no_limit(self):",
            "        # Arrange",
            "        # Turn limit off",
            "        Image.MAX_IMAGE_PIXELS = None",
            "        assert Image.MAX_IMAGE_PIXELS is None",
            "",
            "        # Act / Assert",
            "        # Implicit assert: no warning.",
            "        # A warning would cause a failure.",
            "        with Image.open(TEST_FILE):",
            "            pass",
            "",
            "    def test_warning(self):",
            "        # Set limit to trigger warning on the test file",
            "        Image.MAX_IMAGE_PIXELS = 128 * 128 - 1",
            "        assert Image.MAX_IMAGE_PIXELS == 128 * 128 - 1",
            "",
            "        def open():",
            "            with Image.open(TEST_FILE):",
            "                pass",
            "",
            "        pytest.warns(Image.DecompressionBombWarning, open)",
            "",
            "    def test_exception(self):",
            "        # Set limit to trigger exception on the test file",
            "        Image.MAX_IMAGE_PIXELS = 64 * 128 - 1",
            "        assert Image.MAX_IMAGE_PIXELS == 64 * 128 - 1",
            "",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(TEST_FILE):",
            "                pass",
            "",
            "    @pytest.mark.xfail(reason=\"different exception\")",
            "    def test_exception_ico(self):",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(\"Tests/images/decompression_bomb.ico\"):",
            "                pass",
            "",
            "    def test_exception_gif(self):",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(\"Tests/images/decompression_bomb.gif\"):",
            "                pass",
            "",
            "    def test_exception_bmp(self):",
            "        with pytest.raises(Image.DecompressionBombError):",
            "            with Image.open(\"Tests/images/bmp/b/reallybig.bmp\"):",
            "                pass",
            "",
            "",
            "class TestDecompressionCrop:",
            "    @classmethod",
            "    def setup_class(self):",
            "        width, height = 128, 128",
            "        Image.MAX_IMAGE_PIXELS = height * width * 4 - 1",
            "",
            "    @classmethod",
            "    def teardown_class(self):",
            "        Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT",
            "",
            "    def testEnlargeCrop(self):",
            "        # Crops can extend the extents, therefore we should have the",
            "        # same decompression bomb warnings on them.",
            "        with hopper() as src:",
            "            box = (0, 0, src.width * 2, src.height * 2)",
            "            pytest.warns(Image.DecompressionBombWarning, src.crop, box)",
            "",
            "    def test_crop_decompression_checks(self):",
            "",
            "        im = Image.new(\"RGB\", (100, 100))",
            "",
            "        good_values = ((-9999, -9999, -9990, -9990), (-999, -999, -990, -990))",
            "",
            "        warning_values = ((-160, -160, 99, 99), (160, 160, -99, -99))",
            "",
            "        error_values = ((-99909, -99990, 99999, 99999), (99909, 99990, -99999, -99999))",
            "",
            "        for value in good_values:",
            "            assert im.crop(value).size == (9, 9)",
            "",
            "        for value in warning_values:",
            "            pytest.warns(Image.DecompressionBombWarning, im.crop, value)",
            "",
            "        for value in error_values:",
            "            with pytest.raises(Image.DecompressionBombError):",
            "                im.crop(value)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "Tests.test_decompression_bomb.TestDecompressionBomb.self"
        ]
    },
    "Tests/test_file_apng.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             exception = e"
            },
            "1": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "         assert exception is None"
            },
            "2": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 314,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    with pytest.raises(SyntaxError):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+    with pytest.raises(OSError):"
            },
            "5": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "         with Image.open(\"Tests/images/apng/syntax_num_frames_high.png\") as im:"
            },
            "6": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "             im.seek(im.n_frames - 1)"
            },
            "7": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "             im.load()"
            }
        },
        "frontPatchFile": [
            "import pytest",
            "",
            "from PIL import Image, ImageSequence, PngImagePlugin",
            "",
            "",
            "# APNG browser support tests and fixtures via:",
            "# https://philip.html5.org/tests/apng/tests.html",
            "# (referenced from https://wiki.mozilla.org/APNG_Specification)",
            "def test_apng_basic():",
            "    with Image.open(\"Tests/images/apng/single_frame.png\") as im:",
            "        assert not im.is_animated",
            "        assert im.n_frames == 1",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\") is None",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/single_frame_default.png\") as im:",
            "        assert im.is_animated",
            "        assert im.n_frames == 2",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\")",
            "        assert im.getpixel((0, 0)) == (255, 0, 0, 255)",
            "        assert im.getpixel((64, 32)) == (255, 0, 0, 255)",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "        # test out of bounds seek",
            "        with pytest.raises(EOFError):",
            "            im.seek(2)",
            "",
            "        # test rewind support",
            "        im.seek(0)",
            "        assert im.getpixel((0, 0)) == (255, 0, 0, 255)",
            "        assert im.getpixel((64, 32)) == (255, 0, 0, 255)",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_fdat():",
            "    with Image.open(\"Tests/images/apng/split_fdat.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/split_fdat_zero_chunk.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_dispose():",
            "    with Image.open(\"Tests/images/apng/dispose_op_none.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_final.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_final.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_first.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "",
            "def test_apng_dispose_region():",
            "    with Image.open(\"Tests/images/apng/dispose_op_none_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_before_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 255, 255)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_dispose_op_previous_frame():",
            "    # Test that the dispose settings being used are from the previous frame",
            "    #",
            "    # Image created with:",
            "    # red = Image.new(\"RGBA\", (128, 64), (255, 0, 0, 255))",
            "    # green = red.copy()",
            "    # green.paste(Image.new(\"RGBA\", (64, 32), (0, 255, 0, 255)))",
            "    # blue = red.copy()",
            "    # blue.paste(Image.new(\"RGBA\", (64, 32), (0, 255, 0, 255)), (64, 32))",
            "    #",
            "    # red.save(",
            "    #     \"Tests/images/apng/dispose_op_previous_frame.png\",",
            "    #     save_all=True,",
            "    #     append_images=[green, blue],",
            "    #     disposal=[",
            "    #         PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS",
            "    #     ],",
            "    # )",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_frame.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (255, 0, 0, 255)",
            "",
            "",
            "def test_apng_dispose_op_background_p_mode():",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_p_mode.png\") as im:",
            "        im.seek(1)",
            "        im.load()",
            "        assert im.size == (128, 64)",
            "",
            "",
            "def test_apng_blend():",
            "    with Image.open(\"Tests/images/apng/blend_op_source_solid.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_source_transparent.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_source_near_transparent.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 2)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 2)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_over.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_over_near_transparent.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 97)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_chunk_order():",
            "    with Image.open(\"Tests/images/apng/fctl_actl.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_delay():",
            "    with Image.open(\"Tests/images/apng/delay.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "        im.seek(3)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(4)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_round.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_short_max.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_zero_denom.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_zero_numer.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 0.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 0.0",
            "        im.seek(3)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(4)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "",
            "def test_apng_num_plays():",
            "    with Image.open(\"Tests/images/apng/num_plays.png\") as im:",
            "        assert im.info.get(\"loop\") == 0",
            "",
            "    with Image.open(\"Tests/images/apng/num_plays_1.png\") as im:",
            "        assert im.info.get(\"loop\") == 1",
            "",
            "",
            "def test_apng_mode():",
            "    with Image.open(\"Tests/images/apng/mode_16bit.png\") as im:",
            "        assert im.mode == \"RGBA\"",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 128, 191)",
            "        assert im.getpixel((64, 32)) == (0, 0, 128, 191)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_greyscale.png\") as im:",
            "        assert im.mode == \"L\"",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == 128",
            "        assert im.getpixel((64, 32)) == 255",
            "",
            "    with Image.open(\"Tests/images/apng/mode_greyscale_alpha.png\") as im:",
            "        assert im.mode == \"LA\"",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (128, 191)",
            "        assert im.getpixel((64, 32)) == (128, 191)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_palette.png\") as im:",
            "        assert im.mode == \"P\"",
            "        im.seek(im.n_frames - 1)",
            "        im = im.convert(\"RGB\")",
            "        assert im.getpixel((0, 0)) == (0, 255, 0)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_palette_alpha.png\") as im:",
            "        assert im.mode == \"P\"",
            "        im.seek(im.n_frames - 1)",
            "        im = im.convert(\"RGBA\")",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_palette_1bit_alpha.png\") as im:",
            "        assert im.mode == \"P\"",
            "        im.seek(im.n_frames - 1)",
            "        im = im.convert(\"RGBA\")",
            "        assert im.getpixel((0, 0)) == (0, 0, 255, 128)",
            "        assert im.getpixel((64, 32)) == (0, 0, 255, 128)",
            "",
            "",
            "def test_apng_chunk_errors():",
            "    with Image.open(\"Tests/images/apng/chunk_no_actl.png\") as im:",
            "        assert not im.is_animated",
            "",
            "    def open():",
            "        with Image.open(\"Tests/images/apng/chunk_multi_actl.png\") as im:",
            "            im.load()",
            "        assert not im.is_animated",
            "",
            "    pytest.warns(UserWarning, open)",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_actl_after_idat.png\") as im:",
            "        assert not im.is_animated",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_no_fctl.png\") as im:",
            "        with pytest.raises(SyntaxError):",
            "            im.seek(im.n_frames - 1)",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_repeat_fctl.png\") as im:",
            "        with pytest.raises(SyntaxError):",
            "            im.seek(im.n_frames - 1)",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_no_fdat.png\") as im:",
            "        with pytest.raises(SyntaxError):",
            "            im.seek(im.n_frames - 1)",
            "",
            "",
            "def test_apng_syntax_errors():",
            "    def open_frames_zero():",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_zero.png\") as im:",
            "            assert not im.is_animated",
            "            with pytest.raises(OSError):",
            "                im.load()",
            "",
            "    pytest.warns(UserWarning, open_frames_zero)",
            "",
            "    def open_frames_zero_default():",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_zero_default.png\") as im:",
            "            assert not im.is_animated",
            "            im.load()",
            "",
            "    pytest.warns(UserWarning, open_frames_zero_default)",
            "",
            "    # we can handle this case gracefully",
            "    exception = None",
            "    with Image.open(\"Tests/images/apng/syntax_num_frames_low.png\") as im:",
            "        try:",
            "            im.seek(im.n_frames - 1)",
            "        except Exception as e:",
            "            exception = e",
            "        assert exception is None",
            "",
            "    with pytest.raises(SyntaxError):",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_high.png\") as im:",
            "            im.seek(im.n_frames - 1)",
            "            im.load()",
            "",
            "    def open():",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_invalid.png\") as im:",
            "            assert not im.is_animated",
            "            im.load()",
            "",
            "    pytest.warns(UserWarning, open)",
            "",
            "",
            "def test_apng_sequence_errors():",
            "    test_files = [",
            "        \"sequence_start.png\",",
            "        \"sequence_gap.png\",",
            "        \"sequence_repeat.png\",",
            "        \"sequence_repeat_chunk.png\",",
            "        \"sequence_reorder.png\",",
            "        \"sequence_reorder_chunk.png\",",
            "        \"sequence_fdat_fctl.png\",",
            "    ]",
            "    for f in test_files:",
            "        with pytest.raises(SyntaxError):",
            "            with Image.open(f\"Tests/images/apng/{f}\") as im:",
            "                im.seek(im.n_frames - 1)",
            "                im.load()",
            "",
            "",
            "def test_apng_save(tmp_path):",
            "    with Image.open(\"Tests/images/apng/single_frame.png\") as im:",
            "        test_file = str(tmp_path / \"temp.png\")",
            "        im.save(test_file, save_all=True)",
            "",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert not im.is_animated",
            "        assert im.n_frames == 1",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\") is None",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/single_frame_default.png\") as im:",
            "        frames = []",
            "        for frame_im in ImageSequence.Iterator(im):",
            "            frames.append(frame_im.copy())",
            "        frames[0].save(",
            "            test_file, save_all=True, default_image=True, append_images=frames[1:]",
            "        )",
            "",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.is_animated",
            "        assert im.n_frames == 2",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\")",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_save_split_fdat(tmp_path):",
            "    # test to make sure we do not generate sequence errors when writing",
            "    # frames with image data spanning multiple fdAT chunks (in this case",
            "    # both the default image and first animation frame will span multiple",
            "    # data chunks)",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    with Image.open(\"Tests/images/old-style-jpeg-compression.png\") as im:",
            "        frames = [im.copy(), Image.new(\"RGBA\", im.size, (255, 0, 0, 255))]",
            "        im.save(",
            "            test_file,",
            "            save_all=True,",
            "            default_image=True,",
            "            append_images=frames,",
            "        )",
            "    with Image.open(test_file) as im:",
            "        exception = None",
            "        try:",
            "            im.seek(im.n_frames - 1)",
            "            im.load()",
            "        except Exception as e:",
            "            exception = e",
            "        assert exception is None",
            "",
            "",
            "def test_apng_save_duration_loop(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    with Image.open(\"Tests/images/apng/delay.png\") as im:",
            "        frames = []",
            "        durations = []",
            "        loop = im.info.get(\"loop\")",
            "        default_image = im.info.get(\"default_image\")",
            "        for i, frame_im in enumerate(ImageSequence.Iterator(im)):",
            "            frames.append(frame_im.copy())",
            "            if i != 0 or not default_image:",
            "                durations.append(frame_im.info.get(\"duration\", 0))",
            "        frames[0].save(",
            "            test_file,",
            "            save_all=True,",
            "            default_image=default_image,",
            "            append_images=frames[1:],",
            "            duration=durations,",
            "            loop=loop,",
            "        )",
            "",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.info.get(\"loop\") == loop",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "        im.seek(3)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(4)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    # test removal of duplicated frames",
            "    frame = Image.new(\"RGBA\", (128, 64), (255, 0, 0, 255))",
            "    frame.save(test_file, save_all=True, append_images=[frame], duration=[500, 250])",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.n_frames == 1",
            "        assert im.info.get(\"duration\") == 750",
            "",
            "",
            "def test_apng_save_disposal(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    size = (128, 64)",
            "    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))",
            "    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))",
            "    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))",
            "",
            "    # test APNG_DISPOSE_OP_NONE",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green, transparent],",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    # test APNG_DISPOSE_OP_BACKGROUND",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, transparent],",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green],",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    # test APNG_DISPOSE_OP_PREVIOUS",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green, red, transparent],",
            "        default_image=True,",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(3)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green],",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_save_disposal_previous(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    size = (128, 64)",
            "    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))",
            "    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))",
            "    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))",
            "",
            "    # test APNG_DISPOSE_OP_NONE",
            "    transparent.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, green],",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_save_blend(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    size = (128, 64)",
            "    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))",
            "    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))",
            "    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))",
            "",
            "    # test APNG_BLEND_OP_SOURCE on solid color",
            "    blend = [",
            "        PngImagePlugin.APNG_BLEND_OP_OVER,",
            "        PngImagePlugin.APNG_BLEND_OP_SOURCE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, green],",
            "        default_image=True,",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=blend,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    # test APNG_BLEND_OP_SOURCE on transparent color",
            "    blend = [",
            "        PngImagePlugin.APNG_BLEND_OP_OVER,",
            "        PngImagePlugin.APNG_BLEND_OP_SOURCE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, transparent],",
            "        default_image=True,",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=blend,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    # test APNG_BLEND_OP_OVER",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green, transparent],",
            "        default_image=True,",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)"
        ],
        "afterPatchFile": [
            "import pytest",
            "",
            "from PIL import Image, ImageSequence, PngImagePlugin",
            "",
            "",
            "# APNG browser support tests and fixtures via:",
            "# https://philip.html5.org/tests/apng/tests.html",
            "# (referenced from https://wiki.mozilla.org/APNG_Specification)",
            "def test_apng_basic():",
            "    with Image.open(\"Tests/images/apng/single_frame.png\") as im:",
            "        assert not im.is_animated",
            "        assert im.n_frames == 1",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\") is None",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/single_frame_default.png\") as im:",
            "        assert im.is_animated",
            "        assert im.n_frames == 2",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\")",
            "        assert im.getpixel((0, 0)) == (255, 0, 0, 255)",
            "        assert im.getpixel((64, 32)) == (255, 0, 0, 255)",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "        # test out of bounds seek",
            "        with pytest.raises(EOFError):",
            "            im.seek(2)",
            "",
            "        # test rewind support",
            "        im.seek(0)",
            "        assert im.getpixel((0, 0)) == (255, 0, 0, 255)",
            "        assert im.getpixel((64, 32)) == (255, 0, 0, 255)",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_fdat():",
            "    with Image.open(\"Tests/images/apng/split_fdat.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/split_fdat_zero_chunk.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_dispose():",
            "    with Image.open(\"Tests/images/apng/dispose_op_none.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_final.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_final.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_first.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "",
            "def test_apng_dispose_region():",
            "    with Image.open(\"Tests/images/apng/dispose_op_none_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_before_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 255, 255)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_region.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_dispose_op_previous_frame():",
            "    # Test that the dispose settings being used are from the previous frame",
            "    #",
            "    # Image created with:",
            "    # red = Image.new(\"RGBA\", (128, 64), (255, 0, 0, 255))",
            "    # green = red.copy()",
            "    # green.paste(Image.new(\"RGBA\", (64, 32), (0, 255, 0, 255)))",
            "    # blue = red.copy()",
            "    # blue.paste(Image.new(\"RGBA\", (64, 32), (0, 255, 0, 255)), (64, 32))",
            "    #",
            "    # red.save(",
            "    #     \"Tests/images/apng/dispose_op_previous_frame.png\",",
            "    #     save_all=True,",
            "    #     append_images=[green, blue],",
            "    #     disposal=[",
            "    #         PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "    #         PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS",
            "    #     ],",
            "    # )",
            "    with Image.open(\"Tests/images/apng/dispose_op_previous_frame.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (255, 0, 0, 255)",
            "",
            "",
            "def test_apng_dispose_op_background_p_mode():",
            "    with Image.open(\"Tests/images/apng/dispose_op_background_p_mode.png\") as im:",
            "        im.seek(1)",
            "        im.load()",
            "        assert im.size == (128, 64)",
            "",
            "",
            "def test_apng_blend():",
            "    with Image.open(\"Tests/images/apng/blend_op_source_solid.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_source_transparent.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_source_near_transparent.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 2)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 2)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_over.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/blend_op_over_near_transparent.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 97)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_chunk_order():",
            "    with Image.open(\"Tests/images/apng/fctl_actl.png\") as im:",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_delay():",
            "    with Image.open(\"Tests/images/apng/delay.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "        im.seek(3)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(4)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_round.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_short_max.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_zero_denom.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    with Image.open(\"Tests/images/apng/delay_zero_numer.png\") as im:",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 0.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 0.0",
            "        im.seek(3)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(4)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "",
            "def test_apng_num_plays():",
            "    with Image.open(\"Tests/images/apng/num_plays.png\") as im:",
            "        assert im.info.get(\"loop\") == 0",
            "",
            "    with Image.open(\"Tests/images/apng/num_plays_1.png\") as im:",
            "        assert im.info.get(\"loop\") == 1",
            "",
            "",
            "def test_apng_mode():",
            "    with Image.open(\"Tests/images/apng/mode_16bit.png\") as im:",
            "        assert im.mode == \"RGBA\"",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (0, 0, 128, 191)",
            "        assert im.getpixel((64, 32)) == (0, 0, 128, 191)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_greyscale.png\") as im:",
            "        assert im.mode == \"L\"",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == 128",
            "        assert im.getpixel((64, 32)) == 255",
            "",
            "    with Image.open(\"Tests/images/apng/mode_greyscale_alpha.png\") as im:",
            "        assert im.mode == \"LA\"",
            "        im.seek(im.n_frames - 1)",
            "        assert im.getpixel((0, 0)) == (128, 191)",
            "        assert im.getpixel((64, 32)) == (128, 191)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_palette.png\") as im:",
            "        assert im.mode == \"P\"",
            "        im.seek(im.n_frames - 1)",
            "        im = im.convert(\"RGB\")",
            "        assert im.getpixel((0, 0)) == (0, 255, 0)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_palette_alpha.png\") as im:",
            "        assert im.mode == \"P\"",
            "        im.seek(im.n_frames - 1)",
            "        im = im.convert(\"RGBA\")",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/mode_palette_1bit_alpha.png\") as im:",
            "        assert im.mode == \"P\"",
            "        im.seek(im.n_frames - 1)",
            "        im = im.convert(\"RGBA\")",
            "        assert im.getpixel((0, 0)) == (0, 0, 255, 128)",
            "        assert im.getpixel((64, 32)) == (0, 0, 255, 128)",
            "",
            "",
            "def test_apng_chunk_errors():",
            "    with Image.open(\"Tests/images/apng/chunk_no_actl.png\") as im:",
            "        assert not im.is_animated",
            "",
            "    def open():",
            "        with Image.open(\"Tests/images/apng/chunk_multi_actl.png\") as im:",
            "            im.load()",
            "        assert not im.is_animated",
            "",
            "    pytest.warns(UserWarning, open)",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_actl_after_idat.png\") as im:",
            "        assert not im.is_animated",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_no_fctl.png\") as im:",
            "        with pytest.raises(SyntaxError):",
            "            im.seek(im.n_frames - 1)",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_repeat_fctl.png\") as im:",
            "        with pytest.raises(SyntaxError):",
            "            im.seek(im.n_frames - 1)",
            "",
            "    with Image.open(\"Tests/images/apng/chunk_no_fdat.png\") as im:",
            "        with pytest.raises(SyntaxError):",
            "            im.seek(im.n_frames - 1)",
            "",
            "",
            "def test_apng_syntax_errors():",
            "    def open_frames_zero():",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_zero.png\") as im:",
            "            assert not im.is_animated",
            "            with pytest.raises(OSError):",
            "                im.load()",
            "",
            "    pytest.warns(UserWarning, open_frames_zero)",
            "",
            "    def open_frames_zero_default():",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_zero_default.png\") as im:",
            "            assert not im.is_animated",
            "            im.load()",
            "",
            "    pytest.warns(UserWarning, open_frames_zero_default)",
            "",
            "    # we can handle this case gracefully",
            "    exception = None",
            "    with Image.open(\"Tests/images/apng/syntax_num_frames_low.png\") as im:",
            "        try:",
            "            im.seek(im.n_frames - 1)",
            "        except Exception as e:",
            "            exception = e",
            "        assert exception is None",
            "",
            "    with pytest.raises(OSError):",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_high.png\") as im:",
            "            im.seek(im.n_frames - 1)",
            "            im.load()",
            "",
            "    def open():",
            "        with Image.open(\"Tests/images/apng/syntax_num_frames_invalid.png\") as im:",
            "            assert not im.is_animated",
            "            im.load()",
            "",
            "    pytest.warns(UserWarning, open)",
            "",
            "",
            "def test_apng_sequence_errors():",
            "    test_files = [",
            "        \"sequence_start.png\",",
            "        \"sequence_gap.png\",",
            "        \"sequence_repeat.png\",",
            "        \"sequence_repeat_chunk.png\",",
            "        \"sequence_reorder.png\",",
            "        \"sequence_reorder_chunk.png\",",
            "        \"sequence_fdat_fctl.png\",",
            "    ]",
            "    for f in test_files:",
            "        with pytest.raises(SyntaxError):",
            "            with Image.open(f\"Tests/images/apng/{f}\") as im:",
            "                im.seek(im.n_frames - 1)",
            "                im.load()",
            "",
            "",
            "def test_apng_save(tmp_path):",
            "    with Image.open(\"Tests/images/apng/single_frame.png\") as im:",
            "        test_file = str(tmp_path / \"temp.png\")",
            "        im.save(test_file, save_all=True)",
            "",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert not im.is_animated",
            "        assert im.n_frames == 1",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\") is None",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    with Image.open(\"Tests/images/apng/single_frame_default.png\") as im:",
            "        frames = []",
            "        for frame_im in ImageSequence.Iterator(im):",
            "            frames.append(frame_im.copy())",
            "        frames[0].save(",
            "            test_file, save_all=True, default_image=True, append_images=frames[1:]",
            "        )",
            "",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.is_animated",
            "        assert im.n_frames == 2",
            "        assert im.get_format_mimetype() == \"image/apng\"",
            "        assert im.info.get(\"default_image\")",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_save_split_fdat(tmp_path):",
            "    # test to make sure we do not generate sequence errors when writing",
            "    # frames with image data spanning multiple fdAT chunks (in this case",
            "    # both the default image and first animation frame will span multiple",
            "    # data chunks)",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    with Image.open(\"Tests/images/old-style-jpeg-compression.png\") as im:",
            "        frames = [im.copy(), Image.new(\"RGBA\", im.size, (255, 0, 0, 255))]",
            "        im.save(",
            "            test_file,",
            "            save_all=True,",
            "            default_image=True,",
            "            append_images=frames,",
            "        )",
            "    with Image.open(test_file) as im:",
            "        exception = None",
            "        try:",
            "            im.seek(im.n_frames - 1)",
            "            im.load()",
            "        except Exception as e:",
            "            exception = e",
            "        assert exception is None",
            "",
            "",
            "def test_apng_save_duration_loop(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    with Image.open(\"Tests/images/apng/delay.png\") as im:",
            "        frames = []",
            "        durations = []",
            "        loop = im.info.get(\"loop\")",
            "        default_image = im.info.get(\"default_image\")",
            "        for i, frame_im in enumerate(ImageSequence.Iterator(im)):",
            "            frames.append(frame_im.copy())",
            "            if i != 0 or not default_image:",
            "                durations.append(frame_im.info.get(\"duration\", 0))",
            "        frames[0].save(",
            "            test_file,",
            "            save_all=True,",
            "            default_image=default_image,",
            "            append_images=frames[1:],",
            "            duration=durations,",
            "            loop=loop,",
            "        )",
            "",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.info.get(\"loop\") == loop",
            "        im.seek(1)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(2)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "        im.seek(3)",
            "        assert im.info.get(\"duration\") == 500.0",
            "        im.seek(4)",
            "        assert im.info.get(\"duration\") == 1000.0",
            "",
            "    # test removal of duplicated frames",
            "    frame = Image.new(\"RGBA\", (128, 64), (255, 0, 0, 255))",
            "    frame.save(test_file, save_all=True, append_images=[frame], duration=[500, 250])",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.n_frames == 1",
            "        assert im.info.get(\"duration\") == 750",
            "",
            "",
            "def test_apng_save_disposal(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    size = (128, 64)",
            "    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))",
            "    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))",
            "    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))",
            "",
            "    # test APNG_DISPOSE_OP_NONE",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green, transparent],",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    # test APNG_DISPOSE_OP_BACKGROUND",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, transparent],",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_BACKGROUND,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green],",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    # test APNG_DISPOSE_OP_PREVIOUS",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green, red, transparent],",
            "        default_image=True,",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(3)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    disposal = [",
            "        PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green],",
            "        disposal=disposal,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_save_disposal_previous(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    size = (128, 64)",
            "    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))",
            "    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))",
            "    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))",
            "",
            "    # test APNG_DISPOSE_OP_NONE",
            "    transparent.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, green],",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_PREVIOUS,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "",
            "def test_apng_save_blend(tmp_path):",
            "    test_file = str(tmp_path / \"temp.png\")",
            "    size = (128, 64)",
            "    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))",
            "    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))",
            "    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))",
            "",
            "    # test APNG_BLEND_OP_SOURCE on solid color",
            "    blend = [",
            "        PngImagePlugin.APNG_BLEND_OP_OVER,",
            "        PngImagePlugin.APNG_BLEND_OP_SOURCE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, green],",
            "        default_image=True,",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=blend,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "",
            "    # test APNG_BLEND_OP_SOURCE on transparent color",
            "    blend = [",
            "        PngImagePlugin.APNG_BLEND_OP_OVER,",
            "        PngImagePlugin.APNG_BLEND_OP_SOURCE,",
            "    ]",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[red, transparent],",
            "        default_image=True,",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=blend,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 0, 0, 0)",
            "        assert im.getpixel((64, 32)) == (0, 0, 0, 0)",
            "",
            "    # test APNG_BLEND_OP_OVER",
            "    red.save(",
            "        test_file,",
            "        save_all=True,",
            "        append_images=[green, transparent],",
            "        default_image=True,",
            "        disposal=PngImagePlugin.APNG_DISPOSE_OP_NONE,",
            "        blend=PngImagePlugin.APNG_BLEND_OP_OVER,",
            "    )",
            "    with Image.open(test_file) as im:",
            "        im.seek(1)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)",
            "        im.seek(2)",
            "        assert im.getpixel((0, 0)) == (0, 255, 0, 255)",
            "        assert im.getpixel((64, 32)) == (0, 255, 0, 255)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "315": [
                "test_apng_syntax_errors"
            ]
        },
        "addLocation": []
    },
    "Tests/test_file_blp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from PIL import Image"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import pytest"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from .helper import assert_image_equal_tofile"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from PIL import Image",
            "",
            "from .helper import assert_image_equal_tofile",
            "",
            "",
            "def test_load_blp2_raw():",
            "    with Image.open(\"Tests/images/blp/blp2_raw.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_raw.png\")",
            "",
            "",
            "def test_load_blp2_dxt1():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1.png\")",
            "",
            "",
            "def test_load_blp2_dxt1a():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1a.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1a.png\")"
        ],
        "afterPatchFile": [
            "from PIL import Image",
            "import pytest",
            "",
            "from .helper import assert_image_equal_tofile",
            "",
            "",
            "def test_load_blp2_raw():",
            "    with Image.open(\"Tests/images/blp/blp2_raw.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_raw.png\")",
            "",
            "",
            "def test_load_blp2_dxt1():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1.png\")",
            "",
            "",
            "def test_load_blp2_dxt1a():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1a.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1a.png\")"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "Tests/test_file_psd.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "     with pytest.raises(OSError):"
            },
            "1": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         with Image.open(\"Tests/images/combined_larger_than_size.psd\"):"
            },
            "2": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "             pass"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+@pytest.mark.parametrize("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    \"test_file,raises\","
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    ["
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        (\"Tests/images/timeout-1ee28a249896e05b83840ae8140622de8e648ba9.psd\", Image.UnidentifiedImageError),"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        (\"Tests/images/timeout-598843abc37fc080ec36a2699ebbd44f795d3a6f.psd\", Image.UnidentifiedImageError),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        (\"Tests/images/timeout-c8efc3fded6426986ba867a399791bae544f59bc.psd\", OSError),"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        (\"Tests/images/timeout-dedc7a4ebd856d79b4359bbcc79e8ef231ce38f6.psd\", OSError),"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    ],"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+def test_crashes(test_file, raises):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    with open(test_file, \"rb\") as f:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        with pytest.raises(raises):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            with Image.open(f):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+                pass"
            }
        },
        "frontPatchFile": [
            "import pytest",
            "",
            "from PIL import Image, PsdImagePlugin",
            "",
            "from .helper import assert_image_similar, hopper, is_pypy",
            "",
            "test_file = \"Tests/images/hopper.psd\"",
            "",
            "",
            "def test_sanity():",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.mode == \"RGB\"",
            "        assert im.size == (128, 128)",
            "        assert im.format == \"PSD\"",
            "        assert im.get_format_mimetype() == \"image/vnd.adobe.photoshop\"",
            "",
            "        im2 = hopper()",
            "        assert_image_similar(im, im2, 4.8)",
            "",
            "",
            "@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")",
            "def test_unclosed_file():",
            "    def open():",
            "        im = Image.open(test_file)",
            "        im.load()",
            "",
            "    pytest.warns(ResourceWarning, open)",
            "",
            "",
            "def test_closed_file():",
            "    with pytest.warns(None) as record:",
            "        im = Image.open(test_file)",
            "        im.load()",
            "        im.close()",
            "",
            "    assert not record",
            "",
            "",
            "def test_context_manager():",
            "    with pytest.warns(None) as record:",
            "        with Image.open(test_file) as im:",
            "            im.load()",
            "",
            "    assert not record",
            "",
            "",
            "def test_invalid_file():",
            "    invalid_file = \"Tests/images/flower.jpg\"",
            "",
            "    with pytest.raises(SyntaxError):",
            "        PsdImagePlugin.PsdImageFile(invalid_file)",
            "",
            "",
            "def test_n_frames():",
            "    with Image.open(\"Tests/images/hopper_merged.psd\") as im:",
            "        assert im.n_frames == 1",
            "        assert not im.is_animated",
            "",
            "    with Image.open(test_file) as im:",
            "        assert im.n_frames == 2",
            "        assert im.is_animated",
            "",
            "",
            "def test_eoferror():",
            "    with Image.open(test_file) as im:",
            "        # PSD seek index starts at 1 rather than 0",
            "        n_frames = im.n_frames + 1",
            "",
            "        # Test seeking past the last frame",
            "        with pytest.raises(EOFError):",
            "            im.seek(n_frames)",
            "        assert im.tell() < n_frames",
            "",
            "        # Test that seeking to the last frame does not raise an error",
            "        im.seek(n_frames - 1)",
            "",
            "",
            "def test_seek_tell():",
            "    with Image.open(test_file) as im:",
            "",
            "        layer_number = im.tell()",
            "        assert layer_number == 1",
            "",
            "        with pytest.raises(EOFError):",
            "            im.seek(0)",
            "",
            "        im.seek(1)",
            "        layer_number = im.tell()",
            "        assert layer_number == 1",
            "",
            "        im.seek(2)",
            "        layer_number = im.tell()",
            "        assert layer_number == 2",
            "",
            "",
            "def test_seek_eoferror():",
            "    with Image.open(test_file) as im:",
            "",
            "        with pytest.raises(EOFError):",
            "            im.seek(-1)",
            "",
            "",
            "def test_open_after_exclusive_load():",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        im.seek(im.tell() + 1)",
            "        im.load()",
            "",
            "",
            "def test_icc_profile():",
            "    with Image.open(test_file) as im:",
            "        assert \"icc_profile\" in im.info",
            "",
            "        icc_profile = im.info[\"icc_profile\"]",
            "        assert len(icc_profile) == 3144",
            "",
            "",
            "def test_no_icc_profile():",
            "    with Image.open(\"Tests/images/hopper_merged.psd\") as im:",
            "        assert \"icc_profile\" not in im.info",
            "",
            "",
            "def test_combined_larger_than_size():",
            "    # The 'combined' sizes of the individual parts is larger than the",
            "    # declared 'size' of the extra data field, resulting in a backwards seek.",
            "",
            "    # If we instead take the 'size' of the extra data field as the source of truth,",
            "    # then the seek can't be negative",
            "    with pytest.raises(OSError):",
            "        with Image.open(\"Tests/images/combined_larger_than_size.psd\"):",
            "            pass"
        ],
        "afterPatchFile": [
            "import pytest",
            "",
            "from PIL import Image, PsdImagePlugin",
            "",
            "from .helper import assert_image_similar, hopper, is_pypy",
            "",
            "test_file = \"Tests/images/hopper.psd\"",
            "",
            "",
            "def test_sanity():",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        assert im.mode == \"RGB\"",
            "        assert im.size == (128, 128)",
            "        assert im.format == \"PSD\"",
            "        assert im.get_format_mimetype() == \"image/vnd.adobe.photoshop\"",
            "",
            "        im2 = hopper()",
            "        assert_image_similar(im, im2, 4.8)",
            "",
            "",
            "@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")",
            "def test_unclosed_file():",
            "    def open():",
            "        im = Image.open(test_file)",
            "        im.load()",
            "",
            "    pytest.warns(ResourceWarning, open)",
            "",
            "",
            "def test_closed_file():",
            "    with pytest.warns(None) as record:",
            "        im = Image.open(test_file)",
            "        im.load()",
            "        im.close()",
            "",
            "    assert not record",
            "",
            "",
            "def test_context_manager():",
            "    with pytest.warns(None) as record:",
            "        with Image.open(test_file) as im:",
            "            im.load()",
            "",
            "    assert not record",
            "",
            "",
            "def test_invalid_file():",
            "    invalid_file = \"Tests/images/flower.jpg\"",
            "",
            "    with pytest.raises(SyntaxError):",
            "        PsdImagePlugin.PsdImageFile(invalid_file)",
            "",
            "",
            "def test_n_frames():",
            "    with Image.open(\"Tests/images/hopper_merged.psd\") as im:",
            "        assert im.n_frames == 1",
            "        assert not im.is_animated",
            "",
            "    with Image.open(test_file) as im:",
            "        assert im.n_frames == 2",
            "        assert im.is_animated",
            "",
            "",
            "def test_eoferror():",
            "    with Image.open(test_file) as im:",
            "        # PSD seek index starts at 1 rather than 0",
            "        n_frames = im.n_frames + 1",
            "",
            "        # Test seeking past the last frame",
            "        with pytest.raises(EOFError):",
            "            im.seek(n_frames)",
            "        assert im.tell() < n_frames",
            "",
            "        # Test that seeking to the last frame does not raise an error",
            "        im.seek(n_frames - 1)",
            "",
            "",
            "def test_seek_tell():",
            "    with Image.open(test_file) as im:",
            "",
            "        layer_number = im.tell()",
            "        assert layer_number == 1",
            "",
            "        with pytest.raises(EOFError):",
            "            im.seek(0)",
            "",
            "        im.seek(1)",
            "        layer_number = im.tell()",
            "        assert layer_number == 1",
            "",
            "        im.seek(2)",
            "        layer_number = im.tell()",
            "        assert layer_number == 2",
            "",
            "",
            "def test_seek_eoferror():",
            "    with Image.open(test_file) as im:",
            "",
            "        with pytest.raises(EOFError):",
            "            im.seek(-1)",
            "",
            "",
            "def test_open_after_exclusive_load():",
            "    with Image.open(test_file) as im:",
            "        im.load()",
            "        im.seek(im.tell() + 1)",
            "        im.load()",
            "",
            "",
            "def test_icc_profile():",
            "    with Image.open(test_file) as im:",
            "        assert \"icc_profile\" in im.info",
            "",
            "        icc_profile = im.info[\"icc_profile\"]",
            "        assert len(icc_profile) == 3144",
            "",
            "",
            "def test_no_icc_profile():",
            "    with Image.open(\"Tests/images/hopper_merged.psd\") as im:",
            "        assert \"icc_profile\" not in im.info",
            "",
            "",
            "def test_combined_larger_than_size():",
            "    # The 'combined' sizes of the individual parts is larger than the",
            "    # declared 'size' of the extra data field, resulting in a backwards seek.",
            "",
            "    # If we instead take the 'size' of the extra data field as the source of truth,",
            "    # then the seek can't be negative",
            "    with pytest.raises(OSError):",
            "        with Image.open(\"Tests/images/combined_larger_than_size.psd\"):",
            "            pass",
            "",
            "@pytest.mark.parametrize(",
            "    \"test_file,raises\",",
            "    [",
            "        (\"Tests/images/timeout-1ee28a249896e05b83840ae8140622de8e648ba9.psd\", Image.UnidentifiedImageError),",
            "        (\"Tests/images/timeout-598843abc37fc080ec36a2699ebbd44f795d3a6f.psd\", Image.UnidentifiedImageError),",
            "        (\"Tests/images/timeout-c8efc3fded6426986ba867a399791bae544f59bc.psd\", OSError),",
            "        (\"Tests/images/timeout-dedc7a4ebd856d79b4359bbcc79e8ef231ce38f6.psd\", OSError),",
            "    ],",
            ")",
            "def test_crashes(test_file, raises):",
            "    with open(test_file, \"rb\") as f:",
            "        with pytest.raises(raises):",
            "            with Image.open(f):",
            "                pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "litellm.utils.exception_type"
        ]
    },
    "Tests/test_file_tiff.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "     )"
            },
            "1": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "     def test_string_dimension(self):"
            },
            "2": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "         # Assert that an error is raised if one of the dimensions is a string"
            },
            "3": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with pytest.raises(ValueError):"
            },
            "4": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            with Image.open(\"Tests/images/string_dimension.tiff\"):"
            },
            "5": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                pass"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+        with pytest.raises(OSError):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 629,
                "PatchRowcode": "+            with Image.open(\"Tests/images/string_dimension.tiff\") as im:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 630,
                "PatchRowcode": "+                im.load()"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 631,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": 632,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 633,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": 634,
                "PatchRowcode": " @pytest.mark.skipif(not is_win32(), reason=\"Windows only\")"
            }
        },
        "frontPatchFile": [
            "import os",
            "from io import BytesIO",
            "",
            "import pytest",
            "",
            "from PIL import Image, TiffImagePlugin",
            "from PIL.TiffImagePlugin import RESOLUTION_UNIT, X_RESOLUTION, Y_RESOLUTION",
            "",
            "from .helper import (",
            "    assert_image_equal,",
            "    assert_image_equal_tofile,",
            "    assert_image_similar,",
            "    assert_image_similar_tofile,",
            "    hopper,",
            "    is_pypy,",
            "    is_win32,",
            ")",
            "",
            "",
            "class TestFileTiff:",
            "    def test_sanity(self, tmp_path):",
            "",
            "        filename = str(tmp_path / \"temp.tif\")",
            "",
            "        hopper(\"RGB\").save(filename)",
            "",
            "        with Image.open(filename) as im:",
            "            im.load()",
            "        assert im.mode == \"RGB\"",
            "        assert im.size == (128, 128)",
            "        assert im.format == \"TIFF\"",
            "",
            "        hopper(\"1\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"L\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"P\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"RGB\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"I\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "    @pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")",
            "    def test_unclosed_file(self):",
            "        def open():",
            "            im = Image.open(\"Tests/images/multipage.tiff\")",
            "            im.load()",
            "",
            "        pytest.warns(ResourceWarning, open)",
            "",
            "    def test_closed_file(self):",
            "        with pytest.warns(None) as record:",
            "            im = Image.open(\"Tests/images/multipage.tiff\")",
            "            im.load()",
            "            im.close()",
            "",
            "        assert not record",
            "",
            "    def test_context_manager(self):",
            "        with pytest.warns(None) as record:",
            "            with Image.open(\"Tests/images/multipage.tiff\") as im:",
            "                im.load()",
            "",
            "        assert not record",
            "",
            "    def test_mac_tiff(self):",
            "        # Read RGBa images from macOS [@PIL136]",
            "",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            assert im.mode == \"RGBA\"",
            "            assert im.size == (55, 43)",
            "            assert im.tile == [(\"raw\", (0, 0, 55, 43), 8, (\"RGBa\", 0, 1))]",
            "            im.load()",
            "",
            "            assert_image_similar_tofile(im, \"Tests/images/pil136.png\", 1)",
            "",
            "    def test_wrong_bits_per_sample(self):",
            "        with Image.open(\"Tests/images/tiff_wrong_bits_per_sample.tiff\") as im:",
            "            assert im.mode == \"RGBA\"",
            "            assert im.size == (52, 53)",
            "            assert im.tile == [(\"raw\", (0, 0, 52, 53), 160, (\"RGBA\", 0, 1))]",
            "            im.load()",
            "",
            "    def test_set_legacy_api(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        with pytest.raises(Exception) as e:",
            "            ifd.legacy_api = None",
            "        assert str(e.value) == \"Not allowing setting of legacy api\"",
            "",
            "    def test_xyres_tiff(self):",
            "        filename = \"Tests/images/pil168.tif\"",
            "        with Image.open(filename) as im:",
            "",
            "            # legacy api",
            "            assert isinstance(im.tag[X_RESOLUTION][0], tuple)",
            "            assert isinstance(im.tag[Y_RESOLUTION][0], tuple)",
            "",
            "            # v2 api",
            "            assert isinstance(im.tag_v2[X_RESOLUTION], TiffImagePlugin.IFDRational)",
            "            assert isinstance(im.tag_v2[Y_RESOLUTION], TiffImagePlugin.IFDRational)",
            "",
            "            assert im.info[\"dpi\"] == (72.0, 72.0)",
            "",
            "    def test_xyres_fallback_tiff(self):",
            "        filename = \"Tests/images/compression.tif\"",
            "        with Image.open(filename) as im:",
            "",
            "            # v2 api",
            "            assert isinstance(im.tag_v2[X_RESOLUTION], TiffImagePlugin.IFDRational)",
            "            assert isinstance(im.tag_v2[Y_RESOLUTION], TiffImagePlugin.IFDRational)",
            "            with pytest.raises(KeyError):",
            "                im.tag_v2[RESOLUTION_UNIT]",
            "",
            "            # Legacy.",
            "            assert im.info[\"resolution\"] == (100.0, 100.0)",
            "            # Fallback \"inch\".",
            "            assert im.info[\"dpi\"] == (100.0, 100.0)",
            "",
            "    def test_int_resolution(self):",
            "        filename = \"Tests/images/pil168.tif\"",
            "        with Image.open(filename) as im:",
            "",
            "            # Try to read a file where X,Y_RESOLUTION are ints",
            "            im.tag_v2[X_RESOLUTION] = 71",
            "            im.tag_v2[Y_RESOLUTION] = 71",
            "            im._setup()",
            "            assert im.info[\"dpi\"] == (71.0, 71.0)",
            "",
            "    def test_load_dpi_rounding(self):",
            "        for resolutionUnit, dpi in ((None, (72, 73)), (2, (72, 73)), (3, (183, 185))):",
            "            with Image.open(",
            "                \"Tests/images/hopper_roundDown_\" + str(resolutionUnit) + \".tif\"",
            "            ) as im:",
            "                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit",
            "                assert im.info[\"dpi\"] == (dpi[0], dpi[0])",
            "",
            "            with Image.open(",
            "                \"Tests/images/hopper_roundUp_\" + str(resolutionUnit) + \".tif\"",
            "            ) as im:",
            "                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit",
            "                assert im.info[\"dpi\"] == (dpi[1], dpi[1])",
            "",
            "    def test_save_dpi_rounding(self, tmp_path):",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        with Image.open(\"Tests/images/hopper.tif\") as im:",
            "            for dpi in (72.2, 72.8):",
            "                im.save(outfile, dpi=(dpi, dpi))",
            "",
            "                with Image.open(outfile) as reloaded:",
            "                    reloaded.load()",
            "                    assert (round(dpi), round(dpi)) == reloaded.info[\"dpi\"]",
            "",
            "    def test_save_setting_missing_resolution(self):",
            "        b = BytesIO()",
            "        with Image.open(\"Tests/images/10ct_32bit_128.tiff\") as im:",
            "            im.save(b, format=\"tiff\", resolution=123.45)",
            "        with Image.open(b) as im:",
            "            assert float(im.tag_v2[X_RESOLUTION]) == 123.45",
            "            assert float(im.tag_v2[Y_RESOLUTION]) == 123.45",
            "",
            "    def test_invalid_file(self):",
            "        invalid_file = \"Tests/images/flower.jpg\"",
            "",
            "        with pytest.raises(SyntaxError):",
            "            TiffImagePlugin.TiffImageFile(invalid_file)",
            "",
            "        TiffImagePlugin.PREFIXES.append(b\"\\xff\\xd8\\xff\\xe0\")",
            "        with pytest.raises(SyntaxError):",
            "            TiffImagePlugin.TiffImageFile(invalid_file)",
            "        TiffImagePlugin.PREFIXES.pop()",
            "",
            "    def test_bad_exif(self):",
            "        with Image.open(\"Tests/images/hopper_bad_exif.jpg\") as i:",
            "            # Should not raise struct.error.",
            "            pytest.warns(UserWarning, i._getexif)",
            "",
            "    def test_save_rgba(self, tmp_path):",
            "        im = hopper(\"RGBA\")",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        im.save(outfile)",
            "",
            "    def test_save_unsupported_mode(self, tmp_path):",
            "        im = hopper(\"HSV\")",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        with pytest.raises(OSError):",
            "            im.save(outfile)",
            "",
            "    def test_little_endian(self):",
            "        with Image.open(\"Tests/images/16bit.cropped.tif\") as im:",
            "            assert im.getpixel((0, 0)) == 480",
            "            assert im.mode == \"I;16\"",
            "",
            "            b = im.tobytes()",
            "        # Bytes are in image native order (little endian)",
            "        assert b[0] == ord(b\"\\xe0\")",
            "        assert b[1] == ord(b\"\\x01\")",
            "",
            "    def test_big_endian(self):",
            "        with Image.open(\"Tests/images/16bit.MM.cropped.tif\") as im:",
            "            assert im.getpixel((0, 0)) == 480",
            "            assert im.mode == \"I;16B\"",
            "",
            "            b = im.tobytes()",
            "        # Bytes are in image native order (big endian)",
            "        assert b[0] == ord(b\"\\x01\")",
            "        assert b[1] == ord(b\"\\xe0\")",
            "",
            "    def test_16bit_s(self):",
            "        with Image.open(\"Tests/images/16bit.s.tif\") as im:",
            "            im.load()",
            "            assert im.mode == \"I\"",
            "            assert im.getpixel((0, 0)) == 32767",
            "            assert im.getpixel((0, 1)) == 0",
            "",
            "    def test_12bit_rawmode(self):",
            "        \"\"\"Are we generating the same interpretation",
            "        of the image as Imagemagick is?\"\"\"",
            "",
            "        with Image.open(\"Tests/images/12bit.cropped.tif\") as im:",
            "            # to make the target --",
            "            # convert 12bit.cropped.tif -depth 16 tmp.tif",
            "            # convert tmp.tif -evaluate RightShift 4 12in16bit2.tif",
            "            # imagemagick will auto scale so that a 12bit FFF is 16bit FFF0,",
            "            # so we need to unshift so that the integer values are the same.",
            "",
            "            assert_image_equal_tofile(im, \"Tests/images/12in16bit.tif\")",
            "",
            "    def test_32bit_float(self):",
            "        # Issue 614, specific 32-bit float format",
            "        path = \"Tests/images/10ct_32bit_128.tiff\"",
            "        with Image.open(path) as im:",
            "            im.load()",
            "",
            "            assert im.getpixel((0, 0)) == -0.4526388943195343",
            "            assert im.getextrema() == (-3.140936851501465, 3.140684127807617)",
            "",
            "    def test_unknown_pixel_mode(self):",
            "        with pytest.raises(OSError):",
            "            with Image.open(\"Tests/images/hopper_unknown_pixel_mode.tif\"):",
            "                pass",
            "",
            "    def test_n_frames(self):",
            "        for path, n_frames in [",
            "            [\"Tests/images/multipage-lastframe.tif\", 1],",
            "            [\"Tests/images/multipage.tiff\", 3],",
            "        ]:",
            "            with Image.open(path) as im:",
            "                assert im.n_frames == n_frames",
            "                assert im.is_animated == (n_frames != 1)",
            "",
            "    def test_eoferror(self):",
            "        with Image.open(\"Tests/images/multipage-lastframe.tif\") as im:",
            "            n_frames = im.n_frames",
            "",
            "            # Test seeking past the last frame",
            "            with pytest.raises(EOFError):",
            "                im.seek(n_frames)",
            "            assert im.tell() < n_frames",
            "",
            "            # Test that seeking to the last frame does not raise an error",
            "            im.seek(n_frames - 1)",
            "",
            "    def test_multipage(self):",
            "        # issue #862",
            "        with Image.open(\"Tests/images/multipage.tiff\") as im:",
            "            # file is a multipage tiff: 10x10 green, 10x10 red, 20x20 blue",
            "",
            "            im.seek(0)",
            "            assert im.size == (10, 10)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)",
            "",
            "            im.seek(1)",
            "            im.load()",
            "            assert im.size == (10, 10)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (255, 0, 0)",
            "",
            "            im.seek(0)",
            "            im.load()",
            "            assert im.size == (10, 10)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)",
            "",
            "            im.seek(2)",
            "            im.load()",
            "            assert im.size == (20, 20)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 255)",
            "",
            "    def test_multipage_last_frame(self):",
            "        with Image.open(\"Tests/images/multipage-lastframe.tif\") as im:",
            "            im.load()",
            "            assert im.size == (20, 20)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 255)",
            "",
            "    def test___str__(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "",
            "            # Act",
            "            ret = str(im.ifd)",
            "",
            "            # Assert",
            "            assert isinstance(ret, str)",
            "",
            "    def test_dict(self):",
            "        # Arrange",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "",
            "            # v2 interface",
            "            v2_tags = {",
            "                256: 55,",
            "                257: 43,",
            "                258: (8, 8, 8, 8),",
            "                259: 1,",
            "                262: 2,",
            "                296: 2,",
            "                273: (8,),",
            "                338: (1,),",
            "                277: 4,",
            "                279: (9460,),",
            "                282: 72.0,",
            "                283: 72.0,",
            "                284: 1,",
            "            }",
            "            assert dict(im.tag_v2) == v2_tags",
            "",
            "            # legacy interface",
            "            legacy_tags = {",
            "                256: (55,),",
            "                257: (43,),",
            "                258: (8, 8, 8, 8),",
            "                259: (1,),",
            "                262: (2,),",
            "                296: (2,),",
            "                273: (8,),",
            "                338: (1,),",
            "                277: (4,),",
            "                279: (9460,),",
            "                282: ((720000, 10000),),",
            "                283: ((720000, 10000),),",
            "                284: (1,),",
            "            }",
            "            assert dict(im.tag) == legacy_tags",
            "",
            "    def test__delitem__(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            len_before = len(dict(im.ifd))",
            "            del im.ifd[256]",
            "            len_after = len(dict(im.ifd))",
            "            assert len_before == len_after + 1",
            "",
            "    def test_load_byte(self):",
            "        for legacy_api in [False, True]:",
            "            ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "            data = b\"abc\"",
            "            ret = ifd.load_byte(data, legacy_api)",
            "            assert ret == b\"abc\"",
            "",
            "    def test_load_string(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        data = b\"abc\\0\"",
            "        ret = ifd.load_string(data, False)",
            "        assert ret == \"abc\"",
            "",
            "    def test_load_float(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        data = b\"abcdabcd\"",
            "        ret = ifd.load_float(data, False)",
            "        assert ret == (1.6777999408082104e22, 1.6777999408082104e22)",
            "",
            "    def test_load_double(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        data = b\"abcdefghabcdefgh\"",
            "        ret = ifd.load_double(data, False)",
            "        assert ret == (8.540883223036124e194, 8.540883223036124e194)",
            "",
            "    def test_ifd_tag_type(self):",
            "        with Image.open(\"Tests/images/ifd_tag_type.tiff\") as im:",
            "            assert 0x8825 in im.tag_v2",
            "",
            "    def test_seek(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            im.seek(0)",
            "            assert im.tell() == 0",
            "",
            "    def test_seek_eof(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            assert im.tell() == 0",
            "            with pytest.raises(EOFError):",
            "                im.seek(-1)",
            "            with pytest.raises(EOFError):",
            "                im.seek(1)",
            "",
            "    def test__limit_rational_int(self):",
            "        from PIL.TiffImagePlugin import _limit_rational",
            "",
            "        value = 34",
            "        ret = _limit_rational(value, 65536)",
            "        assert ret == (34, 1)",
            "",
            "    def test__limit_rational_float(self):",
            "        from PIL.TiffImagePlugin import _limit_rational",
            "",
            "        value = 22.3",
            "        ret = _limit_rational(value, 65536)",
            "        assert ret == (223, 10)",
            "",
            "    def test_4bit(self):",
            "        test_file = \"Tests/images/hopper_gray_4bpp.tif\"",
            "        original = hopper(\"L\")",
            "        with Image.open(test_file) as im:",
            "            assert im.size == (128, 128)",
            "            assert im.mode == \"L\"",
            "            assert_image_similar(im, original, 7.3)",
            "",
            "    def test_gray_semibyte_per_pixel(self):",
            "        test_files = (",
            "            (",
            "                24.8,  # epsilon",
            "                (  # group",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2I.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2R.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2IR.tif\",",
            "                ),",
            "            ),",
            "            (",
            "                7.3,  # epsilon",
            "                (  # group",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4I.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4R.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4IR.tif\",",
            "                ),",
            "            ),",
            "        )",
            "        original = hopper(\"L\")",
            "        for epsilon, group in test_files:",
            "            with Image.open(group[0]) as im:",
            "                assert im.size == (128, 128)",
            "                assert im.mode == \"L\"",
            "                assert_image_similar(im, original, epsilon)",
            "                for file in group[1:]:",
            "                    with Image.open(file) as im2:",
            "                        assert im2.size == (128, 128)",
            "                        assert im2.mode == \"L\"",
            "                        assert_image_equal(im, im2)",
            "",
            "    def test_with_underscores(self, tmp_path):",
            "        kwargs = {\"resolution_unit\": \"inch\", \"x_resolution\": 72, \"y_resolution\": 36}",
            "        filename = str(tmp_path / \"temp.tif\")",
            "        hopper(\"RGB\").save(filename, **kwargs)",
            "        with Image.open(filename) as im:",
            "",
            "            # legacy interface",
            "            assert im.tag[X_RESOLUTION][0][0] == 72",
            "            assert im.tag[Y_RESOLUTION][0][0] == 36",
            "",
            "            # v2 interface",
            "            assert im.tag_v2[X_RESOLUTION] == 72",
            "            assert im.tag_v2[Y_RESOLUTION] == 36",
            "",
            "    def test_roundtrip_tiff_uint16(self, tmp_path):",
            "        # Test an image of all '0' values",
            "        pixel_value = 0x1234",
            "        infile = \"Tests/images/uint16_1_4660.tif\"",
            "        with Image.open(infile) as im:",
            "            assert im.getpixel((0, 0)) == pixel_value",
            "",
            "            tmpfile = str(tmp_path / \"temp.tif\")",
            "            im.save(tmpfile)",
            "",
            "            assert_image_equal_tofile(im, tmpfile)",
            "",
            "    def test_strip_raw(self):",
            "        infile = \"Tests/images/tiff_strip_raw.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_strip_planar_raw(self):",
            "        # gdal_translate -of GTiff -co INTERLEAVE=BAND \\",
            "        # tiff_strip_raw.tif tiff_strip_planar_raw.tiff",
            "        infile = \"Tests/images/tiff_strip_planar_raw.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_strip_planar_raw_with_overviews(self):",
            "        # gdaladdo tiff_strip_planar_raw2.tif 2 4 8 16",
            "        infile = \"Tests/images/tiff_strip_planar_raw_with_overviews.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_tiled_planar_raw(self):",
            "        # gdal_translate -of GTiff -co TILED=YES -co BLOCKXSIZE=32 \\",
            "        # -co BLOCKYSIZE=32 -co INTERLEAVE=BAND \\",
            "        # tiff_tiled_raw.tif tiff_tiled_planar_raw.tiff",
            "        infile = \"Tests/images/tiff_tiled_planar_raw.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_palette(self, tmp_path):",
            "        def roundtrip(mode):",
            "            outfile = str(tmp_path / \"temp.tif\")",
            "",
            "            im = hopper(mode)",
            "            im.save(outfile)",
            "",
            "            with Image.open(outfile) as reloaded:",
            "                assert_image_equal(im.convert(\"RGB\"), reloaded.convert(\"RGB\"))",
            "",
            "        for mode in [\"P\", \"PA\"]:",
            "            roundtrip(mode)",
            "",
            "    def test_tiff_save_all(self):",
            "        mp = BytesIO()",
            "        with Image.open(\"Tests/images/multipage.tiff\") as im:",
            "            im.save(mp, format=\"tiff\", save_all=True)",
            "",
            "        mp.seek(0, os.SEEK_SET)",
            "        with Image.open(mp) as im:",
            "            assert im.n_frames == 3",
            "",
            "        # Test appending images",
            "        mp = BytesIO()",
            "        im = Image.new(\"RGB\", (100, 100), \"#f00\")",
            "        ims = [Image.new(\"RGB\", (100, 100), color) for color in [\"#0f0\", \"#00f\"]]",
            "        im.copy().save(mp, format=\"TIFF\", save_all=True, append_images=ims)",
            "",
            "        mp.seek(0, os.SEEK_SET)",
            "        with Image.open(mp) as reread:",
            "            assert reread.n_frames == 3",
            "",
            "        # Test appending using a generator",
            "        def imGenerator(ims):",
            "            yield from ims",
            "",
            "        mp = BytesIO()",
            "        im.save(mp, format=\"TIFF\", save_all=True, append_images=imGenerator(ims))",
            "",
            "        mp.seek(0, os.SEEK_SET)",
            "        with Image.open(mp) as reread:",
            "            assert reread.n_frames == 3",
            "",
            "    def test_saving_icc_profile(self, tmp_path):",
            "        # Tests saving TIFF with icc_profile set.",
            "        # At the time of writing this will only work for non-compressed tiffs",
            "        # as libtiff does not support embedded ICC profiles,",
            "        # ImageFile._save(..) however does.",
            "        im = Image.new(\"RGB\", (1, 1))",
            "        im.info[\"icc_profile\"] = \"Dummy value\"",
            "",
            "        # Try save-load round trip to make sure both handle icc_profile.",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "        im.save(tmpfile, \"TIFF\", compression=\"raw\")",
            "        with Image.open(tmpfile) as reloaded:",
            "            assert b\"Dummy value\" == reloaded.info[\"icc_profile\"]",
            "",
            "    def test_save_icc_profile(self, tmp_path):",
            "        im = hopper()",
            "        assert \"icc_profile\" not in im.info",
            "",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        icc_profile = b\"Dummy value\"",
            "        im.save(outfile, icc_profile=icc_profile)",
            "",
            "        with Image.open(outfile) as reloaded:",
            "            assert reloaded.info[\"icc_profile\"] == icc_profile",
            "",
            "    def test_discard_icc_profile(self, tmp_path):",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "",
            "        with Image.open(\"Tests/images/icc_profile.png\") as im:",
            "            assert \"icc_profile\" in im.info",
            "",
            "            im.save(outfile, icc_profile=None)",
            "",
            "        with Image.open(outfile) as reloaded:",
            "            assert \"icc_profile\" not in reloaded.info",
            "",
            "    def test_close_on_load_exclusive(self, tmp_path):",
            "        # similar to test_fd_leak, but runs on unixlike os",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "",
            "        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:",
            "            im.save(tmpfile)",
            "",
            "        im = Image.open(tmpfile)",
            "        fp = im.fp",
            "        assert not fp.closed",
            "        im.load()",
            "        assert fp.closed",
            "",
            "    def test_close_on_load_nonexclusive(self, tmp_path):",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "",
            "        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:",
            "            im.save(tmpfile)",
            "",
            "        with open(tmpfile, \"rb\") as f:",
            "            im = Image.open(f)",
            "            fp = im.fp",
            "            assert not fp.closed",
            "            im.load()",
            "            assert not fp.closed",
            "",
            "    # Ignore this UserWarning which triggers for four tags:",
            "    # \"Possibly corrupt EXIF data.  Expecting to read 50404352 bytes but...\"",
            "    @pytest.mark.filterwarnings(\"ignore:Possibly corrupt EXIF data\")",
            "    @pytest.mark.skipif(",
            "        not os.path.exists(\"Tests/images/string_dimension.tiff\"),",
            "        reason=\"Extra image files not installed\",",
            "    )",
            "    def test_string_dimension(self):",
            "        # Assert that an error is raised if one of the dimensions is a string",
            "        with pytest.raises(ValueError):",
            "            with Image.open(\"Tests/images/string_dimension.tiff\"):",
            "                pass",
            "",
            "",
            "@pytest.mark.skipif(not is_win32(), reason=\"Windows only\")",
            "class TestFileTiffW32:",
            "    def test_fd_leak(self, tmp_path):",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "",
            "        # this is an mmaped file.",
            "        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:",
            "            im.save(tmpfile)",
            "",
            "        im = Image.open(tmpfile)",
            "        fp = im.fp",
            "        assert not fp.closed",
            "        with pytest.raises(OSError):",
            "            os.remove(tmpfile)",
            "        im.load()",
            "        assert fp.closed",
            "",
            "        # this closes the mmap",
            "        im.close()",
            "",
            "        # this should not fail, as load should have closed the file pointer,",
            "        # and close should have closed the mmap",
            "        os.remove(tmpfile)"
        ],
        "afterPatchFile": [
            "import os",
            "from io import BytesIO",
            "",
            "import pytest",
            "",
            "from PIL import Image, TiffImagePlugin",
            "from PIL.TiffImagePlugin import RESOLUTION_UNIT, X_RESOLUTION, Y_RESOLUTION",
            "",
            "from .helper import (",
            "    assert_image_equal,",
            "    assert_image_equal_tofile,",
            "    assert_image_similar,",
            "    assert_image_similar_tofile,",
            "    hopper,",
            "    is_pypy,",
            "    is_win32,",
            ")",
            "",
            "",
            "class TestFileTiff:",
            "    def test_sanity(self, tmp_path):",
            "",
            "        filename = str(tmp_path / \"temp.tif\")",
            "",
            "        hopper(\"RGB\").save(filename)",
            "",
            "        with Image.open(filename) as im:",
            "            im.load()",
            "        assert im.mode == \"RGB\"",
            "        assert im.size == (128, 128)",
            "        assert im.format == \"TIFF\"",
            "",
            "        hopper(\"1\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"L\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"P\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"RGB\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "        hopper(\"I\").save(filename)",
            "        with Image.open(filename):",
            "            pass",
            "",
            "    @pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")",
            "    def test_unclosed_file(self):",
            "        def open():",
            "            im = Image.open(\"Tests/images/multipage.tiff\")",
            "            im.load()",
            "",
            "        pytest.warns(ResourceWarning, open)",
            "",
            "    def test_closed_file(self):",
            "        with pytest.warns(None) as record:",
            "            im = Image.open(\"Tests/images/multipage.tiff\")",
            "            im.load()",
            "            im.close()",
            "",
            "        assert not record",
            "",
            "    def test_context_manager(self):",
            "        with pytest.warns(None) as record:",
            "            with Image.open(\"Tests/images/multipage.tiff\") as im:",
            "                im.load()",
            "",
            "        assert not record",
            "",
            "    def test_mac_tiff(self):",
            "        # Read RGBa images from macOS [@PIL136]",
            "",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            assert im.mode == \"RGBA\"",
            "            assert im.size == (55, 43)",
            "            assert im.tile == [(\"raw\", (0, 0, 55, 43), 8, (\"RGBa\", 0, 1))]",
            "            im.load()",
            "",
            "            assert_image_similar_tofile(im, \"Tests/images/pil136.png\", 1)",
            "",
            "    def test_wrong_bits_per_sample(self):",
            "        with Image.open(\"Tests/images/tiff_wrong_bits_per_sample.tiff\") as im:",
            "            assert im.mode == \"RGBA\"",
            "            assert im.size == (52, 53)",
            "            assert im.tile == [(\"raw\", (0, 0, 52, 53), 160, (\"RGBA\", 0, 1))]",
            "            im.load()",
            "",
            "    def test_set_legacy_api(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        with pytest.raises(Exception) as e:",
            "            ifd.legacy_api = None",
            "        assert str(e.value) == \"Not allowing setting of legacy api\"",
            "",
            "    def test_xyres_tiff(self):",
            "        filename = \"Tests/images/pil168.tif\"",
            "        with Image.open(filename) as im:",
            "",
            "            # legacy api",
            "            assert isinstance(im.tag[X_RESOLUTION][0], tuple)",
            "            assert isinstance(im.tag[Y_RESOLUTION][0], tuple)",
            "",
            "            # v2 api",
            "            assert isinstance(im.tag_v2[X_RESOLUTION], TiffImagePlugin.IFDRational)",
            "            assert isinstance(im.tag_v2[Y_RESOLUTION], TiffImagePlugin.IFDRational)",
            "",
            "            assert im.info[\"dpi\"] == (72.0, 72.0)",
            "",
            "    def test_xyres_fallback_tiff(self):",
            "        filename = \"Tests/images/compression.tif\"",
            "        with Image.open(filename) as im:",
            "",
            "            # v2 api",
            "            assert isinstance(im.tag_v2[X_RESOLUTION], TiffImagePlugin.IFDRational)",
            "            assert isinstance(im.tag_v2[Y_RESOLUTION], TiffImagePlugin.IFDRational)",
            "            with pytest.raises(KeyError):",
            "                im.tag_v2[RESOLUTION_UNIT]",
            "",
            "            # Legacy.",
            "            assert im.info[\"resolution\"] == (100.0, 100.0)",
            "            # Fallback \"inch\".",
            "            assert im.info[\"dpi\"] == (100.0, 100.0)",
            "",
            "    def test_int_resolution(self):",
            "        filename = \"Tests/images/pil168.tif\"",
            "        with Image.open(filename) as im:",
            "",
            "            # Try to read a file where X,Y_RESOLUTION are ints",
            "            im.tag_v2[X_RESOLUTION] = 71",
            "            im.tag_v2[Y_RESOLUTION] = 71",
            "            im._setup()",
            "            assert im.info[\"dpi\"] == (71.0, 71.0)",
            "",
            "    def test_load_dpi_rounding(self):",
            "        for resolutionUnit, dpi in ((None, (72, 73)), (2, (72, 73)), (3, (183, 185))):",
            "            with Image.open(",
            "                \"Tests/images/hopper_roundDown_\" + str(resolutionUnit) + \".tif\"",
            "            ) as im:",
            "                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit",
            "                assert im.info[\"dpi\"] == (dpi[0], dpi[0])",
            "",
            "            with Image.open(",
            "                \"Tests/images/hopper_roundUp_\" + str(resolutionUnit) + \".tif\"",
            "            ) as im:",
            "                assert im.tag_v2.get(RESOLUTION_UNIT) == resolutionUnit",
            "                assert im.info[\"dpi\"] == (dpi[1], dpi[1])",
            "",
            "    def test_save_dpi_rounding(self, tmp_path):",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        with Image.open(\"Tests/images/hopper.tif\") as im:",
            "            for dpi in (72.2, 72.8):",
            "                im.save(outfile, dpi=(dpi, dpi))",
            "",
            "                with Image.open(outfile) as reloaded:",
            "                    reloaded.load()",
            "                    assert (round(dpi), round(dpi)) == reloaded.info[\"dpi\"]",
            "",
            "    def test_save_setting_missing_resolution(self):",
            "        b = BytesIO()",
            "        with Image.open(\"Tests/images/10ct_32bit_128.tiff\") as im:",
            "            im.save(b, format=\"tiff\", resolution=123.45)",
            "        with Image.open(b) as im:",
            "            assert float(im.tag_v2[X_RESOLUTION]) == 123.45",
            "            assert float(im.tag_v2[Y_RESOLUTION]) == 123.45",
            "",
            "    def test_invalid_file(self):",
            "        invalid_file = \"Tests/images/flower.jpg\"",
            "",
            "        with pytest.raises(SyntaxError):",
            "            TiffImagePlugin.TiffImageFile(invalid_file)",
            "",
            "        TiffImagePlugin.PREFIXES.append(b\"\\xff\\xd8\\xff\\xe0\")",
            "        with pytest.raises(SyntaxError):",
            "            TiffImagePlugin.TiffImageFile(invalid_file)",
            "        TiffImagePlugin.PREFIXES.pop()",
            "",
            "    def test_bad_exif(self):",
            "        with Image.open(\"Tests/images/hopper_bad_exif.jpg\") as i:",
            "            # Should not raise struct.error.",
            "            pytest.warns(UserWarning, i._getexif)",
            "",
            "    def test_save_rgba(self, tmp_path):",
            "        im = hopper(\"RGBA\")",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        im.save(outfile)",
            "",
            "    def test_save_unsupported_mode(self, tmp_path):",
            "        im = hopper(\"HSV\")",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        with pytest.raises(OSError):",
            "            im.save(outfile)",
            "",
            "    def test_little_endian(self):",
            "        with Image.open(\"Tests/images/16bit.cropped.tif\") as im:",
            "            assert im.getpixel((0, 0)) == 480",
            "            assert im.mode == \"I;16\"",
            "",
            "            b = im.tobytes()",
            "        # Bytes are in image native order (little endian)",
            "        assert b[0] == ord(b\"\\xe0\")",
            "        assert b[1] == ord(b\"\\x01\")",
            "",
            "    def test_big_endian(self):",
            "        with Image.open(\"Tests/images/16bit.MM.cropped.tif\") as im:",
            "            assert im.getpixel((0, 0)) == 480",
            "            assert im.mode == \"I;16B\"",
            "",
            "            b = im.tobytes()",
            "        # Bytes are in image native order (big endian)",
            "        assert b[0] == ord(b\"\\x01\")",
            "        assert b[1] == ord(b\"\\xe0\")",
            "",
            "    def test_16bit_s(self):",
            "        with Image.open(\"Tests/images/16bit.s.tif\") as im:",
            "            im.load()",
            "            assert im.mode == \"I\"",
            "            assert im.getpixel((0, 0)) == 32767",
            "            assert im.getpixel((0, 1)) == 0",
            "",
            "    def test_12bit_rawmode(self):",
            "        \"\"\"Are we generating the same interpretation",
            "        of the image as Imagemagick is?\"\"\"",
            "",
            "        with Image.open(\"Tests/images/12bit.cropped.tif\") as im:",
            "            # to make the target --",
            "            # convert 12bit.cropped.tif -depth 16 tmp.tif",
            "            # convert tmp.tif -evaluate RightShift 4 12in16bit2.tif",
            "            # imagemagick will auto scale so that a 12bit FFF is 16bit FFF0,",
            "            # so we need to unshift so that the integer values are the same.",
            "",
            "            assert_image_equal_tofile(im, \"Tests/images/12in16bit.tif\")",
            "",
            "    def test_32bit_float(self):",
            "        # Issue 614, specific 32-bit float format",
            "        path = \"Tests/images/10ct_32bit_128.tiff\"",
            "        with Image.open(path) as im:",
            "            im.load()",
            "",
            "            assert im.getpixel((0, 0)) == -0.4526388943195343",
            "            assert im.getextrema() == (-3.140936851501465, 3.140684127807617)",
            "",
            "    def test_unknown_pixel_mode(self):",
            "        with pytest.raises(OSError):",
            "            with Image.open(\"Tests/images/hopper_unknown_pixel_mode.tif\"):",
            "                pass",
            "",
            "    def test_n_frames(self):",
            "        for path, n_frames in [",
            "            [\"Tests/images/multipage-lastframe.tif\", 1],",
            "            [\"Tests/images/multipage.tiff\", 3],",
            "        ]:",
            "            with Image.open(path) as im:",
            "                assert im.n_frames == n_frames",
            "                assert im.is_animated == (n_frames != 1)",
            "",
            "    def test_eoferror(self):",
            "        with Image.open(\"Tests/images/multipage-lastframe.tif\") as im:",
            "            n_frames = im.n_frames",
            "",
            "            # Test seeking past the last frame",
            "            with pytest.raises(EOFError):",
            "                im.seek(n_frames)",
            "            assert im.tell() < n_frames",
            "",
            "            # Test that seeking to the last frame does not raise an error",
            "            im.seek(n_frames - 1)",
            "",
            "    def test_multipage(self):",
            "        # issue #862",
            "        with Image.open(\"Tests/images/multipage.tiff\") as im:",
            "            # file is a multipage tiff: 10x10 green, 10x10 red, 20x20 blue",
            "",
            "            im.seek(0)",
            "            assert im.size == (10, 10)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)",
            "",
            "            im.seek(1)",
            "            im.load()",
            "            assert im.size == (10, 10)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (255, 0, 0)",
            "",
            "            im.seek(0)",
            "            im.load()",
            "            assert im.size == (10, 10)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)",
            "",
            "            im.seek(2)",
            "            im.load()",
            "            assert im.size == (20, 20)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 255)",
            "",
            "    def test_multipage_last_frame(self):",
            "        with Image.open(\"Tests/images/multipage-lastframe.tif\") as im:",
            "            im.load()",
            "            assert im.size == (20, 20)",
            "            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 255)",
            "",
            "    def test___str__(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "",
            "            # Act",
            "            ret = str(im.ifd)",
            "",
            "            # Assert",
            "            assert isinstance(ret, str)",
            "",
            "    def test_dict(self):",
            "        # Arrange",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "",
            "            # v2 interface",
            "            v2_tags = {",
            "                256: 55,",
            "                257: 43,",
            "                258: (8, 8, 8, 8),",
            "                259: 1,",
            "                262: 2,",
            "                296: 2,",
            "                273: (8,),",
            "                338: (1,),",
            "                277: 4,",
            "                279: (9460,),",
            "                282: 72.0,",
            "                283: 72.0,",
            "                284: 1,",
            "            }",
            "            assert dict(im.tag_v2) == v2_tags",
            "",
            "            # legacy interface",
            "            legacy_tags = {",
            "                256: (55,),",
            "                257: (43,),",
            "                258: (8, 8, 8, 8),",
            "                259: (1,),",
            "                262: (2,),",
            "                296: (2,),",
            "                273: (8,),",
            "                338: (1,),",
            "                277: (4,),",
            "                279: (9460,),",
            "                282: ((720000, 10000),),",
            "                283: ((720000, 10000),),",
            "                284: (1,),",
            "            }",
            "            assert dict(im.tag) == legacy_tags",
            "",
            "    def test__delitem__(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            len_before = len(dict(im.ifd))",
            "            del im.ifd[256]",
            "            len_after = len(dict(im.ifd))",
            "            assert len_before == len_after + 1",
            "",
            "    def test_load_byte(self):",
            "        for legacy_api in [False, True]:",
            "            ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "            data = b\"abc\"",
            "            ret = ifd.load_byte(data, legacy_api)",
            "            assert ret == b\"abc\"",
            "",
            "    def test_load_string(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        data = b\"abc\\0\"",
            "        ret = ifd.load_string(data, False)",
            "        assert ret == \"abc\"",
            "",
            "    def test_load_float(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        data = b\"abcdabcd\"",
            "        ret = ifd.load_float(data, False)",
            "        assert ret == (1.6777999408082104e22, 1.6777999408082104e22)",
            "",
            "    def test_load_double(self):",
            "        ifd = TiffImagePlugin.ImageFileDirectory_v2()",
            "        data = b\"abcdefghabcdefgh\"",
            "        ret = ifd.load_double(data, False)",
            "        assert ret == (8.540883223036124e194, 8.540883223036124e194)",
            "",
            "    def test_ifd_tag_type(self):",
            "        with Image.open(\"Tests/images/ifd_tag_type.tiff\") as im:",
            "            assert 0x8825 in im.tag_v2",
            "",
            "    def test_seek(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            im.seek(0)",
            "            assert im.tell() == 0",
            "",
            "    def test_seek_eof(self):",
            "        filename = \"Tests/images/pil136.tiff\"",
            "        with Image.open(filename) as im:",
            "            assert im.tell() == 0",
            "            with pytest.raises(EOFError):",
            "                im.seek(-1)",
            "            with pytest.raises(EOFError):",
            "                im.seek(1)",
            "",
            "    def test__limit_rational_int(self):",
            "        from PIL.TiffImagePlugin import _limit_rational",
            "",
            "        value = 34",
            "        ret = _limit_rational(value, 65536)",
            "        assert ret == (34, 1)",
            "",
            "    def test__limit_rational_float(self):",
            "        from PIL.TiffImagePlugin import _limit_rational",
            "",
            "        value = 22.3",
            "        ret = _limit_rational(value, 65536)",
            "        assert ret == (223, 10)",
            "",
            "    def test_4bit(self):",
            "        test_file = \"Tests/images/hopper_gray_4bpp.tif\"",
            "        original = hopper(\"L\")",
            "        with Image.open(test_file) as im:",
            "            assert im.size == (128, 128)",
            "            assert im.mode == \"L\"",
            "            assert_image_similar(im, original, 7.3)",
            "",
            "    def test_gray_semibyte_per_pixel(self):",
            "        test_files = (",
            "            (",
            "                24.8,  # epsilon",
            "                (  # group",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2I.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2R.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper2IR.tif\",",
            "                ),",
            "            ),",
            "            (",
            "                7.3,  # epsilon",
            "                (  # group",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4I.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4R.tif\",",
            "                    \"Tests/images/tiff_gray_2_4_bpp/hopper4IR.tif\",",
            "                ),",
            "            ),",
            "        )",
            "        original = hopper(\"L\")",
            "        for epsilon, group in test_files:",
            "            with Image.open(group[0]) as im:",
            "                assert im.size == (128, 128)",
            "                assert im.mode == \"L\"",
            "                assert_image_similar(im, original, epsilon)",
            "                for file in group[1:]:",
            "                    with Image.open(file) as im2:",
            "                        assert im2.size == (128, 128)",
            "                        assert im2.mode == \"L\"",
            "                        assert_image_equal(im, im2)",
            "",
            "    def test_with_underscores(self, tmp_path):",
            "        kwargs = {\"resolution_unit\": \"inch\", \"x_resolution\": 72, \"y_resolution\": 36}",
            "        filename = str(tmp_path / \"temp.tif\")",
            "        hopper(\"RGB\").save(filename, **kwargs)",
            "        with Image.open(filename) as im:",
            "",
            "            # legacy interface",
            "            assert im.tag[X_RESOLUTION][0][0] == 72",
            "            assert im.tag[Y_RESOLUTION][0][0] == 36",
            "",
            "            # v2 interface",
            "            assert im.tag_v2[X_RESOLUTION] == 72",
            "            assert im.tag_v2[Y_RESOLUTION] == 36",
            "",
            "    def test_roundtrip_tiff_uint16(self, tmp_path):",
            "        # Test an image of all '0' values",
            "        pixel_value = 0x1234",
            "        infile = \"Tests/images/uint16_1_4660.tif\"",
            "        with Image.open(infile) as im:",
            "            assert im.getpixel((0, 0)) == pixel_value",
            "",
            "            tmpfile = str(tmp_path / \"temp.tif\")",
            "            im.save(tmpfile)",
            "",
            "            assert_image_equal_tofile(im, tmpfile)",
            "",
            "    def test_strip_raw(self):",
            "        infile = \"Tests/images/tiff_strip_raw.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_strip_planar_raw(self):",
            "        # gdal_translate -of GTiff -co INTERLEAVE=BAND \\",
            "        # tiff_strip_raw.tif tiff_strip_planar_raw.tiff",
            "        infile = \"Tests/images/tiff_strip_planar_raw.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_strip_planar_raw_with_overviews(self):",
            "        # gdaladdo tiff_strip_planar_raw2.tif 2 4 8 16",
            "        infile = \"Tests/images/tiff_strip_planar_raw_with_overviews.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_tiled_planar_raw(self):",
            "        # gdal_translate -of GTiff -co TILED=YES -co BLOCKXSIZE=32 \\",
            "        # -co BLOCKYSIZE=32 -co INTERLEAVE=BAND \\",
            "        # tiff_tiled_raw.tif tiff_tiled_planar_raw.tiff",
            "        infile = \"Tests/images/tiff_tiled_planar_raw.tif\"",
            "        with Image.open(infile) as im:",
            "            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")",
            "",
            "    def test_palette(self, tmp_path):",
            "        def roundtrip(mode):",
            "            outfile = str(tmp_path / \"temp.tif\")",
            "",
            "            im = hopper(mode)",
            "            im.save(outfile)",
            "",
            "            with Image.open(outfile) as reloaded:",
            "                assert_image_equal(im.convert(\"RGB\"), reloaded.convert(\"RGB\"))",
            "",
            "        for mode in [\"P\", \"PA\"]:",
            "            roundtrip(mode)",
            "",
            "    def test_tiff_save_all(self):",
            "        mp = BytesIO()",
            "        with Image.open(\"Tests/images/multipage.tiff\") as im:",
            "            im.save(mp, format=\"tiff\", save_all=True)",
            "",
            "        mp.seek(0, os.SEEK_SET)",
            "        with Image.open(mp) as im:",
            "            assert im.n_frames == 3",
            "",
            "        # Test appending images",
            "        mp = BytesIO()",
            "        im = Image.new(\"RGB\", (100, 100), \"#f00\")",
            "        ims = [Image.new(\"RGB\", (100, 100), color) for color in [\"#0f0\", \"#00f\"]]",
            "        im.copy().save(mp, format=\"TIFF\", save_all=True, append_images=ims)",
            "",
            "        mp.seek(0, os.SEEK_SET)",
            "        with Image.open(mp) as reread:",
            "            assert reread.n_frames == 3",
            "",
            "        # Test appending using a generator",
            "        def imGenerator(ims):",
            "            yield from ims",
            "",
            "        mp = BytesIO()",
            "        im.save(mp, format=\"TIFF\", save_all=True, append_images=imGenerator(ims))",
            "",
            "        mp.seek(0, os.SEEK_SET)",
            "        with Image.open(mp) as reread:",
            "            assert reread.n_frames == 3",
            "",
            "    def test_saving_icc_profile(self, tmp_path):",
            "        # Tests saving TIFF with icc_profile set.",
            "        # At the time of writing this will only work for non-compressed tiffs",
            "        # as libtiff does not support embedded ICC profiles,",
            "        # ImageFile._save(..) however does.",
            "        im = Image.new(\"RGB\", (1, 1))",
            "        im.info[\"icc_profile\"] = \"Dummy value\"",
            "",
            "        # Try save-load round trip to make sure both handle icc_profile.",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "        im.save(tmpfile, \"TIFF\", compression=\"raw\")",
            "        with Image.open(tmpfile) as reloaded:",
            "            assert b\"Dummy value\" == reloaded.info[\"icc_profile\"]",
            "",
            "    def test_save_icc_profile(self, tmp_path):",
            "        im = hopper()",
            "        assert \"icc_profile\" not in im.info",
            "",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "        icc_profile = b\"Dummy value\"",
            "        im.save(outfile, icc_profile=icc_profile)",
            "",
            "        with Image.open(outfile) as reloaded:",
            "            assert reloaded.info[\"icc_profile\"] == icc_profile",
            "",
            "    def test_discard_icc_profile(self, tmp_path):",
            "        outfile = str(tmp_path / \"temp.tif\")",
            "",
            "        with Image.open(\"Tests/images/icc_profile.png\") as im:",
            "            assert \"icc_profile\" in im.info",
            "",
            "            im.save(outfile, icc_profile=None)",
            "",
            "        with Image.open(outfile) as reloaded:",
            "            assert \"icc_profile\" not in reloaded.info",
            "",
            "    def test_close_on_load_exclusive(self, tmp_path):",
            "        # similar to test_fd_leak, but runs on unixlike os",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "",
            "        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:",
            "            im.save(tmpfile)",
            "",
            "        im = Image.open(tmpfile)",
            "        fp = im.fp",
            "        assert not fp.closed",
            "        im.load()",
            "        assert fp.closed",
            "",
            "    def test_close_on_load_nonexclusive(self, tmp_path):",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "",
            "        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:",
            "            im.save(tmpfile)",
            "",
            "        with open(tmpfile, \"rb\") as f:",
            "            im = Image.open(f)",
            "            fp = im.fp",
            "            assert not fp.closed",
            "            im.load()",
            "            assert not fp.closed",
            "",
            "    # Ignore this UserWarning which triggers for four tags:",
            "    # \"Possibly corrupt EXIF data.  Expecting to read 50404352 bytes but...\"",
            "    @pytest.mark.filterwarnings(\"ignore:Possibly corrupt EXIF data\")",
            "    @pytest.mark.skipif(",
            "        not os.path.exists(\"Tests/images/string_dimension.tiff\"),",
            "        reason=\"Extra image files not installed\",",
            "    )",
            "    def test_string_dimension(self):",
            "        # Assert that an error is raised if one of the dimensions is a string",
            "        with pytest.raises(OSError):",
            "            with Image.open(\"Tests/images/string_dimension.tiff\") as im:",
            "                im.load()",
            "",
            "",
            "",
            "@pytest.mark.skipif(not is_win32(), reason=\"Windows only\")",
            "class TestFileTiffW32:",
            "    def test_fd_leak(self, tmp_path):",
            "        tmpfile = str(tmp_path / \"temp.tif\")",
            "",
            "        # this is an mmaped file.",
            "        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:",
            "            im.save(tmpfile)",
            "",
            "        im = Image.open(tmpfile)",
            "        fp = im.fp",
            "        assert not fp.closed",
            "        with pytest.raises(OSError):",
            "            os.remove(tmpfile)",
            "        im.load()",
            "        assert fp.closed",
            "",
            "        # this closes the mmap",
            "        im.close()",
            "",
            "        # this should not fail, as load should have closed the file pointer,",
            "        # and close should have closed the mmap",
            "        os.remove(tmpfile)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "628": [
                "TestFileTiff",
                "test_string_dimension"
            ],
            "629": [
                "TestFileTiff",
                "test_string_dimension"
            ],
            "630": [
                "TestFileTiff",
                "test_string_dimension"
            ]
        },
        "addLocation": []
    },
    "src/PIL/ImageFile.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 545,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "     :param fp: File handle.  Must implement a <b>read</b> method."
            },
            "2": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "     :param size: Number of bytes to read."
            },
            "3": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :returns: A string containing up to <i>size</i> bytes of data."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 548,
                "PatchRowcode": "+    :returns: A string containing <i>size</i> bytes of data."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 550,
                "PatchRowcode": "+    Raises an OSError if the file is truncated and the read can not be completed"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 551,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 552,
                "PatchRowcode": "     \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 553,
                "PatchRowcode": "     if size <= 0:"
            },
            "10": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 554,
                "PatchRowcode": "         return b\"\""
            },
            "11": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 555,
                "PatchRowcode": "     if size <= SAFEBLOCK:"
            },
            "12": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return fp.read(size)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 556,
                "PatchRowcode": "+        data = fp.read(size)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 557,
                "PatchRowcode": "+        if len(data) < size:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 558,
                "PatchRowcode": "+            raise OSError(\"Truncated File Read\")"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 559,
                "PatchRowcode": "+        return data"
            },
            "17": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": 560,
                "PatchRowcode": "     data = []"
            },
            "18": {
                "beforePatchRowNumber": 555,
                "afterPatchRowNumber": 561,
                "PatchRowcode": "     while size > 0:"
            },
            "19": {
                "beforePatchRowNumber": 556,
                "afterPatchRowNumber": 562,
                "PatchRowcode": "         block = fp.read(min(size, SAFEBLOCK))"
            },
            "20": {
                "beforePatchRowNumber": 557,
                "afterPatchRowNumber": 563,
                "PatchRowcode": "         if not block:"
            },
            "21": {
                "beforePatchRowNumber": 558,
                "afterPatchRowNumber": 564,
                "PatchRowcode": "             break"
            },
            "22": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": 565,
                "PatchRowcode": "         data.append(block)"
            },
            "23": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "         size -= len(block)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+    if sum(len(d) for d in data) < size:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+        raise OSError(\"Truncated File Read\")"
            },
            "26": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "     return b\"\".join(data)"
            },
            "27": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 570,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": 571,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 572,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 573,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 574,
                "PatchRowcode": " class PyCodecState:"
            },
            "32": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 575,
                "PatchRowcode": "     def __init__(self):"
            },
            "33": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 576,
                "PatchRowcode": "         self.xsize = 0"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# base class for image file handlers",
            "#",
            "# history:",
            "# 1995-09-09 fl   Created",
            "# 1996-03-11 fl   Fixed load mechanism.",
            "# 1996-04-15 fl   Added pcx/xbm decoders.",
            "# 1996-04-30 fl   Added encoders.",
            "# 1996-12-14 fl   Added load helpers",
            "# 1997-01-11 fl   Use encode_to_file where possible",
            "# 1997-08-27 fl   Flush output in _save",
            "# 1998-03-05 fl   Use memory mapping for some modes",
            "# 1999-02-04 fl   Use memory mapping also for \"I;16\" and \"I;16B\"",
            "# 1999-05-31 fl   Added image parser",
            "# 2000-10-12 fl   Set readonly flag on memory-mapped images",
            "# 2002-03-20 fl   Use better messages for common decoder errors",
            "# 2003-04-21 fl   Fall back on mmap/map_buffer if map is not available",
            "# 2003-10-30 fl   Added StubImageFile class",
            "# 2004-02-25 fl   Made incremental parser more robust",
            "#",
            "# Copyright (c) 1997-2004 by Secret Labs AB",
            "# Copyright (c) 1995-2004 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import struct",
            "import sys",
            "import warnings",
            "",
            "from . import Image",
            "from ._util import isPath",
            "",
            "MAXBLOCK = 65536",
            "",
            "SAFEBLOCK = 1024 * 1024",
            "",
            "LOAD_TRUNCATED_IMAGES = False",
            "\"\"\"Whether or not to load truncated image files. User code may change this.\"\"\"",
            "",
            "ERRORS = {",
            "    -1: \"image buffer overrun error\",",
            "    -2: \"decoding error\",",
            "    -3: \"unknown error\",",
            "    -8: \"bad configuration\",",
            "    -9: \"out of memory error\",",
            "}",
            "\"\"\"Dict of known error codes returned from :meth:`.PyDecoder.decode`.\"\"\"",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "# Helpers",
            "",
            "",
            "def raise_oserror(error):",
            "    try:",
            "        message = Image.core.getcodecstatus(error)",
            "    except AttributeError:",
            "        message = ERRORS.get(error)",
            "    if not message:",
            "        message = f\"decoder error {error}\"",
            "    raise OSError(message + \" when reading image file\")",
            "",
            "",
            "def raise_ioerror(error):",
            "    warnings.warn(",
            "        \"raise_ioerror is deprecated and will be removed in Pillow 9 (2022-01-02). \"",
            "        \"Use raise_oserror instead.\",",
            "        DeprecationWarning,",
            "    )",
            "    return raise_oserror(error)",
            "",
            "",
            "def _tilesort(t):",
            "    # sort on offset",
            "    return t[2]",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "# ImageFile base class",
            "",
            "",
            "class ImageFile(Image.Image):",
            "    \"\"\"Base class for image file format handlers.\"\"\"",
            "",
            "    def __init__(self, fp=None, filename=None):",
            "        super().__init__()",
            "",
            "        self._min_frame = 0",
            "",
            "        self.custom_mimetype = None",
            "",
            "        self.tile = None",
            "        \"\"\" A list of tile descriptors, or ``None`` \"\"\"",
            "",
            "        self.readonly = 1  # until we know better",
            "",
            "        self.decoderconfig = ()",
            "        self.decodermaxblock = MAXBLOCK",
            "",
            "        if isPath(fp):",
            "            # filename",
            "            self.fp = open(fp, \"rb\")",
            "            self.filename = fp",
            "            self._exclusive_fp = True",
            "        else:",
            "            # stream",
            "            self.fp = fp",
            "            self.filename = filename",
            "            # can be overridden",
            "            self._exclusive_fp = None",
            "",
            "        try:",
            "            try:",
            "                self._open()",
            "            except (",
            "                IndexError,  # end of data",
            "                TypeError,  # end of data (ord)",
            "                KeyError,  # unsupported mode",
            "                EOFError,  # got header but not the first frame",
            "                struct.error,",
            "            ) as v:",
            "                raise SyntaxError(v) from v",
            "",
            "            if not self.mode or self.size[0] <= 0:",
            "                raise SyntaxError(\"not identified by this driver\")",
            "        except BaseException:",
            "            # close the file only if we have opened it this constructor",
            "            if self._exclusive_fp:",
            "                self.fp.close()",
            "            raise",
            "",
            "    def get_format_mimetype(self):",
            "        if self.custom_mimetype:",
            "            return self.custom_mimetype",
            "        if self.format is not None:",
            "            return Image.MIME.get(self.format.upper())",
            "",
            "    def verify(self):",
            "        \"\"\"Check file integrity\"\"\"",
            "",
            "        # raise exception if something's wrong.  must be called",
            "        # directly after open, and closes file when finished.",
            "        if self._exclusive_fp:",
            "            self.fp.close()",
            "        self.fp = None",
            "",
            "    def load(self):",
            "        \"\"\"Load image data based on tile list\"\"\"",
            "",
            "        if self.tile is None:",
            "            raise OSError(\"cannot load this image\")",
            "",
            "        pixel = Image.Image.load(self)",
            "        if not self.tile:",
            "            return pixel",
            "",
            "        self.map = None",
            "        use_mmap = self.filename and len(self.tile) == 1",
            "        # As of pypy 2.1.0, memory mapping was failing here.",
            "        use_mmap = use_mmap and not hasattr(sys, \"pypy_version_info\")",
            "",
            "        readonly = 0",
            "",
            "        # look for read/seek overrides",
            "        try:",
            "            read = self.load_read",
            "            # don't use mmap if there are custom read/seek functions",
            "            use_mmap = False",
            "        except AttributeError:",
            "            read = self.fp.read",
            "",
            "        try:",
            "            seek = self.load_seek",
            "            use_mmap = False",
            "        except AttributeError:",
            "            seek = self.fp.seek",
            "",
            "        if use_mmap:",
            "            # try memory mapping",
            "            decoder_name, extents, offset, args = self.tile[0]",
            "            if (",
            "                decoder_name == \"raw\"",
            "                and len(args) >= 3",
            "                and args[0] == self.mode",
            "                and args[0] in Image._MAPMODES",
            "            ):",
            "                try:",
            "                    # use mmap, if possible",
            "                    import mmap",
            "",
            "                    with open(self.filename) as fp:",
            "                        self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)",
            "                    self.im = Image.core.map_buffer(",
            "                        self.map, self.size, decoder_name, offset, args",
            "                    )",
            "                    readonly = 1",
            "                    # After trashing self.im,",
            "                    # we might need to reload the palette data.",
            "                    if self.palette:",
            "                        self.palette.dirty = 1",
            "                except (AttributeError, OSError, ImportError):",
            "                    self.map = None",
            "",
            "        self.load_prepare()",
            "        err_code = -3  # initialize to unknown error",
            "        if not self.map:",
            "            # sort tiles in file order",
            "            self.tile.sort(key=_tilesort)",
            "",
            "            try:",
            "                # FIXME: This is a hack to handle TIFF's JpegTables tag.",
            "                prefix = self.tile_prefix",
            "            except AttributeError:",
            "                prefix = b\"\"",
            "",
            "            for decoder_name, extents, offset, args in self.tile:",
            "                decoder = Image._getdecoder(",
            "                    self.mode, decoder_name, args, self.decoderconfig",
            "                )",
            "                try:",
            "                    seek(offset)",
            "                    decoder.setimage(self.im, extents)",
            "                    if decoder.pulls_fd:",
            "                        decoder.setfd(self.fp)",
            "                        status, err_code = decoder.decode(b\"\")",
            "                    else:",
            "                        b = prefix",
            "                        while True:",
            "                            try:",
            "                                s = read(self.decodermaxblock)",
            "                            except (IndexError, struct.error) as e:",
            "                                # truncated png/gif",
            "                                if LOAD_TRUNCATED_IMAGES:",
            "                                    break",
            "                                else:",
            "                                    raise OSError(\"image file is truncated\") from e",
            "",
            "                            if not s:  # truncated jpeg",
            "                                if LOAD_TRUNCATED_IMAGES:",
            "                                    break",
            "                                else:",
            "                                    raise OSError(",
            "                                        \"image file is truncated \"",
            "                                        f\"({len(b)} bytes not processed)\"",
            "                                    )",
            "",
            "                            b = b + s",
            "                            n, err_code = decoder.decode(b)",
            "                            if n < 0:",
            "                                break",
            "                            b = b[n:]",
            "                finally:",
            "                    # Need to cleanup here to prevent leaks",
            "                    decoder.cleanup()",
            "",
            "        self.tile = []",
            "        self.readonly = readonly",
            "",
            "        self.load_end()",
            "",
            "        if self._exclusive_fp and self._close_exclusive_fp_after_loading:",
            "            self.fp.close()",
            "        self.fp = None",
            "",
            "        if not self.map and not LOAD_TRUNCATED_IMAGES and err_code < 0:",
            "            # still raised if decoder fails to return anything",
            "            raise_oserror(err_code)",
            "",
            "        return Image.Image.load(self)",
            "",
            "    def load_prepare(self):",
            "        # create image memory if necessary",
            "        if not self.im or self.im.mode != self.mode or self.im.size != self.size:",
            "            self.im = Image.core.new(self.mode, self.size)",
            "        # create palette (optional)",
            "        if self.mode == \"P\":",
            "            Image.Image.load(self)",
            "",
            "    def load_end(self):",
            "        # may be overridden",
            "        pass",
            "",
            "    # may be defined for contained formats",
            "    # def load_seek(self, pos):",
            "    #     pass",
            "",
            "    # may be defined for blocked formats (e.g. PNG)",
            "    # def load_read(self, bytes):",
            "    #     pass",
            "",
            "    def _seek_check(self, frame):",
            "        if (",
            "            frame < self._min_frame",
            "            # Only check upper limit on frames if additional seek operations",
            "            # are not required to do so",
            "            or (",
            "                not (hasattr(self, \"_n_frames\") and self._n_frames is None)",
            "                and frame >= self.n_frames + self._min_frame",
            "            )",
            "        ):",
            "            raise EOFError(\"attempt to seek outside sequence\")",
            "",
            "        return self.tell() != frame",
            "",
            "",
            "class StubImageFile(ImageFile):",
            "    \"\"\"",
            "    Base class for stub image loaders.",
            "",
            "    A stub loader is an image loader that can identify files of a",
            "    certain format, but relies on external code to load the file.",
            "    \"\"\"",
            "",
            "    def _open(self):",
            "        raise NotImplementedError(\"StubImageFile subclass must implement _open\")",
            "",
            "    def load(self):",
            "        loader = self._load()",
            "        if loader is None:",
            "            raise OSError(f\"cannot find loader for this {self.format} file\")",
            "        image = loader.load(self)",
            "        assert image is not None",
            "        # become the other object (!)",
            "        self.__class__ = image.__class__",
            "        self.__dict__ = image.__dict__",
            "",
            "    def _load(self):",
            "        \"\"\"(Hook) Find actual image loader.\"\"\"",
            "        raise NotImplementedError(\"StubImageFile subclass must implement _load\")",
            "",
            "",
            "class Parser:",
            "    \"\"\"",
            "    Incremental image parser.  This class implements the standard",
            "    feed/close consumer interface.",
            "    \"\"\"",
            "",
            "    incremental = None",
            "    image = None",
            "    data = None",
            "    decoder = None",
            "    offset = 0",
            "    finished = 0",
            "",
            "    def reset(self):",
            "        \"\"\"",
            "        (Consumer) Reset the parser.  Note that you can only call this",
            "        method immediately after you've created a parser; parser",
            "        instances cannot be reused.",
            "        \"\"\"",
            "        assert self.data is None, \"cannot reuse parsers\"",
            "",
            "    def feed(self, data):",
            "        \"\"\"",
            "        (Consumer) Feed data to the parser.",
            "",
            "        :param data: A string buffer.",
            "        :exception OSError: If the parser failed to parse the image file.",
            "        \"\"\"",
            "        # collect data",
            "",
            "        if self.finished:",
            "            return",
            "",
            "        if self.data is None:",
            "            self.data = data",
            "        else:",
            "            self.data = self.data + data",
            "",
            "        # parse what we have",
            "        if self.decoder:",
            "",
            "            if self.offset > 0:",
            "                # skip header",
            "                skip = min(len(self.data), self.offset)",
            "                self.data = self.data[skip:]",
            "                self.offset = self.offset - skip",
            "                if self.offset > 0 or not self.data:",
            "                    return",
            "",
            "            n, e = self.decoder.decode(self.data)",
            "",
            "            if n < 0:",
            "                # end of stream",
            "                self.data = None",
            "                self.finished = 1",
            "                if e < 0:",
            "                    # decoding error",
            "                    self.image = None",
            "                    raise_oserror(e)",
            "                else:",
            "                    # end of image",
            "                    return",
            "            self.data = self.data[n:]",
            "",
            "        elif self.image:",
            "",
            "            # if we end up here with no decoder, this file cannot",
            "            # be incrementally parsed.  wait until we've gotten all",
            "            # available data",
            "            pass",
            "",
            "        else:",
            "",
            "            # attempt to open this file",
            "            try:",
            "                with io.BytesIO(self.data) as fp:",
            "                    im = Image.open(fp)",
            "            except OSError:",
            "                # traceback.print_exc()",
            "                pass  # not enough data",
            "            else:",
            "                flag = hasattr(im, \"load_seek\") or hasattr(im, \"load_read\")",
            "                if flag or len(im.tile) != 1:",
            "                    # custom load code, or multiple tiles",
            "                    self.decode = None",
            "                else:",
            "                    # initialize decoder",
            "                    im.load_prepare()",
            "                    d, e, o, a = im.tile[0]",
            "                    im.tile = []",
            "                    self.decoder = Image._getdecoder(im.mode, d, a, im.decoderconfig)",
            "                    self.decoder.setimage(im.im, e)",
            "",
            "                    # calculate decoder offset",
            "                    self.offset = o",
            "                    if self.offset <= len(self.data):",
            "                        self.data = self.data[self.offset :]",
            "                        self.offset = 0",
            "",
            "                self.image = im",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(self, *args):",
            "        self.close()",
            "",
            "    def close(self):",
            "        \"\"\"",
            "        (Consumer) Close the stream.",
            "",
            "        :returns: An image object.",
            "        :exception OSError: If the parser failed to parse the image file either",
            "                            because it cannot be identified or cannot be",
            "                            decoded.",
            "        \"\"\"",
            "        # finish decoding",
            "        if self.decoder:",
            "            # get rid of what's left in the buffers",
            "            self.feed(b\"\")",
            "            self.data = self.decoder = None",
            "            if not self.finished:",
            "                raise OSError(\"image was incomplete\")",
            "        if not self.image:",
            "            raise OSError(\"cannot parse this image\")",
            "        if self.data:",
            "            # incremental parsing not possible; reopen the file",
            "            # not that we have all data",
            "            with io.BytesIO(self.data) as fp:",
            "                try:",
            "                    self.image = Image.open(fp)",
            "                finally:",
            "                    self.image.load()",
            "        return self.image",
            "",
            "",
            "# --------------------------------------------------------------------",
            "",
            "",
            "def _save(im, fp, tile, bufsize=0):",
            "    \"\"\"Helper to save image based on tile list",
            "",
            "    :param im: Image object.",
            "    :param fp: File object.",
            "    :param tile: Tile list.",
            "    :param bufsize: Optional buffer size",
            "    \"\"\"",
            "",
            "    im.load()",
            "    if not hasattr(im, \"encoderconfig\"):",
            "        im.encoderconfig = ()",
            "    tile.sort(key=_tilesort)",
            "    # FIXME: make MAXBLOCK a configuration parameter",
            "    # It would be great if we could have the encoder specify what it needs",
            "    # But, it would need at least the image size in most cases. RawEncode is",
            "    # a tricky case.",
            "    bufsize = max(MAXBLOCK, bufsize, im.size[0] * 4)  # see RawEncode.c",
            "    if fp == sys.stdout:",
            "        fp.flush()",
            "        return",
            "    try:",
            "        fh = fp.fileno()",
            "        fp.flush()",
            "    except (AttributeError, io.UnsupportedOperation) as exc:",
            "        # compress to Python file-compatible object",
            "        for e, b, o, a in tile:",
            "            e = Image._getencoder(im.mode, e, a, im.encoderconfig)",
            "            if o > 0:",
            "                fp.seek(o)",
            "            e.setimage(im.im, b)",
            "            if e.pushes_fd:",
            "                e.setfd(fp)",
            "                l, s = e.encode_to_pyfd()",
            "            else:",
            "                while True:",
            "                    l, s, d = e.encode(bufsize)",
            "                    fp.write(d)",
            "                    if s:",
            "                        break",
            "            if s < 0:",
            "                raise OSError(f\"encoder error {s} when writing image file\") from exc",
            "            e.cleanup()",
            "    else:",
            "        # slight speedup: compress to real file object",
            "        for e, b, o, a in tile:",
            "            e = Image._getencoder(im.mode, e, a, im.encoderconfig)",
            "            if o > 0:",
            "                fp.seek(o)",
            "            e.setimage(im.im, b)",
            "            if e.pushes_fd:",
            "                e.setfd(fp)",
            "                l, s = e.encode_to_pyfd()",
            "            else:",
            "                s = e.encode_to_file(fh, bufsize)",
            "            if s < 0:",
            "                raise OSError(f\"encoder error {s} when writing image file\")",
            "            e.cleanup()",
            "    if hasattr(fp, \"flush\"):",
            "        fp.flush()",
            "",
            "",
            "def _safe_read(fp, size):",
            "    \"\"\"",
            "    Reads large blocks in a safe way.  Unlike fp.read(n), this function",
            "    doesn't trust the user.  If the requested size is larger than",
            "    SAFEBLOCK, the file is read block by block.",
            "",
            "    :param fp: File handle.  Must implement a <b>read</b> method.",
            "    :param size: Number of bytes to read.",
            "    :returns: A string containing up to <i>size</i> bytes of data.",
            "    \"\"\"",
            "    if size <= 0:",
            "        return b\"\"",
            "    if size <= SAFEBLOCK:",
            "        return fp.read(size)",
            "    data = []",
            "    while size > 0:",
            "        block = fp.read(min(size, SAFEBLOCK))",
            "        if not block:",
            "            break",
            "        data.append(block)",
            "        size -= len(block)",
            "    return b\"\".join(data)",
            "",
            "",
            "class PyCodecState:",
            "    def __init__(self):",
            "        self.xsize = 0",
            "        self.ysize = 0",
            "        self.xoff = 0",
            "        self.yoff = 0",
            "",
            "    def extents(self):",
            "        return (self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize)",
            "",
            "",
            "class PyDecoder:",
            "    \"\"\"",
            "    Python implementation of a format decoder. Override this class and",
            "    add the decoding logic in the :meth:`decode` method.",
            "",
            "    See :ref:`Writing Your Own File Decoder in Python<file-decoders-py>`",
            "    \"\"\"",
            "",
            "    _pulls_fd = False",
            "",
            "    def __init__(self, mode, *args):",
            "        self.im = None",
            "        self.state = PyCodecState()",
            "        self.fd = None",
            "        self.mode = mode",
            "        self.init(args)",
            "",
            "    def init(self, args):",
            "        \"\"\"",
            "        Override to perform decoder specific initialization",
            "",
            "        :param args: Array of args items from the tile entry",
            "        :returns: None",
            "        \"\"\"",
            "        self.args = args",
            "",
            "    @property",
            "    def pulls_fd(self):",
            "        return self._pulls_fd",
            "",
            "    def decode(self, buffer):",
            "        \"\"\"",
            "        Override to perform the decoding process.",
            "",
            "        :param buffer: A bytes object with the data to be decoded.",
            "        :returns: A tuple of ``(bytes consumed, errcode)``.",
            "            If finished with decoding return <0 for the bytes consumed.",
            "            Err codes are from :data:`.ImageFile.ERRORS`.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def cleanup(self):",
            "        \"\"\"",
            "        Override to perform decoder specific cleanup",
            "",
            "        :returns: None",
            "        \"\"\"",
            "        pass",
            "",
            "    def setfd(self, fd):",
            "        \"\"\"",
            "        Called from ImageFile to set the python file-like object",
            "",
            "        :param fd: A python file-like object",
            "        :returns: None",
            "        \"\"\"",
            "        self.fd = fd",
            "",
            "    def setimage(self, im, extents=None):",
            "        \"\"\"",
            "        Called from ImageFile to set the core output image for the decoder",
            "",
            "        :param im: A core image object",
            "        :param extents: a 4 tuple of (x0, y0, x1, y1) defining the rectangle",
            "            for this tile",
            "        :returns: None",
            "        \"\"\"",
            "",
            "        # following c code",
            "        self.im = im",
            "",
            "        if extents:",
            "            (x0, y0, x1, y1) = extents",
            "        else:",
            "            (x0, y0, x1, y1) = (0, 0, 0, 0)",
            "",
            "        if x0 == 0 and x1 == 0:",
            "            self.state.xsize, self.state.ysize = self.im.size",
            "        else:",
            "            self.state.xoff = x0",
            "            self.state.yoff = y0",
            "            self.state.xsize = x1 - x0",
            "            self.state.ysize = y1 - y0",
            "",
            "        if self.state.xsize <= 0 or self.state.ysize <= 0:",
            "            raise ValueError(\"Size cannot be negative\")",
            "",
            "        if (",
            "            self.state.xsize + self.state.xoff > self.im.size[0]",
            "            or self.state.ysize + self.state.yoff > self.im.size[1]",
            "        ):",
            "            raise ValueError(\"Tile cannot extend outside image\")",
            "",
            "    def set_as_raw(self, data, rawmode=None):",
            "        \"\"\"",
            "        Convenience method to set the internal image from a stream of raw data",
            "",
            "        :param data: Bytes to be set",
            "        :param rawmode: The rawmode to be used for the decoder.",
            "            If not specified, it will default to the mode of the image",
            "        :returns: None",
            "        \"\"\"",
            "",
            "        if not rawmode:",
            "            rawmode = self.mode",
            "        d = Image._getdecoder(self.mode, \"raw\", (rawmode))",
            "        d.setimage(self.im, self.state.extents())",
            "        s = d.decode(data)",
            "",
            "        if s[0] >= 0:",
            "            raise ValueError(\"not enough image data\")",
            "        if s[1] != 0:",
            "            raise ValueError(\"cannot decode image data\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# base class for image file handlers",
            "#",
            "# history:",
            "# 1995-09-09 fl   Created",
            "# 1996-03-11 fl   Fixed load mechanism.",
            "# 1996-04-15 fl   Added pcx/xbm decoders.",
            "# 1996-04-30 fl   Added encoders.",
            "# 1996-12-14 fl   Added load helpers",
            "# 1997-01-11 fl   Use encode_to_file where possible",
            "# 1997-08-27 fl   Flush output in _save",
            "# 1998-03-05 fl   Use memory mapping for some modes",
            "# 1999-02-04 fl   Use memory mapping also for \"I;16\" and \"I;16B\"",
            "# 1999-05-31 fl   Added image parser",
            "# 2000-10-12 fl   Set readonly flag on memory-mapped images",
            "# 2002-03-20 fl   Use better messages for common decoder errors",
            "# 2003-04-21 fl   Fall back on mmap/map_buffer if map is not available",
            "# 2003-10-30 fl   Added StubImageFile class",
            "# 2004-02-25 fl   Made incremental parser more robust",
            "#",
            "# Copyright (c) 1997-2004 by Secret Labs AB",
            "# Copyright (c) 1995-2004 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import struct",
            "import sys",
            "import warnings",
            "",
            "from . import Image",
            "from ._util import isPath",
            "",
            "MAXBLOCK = 65536",
            "",
            "SAFEBLOCK = 1024 * 1024",
            "",
            "LOAD_TRUNCATED_IMAGES = False",
            "\"\"\"Whether or not to load truncated image files. User code may change this.\"\"\"",
            "",
            "ERRORS = {",
            "    -1: \"image buffer overrun error\",",
            "    -2: \"decoding error\",",
            "    -3: \"unknown error\",",
            "    -8: \"bad configuration\",",
            "    -9: \"out of memory error\",",
            "}",
            "\"\"\"Dict of known error codes returned from :meth:`.PyDecoder.decode`.\"\"\"",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "# Helpers",
            "",
            "",
            "def raise_oserror(error):",
            "    try:",
            "        message = Image.core.getcodecstatus(error)",
            "    except AttributeError:",
            "        message = ERRORS.get(error)",
            "    if not message:",
            "        message = f\"decoder error {error}\"",
            "    raise OSError(message + \" when reading image file\")",
            "",
            "",
            "def raise_ioerror(error):",
            "    warnings.warn(",
            "        \"raise_ioerror is deprecated and will be removed in Pillow 9 (2022-01-02). \"",
            "        \"Use raise_oserror instead.\",",
            "        DeprecationWarning,",
            "    )",
            "    return raise_oserror(error)",
            "",
            "",
            "def _tilesort(t):",
            "    # sort on offset",
            "    return t[2]",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "# ImageFile base class",
            "",
            "",
            "class ImageFile(Image.Image):",
            "    \"\"\"Base class for image file format handlers.\"\"\"",
            "",
            "    def __init__(self, fp=None, filename=None):",
            "        super().__init__()",
            "",
            "        self._min_frame = 0",
            "",
            "        self.custom_mimetype = None",
            "",
            "        self.tile = None",
            "        \"\"\" A list of tile descriptors, or ``None`` \"\"\"",
            "",
            "        self.readonly = 1  # until we know better",
            "",
            "        self.decoderconfig = ()",
            "        self.decodermaxblock = MAXBLOCK",
            "",
            "        if isPath(fp):",
            "            # filename",
            "            self.fp = open(fp, \"rb\")",
            "            self.filename = fp",
            "            self._exclusive_fp = True",
            "        else:",
            "            # stream",
            "            self.fp = fp",
            "            self.filename = filename",
            "            # can be overridden",
            "            self._exclusive_fp = None",
            "",
            "        try:",
            "            try:",
            "                self._open()",
            "            except (",
            "                IndexError,  # end of data",
            "                TypeError,  # end of data (ord)",
            "                KeyError,  # unsupported mode",
            "                EOFError,  # got header but not the first frame",
            "                struct.error,",
            "            ) as v:",
            "                raise SyntaxError(v) from v",
            "",
            "            if not self.mode or self.size[0] <= 0:",
            "                raise SyntaxError(\"not identified by this driver\")",
            "        except BaseException:",
            "            # close the file only if we have opened it this constructor",
            "            if self._exclusive_fp:",
            "                self.fp.close()",
            "            raise",
            "",
            "    def get_format_mimetype(self):",
            "        if self.custom_mimetype:",
            "            return self.custom_mimetype",
            "        if self.format is not None:",
            "            return Image.MIME.get(self.format.upper())",
            "",
            "    def verify(self):",
            "        \"\"\"Check file integrity\"\"\"",
            "",
            "        # raise exception if something's wrong.  must be called",
            "        # directly after open, and closes file when finished.",
            "        if self._exclusive_fp:",
            "            self.fp.close()",
            "        self.fp = None",
            "",
            "    def load(self):",
            "        \"\"\"Load image data based on tile list\"\"\"",
            "",
            "        if self.tile is None:",
            "            raise OSError(\"cannot load this image\")",
            "",
            "        pixel = Image.Image.load(self)",
            "        if not self.tile:",
            "            return pixel",
            "",
            "        self.map = None",
            "        use_mmap = self.filename and len(self.tile) == 1",
            "        # As of pypy 2.1.0, memory mapping was failing here.",
            "        use_mmap = use_mmap and not hasattr(sys, \"pypy_version_info\")",
            "",
            "        readonly = 0",
            "",
            "        # look for read/seek overrides",
            "        try:",
            "            read = self.load_read",
            "            # don't use mmap if there are custom read/seek functions",
            "            use_mmap = False",
            "        except AttributeError:",
            "            read = self.fp.read",
            "",
            "        try:",
            "            seek = self.load_seek",
            "            use_mmap = False",
            "        except AttributeError:",
            "            seek = self.fp.seek",
            "",
            "        if use_mmap:",
            "            # try memory mapping",
            "            decoder_name, extents, offset, args = self.tile[0]",
            "            if (",
            "                decoder_name == \"raw\"",
            "                and len(args) >= 3",
            "                and args[0] == self.mode",
            "                and args[0] in Image._MAPMODES",
            "            ):",
            "                try:",
            "                    # use mmap, if possible",
            "                    import mmap",
            "",
            "                    with open(self.filename) as fp:",
            "                        self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)",
            "                    self.im = Image.core.map_buffer(",
            "                        self.map, self.size, decoder_name, offset, args",
            "                    )",
            "                    readonly = 1",
            "                    # After trashing self.im,",
            "                    # we might need to reload the palette data.",
            "                    if self.palette:",
            "                        self.palette.dirty = 1",
            "                except (AttributeError, OSError, ImportError):",
            "                    self.map = None",
            "",
            "        self.load_prepare()",
            "        err_code = -3  # initialize to unknown error",
            "        if not self.map:",
            "            # sort tiles in file order",
            "            self.tile.sort(key=_tilesort)",
            "",
            "            try:",
            "                # FIXME: This is a hack to handle TIFF's JpegTables tag.",
            "                prefix = self.tile_prefix",
            "            except AttributeError:",
            "                prefix = b\"\"",
            "",
            "            for decoder_name, extents, offset, args in self.tile:",
            "                decoder = Image._getdecoder(",
            "                    self.mode, decoder_name, args, self.decoderconfig",
            "                )",
            "                try:",
            "                    seek(offset)",
            "                    decoder.setimage(self.im, extents)",
            "                    if decoder.pulls_fd:",
            "                        decoder.setfd(self.fp)",
            "                        status, err_code = decoder.decode(b\"\")",
            "                    else:",
            "                        b = prefix",
            "                        while True:",
            "                            try:",
            "                                s = read(self.decodermaxblock)",
            "                            except (IndexError, struct.error) as e:",
            "                                # truncated png/gif",
            "                                if LOAD_TRUNCATED_IMAGES:",
            "                                    break",
            "                                else:",
            "                                    raise OSError(\"image file is truncated\") from e",
            "",
            "                            if not s:  # truncated jpeg",
            "                                if LOAD_TRUNCATED_IMAGES:",
            "                                    break",
            "                                else:",
            "                                    raise OSError(",
            "                                        \"image file is truncated \"",
            "                                        f\"({len(b)} bytes not processed)\"",
            "                                    )",
            "",
            "                            b = b + s",
            "                            n, err_code = decoder.decode(b)",
            "                            if n < 0:",
            "                                break",
            "                            b = b[n:]",
            "                finally:",
            "                    # Need to cleanup here to prevent leaks",
            "                    decoder.cleanup()",
            "",
            "        self.tile = []",
            "        self.readonly = readonly",
            "",
            "        self.load_end()",
            "",
            "        if self._exclusive_fp and self._close_exclusive_fp_after_loading:",
            "            self.fp.close()",
            "        self.fp = None",
            "",
            "        if not self.map and not LOAD_TRUNCATED_IMAGES and err_code < 0:",
            "            # still raised if decoder fails to return anything",
            "            raise_oserror(err_code)",
            "",
            "        return Image.Image.load(self)",
            "",
            "    def load_prepare(self):",
            "        # create image memory if necessary",
            "        if not self.im or self.im.mode != self.mode or self.im.size != self.size:",
            "            self.im = Image.core.new(self.mode, self.size)",
            "        # create palette (optional)",
            "        if self.mode == \"P\":",
            "            Image.Image.load(self)",
            "",
            "    def load_end(self):",
            "        # may be overridden",
            "        pass",
            "",
            "    # may be defined for contained formats",
            "    # def load_seek(self, pos):",
            "    #     pass",
            "",
            "    # may be defined for blocked formats (e.g. PNG)",
            "    # def load_read(self, bytes):",
            "    #     pass",
            "",
            "    def _seek_check(self, frame):",
            "        if (",
            "            frame < self._min_frame",
            "            # Only check upper limit on frames if additional seek operations",
            "            # are not required to do so",
            "            or (",
            "                not (hasattr(self, \"_n_frames\") and self._n_frames is None)",
            "                and frame >= self.n_frames + self._min_frame",
            "            )",
            "        ):",
            "            raise EOFError(\"attempt to seek outside sequence\")",
            "",
            "        return self.tell() != frame",
            "",
            "",
            "class StubImageFile(ImageFile):",
            "    \"\"\"",
            "    Base class for stub image loaders.",
            "",
            "    A stub loader is an image loader that can identify files of a",
            "    certain format, but relies on external code to load the file.",
            "    \"\"\"",
            "",
            "    def _open(self):",
            "        raise NotImplementedError(\"StubImageFile subclass must implement _open\")",
            "",
            "    def load(self):",
            "        loader = self._load()",
            "        if loader is None:",
            "            raise OSError(f\"cannot find loader for this {self.format} file\")",
            "        image = loader.load(self)",
            "        assert image is not None",
            "        # become the other object (!)",
            "        self.__class__ = image.__class__",
            "        self.__dict__ = image.__dict__",
            "",
            "    def _load(self):",
            "        \"\"\"(Hook) Find actual image loader.\"\"\"",
            "        raise NotImplementedError(\"StubImageFile subclass must implement _load\")",
            "",
            "",
            "class Parser:",
            "    \"\"\"",
            "    Incremental image parser.  This class implements the standard",
            "    feed/close consumer interface.",
            "    \"\"\"",
            "",
            "    incremental = None",
            "    image = None",
            "    data = None",
            "    decoder = None",
            "    offset = 0",
            "    finished = 0",
            "",
            "    def reset(self):",
            "        \"\"\"",
            "        (Consumer) Reset the parser.  Note that you can only call this",
            "        method immediately after you've created a parser; parser",
            "        instances cannot be reused.",
            "        \"\"\"",
            "        assert self.data is None, \"cannot reuse parsers\"",
            "",
            "    def feed(self, data):",
            "        \"\"\"",
            "        (Consumer) Feed data to the parser.",
            "",
            "        :param data: A string buffer.",
            "        :exception OSError: If the parser failed to parse the image file.",
            "        \"\"\"",
            "        # collect data",
            "",
            "        if self.finished:",
            "            return",
            "",
            "        if self.data is None:",
            "            self.data = data",
            "        else:",
            "            self.data = self.data + data",
            "",
            "        # parse what we have",
            "        if self.decoder:",
            "",
            "            if self.offset > 0:",
            "                # skip header",
            "                skip = min(len(self.data), self.offset)",
            "                self.data = self.data[skip:]",
            "                self.offset = self.offset - skip",
            "                if self.offset > 0 or not self.data:",
            "                    return",
            "",
            "            n, e = self.decoder.decode(self.data)",
            "",
            "            if n < 0:",
            "                # end of stream",
            "                self.data = None",
            "                self.finished = 1",
            "                if e < 0:",
            "                    # decoding error",
            "                    self.image = None",
            "                    raise_oserror(e)",
            "                else:",
            "                    # end of image",
            "                    return",
            "            self.data = self.data[n:]",
            "",
            "        elif self.image:",
            "",
            "            # if we end up here with no decoder, this file cannot",
            "            # be incrementally parsed.  wait until we've gotten all",
            "            # available data",
            "            pass",
            "",
            "        else:",
            "",
            "            # attempt to open this file",
            "            try:",
            "                with io.BytesIO(self.data) as fp:",
            "                    im = Image.open(fp)",
            "            except OSError:",
            "                # traceback.print_exc()",
            "                pass  # not enough data",
            "            else:",
            "                flag = hasattr(im, \"load_seek\") or hasattr(im, \"load_read\")",
            "                if flag or len(im.tile) != 1:",
            "                    # custom load code, or multiple tiles",
            "                    self.decode = None",
            "                else:",
            "                    # initialize decoder",
            "                    im.load_prepare()",
            "                    d, e, o, a = im.tile[0]",
            "                    im.tile = []",
            "                    self.decoder = Image._getdecoder(im.mode, d, a, im.decoderconfig)",
            "                    self.decoder.setimage(im.im, e)",
            "",
            "                    # calculate decoder offset",
            "                    self.offset = o",
            "                    if self.offset <= len(self.data):",
            "                        self.data = self.data[self.offset :]",
            "                        self.offset = 0",
            "",
            "                self.image = im",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(self, *args):",
            "        self.close()",
            "",
            "    def close(self):",
            "        \"\"\"",
            "        (Consumer) Close the stream.",
            "",
            "        :returns: An image object.",
            "        :exception OSError: If the parser failed to parse the image file either",
            "                            because it cannot be identified or cannot be",
            "                            decoded.",
            "        \"\"\"",
            "        # finish decoding",
            "        if self.decoder:",
            "            # get rid of what's left in the buffers",
            "            self.feed(b\"\")",
            "            self.data = self.decoder = None",
            "            if not self.finished:",
            "                raise OSError(\"image was incomplete\")",
            "        if not self.image:",
            "            raise OSError(\"cannot parse this image\")",
            "        if self.data:",
            "            # incremental parsing not possible; reopen the file",
            "            # not that we have all data",
            "            with io.BytesIO(self.data) as fp:",
            "                try:",
            "                    self.image = Image.open(fp)",
            "                finally:",
            "                    self.image.load()",
            "        return self.image",
            "",
            "",
            "# --------------------------------------------------------------------",
            "",
            "",
            "def _save(im, fp, tile, bufsize=0):",
            "    \"\"\"Helper to save image based on tile list",
            "",
            "    :param im: Image object.",
            "    :param fp: File object.",
            "    :param tile: Tile list.",
            "    :param bufsize: Optional buffer size",
            "    \"\"\"",
            "",
            "    im.load()",
            "    if not hasattr(im, \"encoderconfig\"):",
            "        im.encoderconfig = ()",
            "    tile.sort(key=_tilesort)",
            "    # FIXME: make MAXBLOCK a configuration parameter",
            "    # It would be great if we could have the encoder specify what it needs",
            "    # But, it would need at least the image size in most cases. RawEncode is",
            "    # a tricky case.",
            "    bufsize = max(MAXBLOCK, bufsize, im.size[0] * 4)  # see RawEncode.c",
            "    if fp == sys.stdout:",
            "        fp.flush()",
            "        return",
            "    try:",
            "        fh = fp.fileno()",
            "        fp.flush()",
            "    except (AttributeError, io.UnsupportedOperation) as exc:",
            "        # compress to Python file-compatible object",
            "        for e, b, o, a in tile:",
            "            e = Image._getencoder(im.mode, e, a, im.encoderconfig)",
            "            if o > 0:",
            "                fp.seek(o)",
            "            e.setimage(im.im, b)",
            "            if e.pushes_fd:",
            "                e.setfd(fp)",
            "                l, s = e.encode_to_pyfd()",
            "            else:",
            "                while True:",
            "                    l, s, d = e.encode(bufsize)",
            "                    fp.write(d)",
            "                    if s:",
            "                        break",
            "            if s < 0:",
            "                raise OSError(f\"encoder error {s} when writing image file\") from exc",
            "            e.cleanup()",
            "    else:",
            "        # slight speedup: compress to real file object",
            "        for e, b, o, a in tile:",
            "            e = Image._getencoder(im.mode, e, a, im.encoderconfig)",
            "            if o > 0:",
            "                fp.seek(o)",
            "            e.setimage(im.im, b)",
            "            if e.pushes_fd:",
            "                e.setfd(fp)",
            "                l, s = e.encode_to_pyfd()",
            "            else:",
            "                s = e.encode_to_file(fh, bufsize)",
            "            if s < 0:",
            "                raise OSError(f\"encoder error {s} when writing image file\")",
            "            e.cleanup()",
            "    if hasattr(fp, \"flush\"):",
            "        fp.flush()",
            "",
            "",
            "def _safe_read(fp, size):",
            "    \"\"\"",
            "    Reads large blocks in a safe way.  Unlike fp.read(n), this function",
            "    doesn't trust the user.  If the requested size is larger than",
            "    SAFEBLOCK, the file is read block by block.",
            "",
            "    :param fp: File handle.  Must implement a <b>read</b> method.",
            "    :param size: Number of bytes to read.",
            "    :returns: A string containing <i>size</i> bytes of data.",
            "",
            "    Raises an OSError if the file is truncated and the read can not be completed",
            "",
            "    \"\"\"",
            "    if size <= 0:",
            "        return b\"\"",
            "    if size <= SAFEBLOCK:",
            "        data = fp.read(size)",
            "        if len(data) < size:",
            "            raise OSError(\"Truncated File Read\")",
            "        return data",
            "    data = []",
            "    while size > 0:",
            "        block = fp.read(min(size, SAFEBLOCK))",
            "        if not block:",
            "            break",
            "        data.append(block)",
            "        size -= len(block)",
            "    if sum(len(d) for d in data) < size:",
            "        raise OSError(\"Truncated File Read\")",
            "    return b\"\".join(data)",
            "",
            "",
            "",
            "",
            "class PyCodecState:",
            "    def __init__(self):",
            "        self.xsize = 0",
            "        self.ysize = 0",
            "        self.xoff = 0",
            "        self.yoff = 0",
            "",
            "    def extents(self):",
            "        return (self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize)",
            "",
            "",
            "class PyDecoder:",
            "    \"\"\"",
            "    Python implementation of a format decoder. Override this class and",
            "    add the decoding logic in the :meth:`decode` method.",
            "",
            "    See :ref:`Writing Your Own File Decoder in Python<file-decoders-py>`",
            "    \"\"\"",
            "",
            "    _pulls_fd = False",
            "",
            "    def __init__(self, mode, *args):",
            "        self.im = None",
            "        self.state = PyCodecState()",
            "        self.fd = None",
            "        self.mode = mode",
            "        self.init(args)",
            "",
            "    def init(self, args):",
            "        \"\"\"",
            "        Override to perform decoder specific initialization",
            "",
            "        :param args: Array of args items from the tile entry",
            "        :returns: None",
            "        \"\"\"",
            "        self.args = args",
            "",
            "    @property",
            "    def pulls_fd(self):",
            "        return self._pulls_fd",
            "",
            "    def decode(self, buffer):",
            "        \"\"\"",
            "        Override to perform the decoding process.",
            "",
            "        :param buffer: A bytes object with the data to be decoded.",
            "        :returns: A tuple of ``(bytes consumed, errcode)``.",
            "            If finished with decoding return <0 for the bytes consumed.",
            "            Err codes are from :data:`.ImageFile.ERRORS`.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def cleanup(self):",
            "        \"\"\"",
            "        Override to perform decoder specific cleanup",
            "",
            "        :returns: None",
            "        \"\"\"",
            "        pass",
            "",
            "    def setfd(self, fd):",
            "        \"\"\"",
            "        Called from ImageFile to set the python file-like object",
            "",
            "        :param fd: A python file-like object",
            "        :returns: None",
            "        \"\"\"",
            "        self.fd = fd",
            "",
            "    def setimage(self, im, extents=None):",
            "        \"\"\"",
            "        Called from ImageFile to set the core output image for the decoder",
            "",
            "        :param im: A core image object",
            "        :param extents: a 4 tuple of (x0, y0, x1, y1) defining the rectangle",
            "            for this tile",
            "        :returns: None",
            "        \"\"\"",
            "",
            "        # following c code",
            "        self.im = im",
            "",
            "        if extents:",
            "            (x0, y0, x1, y1) = extents",
            "        else:",
            "            (x0, y0, x1, y1) = (0, 0, 0, 0)",
            "",
            "        if x0 == 0 and x1 == 0:",
            "            self.state.xsize, self.state.ysize = self.im.size",
            "        else:",
            "            self.state.xoff = x0",
            "            self.state.yoff = y0",
            "            self.state.xsize = x1 - x0",
            "            self.state.ysize = y1 - y0",
            "",
            "        if self.state.xsize <= 0 or self.state.ysize <= 0:",
            "            raise ValueError(\"Size cannot be negative\")",
            "",
            "        if (",
            "            self.state.xsize + self.state.xoff > self.im.size[0]",
            "            or self.state.ysize + self.state.yoff > self.im.size[1]",
            "        ):",
            "            raise ValueError(\"Tile cannot extend outside image\")",
            "",
            "    def set_as_raw(self, data, rawmode=None):",
            "        \"\"\"",
            "        Convenience method to set the internal image from a stream of raw data",
            "",
            "        :param data: Bytes to be set",
            "        :param rawmode: The rawmode to be used for the decoder.",
            "            If not specified, it will default to the mode of the image",
            "        :returns: None",
            "        \"\"\"",
            "",
            "        if not rawmode:",
            "            rawmode = self.mode",
            "        d = Image._getdecoder(self.mode, \"raw\", (rawmode))",
            "        d.setimage(self.im, self.state.extents())",
            "        s = d.decode(data)",
            "",
            "        if s[0] >= 0:",
            "            raise ValueError(\"not enough image data\")",
            "        if s[1] != 0:",
            "            raise ValueError(\"cannot decode image data\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "548": [
                "_safe_read"
            ],
            "553": [
                "_safe_read"
            ]
        },
        "addLocation": []
    },
    "src/PIL/PsdImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "             end = self.fp.tell() + size"
            },
            "1": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "             size = i32(read(4))"
            },
            "2": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "             if size:"
            },
            "3": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.layers = _layerinfo(self.fp)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                _layer_data = io.BytesIO(ImageFile._safe_read(self.fp, size))"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+                self.layers = _layerinfo(_layer_data, size)"
            },
            "6": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             self.fp.seek(end)"
            },
            "7": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         self.n_frames = len(self.layers)"
            },
            "8": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         self.is_animated = self.n_frames > 1"
            },
            "9": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         finally:"
            },
            "10": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "             self.__fp = None"
            },
            "11": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def _layerinfo(file):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+def _layerinfo(fp, ct_bytes):"
            },
            "15": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "     # read layerinfo block"
            },
            "16": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "     layers = []"
            },
            "17": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    read = file.read"
            },
            "18": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for i in range(abs(i16(read(2)))):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    def read(size):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        return ImageFile._safe_read(fp, size)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+    ct = i16(read(2))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+    # sanity check"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    if ct_bytes < (abs(ct) * 20):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        raise SyntaxError(\"Layer block too short for number of layers requested\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+    for i in range(abs(ct)):"
            },
            "30": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         # bounding box"
            },
            "32": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         y0 = i32(read(4))"
            },
            "33": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "         # image info"
            },
            "34": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         info = []"
            },
            "35": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         mode = []"
            },
            "36": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        types = list(range(i16(read(2))))"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        ct_types = i16(read(2))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        types = list(range(ct_types))"
            },
            "39": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         if len(types) > 4:"
            },
            "40": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "             continue"
            },
            "41": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 202,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         size = i32(read(4))  # length of the extra data field"
            },
            "43": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         combined = 0"
            },
            "44": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         if size:"
            },
            "45": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data_end = file.tell() + size"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            data_end = fp.tell() + size"
            },
            "47": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             length = i32(read(4))"
            },
            "49": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             if length:"
            },
            "50": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                file.seek(length - 16, io.SEEK_CUR)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+                fp.seek(length - 16, io.SEEK_CUR)"
            },
            "52": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "             combined += length + 4"
            },
            "53": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "             length = i32(read(4))"
            },
            "55": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "             if length:"
            },
            "56": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                file.seek(length, io.SEEK_CUR)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+                fp.seek(length, io.SEEK_CUR)"
            },
            "58": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "             combined += length + 4"
            },
            "59": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             length = i8(read(1))"
            },
            "61": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "                 name = read(length).decode(\"latin-1\", \"replace\")"
            },
            "62": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "             combined += length + 1"
            },
            "63": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 250,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file.seek(data_end)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+            fp.seek(data_end)"
            },
            "66": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         layers.append((name, mode, (x0, y0, x1, y1)))"
            },
            "67": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 253,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "     # get tiles"
            },
            "69": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     i = 0"
            },
            "70": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "     for name, mode, bbox in layers:"
            },
            "71": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         tile = []"
            },
            "72": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         for m in mode:"
            },
            "73": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            t = _maketile(file, m, bbox, 1)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+            t = _maketile(fp, m, bbox, 1)"
            },
            "75": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "             if t:"
            },
            "76": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "                 tile.extend(t)"
            },
            "77": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         layers[i] = name, mode, bbox, tile"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library",
            "# $Id$",
            "#",
            "# Adobe PSD 2.5/3.0 file handling",
            "#",
            "# History:",
            "# 1995-09-01 fl   Created",
            "# 1997-01-03 fl   Read most PSD images",
            "# 1997-01-18 fl   Fixed P and CMYK support",
            "# 2001-10-21 fl   Added seek/tell support (for layers)",
            "#",
            "# Copyright (c) 1997-2001 by Secret Labs AB.",
            "# Copyright (c) 1995-2001 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "",
            "from . import Image, ImageFile, ImagePalette",
            "from ._binary import i8",
            "from ._binary import i16be as i16",
            "from ._binary import i32be as i32",
            "",
            "MODES = {",
            "    # (photoshop mode, bits) -> (pil mode, required channels)",
            "    (0, 1): (\"1\", 1),",
            "    (0, 8): (\"L\", 1),",
            "    (1, 8): (\"L\", 1),",
            "    (2, 8): (\"P\", 1),",
            "    (3, 8): (\"RGB\", 3),",
            "    (4, 8): (\"CMYK\", 4),",
            "    (7, 8): (\"L\", 1),  # FIXME: multilayer",
            "    (8, 8): (\"L\", 1),  # duotone",
            "    (9, 8): (\"LAB\", 3),",
            "}",
            "",
            "",
            "# --------------------------------------------------------------------.",
            "# read PSD images",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == b\"8BPS\"",
            "",
            "",
            "##",
            "# Image plugin for Photoshop images.",
            "",
            "",
            "class PsdImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"PSD\"",
            "    format_description = \"Adobe Photoshop\"",
            "    _close_exclusive_fp_after_loading = False",
            "",
            "    def _open(self):",
            "",
            "        read = self.fp.read",
            "",
            "        #",
            "        # header",
            "",
            "        s = read(26)",
            "        if not _accept(s) or i16(s, 4) != 1:",
            "            raise SyntaxError(\"not a PSD file\")",
            "",
            "        psd_bits = i16(s, 22)",
            "        psd_channels = i16(s, 12)",
            "        psd_mode = i16(s, 24)",
            "",
            "        mode, channels = MODES[(psd_mode, psd_bits)]",
            "",
            "        if channels > psd_channels:",
            "            raise OSError(\"not enough channels\")",
            "",
            "        self.mode = mode",
            "        self._size = i32(s, 18), i32(s, 14)",
            "",
            "        #",
            "        # color mode data",
            "",
            "        size = i32(read(4))",
            "        if size:",
            "            data = read(size)",
            "            if mode == \"P\" and size == 768:",
            "                self.palette = ImagePalette.raw(\"RGB;L\", data)",
            "",
            "        #",
            "        # image resources",
            "",
            "        self.resources = []",
            "",
            "        size = i32(read(4))",
            "        if size:",
            "            # load resources",
            "            end = self.fp.tell() + size",
            "            while self.fp.tell() < end:",
            "                read(4)  # signature",
            "                id = i16(read(2))",
            "                name = read(i8(read(1)))",
            "                if not (len(name) & 1):",
            "                    read(1)  # padding",
            "                data = read(i32(read(4)))",
            "                if len(data) & 1:",
            "                    read(1)  # padding",
            "                self.resources.append((id, name, data))",
            "                if id == 1039:  # ICC profile",
            "                    self.info[\"icc_profile\"] = data",
            "",
            "        #",
            "        # layer and mask information",
            "",
            "        self.layers = []",
            "",
            "        size = i32(read(4))",
            "        if size:",
            "            end = self.fp.tell() + size",
            "            size = i32(read(4))",
            "            if size:",
            "                self.layers = _layerinfo(self.fp)",
            "            self.fp.seek(end)",
            "        self.n_frames = len(self.layers)",
            "        self.is_animated = self.n_frames > 1",
            "",
            "        #",
            "        # image descriptor",
            "",
            "        self.tile = _maketile(self.fp, mode, (0, 0) + self.size, channels)",
            "",
            "        # keep the file open",
            "        self.__fp = self.fp",
            "        self.frame = 1",
            "        self._min_frame = 1",
            "",
            "    def seek(self, layer):",
            "        if not self._seek_check(layer):",
            "            return",
            "",
            "        # seek to given layer (1..max)",
            "        try:",
            "            name, mode, bbox, tile = self.layers[layer - 1]",
            "            self.mode = mode",
            "            self.tile = tile",
            "            self.frame = layer",
            "            self.fp = self.__fp",
            "            return name, bbox",
            "        except IndexError as e:",
            "            raise EOFError(\"no such layer\") from e",
            "",
            "    def tell(self):",
            "        # return layer number (0=image, 1..max=layers)",
            "        return self.frame",
            "",
            "    def load_prepare(self):",
            "        # create image memory if necessary",
            "        if not self.im or self.im.mode != self.mode or self.im.size != self.size:",
            "            self.im = Image.core.fill(self.mode, self.size, 0)",
            "        # create palette (optional)",
            "        if self.mode == \"P\":",
            "            Image.Image.load(self)",
            "",
            "    def _close__fp(self):",
            "        try:",
            "            if self.__fp != self.fp:",
            "                self.__fp.close()",
            "        except AttributeError:",
            "            pass",
            "        finally:",
            "            self.__fp = None",
            "",
            "",
            "def _layerinfo(file):",
            "    # read layerinfo block",
            "    layers = []",
            "    read = file.read",
            "    for i in range(abs(i16(read(2)))):",
            "",
            "        # bounding box",
            "        y0 = i32(read(4))",
            "        x0 = i32(read(4))",
            "        y1 = i32(read(4))",
            "        x1 = i32(read(4))",
            "",
            "        # image info",
            "        info = []",
            "        mode = []",
            "        types = list(range(i16(read(2))))",
            "        if len(types) > 4:",
            "            continue",
            "",
            "        for i in types:",
            "            type = i16(read(2))",
            "",
            "            if type == 65535:",
            "                m = \"A\"",
            "            else:",
            "                m = \"RGBA\"[type]",
            "",
            "            mode.append(m)",
            "            size = i32(read(4))",
            "            info.append((m, size))",
            "",
            "        # figure out the image mode",
            "        mode.sort()",
            "        if mode == [\"R\"]:",
            "            mode = \"L\"",
            "        elif mode == [\"B\", \"G\", \"R\"]:",
            "            mode = \"RGB\"",
            "        elif mode == [\"A\", \"B\", \"G\", \"R\"]:",
            "            mode = \"RGBA\"",
            "        else:",
            "            mode = None  # unknown",
            "",
            "        # skip over blend flags and extra information",
            "        read(12)  # filler",
            "        name = \"\"",
            "        size = i32(read(4))  # length of the extra data field",
            "        combined = 0",
            "        if size:",
            "            data_end = file.tell() + size",
            "",
            "            length = i32(read(4))",
            "            if length:",
            "                file.seek(length - 16, io.SEEK_CUR)",
            "            combined += length + 4",
            "",
            "            length = i32(read(4))",
            "            if length:",
            "                file.seek(length, io.SEEK_CUR)",
            "            combined += length + 4",
            "",
            "            length = i8(read(1))",
            "            if length:",
            "                # Don't know the proper encoding,",
            "                # Latin-1 should be a good guess",
            "                name = read(length).decode(\"latin-1\", \"replace\")",
            "            combined += length + 1",
            "",
            "            file.seek(data_end)",
            "        layers.append((name, mode, (x0, y0, x1, y1)))",
            "",
            "    # get tiles",
            "    i = 0",
            "    for name, mode, bbox in layers:",
            "        tile = []",
            "        for m in mode:",
            "            t = _maketile(file, m, bbox, 1)",
            "            if t:",
            "                tile.extend(t)",
            "        layers[i] = name, mode, bbox, tile",
            "        i += 1",
            "",
            "    return layers",
            "",
            "",
            "def _maketile(file, mode, bbox, channels):",
            "",
            "    tile = None",
            "    read = file.read",
            "",
            "    compression = i16(read(2))",
            "",
            "    xsize = bbox[2] - bbox[0]",
            "    ysize = bbox[3] - bbox[1]",
            "",
            "    offset = file.tell()",
            "",
            "    if compression == 0:",
            "        #",
            "        # raw compression",
            "        tile = []",
            "        for channel in range(channels):",
            "            layer = mode[channel]",
            "            if mode == \"CMYK\":",
            "                layer += \";I\"",
            "            tile.append((\"raw\", bbox, offset, layer))",
            "            offset = offset + xsize * ysize",
            "",
            "    elif compression == 1:",
            "        #",
            "        # packbits compression",
            "        i = 0",
            "        tile = []",
            "        bytecount = read(channels * ysize * 2)",
            "        offset = file.tell()",
            "        for channel in range(channels):",
            "            layer = mode[channel]",
            "            if mode == \"CMYK\":",
            "                layer += \";I\"",
            "            tile.append((\"packbits\", bbox, offset, layer))",
            "            for y in range(ysize):",
            "                offset = offset + i16(bytecount, i)",
            "                i += 2",
            "",
            "    file.seek(offset)",
            "",
            "    if offset & 1:",
            "        read(1)  # padding",
            "",
            "    return tile",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# registry",
            "",
            "",
            "Image.register_open(PsdImageFile.format, PsdImageFile, _accept)",
            "",
            "Image.register_extension(PsdImageFile.format, \".psd\")",
            "",
            "Image.register_mime(PsdImageFile.format, \"image/vnd.adobe.photoshop\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library",
            "# $Id$",
            "#",
            "# Adobe PSD 2.5/3.0 file handling",
            "#",
            "# History:",
            "# 1995-09-01 fl   Created",
            "# 1997-01-03 fl   Read most PSD images",
            "# 1997-01-18 fl   Fixed P and CMYK support",
            "# 2001-10-21 fl   Added seek/tell support (for layers)",
            "#",
            "# Copyright (c) 1997-2001 by Secret Labs AB.",
            "# Copyright (c) 1995-2001 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "",
            "from . import Image, ImageFile, ImagePalette",
            "from ._binary import i8",
            "from ._binary import i16be as i16",
            "from ._binary import i32be as i32",
            "",
            "MODES = {",
            "    # (photoshop mode, bits) -> (pil mode, required channels)",
            "    (0, 1): (\"1\", 1),",
            "    (0, 8): (\"L\", 1),",
            "    (1, 8): (\"L\", 1),",
            "    (2, 8): (\"P\", 1),",
            "    (3, 8): (\"RGB\", 3),",
            "    (4, 8): (\"CMYK\", 4),",
            "    (7, 8): (\"L\", 1),  # FIXME: multilayer",
            "    (8, 8): (\"L\", 1),  # duotone",
            "    (9, 8): (\"LAB\", 3),",
            "}",
            "",
            "",
            "# --------------------------------------------------------------------.",
            "# read PSD images",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == b\"8BPS\"",
            "",
            "",
            "##",
            "# Image plugin for Photoshop images.",
            "",
            "",
            "class PsdImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"PSD\"",
            "    format_description = \"Adobe Photoshop\"",
            "    _close_exclusive_fp_after_loading = False",
            "",
            "    def _open(self):",
            "",
            "        read = self.fp.read",
            "",
            "        #",
            "        # header",
            "",
            "        s = read(26)",
            "        if not _accept(s) or i16(s, 4) != 1:",
            "            raise SyntaxError(\"not a PSD file\")",
            "",
            "        psd_bits = i16(s, 22)",
            "        psd_channels = i16(s, 12)",
            "        psd_mode = i16(s, 24)",
            "",
            "        mode, channels = MODES[(psd_mode, psd_bits)]",
            "",
            "        if channels > psd_channels:",
            "            raise OSError(\"not enough channels\")",
            "",
            "        self.mode = mode",
            "        self._size = i32(s, 18), i32(s, 14)",
            "",
            "        #",
            "        # color mode data",
            "",
            "        size = i32(read(4))",
            "        if size:",
            "            data = read(size)",
            "            if mode == \"P\" and size == 768:",
            "                self.palette = ImagePalette.raw(\"RGB;L\", data)",
            "",
            "        #",
            "        # image resources",
            "",
            "        self.resources = []",
            "",
            "        size = i32(read(4))",
            "        if size:",
            "            # load resources",
            "            end = self.fp.tell() + size",
            "            while self.fp.tell() < end:",
            "                read(4)  # signature",
            "                id = i16(read(2))",
            "                name = read(i8(read(1)))",
            "                if not (len(name) & 1):",
            "                    read(1)  # padding",
            "                data = read(i32(read(4)))",
            "                if len(data) & 1:",
            "                    read(1)  # padding",
            "                self.resources.append((id, name, data))",
            "                if id == 1039:  # ICC profile",
            "                    self.info[\"icc_profile\"] = data",
            "",
            "        #",
            "        # layer and mask information",
            "",
            "        self.layers = []",
            "",
            "        size = i32(read(4))",
            "        if size:",
            "            end = self.fp.tell() + size",
            "            size = i32(read(4))",
            "            if size:",
            "                _layer_data = io.BytesIO(ImageFile._safe_read(self.fp, size))",
            "                self.layers = _layerinfo(_layer_data, size)",
            "            self.fp.seek(end)",
            "        self.n_frames = len(self.layers)",
            "        self.is_animated = self.n_frames > 1",
            "",
            "        #",
            "        # image descriptor",
            "",
            "        self.tile = _maketile(self.fp, mode, (0, 0) + self.size, channels)",
            "",
            "        # keep the file open",
            "        self.__fp = self.fp",
            "        self.frame = 1",
            "        self._min_frame = 1",
            "",
            "    def seek(self, layer):",
            "        if not self._seek_check(layer):",
            "            return",
            "",
            "        # seek to given layer (1..max)",
            "        try:",
            "            name, mode, bbox, tile = self.layers[layer - 1]",
            "            self.mode = mode",
            "            self.tile = tile",
            "            self.frame = layer",
            "            self.fp = self.__fp",
            "            return name, bbox",
            "        except IndexError as e:",
            "            raise EOFError(\"no such layer\") from e",
            "",
            "    def tell(self):",
            "        # return layer number (0=image, 1..max=layers)",
            "        return self.frame",
            "",
            "    def load_prepare(self):",
            "        # create image memory if necessary",
            "        if not self.im or self.im.mode != self.mode or self.im.size != self.size:",
            "            self.im = Image.core.fill(self.mode, self.size, 0)",
            "        # create palette (optional)",
            "        if self.mode == \"P\":",
            "            Image.Image.load(self)",
            "",
            "    def _close__fp(self):",
            "        try:",
            "            if self.__fp != self.fp:",
            "                self.__fp.close()",
            "        except AttributeError:",
            "            pass",
            "        finally:",
            "            self.__fp = None",
            "",
            "def _layerinfo(fp, ct_bytes):",
            "    # read layerinfo block",
            "    layers = []",
            "",
            "    def read(size):",
            "        return ImageFile._safe_read(fp, size)",
            "",
            "    ct = i16(read(2))",
            "",
            "    # sanity check",
            "    if ct_bytes < (abs(ct) * 20):",
            "        raise SyntaxError(\"Layer block too short for number of layers requested\")",
            "",
            "    for i in range(abs(ct)):",
            "",
            "        # bounding box",
            "        y0 = i32(read(4))",
            "        x0 = i32(read(4))",
            "        y1 = i32(read(4))",
            "        x1 = i32(read(4))",
            "",
            "        # image info",
            "        info = []",
            "        mode = []",
            "        ct_types = i16(read(2))",
            "        types = list(range(ct_types))",
            "        if len(types) > 4:",
            "            continue",
            "",
            "        for i in types:",
            "            type = i16(read(2))",
            "",
            "            if type == 65535:",
            "                m = \"A\"",
            "            else:",
            "                m = \"RGBA\"[type]",
            "",
            "            mode.append(m)",
            "            size = i32(read(4))",
            "            info.append((m, size))",
            "",
            "        # figure out the image mode",
            "        mode.sort()",
            "        if mode == [\"R\"]:",
            "            mode = \"L\"",
            "        elif mode == [\"B\", \"G\", \"R\"]:",
            "            mode = \"RGB\"",
            "        elif mode == [\"A\", \"B\", \"G\", \"R\"]:",
            "            mode = \"RGBA\"",
            "        else:",
            "            mode = None  # unknown",
            "",
            "        # skip over blend flags and extra information",
            "        read(12)  # filler",
            "        name = \"\"",
            "        size = i32(read(4))  # length of the extra data field",
            "        combined = 0",
            "        if size:",
            "            data_end = fp.tell() + size",
            "",
            "            length = i32(read(4))",
            "            if length:",
            "                fp.seek(length - 16, io.SEEK_CUR)",
            "            combined += length + 4",
            "",
            "            length = i32(read(4))",
            "            if length:",
            "                fp.seek(length, io.SEEK_CUR)",
            "            combined += length + 4",
            "",
            "            length = i8(read(1))",
            "            if length:",
            "                # Don't know the proper encoding,",
            "                # Latin-1 should be a good guess",
            "                name = read(length).decode(\"latin-1\", \"replace\")",
            "            combined += length + 1",
            "",
            "            fp.seek(data_end)",
            "        layers.append((name, mode, (x0, y0, x1, y1)))",
            "",
            "    # get tiles",
            "    i = 0",
            "    for name, mode, bbox in layers:",
            "        tile = []",
            "        for m in mode:",
            "            t = _maketile(fp, m, bbox, 1)",
            "            if t:",
            "                tile.extend(t)",
            "        layers[i] = name, mode, bbox, tile",
            "        i += 1",
            "",
            "    return layers",
            "",
            "",
            "def _maketile(file, mode, bbox, channels):",
            "",
            "    tile = None",
            "    read = file.read",
            "",
            "    compression = i16(read(2))",
            "",
            "    xsize = bbox[2] - bbox[0]",
            "    ysize = bbox[3] - bbox[1]",
            "",
            "    offset = file.tell()",
            "",
            "    if compression == 0:",
            "        #",
            "        # raw compression",
            "        tile = []",
            "        for channel in range(channels):",
            "            layer = mode[channel]",
            "            if mode == \"CMYK\":",
            "                layer += \";I\"",
            "            tile.append((\"raw\", bbox, offset, layer))",
            "            offset = offset + xsize * ysize",
            "",
            "    elif compression == 1:",
            "        #",
            "        # packbits compression",
            "        i = 0",
            "        tile = []",
            "        bytecount = read(channels * ysize * 2)",
            "        offset = file.tell()",
            "        for channel in range(channels):",
            "            layer = mode[channel]",
            "            if mode == \"CMYK\":",
            "                layer += \";I\"",
            "            tile.append((\"packbits\", bbox, offset, layer))",
            "            for y in range(ysize):",
            "                offset = offset + i16(bytecount, i)",
            "                i += 2",
            "",
            "    file.seek(offset)",
            "",
            "    if offset & 1:",
            "        read(1)  # padding",
            "",
            "    return tile",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# registry",
            "",
            "",
            "Image.register_open(PsdImageFile.format, PsdImageFile, _accept)",
            "",
            "Image.register_extension(PsdImageFile.format, \".psd\")",
            "",
            "Image.register_mime(PsdImageFile.format, \"image/vnd.adobe.photoshop\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "122": [
                "PsdImageFile",
                "_open"
            ],
            "173": [],
            "174": [
                "_layerinfo"
            ],
            "177": [
                "_layerinfo"
            ],
            "178": [
                "_layerinfo"
            ],
            "189": [
                "_layerinfo"
            ],
            "222": [
                "_layerinfo"
            ],
            "226": [
                "_layerinfo"
            ],
            "231": [
                "_layerinfo"
            ],
            "241": [
                "_layerinfo"
            ],
            "249": [
                "_layerinfo"
            ]
        },
        "addLocation": []
    }
}