{
    "nautobot/extras/api/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "     # @extend_schema(methods=[\"get\"], responses={200: member_response})"
            },
            "1": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "     @action(detail=True, methods=[\"get\"])"
            },
            "2": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "     def members(self, request, pk, *args, **kwargs):"
            },
            "3": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"List member objects of the same type as the `content_type` for this dynamic group.\"\"\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        \"\"\"List the member objects of this dynamic group.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         instance = get_object_or_404(self.queryset, pk=pk)"
            },
            "6": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 335,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         # Retrieve the serializer for the content_type and paginate the results"
            },
            "8": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         member_model_class = instance.content_type.model_class()"
            },
            "9": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "         member_serializer_class = get_serializer_for_model(member_model_class)"
            },
            "10": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        members = self.paginate_queryset(instance.members)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+        members = self.paginate_queryset(instance.members.restrict(request.user, \"view\"))"
            },
            "12": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "         member_serializer = member_serializer_class(members, many=True, context={\"request\": request})"
            },
            "13": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "         return self.get_paginated_response(member_serializer.data)"
            },
            "14": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 342,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from datetime import timedelta",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.forms import ValidationError as FormsValidationError",
            "from django.http import Http404",
            "from django.shortcuts import get_object_or_404",
            "from django.utils import timezone",
            "from drf_spectacular.types import OpenApiTypes",
            "from drf_spectacular.utils import extend_schema, extend_schema_view, OpenApiParameter",
            "from graphene_django.views import GraphQLView",
            "from graphql import GraphQLError",
            "from rest_framework import status",
            "from rest_framework.decorators import action",
            "from rest_framework.exceptions import MethodNotAllowed, PermissionDenied, ValidationError",
            "from rest_framework.parsers import JSONParser, MultiPartParser",
            "from rest_framework.permissions import IsAuthenticated",
            "from rest_framework.response import Response",
            "from rest_framework import mixins, viewsets",
            "",
            "from nautobot.core.api.authentication import TokenPermissions",
            "from nautobot.core.api.filter_backends import NautobotFilterBackend",
            "from nautobot.core.api.metadata import ContentTypeMetadata, StatusFieldMetadata",
            "from nautobot.core.api.views import (",
            "    BulkDestroyModelMixin,",
            "    BulkUpdateModelMixin,",
            "    ModelViewSet,",
            "    ReadOnlyModelViewSet,",
            ")",
            "from nautobot.core.graphql import execute_saved_query",
            "from nautobot.extras import filters",
            "from nautobot.extras.choices import JobExecutionType, JobResultStatusChoices",
            "from nautobot.extras.datasources import enqueue_pull_git_repository_and_refresh_data",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    CustomLink,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Webhook,",
            ")",
            "from nautobot.extras.models import CustomField, CustomFieldChoice",
            "from nautobot.extras.jobs import run_job",
            "from nautobot.extras.secrets.exceptions import SecretError",
            "from nautobot.extras.utils import get_job_content_type, get_worker_count",
            "from nautobot.utilities.exceptions import CeleryWorkerNotRunningException",
            "from nautobot.utilities.api import get_serializer_for_model",
            "from nautobot.utilities.utils import (",
            "    copy_safe_request,",
            "    count_related,",
            "    SerializerForAPIVersions,",
            "    versioned_serializer_selector,",
            ")",
            "from . import nested_serializers, serializers",
            "",
            "",
            "class NotesViewSetMixin:",
            "    @extend_schema(methods=[\"get\"], filters=False, responses={200: serializers.NoteSerializer(many=True)})",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.NoteInputSerializer,",
            "        responses={201: serializers.NoteSerializer(many=False)},",
            "    )",
            "    @action(detail=True, url_path=\"notes\", methods=[\"get\", \"post\"])",
            "    def notes(self, request, pk=None):",
            "        \"\"\"",
            "        API methods for returning or creating notes on an object.",
            "        \"\"\"",
            "        obj = get_object_or_404(self.queryset, pk=pk)",
            "        if request.method == \"POST\":",
            "            content_type = ContentType.objects.get_for_model(obj)",
            "            data = request.data",
            "            data[\"assigned_object_id\"] = obj.pk",
            "            data[\"assigned_object_type\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            serializer = serializers.NoteSerializer(data=data, context={\"request\": request})",
            "",
            "            # Create the new Note.",
            "            serializer.is_valid(raise_exception=True)",
            "            serializer.save(user=request.user)",
            "            return Response(serializer.data, status=status.HTTP_201_CREATED)",
            "",
            "        else:",
            "            notes = self.paginate_queryset(obj.notes)",
            "            serializer = serializers.NoteSerializer(notes, many=True, context={\"request\": request})",
            "",
            "        return self.get_paginated_response(serializer.data)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = ComputedField.objects.all()",
            "    serializer_class = serializers.ComputedFieldSerializer",
            "    filterset_class = filters.ComputedFieldFilterSet",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextFilterBackend(NautobotFilterBackend):",
            "    \"\"\"",
            "    Used by views that work with config context models (device and virtual machine).",
            "",
            "    Recognizes that \"exclude\" is not a filterset parameter but rather a view parameter (see ConfigContextQuerySetMixin)",
            "    \"\"\"",
            "",
            "    def get_filterset_kwargs(self, request, queryset, view):",
            "        kwargs = super().get_filterset_kwargs(request, queryset, view)",
            "        try:",
            "            kwargs[\"data\"].pop(\"exclude\")",
            "        except KeyError:",
            "            pass",
            "        return kwargs",
            "",
            "",
            "class ConfigContextQuerySetMixin:",
            "    \"\"\"",
            "    Used by views that work with config context models (device and virtual machine).",
            "    Provides a get_queryset() method which deals with adding the config context",
            "    data annotation or not.",
            "    \"\"\"",
            "",
            "    filter_backends = [ConfigContextFilterBackend]",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Build the proper queryset based on the request context",
            "",
            "        If the `brief` query param equates to True or the `exclude` query param",
            "        includes `config_context` as a value, return the base queryset.",
            "",
            "        Else, return the queryset annotated with config context data",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        request = self.get_serializer_context()[\"request\"]",
            "        if self.brief or (request is not None and \"config_context\" in request.query_params.get(\"exclude\", [])):",
            "            return queryset",
            "        return queryset.annotate_config_context_data()",
            "",
            "",
            "class ConfigContextViewSet(ModelViewSet, NotesViewSetMixin):",
            "    queryset = ConfigContext.objects.prefetch_related(",
            "        \"regions\",",
            "        \"sites\",",
            "        \"roles\",",
            "        \"device_types\",",
            "        \"platforms\",",
            "        \"tenant_groups\",",
            "        \"tenants\",",
            "        \"device_redundancy_groups\",",
            "    )",
            "    serializer_class = serializers.ConfigContextSerializer",
            "    filterset_class = filters.ConfigContextFilterSet",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaViewSet(ModelViewSet, NotesViewSetMixin):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    serializer_class = serializers.ConfigContextSchemaSerializer",
            "    filterset_class = filters.ConfigContextSchemaFilterSet",
            "",
            "",
            "#",
            "# ContentTypes",
            "#",
            "",
            "",
            "class ContentTypeViewSet(viewsets.ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Read-only list of ContentTypes. Limit results to ContentTypes pertinent to Nautobot objects.",
            "    \"\"\"",
            "",
            "    permission_classes = [IsAuthenticated]",
            "    queryset = ContentType.objects.order_by(\"app_label\", \"model\")",
            "    serializer_class = serializers.ContentTypeSerializer",
            "    filterset_class = filters.ContentTypeFilterSet",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "@extend_schema_view(",
            "    bulk_partial_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.CustomFieldSerializerVersion12(many=True),",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12(many=True)},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    bulk_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.CustomFieldSerializerVersion12(many=True),",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12(many=True)},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    create=extend_schema(",
            "        request=serializers.CustomFieldSerializerVersion12,",
            "        responses={\"201\": serializers.CustomFieldSerializerVersion12},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    list=extend_schema(",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12(many=True)}, versions=[\"1.2\", \"1.3\"]",
            "    ),",
            "    partial_update=extend_schema(",
            "        request=serializers.CustomFieldSerializerVersion12,",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    retrieve=extend_schema(responses={\"200\": serializers.CustomFieldSerializerVersion12}, versions=[\"1.2\", \"1.3\"]),",
            "    update=extend_schema(",
            "        request=serializers.CustomFieldSerializerVersion12,",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            ")",
            "class CustomFieldViewSet(ModelViewSet, NotesViewSetMixin):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = CustomField.objects.all()",
            "    serializer_class = serializers.CustomFieldSerializer",
            "    filterset_class = filters.CustomFieldFilterSet",
            "",
            "    def get_serializer_class(self):",
            "        serializer_choices = (",
            "            SerializerForAPIVersions(versions=[\"1.2\", \"1.3\"], serializer=serializers.CustomFieldSerializerVersion12),",
            "        )",
            "        return versioned_serializer_selector(",
            "            obj=self,",
            "            serializer_choices=serializer_choices,",
            "            default_serializer=super().get_serializer_class(),",
            "        )",
            "",
            "",
            "class CustomFieldChoiceViewSet(ModelViewSet):",
            "    queryset = CustomFieldChoice.objects.all()",
            "    serializer_class = serializers.CustomFieldChoiceSerializer",
            "    filterset_class = filters.CustomFieldChoiceFilterSet",
            "",
            "",
            "class CustomFieldModelViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Include the applicable set of CustomFields in the ModelViewSet context.",
            "    \"\"\"",
            "",
            "    def get_serializer_context(self):",
            "        # Gather all custom fields for the model",
            "        content_type = ContentType.objects.get_for_model(self.queryset.model)",
            "        custom_fields = content_type.custom_fields.all()",
            "",
            "        context = super().get_serializer_context()",
            "        context.update(",
            "            {",
            "                \"custom_fields\": custom_fields,",
            "            }",
            "        )",
            "        return context",
            "",
            "",
            "class NautobotModelViewSet(CustomFieldModelViewSet, NotesViewSetMixin):",
            "    \"\"\"Base class to use for API ViewSets based on OrganizationalModel or PrimaryModel.",
            "",
            "    Can also be used for models derived from BaseModel, so long as they support Notes.",
            "    \"\"\"",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = CustomLink.objects.all()",
            "    serializer_class = serializers.CustomLinkSerializer",
            "    filterset_class = filters.CustomLinkFilterSet",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroup.objects.select_related(\"content_type\")",
            "    serializer_class = serializers.DynamicGroupSerializer",
            "    filterset_class = filters.DynamicGroupFilterSet",
            "",
            "    # FIXME(jathan): Figure out how to do dynamic `responses` serializer based on the `content_type`",
            "    # of the DynamicGroup? May not be possible or even desirable to have a \"dynamic schema\".",
            "    # @extend_schema(methods=[\"get\"], responses={200: member_response})",
            "    @action(detail=True, methods=[\"get\"])",
            "    def members(self, request, pk, *args, **kwargs):",
            "        \"\"\"List member objects of the same type as the `content_type` for this dynamic group.\"\"\"",
            "        instance = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        # Retrieve the serializer for the content_type and paginate the results",
            "        member_model_class = instance.content_type.model_class()",
            "        member_serializer_class = get_serializer_for_model(member_model_class)",
            "        members = self.paginate_queryset(instance.members)",
            "        member_serializer = member_serializer_class(members, many=True, context={\"request\": request})",
            "        return self.get_paginated_response(member_serializer.data)",
            "",
            "",
            "class DynamicGroupMembershipViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroupMembership.objects.select_related(\"group\", \"parent_group\")",
            "    serializer_class = serializers.DynamicGroupMembershipSerializer",
            "    filterset_class = filters.DynamicGroupMembershipFilterSet",
            "",
            "",
            "#",
            "# Export templates",
            "#",
            "",
            "",
            "class ExportTemplateViewSet(ModelViewSet, NotesViewSetMixin):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = ExportTemplate.objects.all()",
            "    serializer_class = serializers.ExportTemplateSerializer",
            "    filterset_class = filters.ExportTemplateFilterSet",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage the use of Git repositories as external data sources.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    serializer_class = serializers.GitRepositorySerializer",
            "    filterset_class = filters.GitRepositoryFilterSet",
            "",
            "    @extend_schema(methods=[\"post\"], request=serializers.GitRepositorySerializer)",
            "    @action(detail=True, methods=[\"post\"])",
            "    def sync(self, request, pk):",
            "        \"\"\"",
            "        Enqueue pull git repository and refresh data.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "            raise PermissionDenied(\"This user does not have permission to make changes to Git repositories.\")",
            "",
            "        if not get_worker_count():",
            "            raise CeleryWorkerNotRunningException()",
            "",
            "        repository = get_object_or_404(GitRepository, id=pk)",
            "        enqueue_pull_git_repository_and_refresh_data(repository, request)",
            "        return Response({\"message\": f\"Repository {repository} sync job added to queue.\"})",
            "",
            "",
            "#",
            "# GraphQL Queries",
            "#",
            "",
            "",
            "class GraphQLQueryViewSet(ModelViewSet, NotesViewSetMixin):",
            "    queryset = GraphQLQuery.objects.all()",
            "    serializer_class = serializers.GraphQLQuerySerializer",
            "    filterset_class = filters.GraphQLQueryFilterSet",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.GraphQLQueryInputSerializer,",
            "        responses={\"200\": serializers.GraphQLQueryOutputSerializer},",
            "    )",
            "    @action(detail=True, methods=[\"post\"])",
            "    def run(self, request, pk):",
            "        try:",
            "            query = get_object_or_404(self.queryset, pk=pk)",
            "            result = execute_saved_query(query.slug, variables=request.data.get(\"variables\"), request=request).to_dict()",
            "            return Response(result)",
            "        except GraphQLError as error:",
            "            return Response(",
            "                {\"errors\": [GraphQLView.format_error(error)]},",
            "                status=status.HTTP_400_BAD_REQUEST,",
            "            )",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentViewSet(ModelViewSet):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = ImageAttachment.objects.all()",
            "    serializer_class = serializers.ImageAttachmentSerializer",
            "    filterset_class = filters.ImageAttachmentFilterSet",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "def _create_schedule(serializer, data, commit, job, job_model, request, celery_kwargs=dict, task_queue=None):",
            "    \"\"\"",
            "    This is an internal function to create a scheduled job from API data.",
            "    It has to handle both once-offs (i.e. of type TYPE_FUTURE) and interval",
            "    jobs.",
            "    \"\"\"",
            "    job_kwargs = {",
            "        \"data\": data,",
            "        \"request\": copy_safe_request(request),",
            "        \"user\": request.user.pk,",
            "        \"commit\": commit,",
            "        \"name\": job.class_path,",
            "        \"celery_kwargs\": celery_kwargs,",
            "        \"task_queue\": task_queue,",
            "    }",
            "    type_ = serializer[\"interval\"]",
            "    if type_ == JobExecutionType.TYPE_IMMEDIATELY:",
            "        time = timezone.now()",
            "        name = serializer.get(\"name\") or f\"{job.name} - {time}\"",
            "    elif type_ == JobExecutionType.TYPE_CUSTOM:",
            "        time = serializer.get(\"start_time\")  # doing .get(\"key\", \"default\") returns None instead of \"default\"",
            "        if time is None:",
            "            # \"start_time\" is checked against models.ScheduledJob.earliest_possible_time()",
            "            # which returns timezone.now() + timedelta(seconds=15)",
            "            time = timezone.now() + timedelta(seconds=20)",
            "        name = serializer[\"name\"]",
            "    else:",
            "        time = serializer[\"start_time\"]",
            "        name = serializer[\"name\"]",
            "    crontab = serializer.get(\"crontab\", \"\")",
            "",
            "    # 2.0 TODO: To revisit this as part of a larger Jobs cleanup in 2.0.",
            "    #",
            "    # We pass in job_class and job_model here partly for forward/backward compatibility logic, and",
            "    # part fallback safety. It's mildly useful to store both the class_path string and the JobModel",
            "    # FK on the ScheduledJob, as in the case where the JobModel gets deleted (and the FK becomes",
            "    # null) you still have a bit of context on the ScheduledJob as to what it was originally",
            "    # scheduled for.",
            "    scheduled_job = ScheduledJob(",
            "        name=name,",
            "        task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "        job_class=job.class_path,",
            "        job_model=job_model,",
            "        start_time=time,",
            "        description=f\"Nautobot job {name} scheduled by {request.user} on {time}\",",
            "        kwargs=job_kwargs,",
            "        interval=type_,",
            "        one_off=(type_ == JobExecutionType.TYPE_FUTURE),",
            "        user=request.user,",
            "        approval_required=job_model.approval_required,",
            "        crontab=crontab,",
            "        queue=task_queue,",
            "    )",
            "    scheduled_job.save()",
            "    return scheduled_job",
            "",
            "",
            "def _run_job(request, job_model, legacy_response=False):",
            "    \"\"\"An internal function providing logic shared between JobModelViewSet.run() and JobViewSet.run().\"\"\"",
            "    if not request.user.has_perm(\"extras.run_job\"):",
            "        raise PermissionDenied(\"This user does not have permission to run jobs.\")",
            "    if not job_model.enabled:",
            "        raise PermissionDenied(\"This job is not enabled to be run.\")",
            "    if not job_model.installed:",
            "        raise MethodNotAllowed(request.method, detail=\"This job is not presently installed and cannot be run\")",
            "    if job_model.has_sensitive_variables:",
            "        if request.data.get(\"schedule\") and request.data[\"schedule\"][\"interval\"] != JobExecutionType.TYPE_IMMEDIATELY:",
            "            raise ValidationError(",
            "                {\"schedule\": {\"interval\": [\"Unable to schedule job: Job may have sensitive input variables\"]}}",
            "            )",
            "        if job_model.approval_required:",
            "            raise ValidationError(",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\"",
            "            )",
            "",
            "    job_class = job_model.job_class",
            "    if job_class is None:",
            "        raise MethodNotAllowed(request.method, detail=\"This job's source code could not be located and cannot be run\")",
            "    job = job_class()",
            "",
            "    valid_queues = job_model.task_queues if job_model.task_queues else [settings.CELERY_TASK_DEFAULT_QUEUE]",
            "    # Get a default queue from either the job model's specified task queue or system default to fall back on if request doesn't provide one",
            "    default_valid_queue = valid_queues[0]",
            "",
            "    # We need to call request.data for both cases as this is what pulls and caches the request data",
            "    data = request.data",
            "    files = None",
            "    schedule_data = None",
            "",
            "    # We must extract from the request:",
            "    # - Job Form data (for submission to the job itself)",
            "    # - Schedule data",
            "    # - Commit flag state",
            "    # - Desired task queue",
            "    # Depending on request content type (largely for backwards compatibility) the keys at which these are found are different",
            "    if \"multipart/form-data\" in request.content_type:",
            "        data = request._data.dict()  # .data will return data and files, we just want the data",
            "        files = request.FILES",
            "",
            "        # JobMultiPartInputSerializer is a \"flattened\" version of JobInputSerializer",
            "        input_serializer = serializers.JobMultiPartInputSerializer(data=data, context={\"request\": request})",
            "        input_serializer.is_valid(raise_exception=True)",
            "",
            "        commit = input_serializer.validated_data.get(\"_commit\", None)",
            "        task_queue = input_serializer.validated_data.get(\"_task_queue\", default_valid_queue)",
            "",
            "        # JobMultiPartInputSerializer only has keys for executing job (commit, task_queue, etc),",
            "        # everything else is a candidate for the job form's data.",
            "        # job_class.validate_data will throw an error for any unexpected key/value pairs.",
            "        non_job_keys = input_serializer.validated_data.keys()",
            "        for non_job_key in non_job_keys:",
            "            data.pop(non_job_key, None)",
            "",
            "        # List of keys in serializer that are effectively exploded versions of the schedule dictionary from JobInputSerializer",
            "        schedule_keys = (\"_schedule_name\", \"_schedule_start_time\", \"_schedule_interval\", \"_schedule_crontab\")",
            "",
            "        # Assign the key from the validated_data output to dictionary without prefixed \"_schedule_\"",
            "        # For all the keys that are schedule keys",
            "        # Assign only if the key is in the output since we don't want None's if not provided",
            "        if any(schedule_key in non_job_keys for schedule_key in schedule_keys):",
            "            schedule_data = {",
            "                k.replace(\"_schedule_\", \"\"): input_serializer.validated_data[k]",
            "                for k in schedule_keys",
            "                if k in input_serializer.validated_data",
            "            }",
            "",
            "    else:",
            "        input_serializer = serializers.JobInputSerializer(data=data, context={\"request\": request})",
            "        input_serializer.is_valid(raise_exception=True)",
            "",
            "        data = input_serializer.validated_data.get(\"data\", {})",
            "        commit = input_serializer.validated_data.get(\"commit\", None)",
            "        task_queue = input_serializer.validated_data.get(\"task_queue\", default_valid_queue)",
            "        schedule_data = input_serializer.validated_data.get(\"schedule\", None)",
            "",
            "    if commit is None:",
            "        commit = job_model.commit_default",
            "",
            "    if task_queue not in valid_queues:",
            "        raise ValidationError({\"task_queue\": [f'\"{task_queue}\" is not a valid choice.']})",
            "",
            "    cleaned_data = None",
            "    try:",
            "        cleaned_data = job.validate_data(data, files=files)",
            "        cleaned_data.pop(",
            "            \"_commit\", None",
            "        )  # We don't get commit from the form, instead it's part of the serializer's validated data",
            "",
            "    except FormsValidationError as e:",
            "        # message_dict can only be accessed if ValidationError got a dict",
            "        # in the constructor (saved as error_dict). Otherwise we get a list",
            "        # of errors under messages",
            "        return Response({\"errors\": e.message_dict if hasattr(e, \"error_dict\") else e.messages}, status=400)",
            "",
            "    if not get_worker_count(queue=task_queue):",
            "        raise CeleryWorkerNotRunningException(queue=task_queue)",
            "",
            "    job_content_type = get_job_content_type()",
            "",
            "    # Default to a null JobResult.",
            "    job_result = None",
            "",
            "    # Assert that a job with `approval_required=True` has a schedule that enforces approval and",
            "    # executes immediately.",
            "    if schedule_data is None and job_model.approval_required:",
            "        schedule_data = {\"interval\": JobExecutionType.TYPE_IMMEDIATELY}",
            "",
            "    # Skip creating a ScheduledJob when job can be executed immediately",
            "    elif (",
            "        schedule_data",
            "        and schedule_data[\"interval\"] == JobExecutionType.TYPE_IMMEDIATELY",
            "        and not job_model.approval_required",
            "    ):",
            "        schedule_data = None",
            "",
            "    # Try to create a ScheduledJob, or...",
            "    if schedule_data:",
            "        schedule = _create_schedule(",
            "            schedule_data,",
            "            job_class.serialize_data(cleaned_data),",
            "            commit,",
            "            job,",
            "            job_model,",
            "            request,",
            "            celery_kwargs={\"queue\": task_queue},",
            "            task_queue=input_serializer.validated_data.get(\"task_queue\", None),",
            "        )",
            "    else:",
            "        schedule = None",
            "",
            "    # ... If we can't create one, create a JobResult instead.",
            "    if schedule is None:",
            "        job_result = JobResult.enqueue_job(",
            "            run_job,",
            "            job.class_path,",
            "            job_content_type,",
            "            request.user,",
            "            celery_kwargs={\"queue\": task_queue},",
            "            data=job_class.serialize_data(cleaned_data),",
            "            request=copy_safe_request(request),",
            "            commit=commit,",
            "            task_queue=input_serializer.validated_data.get(\"task_queue\", None),",
            "        )",
            "        job.result = job_result",
            "",
            "    if legacy_response:",
            "        # Old-style JobViewSet response - serialize the Job class in the response for some reason?",
            "        serializer = serializers.JobClassDetailSerializer(job, context={\"request\": request})",
            "        return Response(serializer.data)",
            "    else:",
            "        # New-style JobModelViewSet response - serialize the schedule or job_result as appropriate",
            "        data = {\"schedule\": None, \"job_result\": None}",
            "        if schedule:",
            "            data[\"schedule\"] = nested_serializers.NestedScheduledJobSerializer(",
            "                schedule, context={\"request\": request}",
            "            ).data",
            "        if job_result:",
            "            data[\"job_result\"] = nested_serializers.NestedJobResultSerializer(",
            "                job_result, context={\"request\": request}",
            "            ).data",
            "        return Response(data, status=status.HTTP_201_CREATED)",
            "",
            "",
            "class JobViewSet(",
            "    # DRF mixins:",
            "    # note no CreateModelMixin",
            "    mixins.UpdateModelMixin,",
            "    mixins.DestroyModelMixin,",
            "    # Nautobot mixins:",
            "    BulkUpdateModelMixin,",
            "    BulkDestroyModelMixin,",
            "    # Base class",
            "    ReadOnlyModelViewSet,",
            "    NotesViewSetMixin,",
            "):",
            "    queryset = Job.objects.all()",
            "    serializer_class = serializers.JobSerializer",
            "    filterset_class = filters.JobFilterSet",
            "",
            "    # Custom schema for the deprecated 1.2 API version of this endpoint.",
            "    # For 1.3 and later, the standard autogenerated API schema is correct and does not need to be customized here.",
            "    @extend_schema(",
            "        filters=False,",
            "        responses={\"200\": serializers.JobClassSerializer(many=True)},",
            "        versions=[\"1.2\"],",
            "    )",
            "    def list(self, request, *args, **kwargs):",
            "        \"\"\"List all known Jobs.\"\"\"",
            "        if request.major_version > 1 or request.minor_version >= 3:",
            "            # API version 1.3 or later - standard model-based response",
            "            return super().list(request, *args, **kwargs)",
            "",
            "        # API version 1.2 or earlier - serialize JobClass records",
            "        if not request.user.has_perm(\"extras.view_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to view jobs.\")",
            "        job_content_type = get_job_content_type()",
            "        results = {",
            "            r.name: r",
            "            for r in JobResult.objects.filter(",
            "                obj_type=job_content_type,",
            "                status__in=JobResultStatusChoices.TERMINAL_STATE_CHOICES,",
            "            )",
            "            .defer(\"data\")",
            "            .order_by(\"created\")",
            "        }",
            "",
            "        job_models = Job.objects.restrict(request.user, \"view\")",
            "        jobs_list = [",
            "            job_model.job_class()  # TODO: why do we need to instantiate the job_class?",
            "            for job_model in job_models",
            "            if job_model.installed and job_model.job_class is not None",
            "        ]",
            "        for job_instance in jobs_list:",
            "            job_instance.result = results.get(job_instance.class_path, None)",
            "",
            "        serializer = serializers.JobClassSerializer(jobs_list, many=True, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    @extend_schema(",
            "        deprecated=True,",
            "        operation_id=\"extras_jobs_read_deprecated\",",
            "        responses={\"200\": serializers.JobClassDetailSerializer()},",
            "    )",
            "    @action(",
            "        detail=False,  # a /jobs/... URL, not a /jobs/<pk>/... URL",
            "        methods=[\"get\"],",
            "        url_path=\"(?P<class_path>[^/]+/[^/]+/[^/]+)\",  # /api/extras/jobs/<class_path>/",
            "        url_name=\"detail\",",
            "    )",
            "    def retrieve_deprecated(self, request, class_path):",
            "        \"\"\"",
            "        Get details of a Job as identified by its class-path.",
            "",
            "        This API endpoint is deprecated; it is recommended to use the extras_jobs_read endpoint instead.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.view_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to view jobs.\")",
            "        try:",
            "            job_model = Job.objects.restrict(request.user, \"view\").get_for_class_path(class_path)",
            "        except Job.DoesNotExist:",
            "            raise Http404",
            "        if not job_model.installed or job_model.job_class is None:",
            "            raise Http404",
            "        job_content_type = get_job_content_type()",
            "        job = job_model.job_class()  # TODO: why do we need to instantiate the job_class?",
            "        job.result = JobResult.objects.filter(",
            "            obj_type=job_content_type,",
            "            name=job.class_path,",
            "            status__in=JobResultStatusChoices.TERMINAL_STATE_CHOICES,",
            "        ).first()",
            "",
            "        serializer = serializers.JobClassDetailSerializer(job, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    @extend_schema(responses={\"200\": serializers.JobVariableSerializer(many=True)})",
            "    @action(detail=True, filterset_class=None)",
            "    def variables(self, request, pk):",
            "        \"\"\"Get details of the input variables that may/must be specified to run a particular Job.\"\"\"",
            "        job_model = self.get_object()",
            "        job_class = job_model.job_class",
            "        if job_class is None:",
            "            raise Http404",
            "        variables_dict = job_class._get_vars()",
            "        data = []",
            "        for name, instance in variables_dict.items():",
            "            entry = {\"name\": name, \"type\": instance.__class__.__name__}",
            "            for key in [",
            "                \"label\",",
            "                \"help_text\",",
            "                \"required\",",
            "                \"min_length\",",
            "                \"max_length\",",
            "                \"min_value\",",
            "                \"max_value\",",
            "                \"choices\",",
            "            ]:",
            "                if key in instance.field_attrs:",
            "                    entry[key] = instance.field_attrs[key]",
            "            if \"initial\" in instance.field_attrs:",
            "                entry[\"default\"] = instance.field_attrs[\"initial\"]",
            "            if \"queryset\" in instance.field_attrs:",
            "                content_type = ContentType.objects.get_for_model(instance.field_attrs[\"queryset\"].model)",
            "                entry[\"model\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            data.append(entry)",
            "        return Response(data)",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special \"run_job\" permission as queryset filter on the /run/ endpoint, otherwise as ModelViewSetMixin.",
            "        \"\"\"",
            "        if request.user.is_authenticated and self.action == \"run\":",
            "            self.queryset = self.queryset.restrict(request.user, \"run\")",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class JobRunTokenPermissions(TokenPermissions):",
            "        \"\"\"As nautobot.core.api.authentication.TokenPermissions, but enforcing run_job instead of add_job.\"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.run_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request={",
            "            \"application/json\": serializers.JobInputSerializer,",
            "            \"multipart/form-data\": serializers.JobMultiPartInputSerializer,",
            "        },",
            "        responses={\"201\": serializers.JobRunResponseSerializer},",
            "    )",
            "    @action(",
            "        detail=True,",
            "        methods=[\"post\"],",
            "        permission_classes=[JobRunTokenPermissions],",
            "        parser_classes=[JSONParser, MultiPartParser],",
            "    )",
            "    def run(self, request, *args, pk, **kwargs):",
            "        \"\"\"Run the specified Job.\"\"\"",
            "        job_model = self.get_object()",
            "        return _run_job(request, job_model)",
            "",
            "    @extend_schema(",
            "        deprecated=True,",
            "        methods=[\"post\"],",
            "        request=serializers.JobInputSerializer,",
            "        responses={\"200\": serializers.JobClassDetailSerializer()},",
            "        operation_id=\"extras_jobs_run_deprecated\",",
            "    )",
            "    @action(",
            "        detail=False,  # a /jobs/... URL, not a /jobs/<pk>/... URL",
            "        methods=[\"post\"],",
            "        permission_classes=[JobRunTokenPermissions],",
            "        url_path=\"(?P<class_path>[^/]+/[^/]+/[^/]+)/run\",  # /api/extras/jobs/<class_path>/run/",
            "        url_name=\"run\",",
            "        parser_classes=[JSONParser, MultiPartParser],",
            "    )",
            "    def run_deprecated(self, request, class_path):",
            "        \"\"\"",
            "        Run a Job as identified by its class-path.",
            "",
            "        This API endpoint is deprecated; it is recommended to use the extras_jobs_run endpoint instead.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.run_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to run jobs.\")",
            "        try:",
            "            job_model = Job.objects.restrict(request.user, \"run\").get_for_class_path(class_path)",
            "        except Job.DoesNotExist:",
            "            raise Http404",
            "        return _run_job(request, job_model, legacy_response=True)",
            "",
            "",
            "#",
            "# Job Hooks",
            "#",
            "",
            "",
            "class JobHooksViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobHook.objects.all()",
            "    serializer_class = serializers.JobHookSerializer",
            "    filterset_class = filters.JobHookFilterSet",
            "",
            "",
            "#",
            "# Job Results",
            "#",
            "",
            "",
            "class JobLogEntryViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of job log entries.",
            "    \"\"\"",
            "",
            "    queryset = JobLogEntry.objects.select_related(\"job_result\")",
            "    serializer_class = serializers.JobLogEntrySerializer",
            "    filterset_class = filters.JobLogEntryFilterSet",
            "",
            "",
            "class JobResultViewSet(",
            "    # DRF mixins:",
            "    # note no CreateModelMixin or UpdateModelMixin",
            "    mixins.DestroyModelMixin,",
            "    # Nautobot mixins:",
            "    BulkDestroyModelMixin,",
            "    # Base class",
            "    ReadOnlyModelViewSet,",
            "):",
            "    \"\"\"",
            "    Retrieve a list of job results",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.select_related(\"job_model\", \"obj_type\", \"user\")",
            "    serializer_class = serializers.JobResultSerializer",
            "    filterset_class = filters.JobResultFilterSet",
            "",
            "    @action(detail=True)",
            "    def logs(self, request, pk=None):",
            "        job_result = self.get_object()",
            "        logs = job_result.logs.all()",
            "        serializer = nested_serializers.NestedJobLogEntrySerializer(logs, context={\"request\": request}, many=True)",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    filterset_class = filters.JobButtonFilterSet",
            "",
            "",
            "#",
            "# Scheduled Jobs",
            "#",
            "",
            "",
            "class ScheduledJobViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of scheduled jobs",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.select_related(\"user\")",
            "    serializer_class = serializers.ScheduledJobSerializer",
            "    filterset_class = filters.ScheduledJobFilterSet",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special permissions as queryset filter on the /approve/, /deny/, and /dry-run/ endpoints.",
            "",
            "        Otherwise, same as ModelViewSetMixin.",
            "        \"\"\"",
            "        action_to_method = {\"approve\": \"change\", \"deny\": \"delete\", \"dry-run\": \"view\"}",
            "        if request.user.is_authenticated and self.action in action_to_method:",
            "            self.queryset = self.queryset.restrict(request.user, action_to_method[self.action])",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class ScheduledJobChangePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing change_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.change_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.ScheduledJobSerializer},",
            "        request=None,",
            "        parameters=[",
            "            OpenApiParameter(",
            "                \"force\",",
            "                location=OpenApiParameter.QUERY,",
            "                description=\"force execution even if start time has passed\",",
            "                type=OpenApiTypes.BOOL,",
            "            )",
            "        ],",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobChangePermissions])",
            "    def approve(self, request, pk):",
            "        scheduled_job = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to approve this request.\")",
            "",
            "        # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        if request.user == scheduled_job.user:",
            "            # The requestor *cannot* approve their own job",
            "            return Response(\"You cannot approve your own job request!\", status=403)",
            "",
            "        if (",
            "            scheduled_job.one_off",
            "            and scheduled_job.start_time < timezone.now()",
            "            and not request.query_params.get(\"force\")",
            "        ):",
            "            return Response(",
            "                \"The job's start time is in the past. If you want to force a run anyway, add the `force` query parameter.\",",
            "                status=400,",
            "            )",
            "",
            "        scheduled_job.approved_by_user = request.user",
            "        scheduled_job.approved_at = timezone.now()",
            "        scheduled_job.save()",
            "        serializer = serializers.ScheduledJobSerializer(scheduled_job, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    class ScheduledJobDeletePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing delete_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.delete_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=None,",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobDeletePermissions])",
            "    def deny(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to deny this request.\")",
            "",
            "        scheduled_job.delete()",
            "",
            "        return Response(None)",
            "",
            "    class ScheduledJobViewPermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing view_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.view_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.JobResultSerializer},",
            "        request=None,",
            "    )",
            "    @action(detail=True, url_path=\"dry-run\", methods=[\"post\"], permission_classes=[ScheduledJobViewPermissions])",
            "    def dry_run(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "        job_model = scheduled_job.job_model",
            "        if job_model is None or not job_model.runnable:",
            "            raise MethodNotAllowed(\"This job cannot be dry-run at this time.\")",
            "        if not Job.objects.check_perms(request.user, instance=job_model, action=\"run\"):",
            "            raise PermissionDenied(\"You do not have permission to run this job.\")",
            "",
            "        # Immediately enqueue the job with commit=False",
            "        job_content_type = get_job_content_type()",
            "        job_result = JobResult.enqueue_job(",
            "            run_job,",
            "            job_model.class_path,",
            "            job_content_type,",
            "            request.user,",
            "            celery_kwargs=scheduled_job.kwargs.get(\"celery_kwargs\", {}),",
            "            data=scheduled_job.kwargs.get(\"data\", {}),",
            "            request=copy_safe_request(request),",
            "            commit=False,  # force a dry-run",
            "            task_queue=scheduled_job.kwargs.get(\"task_queue\", None),",
            "        )",
            "        serializer = serializers.JobResultSerializer(job_result, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteViewSet(ModelViewSet):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = Note.objects.select_related(\"user\")",
            "    serializer_class = serializers.NoteSerializer",
            "    filterset_class = filters.NoteFilterSet",
            "",
            "    # Assign user from request",
            "    def perform_create(self, serializer):",
            "        serializer.save(user=self.request.user)",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of recent changes.",
            "    \"\"\"",
            "",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = ObjectChange.objects.select_related(\"user\")",
            "    serializer_class = serializers.ObjectChangeSerializer",
            "    filterset_class = filters.ObjectChangeFilterSet",
            "",
            "",
            "#",
            "#  Relationships",
            "#",
            "",
            "",
            "class RelationshipViewSet(ModelViewSet, NotesViewSetMixin):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = Relationship.objects.all()",
            "    serializer_class = serializers.RelationshipSerializer",
            "    filterset_class = filters.RelationshipFilterSet",
            "",
            "",
            "class RelationshipAssociationViewSet(ModelViewSet):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = RelationshipAssociation.objects.all()",
            "    serializer_class = serializers.RelationshipAssociationSerializer",
            "    filterset_class = filters.RelationshipAssociationFilterSet",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretsViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Secret.objects.all()",
            "    serializer_class = serializers.SecretSerializer",
            "    filterset_class = filters.SecretFilterSet",
            "",
            "    @extend_schema(",
            "        responses={",
            "            200: {",
            "                \"type\": \"object\",",
            "                \"properties\": {",
            "                    \"result\": {\"type\": \"boolean\"},",
            "                    \"message\": {\"type\": \"string\"},",
            "                },",
            "            }",
            "        },",
            "    )",
            "    @action(methods=[\"GET\"], detail=True)",
            "    def check(self, request, pk):",
            "        \"\"\"Check that a secret's value is accessible.\"\"\"",
            "        result = False",
            "        message = \"Unknown error\"",
            "        try:",
            "            self.get_object().get_value()",
            "            result = True",
            "            message = \"Passed\"",
            "        except SecretError as e:",
            "            message = str(e)",
            "        response = {\"result\": result, \"message\": message}",
            "        return Response(response)",
            "",
            "",
            "class SecretsGroupViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroup.objects.all()",
            "    serializer_class = serializers.SecretsGroupSerializer",
            "    filterset_class = filters.SecretsGroupFilterSet",
            "",
            "",
            "class SecretsGroupAssociationViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroupAssociation.objects.all()",
            "    serializer_class = serializers.SecretsGroupAssociationSerializer",
            "    filterset_class = filters.SecretsGroupAssociationFilterSet",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    View and manage custom status choices for objects with a `status` field.",
            "    \"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    serializer_class = serializers.StatusSerializer",
            "    filterset_class = filters.StatusFilterSet",
            "",
            "",
            "class StatusViewSetMixin(ModelViewSet):",
            "    \"\"\"",
            "    Mixin to set `metadata_class` to implement `status` field in model viewset metadata.",
            "    \"\"\"",
            "",
            "    metadata_class = StatusFieldMetadata",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "@extend_schema_view(",
            "    bulk_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.TagSerializer(many=True),",
            "        responses={\"200\": serializers.TagSerializer(many=True)},",
            "        versions=[\"1.2\"],",
            "    ),",
            "    bulk_partial_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.TagSerializer(many=True),",
            "        responses={\"200\": serializers.TagSerializer(many=True)},",
            "        versions=[\"1.2\"],",
            "    ),",
            "    create=extend_schema(",
            "        request=serializers.TagSerializer, responses={\"201\": serializers.TagSerializer}, versions=[\"1.2\"]",
            "    ),",
            "    partial_update=extend_schema(",
            "        request=serializers.TagSerializer, responses={\"200\": serializers.TagSerializer}, versions=[\"1.2\"]",
            "    ),",
            "    update=extend_schema(",
            "        request=serializers.TagSerializer, responses={\"200\": serializers.TagSerializer}, versions=[\"1.2\"]",
            "    ),",
            "    list=extend_schema(responses={\"200\": serializers.TagSerializer(many=True)}, versions=[\"1.2\"]),",
            "    retrieve=extend_schema(responses={\"200\": serializers.TagSerializer}, versions=[\"1.2\"]),",
            ")",
            "class TagViewSet(NautobotModelViewSet):",
            "    queryset = Tag.objects.annotate(tagged_items=count_related(TaggedItem, \"tag\"))",
            "    serializer_class = serializers.TagSerializerVersion13",
            "    filterset_class = filters.TagFilterSet",
            "",
            "    def get_serializer_class(self):",
            "        serializer_choices = (SerializerForAPIVersions(versions=[\"1.2\"], serializer=serializers.TagSerializer),)",
            "        return versioned_serializer_selector(",
            "            obj=self,",
            "            serializer_choices=serializer_choices,",
            "            default_serializer=super().get_serializer_class(),",
            "        )",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhooksViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Webhook.objects.all()",
            "    serializer_class = serializers.WebhookSerializer",
            "    filterset_class = filters.WebhookFilterSet"
        ],
        "afterPatchFile": [
            "from datetime import timedelta",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.forms import ValidationError as FormsValidationError",
            "from django.http import Http404",
            "from django.shortcuts import get_object_or_404",
            "from django.utils import timezone",
            "from drf_spectacular.types import OpenApiTypes",
            "from drf_spectacular.utils import extend_schema, extend_schema_view, OpenApiParameter",
            "from graphene_django.views import GraphQLView",
            "from graphql import GraphQLError",
            "from rest_framework import status",
            "from rest_framework.decorators import action",
            "from rest_framework.exceptions import MethodNotAllowed, PermissionDenied, ValidationError",
            "from rest_framework.parsers import JSONParser, MultiPartParser",
            "from rest_framework.permissions import IsAuthenticated",
            "from rest_framework.response import Response",
            "from rest_framework import mixins, viewsets",
            "",
            "from nautobot.core.api.authentication import TokenPermissions",
            "from nautobot.core.api.filter_backends import NautobotFilterBackend",
            "from nautobot.core.api.metadata import ContentTypeMetadata, StatusFieldMetadata",
            "from nautobot.core.api.views import (",
            "    BulkDestroyModelMixin,",
            "    BulkUpdateModelMixin,",
            "    ModelViewSet,",
            "    ReadOnlyModelViewSet,",
            ")",
            "from nautobot.core.graphql import execute_saved_query",
            "from nautobot.extras import filters",
            "from nautobot.extras.choices import JobExecutionType, JobResultStatusChoices",
            "from nautobot.extras.datasources import enqueue_pull_git_repository_and_refresh_data",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    CustomLink,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Webhook,",
            ")",
            "from nautobot.extras.models import CustomField, CustomFieldChoice",
            "from nautobot.extras.jobs import run_job",
            "from nautobot.extras.secrets.exceptions import SecretError",
            "from nautobot.extras.utils import get_job_content_type, get_worker_count",
            "from nautobot.utilities.exceptions import CeleryWorkerNotRunningException",
            "from nautobot.utilities.api import get_serializer_for_model",
            "from nautobot.utilities.utils import (",
            "    copy_safe_request,",
            "    count_related,",
            "    SerializerForAPIVersions,",
            "    versioned_serializer_selector,",
            ")",
            "from . import nested_serializers, serializers",
            "",
            "",
            "class NotesViewSetMixin:",
            "    @extend_schema(methods=[\"get\"], filters=False, responses={200: serializers.NoteSerializer(many=True)})",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.NoteInputSerializer,",
            "        responses={201: serializers.NoteSerializer(many=False)},",
            "    )",
            "    @action(detail=True, url_path=\"notes\", methods=[\"get\", \"post\"])",
            "    def notes(self, request, pk=None):",
            "        \"\"\"",
            "        API methods for returning or creating notes on an object.",
            "        \"\"\"",
            "        obj = get_object_or_404(self.queryset, pk=pk)",
            "        if request.method == \"POST\":",
            "            content_type = ContentType.objects.get_for_model(obj)",
            "            data = request.data",
            "            data[\"assigned_object_id\"] = obj.pk",
            "            data[\"assigned_object_type\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            serializer = serializers.NoteSerializer(data=data, context={\"request\": request})",
            "",
            "            # Create the new Note.",
            "            serializer.is_valid(raise_exception=True)",
            "            serializer.save(user=request.user)",
            "            return Response(serializer.data, status=status.HTTP_201_CREATED)",
            "",
            "        else:",
            "            notes = self.paginate_queryset(obj.notes)",
            "            serializer = serializers.NoteSerializer(notes, many=True, context={\"request\": request})",
            "",
            "        return self.get_paginated_response(serializer.data)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = ComputedField.objects.all()",
            "    serializer_class = serializers.ComputedFieldSerializer",
            "    filterset_class = filters.ComputedFieldFilterSet",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextFilterBackend(NautobotFilterBackend):",
            "    \"\"\"",
            "    Used by views that work with config context models (device and virtual machine).",
            "",
            "    Recognizes that \"exclude\" is not a filterset parameter but rather a view parameter (see ConfigContextQuerySetMixin)",
            "    \"\"\"",
            "",
            "    def get_filterset_kwargs(self, request, queryset, view):",
            "        kwargs = super().get_filterset_kwargs(request, queryset, view)",
            "        try:",
            "            kwargs[\"data\"].pop(\"exclude\")",
            "        except KeyError:",
            "            pass",
            "        return kwargs",
            "",
            "",
            "class ConfigContextQuerySetMixin:",
            "    \"\"\"",
            "    Used by views that work with config context models (device and virtual machine).",
            "    Provides a get_queryset() method which deals with adding the config context",
            "    data annotation or not.",
            "    \"\"\"",
            "",
            "    filter_backends = [ConfigContextFilterBackend]",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Build the proper queryset based on the request context",
            "",
            "        If the `brief` query param equates to True or the `exclude` query param",
            "        includes `config_context` as a value, return the base queryset.",
            "",
            "        Else, return the queryset annotated with config context data",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        request = self.get_serializer_context()[\"request\"]",
            "        if self.brief or (request is not None and \"config_context\" in request.query_params.get(\"exclude\", [])):",
            "            return queryset",
            "        return queryset.annotate_config_context_data()",
            "",
            "",
            "class ConfigContextViewSet(ModelViewSet, NotesViewSetMixin):",
            "    queryset = ConfigContext.objects.prefetch_related(",
            "        \"regions\",",
            "        \"sites\",",
            "        \"roles\",",
            "        \"device_types\",",
            "        \"platforms\",",
            "        \"tenant_groups\",",
            "        \"tenants\",",
            "        \"device_redundancy_groups\",",
            "    )",
            "    serializer_class = serializers.ConfigContextSerializer",
            "    filterset_class = filters.ConfigContextFilterSet",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaViewSet(ModelViewSet, NotesViewSetMixin):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    serializer_class = serializers.ConfigContextSchemaSerializer",
            "    filterset_class = filters.ConfigContextSchemaFilterSet",
            "",
            "",
            "#",
            "# ContentTypes",
            "#",
            "",
            "",
            "class ContentTypeViewSet(viewsets.ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Read-only list of ContentTypes. Limit results to ContentTypes pertinent to Nautobot objects.",
            "    \"\"\"",
            "",
            "    permission_classes = [IsAuthenticated]",
            "    queryset = ContentType.objects.order_by(\"app_label\", \"model\")",
            "    serializer_class = serializers.ContentTypeSerializer",
            "    filterset_class = filters.ContentTypeFilterSet",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "@extend_schema_view(",
            "    bulk_partial_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.CustomFieldSerializerVersion12(many=True),",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12(many=True)},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    bulk_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.CustomFieldSerializerVersion12(many=True),",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12(many=True)},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    create=extend_schema(",
            "        request=serializers.CustomFieldSerializerVersion12,",
            "        responses={\"201\": serializers.CustomFieldSerializerVersion12},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    list=extend_schema(",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12(many=True)}, versions=[\"1.2\", \"1.3\"]",
            "    ),",
            "    partial_update=extend_schema(",
            "        request=serializers.CustomFieldSerializerVersion12,",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            "    retrieve=extend_schema(responses={\"200\": serializers.CustomFieldSerializerVersion12}, versions=[\"1.2\", \"1.3\"]),",
            "    update=extend_schema(",
            "        request=serializers.CustomFieldSerializerVersion12,",
            "        responses={\"200\": serializers.CustomFieldSerializerVersion12},",
            "        versions=[\"1.2\", \"1.3\"],",
            "    ),",
            ")",
            "class CustomFieldViewSet(ModelViewSet, NotesViewSetMixin):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = CustomField.objects.all()",
            "    serializer_class = serializers.CustomFieldSerializer",
            "    filterset_class = filters.CustomFieldFilterSet",
            "",
            "    def get_serializer_class(self):",
            "        serializer_choices = (",
            "            SerializerForAPIVersions(versions=[\"1.2\", \"1.3\"], serializer=serializers.CustomFieldSerializerVersion12),",
            "        )",
            "        return versioned_serializer_selector(",
            "            obj=self,",
            "            serializer_choices=serializer_choices,",
            "            default_serializer=super().get_serializer_class(),",
            "        )",
            "",
            "",
            "class CustomFieldChoiceViewSet(ModelViewSet):",
            "    queryset = CustomFieldChoice.objects.all()",
            "    serializer_class = serializers.CustomFieldChoiceSerializer",
            "    filterset_class = filters.CustomFieldChoiceFilterSet",
            "",
            "",
            "class CustomFieldModelViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Include the applicable set of CustomFields in the ModelViewSet context.",
            "    \"\"\"",
            "",
            "    def get_serializer_context(self):",
            "        # Gather all custom fields for the model",
            "        content_type = ContentType.objects.get_for_model(self.queryset.model)",
            "        custom_fields = content_type.custom_fields.all()",
            "",
            "        context = super().get_serializer_context()",
            "        context.update(",
            "            {",
            "                \"custom_fields\": custom_fields,",
            "            }",
            "        )",
            "        return context",
            "",
            "",
            "class NautobotModelViewSet(CustomFieldModelViewSet, NotesViewSetMixin):",
            "    \"\"\"Base class to use for API ViewSets based on OrganizationalModel or PrimaryModel.",
            "",
            "    Can also be used for models derived from BaseModel, so long as they support Notes.",
            "    \"\"\"",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = CustomLink.objects.all()",
            "    serializer_class = serializers.CustomLinkSerializer",
            "    filterset_class = filters.CustomLinkFilterSet",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroup.objects.select_related(\"content_type\")",
            "    serializer_class = serializers.DynamicGroupSerializer",
            "    filterset_class = filters.DynamicGroupFilterSet",
            "",
            "    # FIXME(jathan): Figure out how to do dynamic `responses` serializer based on the `content_type`",
            "    # of the DynamicGroup? May not be possible or even desirable to have a \"dynamic schema\".",
            "    # @extend_schema(methods=[\"get\"], responses={200: member_response})",
            "    @action(detail=True, methods=[\"get\"])",
            "    def members(self, request, pk, *args, **kwargs):",
            "        \"\"\"List the member objects of this dynamic group.\"\"\"",
            "        instance = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        # Retrieve the serializer for the content_type and paginate the results",
            "        member_model_class = instance.content_type.model_class()",
            "        member_serializer_class = get_serializer_for_model(member_model_class)",
            "        members = self.paginate_queryset(instance.members.restrict(request.user, \"view\"))",
            "        member_serializer = member_serializer_class(members, many=True, context={\"request\": request})",
            "        return self.get_paginated_response(member_serializer.data)",
            "",
            "",
            "class DynamicGroupMembershipViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroupMembership.objects.select_related(\"group\", \"parent_group\")",
            "    serializer_class = serializers.DynamicGroupMembershipSerializer",
            "    filterset_class = filters.DynamicGroupMembershipFilterSet",
            "",
            "",
            "#",
            "# Export templates",
            "#",
            "",
            "",
            "class ExportTemplateViewSet(ModelViewSet, NotesViewSetMixin):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = ExportTemplate.objects.all()",
            "    serializer_class = serializers.ExportTemplateSerializer",
            "    filterset_class = filters.ExportTemplateFilterSet",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage the use of Git repositories as external data sources.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    serializer_class = serializers.GitRepositorySerializer",
            "    filterset_class = filters.GitRepositoryFilterSet",
            "",
            "    @extend_schema(methods=[\"post\"], request=serializers.GitRepositorySerializer)",
            "    @action(detail=True, methods=[\"post\"])",
            "    def sync(self, request, pk):",
            "        \"\"\"",
            "        Enqueue pull git repository and refresh data.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "            raise PermissionDenied(\"This user does not have permission to make changes to Git repositories.\")",
            "",
            "        if not get_worker_count():",
            "            raise CeleryWorkerNotRunningException()",
            "",
            "        repository = get_object_or_404(GitRepository, id=pk)",
            "        enqueue_pull_git_repository_and_refresh_data(repository, request)",
            "        return Response({\"message\": f\"Repository {repository} sync job added to queue.\"})",
            "",
            "",
            "#",
            "# GraphQL Queries",
            "#",
            "",
            "",
            "class GraphQLQueryViewSet(ModelViewSet, NotesViewSetMixin):",
            "    queryset = GraphQLQuery.objects.all()",
            "    serializer_class = serializers.GraphQLQuerySerializer",
            "    filterset_class = filters.GraphQLQueryFilterSet",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.GraphQLQueryInputSerializer,",
            "        responses={\"200\": serializers.GraphQLQueryOutputSerializer},",
            "    )",
            "    @action(detail=True, methods=[\"post\"])",
            "    def run(self, request, pk):",
            "        try:",
            "            query = get_object_or_404(self.queryset, pk=pk)",
            "            result = execute_saved_query(query.slug, variables=request.data.get(\"variables\"), request=request).to_dict()",
            "            return Response(result)",
            "        except GraphQLError as error:",
            "            return Response(",
            "                {\"errors\": [GraphQLView.format_error(error)]},",
            "                status=status.HTTP_400_BAD_REQUEST,",
            "            )",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentViewSet(ModelViewSet):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = ImageAttachment.objects.all()",
            "    serializer_class = serializers.ImageAttachmentSerializer",
            "    filterset_class = filters.ImageAttachmentFilterSet",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "def _create_schedule(serializer, data, commit, job, job_model, request, celery_kwargs=dict, task_queue=None):",
            "    \"\"\"",
            "    This is an internal function to create a scheduled job from API data.",
            "    It has to handle both once-offs (i.e. of type TYPE_FUTURE) and interval",
            "    jobs.",
            "    \"\"\"",
            "    job_kwargs = {",
            "        \"data\": data,",
            "        \"request\": copy_safe_request(request),",
            "        \"user\": request.user.pk,",
            "        \"commit\": commit,",
            "        \"name\": job.class_path,",
            "        \"celery_kwargs\": celery_kwargs,",
            "        \"task_queue\": task_queue,",
            "    }",
            "    type_ = serializer[\"interval\"]",
            "    if type_ == JobExecutionType.TYPE_IMMEDIATELY:",
            "        time = timezone.now()",
            "        name = serializer.get(\"name\") or f\"{job.name} - {time}\"",
            "    elif type_ == JobExecutionType.TYPE_CUSTOM:",
            "        time = serializer.get(\"start_time\")  # doing .get(\"key\", \"default\") returns None instead of \"default\"",
            "        if time is None:",
            "            # \"start_time\" is checked against models.ScheduledJob.earliest_possible_time()",
            "            # which returns timezone.now() + timedelta(seconds=15)",
            "            time = timezone.now() + timedelta(seconds=20)",
            "        name = serializer[\"name\"]",
            "    else:",
            "        time = serializer[\"start_time\"]",
            "        name = serializer[\"name\"]",
            "    crontab = serializer.get(\"crontab\", \"\")",
            "",
            "    # 2.0 TODO: To revisit this as part of a larger Jobs cleanup in 2.0.",
            "    #",
            "    # We pass in job_class and job_model here partly for forward/backward compatibility logic, and",
            "    # part fallback safety. It's mildly useful to store both the class_path string and the JobModel",
            "    # FK on the ScheduledJob, as in the case where the JobModel gets deleted (and the FK becomes",
            "    # null) you still have a bit of context on the ScheduledJob as to what it was originally",
            "    # scheduled for.",
            "    scheduled_job = ScheduledJob(",
            "        name=name,",
            "        task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "        job_class=job.class_path,",
            "        job_model=job_model,",
            "        start_time=time,",
            "        description=f\"Nautobot job {name} scheduled by {request.user} on {time}\",",
            "        kwargs=job_kwargs,",
            "        interval=type_,",
            "        one_off=(type_ == JobExecutionType.TYPE_FUTURE),",
            "        user=request.user,",
            "        approval_required=job_model.approval_required,",
            "        crontab=crontab,",
            "        queue=task_queue,",
            "    )",
            "    scheduled_job.save()",
            "    return scheduled_job",
            "",
            "",
            "def _run_job(request, job_model, legacy_response=False):",
            "    \"\"\"An internal function providing logic shared between JobModelViewSet.run() and JobViewSet.run().\"\"\"",
            "    if not request.user.has_perm(\"extras.run_job\"):",
            "        raise PermissionDenied(\"This user does not have permission to run jobs.\")",
            "    if not job_model.enabled:",
            "        raise PermissionDenied(\"This job is not enabled to be run.\")",
            "    if not job_model.installed:",
            "        raise MethodNotAllowed(request.method, detail=\"This job is not presently installed and cannot be run\")",
            "    if job_model.has_sensitive_variables:",
            "        if request.data.get(\"schedule\") and request.data[\"schedule\"][\"interval\"] != JobExecutionType.TYPE_IMMEDIATELY:",
            "            raise ValidationError(",
            "                {\"schedule\": {\"interval\": [\"Unable to schedule job: Job may have sensitive input variables\"]}}",
            "            )",
            "        if job_model.approval_required:",
            "            raise ValidationError(",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\"",
            "            )",
            "",
            "    job_class = job_model.job_class",
            "    if job_class is None:",
            "        raise MethodNotAllowed(request.method, detail=\"This job's source code could not be located and cannot be run\")",
            "    job = job_class()",
            "",
            "    valid_queues = job_model.task_queues if job_model.task_queues else [settings.CELERY_TASK_DEFAULT_QUEUE]",
            "    # Get a default queue from either the job model's specified task queue or system default to fall back on if request doesn't provide one",
            "    default_valid_queue = valid_queues[0]",
            "",
            "    # We need to call request.data for both cases as this is what pulls and caches the request data",
            "    data = request.data",
            "    files = None",
            "    schedule_data = None",
            "",
            "    # We must extract from the request:",
            "    # - Job Form data (for submission to the job itself)",
            "    # - Schedule data",
            "    # - Commit flag state",
            "    # - Desired task queue",
            "    # Depending on request content type (largely for backwards compatibility) the keys at which these are found are different",
            "    if \"multipart/form-data\" in request.content_type:",
            "        data = request._data.dict()  # .data will return data and files, we just want the data",
            "        files = request.FILES",
            "",
            "        # JobMultiPartInputSerializer is a \"flattened\" version of JobInputSerializer",
            "        input_serializer = serializers.JobMultiPartInputSerializer(data=data, context={\"request\": request})",
            "        input_serializer.is_valid(raise_exception=True)",
            "",
            "        commit = input_serializer.validated_data.get(\"_commit\", None)",
            "        task_queue = input_serializer.validated_data.get(\"_task_queue\", default_valid_queue)",
            "",
            "        # JobMultiPartInputSerializer only has keys for executing job (commit, task_queue, etc),",
            "        # everything else is a candidate for the job form's data.",
            "        # job_class.validate_data will throw an error for any unexpected key/value pairs.",
            "        non_job_keys = input_serializer.validated_data.keys()",
            "        for non_job_key in non_job_keys:",
            "            data.pop(non_job_key, None)",
            "",
            "        # List of keys in serializer that are effectively exploded versions of the schedule dictionary from JobInputSerializer",
            "        schedule_keys = (\"_schedule_name\", \"_schedule_start_time\", \"_schedule_interval\", \"_schedule_crontab\")",
            "",
            "        # Assign the key from the validated_data output to dictionary without prefixed \"_schedule_\"",
            "        # For all the keys that are schedule keys",
            "        # Assign only if the key is in the output since we don't want None's if not provided",
            "        if any(schedule_key in non_job_keys for schedule_key in schedule_keys):",
            "            schedule_data = {",
            "                k.replace(\"_schedule_\", \"\"): input_serializer.validated_data[k]",
            "                for k in schedule_keys",
            "                if k in input_serializer.validated_data",
            "            }",
            "",
            "    else:",
            "        input_serializer = serializers.JobInputSerializer(data=data, context={\"request\": request})",
            "        input_serializer.is_valid(raise_exception=True)",
            "",
            "        data = input_serializer.validated_data.get(\"data\", {})",
            "        commit = input_serializer.validated_data.get(\"commit\", None)",
            "        task_queue = input_serializer.validated_data.get(\"task_queue\", default_valid_queue)",
            "        schedule_data = input_serializer.validated_data.get(\"schedule\", None)",
            "",
            "    if commit is None:",
            "        commit = job_model.commit_default",
            "",
            "    if task_queue not in valid_queues:",
            "        raise ValidationError({\"task_queue\": [f'\"{task_queue}\" is not a valid choice.']})",
            "",
            "    cleaned_data = None",
            "    try:",
            "        cleaned_data = job.validate_data(data, files=files)",
            "        cleaned_data.pop(",
            "            \"_commit\", None",
            "        )  # We don't get commit from the form, instead it's part of the serializer's validated data",
            "",
            "    except FormsValidationError as e:",
            "        # message_dict can only be accessed if ValidationError got a dict",
            "        # in the constructor (saved as error_dict). Otherwise we get a list",
            "        # of errors under messages",
            "        return Response({\"errors\": e.message_dict if hasattr(e, \"error_dict\") else e.messages}, status=400)",
            "",
            "    if not get_worker_count(queue=task_queue):",
            "        raise CeleryWorkerNotRunningException(queue=task_queue)",
            "",
            "    job_content_type = get_job_content_type()",
            "",
            "    # Default to a null JobResult.",
            "    job_result = None",
            "",
            "    # Assert that a job with `approval_required=True` has a schedule that enforces approval and",
            "    # executes immediately.",
            "    if schedule_data is None and job_model.approval_required:",
            "        schedule_data = {\"interval\": JobExecutionType.TYPE_IMMEDIATELY}",
            "",
            "    # Skip creating a ScheduledJob when job can be executed immediately",
            "    elif (",
            "        schedule_data",
            "        and schedule_data[\"interval\"] == JobExecutionType.TYPE_IMMEDIATELY",
            "        and not job_model.approval_required",
            "    ):",
            "        schedule_data = None",
            "",
            "    # Try to create a ScheduledJob, or...",
            "    if schedule_data:",
            "        schedule = _create_schedule(",
            "            schedule_data,",
            "            job_class.serialize_data(cleaned_data),",
            "            commit,",
            "            job,",
            "            job_model,",
            "            request,",
            "            celery_kwargs={\"queue\": task_queue},",
            "            task_queue=input_serializer.validated_data.get(\"task_queue\", None),",
            "        )",
            "    else:",
            "        schedule = None",
            "",
            "    # ... If we can't create one, create a JobResult instead.",
            "    if schedule is None:",
            "        job_result = JobResult.enqueue_job(",
            "            run_job,",
            "            job.class_path,",
            "            job_content_type,",
            "            request.user,",
            "            celery_kwargs={\"queue\": task_queue},",
            "            data=job_class.serialize_data(cleaned_data),",
            "            request=copy_safe_request(request),",
            "            commit=commit,",
            "            task_queue=input_serializer.validated_data.get(\"task_queue\", None),",
            "        )",
            "        job.result = job_result",
            "",
            "    if legacy_response:",
            "        # Old-style JobViewSet response - serialize the Job class in the response for some reason?",
            "        serializer = serializers.JobClassDetailSerializer(job, context={\"request\": request})",
            "        return Response(serializer.data)",
            "    else:",
            "        # New-style JobModelViewSet response - serialize the schedule or job_result as appropriate",
            "        data = {\"schedule\": None, \"job_result\": None}",
            "        if schedule:",
            "            data[\"schedule\"] = nested_serializers.NestedScheduledJobSerializer(",
            "                schedule, context={\"request\": request}",
            "            ).data",
            "        if job_result:",
            "            data[\"job_result\"] = nested_serializers.NestedJobResultSerializer(",
            "                job_result, context={\"request\": request}",
            "            ).data",
            "        return Response(data, status=status.HTTP_201_CREATED)",
            "",
            "",
            "class JobViewSet(",
            "    # DRF mixins:",
            "    # note no CreateModelMixin",
            "    mixins.UpdateModelMixin,",
            "    mixins.DestroyModelMixin,",
            "    # Nautobot mixins:",
            "    BulkUpdateModelMixin,",
            "    BulkDestroyModelMixin,",
            "    # Base class",
            "    ReadOnlyModelViewSet,",
            "    NotesViewSetMixin,",
            "):",
            "    queryset = Job.objects.all()",
            "    serializer_class = serializers.JobSerializer",
            "    filterset_class = filters.JobFilterSet",
            "",
            "    # Custom schema for the deprecated 1.2 API version of this endpoint.",
            "    # For 1.3 and later, the standard autogenerated API schema is correct and does not need to be customized here.",
            "    @extend_schema(",
            "        filters=False,",
            "        responses={\"200\": serializers.JobClassSerializer(many=True)},",
            "        versions=[\"1.2\"],",
            "    )",
            "    def list(self, request, *args, **kwargs):",
            "        \"\"\"List all known Jobs.\"\"\"",
            "        if request.major_version > 1 or request.minor_version >= 3:",
            "            # API version 1.3 or later - standard model-based response",
            "            return super().list(request, *args, **kwargs)",
            "",
            "        # API version 1.2 or earlier - serialize JobClass records",
            "        if not request.user.has_perm(\"extras.view_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to view jobs.\")",
            "        job_content_type = get_job_content_type()",
            "        results = {",
            "            r.name: r",
            "            for r in JobResult.objects.filter(",
            "                obj_type=job_content_type,",
            "                status__in=JobResultStatusChoices.TERMINAL_STATE_CHOICES,",
            "            )",
            "            .defer(\"data\")",
            "            .order_by(\"created\")",
            "        }",
            "",
            "        job_models = Job.objects.restrict(request.user, \"view\")",
            "        jobs_list = [",
            "            job_model.job_class()  # TODO: why do we need to instantiate the job_class?",
            "            for job_model in job_models",
            "            if job_model.installed and job_model.job_class is not None",
            "        ]",
            "        for job_instance in jobs_list:",
            "            job_instance.result = results.get(job_instance.class_path, None)",
            "",
            "        serializer = serializers.JobClassSerializer(jobs_list, many=True, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    @extend_schema(",
            "        deprecated=True,",
            "        operation_id=\"extras_jobs_read_deprecated\",",
            "        responses={\"200\": serializers.JobClassDetailSerializer()},",
            "    )",
            "    @action(",
            "        detail=False,  # a /jobs/... URL, not a /jobs/<pk>/... URL",
            "        methods=[\"get\"],",
            "        url_path=\"(?P<class_path>[^/]+/[^/]+/[^/]+)\",  # /api/extras/jobs/<class_path>/",
            "        url_name=\"detail\",",
            "    )",
            "    def retrieve_deprecated(self, request, class_path):",
            "        \"\"\"",
            "        Get details of a Job as identified by its class-path.",
            "",
            "        This API endpoint is deprecated; it is recommended to use the extras_jobs_read endpoint instead.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.view_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to view jobs.\")",
            "        try:",
            "            job_model = Job.objects.restrict(request.user, \"view\").get_for_class_path(class_path)",
            "        except Job.DoesNotExist:",
            "            raise Http404",
            "        if not job_model.installed or job_model.job_class is None:",
            "            raise Http404",
            "        job_content_type = get_job_content_type()",
            "        job = job_model.job_class()  # TODO: why do we need to instantiate the job_class?",
            "        job.result = JobResult.objects.filter(",
            "            obj_type=job_content_type,",
            "            name=job.class_path,",
            "            status__in=JobResultStatusChoices.TERMINAL_STATE_CHOICES,",
            "        ).first()",
            "",
            "        serializer = serializers.JobClassDetailSerializer(job, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    @extend_schema(responses={\"200\": serializers.JobVariableSerializer(many=True)})",
            "    @action(detail=True, filterset_class=None)",
            "    def variables(self, request, pk):",
            "        \"\"\"Get details of the input variables that may/must be specified to run a particular Job.\"\"\"",
            "        job_model = self.get_object()",
            "        job_class = job_model.job_class",
            "        if job_class is None:",
            "            raise Http404",
            "        variables_dict = job_class._get_vars()",
            "        data = []",
            "        for name, instance in variables_dict.items():",
            "            entry = {\"name\": name, \"type\": instance.__class__.__name__}",
            "            for key in [",
            "                \"label\",",
            "                \"help_text\",",
            "                \"required\",",
            "                \"min_length\",",
            "                \"max_length\",",
            "                \"min_value\",",
            "                \"max_value\",",
            "                \"choices\",",
            "            ]:",
            "                if key in instance.field_attrs:",
            "                    entry[key] = instance.field_attrs[key]",
            "            if \"initial\" in instance.field_attrs:",
            "                entry[\"default\"] = instance.field_attrs[\"initial\"]",
            "            if \"queryset\" in instance.field_attrs:",
            "                content_type = ContentType.objects.get_for_model(instance.field_attrs[\"queryset\"].model)",
            "                entry[\"model\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            data.append(entry)",
            "        return Response(data)",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special \"run_job\" permission as queryset filter on the /run/ endpoint, otherwise as ModelViewSetMixin.",
            "        \"\"\"",
            "        if request.user.is_authenticated and self.action == \"run\":",
            "            self.queryset = self.queryset.restrict(request.user, \"run\")",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class JobRunTokenPermissions(TokenPermissions):",
            "        \"\"\"As nautobot.core.api.authentication.TokenPermissions, but enforcing run_job instead of add_job.\"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.run_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request={",
            "            \"application/json\": serializers.JobInputSerializer,",
            "            \"multipart/form-data\": serializers.JobMultiPartInputSerializer,",
            "        },",
            "        responses={\"201\": serializers.JobRunResponseSerializer},",
            "    )",
            "    @action(",
            "        detail=True,",
            "        methods=[\"post\"],",
            "        permission_classes=[JobRunTokenPermissions],",
            "        parser_classes=[JSONParser, MultiPartParser],",
            "    )",
            "    def run(self, request, *args, pk, **kwargs):",
            "        \"\"\"Run the specified Job.\"\"\"",
            "        job_model = self.get_object()",
            "        return _run_job(request, job_model)",
            "",
            "    @extend_schema(",
            "        deprecated=True,",
            "        methods=[\"post\"],",
            "        request=serializers.JobInputSerializer,",
            "        responses={\"200\": serializers.JobClassDetailSerializer()},",
            "        operation_id=\"extras_jobs_run_deprecated\",",
            "    )",
            "    @action(",
            "        detail=False,  # a /jobs/... URL, not a /jobs/<pk>/... URL",
            "        methods=[\"post\"],",
            "        permission_classes=[JobRunTokenPermissions],",
            "        url_path=\"(?P<class_path>[^/]+/[^/]+/[^/]+)/run\",  # /api/extras/jobs/<class_path>/run/",
            "        url_name=\"run\",",
            "        parser_classes=[JSONParser, MultiPartParser],",
            "    )",
            "    def run_deprecated(self, request, class_path):",
            "        \"\"\"",
            "        Run a Job as identified by its class-path.",
            "",
            "        This API endpoint is deprecated; it is recommended to use the extras_jobs_run endpoint instead.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.run_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to run jobs.\")",
            "        try:",
            "            job_model = Job.objects.restrict(request.user, \"run\").get_for_class_path(class_path)",
            "        except Job.DoesNotExist:",
            "            raise Http404",
            "        return _run_job(request, job_model, legacy_response=True)",
            "",
            "",
            "#",
            "# Job Hooks",
            "#",
            "",
            "",
            "class JobHooksViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobHook.objects.all()",
            "    serializer_class = serializers.JobHookSerializer",
            "    filterset_class = filters.JobHookFilterSet",
            "",
            "",
            "#",
            "# Job Results",
            "#",
            "",
            "",
            "class JobLogEntryViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of job log entries.",
            "    \"\"\"",
            "",
            "    queryset = JobLogEntry.objects.select_related(\"job_result\")",
            "    serializer_class = serializers.JobLogEntrySerializer",
            "    filterset_class = filters.JobLogEntryFilterSet",
            "",
            "",
            "class JobResultViewSet(",
            "    # DRF mixins:",
            "    # note no CreateModelMixin or UpdateModelMixin",
            "    mixins.DestroyModelMixin,",
            "    # Nautobot mixins:",
            "    BulkDestroyModelMixin,",
            "    # Base class",
            "    ReadOnlyModelViewSet,",
            "):",
            "    \"\"\"",
            "    Retrieve a list of job results",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.select_related(\"job_model\", \"obj_type\", \"user\")",
            "    serializer_class = serializers.JobResultSerializer",
            "    filterset_class = filters.JobResultFilterSet",
            "",
            "    @action(detail=True)",
            "    def logs(self, request, pk=None):",
            "        job_result = self.get_object()",
            "        logs = job_result.logs.all()",
            "        serializer = nested_serializers.NestedJobLogEntrySerializer(logs, context={\"request\": request}, many=True)",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    filterset_class = filters.JobButtonFilterSet",
            "",
            "",
            "#",
            "# Scheduled Jobs",
            "#",
            "",
            "",
            "class ScheduledJobViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of scheduled jobs",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.select_related(\"user\")",
            "    serializer_class = serializers.ScheduledJobSerializer",
            "    filterset_class = filters.ScheduledJobFilterSet",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special permissions as queryset filter on the /approve/, /deny/, and /dry-run/ endpoints.",
            "",
            "        Otherwise, same as ModelViewSetMixin.",
            "        \"\"\"",
            "        action_to_method = {\"approve\": \"change\", \"deny\": \"delete\", \"dry-run\": \"view\"}",
            "        if request.user.is_authenticated and self.action in action_to_method:",
            "            self.queryset = self.queryset.restrict(request.user, action_to_method[self.action])",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class ScheduledJobChangePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing change_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.change_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.ScheduledJobSerializer},",
            "        request=None,",
            "        parameters=[",
            "            OpenApiParameter(",
            "                \"force\",",
            "                location=OpenApiParameter.QUERY,",
            "                description=\"force execution even if start time has passed\",",
            "                type=OpenApiTypes.BOOL,",
            "            )",
            "        ],",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobChangePermissions])",
            "    def approve(self, request, pk):",
            "        scheduled_job = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to approve this request.\")",
            "",
            "        # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        if request.user == scheduled_job.user:",
            "            # The requestor *cannot* approve their own job",
            "            return Response(\"You cannot approve your own job request!\", status=403)",
            "",
            "        if (",
            "            scheduled_job.one_off",
            "            and scheduled_job.start_time < timezone.now()",
            "            and not request.query_params.get(\"force\")",
            "        ):",
            "            return Response(",
            "                \"The job's start time is in the past. If you want to force a run anyway, add the `force` query parameter.\",",
            "                status=400,",
            "            )",
            "",
            "        scheduled_job.approved_by_user = request.user",
            "        scheduled_job.approved_at = timezone.now()",
            "        scheduled_job.save()",
            "        serializer = serializers.ScheduledJobSerializer(scheduled_job, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    class ScheduledJobDeletePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing delete_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.delete_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=None,",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobDeletePermissions])",
            "    def deny(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to deny this request.\")",
            "",
            "        scheduled_job.delete()",
            "",
            "        return Response(None)",
            "",
            "    class ScheduledJobViewPermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing view_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.view_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.JobResultSerializer},",
            "        request=None,",
            "    )",
            "    @action(detail=True, url_path=\"dry-run\", methods=[\"post\"], permission_classes=[ScheduledJobViewPermissions])",
            "    def dry_run(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "        job_model = scheduled_job.job_model",
            "        if job_model is None or not job_model.runnable:",
            "            raise MethodNotAllowed(\"This job cannot be dry-run at this time.\")",
            "        if not Job.objects.check_perms(request.user, instance=job_model, action=\"run\"):",
            "            raise PermissionDenied(\"You do not have permission to run this job.\")",
            "",
            "        # Immediately enqueue the job with commit=False",
            "        job_content_type = get_job_content_type()",
            "        job_result = JobResult.enqueue_job(",
            "            run_job,",
            "            job_model.class_path,",
            "            job_content_type,",
            "            request.user,",
            "            celery_kwargs=scheduled_job.kwargs.get(\"celery_kwargs\", {}),",
            "            data=scheduled_job.kwargs.get(\"data\", {}),",
            "            request=copy_safe_request(request),",
            "            commit=False,  # force a dry-run",
            "            task_queue=scheduled_job.kwargs.get(\"task_queue\", None),",
            "        )",
            "        serializer = serializers.JobResultSerializer(job_result, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteViewSet(ModelViewSet):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = Note.objects.select_related(\"user\")",
            "    serializer_class = serializers.NoteSerializer",
            "    filterset_class = filters.NoteFilterSet",
            "",
            "    # Assign user from request",
            "    def perform_create(self, serializer):",
            "        serializer.save(user=self.request.user)",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of recent changes.",
            "    \"\"\"",
            "",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = ObjectChange.objects.select_related(\"user\")",
            "    serializer_class = serializers.ObjectChangeSerializer",
            "    filterset_class = filters.ObjectChangeFilterSet",
            "",
            "",
            "#",
            "#  Relationships",
            "#",
            "",
            "",
            "class RelationshipViewSet(ModelViewSet, NotesViewSetMixin):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = Relationship.objects.all()",
            "    serializer_class = serializers.RelationshipSerializer",
            "    filterset_class = filters.RelationshipFilterSet",
            "",
            "",
            "class RelationshipAssociationViewSet(ModelViewSet):",
            "    metadata_class = ContentTypeMetadata",
            "    queryset = RelationshipAssociation.objects.all()",
            "    serializer_class = serializers.RelationshipAssociationSerializer",
            "    filterset_class = filters.RelationshipAssociationFilterSet",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretsViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Secret.objects.all()",
            "    serializer_class = serializers.SecretSerializer",
            "    filterset_class = filters.SecretFilterSet",
            "",
            "    @extend_schema(",
            "        responses={",
            "            200: {",
            "                \"type\": \"object\",",
            "                \"properties\": {",
            "                    \"result\": {\"type\": \"boolean\"},",
            "                    \"message\": {\"type\": \"string\"},",
            "                },",
            "            }",
            "        },",
            "    )",
            "    @action(methods=[\"GET\"], detail=True)",
            "    def check(self, request, pk):",
            "        \"\"\"Check that a secret's value is accessible.\"\"\"",
            "        result = False",
            "        message = \"Unknown error\"",
            "        try:",
            "            self.get_object().get_value()",
            "            result = True",
            "            message = \"Passed\"",
            "        except SecretError as e:",
            "            message = str(e)",
            "        response = {\"result\": result, \"message\": message}",
            "        return Response(response)",
            "",
            "",
            "class SecretsGroupViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroup.objects.all()",
            "    serializer_class = serializers.SecretsGroupSerializer",
            "    filterset_class = filters.SecretsGroupFilterSet",
            "",
            "",
            "class SecretsGroupAssociationViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroupAssociation.objects.all()",
            "    serializer_class = serializers.SecretsGroupAssociationSerializer",
            "    filterset_class = filters.SecretsGroupAssociationFilterSet",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    View and manage custom status choices for objects with a `status` field.",
            "    \"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    serializer_class = serializers.StatusSerializer",
            "    filterset_class = filters.StatusFilterSet",
            "",
            "",
            "class StatusViewSetMixin(ModelViewSet):",
            "    \"\"\"",
            "    Mixin to set `metadata_class` to implement `status` field in model viewset metadata.",
            "    \"\"\"",
            "",
            "    metadata_class = StatusFieldMetadata",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "@extend_schema_view(",
            "    bulk_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.TagSerializer(many=True),",
            "        responses={\"200\": serializers.TagSerializer(many=True)},",
            "        versions=[\"1.2\"],",
            "    ),",
            "    bulk_partial_update=extend_schema(",
            "        filters=False,",
            "        request=serializers.TagSerializer(many=True),",
            "        responses={\"200\": serializers.TagSerializer(many=True)},",
            "        versions=[\"1.2\"],",
            "    ),",
            "    create=extend_schema(",
            "        request=serializers.TagSerializer, responses={\"201\": serializers.TagSerializer}, versions=[\"1.2\"]",
            "    ),",
            "    partial_update=extend_schema(",
            "        request=serializers.TagSerializer, responses={\"200\": serializers.TagSerializer}, versions=[\"1.2\"]",
            "    ),",
            "    update=extend_schema(",
            "        request=serializers.TagSerializer, responses={\"200\": serializers.TagSerializer}, versions=[\"1.2\"]",
            "    ),",
            "    list=extend_schema(responses={\"200\": serializers.TagSerializer(many=True)}, versions=[\"1.2\"]),",
            "    retrieve=extend_schema(responses={\"200\": serializers.TagSerializer}, versions=[\"1.2\"]),",
            ")",
            "class TagViewSet(NautobotModelViewSet):",
            "    queryset = Tag.objects.annotate(tagged_items=count_related(TaggedItem, \"tag\"))",
            "    serializer_class = serializers.TagSerializerVersion13",
            "    filterset_class = filters.TagFilterSet",
            "",
            "    def get_serializer_class(self):",
            "        serializer_choices = (SerializerForAPIVersions(versions=[\"1.2\"], serializer=serializers.TagSerializer),)",
            "        return versioned_serializer_selector(",
            "            obj=self,",
            "            serializer_choices=serializer_choices,",
            "            default_serializer=super().get_serializer_class(),",
            "        )",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhooksViewSet(ModelViewSet, NotesViewSetMixin):",
            "    \"\"\"",
            "    Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Webhook.objects.all()",
            "    serializer_class = serializers.WebhookSerializer",
            "    filterset_class = filters.WebhookFilterSet"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "333": [
                "DynamicGroupViewSet",
                "members"
            ],
            "339": [
                "DynamicGroupViewSet",
                "members"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/tests/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " from nautobot.ipam.models import VLAN, VLANGroup"
            },
            "1": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " from nautobot.users.models import ObjectPermission"
            },
            "2": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " from nautobot.utilities.choices import ColorChoices"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+from nautobot.utilities.permissions import get_permission_for_model"
            },
            "4": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " from nautobot.utilities.testing import APITestCase, APIViewTestCases"
            },
            "5": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " from nautobot.utilities.testing.utils import disable_warnings"
            },
            "6": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " from nautobot.utilities.utils import get_route_for_model, slugify_dashes_to_underscores"
            },
            "7": {
                "beforePatchRowNumber": 752,
                "afterPatchRowNumber": 753,
                "PatchRowcode": "     def test_get_members(self):"
            },
            "8": {
                "beforePatchRowNumber": 753,
                "afterPatchRowNumber": 754,
                "PatchRowcode": "         \"\"\"Test that the `/members/` API endpoint returns what is expected.\"\"\""
            },
            "9": {
                "beforePatchRowNumber": 754,
                "afterPatchRowNumber": 755,
                "PatchRowcode": "         self.add_permissions(\"extras.view_dynamicgroup\")"
            },
            "10": {
                "beforePatchRowNumber": 755,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        instance = DynamicGroup.objects.first()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 756,
                "PatchRowcode": "+        instance = self.groups[0]"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 757,
                "PatchRowcode": "+        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))"
            },
            "13": {
                "beforePatchRowNumber": 756,
                "afterPatchRowNumber": 758,
                "PatchRowcode": "         member_count = instance.members.count()"
            },
            "14": {
                "beforePatchRowNumber": 757,
                "afterPatchRowNumber": 759,
                "PatchRowcode": "         url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})"
            },
            "15": {
                "beforePatchRowNumber": 758,
                "afterPatchRowNumber": 760,
                "PatchRowcode": "         response = self.client.get(url, **self.header)"
            },
            "16": {
                "beforePatchRowNumber": 759,
                "afterPatchRowNumber": 761,
                "PatchRowcode": "         self.assertHttpStatus(response, status.HTTP_200_OK)"
            },
            "17": {
                "beforePatchRowNumber": 760,
                "afterPatchRowNumber": 762,
                "PatchRowcode": "         self.assertEqual(member_count, len(response.json()[\"results\"]))"
            },
            "18": {
                "beforePatchRowNumber": 761,
                "afterPatchRowNumber": 763,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 764,
                "PatchRowcode": "+    def test_get_members_with_constrained_permission(self):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 765,
                "PatchRowcode": "+        \"\"\"Test that the `/members/` API endpoint enforces permissions on the member model.\"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 766,
                "PatchRowcode": "+        self.add_permissions(\"extras.view_dynamicgroup\")"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 767,
                "PatchRowcode": "+        instance = self.groups[0]"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 768,
                "PatchRowcode": "+        obj1 = instance.members.first()"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 769,
                "PatchRowcode": "+        obj_perm = ObjectPermission("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 770,
                "PatchRowcode": "+            name=\"Test permission\","
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 771,
                "PatchRowcode": "+            constraints={\"pk__in\": [obj1.pk]},"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 772,
                "PatchRowcode": "+            actions=[\"view\"],"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 773,
                "PatchRowcode": "+        )"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 774,
                "PatchRowcode": "+        obj_perm.save()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 775,
                "PatchRowcode": "+        obj_perm.users.add(self.user)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 776,
                "PatchRowcode": "+        obj_perm.object_types.add(instance.content_type)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 777,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 778,
                "PatchRowcode": "+        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 779,
                "PatchRowcode": "+        response = self.client.get(url, **self.header)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 780,
                "PatchRowcode": "+        self.assertHttpStatus(response, status.HTTP_200_OK)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 781,
                "PatchRowcode": "+        self.assertEqual(len(response.json()[\"results\"]), 1)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 782,
                "PatchRowcode": "+        self.assertEqual(response.json()[\"results\"][0][\"id\"], str(obj1.pk))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 783,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 762,
                "afterPatchRowNumber": 784,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 763,
                "afterPatchRowNumber": 785,
                "PatchRowcode": " class DynamicGroupMembershipTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):"
            },
            "41": {
                "beforePatchRowNumber": 764,
                "afterPatchRowNumber": 786,
                "PatchRowcode": "     model = DynamicGroupMembership"
            }
        },
        "frontPatchFile": [
            "from datetime import datetime, timedelta",
            "import uuid",
            "import tempfile",
            "from unittest import mock",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils.timezone import make_aware, now",
            "from rest_framework import status",
            "",
            "from nautobot.dcim.models import (",
            "    Device,",
            "    DeviceRedundancyGroup,",
            "    DeviceRole,",
            "    DeviceType,",
            "    Manufacturer,",
            "    Rack,",
            "    RackGroup,",
            "    RackRole,",
            "    Site,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.api.nested_serializers import NestedJobResultSerializer",
            "from nautobot.extras.api.serializers import ConfigContextSerializer",
            "from nautobot.extras.choices import (",
            "    DynamicGroupOperatorChoices,",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    RelationshipTypeChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            ")",
            "from nautobot.extras.jobs import get_job",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.models.jobs import JobHook, JobButton",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import TaggableClassesQuery",
            "from nautobot.ipam.factory import VLANFactory",
            "from nautobot.ipam.models import VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.choices import ColorChoices",
            "from nautobot.utilities.testing import APITestCase, APIViewTestCases",
            "from nautobot.utilities.testing.utils import disable_warnings",
            "from nautobot.utilities.utils import get_route_for_model, slugify_dashes_to_underscores",
            "",
            "",
            "User = get_user_model()",
            "",
            "",
            "class AppTest(APITestCase):",
            "    def test_root(self):",
            "        url = reverse(\"extras-api:api-root\")",
            "        response = self.client.get(f\"{url}?format=api\", **self.header)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldTest(APIViewTestCases.APIViewTestCase):",
            "    model = ComputedField",
            "    brief_fields = [",
            "        \"content_type\",",
            "        \"display\",",
            "        \"id\",",
            "        \"label\",",
            "        \"url\",",
            "    ]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"slug\": \"cf4\",",
            "            \"label\": \"Computed Field 4\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"slug\": \"cf5\",",
            "            \"label\": \"Computed Field 5\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"slug\": \"cf6\",",
            "            \"label\": \"Computed Field 6\",",
            "            \"template\": \"{{ obj.name }}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"label\": \"Computed Field 7\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_type\": \"dcim.site\",",
            "        \"slug\": \"cf1\",",
            "        \"label\": \"My Computed Field\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "",
            "        ComputedField.objects.create(",
            "            slug=\"cf1\",",
            "            label=\"Computed Field One\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=site_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            slug=\"cf2\",",
            "            label=\"Computed Field Two\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=site_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            slug=\"cf3\",",
            "            label=\"Computed Field Three\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=site_ct,",
            "        )",
            "",
            "        cls.site = Site.objects.create(name=\"Site 1\", slug=\"site-1\")",
            "",
            "    def test_computed_field_include(self):",
            "        \"\"\"Test that explicitly including a computed field behaves as expected.\"\"\"",
            "        self.add_permissions(\"dcim.view_site\")",
            "        url = reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.site.pk})",
            "",
            "        # First get the object without computed fields.",
            "        response = self.client.get(url, **self.header)",
            "        self.assertNotIn(\"computed_fields\", response.json())",
            "",
            "        # Now get it with computed fields.",
            "        params = {\"include\": \"computed_fields\"}",
            "        response = self.client.get(url, data=params, **self.header)",
            "        self.assertIn(\"computed_fields\", response.json())",
            "",
            "",
            "class ConfigContextTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContext",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContext.objects.create(name=\"Config Context 1\", weight=100, data={\"foo\": 123})",
            "        ConfigContext.objects.create(name=\"Config Context 2\", weight=200, data={\"bar\": 456})",
            "        ConfigContext.objects.create(name=\"Config Context 3\", weight=300, data={\"baz\": 789})",
            "",
            "        device_redundancy_groups = DeviceRedundancyGroup.objects.all()[:2]",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Config Context 4\",",
            "                \"device_redundancy_groups\": [device_redundancy_groups[0].pk, device_redundancy_groups[1].pk],",
            "                \"data\": {\"more_foo\": True},",
            "            },",
            "            {",
            "                \"name\": \"Config Context 5\",",
            "                \"device_redundancy_groups\": [device_redundancy_groups[1].pk],",
            "                \"data\": {\"more_bar\": False},",
            "            },",
            "            {",
            "                \"name\": \"Config Context 6\",",
            "                \"data\": {\"more_baz\": None},",
            "            },",
            "        ]",
            "",
            "    def test_render_configcontext_for_object(self):",
            "        \"\"\"",
            "        Test rendering config context data for a device.",
            "        \"\"\"",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        site = Site.objects.create(name=\"Site-1\", slug=\"site-1\")",
            "        device = Device.objects.create(name=\"Device 1\", device_type=devicetype, device_role=devicerole, site=site)",
            "",
            "        # Test default config contexts (created at test setup)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 123)",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        self.assertEqual(rendered_context[\"baz\"], 789)",
            "",
            "        # Test API response as well",
            "        self.add_permissions(\"dcim.view_device\")",
            "        device_url = reverse(\"dcim-api:device-detail\", kwargs={\"pk\": device.pk})",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"], {\"foo\": 123, \"bar\": 456, \"baz\": 789}, response.data)",
            "",
            "        # Add another context specific to the site",
            "        configcontext4 = ConfigContext(name=\"Config Context 4\", data={\"site_data\": \"ABC\"})",
            "        configcontext4.save()",
            "        configcontext4.sites.add(site)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"site_data\"], \"ABC\")",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"site_data\"], \"ABC\", response.data[\"config_context\"])",
            "",
            "        # Override one of the default contexts",
            "        configcontext5 = ConfigContext(name=\"Config Context 5\", weight=2000, data={\"foo\": 999})",
            "        configcontext5.save()",
            "        configcontext5.sites.add(site)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 999)",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"foo\"], 999, response.data[\"config_context\"])",
            "",
            "        # Add a context which does NOT match our device and ensure it does not apply",
            "        site2 = Site.objects.create(name=\"Site 2\", slug=\"site-2\")",
            "        configcontext6 = ConfigContext(name=\"Config Context 6\", weight=2000, data={\"bar\": 999})",
            "        configcontext6.save()",
            "        configcontext6.sites.add(site2)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"bar\"], 456, response.data[\"config_context\"])",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {\"name\": \"Config Context with schema\", \"weight\": 100, \"data\": {\"foo\": \"bar\"}, \"schema\": str(schema.pk)}",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(response.data[\"schema\"][\"id\"], str(schema.pk))",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 100,",
            "            \"data\": {\"foo\": \"bar\"},",
            "            \"schema\": str(schema.pk),",
            "        }",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=True)",
            "    def test_with_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is present when feature flag is enabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertIn(\"dynamic_groups\", serializer.fields)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=False)",
            "    def test_without_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is NOT present the when feature flag is disabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertNotIn(\"dynamic_groups\", serializer.fields)",
            "",
            "",
            "class ConfigContextSchemaTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContextSchema",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"Schema 4\",",
            "            \"slug\": \"schema-4\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 5\",",
            "            \"slug\": \"schema-5\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 6\",",
            "            \"slug\": \"schema-6\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 7\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = []",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", slug=\"schema-2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", slug=\"schema-3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "",
            "class ContentTypeTest(APITestCase):",
            "    \"\"\"",
            "    ContentTypeViewSet does not have permission checks,",
            "    So It should be accessible with or without permission override",
            "    e.g. @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"contenttypes.contenttype\"])",
            "    \"\"\"",
            "",
            "    def test_list_objects_with_or_without_permission(self):",
            "        contenttype_count = ContentType.objects.count()",
            "",
            "        response = self.client.get(reverse(\"extras-api:contenttype-list\"), **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], contenttype_count)",
            "",
            "    def test_get_object_with_or_without_permission(self):",
            "        contenttype = ContentType.objects.first()",
            "",
            "        url = reverse(\"extras-api:contenttype-detail\", kwargs={\"pk\": contenttype.pk})",
            "        self.assertHttpStatus(self.client.get(url, **self.header), status.HTTP_200_OK)",
            "",
            "",
            "class CreatedUpdatedFilterTest(APITestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.site1 = Site.objects.create(name=\"Test Site 1\", slug=\"test-site-1\")",
            "        self.rackgroup1 = RackGroup.objects.create(site=self.site1, name=\"Test Rack Group 1\", slug=\"test-rack-group-1\")",
            "        self.rackrole1 = RackRole.objects.create(name=\"Test Rack Role 1\", slug=\"test-rack-role-1\", color=\"ff0000\")",
            "        self.rack1 = Rack.objects.create(",
            "            site=self.site1,",
            "            group=self.rackgroup1,",
            "            role=self.rackrole1,",
            "            name=\"Test Rack 1\",",
            "            u_height=42,",
            "        )",
            "        self.rack2 = Rack.objects.create(",
            "            site=self.site1,",
            "            group=self.rackgroup1,",
            "            role=self.rackrole1,",
            "            name=\"Test Rack 2\",",
            "            u_height=42,",
            "        )",
            "",
            "        # change the created and last_updated of one",
            "        Rack.objects.filter(pk=self.rack2.pk).update(",
            "            last_updated=make_aware(datetime(2001, 2, 3, 1, 2, 3, 4)),",
            "            created=make_aware(datetime(2001, 2, 3)),",
            "        )",
            "",
            "    def test_get_rack_created(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created=2001-02-03\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_created_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created__gte=2001-02-04\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_created_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created__lte=2001-02-04\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated=2001-02-03%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__gte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_last_updated_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__lte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "",
            "class CustomFieldTestVersion12(APIViewTestCases.APIViewTestCase):",
            "    \"\"\"Tests for the API version 1.2/1.3 CustomField REST API.\"\"\"",
            "",
            "    model = CustomField",
            "    api_version = \"1.2\"",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"name\": \"cf4\",",
            "            \"type\": \"date\",",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"name\": \"cf5\",",
            "            \"type\": \"url\",",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"name\": \"cf6\",",
            "            \"type\": \"select\",",
            "            \"label\": \"Custom Field 6\",",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_types\": [\"dcim.site\"],",
            "        \"name\": \"cf1\",",
            "        \"label\": \"foo\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"filter_logic\", \"type\"]",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "",
            "        custom_fields = (",
            "            CustomField(name=\"cf1\", type=\"text\"),",
            "            CustomField(name=\"cf2\", type=\"integer\"),",
            "            CustomField(name=\"cf3\", type=\"boolean\"),",
            "        )",
            "        for cf in custom_fields:",
            "            cf.validated_save()",
            "            cf.content_types.add(site_ct)",
            "",
            "    def test_create_object(self):",
            "        super(APIViewTestCases.APIViewTestCase, self).test_create_object()",
            "        # Verify that label is auto-populated when not specified",
            "        for create_data in self.create_data:",
            "            instance = self._get_queryset().get(name=create_data[\"name\"])",
            "            self.assertEqual(instance.label, create_data.get(\"label\", instance.name))",
            "",
            "",
            "class CustomFieldTestVersion14(CustomFieldTestVersion12):",
            "    \"\"\"Tests for the API version 1.4+ CustomField REST API.\"\"\"",
            "",
            "    api_version = \"1.4\"",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"label\": \"Custom Field 4\",",
            "            \"slug\": \"cf4\",",
            "            \"type\": \"date\",",
            "            \"weight\": 100,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\", \"dcim.device\"],",
            "            \"label\": \"Custom Field 5\",",
            "            \"slug\": \"cf5\",",
            "            \"type\": \"url\",",
            "            \"default\": \"http://example.com\",",
            "            \"weight\": 200,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"label\": \"Custom Field 6\",",
            "            \"slug\": \"cf6\",",
            "            \"type\": \"select\",",
            "            \"description\": \"A select custom field\",",
            "            \"weight\": 300,",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_types\": [\"dcim.site\"],",
            "        \"description\": \"New description\",",
            "        \"label\": \"Non-unique label\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "",
            "        custom_fields = (",
            "            CustomField(slug=\"cf1\", label=\"Custom Field 1\", type=\"text\"),",
            "            CustomField(slug=\"cf2\", label=\"Custom Field 2\", type=\"integer\"),",
            "            CustomField(slug=\"cf3\", label=\"Custom Field 3\", type=\"boolean\"),",
            "        )",
            "        for cf in custom_fields:",
            "            cf.validated_save()",
            "            cf.content_types.add(site_ct)",
            "",
            "    def test_create_object(self):",
            "        super(APIViewTestCases.APIViewTestCase, self).test_create_object()",
            "        # 2.0 TODO: #824 remove name entirely",
            "        # For now, check that name is correctly populated in the model even though it's not an API field.",
            "        for create_data in self.create_data:",
            "            instance = self._get_queryset().get(slug=create_data[\"slug\"])",
            "            self.assertEqual(instance.name, instance.slug)",
            "",
            "    def test_create_object_required_fields(self):",
            "        \"\"\"For this API version, `label` and `slug` are required fields.\"\"\"",
            "        self.add_permissions(\"extras.add_customfield\")",
            "",
            "        incomplete_data = {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"type\": \"date\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), incomplete_data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            response.data,",
            "            {\"slug\": [\"This field is required.\"], \"label\": [\"This field is required.\"]},",
            "        )",
            "",
            "",
            "class CustomLinkTest(APIViewTestCases.APIViewTestCase):",
            "    model = CustomLink",
            "    brief_fields = [\"content_type\", \"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"name\": \"api-test-4\",",
            "            \"text\": \"API customlink text 4\",",
            "            \"target_url\": \"http://api-test-4.com/test4\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"name\": \"api-test-5\",",
            "            \"text\": \"API customlink text 5\",",
            "            \"target_url\": \"http://api-test-5.com/test5\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"name\": \"api-test-6\",",
            "            \"text\": \"API customlink text 6\",",
            "            \"target_url\": \"http://api-test-6.com/test6\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "    ]",
            "    choices_fields = [\"button_class\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-1\",",
            "            text=\"API customlink text 1\",",
            "            target_url=\"http://api-test-1.com/test1\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-2\",",
            "            text=\"API customlink text 2\",",
            "            target_url=\"http://api-test-2.com/test2\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-3\",",
            "            text=\"API customlink text 3\",",
            "            target_url=\"http://api-test-3.com/test3\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "",
            "",
            "class DynamicGroupTestMixin:",
            "    \"\"\"Mixin for Dynamic Group test cases to re-use the same set of common fixtures.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create the objects required for devices.",
            "        sites = [",
            "            Site.objects.create(name=\"Site 1\", slug=\"site-1\"),",
            "            Site.objects.create(name=\"Site 2\", slug=\"site-2\"),",
            "            Site.objects.create(name=\"Site 3\", slug=\"site-3\"),",
            "        ]",
            "",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "            slug=\"device-type-1\",",
            "        )",
            "        device_role = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\", color=\"ff0000\")",
            "        status_active = Status.objects.get(slug=\"active\")",
            "        status_planned = Status.objects.get(slug=\"planned\")",
            "        Device.objects.create(",
            "            name=\"device-site-1\",",
            "            status=status_active,",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=sites[0],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-site-2\",",
            "            status=status_active,",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=sites[1],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-site-3\",",
            "            status=status_planned,",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=sites[2],",
            "        )",
            "",
            "        # Then the DynamicGroups.",
            "        cls.content_type = ContentType.objects.get_for_model(Device)",
            "        cls.groups = [",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 1\",",
            "                slug=\"api-dynamicgroup-1\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [\"active\"]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 2\",",
            "                slug=\"api-dynamicgroup-2\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [\"planned\"]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 3\",",
            "                slug=\"api-dynamicgroup-3\",",
            "                content_type=cls.content_type,",
            "                filter={\"site\": [\"site-3\"]},",
            "            ),",
            "        ]",
            "",
            "",
            "class DynamicGroupTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroup",
            "    brief_fields = [\"content_type\", \"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"API DynamicGroup 4\",",
            "            \"slug\": \"api-dynamicgroup-4\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"site\": [\"site-1\"]},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 5\",",
            "            \"slug\": \"api-dynamicgroup-5\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"has_interfaces\": False},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 6\",",
            "            \"slug\": \"api-dynamicgroup-6\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"site\": [\"site-2\"]},",
            "        },",
            "    ]",
            "",
            "    def test_get_members(self):",
            "        \"\"\"Test that the `/members/` API endpoint returns what is expected.\"\"\"",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        instance = DynamicGroup.objects.first()",
            "        member_count = instance.members.count()",
            "        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(member_count, len(response.json()[\"results\"]))",
            "",
            "",
            "class DynamicGroupMembershipTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroupMembership",
            "    brief_fields = [\"display\", \"group\", \"id\", \"operator\", \"parent_group\", \"url\", \"weight\"]",
            "    choices_fields = [\"operator\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super().setUpTestData()",
            "",
            "        parent = DynamicGroup.objects.create(",
            "            name=\"parent\",",
            "            slug=\"parent\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        parent2 = DynamicGroup.objects.create(",
            "            name=\"parent2\",",
            "            slug=\"parent2\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        group1, group2, group3 = cls.groups",
            "",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group1,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            weight=10,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group2,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "            weight=20,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group3,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            weight=30,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group1.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "                \"weight\": 10,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group2.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "                \"weight\": 20,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group3.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                \"weight\": 30,",
            "            },",
            "        ]",
            "",
            "",
            "class ExportTemplateTest(APIViewTestCases.APIViewTestCase):",
            "    model = ExportTemplate",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 4\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 5\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 6\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\", \"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Device)",
            "",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 1\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 2\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 3\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "",
            "",
            "class GitRepositoryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GitRepository",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    bulk_update_data = {",
            "        \"branch\": \"develop\",",
            "    }",
            "    choices_fields = [\"provided_contents\"]",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\", slug=\"secrets-group-1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\", slug=\"secrets-group-2\"),",
            "        )",
            "",
            "        cls.repos = (",
            "            GitRepository(",
            "                name=\"Repo 1\",",
            "                slug=\"repo-1\",",
            "                remote_url=\"https://example.com/repo1.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(",
            "                name=\"Repo 2\",",
            "                slug=\"repo-2\",",
            "                remote_url=\"https://example.com/repo2.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo-3\", remote_url=\"https://example.com/repo3.git\"),",
            "        )",
            "        for repo in cls.repos:",
            "            repo.validated_save(trigger_resync=False)",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"New Git Repository 1\",",
            "                \"slug\": \"new-git-repository-1\",",
            "                \"remote_url\": \"https://example.com/newrepo1.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 2\",",
            "                \"slug\": \"new-git-repository-2\",",
            "                \"remote_url\": \"https://example.com/newrepo2.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 3\",",
            "                \"slug\": \"new-git-repository-3\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 4\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "        ]",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_no_celery_worker(self, mock_get_worker_count):",
            "        \"\"\"Git sync cannot be triggered if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_nonexistent_repo(self, mock_get_worker_count):",
            "        \"\"\"Git sync request handles case of a nonexistent repository.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": \"11111111-1111-1111-1111-111111111111\"})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_without_permissions(self, mock_get_worker_count):",
            "        \"\"\"Git sync request verifies user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_with_permissions(self, mock_get_worker_count):",
            "        \"\"\"Git sync request can be submitted successfully.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_create_with_plugin_provided_contents(self):",
            "        \"\"\"Test that `provided_contents` published by a plugin works.\"\"\"",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = self._get_list_url()",
            "        data = {",
            "            \"name\": \"plugin_test\",",
            "            \"slug\": \"plugin-test\",",
            "            \"remote_url\": \"https://localhost/plugin-test\",",
            "            \"provided_contents\": [\"example_plugin.textfile\"],",
            "        }",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(list(response.data[\"provided_contents\"]), data[\"provided_contents\"])",
            "",
            "",
            "class GraphQLQueryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GraphQLQuery",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"graphql-query-4\",",
            "            \"slug\": \"graphql-query-4\",",
            "            \"query\": \"{ query: sites {name} }\",",
            "        },",
            "        {",
            "            \"name\": \"graphql-query-5\",",
            "            \"slug\": \"graphql-query-5\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "        },",
            "        {",
            "            \"name\": \"Graphql Query 6\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "        },",
            "    ]",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                slug=\"graphql-query-1\",",
            "                query=\"{ sites {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                slug=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                slug=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "        )",
            "",
            "        for query in cls.graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "    def test_run_saved_query(self):",
            "        \"\"\"Exercise the /run/ API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.add_graphqlquery\")",
            "        self.add_permissions(\"extras.change_graphqlquery\")",
            "        self.add_permissions(\"extras.view_graphqlquery\")",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[0].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"sites\": []}}, response.data)",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[2].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"devices\": []}}, response.data)",
            "",
            "",
            "# TODO(Glenn): Standardize to APIViewTestCase (needs create & update tests)",
            "class ImageAttachmentTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = ImageAttachment",
            "    brief_fields = [\"display\", \"id\", \"image\", \"name\", \"url\"]",
            "    choices_fields = [\"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Site)",
            "",
            "        site = Site.objects.create(name=\"Site 1\", slug=\"site-1\")",
            "",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=site.pk,",
            "            name=\"Image Attachment 1\",",
            "            image=\"http://example.com/image1.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=site.pk,",
            "            name=\"Image Attachment 2\",",
            "            image=\"http://example.com/image2.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=site.pk,",
            "            name=\"Image Attachment 3\",",
            "            image=\"http://example.com/image3.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "",
            "",
            "class JobAPIRunTestMixin:",
            "    \"\"\"",
            "    Mixin providing test cases for the \"run\" API endpoint, shared between the different versions of Job API testing.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        self.job_model.enabled = True",
            "        self.job_model.validated_save()",
            "",
            "    def get_run_url(self, class_path=\"local/api_test_job/APITestJob\"):",
            "        \"\"\"To be implemented by classes using this mixin.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    # Status code for successful submission of a job or schedule - to be set by subclasses",
            "    run_success_response_status = None",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_anonymous_not_permitted(self):",
            "        \"\"\"The run_job endpoint should NOT allow anonymous users to submit jobs.\"\"\"",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_without_permission(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_permissions(self, mock_get_worker_count):",
            "        \"\"\"The run_job endpoint should enforce object-level permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"module_name__in\": [\"test_pass\", \"test_fail\"]},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try post to unpermitted job",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "        # Try post to permitted job",
            "        job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"local/test_pass/TestPass\")",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_enabled(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.enabled flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job_model.enabled = False",
            "        job_model.save()",
            "",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_installed(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.installed flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job(",
            "            source=\"local\",",
            "            module_name=\"uninstalled_module\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Uninstalled Module\",",
            "            name=\"No such job\",",
            "            installed=False,",
            "            enabled=True,",
            "        )",
            "        job_model.validated_save()",
            "",
            "        url = self.get_run_url(\"local/uninstalled_module/NoSuchJob\")",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_405_METHOD_NOT_ALLOWED)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_no_worker(self, mock_get_worker_count):",
            "        \"\"\"Job run cannot be requested if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their primary keys.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"name\": \"test\",",
            "                \"interval\": \"future\",",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertEqual(schedule.kwargs[\"data\"][\"var4\"], str(device_role.pk))",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var_no_schedule(self, mock_get_worker_count):",
            "        \"\"\"",
            "        Run a job with `approval_required` without providing a schedule.",
            "",
            "        Assert an immediate schedule that enforces it.",
            "        \"\"\"",
            "        # Set approval_required=True",
            "        self.job_model.approval_required = True",
            "        self.job_model.save()",
            "",
            "        # Do the stuff.",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "            # schedule is omitted",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        # Assert that a JobResult was NOT created.",
            "        self.assertFalse(JobResult.objects.exists())",
            "",
            "        # Assert that we have an immediate ScheduledJob and that it matches the job_model.",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertIsNotNone(schedule)",
            "        self.assertEqual(schedule.interval, JobExecutionType.TYPE_IMMEDIATELY)",
            "        self.assertEqual(schedule.approval_required, self.job_model.approval_required)",
            "        self.assertEqual(schedule.kwargs[\"data\"][\"var4\"], str(device_role.pk))",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var_lookup(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": {\"name\": \"role\"},",
            "        }",
            "",
            "        # This handles things like ObjectVar fields looked up by non-UUID",
            "        # Jobs are executed with deserialized data",
            "        deserialized_data = get_job(\"local/api_test_job/APITestJob\").deserialize_data(job_data)",
            "",
            "        self.assertEqual(",
            "            deserialized_data,",
            "            {\"var1\": \"FooBar\", \"var2\": 123, \"var3\": False, \"var4\": device_role},",
            "        )",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, {\"data\": job_data}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.last()",
            "        self.assertIn(\"data\", job_result.job_kwargs)",
            "",
            "        # Ensure the stored job_kwargs deserialize to the same as originally inputted",
            "        self.assertEqual(",
            "            get_job(\"local/api_test_job/APITestJob\").deserialize_data(job_result.job_kwargs[\"data\"]), deserialized_data",
            "        )",
            "",
            "        return (response, job_result)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_commit(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_field_order/TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "            \"_commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"local/test_field_order/TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        return response  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_only(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_field_order/TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"local/test_field_order/TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        return response  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_schedule(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_field_order/TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "            \"_commit\": True,",
            "            \"_schedule_start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            \"_schedule_interval\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"local/test_field_order/TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        return response  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_for_future(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        # url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"interval\"][0],",
            "            \"Unable to schedule job: Job may have sensitive input variables\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_and_requires_approval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.has_sensitive_variables = True",
            "        job_model.approval_required = True",
            "        job_model.save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0],",
            "            \"Unable to run or schedule job: \"",
            "            \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "            \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_immediately(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "        job = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job.has_sensitive_variables = True",
            "        job.has_sensitive_variables_override = True",
            "        job.validated_save()",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.last()",
            "        self.assertEqual(job_result.job_kwargs, None)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future_past(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() - timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_interval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"hourly\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"data\": \"invalid\",",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": [\"Job data needs to be a dict\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_wrong_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var5\": \"wrong\",",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": {\"var5\": [\"Job data contained an unknown property\"]}})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_missing_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var3\": False,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data, {\"errors\": {\"var2\": [\"This field is required.\"], \"var4\": [\"This field is required.\"]}}",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_task_queue(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"task_queue\": \"invalid\",",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data,",
            "            {\"task_queue\": ['\"invalid\" is not a valid choice.']},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_valid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_default_queue_with_empty_job_model_task_queues(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        data = {",
            "            \"commit\": True,",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"local/test_pass/TestPass\")",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "",
            "class JobHookTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobHook",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    choices_fields = []",
            "    update_data = {",
            "        \"name\": \"Overridden name\",",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "    validation_excluded_fields = []",
            "    api_version = \"1.3\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobHook4\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook5\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverChange\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook6\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverFail\").pk,",
            "                \"enabled\": False,",
            "            },",
            "        ]",
            "        cls.job_hooks = (",
            "            JobHook(",
            "                name=\"JobHook1\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverLog\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook2\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverChange\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook3\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverFail\"),",
            "                type_delete=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for job_hook in cls.job_hooks:",
            "            job_hook.save()",
            "            job_hook.content_types.set([obj_type])",
            "",
            "    def test_validate_post(self):",
            "        \"\"\"POST a job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"name\": \"JobHook4\",",
            "            \"content_types\": [\"dcim.devicetype\"],",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_create\": False,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_jobhook\")",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "    def test_validate_patch(self):",
            "        \"\"\"PATCH an existing job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_jobhook\")",
            "        job_hook2 = JobHook.objects.get(name=\"JobHook2\")",
            "        response = self.client.patch(self._get_detail_url(job_hook2), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "",
            "class JobButtonTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobButton",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    choices_fields = [\"button_class\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobButton4\",",
            "                \"text\": \"JobButton4\",",
            "                \"content_types\": [\"dcim.region\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\").pk,",
            "            },",
            "            {",
            "                \"name\": \"JobButton5\",",
            "                \"text\": \"JobButton5\",",
            "                \"content_types\": [\"circuits.circuit\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            },",
            "        ]",
            "        site_type = ContentType.objects.get_for_model(Site)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        site_jb = JobButton(",
            "            name=\"api-test-site\",",
            "            text=\"API job button site text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        site_jb.save()",
            "        site_jb.content_types.set([site_type])",
            "",
            "        device_jb = JobButton.objects.create(",
            "            name=\"api-test-device\",",
            "            text=\"API job button device text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        device_jb.save()",
            "        device_jb.content_types.set([device_type])",
            "",
            "        complex_jb = JobButton.objects.create(",
            "            name=\"api-test-complex\",",
            "            text=\"API job button complex text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        complex_jb.save()",
            "        complex_jb.content_types.set([device_type, site_type])",
            "",
            "",
            "class JobTestVersion13(",
            "    JobAPIRunTestMixin,",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.UpdateObjectViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    \"\"\"Test cases for the Jobs REST API under API version 1.3 - first version introducing JobModel-based APIs.\"\"\"",
            "",
            "    model = Job",
            "    brief_fields = [\"display\", \"grouping\", \"id\", \"job_class_name\", \"module_name\", \"name\", \"slug\", \"source\", \"url\"]",
            "    choices_fields = None",
            "    update_data = {",
            "        # source, module_name, job_class_name, installed are NOT editable",
            "        \"grouping_override\": True,",
            "        \"grouping\": \"Overridden grouping\",",
            "        \"name_override\": True,",
            "        \"name\": \"Overridden name\",",
            "        \"slug\": \"overridden-slug\",",
            "        \"description_override\": True,",
            "        \"description\": \"This is an overridden description.\",",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"commit_default_override\": True,",
            "        \"commit_default\": False,",
            "        \"hidden_override\": True,",
            "        \"hidden\": True,",
            "        \"read_only_override\": True,",
            "        \"read_only\": True,",
            "        \"soft_time_limit_override\": True,",
            "        \"soft_time_limit\": 350.1,",
            "        \"time_limit_override\": True,",
            "        \"time_limit\": 650,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "        \"task_queues\": [\"default\", \"priority\"],",
            "        \"task_queues_override\": True,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "    }",
            "    validation_excluded_fields = []",
            "",
            "    run_success_response_status = status.HTTP_201_CREATED",
            "    api_version = \"1.3\"",
            "",
            "    def get_run_url(self, class_path=\"local/api_test_job/APITestJob\"):",
            "        job_model = Job.objects.get_for_class_path(class_path)",
            "        return reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "",
            "    def test_get_job_variables(self):",
            "        \"\"\"Test the job/<pk>/variables API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.view_job\")",
            "        route = get_route_for_model(self.model, \"variables\", api=True)",
            "        response = self.client.get(reverse(route, kwargs={\"pk\": self.job_model.pk}), **self.header)",
            "        self.assertEqual(4, len(response.data))  # 4 variables, in order",
            "        self.assertEqual(response.data[0], {\"name\": \"var1\", \"type\": \"StringVar\", \"required\": True})",
            "        self.assertEqual(response.data[1], {\"name\": \"var2\", \"type\": \"IntegerVar\", \"required\": True})",
            "        self.assertEqual(response.data[2], {\"name\": \"var3\", \"type\": \"BooleanVar\", \"required\": False})",
            "        self.assertEqual(",
            "            response.data[3],",
            "            {\"name\": \"var4\", \"type\": \"ObjectVar\", \"required\": True, \"model\": \"dcim.devicerole\"},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_job_with_sensitive_variables_set_approval_required_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job_model.has_sensitive_variables = True",
            "        job_model.has_sensitive_variables_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"approval_required\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_approval_required_job_set_has_sensitive_variables_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job_model.approval_required = True",
            "        job_model.approval_required_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"has_sensitive_variables\": True,",
            "            \"has_sensitive_variables_override\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"has_sensitive_variables\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_object_var(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, schedule = super().test_run_job_object_var()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"schedule\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"url\"],",
            "            \"http://nautobot.example.com\" + reverse(\"extras-api:scheduledjob-detail\", kwargs={\"pk\": schedule.pk}),",
            "        )",
            "        self.assertEqual(response.data[\"schedule\"][\"name\"], schedule.name)",
            "        self.assertEqual(response.data[\"schedule\"][\"start_time\"], schedule.start_time)",
            "        self.assertEqual(response.data[\"schedule\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_object_var_lookup(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, job_result = super().test_run_job_object_var_lookup()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertIsNone(response.data[\"schedule\"])",
            "        # The urls in a NestedJobResultSerializer depends on the request context, which we don't have",
            "        data_job_result = response.data[\"job_result\"]",
            "        del data_job_result[\"url\"]",
            "        del data_job_result[\"user\"][\"url\"]",
            "        expected_data_job_result = NestedJobResultSerializer(job_result, context={\"request\": None}).data",
            "        del expected_data_job_result[\"url\"]",
            "        del expected_data_job_result[\"user\"][\"url\"]",
            "        self.assertEqual(data_job_result, expected_data_job_result)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_future(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, schedule = super().test_run_job_future()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"schedule\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"url\"],",
            "            \"http://nautobot.example.com\" + reverse(\"extras-api:scheduledjob-detail\", kwargs={\"pk\": schedule.pk}),",
            "        )",
            "        self.assertEqual(response.data[\"schedule\"][\"name\"], schedule.name)",
            "        self.assertEqual(response.data[\"schedule\"][\"start_time\"], schedule.start_time)",
            "        self.assertEqual(response.data[\"schedule\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_future_schedule_kwargs_pk(self):",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify that kwargs['scheduled_job_pk'] was set in the scheduled job.\"\"\"",
            "        _, schedule = super().test_run_job_future()",
            "",
            "        self.assertEqual(schedule.kwargs[\"scheduled_job_pk\"], str(schedule.pk))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_interval(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, schedule = super().test_run_job_interval()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"schedule\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"url\"],",
            "            \"http://nautobot.example.com\" + reverse(\"extras-api:scheduledjob-detail\", kwargs={\"pk\": schedule.pk}),",
            "        )",
            "        self.assertEqual(response.data[\"schedule\"][\"name\"], schedule.name)",
            "        self.assertEqual(response.data[\"schedule\"][\"start_time\"], schedule.start_time)",
            "        self.assertEqual(response.data[\"schedule\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "",
            "class JobTestVersion12(",
            "    JobAPIRunTestMixin,",
            "    APITestCase,",
            "):",
            "    \"\"\"Test cases for the Jobs REST API under API version 1.2 - deprecated JobClass-based API pattern.\"\"\"",
            "",
            "    run_success_response_status = status.HTTP_200_OK",
            "    api_version = \"1.2\"",
            "",
            "    def get_run_url(self, class_path=\"local/api_test_job/APITestJob\"):",
            "        return reverse(\"extras-api:job-run\", kwargs={\"class_path\": class_path})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_list_jobs_anonymous(self):",
            "        url = reverse(\"extras-api:job-list\")",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_list_jobs_without_permission(self):",
            "        url = reverse(\"extras-api:job-list\")",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_list_jobs_with_permission(self):",
            "        self.add_permissions(\"extras.view_job\")",
            "        url = reverse(\"extras-api:job-list\")",
            "        response = self.client.get(url, **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        # At a minimum, the job provided by the example plugin should be present",
            "        self.assertNotEqual(response.data, [])",
            "        self.assertIn(",
            "            \"plugins/example_plugin.jobs/ExampleJob\",",
            "            [job[\"id\"] for job in response.data],",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_get_job_anonymous(self):",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/APITestJob\"})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_job_without_permission(self):",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/APITestJob\"})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_job_with_permission(self):",
            "        self.add_permissions(\"extras.view_job\")",
            "        # Try GET to permitted object",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/APITestJob\"})",
            "        response = self.client.get(url, **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"name\"], \"Job for API Tests\")",
            "        self.assertEqual(response.data[\"vars\"][\"var1\"], \"StringVar\")",
            "        self.assertEqual(response.data[\"vars\"][\"var2\"], \"IntegerVar\")",
            "        self.assertEqual(response.data[\"vars\"][\"var3\"], \"BooleanVar\")",
            "",
            "        # Try GET to non-existent object",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/NoSuchJob\"})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "",
            "class JobTestVersionDefault(JobTestVersion12):",
            "    \"\"\"",
            "    Test cases for the Jobs REST API when not explicitly requesting a specific API version.",
            "",
            "    Currently we default to version 1.2, but this may change in a future major release.",
            "    \"\"\"",
            "",
            "    api_version = None",
            "",
            "",
            "class JobResultTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = JobResult",
            "    brief_fields = [\"completed\", \"created\", \"display\", \"id\", \"name\", \"status\", \"url\", \"user\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        jobs = Job.objects.all()[:2]",
            "        job_ct = ContentType.objects.get_for_model(Job)",
            "        git_ct = ContentType.objects.get_for_model(GitRepository)",
            "",
            "        JobResult.objects.create(",
            "            job_model=jobs[0],",
            "            name=jobs[0].class_path,",
            "            obj_type=job_ct,",
            "            completed=datetime.now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_COMPLETED,",
            "            data={\"output\": \"\\nRan for 3 seconds\"},",
            "            job_kwargs=None,",
            "            schedule=None,",
            "            job_id=uuid.uuid4(),",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=None,",
            "            name=\"Git Repository\",",
            "            obj_type=git_ct,",
            "            completed=datetime.now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_COMPLETED,",
            "            data=None,",
            "            job_kwargs={\"repository_pk\": uuid.uuid4()},",
            "            schedule=None,",
            "            job_id=uuid.uuid4(),",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=jobs[1],",
            "            name=jobs[1].class_path,",
            "            obj_type=job_ct,",
            "            completed=None,",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_PENDING,",
            "            data=None,",
            "            job_kwargs={\"data\": {\"device\": uuid.uuid4(), \"multichoices\": [\"red\", \"green\"], \"checkbox\": False}},",
            "            schedule=None,",
            "            job_id=uuid.uuid4(),",
            "        )",
            "",
            "",
            "class JobLogEntryTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobLogEntry",
            "    brief_fields = [",
            "        \"absolute_url\",",
            "        \"created\",",
            "        \"display\",",
            "        \"grouping\",",
            "        \"id\",",
            "        \"job_result\",",
            "        \"log_level\",",
            "        \"log_object\",",
            "        \"message\",",
            "        \"url\",",
            "    ]",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.job_result = JobResult.objects.create(",
            "            name=\"test\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=ContentType.objects.get_for_model(GitRepository),",
            "        )",
            "",
            "        for log_level in (\"debug\", \"info\", \"success\", \"warning\"):",
            "            JobLogEntry.objects.create(",
            "                log_level=log_level,",
            "                grouping=\"run\",",
            "                job_result=cls.job_result,",
            "                message=f\"I am a {log_level} log.\",",
            "            )",
            "",
            "    def test_list_job_logs_from_job_results_detail(self):",
            "        \"\"\"Test `logs` endpoint from `JobResult` detail.\"\"\"",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "        url = reverse(\"extras-api:jobresult-logs\", kwargs={\"pk\": self.job_result.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertEqual(len(response.json()), JobLogEntry.objects.count())",
            "",
            "",
            "class ScheduledJobTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    brief_fields = [\"crontab\", \"display\", \"id\", \"interval\", \"name\", \"start_time\", \"url\"]",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=job_model.class_path,",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=job_model.class_path,",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=job_model.class_path,",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "",
            "class JobApprovalTest(APITestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.additional_user = User.objects.create(username=\"user1\", is_active=True)",
            "        cls.job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        cls.job_model.enabled = True",
            "        cls.job_model.save()",
            "        cls.scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=cls.job_model.class_path,",
            "            job_model=cls.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=cls.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_anonymous(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_change_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_same_user(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=self.job_model.class_path,",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=self.job_model.class_path,",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past_force(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=self.job_model.class_path,",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url + \"?force=true\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_delete_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIsNone(ScheduledJob.objects.filter(pk=self.scheduled_job.pk).first())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_dry_run_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job_without_run_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job(self):",
            "        self.add_permissions(\"extras.run_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "",
            "class NoteTest(APIViewTestCases.APIViewTestCase):",
            "    model = Note",
            "    brief_fields = [",
            "        \"assigned_object\",",
            "        \"display\",",
            "        \"id\",",
            "        \"note\",",
            "        \"slug\",",
            "        \"url\",",
            "        \"user\",",
            "    ]",
            "    choices_fields = [\"assigned_object_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site1 = Site.objects.create(name=\"Site 1\", slug=\"site-1\")",
            "        site2 = Site.objects.create(name=\"Site 2\", slug=\"site-2\")",
            "        ct = ContentType.objects.get_for_model(Site)",
            "        user1 = User.objects.create(username=\"user1\", is_active=True)",
            "        user2 = User.objects.create(username=\"user2\", is_active=True)",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": site1.pk,",
            "                \"assigned_object_type\": \"dcim.site\",",
            "            },",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": site2.pk,",
            "                \"assigned_object_type\": \"dcim.site\",",
            "            },",
            "            {",
            "                \"note\": \"This is a note on Site 1.\",",
            "                \"assigned_object_id\": site1.pk,",
            "                \"assigned_object_type\": \"dcim.site\",",
            "            },",
            "        ]",
            "        cls.bulk_update_data = {",
            "            \"note\": \"Bulk change.\",",
            "        }",
            "        Note.objects.create(",
            "            note=\"Site has been placed on maintenance.\",",
            "            user=user1,",
            "            assigned_object_type=ct,",
            "            assigned_object_id=site1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site maintenance has ended.\",",
            "            user=user1,",
            "            assigned_object_type=ct,",
            "            assigned_object_id=site1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site is under duress.\",",
            "            user=user2,",
            "            assigned_object_type=ct,",
            "            assigned_object_id=site2.pk,",
            "        )",
            "",
            "",
            "class RelationshipTest(APIViewTestCases.APIViewTestCase, RequiredRelationshipTestMixin):",
            "    model = Relationship",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Device VLANs\",",
            "            \"slug\": \"device-vlans\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"name\": \"Primary VLAN\",",
            "            \"slug\": \"primary-vlan\",",
            "            \"type\": \"one-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"name\": \"Primary Interface\",",
            "            \"slug\": \"primary-interface\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "        {",
            "            \"name\": \"Relationship 1\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "    ]",
            "",
            "    bulk_update_data = {",
            "        \"source_filter\": {\"slug\": [\"some-slug\"]},",
            "    }",
            "    choices_fields = [\"destination_type\", \"source_type\", \"type\", \"required_on\"]",
            "    slug_source = \"name\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_type = ContentType.objects.get_for_model(Site)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.relationships = (",
            "            Relationship(",
            "                name=\"Related Sites\",",
            "                slug=\"related-sites\",",
            "                type=\"symmetric-many-to-many\",",
            "                source_type=site_type,",
            "                destination_type=site_type,",
            "            ),",
            "            Relationship(",
            "                name=\"Unrelated Sites\",",
            "                slug=\"unrelated-sites\",",
            "                type=\"many-to-many\",",
            "                source_type=site_type,",
            "                source_label=\"Other sites (from source side)\",",
            "                destination_type=site_type,",
            "                destination_label=\"Other sites (from destination side)\",",
            "            ),",
            "            Relationship(",
            "                name=\"Devices found elsewhere\",",
            "                slug=\"devices-elsewhere\",",
            "                type=\"many-to-many\",",
            "                source_type=site_type,",
            "                destination_type=device_type,",
            "            ),",
            "        )",
            "        for relationship in cls.relationships:",
            "            relationship.validated_save()",
            "",
            "        cls.site = Site.objects.create(name=\"Site 1\", status=Status.objects.get(slug=\"active\"))",
            "",
            "    def test_get_all_relationships_on_site(self):",
            "        \"\"\"Verify that all relationships are accurately represented when requested.\"\"\"",
            "        self.add_permissions(\"dcim.view_site\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.site.pk}) + \"?include=relationships\", **self.header",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            {",
            "                self.relationships[0].slug: {",
            "                    \"id\": str(self.relationships[0].pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationships[0].pk})",
            "                    ),",
            "                    \"name\": self.relationships[0].name,",
            "                    \"type\": self.relationships[0].type,",
            "                    \"peer\": {",
            "                        \"label\": \"sites\",",
            "                        \"object_type\": \"dcim.site\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[1].slug: {",
            "                    \"id\": str(self.relationships[1].pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationships[1].pk})",
            "                    ),",
            "                    \"name\": self.relationships[1].name,",
            "                    \"type\": self.relationships[1].type,",
            "                    \"destination\": {",
            "                        \"label\": self.relationships[1].source_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.site\",",
            "                        \"objects\": [],",
            "                    },",
            "                    \"source\": {",
            "                        \"label\": self.relationships[1].destination_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.site\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[2].slug: {",
            "                    \"id\": str(self.relationships[2].pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationships[2].pk})",
            "                    ),",
            "                    \"name\": self.relationships[2].name,",
            "                    \"type\": self.relationships[2].type,",
            "                    \"destination\": {",
            "                        \"label\": \"devices\",",
            "                        \"object_type\": \"dcim.device\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "            },",
            "            response.data[\"relationships\"],",
            "        )",
            "",
            "    def test_populate_relationship_associations_on_site_create(self):",
            "        \"\"\"Verify that relationship associations can be populated at instance creation time.\"\"\"",
            "        existing_site_1 = Site.objects.create(name=\"Existing Site 1\", status=Status.objects.get(slug=\"active\"))",
            "        existing_site_2 = Site.objects.create(name=\"Existing Site 2\", status=Status.objects.get(slug=\"active\"))",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "            slug=\"device-type-1\",",
            "        )",
            "        device_role = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\", color=\"ff0000\")",
            "        existing_device_1 = Device.objects.create(",
            "            name=\"existing-device-site-1\",",
            "            status=Status.objects.get(slug=\"active\"),",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=existing_site_1,",
            "        )",
            "        existing_device_2 = Device.objects.create(",
            "            name=\"existing-device-site-2\",",
            "            status=Status.objects.get(slug=\"active\"),",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=existing_site_2,",
            "        )",
            "",
            "        self.add_permissions(\"dcim.view_site\", \"dcim.add_site\", \"extras.add_relationshipassociation\")",
            "        response = self.client.post(",
            "            reverse(\"dcim-api:site-list\"),",
            "            data={",
            "                \"name\": \"New Site\",",
            "                \"status\": \"active\",",
            "                \"relationships\": {",
            "                    self.relationships[0].slug: {",
            "                        \"peer\": {",
            "                            \"objects\": [str(existing_site_1.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[1].slug: {",
            "                        \"source\": {",
            "                            \"objects\": [str(existing_site_2.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[2].slug: {",
            "                        \"destination\": {",
            "                            \"objects\": [",
            "                                {\"name\": \"existing-device-site-1\"},",
            "                                {\"name\": \"existing-device-site-2\"},",
            "                            ],",
            "                        },",
            "                    },",
            "                },",
            "            },",
            "            format=\"json\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        new_site_id = response.data[\"id\"]",
            "        # Peer case - don't distinguish source/destination",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[0],",
            "                source_type=self.relationships[0].source_type,",
            "                source_id__in=[existing_site_1.pk, new_site_id],",
            "                destination_type=self.relationships[0].destination_type,",
            "                destination_id__in=[existing_site_1.pk, new_site_id],",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[1],",
            "                source_type=self.relationships[1].source_type,",
            "                source_id=existing_site_2.pk,",
            "                destination_type=self.relationships[1].destination_type,",
            "                destination_id=new_site_id,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_site_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_1.pk,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_site_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_2.pk,",
            "            ).exists()",
            "        )",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test various bulk create/edit scenarios",
            "        \"\"\"",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"api\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        # VLAN endpoint to POST, PATCH and PUT multiple objects to:",
            "        vlan_list_endpoint = reverse(get_route_for_model(VLAN, \"list\", api=True))",
            "",
            "        def send_bulk_data(http_method, data):",
            "            return getattr(self.client, http_method)(",
            "                vlan_list_endpoint,",
            "                data=data,",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "",
            "        # Try deleting all devices and then creating 2 VLANs (fails):",
            "        Device.objects.all().delete()",
            "        response = send_bulk_data(",
            "            \"post\", data=[{\"vid\": \"1\", \"name\": \"1\", \"status\": \"active\"}, {\"vid\": \"2\", \"name\": \"2\", \"status\": \"active\"}]",
            "        )",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            {",
            "                \"relationships\": {",
            "                    \"vlans-devices-m2m\": [",
            "                        \"VLANs require at least one device, but no devices exist yet. \"",
            "                        \"Create a device by posting to /api/dcim/devices/\",",
            "                        'You need to specify [\"relationships\"][\"vlans-devices-m2m\"][\"source\"][\"objects\"].',",
            "                    ]",
            "                }",
            "            },",
            "            response.json(),",
            "        )",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "        required_relationship_json = {\"vlans-devices-m2m\": {\"source\": {\"objects\": [str(device_for_association.id)]}}}",
            "        expected_error_json = {",
            "            \"relationships\": {",
            "                \"vlans-devices-m2m\": [",
            "                    'You need to specify [\"relationships\"][\"vlans-devices-m2m\"][\"source\"][\"objects\"].'",
            "                ]",
            "            }",
            "        }",
            "",
            "        # Test POST, PATCH and PUT",
            "        for method in [\"post\", \"patch\", \"put\"]:",
            "            if method == \"post\":",
            "                vlan1_json_data = {",
            "                    \"vid\": \"1\",",
            "                    \"name\": \"1\",",
            "                    \"status\": \"active\",",
            "                }",
            "                vlan2_json_data = {",
            "                    \"vid\": \"2\",",
            "                    \"name\": \"2\",",
            "                    \"status\": \"active\",",
            "                }",
            "            else:",
            "                vlan1, vlan2 = VLANFactory.create_batch(2)",
            "                vlan1_json_data = {\"status\": \"active\", \"id\": str(vlan1.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan1_json_data.update({\"vid\": vlan1.vid, \"name\": vlan1.name})",
            "",
            "                vlan2_json_data = {\"status\": \"active\", \"id\": str(vlan2.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan2_json_data.update({\"vid\": vlan2.vid, \"name\": vlan2.name})",
            "",
            "            # Try method without specifying required relationships for either vlan1 or vlan2 (fails)",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for just vlan1 (fails)",
            "            vlan1_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for both vlan1 and vlan2 (succeeds)",
            "            vlan2_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            if method == \"post\":",
            "                self.assertHttpStatus(response, 201)",
            "            else:",
            "                self.assertHttpStatus(response, 200)",
            "",
            "            # Check the relationship associations were actually created",
            "            for vlan in response.json():",
            "                associated_device = vlan[\"relationships\"][\"vlans-devices-m2m\"][\"source\"][\"objects\"][0]",
            "                self.assertEqual(str(device_for_association.id), associated_device[\"id\"])",
            "",
            "",
            "class RelationshipAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = RelationshipAssociation",
            "    brief_fields = [\"destination_id\", \"display\", \"id\", \"relationship\", \"source_id\", \"url\"]",
            "    choices_fields = [\"destination_type\", \"source_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.site_type = ContentType.objects.get_for_model(Site)",
            "        cls.device_type = ContentType.objects.get_for_model(Device)",
            "        cls.status_active = Status.objects.get(slug=\"active\")",
            "",
            "        cls.relationship = Relationship(",
            "            name=\"Devices found elsewhere\",",
            "            slug=\"elsewhere-devices\",",
            "            type=\"many-to-many\",",
            "            source_type=cls.site_type,",
            "            destination_type=cls.device_type,",
            "        )",
            "        cls.relationship.validated_save()",
            "        cls.sites = (",
            "            Site.objects.create(name=\"Empty Site\", slug=\"empty\", status=cls.status_active),",
            "            Site.objects.create(name=\"Occupied Site\", slug=\"occupied\", status=cls.status_active),",
            "            Site.objects.create(name=\"Another Empty Site\", slug=\"another-empty\", status=cls.status_active),",
            "        )",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        cls.devices = (",
            "            Device.objects.create(",
            "                name=\"Device 1\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 2\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 3\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 4\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "        )",
            "",
            "        cls.associations = (",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.site_type,",
            "                source_id=cls.sites[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[0].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.site_type,",
            "                source_id=cls.sites[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[1].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.site_type,",
            "                source_id=cls.sites[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[2].pk,",
            "            ),",
            "        )",
            "        for association in cls.associations:",
            "            association.validated_save()",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.site\",",
            "                \"source_id\": cls.sites[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[0].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.site\",",
            "                \"source_id\": cls.sites[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[1].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.site\",",
            "                \"source_id\": cls.sites[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[2].pk,",
            "            },",
            "        ]",
            "",
            "    def test_create_invalid_relationship_association(self):",
            "        \"\"\"Test creation of invalid relationship association restricted by destination/source filter.\"\"\"",
            "",
            "        relationship = Relationship.objects.create(",
            "            name=\"Device to Site Rel 1\",",
            "            slug=\"device-to-site-rel-1\",",
            "            source_type=self.device_type,",
            "            source_filter={\"name\": [self.devices[0].name]},",
            "            destination_type=self.site_type,",
            "            destination_label=\"Primary Rack\",",
            "            type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            destination_filter={\"name\": [self.sites[0].name]},",
            "        )",
            "",
            "        associations = [",
            "            (",
            "                \"destination\",  # side",
            "                self.sites[2].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[0].pk,",
            "                    \"destination_type\": \"dcim.site\",",
            "                    \"destination_id\": self.sites[2].pk,",
            "                },",
            "            ),",
            "            (",
            "                \"source\",  # side",
            "                self.devices[1].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[1].pk,",
            "                    \"destination_type\": \"dcim.site\",",
            "                    \"destination_id\": self.sites[0].pk,",
            "                },",
            "            ),",
            "        ]",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        for side, field_error_name, data in associations:",
            "            response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                response.data[side],",
            "                [f\"{field_error_name} violates {relationship.name} {side}_filter restriction\"],",
            "            )",
            "",
            "    def test_model_clean_method_is_called(self):",
            "        \"\"\"Validate RelationshipAssociation clean method is called\"\"\"",
            "",
            "        data = {",
            "            \"relationship\": self.relationship.pk,",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_id\": self.sites[2].pk,",
            "            \"destination_type\": \"dcim.device\",",
            "            \"destination_id\": self.devices[2].pk,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"source_type\"], [f\"source_type has a different value than defined in {self.relationship}\"]",
            "        )",
            "",
            "    def test_get_association_data_on_site(self):",
            "        \"\"\"",
            "        Check that `include=relationships` query parameter on a model endpoint includes relationships/associations.",
            "        \"\"\"",
            "        self.add_permissions(\"dcim.view_site\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.sites[0].pk}) + \"?include=relationships\", **self.header",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        # Ensure consistent ordering",
            "        response.data[\"relationships\"][self.relationship.slug][\"destination\"][\"objects\"].sort(key=lambda v: v[\"name\"])",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            {",
            "                self.relationship.slug: {",
            "                    \"id\": str(self.relationship.pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationship.pk})",
            "                    ),",
            "                    \"name\": self.relationship.name,",
            "                    \"type\": \"many-to-many\",",
            "                    \"destination\": {",
            "                        \"label\": \"devices\",",
            "                        \"object_type\": \"dcim.device\",",
            "                        \"objects\": [",
            "                            {",
            "                                \"id\": str(self.devices[0].pk),",
            "                                \"url\": (",
            "                                    \"http://nautobot.example.com\"",
            "                                    + reverse(\"dcim-api:device-detail\", kwargs={\"pk\": self.devices[0].pk})",
            "                                ),",
            "                                \"display\": self.devices[0].display,",
            "                                \"name\": self.devices[0].name,",
            "                            },",
            "                            {",
            "                                \"id\": str(self.devices[1].pk),",
            "                                \"url\": (",
            "                                    \"http://nautobot.example.com\"",
            "                                    + reverse(\"dcim-api:device-detail\", kwargs={\"pk\": self.devices[1].pk})",
            "                                ),",
            "                                \"display\": self.devices[1].display,",
            "                                \"name\": self.devices[1].name,",
            "                            },",
            "                            {",
            "                                \"id\": str(self.devices[2].pk),",
            "                                \"url\": (",
            "                                    \"http://nautobot.example.com\"",
            "                                    + reverse(\"dcim-api:device-detail\", kwargs={\"pk\": self.devices[2].pk})",
            "                                ),",
            "                                \"display\": self.devices[2].display,",
            "                                \"name\": self.devices[2].name,",
            "                            },",
            "                        ],",
            "                    },",
            "                },",
            "            },",
            "            response.data[\"relationships\"],",
            "        )",
            "",
            "    def test_update_association_data_on_site(self):",
            "        \"\"\"",
            "        Check that relationship-associations can be updated via the 'relationships' field.",
            "        \"\"\"",
            "        self.add_permissions(",
            "            \"dcim.view_site\",",
            "            \"dcim.change_site\",",
            "            \"extras.add_relationshipassociation\",",
            "            \"extras.delete_relationshipassociation\",",
            "        )",
            "        initial_response = self.client.get(",
            "            reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.sites[0].pk}) + \"?include=relationships\", **self.header",
            "        )",
            "        self.assertHttpStatus(initial_response, status.HTTP_200_OK)",
            "",
            "        url = reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.sites[0].pk})",
            "",
            "        with self.subTest(\"Round-trip of same relationships data is a no-op\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": initial_response.data[\"relationships\"]},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Omitting relationships data entirely is valid\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: nonexistent relationship\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"nonexistent-relationship\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]), '\"nonexistent-relationship\" is not a relationship on dcim.Site'",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship\"):",
            "            Relationship.objects.create(",
            "                name=\"Device-to-Device\",",
            "                slug=\"device-to-device\",",
            "                source_type=self.device_type,",
            "                destination_type=self.device_type,",
            "                type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            )",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"device-to-device\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]), '\"device-to-device\" is not a relationship on dcim.Site'",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship side\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {self.relationship.slug: {\"source\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]),",
            "                '\"source\" is not a valid side for \"Devices found elsewhere\" on dcim.Site',",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Valid data: create/no-op/delete on RelationshipAssociations\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {",
            "                    \"relationships\": {",
            "                        self.relationship.slug: {",
            "                            \"destination\": {",
            "                                \"objects\": [",
            "                                    # remove devices[0] by omission",
            "                                    str(self.devices[1].pk),  # existing device identified by PK",
            "                                    {\"name\": self.devices[2].name},  # existing device identified by attributes",
            "                                    {\"id\": self.devices[3].pk},  # new device association",
            "                                ]",
            "                            }",
            "                        }",
            "                    },",
            "                },",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            # Removed association",
            "            self.assertFalse(RelationshipAssociation.objects.filter(pk=self.associations[0].pk).exists())",
            "            # Unchanged associations",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[1].pk).exists())",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[2].pk).exists())",
            "            # Created association",
            "            self.assertTrue(RelationshipAssociation.objects.filter(destination_id=self.devices[3].pk).exists())",
            "",
            "",
            "class SecretTest(APIViewTestCases.APIViewTestCase):",
            "    model = Secret",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    bulk_update_data = {}",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"NAPALM Username\",",
            "            \"provider\": \"environment-variable\",",
            "            \"description\": \"Username for all NAPALM devices\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_USERNAME\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"NAPALM Password\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_PASSWORD\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"GitHub Token for My Repository\",",
            "            \"slug\": \"github-token-my-repository\",",
            "            \"provider\": \"text-file\",",
            "            \"parameters\": {",
            "                \"path\": \"/github-tokens/user/myusername.txt\",",
            "            },",
            "        },",
            "    ]",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"api-test-1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_1\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "    def test_secret_check(self):",
            "        \"\"\"",
            "        Ensure that we can check the validity of a secret.",
            "        \"\"\"",
            "",
            "        with self.subTest(\"Secret is not accessible\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-not-accessible\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-matter\"},",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "        self.add_permissions(\"extras.view_secret\")",
            "",
            "        with self.subTest(\"Secret check successful\"):",
            "            with tempfile.NamedTemporaryFile() as secret_file:",
            "                secret_file.write(b\"HELLO WORLD\")",
            "                test_secret = Secret.objects.create(",
            "                    name=\"secret-check-test-accessible\",",
            "                    provider=\"text-file\",",
            "                    parameters={\"path\": secret_file.name},",
            "                )",
            "                response = self.client.get(",
            "                    reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header",
            "                )",
            "                self.assertHttpStatus(response, status.HTTP_200_OK)",
            "                self.assertEqual(response.data[\"result\"], True)",
            "",
            "        with self.subTest(\"Secret check failed\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-failed\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-exist\"},",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(response.data[\"result\"], False)",
            "            self.assertIn(\"SecretValueNotFoundError\", response.data[\"message\"])",
            "",
            "",
            "class SecretsGroupTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroup",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    bulk_update_data = {}",
            "",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\", slug=\"group-a\"),",
            "            SecretsGroup.objects.create(name=\"Group B\", slug=\"group-b\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", slug=\"group-c\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Secrets Group 1\",",
            "                \"slug\": \"secrets-group-1\",",
            "                \"description\": \"First Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 2\",",
            "                \"description\": \"Second Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 3\",",
            "                \"description\": \"Third Secrets Group\",",
            "            },",
            "        ]",
            "",
            "",
            "class SecretsGroupAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroupAssociation",
            "    brief_fields = [\"access_type\", \"display\", \"id\", \"secret\", \"secret_type\", \"url\"]",
            "    bulk_update_data = {}",
            "    choices_fields = [\"access_type\", \"secret_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-3\", provider=\"environment-variable\", parameters={\"variable\": \"YET_ANOTHER\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\", slug=\"group-a\"),",
            "            SecretsGroup.objects.create(name=\"Group B\", slug=\"group-b\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", slug=\"group-c\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[2],",
            "            group=secrets_groups[2],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"group\": secrets_groups[0].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[0].pk,",
            "            },",
            "            {",
            "                \"group\": secrets_groups[1].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[1].pk,",
            "            },",
            "            {",
            "                \"group\": secrets_groups[2].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[2].pk,",
            "            },",
            "        ]",
            "",
            "",
            "class StatusTest(APIViewTestCases.APIViewTestCase):",
            "    model = Status",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    bulk_update_data = {",
            "        \"color\": \"000000\",",
            "    }",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Pizza\",",
            "            \"slug\": \"pizza\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.device\", \"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Oysters\",",
            "            \"slug\": \"oysters\",",
            "            \"color\": \"00ff00\",",
            "            \"content_types\": [\"ipam.ipaddress\", \"ipam.prefix\"],",
            "        },",
            "        {",
            "            \"name\": \"Bad combinations\",",
            "            \"slug\": \"bad-combinations\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "        {",
            "            \"name\": \"Status 1\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "    ]",
            "    slug_source = \"name\"",
            "",
            "",
            "class TagTestVersion12(APIViewTestCases.APIViewTestCase):",
            "    model = Tag",
            "    brief_fields = [\"color\", \"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"Tag 4\",",
            "            \"slug\": \"tag-4\",",
            "        },",
            "        {",
            "            \"name\": \"Tag 5\",",
            "            \"slug\": \"tag-5\",",
            "        },",
            "        {",
            "            \"name\": \"Tag 6\",",
            "            \"slug\": \"tag-6\",",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "",
            "    def test_all_relevant_content_types_assigned_to_tags_with_empty_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "",
            "        self.client.post(self._get_list_url(), self.create_data[0], format=\"json\", **self.header)",
            "",
            "        tag = Tag.objects.get(slug=self.create_data[0][\"slug\"])",
            "        self.assertEqual(",
            "            tag.content_types.count(),",
            "            TaggableClassesQuery().as_queryset().count(),",
            "        )",
            "",
            "",
            "class TagTestVersion13(",
            "    APIViewTestCases.CreateObjectViewTestCase,",
            "    APIViewTestCases.UpdateObjectViewTestCase,",
            "):",
            "    model = Tag",
            "    brief_fields = [\"color\", \"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    api_version = \"1.3\"",
            "    create_data = [",
            "        {\"name\": \"Tag 4\", \"slug\": \"tag-4\", \"content_types\": [Site._meta.label_lower]},",
            "        {\"name\": \"Tag 5\", \"slug\": \"tag-5\", \"content_types\": [Site._meta.label_lower]},",
            "        {\"name\": \"Tag 6\", \"slug\": \"tag-6\", \"content_types\": [Site._meta.label_lower]},",
            "    ]",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.update_data = {",
            "            \"name\": \"A new tag name\",",
            "            \"slug\": \"a-new-tag-name\",",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "        cls.bulk_update_data = {",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()]",
            "        }",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "",
            "        # VLANGroup is an OrganizationalModel, not a PrimaryModel, and therefore does not support tags",
            "        data = {**self.create_data[0], \"content_types\": [VLANGroup._meta.label_lower]}",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "",
            "        tag = Tag.objects.filter(slug=data[\"slug\"])",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(f\"Invalid content type: {VLANGroup._meta.label_lower}\", response.data[\"content_types\"])",
            "",
            "    def test_create_tags_without_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        data = {",
            "            \"name\": \"Tag 8\",",
            "            \"slug\": \"tag-8\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(str(response.data[\"content_types\"][0]), \"This field is required.\")",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.filter(content_types=ContentType.objects.get_for_model(Site)).first()",
            "        site = Site.objects.create(name=\"site 1\", slug=\"site-1\")",
            "        site.tags.add(tag_1)",
            "",
            "        tag_content_types = list(tag_1.content_types.all())",
            "        tag_content_types.remove(ContentType.objects.get_for_model(Site))",
            "",
            "        url = self._get_detail_url(tag_1)",
            "        data = {\"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types]}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            str(response.data[\"content_types\"][0]), \"Unable to remove dcim.site. Dependent objects were found.\"",
            "        )",
            "",
            "    def test_update_tag_content_type_unchanged(self):",
            "        \"\"\"Test updating a tag without changing its content-types.\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag = Tag.objects.exclude(content_types=ContentType.objects.get_for_model(Site)).first()",
            "        tag_content_types = list(tag.content_types.all())",
            "        url = self._get_detail_url(tag)",
            "        data = {\"color\": ColorChoices.COLOR_LIME}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"color\"], ColorChoices.COLOR_LIME)",
            "        self.assertEqual(",
            "            sorted(response.data[\"content_types\"]), sorted([f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types])",
            "        )",
            "",
            "        tag.refresh_from_db()",
            "        self.assertEqual(tag.color, ColorChoices.COLOR_LIME)",
            "        self.assertEqual(list(tag.content_types.all()), tag_content_types)",
            "",
            "",
            "class WebhookTest(APIViewTestCases.APIViewTestCase):",
            "    model = Webhook",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-4\",",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://example.com/test4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-5\",",
            "            \"type_update\": True,",
            "            \"payload_url\": \"http://example.com/test5\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-6\",",
            "            \"type_delete\": True,",
            "            \"payload_url\": \"http://example.com/test6\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "    ]",
            "    choices_fields = [\"http_method\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.webhooks = (",
            "            Webhook(",
            "                name=\"api-test-1\",",
            "                type_create=True,",
            "                payload_url=\"http://example.com/test1\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-2\",",
            "                type_update=True,",
            "                payload_url=\"http://example.com/test2\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-3\",",
            "                type_delete=True,",
            "                payload_url=\"http://example.com/test3\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for webhook in cls.webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "    def test_create_webhooks_with_diff_content_type_same_url_same_action(self):",
            "        \"\"\"",
            "        Create a new webhook with diffrent content_types, same url and same action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | console port, create, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_diff_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and diff action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, delete, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_common_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and common action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, create, update, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0][\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )",
            "",
            "    def test_patch_webhooks_with_same_content_type_same_url_common_action(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        self.webhooks[2].payload_url = self.webhooks[1].payload_url",
            "        self.webhooks[2].save()",
            "",
            "        data = {\"type_update\": True}",
            "",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            f\"A webhook already exists for update on dcim | device type to URL {self.webhooks[1].payload_url}\",",
            "        )",
            "",
            "    def test_patch_webhooks(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        instance = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=self.webhooks[1].payload_url,",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"type_delete\": True}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"content_types\": [\"dcim.device\"]}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"payload_url\": \"http://example.com/test4\"}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_invalid_webhooks_patch(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        # Test patch payload_url with conflicts",
            "        instance_1 = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=\"http://example.com/test4\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_1.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"payload_url\": \"http://example.com/test2\"}",
            "        response = self.client.patch(self._get_detail_url(instance_1), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            \"A webhook already exists for update on dcim | device type to URL http://example.com/test2\",",
            "        )",
            "",
            "        # Test patch content_types with conflicts",
            "        instance_2 = Webhook.objects.create(",
            "            name=\"api-test-5\",",
            "            type_create=True,",
            "            payload_url=\"http://example.com/test1\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_2.content_types.set([ContentType.objects.get_for_model(Device)])",
            "",
            "        data = {\"content_types\": [\"dcim.devicetype\"]}",
            "        response = self.client.patch(self._get_detail_url(instance_2), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )"
        ],
        "afterPatchFile": [
            "from datetime import datetime, timedelta",
            "import uuid",
            "import tempfile",
            "from unittest import mock",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils.timezone import make_aware, now",
            "from rest_framework import status",
            "",
            "from nautobot.dcim.models import (",
            "    Device,",
            "    DeviceRedundancyGroup,",
            "    DeviceRole,",
            "    DeviceType,",
            "    Manufacturer,",
            "    Rack,",
            "    RackGroup,",
            "    RackRole,",
            "    Site,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.api.nested_serializers import NestedJobResultSerializer",
            "from nautobot.extras.api.serializers import ConfigContextSerializer",
            "from nautobot.extras.choices import (",
            "    DynamicGroupOperatorChoices,",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    RelationshipTypeChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            ")",
            "from nautobot.extras.jobs import get_job",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.models.jobs import JobHook, JobButton",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import TaggableClassesQuery",
            "from nautobot.ipam.factory import VLANFactory",
            "from nautobot.ipam.models import VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.choices import ColorChoices",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.testing import APITestCase, APIViewTestCases",
            "from nautobot.utilities.testing.utils import disable_warnings",
            "from nautobot.utilities.utils import get_route_for_model, slugify_dashes_to_underscores",
            "",
            "",
            "User = get_user_model()",
            "",
            "",
            "class AppTest(APITestCase):",
            "    def test_root(self):",
            "        url = reverse(\"extras-api:api-root\")",
            "        response = self.client.get(f\"{url}?format=api\", **self.header)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldTest(APIViewTestCases.APIViewTestCase):",
            "    model = ComputedField",
            "    brief_fields = [",
            "        \"content_type\",",
            "        \"display\",",
            "        \"id\",",
            "        \"label\",",
            "        \"url\",",
            "    ]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"slug\": \"cf4\",",
            "            \"label\": \"Computed Field 4\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"slug\": \"cf5\",",
            "            \"label\": \"Computed Field 5\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"slug\": \"cf6\",",
            "            \"label\": \"Computed Field 6\",",
            "            \"template\": \"{{ obj.name }}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"label\": \"Computed Field 7\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_type\": \"dcim.site\",",
            "        \"slug\": \"cf1\",",
            "        \"label\": \"My Computed Field\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "",
            "        ComputedField.objects.create(",
            "            slug=\"cf1\",",
            "            label=\"Computed Field One\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=site_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            slug=\"cf2\",",
            "            label=\"Computed Field Two\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=site_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            slug=\"cf3\",",
            "            label=\"Computed Field Three\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=site_ct,",
            "        )",
            "",
            "        cls.site = Site.objects.create(name=\"Site 1\", slug=\"site-1\")",
            "",
            "    def test_computed_field_include(self):",
            "        \"\"\"Test that explicitly including a computed field behaves as expected.\"\"\"",
            "        self.add_permissions(\"dcim.view_site\")",
            "        url = reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.site.pk})",
            "",
            "        # First get the object without computed fields.",
            "        response = self.client.get(url, **self.header)",
            "        self.assertNotIn(\"computed_fields\", response.json())",
            "",
            "        # Now get it with computed fields.",
            "        params = {\"include\": \"computed_fields\"}",
            "        response = self.client.get(url, data=params, **self.header)",
            "        self.assertIn(\"computed_fields\", response.json())",
            "",
            "",
            "class ConfigContextTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContext",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContext.objects.create(name=\"Config Context 1\", weight=100, data={\"foo\": 123})",
            "        ConfigContext.objects.create(name=\"Config Context 2\", weight=200, data={\"bar\": 456})",
            "        ConfigContext.objects.create(name=\"Config Context 3\", weight=300, data={\"baz\": 789})",
            "",
            "        device_redundancy_groups = DeviceRedundancyGroup.objects.all()[:2]",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Config Context 4\",",
            "                \"device_redundancy_groups\": [device_redundancy_groups[0].pk, device_redundancy_groups[1].pk],",
            "                \"data\": {\"more_foo\": True},",
            "            },",
            "            {",
            "                \"name\": \"Config Context 5\",",
            "                \"device_redundancy_groups\": [device_redundancy_groups[1].pk],",
            "                \"data\": {\"more_bar\": False},",
            "            },",
            "            {",
            "                \"name\": \"Config Context 6\",",
            "                \"data\": {\"more_baz\": None},",
            "            },",
            "        ]",
            "",
            "    def test_render_configcontext_for_object(self):",
            "        \"\"\"",
            "        Test rendering config context data for a device.",
            "        \"\"\"",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        site = Site.objects.create(name=\"Site-1\", slug=\"site-1\")",
            "        device = Device.objects.create(name=\"Device 1\", device_type=devicetype, device_role=devicerole, site=site)",
            "",
            "        # Test default config contexts (created at test setup)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 123)",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        self.assertEqual(rendered_context[\"baz\"], 789)",
            "",
            "        # Test API response as well",
            "        self.add_permissions(\"dcim.view_device\")",
            "        device_url = reverse(\"dcim-api:device-detail\", kwargs={\"pk\": device.pk})",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"], {\"foo\": 123, \"bar\": 456, \"baz\": 789}, response.data)",
            "",
            "        # Add another context specific to the site",
            "        configcontext4 = ConfigContext(name=\"Config Context 4\", data={\"site_data\": \"ABC\"})",
            "        configcontext4.save()",
            "        configcontext4.sites.add(site)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"site_data\"], \"ABC\")",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"site_data\"], \"ABC\", response.data[\"config_context\"])",
            "",
            "        # Override one of the default contexts",
            "        configcontext5 = ConfigContext(name=\"Config Context 5\", weight=2000, data={\"foo\": 999})",
            "        configcontext5.save()",
            "        configcontext5.sites.add(site)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 999)",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"foo\"], 999, response.data[\"config_context\"])",
            "",
            "        # Add a context which does NOT match our device and ensure it does not apply",
            "        site2 = Site.objects.create(name=\"Site 2\", slug=\"site-2\")",
            "        configcontext6 = ConfigContext(name=\"Config Context 6\", weight=2000, data={\"bar\": 999})",
            "        configcontext6.save()",
            "        configcontext6.sites.add(site2)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        response = self.client.get(device_url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"bar\"], 456, response.data[\"config_context\"])",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {\"name\": \"Config Context with schema\", \"weight\": 100, \"data\": {\"foo\": \"bar\"}, \"schema\": str(schema.pk)}",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(response.data[\"schema\"][\"id\"], str(schema.pk))",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 100,",
            "            \"data\": {\"foo\": \"bar\"},",
            "            \"schema\": str(schema.pk),",
            "        }",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=True)",
            "    def test_with_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is present when feature flag is enabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertIn(\"dynamic_groups\", serializer.fields)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=False)",
            "    def test_without_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is NOT present the when feature flag is disabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertNotIn(\"dynamic_groups\", serializer.fields)",
            "",
            "",
            "class ConfigContextSchemaTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContextSchema",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"Schema 4\",",
            "            \"slug\": \"schema-4\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 5\",",
            "            \"slug\": \"schema-5\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 6\",",
            "            \"slug\": \"schema-6\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 7\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = []",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", slug=\"schema-2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", slug=\"schema-3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "",
            "class ContentTypeTest(APITestCase):",
            "    \"\"\"",
            "    ContentTypeViewSet does not have permission checks,",
            "    So It should be accessible with or without permission override",
            "    e.g. @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"contenttypes.contenttype\"])",
            "    \"\"\"",
            "",
            "    def test_list_objects_with_or_without_permission(self):",
            "        contenttype_count = ContentType.objects.count()",
            "",
            "        response = self.client.get(reverse(\"extras-api:contenttype-list\"), **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], contenttype_count)",
            "",
            "    def test_get_object_with_or_without_permission(self):",
            "        contenttype = ContentType.objects.first()",
            "",
            "        url = reverse(\"extras-api:contenttype-detail\", kwargs={\"pk\": contenttype.pk})",
            "        self.assertHttpStatus(self.client.get(url, **self.header), status.HTTP_200_OK)",
            "",
            "",
            "class CreatedUpdatedFilterTest(APITestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.site1 = Site.objects.create(name=\"Test Site 1\", slug=\"test-site-1\")",
            "        self.rackgroup1 = RackGroup.objects.create(site=self.site1, name=\"Test Rack Group 1\", slug=\"test-rack-group-1\")",
            "        self.rackrole1 = RackRole.objects.create(name=\"Test Rack Role 1\", slug=\"test-rack-role-1\", color=\"ff0000\")",
            "        self.rack1 = Rack.objects.create(",
            "            site=self.site1,",
            "            group=self.rackgroup1,",
            "            role=self.rackrole1,",
            "            name=\"Test Rack 1\",",
            "            u_height=42,",
            "        )",
            "        self.rack2 = Rack.objects.create(",
            "            site=self.site1,",
            "            group=self.rackgroup1,",
            "            role=self.rackrole1,",
            "            name=\"Test Rack 2\",",
            "            u_height=42,",
            "        )",
            "",
            "        # change the created and last_updated of one",
            "        Rack.objects.filter(pk=self.rack2.pk).update(",
            "            last_updated=make_aware(datetime(2001, 2, 3, 1, 2, 3, 4)),",
            "            created=make_aware(datetime(2001, 2, 3)),",
            "        )",
            "",
            "    def test_get_rack_created(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created=2001-02-03\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_created_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created__gte=2001-02-04\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_created_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created__lte=2001-02-04\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated=2001-02-03%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__gte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_last_updated_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__lte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "",
            "class CustomFieldTestVersion12(APIViewTestCases.APIViewTestCase):",
            "    \"\"\"Tests for the API version 1.2/1.3 CustomField REST API.\"\"\"",
            "",
            "    model = CustomField",
            "    api_version = \"1.2\"",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"name\": \"cf4\",",
            "            \"type\": \"date\",",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"name\": \"cf5\",",
            "            \"type\": \"url\",",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"name\": \"cf6\",",
            "            \"type\": \"select\",",
            "            \"label\": \"Custom Field 6\",",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_types\": [\"dcim.site\"],",
            "        \"name\": \"cf1\",",
            "        \"label\": \"foo\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"filter_logic\", \"type\"]",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "",
            "        custom_fields = (",
            "            CustomField(name=\"cf1\", type=\"text\"),",
            "            CustomField(name=\"cf2\", type=\"integer\"),",
            "            CustomField(name=\"cf3\", type=\"boolean\"),",
            "        )",
            "        for cf in custom_fields:",
            "            cf.validated_save()",
            "            cf.content_types.add(site_ct)",
            "",
            "    def test_create_object(self):",
            "        super(APIViewTestCases.APIViewTestCase, self).test_create_object()",
            "        # Verify that label is auto-populated when not specified",
            "        for create_data in self.create_data:",
            "            instance = self._get_queryset().get(name=create_data[\"name\"])",
            "            self.assertEqual(instance.label, create_data.get(\"label\", instance.name))",
            "",
            "",
            "class CustomFieldTestVersion14(CustomFieldTestVersion12):",
            "    \"\"\"Tests for the API version 1.4+ CustomField REST API.\"\"\"",
            "",
            "    api_version = \"1.4\"",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"label\": \"Custom Field 4\",",
            "            \"slug\": \"cf4\",",
            "            \"type\": \"date\",",
            "            \"weight\": 100,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\", \"dcim.device\"],",
            "            \"label\": \"Custom Field 5\",",
            "            \"slug\": \"cf5\",",
            "            \"type\": \"url\",",
            "            \"default\": \"http://example.com\",",
            "            \"weight\": 200,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"label\": \"Custom Field 6\",",
            "            \"slug\": \"cf6\",",
            "            \"type\": \"select\",",
            "            \"description\": \"A select custom field\",",
            "            \"weight\": 300,",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_types\": [\"dcim.site\"],",
            "        \"description\": \"New description\",",
            "        \"label\": \"Non-unique label\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "",
            "        custom_fields = (",
            "            CustomField(slug=\"cf1\", label=\"Custom Field 1\", type=\"text\"),",
            "            CustomField(slug=\"cf2\", label=\"Custom Field 2\", type=\"integer\"),",
            "            CustomField(slug=\"cf3\", label=\"Custom Field 3\", type=\"boolean\"),",
            "        )",
            "        for cf in custom_fields:",
            "            cf.validated_save()",
            "            cf.content_types.add(site_ct)",
            "",
            "    def test_create_object(self):",
            "        super(APIViewTestCases.APIViewTestCase, self).test_create_object()",
            "        # 2.0 TODO: #824 remove name entirely",
            "        # For now, check that name is correctly populated in the model even though it's not an API field.",
            "        for create_data in self.create_data:",
            "            instance = self._get_queryset().get(slug=create_data[\"slug\"])",
            "            self.assertEqual(instance.name, instance.slug)",
            "",
            "    def test_create_object_required_fields(self):",
            "        \"\"\"For this API version, `label` and `slug` are required fields.\"\"\"",
            "        self.add_permissions(\"extras.add_customfield\")",
            "",
            "        incomplete_data = {",
            "            \"content_types\": [\"dcim.site\"],",
            "            \"type\": \"date\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), incomplete_data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            response.data,",
            "            {\"slug\": [\"This field is required.\"], \"label\": [\"This field is required.\"]},",
            "        )",
            "",
            "",
            "class CustomLinkTest(APIViewTestCases.APIViewTestCase):",
            "    model = CustomLink",
            "    brief_fields = [\"content_type\", \"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"name\": \"api-test-4\",",
            "            \"text\": \"API customlink text 4\",",
            "            \"target_url\": \"http://api-test-4.com/test4\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"name\": \"api-test-5\",",
            "            \"text\": \"API customlink text 5\",",
            "            \"target_url\": \"http://api-test-5.com/test5\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.site\",",
            "            \"name\": \"api-test-6\",",
            "            \"text\": \"API customlink text 6\",",
            "            \"target_url\": \"http://api-test-6.com/test6\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "    ]",
            "    choices_fields = [\"button_class\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-1\",",
            "            text=\"API customlink text 1\",",
            "            target_url=\"http://api-test-1.com/test1\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-2\",",
            "            text=\"API customlink text 2\",",
            "            target_url=\"http://api-test-2.com/test2\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-3\",",
            "            text=\"API customlink text 3\",",
            "            target_url=\"http://api-test-3.com/test3\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "",
            "",
            "class DynamicGroupTestMixin:",
            "    \"\"\"Mixin for Dynamic Group test cases to re-use the same set of common fixtures.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create the objects required for devices.",
            "        sites = [",
            "            Site.objects.create(name=\"Site 1\", slug=\"site-1\"),",
            "            Site.objects.create(name=\"Site 2\", slug=\"site-2\"),",
            "            Site.objects.create(name=\"Site 3\", slug=\"site-3\"),",
            "        ]",
            "",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "            slug=\"device-type-1\",",
            "        )",
            "        device_role = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\", color=\"ff0000\")",
            "        status_active = Status.objects.get(slug=\"active\")",
            "        status_planned = Status.objects.get(slug=\"planned\")",
            "        Device.objects.create(",
            "            name=\"device-site-1\",",
            "            status=status_active,",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=sites[0],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-site-2\",",
            "            status=status_active,",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=sites[1],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-site-3\",",
            "            status=status_planned,",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=sites[2],",
            "        )",
            "",
            "        # Then the DynamicGroups.",
            "        cls.content_type = ContentType.objects.get_for_model(Device)",
            "        cls.groups = [",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 1\",",
            "                slug=\"api-dynamicgroup-1\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [\"active\"]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 2\",",
            "                slug=\"api-dynamicgroup-2\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [\"planned\"]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 3\",",
            "                slug=\"api-dynamicgroup-3\",",
            "                content_type=cls.content_type,",
            "                filter={\"site\": [\"site-3\"]},",
            "            ),",
            "        ]",
            "",
            "",
            "class DynamicGroupTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroup",
            "    brief_fields = [\"content_type\", \"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"API DynamicGroup 4\",",
            "            \"slug\": \"api-dynamicgroup-4\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"site\": [\"site-1\"]},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 5\",",
            "            \"slug\": \"api-dynamicgroup-5\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"has_interfaces\": False},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 6\",",
            "            \"slug\": \"api-dynamicgroup-6\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"site\": [\"site-2\"]},",
            "        },",
            "    ]",
            "",
            "    def test_get_members(self):",
            "        \"\"\"Test that the `/members/` API endpoint returns what is expected.\"\"\"",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        instance = self.groups[0]",
            "        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))",
            "        member_count = instance.members.count()",
            "        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(member_count, len(response.json()[\"results\"]))",
            "",
            "    def test_get_members_with_constrained_permission(self):",
            "        \"\"\"Test that the `/members/` API endpoint enforces permissions on the member model.\"\"\"",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        instance = self.groups[0]",
            "        obj1 = instance.members.first()",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk__in\": [obj1.pk]},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(instance.content_type)",
            "",
            "        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(len(response.json()[\"results\"]), 1)",
            "        self.assertEqual(response.json()[\"results\"][0][\"id\"], str(obj1.pk))",
            "",
            "",
            "class DynamicGroupMembershipTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroupMembership",
            "    brief_fields = [\"display\", \"group\", \"id\", \"operator\", \"parent_group\", \"url\", \"weight\"]",
            "    choices_fields = [\"operator\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super().setUpTestData()",
            "",
            "        parent = DynamicGroup.objects.create(",
            "            name=\"parent\",",
            "            slug=\"parent\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        parent2 = DynamicGroup.objects.create(",
            "            name=\"parent2\",",
            "            slug=\"parent2\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        group1, group2, group3 = cls.groups",
            "",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group1,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            weight=10,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group2,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "            weight=20,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group3,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            weight=30,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group1.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "                \"weight\": 10,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group2.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "                \"weight\": 20,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group3.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                \"weight\": 30,",
            "            },",
            "        ]",
            "",
            "",
            "class ExportTemplateTest(APIViewTestCases.APIViewTestCase):",
            "    model = ExportTemplate",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 4\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 5\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 6\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\", \"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Device)",
            "",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 1\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 2\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 3\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "",
            "",
            "class GitRepositoryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GitRepository",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    bulk_update_data = {",
            "        \"branch\": \"develop\",",
            "    }",
            "    choices_fields = [\"provided_contents\"]",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\", slug=\"secrets-group-1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\", slug=\"secrets-group-2\"),",
            "        )",
            "",
            "        cls.repos = (",
            "            GitRepository(",
            "                name=\"Repo 1\",",
            "                slug=\"repo-1\",",
            "                remote_url=\"https://example.com/repo1.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(",
            "                name=\"Repo 2\",",
            "                slug=\"repo-2\",",
            "                remote_url=\"https://example.com/repo2.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo-3\", remote_url=\"https://example.com/repo3.git\"),",
            "        )",
            "        for repo in cls.repos:",
            "            repo.validated_save(trigger_resync=False)",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"New Git Repository 1\",",
            "                \"slug\": \"new-git-repository-1\",",
            "                \"remote_url\": \"https://example.com/newrepo1.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 2\",",
            "                \"slug\": \"new-git-repository-2\",",
            "                \"remote_url\": \"https://example.com/newrepo2.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 3\",",
            "                \"slug\": \"new-git-repository-3\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 4\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "        ]",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_no_celery_worker(self, mock_get_worker_count):",
            "        \"\"\"Git sync cannot be triggered if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_nonexistent_repo(self, mock_get_worker_count):",
            "        \"\"\"Git sync request handles case of a nonexistent repository.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": \"11111111-1111-1111-1111-111111111111\"})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_without_permissions(self, mock_get_worker_count):",
            "        \"\"\"Git sync request verifies user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_with_permissions(self, mock_get_worker_count):",
            "        \"\"\"Git sync request can be submitted successfully.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_create_with_plugin_provided_contents(self):",
            "        \"\"\"Test that `provided_contents` published by a plugin works.\"\"\"",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = self._get_list_url()",
            "        data = {",
            "            \"name\": \"plugin_test\",",
            "            \"slug\": \"plugin-test\",",
            "            \"remote_url\": \"https://localhost/plugin-test\",",
            "            \"provided_contents\": [\"example_plugin.textfile\"],",
            "        }",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(list(response.data[\"provided_contents\"]), data[\"provided_contents\"])",
            "",
            "",
            "class GraphQLQueryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GraphQLQuery",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"graphql-query-4\",",
            "            \"slug\": \"graphql-query-4\",",
            "            \"query\": \"{ query: sites {name} }\",",
            "        },",
            "        {",
            "            \"name\": \"graphql-query-5\",",
            "            \"slug\": \"graphql-query-5\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "        },",
            "        {",
            "            \"name\": \"Graphql Query 6\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "        },",
            "    ]",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                slug=\"graphql-query-1\",",
            "                query=\"{ sites {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                slug=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                slug=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "        )",
            "",
            "        for query in cls.graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "    def test_run_saved_query(self):",
            "        \"\"\"Exercise the /run/ API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.add_graphqlquery\")",
            "        self.add_permissions(\"extras.change_graphqlquery\")",
            "        self.add_permissions(\"extras.view_graphqlquery\")",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[0].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"sites\": []}}, response.data)",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[2].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"devices\": []}}, response.data)",
            "",
            "",
            "# TODO(Glenn): Standardize to APIViewTestCase (needs create & update tests)",
            "class ImageAttachmentTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = ImageAttachment",
            "    brief_fields = [\"display\", \"id\", \"image\", \"name\", \"url\"]",
            "    choices_fields = [\"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Site)",
            "",
            "        site = Site.objects.create(name=\"Site 1\", slug=\"site-1\")",
            "",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=site.pk,",
            "            name=\"Image Attachment 1\",",
            "            image=\"http://example.com/image1.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=site.pk,",
            "            name=\"Image Attachment 2\",",
            "            image=\"http://example.com/image2.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=site.pk,",
            "            name=\"Image Attachment 3\",",
            "            image=\"http://example.com/image3.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "",
            "",
            "class JobAPIRunTestMixin:",
            "    \"\"\"",
            "    Mixin providing test cases for the \"run\" API endpoint, shared between the different versions of Job API testing.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        self.job_model.enabled = True",
            "        self.job_model.validated_save()",
            "",
            "    def get_run_url(self, class_path=\"local/api_test_job/APITestJob\"):",
            "        \"\"\"To be implemented by classes using this mixin.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    # Status code for successful submission of a job or schedule - to be set by subclasses",
            "    run_success_response_status = None",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_anonymous_not_permitted(self):",
            "        \"\"\"The run_job endpoint should NOT allow anonymous users to submit jobs.\"\"\"",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_without_permission(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_permissions(self, mock_get_worker_count):",
            "        \"\"\"The run_job endpoint should enforce object-level permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"module_name__in\": [\"test_pass\", \"test_fail\"]},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try post to unpermitted job",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "        # Try post to permitted job",
            "        job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"local/test_pass/TestPass\")",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_enabled(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.enabled flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job_model.enabled = False",
            "        job_model.save()",
            "",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_installed(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.installed flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job(",
            "            source=\"local\",",
            "            module_name=\"uninstalled_module\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Uninstalled Module\",",
            "            name=\"No such job\",",
            "            installed=False,",
            "            enabled=True,",
            "        )",
            "        job_model.validated_save()",
            "",
            "        url = self.get_run_url(\"local/uninstalled_module/NoSuchJob\")",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_405_METHOD_NOT_ALLOWED)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_no_worker(self, mock_get_worker_count):",
            "        \"\"\"Job run cannot be requested if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their primary keys.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"name\": \"test\",",
            "                \"interval\": \"future\",",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertEqual(schedule.kwargs[\"data\"][\"var4\"], str(device_role.pk))",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var_no_schedule(self, mock_get_worker_count):",
            "        \"\"\"",
            "        Run a job with `approval_required` without providing a schedule.",
            "",
            "        Assert an immediate schedule that enforces it.",
            "        \"\"\"",
            "        # Set approval_required=True",
            "        self.job_model.approval_required = True",
            "        self.job_model.save()",
            "",
            "        # Do the stuff.",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "            # schedule is omitted",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        # Assert that a JobResult was NOT created.",
            "        self.assertFalse(JobResult.objects.exists())",
            "",
            "        # Assert that we have an immediate ScheduledJob and that it matches the job_model.",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertIsNotNone(schedule)",
            "        self.assertEqual(schedule.interval, JobExecutionType.TYPE_IMMEDIATELY)",
            "        self.assertEqual(schedule.approval_required, self.job_model.approval_required)",
            "        self.assertEqual(schedule.kwargs[\"data\"][\"var4\"], str(device_role.pk))",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var_lookup(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": {\"name\": \"role\"},",
            "        }",
            "",
            "        # This handles things like ObjectVar fields looked up by non-UUID",
            "        # Jobs are executed with deserialized data",
            "        deserialized_data = get_job(\"local/api_test_job/APITestJob\").deserialize_data(job_data)",
            "",
            "        self.assertEqual(",
            "            deserialized_data,",
            "            {\"var1\": \"FooBar\", \"var2\": 123, \"var3\": False, \"var4\": device_role},",
            "        )",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, {\"data\": job_data}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.last()",
            "        self.assertIn(\"data\", job_result.job_kwargs)",
            "",
            "        # Ensure the stored job_kwargs deserialize to the same as originally inputted",
            "        self.assertEqual(",
            "            get_job(\"local/api_test_job/APITestJob\").deserialize_data(job_result.job_kwargs[\"data\"]), deserialized_data",
            "        )",
            "",
            "        return (response, job_result)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_commit(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_field_order/TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "            \"_commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"local/test_field_order/TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        return response  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_only(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_field_order/TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"local/test_field_order/TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        return response  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_schedule(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_field_order/TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "            \"_commit\": True,",
            "            \"_schedule_start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            \"_schedule_interval\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"local/test_field_order/TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        return response  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_for_future(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        # url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"interval\"][0],",
            "            \"Unable to schedule job: Job may have sensitive input variables\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_and_requires_approval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.has_sensitive_variables = True",
            "        job_model.approval_required = True",
            "        job_model.save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0],",
            "            \"Unable to run or schedule job: \"",
            "            \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "            \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_immediately(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "        job = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job.has_sensitive_variables = True",
            "        job.has_sensitive_variables_override = True",
            "        job.validated_save()",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.last()",
            "        self.assertEqual(job_result.job_kwargs, None)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future_past(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() - timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_interval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"hourly\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "",
            "        return (response, schedule)  # so subclasses can do additional testing",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"data\": \"invalid\",",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": [\"Job data needs to be a dict\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_wrong_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var5\": \"wrong\",",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": {\"var5\": [\"Job data contained an unknown property\"]}})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_missing_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var3\": False,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"commit\": True,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data, {\"errors\": {\"var2\": [\"This field is required.\"], \"var4\": [\"This field is required.\"]}}",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_task_queue(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"task_queue\": \"invalid\",",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data,",
            "            {\"task_queue\": ['\"invalid\" is not a valid choice.']},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_valid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = DeviceRole.objects.create(name=\"role\", slug=\"role\")",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"commit\": True,",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_default_queue_with_empty_job_model_task_queues(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        data = {",
            "            \"commit\": True,",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"local/test_pass/TestPass\")",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "",
            "class JobHookTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobHook",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    choices_fields = []",
            "    update_data = {",
            "        \"name\": \"Overridden name\",",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "    validation_excluded_fields = []",
            "    api_version = \"1.3\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobHook4\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook5\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverChange\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook6\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverFail\").pk,",
            "                \"enabled\": False,",
            "            },",
            "        ]",
            "        cls.job_hooks = (",
            "            JobHook(",
            "                name=\"JobHook1\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverLog\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook2\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverChange\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook3\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverFail\"),",
            "                type_delete=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for job_hook in cls.job_hooks:",
            "            job_hook.save()",
            "            job_hook.content_types.set([obj_type])",
            "",
            "    def test_validate_post(self):",
            "        \"\"\"POST a job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"name\": \"JobHook4\",",
            "            \"content_types\": [\"dcim.devicetype\"],",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_create\": False,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_jobhook\")",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "    def test_validate_patch(self):",
            "        \"\"\"PATCH an existing job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_jobhook\")",
            "        job_hook2 = JobHook.objects.get(name=\"JobHook2\")",
            "        response = self.client.patch(self._get_detail_url(job_hook2), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "",
            "class JobButtonTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobButton",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    choices_fields = [\"button_class\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobButton4\",",
            "                \"text\": \"JobButton4\",",
            "                \"content_types\": [\"dcim.region\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\").pk,",
            "            },",
            "            {",
            "                \"name\": \"JobButton5\",",
            "                \"text\": \"JobButton5\",",
            "                \"content_types\": [\"circuits.circuit\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            },",
            "        ]",
            "        site_type = ContentType.objects.get_for_model(Site)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        site_jb = JobButton(",
            "            name=\"api-test-site\",",
            "            text=\"API job button site text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        site_jb.save()",
            "        site_jb.content_types.set([site_type])",
            "",
            "        device_jb = JobButton.objects.create(",
            "            name=\"api-test-device\",",
            "            text=\"API job button device text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        device_jb.save()",
            "        device_jb.content_types.set([device_type])",
            "",
            "        complex_jb = JobButton.objects.create(",
            "            name=\"api-test-complex\",",
            "            text=\"API job button complex text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        complex_jb.save()",
            "        complex_jb.content_types.set([device_type, site_type])",
            "",
            "",
            "class JobTestVersion13(",
            "    JobAPIRunTestMixin,",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.UpdateObjectViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    \"\"\"Test cases for the Jobs REST API under API version 1.3 - first version introducing JobModel-based APIs.\"\"\"",
            "",
            "    model = Job",
            "    brief_fields = [\"display\", \"grouping\", \"id\", \"job_class_name\", \"module_name\", \"name\", \"slug\", \"source\", \"url\"]",
            "    choices_fields = None",
            "    update_data = {",
            "        # source, module_name, job_class_name, installed are NOT editable",
            "        \"grouping_override\": True,",
            "        \"grouping\": \"Overridden grouping\",",
            "        \"name_override\": True,",
            "        \"name\": \"Overridden name\",",
            "        \"slug\": \"overridden-slug\",",
            "        \"description_override\": True,",
            "        \"description\": \"This is an overridden description.\",",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"commit_default_override\": True,",
            "        \"commit_default\": False,",
            "        \"hidden_override\": True,",
            "        \"hidden\": True,",
            "        \"read_only_override\": True,",
            "        \"read_only\": True,",
            "        \"soft_time_limit_override\": True,",
            "        \"soft_time_limit\": 350.1,",
            "        \"time_limit_override\": True,",
            "        \"time_limit\": 650,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "        \"task_queues\": [\"default\", \"priority\"],",
            "        \"task_queues_override\": True,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "    }",
            "    validation_excluded_fields = []",
            "",
            "    run_success_response_status = status.HTTP_201_CREATED",
            "    api_version = \"1.3\"",
            "",
            "    def get_run_url(self, class_path=\"local/api_test_job/APITestJob\"):",
            "        job_model = Job.objects.get_for_class_path(class_path)",
            "        return reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "",
            "    def test_get_job_variables(self):",
            "        \"\"\"Test the job/<pk>/variables API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.view_job\")",
            "        route = get_route_for_model(self.model, \"variables\", api=True)",
            "        response = self.client.get(reverse(route, kwargs={\"pk\": self.job_model.pk}), **self.header)",
            "        self.assertEqual(4, len(response.data))  # 4 variables, in order",
            "        self.assertEqual(response.data[0], {\"name\": \"var1\", \"type\": \"StringVar\", \"required\": True})",
            "        self.assertEqual(response.data[1], {\"name\": \"var2\", \"type\": \"IntegerVar\", \"required\": True})",
            "        self.assertEqual(response.data[2], {\"name\": \"var3\", \"type\": \"BooleanVar\", \"required\": False})",
            "        self.assertEqual(",
            "            response.data[3],",
            "            {\"name\": \"var4\", \"type\": \"ObjectVar\", \"required\": True, \"model\": \"dcim.devicerole\"},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_job_with_sensitive_variables_set_approval_required_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job_model.has_sensitive_variables = True",
            "        job_model.has_sensitive_variables_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"approval_required\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_approval_required_job_set_has_sensitive_variables_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"local/api_test_job/APITestJob\")",
            "        job_model.approval_required = True",
            "        job_model.approval_required_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"has_sensitive_variables\": True,",
            "            \"has_sensitive_variables_override\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"has_sensitive_variables\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_object_var(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, schedule = super().test_run_job_object_var()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"schedule\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"url\"],",
            "            \"http://nautobot.example.com\" + reverse(\"extras-api:scheduledjob-detail\", kwargs={\"pk\": schedule.pk}),",
            "        )",
            "        self.assertEqual(response.data[\"schedule\"][\"name\"], schedule.name)",
            "        self.assertEqual(response.data[\"schedule\"][\"start_time\"], schedule.start_time)",
            "        self.assertEqual(response.data[\"schedule\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_object_var_lookup(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, job_result = super().test_run_job_object_var_lookup()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertIsNone(response.data[\"schedule\"])",
            "        # The urls in a NestedJobResultSerializer depends on the request context, which we don't have",
            "        data_job_result = response.data[\"job_result\"]",
            "        del data_job_result[\"url\"]",
            "        del data_job_result[\"user\"][\"url\"]",
            "        expected_data_job_result = NestedJobResultSerializer(job_result, context={\"request\": None}).data",
            "        del expected_data_job_result[\"url\"]",
            "        del expected_data_job_result[\"user\"][\"url\"]",
            "        self.assertEqual(data_job_result, expected_data_job_result)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_future(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, schedule = super().test_run_job_future()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"schedule\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"url\"],",
            "            \"http://nautobot.example.com\" + reverse(\"extras-api:scheduledjob-detail\", kwargs={\"pk\": schedule.pk}),",
            "        )",
            "        self.assertEqual(response.data[\"schedule\"][\"name\"], schedule.name)",
            "        self.assertEqual(response.data[\"schedule\"][\"start_time\"], schedule.start_time)",
            "        self.assertEqual(response.data[\"schedule\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_future_schedule_kwargs_pk(self):",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify that kwargs['scheduled_job_pk'] was set in the scheduled job.\"\"\"",
            "        _, schedule = super().test_run_job_future()",
            "",
            "        self.assertEqual(schedule.kwargs[\"scheduled_job_pk\"], str(schedule.pk))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_interval(self):  # pylint: disable=arguments-differ",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        response, schedule = super().test_run_job_interval()",
            "",
            "        self.assertIn(\"schedule\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"schedule\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"url\"],",
            "            \"http://nautobot.example.com\" + reverse(\"extras-api:scheduledjob-detail\", kwargs={\"pk\": schedule.pk}),",
            "        )",
            "        self.assertEqual(response.data[\"schedule\"][\"name\"], schedule.name)",
            "        self.assertEqual(response.data[\"schedule\"][\"start_time\"], schedule.start_time)",
            "        self.assertEqual(response.data[\"schedule\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "",
            "class JobTestVersion12(",
            "    JobAPIRunTestMixin,",
            "    APITestCase,",
            "):",
            "    \"\"\"Test cases for the Jobs REST API under API version 1.2 - deprecated JobClass-based API pattern.\"\"\"",
            "",
            "    run_success_response_status = status.HTTP_200_OK",
            "    api_version = \"1.2\"",
            "",
            "    def get_run_url(self, class_path=\"local/api_test_job/APITestJob\"):",
            "        return reverse(\"extras-api:job-run\", kwargs={\"class_path\": class_path})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_list_jobs_anonymous(self):",
            "        url = reverse(\"extras-api:job-list\")",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_list_jobs_without_permission(self):",
            "        url = reverse(\"extras-api:job-list\")",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_list_jobs_with_permission(self):",
            "        self.add_permissions(\"extras.view_job\")",
            "        url = reverse(\"extras-api:job-list\")",
            "        response = self.client.get(url, **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        # At a minimum, the job provided by the example plugin should be present",
            "        self.assertNotEqual(response.data, [])",
            "        self.assertIn(",
            "            \"plugins/example_plugin.jobs/ExampleJob\",",
            "            [job[\"id\"] for job in response.data],",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_get_job_anonymous(self):",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/APITestJob\"})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_job_without_permission(self):",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/APITestJob\"})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_job_with_permission(self):",
            "        self.add_permissions(\"extras.view_job\")",
            "        # Try GET to permitted object",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/APITestJob\"})",
            "        response = self.client.get(url, **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"name\"], \"Job for API Tests\")",
            "        self.assertEqual(response.data[\"vars\"][\"var1\"], \"StringVar\")",
            "        self.assertEqual(response.data[\"vars\"][\"var2\"], \"IntegerVar\")",
            "        self.assertEqual(response.data[\"vars\"][\"var3\"], \"BooleanVar\")",
            "",
            "        # Try GET to non-existent object",
            "        url = reverse(\"extras-api:job-detail\", kwargs={\"class_path\": \"local/api_test_job/NoSuchJob\"})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "",
            "class JobTestVersionDefault(JobTestVersion12):",
            "    \"\"\"",
            "    Test cases for the Jobs REST API when not explicitly requesting a specific API version.",
            "",
            "    Currently we default to version 1.2, but this may change in a future major release.",
            "    \"\"\"",
            "",
            "    api_version = None",
            "",
            "",
            "class JobResultTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = JobResult",
            "    brief_fields = [\"completed\", \"created\", \"display\", \"id\", \"name\", \"status\", \"url\", \"user\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        jobs = Job.objects.all()[:2]",
            "        job_ct = ContentType.objects.get_for_model(Job)",
            "        git_ct = ContentType.objects.get_for_model(GitRepository)",
            "",
            "        JobResult.objects.create(",
            "            job_model=jobs[0],",
            "            name=jobs[0].class_path,",
            "            obj_type=job_ct,",
            "            completed=datetime.now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_COMPLETED,",
            "            data={\"output\": \"\\nRan for 3 seconds\"},",
            "            job_kwargs=None,",
            "            schedule=None,",
            "            job_id=uuid.uuid4(),",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=None,",
            "            name=\"Git Repository\",",
            "            obj_type=git_ct,",
            "            completed=datetime.now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_COMPLETED,",
            "            data=None,",
            "            job_kwargs={\"repository_pk\": uuid.uuid4()},",
            "            schedule=None,",
            "            job_id=uuid.uuid4(),",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=jobs[1],",
            "            name=jobs[1].class_path,",
            "            obj_type=job_ct,",
            "            completed=None,",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_PENDING,",
            "            data=None,",
            "            job_kwargs={\"data\": {\"device\": uuid.uuid4(), \"multichoices\": [\"red\", \"green\"], \"checkbox\": False}},",
            "            schedule=None,",
            "            job_id=uuid.uuid4(),",
            "        )",
            "",
            "",
            "class JobLogEntryTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobLogEntry",
            "    brief_fields = [",
            "        \"absolute_url\",",
            "        \"created\",",
            "        \"display\",",
            "        \"grouping\",",
            "        \"id\",",
            "        \"job_result\",",
            "        \"log_level\",",
            "        \"log_object\",",
            "        \"message\",",
            "        \"url\",",
            "    ]",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.job_result = JobResult.objects.create(",
            "            name=\"test\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=ContentType.objects.get_for_model(GitRepository),",
            "        )",
            "",
            "        for log_level in (\"debug\", \"info\", \"success\", \"warning\"):",
            "            JobLogEntry.objects.create(",
            "                log_level=log_level,",
            "                grouping=\"run\",",
            "                job_result=cls.job_result,",
            "                message=f\"I am a {log_level} log.\",",
            "            )",
            "",
            "    def test_list_job_logs_from_job_results_detail(self):",
            "        \"\"\"Test `logs` endpoint from `JobResult` detail.\"\"\"",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "        url = reverse(\"extras-api:jobresult-logs\", kwargs={\"pk\": self.job_result.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertEqual(len(response.json()), JobLogEntry.objects.count())",
            "",
            "",
            "class ScheduledJobTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    brief_fields = [\"crontab\", \"display\", \"id\", \"interval\", \"name\", \"start_time\", \"url\"]",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=job_model.class_path,",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=job_model.class_path,",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=job_model.class_path,",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "",
            "class JobApprovalTest(APITestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.additional_user = User.objects.create(username=\"user1\", is_active=True)",
            "        cls.job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        cls.job_model.enabled = True",
            "        cls.job_model.save()",
            "        cls.scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=cls.job_model.class_path,",
            "            job_model=cls.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=cls.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_anonymous(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_change_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_same_user(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=self.job_model.class_path,",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=self.job_model.class_path,",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past_force(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=self.job_model.class_path,",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url + \"?force=true\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_delete_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIsNone(ScheduledJob.objects.filter(pk=self.scheduled_job.pk).first())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_dry_run_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job_without_run_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job(self):",
            "        self.add_permissions(\"extras.run_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "",
            "class NoteTest(APIViewTestCases.APIViewTestCase):",
            "    model = Note",
            "    brief_fields = [",
            "        \"assigned_object\",",
            "        \"display\",",
            "        \"id\",",
            "        \"note\",",
            "        \"slug\",",
            "        \"url\",",
            "        \"user\",",
            "    ]",
            "    choices_fields = [\"assigned_object_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site1 = Site.objects.create(name=\"Site 1\", slug=\"site-1\")",
            "        site2 = Site.objects.create(name=\"Site 2\", slug=\"site-2\")",
            "        ct = ContentType.objects.get_for_model(Site)",
            "        user1 = User.objects.create(username=\"user1\", is_active=True)",
            "        user2 = User.objects.create(username=\"user2\", is_active=True)",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": site1.pk,",
            "                \"assigned_object_type\": \"dcim.site\",",
            "            },",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": site2.pk,",
            "                \"assigned_object_type\": \"dcim.site\",",
            "            },",
            "            {",
            "                \"note\": \"This is a note on Site 1.\",",
            "                \"assigned_object_id\": site1.pk,",
            "                \"assigned_object_type\": \"dcim.site\",",
            "            },",
            "        ]",
            "        cls.bulk_update_data = {",
            "            \"note\": \"Bulk change.\",",
            "        }",
            "        Note.objects.create(",
            "            note=\"Site has been placed on maintenance.\",",
            "            user=user1,",
            "            assigned_object_type=ct,",
            "            assigned_object_id=site1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site maintenance has ended.\",",
            "            user=user1,",
            "            assigned_object_type=ct,",
            "            assigned_object_id=site1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site is under duress.\",",
            "            user=user2,",
            "            assigned_object_type=ct,",
            "            assigned_object_id=site2.pk,",
            "        )",
            "",
            "",
            "class RelationshipTest(APIViewTestCases.APIViewTestCase, RequiredRelationshipTestMixin):",
            "    model = Relationship",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Device VLANs\",",
            "            \"slug\": \"device-vlans\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"name\": \"Primary VLAN\",",
            "            \"slug\": \"primary-vlan\",",
            "            \"type\": \"one-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"name\": \"Primary Interface\",",
            "            \"slug\": \"primary-interface\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "        {",
            "            \"name\": \"Relationship 1\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "    ]",
            "",
            "    bulk_update_data = {",
            "        \"source_filter\": {\"slug\": [\"some-slug\"]},",
            "    }",
            "    choices_fields = [\"destination_type\", \"source_type\", \"type\", \"required_on\"]",
            "    slug_source = \"name\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site_type = ContentType.objects.get_for_model(Site)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.relationships = (",
            "            Relationship(",
            "                name=\"Related Sites\",",
            "                slug=\"related-sites\",",
            "                type=\"symmetric-many-to-many\",",
            "                source_type=site_type,",
            "                destination_type=site_type,",
            "            ),",
            "            Relationship(",
            "                name=\"Unrelated Sites\",",
            "                slug=\"unrelated-sites\",",
            "                type=\"many-to-many\",",
            "                source_type=site_type,",
            "                source_label=\"Other sites (from source side)\",",
            "                destination_type=site_type,",
            "                destination_label=\"Other sites (from destination side)\",",
            "            ),",
            "            Relationship(",
            "                name=\"Devices found elsewhere\",",
            "                slug=\"devices-elsewhere\",",
            "                type=\"many-to-many\",",
            "                source_type=site_type,",
            "                destination_type=device_type,",
            "            ),",
            "        )",
            "        for relationship in cls.relationships:",
            "            relationship.validated_save()",
            "",
            "        cls.site = Site.objects.create(name=\"Site 1\", status=Status.objects.get(slug=\"active\"))",
            "",
            "    def test_get_all_relationships_on_site(self):",
            "        \"\"\"Verify that all relationships are accurately represented when requested.\"\"\"",
            "        self.add_permissions(\"dcim.view_site\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.site.pk}) + \"?include=relationships\", **self.header",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            {",
            "                self.relationships[0].slug: {",
            "                    \"id\": str(self.relationships[0].pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationships[0].pk})",
            "                    ),",
            "                    \"name\": self.relationships[0].name,",
            "                    \"type\": self.relationships[0].type,",
            "                    \"peer\": {",
            "                        \"label\": \"sites\",",
            "                        \"object_type\": \"dcim.site\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[1].slug: {",
            "                    \"id\": str(self.relationships[1].pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationships[1].pk})",
            "                    ),",
            "                    \"name\": self.relationships[1].name,",
            "                    \"type\": self.relationships[1].type,",
            "                    \"destination\": {",
            "                        \"label\": self.relationships[1].source_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.site\",",
            "                        \"objects\": [],",
            "                    },",
            "                    \"source\": {",
            "                        \"label\": self.relationships[1].destination_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.site\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[2].slug: {",
            "                    \"id\": str(self.relationships[2].pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationships[2].pk})",
            "                    ),",
            "                    \"name\": self.relationships[2].name,",
            "                    \"type\": self.relationships[2].type,",
            "                    \"destination\": {",
            "                        \"label\": \"devices\",",
            "                        \"object_type\": \"dcim.device\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "            },",
            "            response.data[\"relationships\"],",
            "        )",
            "",
            "    def test_populate_relationship_associations_on_site_create(self):",
            "        \"\"\"Verify that relationship associations can be populated at instance creation time.\"\"\"",
            "        existing_site_1 = Site.objects.create(name=\"Existing Site 1\", status=Status.objects.get(slug=\"active\"))",
            "        existing_site_2 = Site.objects.create(name=\"Existing Site 2\", status=Status.objects.get(slug=\"active\"))",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "            slug=\"device-type-1\",",
            "        )",
            "        device_role = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\", color=\"ff0000\")",
            "        existing_device_1 = Device.objects.create(",
            "            name=\"existing-device-site-1\",",
            "            status=Status.objects.get(slug=\"active\"),",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=existing_site_1,",
            "        )",
            "        existing_device_2 = Device.objects.create(",
            "            name=\"existing-device-site-2\",",
            "            status=Status.objects.get(slug=\"active\"),",
            "            device_role=device_role,",
            "            device_type=device_type,",
            "            site=existing_site_2,",
            "        )",
            "",
            "        self.add_permissions(\"dcim.view_site\", \"dcim.add_site\", \"extras.add_relationshipassociation\")",
            "        response = self.client.post(",
            "            reverse(\"dcim-api:site-list\"),",
            "            data={",
            "                \"name\": \"New Site\",",
            "                \"status\": \"active\",",
            "                \"relationships\": {",
            "                    self.relationships[0].slug: {",
            "                        \"peer\": {",
            "                            \"objects\": [str(existing_site_1.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[1].slug: {",
            "                        \"source\": {",
            "                            \"objects\": [str(existing_site_2.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[2].slug: {",
            "                        \"destination\": {",
            "                            \"objects\": [",
            "                                {\"name\": \"existing-device-site-1\"},",
            "                                {\"name\": \"existing-device-site-2\"},",
            "                            ],",
            "                        },",
            "                    },",
            "                },",
            "            },",
            "            format=\"json\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        new_site_id = response.data[\"id\"]",
            "        # Peer case - don't distinguish source/destination",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[0],",
            "                source_type=self.relationships[0].source_type,",
            "                source_id__in=[existing_site_1.pk, new_site_id],",
            "                destination_type=self.relationships[0].destination_type,",
            "                destination_id__in=[existing_site_1.pk, new_site_id],",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[1],",
            "                source_type=self.relationships[1].source_type,",
            "                source_id=existing_site_2.pk,",
            "                destination_type=self.relationships[1].destination_type,",
            "                destination_id=new_site_id,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_site_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_1.pk,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_site_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_2.pk,",
            "            ).exists()",
            "        )",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test various bulk create/edit scenarios",
            "        \"\"\"",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"api\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        # VLAN endpoint to POST, PATCH and PUT multiple objects to:",
            "        vlan_list_endpoint = reverse(get_route_for_model(VLAN, \"list\", api=True))",
            "",
            "        def send_bulk_data(http_method, data):",
            "            return getattr(self.client, http_method)(",
            "                vlan_list_endpoint,",
            "                data=data,",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "",
            "        # Try deleting all devices and then creating 2 VLANs (fails):",
            "        Device.objects.all().delete()",
            "        response = send_bulk_data(",
            "            \"post\", data=[{\"vid\": \"1\", \"name\": \"1\", \"status\": \"active\"}, {\"vid\": \"2\", \"name\": \"2\", \"status\": \"active\"}]",
            "        )",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            {",
            "                \"relationships\": {",
            "                    \"vlans-devices-m2m\": [",
            "                        \"VLANs require at least one device, but no devices exist yet. \"",
            "                        \"Create a device by posting to /api/dcim/devices/\",",
            "                        'You need to specify [\"relationships\"][\"vlans-devices-m2m\"][\"source\"][\"objects\"].',",
            "                    ]",
            "                }",
            "            },",
            "            response.json(),",
            "        )",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "        required_relationship_json = {\"vlans-devices-m2m\": {\"source\": {\"objects\": [str(device_for_association.id)]}}}",
            "        expected_error_json = {",
            "            \"relationships\": {",
            "                \"vlans-devices-m2m\": [",
            "                    'You need to specify [\"relationships\"][\"vlans-devices-m2m\"][\"source\"][\"objects\"].'",
            "                ]",
            "            }",
            "        }",
            "",
            "        # Test POST, PATCH and PUT",
            "        for method in [\"post\", \"patch\", \"put\"]:",
            "            if method == \"post\":",
            "                vlan1_json_data = {",
            "                    \"vid\": \"1\",",
            "                    \"name\": \"1\",",
            "                    \"status\": \"active\",",
            "                }",
            "                vlan2_json_data = {",
            "                    \"vid\": \"2\",",
            "                    \"name\": \"2\",",
            "                    \"status\": \"active\",",
            "                }",
            "            else:",
            "                vlan1, vlan2 = VLANFactory.create_batch(2)",
            "                vlan1_json_data = {\"status\": \"active\", \"id\": str(vlan1.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan1_json_data.update({\"vid\": vlan1.vid, \"name\": vlan1.name})",
            "",
            "                vlan2_json_data = {\"status\": \"active\", \"id\": str(vlan2.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan2_json_data.update({\"vid\": vlan2.vid, \"name\": vlan2.name})",
            "",
            "            # Try method without specifying required relationships for either vlan1 or vlan2 (fails)",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for just vlan1 (fails)",
            "            vlan1_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for both vlan1 and vlan2 (succeeds)",
            "            vlan2_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            if method == \"post\":",
            "                self.assertHttpStatus(response, 201)",
            "            else:",
            "                self.assertHttpStatus(response, 200)",
            "",
            "            # Check the relationship associations were actually created",
            "            for vlan in response.json():",
            "                associated_device = vlan[\"relationships\"][\"vlans-devices-m2m\"][\"source\"][\"objects\"][0]",
            "                self.assertEqual(str(device_for_association.id), associated_device[\"id\"])",
            "",
            "",
            "class RelationshipAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = RelationshipAssociation",
            "    brief_fields = [\"destination_id\", \"display\", \"id\", \"relationship\", \"source_id\", \"url\"]",
            "    choices_fields = [\"destination_type\", \"source_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.site_type = ContentType.objects.get_for_model(Site)",
            "        cls.device_type = ContentType.objects.get_for_model(Device)",
            "        cls.status_active = Status.objects.get(slug=\"active\")",
            "",
            "        cls.relationship = Relationship(",
            "            name=\"Devices found elsewhere\",",
            "            slug=\"elsewhere-devices\",",
            "            type=\"many-to-many\",",
            "            source_type=cls.site_type,",
            "            destination_type=cls.device_type,",
            "        )",
            "        cls.relationship.validated_save()",
            "        cls.sites = (",
            "            Site.objects.create(name=\"Empty Site\", slug=\"empty\", status=cls.status_active),",
            "            Site.objects.create(name=\"Occupied Site\", slug=\"occupied\", status=cls.status_active),",
            "            Site.objects.create(name=\"Another Empty Site\", slug=\"another-empty\", status=cls.status_active),",
            "        )",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        cls.devices = (",
            "            Device.objects.create(",
            "                name=\"Device 1\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 2\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 3\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 4\",",
            "                device_type=devicetype,",
            "                device_role=devicerole,",
            "                site=cls.sites[1],",
            "                status=cls.status_active,",
            "            ),",
            "        )",
            "",
            "        cls.associations = (",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.site_type,",
            "                source_id=cls.sites[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[0].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.site_type,",
            "                source_id=cls.sites[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[1].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.site_type,",
            "                source_id=cls.sites[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[2].pk,",
            "            ),",
            "        )",
            "        for association in cls.associations:",
            "            association.validated_save()",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.site\",",
            "                \"source_id\": cls.sites[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[0].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.site\",",
            "                \"source_id\": cls.sites[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[1].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.site\",",
            "                \"source_id\": cls.sites[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[2].pk,",
            "            },",
            "        ]",
            "",
            "    def test_create_invalid_relationship_association(self):",
            "        \"\"\"Test creation of invalid relationship association restricted by destination/source filter.\"\"\"",
            "",
            "        relationship = Relationship.objects.create(",
            "            name=\"Device to Site Rel 1\",",
            "            slug=\"device-to-site-rel-1\",",
            "            source_type=self.device_type,",
            "            source_filter={\"name\": [self.devices[0].name]},",
            "            destination_type=self.site_type,",
            "            destination_label=\"Primary Rack\",",
            "            type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            destination_filter={\"name\": [self.sites[0].name]},",
            "        )",
            "",
            "        associations = [",
            "            (",
            "                \"destination\",  # side",
            "                self.sites[2].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[0].pk,",
            "                    \"destination_type\": \"dcim.site\",",
            "                    \"destination_id\": self.sites[2].pk,",
            "                },",
            "            ),",
            "            (",
            "                \"source\",  # side",
            "                self.devices[1].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[1].pk,",
            "                    \"destination_type\": \"dcim.site\",",
            "                    \"destination_id\": self.sites[0].pk,",
            "                },",
            "            ),",
            "        ]",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        for side, field_error_name, data in associations:",
            "            response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                response.data[side],",
            "                [f\"{field_error_name} violates {relationship.name} {side}_filter restriction\"],",
            "            )",
            "",
            "    def test_model_clean_method_is_called(self):",
            "        \"\"\"Validate RelationshipAssociation clean method is called\"\"\"",
            "",
            "        data = {",
            "            \"relationship\": self.relationship.pk,",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_id\": self.sites[2].pk,",
            "            \"destination_type\": \"dcim.device\",",
            "            \"destination_id\": self.devices[2].pk,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"source_type\"], [f\"source_type has a different value than defined in {self.relationship}\"]",
            "        )",
            "",
            "    def test_get_association_data_on_site(self):",
            "        \"\"\"",
            "        Check that `include=relationships` query parameter on a model endpoint includes relationships/associations.",
            "        \"\"\"",
            "        self.add_permissions(\"dcim.view_site\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.sites[0].pk}) + \"?include=relationships\", **self.header",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        # Ensure consistent ordering",
            "        response.data[\"relationships\"][self.relationship.slug][\"destination\"][\"objects\"].sort(key=lambda v: v[\"name\"])",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            {",
            "                self.relationship.slug: {",
            "                    \"id\": str(self.relationship.pk),",
            "                    \"url\": (",
            "                        \"http://nautobot.example.com\"",
            "                        + reverse(\"extras-api:relationship-detail\", kwargs={\"pk\": self.relationship.pk})",
            "                    ),",
            "                    \"name\": self.relationship.name,",
            "                    \"type\": \"many-to-many\",",
            "                    \"destination\": {",
            "                        \"label\": \"devices\",",
            "                        \"object_type\": \"dcim.device\",",
            "                        \"objects\": [",
            "                            {",
            "                                \"id\": str(self.devices[0].pk),",
            "                                \"url\": (",
            "                                    \"http://nautobot.example.com\"",
            "                                    + reverse(\"dcim-api:device-detail\", kwargs={\"pk\": self.devices[0].pk})",
            "                                ),",
            "                                \"display\": self.devices[0].display,",
            "                                \"name\": self.devices[0].name,",
            "                            },",
            "                            {",
            "                                \"id\": str(self.devices[1].pk),",
            "                                \"url\": (",
            "                                    \"http://nautobot.example.com\"",
            "                                    + reverse(\"dcim-api:device-detail\", kwargs={\"pk\": self.devices[1].pk})",
            "                                ),",
            "                                \"display\": self.devices[1].display,",
            "                                \"name\": self.devices[1].name,",
            "                            },",
            "                            {",
            "                                \"id\": str(self.devices[2].pk),",
            "                                \"url\": (",
            "                                    \"http://nautobot.example.com\"",
            "                                    + reverse(\"dcim-api:device-detail\", kwargs={\"pk\": self.devices[2].pk})",
            "                                ),",
            "                                \"display\": self.devices[2].display,",
            "                                \"name\": self.devices[2].name,",
            "                            },",
            "                        ],",
            "                    },",
            "                },",
            "            },",
            "            response.data[\"relationships\"],",
            "        )",
            "",
            "    def test_update_association_data_on_site(self):",
            "        \"\"\"",
            "        Check that relationship-associations can be updated via the 'relationships' field.",
            "        \"\"\"",
            "        self.add_permissions(",
            "            \"dcim.view_site\",",
            "            \"dcim.change_site\",",
            "            \"extras.add_relationshipassociation\",",
            "            \"extras.delete_relationshipassociation\",",
            "        )",
            "        initial_response = self.client.get(",
            "            reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.sites[0].pk}) + \"?include=relationships\", **self.header",
            "        )",
            "        self.assertHttpStatus(initial_response, status.HTTP_200_OK)",
            "",
            "        url = reverse(\"dcim-api:site-detail\", kwargs={\"pk\": self.sites[0].pk})",
            "",
            "        with self.subTest(\"Round-trip of same relationships data is a no-op\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": initial_response.data[\"relationships\"]},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Omitting relationships data entirely is valid\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: nonexistent relationship\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"nonexistent-relationship\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]), '\"nonexistent-relationship\" is not a relationship on dcim.Site'",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship\"):",
            "            Relationship.objects.create(",
            "                name=\"Device-to-Device\",",
            "                slug=\"device-to-device\",",
            "                source_type=self.device_type,",
            "                destination_type=self.device_type,",
            "                type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            )",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"device-to-device\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]), '\"device-to-device\" is not a relationship on dcim.Site'",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship side\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {self.relationship.slug: {\"source\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]),",
            "                '\"source\" is not a valid side for \"Devices found elsewhere\" on dcim.Site',",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Valid data: create/no-op/delete on RelationshipAssociations\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {",
            "                    \"relationships\": {",
            "                        self.relationship.slug: {",
            "                            \"destination\": {",
            "                                \"objects\": [",
            "                                    # remove devices[0] by omission",
            "                                    str(self.devices[1].pk),  # existing device identified by PK",
            "                                    {\"name\": self.devices[2].name},  # existing device identified by attributes",
            "                                    {\"id\": self.devices[3].pk},  # new device association",
            "                                ]",
            "                            }",
            "                        }",
            "                    },",
            "                },",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            # Removed association",
            "            self.assertFalse(RelationshipAssociation.objects.filter(pk=self.associations[0].pk).exists())",
            "            # Unchanged associations",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[1].pk).exists())",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[2].pk).exists())",
            "            # Created association",
            "            self.assertTrue(RelationshipAssociation.objects.filter(destination_id=self.devices[3].pk).exists())",
            "",
            "",
            "class SecretTest(APIViewTestCases.APIViewTestCase):",
            "    model = Secret",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    bulk_update_data = {}",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"NAPALM Username\",",
            "            \"provider\": \"environment-variable\",",
            "            \"description\": \"Username for all NAPALM devices\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_USERNAME\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"NAPALM Password\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_PASSWORD\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"GitHub Token for My Repository\",",
            "            \"slug\": \"github-token-my-repository\",",
            "            \"provider\": \"text-file\",",
            "            \"parameters\": {",
            "                \"path\": \"/github-tokens/user/myusername.txt\",",
            "            },",
            "        },",
            "    ]",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"api-test-1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_1\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "    def test_secret_check(self):",
            "        \"\"\"",
            "        Ensure that we can check the validity of a secret.",
            "        \"\"\"",
            "",
            "        with self.subTest(\"Secret is not accessible\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-not-accessible\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-matter\"},",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "        self.add_permissions(\"extras.view_secret\")",
            "",
            "        with self.subTest(\"Secret check successful\"):",
            "            with tempfile.NamedTemporaryFile() as secret_file:",
            "                secret_file.write(b\"HELLO WORLD\")",
            "                test_secret = Secret.objects.create(",
            "                    name=\"secret-check-test-accessible\",",
            "                    provider=\"text-file\",",
            "                    parameters={\"path\": secret_file.name},",
            "                )",
            "                response = self.client.get(",
            "                    reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header",
            "                )",
            "                self.assertHttpStatus(response, status.HTTP_200_OK)",
            "                self.assertEqual(response.data[\"result\"], True)",
            "",
            "        with self.subTest(\"Secret check failed\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-failed\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-exist\"},",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(response.data[\"result\"], False)",
            "            self.assertIn(\"SecretValueNotFoundError\", response.data[\"message\"])",
            "",
            "",
            "class SecretsGroupTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroup",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    bulk_update_data = {}",
            "",
            "    slug_source = \"name\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\", slug=\"group-a\"),",
            "            SecretsGroup.objects.create(name=\"Group B\", slug=\"group-b\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", slug=\"group-c\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Secrets Group 1\",",
            "                \"slug\": \"secrets-group-1\",",
            "                \"description\": \"First Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 2\",",
            "                \"description\": \"Second Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 3\",",
            "                \"description\": \"Third Secrets Group\",",
            "            },",
            "        ]",
            "",
            "",
            "class SecretsGroupAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroupAssociation",
            "    brief_fields = [\"access_type\", \"display\", \"id\", \"secret\", \"secret_type\", \"url\"]",
            "    bulk_update_data = {}",
            "    choices_fields = [\"access_type\", \"secret_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-3\", provider=\"environment-variable\", parameters={\"variable\": \"YET_ANOTHER\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\", slug=\"group-a\"),",
            "            SecretsGroup.objects.create(name=\"Group B\", slug=\"group-b\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", slug=\"group-c\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[2],",
            "            group=secrets_groups[2],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"group\": secrets_groups[0].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[0].pk,",
            "            },",
            "            {",
            "                \"group\": secrets_groups[1].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[1].pk,",
            "            },",
            "            {",
            "                \"group\": secrets_groups[2].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[2].pk,",
            "            },",
            "        ]",
            "",
            "",
            "class StatusTest(APIViewTestCases.APIViewTestCase):",
            "    model = Status",
            "    brief_fields = [\"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    bulk_update_data = {",
            "        \"color\": \"000000\",",
            "    }",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Pizza\",",
            "            \"slug\": \"pizza\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.device\", \"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Oysters\",",
            "            \"slug\": \"oysters\",",
            "            \"color\": \"00ff00\",",
            "            \"content_types\": [\"ipam.ipaddress\", \"ipam.prefix\"],",
            "        },",
            "        {",
            "            \"name\": \"Bad combinations\",",
            "            \"slug\": \"bad-combinations\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "        {",
            "            \"name\": \"Status 1\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "    ]",
            "    slug_source = \"name\"",
            "",
            "",
            "class TagTestVersion12(APIViewTestCases.APIViewTestCase):",
            "    model = Tag",
            "    brief_fields = [\"color\", \"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"Tag 4\",",
            "            \"slug\": \"tag-4\",",
            "        },",
            "        {",
            "            \"name\": \"Tag 5\",",
            "            \"slug\": \"tag-5\",",
            "        },",
            "        {",
            "            \"name\": \"Tag 6\",",
            "            \"slug\": \"tag-6\",",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "",
            "    def test_all_relevant_content_types_assigned_to_tags_with_empty_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "",
            "        self.client.post(self._get_list_url(), self.create_data[0], format=\"json\", **self.header)",
            "",
            "        tag = Tag.objects.get(slug=self.create_data[0][\"slug\"])",
            "        self.assertEqual(",
            "            tag.content_types.count(),",
            "            TaggableClassesQuery().as_queryset().count(),",
            "        )",
            "",
            "",
            "class TagTestVersion13(",
            "    APIViewTestCases.CreateObjectViewTestCase,",
            "    APIViewTestCases.UpdateObjectViewTestCase,",
            "):",
            "    model = Tag",
            "    brief_fields = [\"color\", \"display\", \"id\", \"name\", \"slug\", \"url\"]",
            "    api_version = \"1.3\"",
            "    create_data = [",
            "        {\"name\": \"Tag 4\", \"slug\": \"tag-4\", \"content_types\": [Site._meta.label_lower]},",
            "        {\"name\": \"Tag 5\", \"slug\": \"tag-5\", \"content_types\": [Site._meta.label_lower]},",
            "        {\"name\": \"Tag 6\", \"slug\": \"tag-6\", \"content_types\": [Site._meta.label_lower]},",
            "    ]",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.update_data = {",
            "            \"name\": \"A new tag name\",",
            "            \"slug\": \"a-new-tag-name\",",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "        cls.bulk_update_data = {",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()]",
            "        }",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "",
            "        # VLANGroup is an OrganizationalModel, not a PrimaryModel, and therefore does not support tags",
            "        data = {**self.create_data[0], \"content_types\": [VLANGroup._meta.label_lower]}",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "",
            "        tag = Tag.objects.filter(slug=data[\"slug\"])",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(f\"Invalid content type: {VLANGroup._meta.label_lower}\", response.data[\"content_types\"])",
            "",
            "    def test_create_tags_without_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        data = {",
            "            \"name\": \"Tag 8\",",
            "            \"slug\": \"tag-8\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(str(response.data[\"content_types\"][0]), \"This field is required.\")",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.filter(content_types=ContentType.objects.get_for_model(Site)).first()",
            "        site = Site.objects.create(name=\"site 1\", slug=\"site-1\")",
            "        site.tags.add(tag_1)",
            "",
            "        tag_content_types = list(tag_1.content_types.all())",
            "        tag_content_types.remove(ContentType.objects.get_for_model(Site))",
            "",
            "        url = self._get_detail_url(tag_1)",
            "        data = {\"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types]}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            str(response.data[\"content_types\"][0]), \"Unable to remove dcim.site. Dependent objects were found.\"",
            "        )",
            "",
            "    def test_update_tag_content_type_unchanged(self):",
            "        \"\"\"Test updating a tag without changing its content-types.\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag = Tag.objects.exclude(content_types=ContentType.objects.get_for_model(Site)).first()",
            "        tag_content_types = list(tag.content_types.all())",
            "        url = self._get_detail_url(tag)",
            "        data = {\"color\": ColorChoices.COLOR_LIME}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"color\"], ColorChoices.COLOR_LIME)",
            "        self.assertEqual(",
            "            sorted(response.data[\"content_types\"]), sorted([f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types])",
            "        )",
            "",
            "        tag.refresh_from_db()",
            "        self.assertEqual(tag.color, ColorChoices.COLOR_LIME)",
            "        self.assertEqual(list(tag.content_types.all()), tag_content_types)",
            "",
            "",
            "class WebhookTest(APIViewTestCases.APIViewTestCase):",
            "    model = Webhook",
            "    brief_fields = [\"display\", \"id\", \"name\", \"url\"]",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-4\",",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://example.com/test4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-5\",",
            "            \"type_update\": True,",
            "            \"payload_url\": \"http://example.com/test5\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-6\",",
            "            \"type_delete\": True,",
            "            \"payload_url\": \"http://example.com/test6\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "    ]",
            "    choices_fields = [\"http_method\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.webhooks = (",
            "            Webhook(",
            "                name=\"api-test-1\",",
            "                type_create=True,",
            "                payload_url=\"http://example.com/test1\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-2\",",
            "                type_update=True,",
            "                payload_url=\"http://example.com/test2\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-3\",",
            "                type_delete=True,",
            "                payload_url=\"http://example.com/test3\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for webhook in cls.webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "    def test_create_webhooks_with_diff_content_type_same_url_same_action(self):",
            "        \"\"\"",
            "        Create a new webhook with diffrent content_types, same url and same action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | console port, create, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_diff_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and diff action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, delete, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_common_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and common action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, create, update, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0][\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )",
            "",
            "    def test_patch_webhooks_with_same_content_type_same_url_common_action(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        self.webhooks[2].payload_url = self.webhooks[1].payload_url",
            "        self.webhooks[2].save()",
            "",
            "        data = {\"type_update\": True}",
            "",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            f\"A webhook already exists for update on dcim | device type to URL {self.webhooks[1].payload_url}\",",
            "        )",
            "",
            "    def test_patch_webhooks(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        instance = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=self.webhooks[1].payload_url,",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"type_delete\": True}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"content_types\": [\"dcim.device\"]}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"payload_url\": \"http://example.com/test4\"}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_invalid_webhooks_patch(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        # Test patch payload_url with conflicts",
            "        instance_1 = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=\"http://example.com/test4\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_1.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"payload_url\": \"http://example.com/test2\"}",
            "        response = self.client.patch(self._get_detail_url(instance_1), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            \"A webhook already exists for update on dcim | device type to URL http://example.com/test2\",",
            "        )",
            "",
            "        # Test patch content_types with conflicts",
            "        instance_2 = Webhook.objects.create(",
            "            name=\"api-test-5\",",
            "            type_create=True,",
            "            payload_url=\"http://example.com/test1\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_2.content_types.set([ContentType.objects.get_for_model(Device)])",
            "",
            "        data = {\"content_types\": [\"dcim.devicetype\"]}",
            "        response = self.client.patch(self._get_detail_url(instance_2), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "755": [
                "DynamicGroupTest",
                "test_get_members"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/tests/test_dynamicgroups.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1002,
                "afterPatchRowNumber": 1002,
                "PatchRowcode": "             group.members_cached"
            },
            "1": {
                "beforePatchRowNumber": 1003,
                "afterPatchRowNumber": 1003,
                "PatchRowcode": "             self.assertEqual(mock_get_queryset.call_count, 1)"
            },
            "2": {
                "beforePatchRowNumber": 1004,
                "afterPatchRowNumber": 1004,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 1005,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            time.sleep(2)  # Let the cache expire"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1005,
                "PatchRowcode": "+            time.sleep(3)  # Let the cache expire"
            },
            "5": {
                "beforePatchRowNumber": 1006,
                "afterPatchRowNumber": 1006,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 1007,
                "afterPatchRowNumber": 1007,
                "PatchRowcode": "             group.members_cached"
            },
            "7": {
                "beforePatchRowNumber": 1008,
                "afterPatchRowNumber": 1008,
                "PatchRowcode": "             self.assertEqual(mock_get_queryset.call_count, 2)"
            }
        },
        "frontPatchFile": [
            "import random",
            "import time",
            "",
            "from unittest.mock import patch",
            "",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.cache import cache",
            "from django.core.exceptions import ValidationError",
            "from django.db.models import ProtectedError",
            "from django.urls import reverse",
            "from django.test import override_settings",
            "",
            "from nautobot.dcim.choices import PortTypeChoices",
            "from nautobot.dcim.filters import DeviceFilterSet",
            "from nautobot.dcim.forms import DeviceFilterForm, DeviceForm",
            "from nautobot.dcim.models import (",
            "    Device,",
            "    DeviceRole,",
            "    DeviceType,",
            "    FrontPort,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    RearPort,",
            "    Region,",
            "    Site,",
            ")",
            "from nautobot.extras.choices import (",
            "    CustomFieldFilterLogicChoices,",
            "    CustomFieldTypeChoices,",
            "    DynamicGroupOperatorChoices,",
            "    RelationshipTypeChoices,",
            ")",
            "from nautobot.extras.filters import DynamicGroupFilterSet, DynamicGroupMembershipFilterSet",
            "from nautobot.extras.models import (",
            "    CustomField,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Status,",
            ")",
            "from nautobot.ipam.models import Prefix",
            "from nautobot.tenancy.models import Tenant",
            "from nautobot.utilities.forms.fields import MultiValueCharField",
            "from nautobot.utilities.forms.widgets import MultiValueCharInput",
            "from nautobot.utilities.testing import TestCase",
            "",
            "",
            "class DynamicGroupTestBase(TestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.device_ct = ContentType.objects.get_for_model(Device)",
            "        cls.dynamicgroup_ct = ContentType.objects.get_for_model(DynamicGroup)",
            "",
            "        cls.sites = [",
            "            Site.objects.create(name=\"Site 1\", slug=\"site-1\"),",
            "            Site.objects.create(name=\"Site 2\", slug=\"site-2\"),",
            "            Site.objects.create(name=\"Site 3\", slug=\"site-3\"),",
            "            Site.objects.create(name=\"Site 4\", slug=\"site-4\"),",
            "        ]",
            "",
            "        cls.manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        cls.device_type = DeviceType.objects.create(",
            "            manufacturer=cls.manufacturer,",
            "            model=\"device Type 1\",",
            "            slug=\"device-type-1\",",
            "        )",
            "        cls.device_role = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\", color=\"ff0000\")",
            "        cls.status_active = Status.objects.get_for_model(Device).get(slug=\"active\")",
            "        cls.status_planned = Status.objects.get_for_model(Device).get(slug=\"planned\")",
            "        cls.status_staged = Status.objects.get_for_model(Device).get(slug=\"staged\")",
            "",
            "        cls.devices = [",
            "            Device.objects.create(",
            "                name=\"device-site-1\",",
            "                status=cls.status_active,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                site=cls.sites[0],",
            "            ),",
            "            Device.objects.create(",
            "                name=\"device-site-2\",",
            "                status=cls.status_active,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                serial=\"abc123\",",
            "                site=cls.sites[1],",
            "            ),",
            "            Device.objects.create(",
            "                name=\"device-site-3\",",
            "                status=cls.status_planned,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                site=cls.sites[2],",
            "            ),",
            "            Device.objects.create(",
            "                name=\"device-site-4\",",
            "                status=cls.status_staged,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                site=cls.sites[3],",
            "            ),",
            "        ]",
            "",
            "        cls.groups = [",
            "            DynamicGroup.objects.create(",
            "                name=\"Parent\",",
            "                slug=\"parent\",",
            "                description=\"The parent group with no filter\",",
            "                filter={},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Site-1 only",
            "            DynamicGroup.objects.create(",
            "                name=\"First Child\",",
            "                slug=\"first-child\",",
            "                description=\"The first child group\",",
            "                filter={\"site\": [\"site-1\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Site-2 only",
            "            DynamicGroup.objects.create(",
            "                name=\"Second Child\",",
            "                slug=\"second-child\",",
            "                description=\"A second child group\",",
            "                filter={\"site\": [\"site-3\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Empty filter to use for testing nesting.",
            "            DynamicGroup.objects.create(",
            "                name=\"Third Child\",",
            "                slug=\"third-child\",",
            "                description=\"A third child group with a child of its own\",",
            "                filter={},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Nested child of third-child to test ancestors/descendants",
            "            DynamicGroup.objects.create(",
            "                name=\"Nested Child\",",
            "                slug=\"nested-child\",",
            "                description=\"This will be the child of third-child\",",
            "                filter={\"status\": [\"active\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # No matches (bogus/invalid name match)",
            "            DynamicGroup.objects.create(",
            "                name=\"Invalid Filter\",",
            "                slug=\"invalid-filter\",",
            "                description=\"A group with a non-matching filter\",",
            "                filter={\"name\": [\"bogus\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"MultiValueCharFilter\",",
            "                slug=\"multivaluecharfilter\",",
            "                description=\"A group with a multivaluechar filter\",",
            "                filter={\"name\": [\"device-1\", \"device-2\", \"device-3\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "        ]",
            "",
            "        cls.parent = cls.groups[0]",
            "        cls.first_child = cls.groups[1]",
            "        cls.second_child = cls.groups[2]",
            "        cls.third_child = cls.groups[3]",
            "        cls.nested_child = cls.groups[4]",
            "        cls.invalid_filter = cls.groups[5]",
            "",
            "        # Setup the group membership hiearchy to use for graph testing",
            "        cls.memberships = [",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.parent,",
            "                group=cls.first_child,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            ),",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.parent,",
            "                group=cls.second_child,",
            "                weight=20,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "            ),",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.parent,",
            "                group=cls.third_child,",
            "                weight=30,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            ),",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.third_child,",
            "                group=cls.nested_child,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            ),",
            "        ]",
            "",
            "    def assertQuerySetEqual(self, left_qs, right_qs):",
            "        \"\"\"Compare two querysets and assert that they are equal.\"\"\"",
            "        self.assertEqual(",
            "            sorted(left_qs.values_list(\"pk\", flat=True)),",
            "            sorted(right_qs.values_list(\"pk\", flat=True)),",
            "        )",
            "",
            "",
            "class DynamicGroupModelTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroup model tests.\"\"\"",
            "",
            "    def test_content_type_is_immutable(self):",
            "        \"\"\"Test that `content_type` is immutable after create.\"\"\"",
            "        instance = self.groups[0]",
            "        with self.assertRaises(ValidationError):",
            "            instance.content_type = self.dynamicgroup_ct",
            "            instance.validated_save()",
            "",
            "    def test_full_clean_filter_not_dict(self):",
            "        \"\"\"Test that invalid filter types raise errors.\"\"\"",
            "        instance = self.groups[0]",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = None",
            "            instance.validated_save()",
            "",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = []",
            "            instance.validated_save()",
            "",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = \"site=ams01\"",
            "            instance.validated_save()",
            "",
            "    def test_full_clean_filter_not_valid(self):",
            "        \"\"\"Test that an invalid filter dict raises an error.\"\"\"",
            "        instance = self.groups[0]",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = {\"site\": -42}",
            "            instance.validated_save()",
            "",
            "    def test_clean_fields_exclude_filter(self):",
            "        \"\"\"Test that filter validation is skipped when an appropriate `exclude` parameter is provided.\"\"\"",
            "        instance = self.groups[0]",
            "        instance.filter = {\"platform\": -42}",
            "        instance.clean_fields(exclude=[\"filter\"])",
            "        instance.full_clean(exclude=[\"filter\"])",
            "",
            "        with self.assertRaises(ValidationError):",
            "            instance.clean_fields()",
            "        with self.assertRaises(ValidationError):",
            "            instance.full_clean()",
            "",
            "    def test_full_clean_valid(self):",
            "        \"\"\"Test a clean validation.\"\"\"",
            "        group = self.groups[0]",
            "        group.refresh_from_db()",
            "        old_filter = group.filter",
            "",
            "        # Overload the filter and validate that it is the same afterward.",
            "        new_filter = {\"interfaces\": True}",
            "        group.set_filter(new_filter)",
            "        group.validated_save()",
            "        self.assertEqual(group.filter, new_filter)",
            "",
            "        # Restore the old filter.",
            "        group.filter = old_filter",
            "        group.save()",
            "",
            "    def test_get_for_object(self):",
            "        \"\"\"Test `DynamicGroup.objects.get_for_object()`.\"\"\"",
            "        device1 = self.devices[0]  # site-1",
            "        device4 = self.devices[-1]  # site-4",
            "",
            "        # Assert that the groups we got from `get_for_object()` match the lookup",
            "        # from the group instance itself.",
            "        device1_groups = DynamicGroup.objects.get_for_object(device1)",
            "        self.assertQuerySetEqual(device1_groups, device1.dynamic_groups)",
            "",
            "        # Device4 should not be in ANY Dynamic Groups.",
            "        device4_groups = DynamicGroup.objects.get_for_object(device4)",
            "        self.assertEqual(list(device4_groups), [])",
            "        self.assertQuerySetEqual(device4_groups, device4.dynamic_groups)",
            "",
            "    def test_members(self):",
            "        \"\"\"Test `DynamicGroup.members`.\"\"\"",
            "        group = self.first_child",
            "        device1 = self.devices[0]",
            "        device2 = self.devices[1]",
            "",
            "        self.assertIn(device1, group.members)",
            "        self.assertNotIn(device2, group.members)",
            "",
            "    def test_members_tree_nodes(self):",
            "        \"\"\"",
            "        Test `DynamicGroup.members` when filtering on tree nodes like `Location`.",
            "        \"\"\"",
            "        # Grab some values we'll used to setup the test case.",
            "        device1 = self.devices[0]",
            "        device2 = self.devices[1]",
            "        site = device1.site",
            "        status = Status.objects.get(slug=\"active\")",
            "",
            "        # Create two LocationTypes (My Region > My Site)",
            "        loc_type_region = LocationType.objects.create(name=\"My Region\", slug=\"my-region\")",
            "        loc_type_region.content_types.add(self.device_ct)",
            "        loc_type_site = LocationType.objects.create(name=\"My Site\", slug=\"my-site\", parent=loc_type_region)",
            "        loc_type_site.content_types.add(self.device_ct)",
            "",
            "        loc_region = Location.objects.create(name=\"Location A\", location_type=loc_type_region, site=site, status=status)",
            "        loc_site = Location.objects.create(",
            "            name=\"Location B\", location_type=loc_type_site, parent=loc_region, status=status",
            "        )",
            "",
            "        # Add Location A to device1",
            "        device1.location = loc_region",
            "        device1.validated_save()",
            "",
            "        # Add Location B to device2",
            "        device2.site = device1.site",
            "        device2.location = loc_site",
            "        device2.validated_save()",
            "",
            "        expected = sorted([device1.name, device2.name])",
            "",
            "        # Create the Dynamic Group filtering on Location A",
            "        group = DynamicGroup.objects.create(",
            "            name=\"Devices Location\",",
            "            slug=\"devices-location\",",
            "            content_type=self.device_ct,",
            "            filter={\"location\": [\"location-a\"]},",
            "        )",
            "",
            "        # We are expecting that the group members here should be nested results from any devices",
            "        # that have a Location whose parent is \"Location A\".",
            "        self.assertEqual(",
            "            sorted(m.name for m in group.members),",
            "            expected,",
            "        )",
            "",
            "        # Now also test that an advancted (nested) dynamic group, also reports",
            "        # the same number of members.",
            "        parent_group = DynamicGroup.objects.create(",
            "            name=\"Parent of Devices Location\",",
            "            slug=\"parent-devices-location\",",
            "            content_type=self.device_ct,",
            "            filter={},",
            "        )",
            "        parent_group.add_child(",
            "            child=group,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            weight=10,",
            "        )",
            "        self.assertEqual(",
            "            sorted(m.name for m in parent_group.members),",
            "            expected,",
            "        )",
            "",
            "    def test_count(self):",
            "        \"\"\"Test `DynamicGroup.count`.\"\"\"",
            "        expected = {",
            "            self.parent.count: 2,",
            "            self.first_child.count: 1,",
            "            self.second_child.count: 1,",
            "            self.third_child.count: 2,",
            "            self.nested_child.count: 2,",
            "            self.invalid_filter.count: 0,",
            "        }",
            "        for grp, cnt in expected.items():",
            "            self.assertEqual(grp, cnt)",
            "",
            "    def test_get_queryset(self):",
            "        \"\"\"Test `DynamicGroup.get_queryset()`.\"\"\"",
            "        group = self.first_child",
            "        device1 = self.devices[0]",
            "",
            "        # Test that we can get a full queryset",
            "        qs = group.get_queryset()",
            "        devices = group.model.objects.filter(site=device1.site)",
            "",
            "        # Expect a single-member qs/list of Device names (only `device1`)",
            "        expected = [device1.name]",
            "        self.assertIn(device1, devices)",
            "        self.assertIn(device1, qs)",
            "        self.assertEqual(list(map(str, devices)), expected)",
            "        self.assertEqual(list(map(str, qs)), expected)",
            "        self.assertEqual(list(qs), list(devices))",
            "",
            "        # A new group that doesn't have a content_type and therefore",
            "        # `self.model`, should raise a RuntimeError",
            "        new_group = DynamicGroup()",
            "        with self.assertRaises(RuntimeError):",
            "            new_group.get_queryset()",
            "",
            "    def test_model(self):",
            "        \"\"\"Test `DynamicGroup.model`.\"\"\"",
            "        # New instances should not have a model unless `content_type` is set.",
            "        new_group = DynamicGroup(name=\"Unsaved Group\", slug=\"unsaved-group\")",
            "        self.assertIsNone(new_group.model)",
            "",
            "        # Setting the content_type will now allow `.model` to be accessed.",
            "        new_group.content_type = self.device_ct",
            "        self.assertIsNotNone(new_group.model)",
            "",
            "    def test_set_object_classes(self):",
            "        \"\"\"Test `DynamicGroup._set_object_classes()`.\"\"\"",
            "        # New instances should fail to map until `content_type` is set.",
            "        new_group = DynamicGroup(name=\"Unsaved Group\", slug=\"unsaved-group\")",
            "        objects_mapped = new_group._set_object_classes(new_group.model)",
            "        self.assertFalse(objects_mapped)",
            "",
            "        # Existing groups w/ `content_type` set work as expected.",
            "        group = self.groups[0]",
            "        model = group.content_type.model_class()",
            "        objects_mapped = group._set_object_classes(model)",
            "",
            "        self.assertTrue(objects_mapped)",
            "        self.assertEqual(group.model, model)",
            "        self.assertEqual(group.filterset_class, DeviceFilterSet)",
            "        self.assertEqual(group.filterform_class, DeviceFilterForm)",
            "        self.assertEqual(group.form_class, DeviceForm)",
            "",
            "    def test_get_group_members_url(self):",
            "        \"\"\"Test `DynamicGroup.get_group_members_url().\"\"\"",
            "",
            "        # First assert that a basic group with no children, then a group with children, will always",
            "        # link to the members tab on the detail view.",
            "        for group in [self.first_child, self.parent]:",
            "            detail_url = reverse(\"extras:dynamicgroup\", kwargs={\"slug\": group.slug})",
            "            params = \"tab=members\"",
            "            url = f\"{detail_url}?{params}\"",
            "            self.assertEqual(group.get_group_members_url(), url)",
            "",
            "        # If the new group has no attributes or map yet, expect an empty string.",
            "        new_group = DynamicGroup()",
            "        self.assertEqual(new_group.get_group_members_url(), \"\")",
            "",
            "    def test_map_filter_fields(self):",
            "        \"\"\"Test `DynamicGroup._map_filter_fields`.\"\"\"",
            "        group = self.groups[0]",
            "        fields = group._map_filter_fields",
            "",
            "        # Test that it's a dict with or without certain key fields.",
            "        self.assertIsInstance(fields, dict)",
            "        self.assertNotEqual(fields, {})",
            "        self.assertNotIn(\"comments\", fields)",
            "        self.assertIn(\"name\", fields)",
            "        # See if a CharField is properly converted to a MultiValueCharField In DynamicGroupEditForm.",
            "        self.assertIsInstance(fields[\"name\"], MultiValueCharField)",
            "        self.assertIsInstance(fields[\"name\"].widget, MultiValueCharInput)",
            "",
            "    def test_map_filter_fields_skip_missing(self):",
            "        \"\"\"",
            "        Test that missing fields are skipped in `DynamicGroup._map_filter_fields`",
            "        when `Model.dynamic_group_skip_missing_fields` is `True`.",
            "        \"\"\"",
            "        group = self.groups[0]",
            "",
            "        try:",
            "            group.model.dynamic_group_skip_missing_fields = True",
            "            fields = group._map_filter_fields",
            "            # Test that it's a dict with or without certain key fields.",
            "            self.assertIsInstance(fields, dict)",
            "            self.assertNotEqual(fields, {})",
            "            self.assertNotIn(\"name\", fields)",
            "            self.assertNotIn(\"asset_tag\", fields)",
            "            self.assertNotIn(\"serial\", fields)",
            "        finally:",
            "            del group.model.dynamic_group_skip_missing_fields",
            "",
            "    def test_map_filter_fields_skip_method_filters_generate_query(self):",
            "        \"\"\"",
            "        Test that method filters are skipped in `DynamicGroup._map_filter_fields` when the filterset",
            "        for the group's content type has a method named `generate_query_{filter_method}`.",
            "        \"\"\"",
            "        group = self.groups[0]",
            "        filterset = group.filterset_class()",
            "        fields = group._map_filter_fields",
            "",
            "        # We know that `has_primary_ip` fits this bill, so let's test that.",
            "        field_name = \"has_primary_ip\"",
            "        filter_field = filterset.filters[field_name]",
            "",
            "        # Make some field presence assertions",
            "        self.assertIn(field_name, fields)",
            "",
            "        # The filterset should have the method name and `generate_query_` method",
            "        self.assertTrue(hasattr(filterset, filter_field.method))",
            "        self.assertTrue(hasattr(filterset, \"generate_query_\" + filter_field.method))",
            "",
            "    # 2.0 TODO(jathan): This is done using `DeviceFilterSet.pass_through_ports` at this time and",
            "    # should be revised as filter fields are vetted.",
            "    def test_filter_method_generate_query(self):",
            "        \"\"\"",
            "        Test that a filter with a filter method's corresponding `generate_query_{filter_method}` works as intended.",
            "        \"\"\"",
            "        group = self.groups[0]",
            "",
            "        # We're going to test `pass_through_ports`",
            "        device = self.devices[0]",
            "        rear_port = RearPort.objects.create(device=device, name=\"rp1\", positions=1, type=PortTypeChoices.TYPE_8P8C)",
            "        FrontPort.objects.create(",
            "            device=device, name=\"fp1\", type=PortTypeChoices.TYPE_FC, rear_port=rear_port, rear_port_position=1",
            "        )",
            "",
            "        # Test that the filter returns the one device to which we added front/rear ports.",
            "        expected = [\"device-site-1\"]",
            "        filterset = group.filterset_class({\"pass_through_ports\": True}, Device.objects.all())",
            "        devices = list(filterset.qs.values_list(\"name\", flat=True))",
            "        self.assertEqual(expected, devices)",
            "",
            "    # 2.0 TODO(jathan): This is done using Prefix at this time and this should be revised as filter",
            "    # fields are vetted.",
            "    def test_map_filter_fields_skip_method_filters_no_generate_query(self):",
            "        \"\"\"",
            "        Test that method filters are skipped in `DynamicGroup._map_filter_fields` when the filterset",
            "        for the group's content type DOES NOT have a method named `generate_query_{filter_method}`.",
            "",
            "        \"\"\"",
            "        pfx_content_type = ContentType.objects.get_for_model(Prefix)",
            "        group = DynamicGroup(name=\"pfx\", slug=\"pfx\", content_type=pfx_content_type)",
            "        filterset = group.filterset_class()",
            "        fields = group._map_filter_fields",
            "",
            "        # We know that `within_include` does not have a `generate_query_{filter_method}` method.",
            "        field_name = \"within_include\"",
            "        filter_field = filterset.filters[field_name]",
            "",
            "        # Make some field presence assertions",
            "        self.assertNotIn(field_name, fields)",
            "",
            "        # The filterset should have the method name BUT NOT `generate_query_` method",
            "        self.assertTrue(hasattr(filterset, filter_field.method))",
            "        self.assertFalse(hasattr(filterset, \"generate_query_\" + filter_field.method))",
            "",
            "    def test_get_filter_fields(self):",
            "        \"\"\"Test `DynamicGroup.get_filter_fields()`.\"\"\"",
            "        # New instances should return {} `content_type` is set.",
            "        new_group = DynamicGroup(name=\"Unsaved Group\", slug=\"unsaved-group\")",
            "        new_filter_fields = new_group.get_filter_fields()",
            "        self.assertEqual(new_filter_fields, {})",
            "",
            "        # Existing groups should have actual fields.",
            "        group = self.groups[0]",
            "        filter_fields = group.get_filter_fields()",
            "        self.assertIsInstance(filter_fields, dict)",
            "        self.assertNotEqual(filter_fields, {})",
            "        self.assertNotIn(\"comments\", filter_fields)",
            "        self.assertIn(\"name\", filter_fields)",
            "",
            "    def test_generate_filter_form(self):",
            "        \"\"\"Test `DynamicGroup.generate_filter_form()`.\"\"\"",
            "        group = self.groups[0]",
            "        filter_fields = group.get_filter_fields()",
            "        form_class = group.generate_filter_form()",
            "        form = form_class(group.filter)",
            "",
            "        # Form should validate just fine from the group's filter",
            "        self.assertTrue(form.is_valid())",
            "",
            "        # Form instance should have identical field set to filter fields.",
            "        self.assertEqual(sorted(form.fields), sorted(filter_fields))",
            "",
            "    def test_get_initial(self):",
            "        \"\"\"Test `DynamicGroup.get_initial()`.\"\"\"",
            "        group1 = self.first_child  # Filter has `site`",
            "        self.assertEqual(group1.get_initial(), group1.filter)",
            "        # Test if MultiValueCharField is properly pre-populated",
            "        group2 = self.groups[6]  # Filter has `name`",
            "        initial = group2.get_initial()",
            "        expected = {\"name\": [\"device-1\", \"device-2\", \"device-3\"]}",
            "        self.assertEqual(initial, expected)",
            "",
            "    def test_set_filter(self):",
            "        \"\"\"Test `DynamicGroup.set_filter()`.\"\"\"",
            "        group = self.groups[0]",
            "",
            "        # Input can come from a form's cleaned_data, such as our generated form. In this case, the",
            "        # filter we set from the form should be identical to what was there already.",
            "        old_filter = group.filter",
            "        form_class = group.generate_filter_form()",
            "        form_class.prefix = None  # We don't want the prefix here right now.",
            "        form = form_class(group.filter)",
            "        form.is_valid()",
            "        group.set_filter(form.cleaned_data)",
            "        self.assertEqual(group.filter, old_filter)",
            "",
            "        # Now we'll do it using a manually crafted dict.",
            "        new_filter = {\"interfaces\": True}",
            "        group.set_filter(new_filter)",
            "        self.assertEqual(group.filter, new_filter)",
            "",
            "        # And a bad input",
            "        bad_filter = {\"site\": -42}",
            "        with self.assertRaises(ValidationError):",
            "            group.set_filter(bad_filter)",
            "",
            "        # Cleanup because we're using class-based fixtures in `setUpTestData()`",
            "        group.refresh_from_db()",
            "",
            "    def test_add_child(self):",
            "        \"\"\"Test `DynamicGroup.add_child()`.\"\"\"",
            "        self.parent.add_child(",
            "            child=self.invalid_filter,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            weight=10,",
            "        )",
            "        self.assertTrue(self.parent.children.filter(slug=self.invalid_filter.slug).exists())",
            "",
            "    def test_clean_child_validation(self):",
            "        \"\"\"Test various ways in which adding a child group should fail.\"\"\"",
            "        parent = self.parent",
            "        parent.filter = {\"site\": [\"site-1\"]}",
            "        child = self.invalid_filter",
            "",
            "        # parent.add_child() should fail",
            "        with self.assertRaises(ValidationError):",
            "            parent.add_child(",
            "                child=child,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "        # parent.children.add() should fail",
            "        with self.assertRaises(ValidationError):",
            "            parent.children.add(",
            "                child,",
            "                through_defaults={\"operator\": DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE, \"weight\": 10},",
            "            )",
            "",
            "    def test_remove_child(self):",
            "        \"\"\"Test `DynamicGroup.remove_child()`.\"\"\"",
            "        self.parent.remove_child(self.third_child)",
            "        self.assertFalse(self.parent.children.filter(slug=self.third_child.slug).exists())",
            "",
            "    def test_generate_query_for_filter(self):",
            "        \"\"\"Test `DynamicGroup.generate_query_for_filter()`.\"\"\"",
            "        group = self.parent  # Any group will do, so why not this one?",
            "        multi_value = [\"site-3\"]",
            "        fs = group.filterset_class()",
            "        multi_field = fs.filters[\"site\"]",
            "        multi_query = group.generate_query_for_filter(",
            "            filter_field=multi_field,",
            "            value=multi_value,",
            "        )",
            "",
            "        queryset = group.get_queryset()",
            "",
            "        # Assert that both querysets resturn the same results",
            "        group_qs = queryset.filter(multi_query)",
            "        device_qs = Device.objects.filter(site__slug__in=multi_value)",
            "        self.assertQuerySetEqual(group_qs, device_qs)",
            "",
            "        # Now do a non-multi-value filter.",
            "        # 2.0 TODO(jathan): When \"serial\" becomes a multi-value filter, this will need to be revised or removed.",
            "        solo_field = fs.filters[\"serial\"]",
            "        solo_value = \"abc123\"",
            "        solo_query = group.generate_query_for_filter(filter_field=solo_field, value=solo_value)",
            "        solo_qs = queryset.filter(solo_query)",
            "        serial_qs = Device.objects.filter(serial__iexact=solo_value)",
            "        self.assertQuerySetEqual(solo_qs, serial_qs)",
            "",
            "        # Test that a nested field_name w/ `generate_query` works as expected. This is explicitly to",
            "        # test a regression w/ nested slug-related values such as `DeviceFilterSet.region` which",
            "        # filters on `site__region`.",
            "        parent_region = Region.objects.filter(children__isnull=False).first()",
            "        nested_value = [parent_region.slug]",
            "        group.set_filter({\"region\": nested_value})",
            "        group.validated_save()",
            "",
            "        # We are making sure the filterset generated from the slug as an argument results in the same",
            "        # filtered queryset, and more importantly that the nested filter expression `site__region`",
            "        # is automatically used to get the related model name without failing.",
            "        nested_query = group.generate_query_for_filter(filter_field=fs.filters[\"region\"], value=nested_value)",
            "        nested_qs = queryset.filter(nested_query)",
            "        region_qs = Device.objects.filter(site__region__slug__in=nested_value)",
            "        self.assertQuerySetEqual(nested_qs, region_qs)",
            "",
            "    def test_generate_query_for_group(self):",
            "        \"\"\"Test `DynamicGroup.generate_query_for_group()`.\"\"\"",
            "        group = self.parent",
            "",
            "        # A group with an empty filter will have a null `Q` object",
            "        parent_q = group.generate_query_for_group(group)",
            "        self.assertFalse(parent_q)",
            "",
            "        # A child group with a filter set will result in a useful Q object.",
            "        child_q = group.generate_query_for_group(self.second_child)",
            "        lookup_kwargs = dict(child_q.children)  # {name: value}",
            "",
            "        # Assert that both querysets resturn the same results",
            "        group_qs = group.get_queryset().filter(child_q)",
            "        device_qs = Device.objects.filter(**lookup_kwargs)",
            "        self.assertQuerySetEqual(group_qs, device_qs)",
            "",
            "    def test_get_group_queryset(self):",
            "        \"\"\"Test `DynamicGroup.get_group_queryset()`.\"\"\"",
            "        # This is literally just calling `process_group_filters(self)` so let's",
            "        # just make sure that it stays consistent until we decide otherwise.",
            "        group = self.parent",
            "        group_qs = group.get_group_queryset()",
            "        process_query = group.generate_query()",
            "        base_qs = group.get_queryset()",
            "        process_qs = base_qs.filter(process_query)",
            "",
            "        self.assertQuerySetEqual(group_qs, process_qs)",
            "",
            "    def test_get_ancestors(self):",
            "        \"\"\"Test `DynamicGroup.get_ancestors()`.\"\"\"",
            "        expected = [\"third-child\", \"parent\"]",
            "        ancestors = [a.slug for a in self.nested_child.get_ancestors()]",
            "        self.assertEqual(ancestors, expected)",
            "",
            "    def test_get_descendants(self):",
            "        \"\"\"Test `DynamicGroup.get_descendants()`.\"\"\"",
            "        expected = [\"first-child\", \"second-child\", \"third-child\", \"nested-child\"]",
            "        descendants = [d.slug for d in self.parent.get_descendants()]",
            "        self.assertEqual(descendants, expected)",
            "",
            "    def test_get_siblings(self):",
            "        \"\"\"Test `DynamicGroup.get_siblings()`.\"\"\"",
            "        expected = [\"first-child\", \"second-child\"]",
            "        siblings = sorted(s.slug for s in self.third_child.get_siblings())",
            "        self.assertEqual(siblings, expected)",
            "",
            "    def test_is_root(self):",
            "        \"\"\"Test `DynamicGroup.is_root()`.\"\"\"",
            "        self.assertTrue(self.parent.is_root())",
            "        self.assertFalse(self.nested_child.is_root())",
            "",
            "    def test_is_leaf(self):",
            "        \"\"\"Test `DynamicGroup.is_leaf()`.\"\"\"",
            "        self.assertFalse(self.parent.is_leaf())",
            "        self.assertTrue(self.nested_child.is_leaf())",
            "",
            "    def test_get_ancestors_queryset(self):",
            "        \"\"\"Test `DynamicGroup.get_ancestors_queryset()`.\"\"\"",
            "        a1 = self.parent.get_ancestors()",
            "        a2 = self.parent.get_ancestors_queryset()",
            "        self.assertEqual(list(a1), list(a2))",
            "",
            "    def test_descendants(self):",
            "        \"\"\"Test `DynamicGroup.get_descendants_queryset()`.\"\"\"",
            "        d1 = self.parent.get_descendants()",
            "        d2 = self.parent.get_descendants_queryset()",
            "        self.assertEqual(list(d1), list(d2))",
            "",
            "    def test_ancestors_tree(self):",
            "        \"\"\"Test `DynamicGroup.ancestors_tree()`.\"\"\"",
            "        a_tree = self.nested_child.ancestors_tree()",
            "        self.assertIn(self.parent, a_tree[self.third_child])",
            "",
            "    def test_descendants_tree(self):",
            "        \"\"\"Test `DynamicGroup.descendants_tree()`.\"\"\"",
            "        d_tree = self.parent.descendants_tree()",
            "        self.assertIn(self.nested_child, d_tree[self.third_child])",
            "",
            "    def test_flatten_descendants_tree(self):",
            "        \"\"\"Test `DynamicGroup.flatten_descendants_tree()`.\"\"\"",
            "        # Assert descendants are deterministic",
            "        d_tree = self.parent.descendants_tree()",
            "        d_flat = self.parent.flatten_descendants_tree(d_tree)",
            "        expected = {\"first-child\": 1, \"second-child\": 1, \"third-child\": 1, \"nested-child\": 2}",
            "        seen = {d.slug: d.depth for d in d_flat}",
            "        self.assertEqual(seen, expected)",
            "",
            "        # Parent should not be here; nested-child should.",
            "        self.assertNotIn(self.parent, d_flat)",
            "        self.assertIn(self.nested_child, d_flat)",
            "",
            "    def test_flatten_ancestors_tree(self):",
            "        \"\"\"Test `DynamicGroup.flatten_ancestors_tree()`.\"\"\"",
            "        # Assert ancestors are deterministic",
            "        a_tree = self.nested_child.ancestors_tree()",
            "        a_flat = self.nested_child.flatten_ancestors_tree(a_tree)",
            "        expected = {\"third-child\": 1, \"parent\": 2}",
            "        seen = {a.slug: a.depth for a in a_flat}",
            "        self.assertEqual(seen, expected)",
            "",
            "        # Nested-child should not be here; parent should.",
            "        self.assertNotIn(self.nested_child, a_flat)",
            "        self.assertIn(self.parent, a_flat)",
            "",
            "    def test_membership_tree(self):",
            "        \"\"\"Test `DynamicGroup.membership_tree()`.\"\"\"",
            "        group = self.parent",
            "",
            "        d_tree = group.flatten_descendants_tree(group.descendants_tree())",
            "        m_tree = group.membership_tree()",
            "",
            "        d_groups = [d.slug for d in d_tree]",
            "        m_groups = [m.group.slug for m in m_tree]",
            "",
            "        d_depths = [d.depth for d in d_tree]",
            "        m_depths = [m.depth for m in m_tree]",
            "",
            "        # Assert same members, same order.",
            "        self.assertEqual(d_groups, m_groups)",
            "        # Assert same depths.",
            "        self.assertEqual(d_depths, m_depths)",
            "",
            "    def test_ordered_queryset_from_pks(self):",
            "        \"\"\"Test `DynamicGroup.ordered_queryset_from_pks()`.\"\"\"",
            "        descendants = self.parent.get_descendants()",
            "        pk_list = [d.pk for d in descendants]",
            "",
            "        # Assert that ordering is always deterministic by shuffling the list of pks and asserting",
            "        # that the ordered pk matches that shuffled order.",
            "        random.shuffle(pk_list)",
            "        ordered_qs = self.parent.ordered_queryset_from_pks(pk_list)",
            "        self.assertEqual(",
            "            pk_list,",
            "            [o.pk for o in ordered_qs],",
            "        )",
            "",
            "    def test_generate_query(self):",
            "        \"\"\"Test `DynamicGroup.generate_query()`.\"\"\"",
            "        # Start with parent. Enumerate descendants and their operators to assert correct results.",
            "        group = self.parent",
            "        group_query = group.generate_query()",
            "        group_qs = group.get_queryset().filter(group_query)",
            "",
            "        # <DynamicGroupMembership: First Child: intersection (10)>",
            "        # <DynamicGroupMembership: Second Child: union (20)>",
            "        # <DynamicGroupMembership: Third Child: difference (30)>",
            "        group_members = group.dynamic_group_memberships.all()",
            "",
            "        # Manually iterate over the groups to assert the same result that the queryset should have,",
            "        # igoring weight since each set of members are already ordered by weight when queried from",
            "        # the database.",
            "        child_set = set(group.get_queryset())",
            "        for member in group_members:",
            "            child_members = set(member.members)",
            "            operator = member.operator",
            "            # Use operator value to call a set method; one of intersection, union, difference and",
            "            # update the results set. (e.g. `child_set.difference(child_members)`",
            "            if operator == \"union\":",
            "                child_set = child_set | child_members",
            "            elif operator == \"difference\":",
            "                child_set = child_set - child_members",
            "            elif operator == \"intersection\":",
            "                child_set = child_set & child_members",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(group_qs.count(), len(child_set))",
            "",
            "        # And have the same members...",
            "        expected = [\"device-site-3\"]",
            "        self.assertEqual(sorted(group_qs.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_delete(self):",
            "        \"\"\"Test `DynamicGroup(instance).delete()`.\"\"\"",
            "        # Has parents",
            "        with self.assertRaises(ProtectedError):",
            "            self.nested_child.delete()",
            "",
            "        # Clear the deeply nested child's parents then delete it!",
            "        self.nested_child.parents.clear()",
            "        self.nested_child.delete()",
            "",
            "    def test_filter_relationships(self):",
            "        \"\"\"Test that relationships can be used in filters.\"\"\"",
            "        prefix_ct = ContentType.objects.get_for_model(Prefix)",
            "",
            "        device = self.devices[0]",
            "        prefix = Prefix.objects.first()",
            "",
            "        relationship = Relationship(",
            "            name=\"Device to Prefix\",",
            "            slug=\"device_to_prefix\",",
            "            source_type=self.device_ct,",
            "            source_label=\"My Prefixes\",",
            "            source_filter=None,",
            "            destination_type=prefix_ct,",
            "            destination_label=\"My Devices\",",
            "            type=RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "        )",
            "        relationship.validated_save()",
            "",
            "        ra = RelationshipAssociation(",
            "            relationship=relationship,",
            "            source=device,",
            "            destination=prefix,",
            "        )",
            "        ra.validated_save()",
            "",
            "        dg = DynamicGroup(",
            "            name=\"relationships\",",
            "            slug=\"relationships\",",
            "            description=\"I filter on relationships.\",",
            "            filter={\"cr_device_to_prefix__destination\": [prefix.pk]},",
            "            content_type=self.device_ct,",
            "        )",
            "        dg.validated_save()",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(dg.count, 1)",
            "",
            "        # And have the same members...",
            "        self.assertIn(device, dg.members)",
            "        expected = [str(device)]",
            "        self.assertEqual(sorted(dg.members.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_filter_custom_fields(self):",
            "        \"\"\"Test that relationships can be used in filters.\"\"\"",
            "",
            "        device = self.devices[0]",
            "",
            "        cf = CustomField.objects.create(",
            "            name=\"favorite_food\",",
            "            type=CustomFieldTypeChoices.TYPE_TEXT,",
            "            filter_logic=CustomFieldFilterLogicChoices.FILTER_LOOSE,",
            "        )",
            "        cf.content_types.add(self.device_ct)",
            "",
            "        device._custom_field_data = {\"favorite_food\": \"bacon\"}",
            "        device.validated_save()",
            "        device.refresh_from_db()",
            "",
            "        dg = DynamicGroup(",
            "            name=\"custom_fields\",",
            "            slug=\"custom_fields\",",
            "            description=\"I filter on custom fields.\",",
            "            filter={\"cf_favorite_food\": \"bacon\"},",
            "            content_type=self.device_ct,",
            "        )",
            "        dg.validated_save()",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(dg.count, 1)",
            "",
            "        # And have the same members...",
            "        self.assertIn(device, dg.members)",
            "        expected = [str(device)]",
            "        self.assertEqual(sorted(dg.members.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_filter_search(self):",
            "        \"\"\"Test that search (`q` filter) can be used in filters.\"\"\"",
            "",
            "        # Rename the device to explicitly match on search.",
            "        device = self.devices[0]",
            "        device.name = \"pizza-party-machine\"",
            "        device.save()",
            "",
            "        dg = DynamicGroup(",
            "            name=\"custom_fields\",",
            "            slug=\"custom_fields\",",
            "            description=\"I filter on the q field\",",
            "            filter={\"q\": \"party\"},  # Let's party! \ud83c\udf89",
            "            content_type=self.device_ct,",
            "        )",
            "        dg.validated_save()",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(dg.count, 1)",
            "",
            "        # And have the same members...",
            "        self.assertIn(device, dg.members)",
            "        expected = [str(device)]",
            "        self.assertEqual(sorted(dg.members.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_group_overloaded_filter_form_field(self):",
            "        \"\"\"FilterForm fields can overload how they pass in the values.\"\"\"",
            "",
            "        prefix_ct = ContentType.objects.get_for_model(Prefix)",
            "",
            "        a_tenant = Tenant.objects.first()",
            "",
            "        this_dg = DynamicGroup(",
            "            name=\"Prefix Group\",",
            "            slug=\"prefix-dg\",",
            "            description=\"A group of prefixes with a specific Tenant name.\",",
            "            filter={},",
            "            content_type=prefix_ct,",
            "        )",
            "        this_dg.validated_save()",
            "",
            "        this_dg.set_filter({\"example_plugin_prefix_tenant_name\": [a_tenant]})",
            "        this_dg.validated_save()",
            "",
            "    def test_member_caching_output(self):",
            "        group = self.first_child",
            "",
            "        # Ensure the cache is empty from previous tests",
            "        cache.delete(group.members_cache_key)",
            "",
            "        self.assertEqual(sorted(list(group.members)), sorted(list(group.members_cached)))",
            "",
            "    @override_settings(DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT=2)",
            "    def test_member_caching_enabled(self):",
            "        \"\"\"",
            "        Verify that the members list of the DynamicGroup is cached and expires.",
            "        \"\"\"",
            "        group = self.first_child",
            "",
            "        class FakeQuerySet:",
            "            def all(self):",
            "                return []",
            "",
            "        # Ensure the cache is empty from previous tests",
            "        cache.delete(group.members_cache_key)",
            "",
            "        with patch.object(group, \"get_queryset\", return_value=FakeQuerySet()) as mock_get_queryset:",
            "            group.members_cached",
            "            group.members_cached",
            "            group.members_cached",
            "            self.assertEqual(mock_get_queryset.call_count, 1)",
            "",
            "            time.sleep(2)  # Let the cache expire",
            "",
            "            group.members_cached",
            "            self.assertEqual(mock_get_queryset.call_count, 2)",
            "",
            "        # Clean-up after ourselves",
            "        cache.delete(f\"{group.__class__.__name__}.{group.id}.cached_members\")",
            "",
            "    @override_settings(DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT=0)",
            "    def test_member_caching_disabled(self):",
            "        \"\"\"",
            "        Verify that the members list of the DynamicGroup is not cached.",
            "        \"\"\"",
            "        group = self.first_child",
            "",
            "        class FakeQuerySet:",
            "            def all(self):",
            "                return []",
            "",
            "        # Ensure the cache is empty from previous tests",
            "        cache.delete(group.members_cache_key)",
            "",
            "        with patch.object(group, \"get_queryset\", return_value=FakeQuerySet()) as mock_get_queryset:",
            "            group.members_cached",
            "            group.members_cached",
            "            self.assertEqual(mock_get_queryset.call_count, 2)",
            "",
            "",
            "class DynamicGroupMembershipModelTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroupMembership model tests.\"\"\"",
            "",
            "    def test_clean_content_type(self):",
            "        \"\"\"Assert that content_type b/w parent/group must match.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.first_child.content_type = self.dynamicgroup_ct",
            "            self.parent.add_child(",
            "                child=self.first_child,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "        # Cleanup because we're using class-based fixtures in `setUpTestData()`",
            "        self.first_child.refresh_from_db()",
            "",
            "    def test_clean_block_self(self):",
            "        \"\"\"Assert that a group cannot be its own child.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.parent.add_child(",
            "                child=self.parent,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "    def test_clean_loop_detection(self):",
            "        \"\"\"Assert that graph loops are blocked (ancestors can't be a child).\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.third_child.add_child(",
            "                child=self.parent,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "    def test_clean_child_uniqueness(self):",
            "        \"\"\"Assert that membership uniqueness criteria are enforced.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.third_child.add_child(",
            "                child=self.nested_child,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            )",
            "",
            "    def test_clean_parent_filter_exclusivity(self):",
            "        \"\"\"Assert that if `parent_group.filter` is set that it blocks creation.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=self.first_child,",
            "                group=self.invalid_filter,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            )",
            "",
            "    def test_group_attributes(self):",
            "        \"\"\"Test passthrough attributes to `self.group`.\"\"\"",
            "        mem = self.memberships[0]",
            "        grp = mem.group",
            "",
            "        self.assertEqual(mem.name, grp.name)",
            "        self.assertEqual(sorted(mem.members), sorted(grp.members))",
            "        self.assertEqual(mem.count, grp.count)",
            "        self.assertEqual(mem.get_absolute_url(), grp.get_absolute_url())",
            "        self.assertEqual(mem.get_group_members_url(), grp.get_group_members_url())",
            "",
            "",
            "class DynamicGroupFilterTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroup instance filterset tests.\"\"\"",
            "",
            "    queryset = DynamicGroup.objects.all()",
            "    filterset = DynamicGroupFilterSet",
            "",
            "    def test_id(self):",
            "        params = {\"id\": self.queryset.values_list(\"pk\", flat=True)[:2]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_name(self):",
            "        params = {\"name\": [\"First Child\", \"Third Child\"]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_slug(self):",
            "        params = {\"slug\": [\"invalid-filter\"]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 1)",
            "",
            "    def test_content_type(self):",
            "        params = {\"content_type\": [\"dcim.device\", \"virtualization.virtualmachine\"]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 7)",
            "",
            "    def test_search(self):",
            "        tests = {",
            "            \"Devices No Filter\": 0,  # name",
            "            \"Invalid Filter\": 1,  # name",
            "            \"invalid-filter\": 1,  # slug",
            "            \"A group with a non-matching filter\": 1,  # description",
            "            \"dcim\": 7,  # content_type__app_label",
            "            \"device\": 7,  # content_type__model",
            "        }",
            "        for value, cnt in tests.items():",
            "            params = {\"q\": value}",
            "            self.assertEqual(self.filterset(params, self.queryset).qs.count(), cnt)",
            "",
            "",
            "class DynamicGroupMembershipFilterTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroupMembership instance filterset tests.\"\"\"",
            "",
            "    queryset = DynamicGroupMembership.objects.all()",
            "    filterset = DynamicGroupMembershipFilterSet",
            "",
            "    def test_id(self):",
            "        params = {\"id\": self.queryset.values_list(\"pk\", flat=True)[:2]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_operator(self):",
            "        params = {\"operator\": DynamicGroupOperatorChoices.OPERATOR_INTERSECTION}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_weight(self):",
            "        params = {\"weight\": [10]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_group(self):",
            "        group_pk = self.queryset.first().group.pk  # expecting 1",
            "        group_slug = self.queryset.last().group.slug  # expecting 1",
            "        params = {\"group\": [group_pk, group_slug]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_parent_group(self):",
            "        parent_group_pk = self.queryset.first().parent_group.pk  # expecting 3",
            "        parent_group_slug = self.queryset.last().parent_group.slug  # expecting 1",
            "        params = {\"parent_group\": [parent_group_pk, parent_group_slug]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 4)",
            "",
            "    def test_search(self):",
            "        tests = {",
            "            \"intersection\": 2,  # operator",
            "            \"First Child\": 1,  # group__name",
            "            \"second-child\": 1,  # group__slug",
            "            \"Parent\": 3,  # parent_group__name,",
            "            \"third-child\": 2,  # parent_group__slug OR group__slug,",
            "        }",
            "        for value, cnt in tests.items():",
            "            params = {\"q\": value}",
            "            self.assertEqual(self.filterset(params, self.queryset).qs.count(), cnt)"
        ],
        "afterPatchFile": [
            "import random",
            "import time",
            "",
            "from unittest.mock import patch",
            "",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.cache import cache",
            "from django.core.exceptions import ValidationError",
            "from django.db.models import ProtectedError",
            "from django.urls import reverse",
            "from django.test import override_settings",
            "",
            "from nautobot.dcim.choices import PortTypeChoices",
            "from nautobot.dcim.filters import DeviceFilterSet",
            "from nautobot.dcim.forms import DeviceFilterForm, DeviceForm",
            "from nautobot.dcim.models import (",
            "    Device,",
            "    DeviceRole,",
            "    DeviceType,",
            "    FrontPort,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    RearPort,",
            "    Region,",
            "    Site,",
            ")",
            "from nautobot.extras.choices import (",
            "    CustomFieldFilterLogicChoices,",
            "    CustomFieldTypeChoices,",
            "    DynamicGroupOperatorChoices,",
            "    RelationshipTypeChoices,",
            ")",
            "from nautobot.extras.filters import DynamicGroupFilterSet, DynamicGroupMembershipFilterSet",
            "from nautobot.extras.models import (",
            "    CustomField,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Status,",
            ")",
            "from nautobot.ipam.models import Prefix",
            "from nautobot.tenancy.models import Tenant",
            "from nautobot.utilities.forms.fields import MultiValueCharField",
            "from nautobot.utilities.forms.widgets import MultiValueCharInput",
            "from nautobot.utilities.testing import TestCase",
            "",
            "",
            "class DynamicGroupTestBase(TestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.device_ct = ContentType.objects.get_for_model(Device)",
            "        cls.dynamicgroup_ct = ContentType.objects.get_for_model(DynamicGroup)",
            "",
            "        cls.sites = [",
            "            Site.objects.create(name=\"Site 1\", slug=\"site-1\"),",
            "            Site.objects.create(name=\"Site 2\", slug=\"site-2\"),",
            "            Site.objects.create(name=\"Site 3\", slug=\"site-3\"),",
            "            Site.objects.create(name=\"Site 4\", slug=\"site-4\"),",
            "        ]",
            "",
            "        cls.manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        cls.device_type = DeviceType.objects.create(",
            "            manufacturer=cls.manufacturer,",
            "            model=\"device Type 1\",",
            "            slug=\"device-type-1\",",
            "        )",
            "        cls.device_role = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\", color=\"ff0000\")",
            "        cls.status_active = Status.objects.get_for_model(Device).get(slug=\"active\")",
            "        cls.status_planned = Status.objects.get_for_model(Device).get(slug=\"planned\")",
            "        cls.status_staged = Status.objects.get_for_model(Device).get(slug=\"staged\")",
            "",
            "        cls.devices = [",
            "            Device.objects.create(",
            "                name=\"device-site-1\",",
            "                status=cls.status_active,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                site=cls.sites[0],",
            "            ),",
            "            Device.objects.create(",
            "                name=\"device-site-2\",",
            "                status=cls.status_active,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                serial=\"abc123\",",
            "                site=cls.sites[1],",
            "            ),",
            "            Device.objects.create(",
            "                name=\"device-site-3\",",
            "                status=cls.status_planned,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                site=cls.sites[2],",
            "            ),",
            "            Device.objects.create(",
            "                name=\"device-site-4\",",
            "                status=cls.status_staged,",
            "                device_role=cls.device_role,",
            "                device_type=cls.device_type,",
            "                site=cls.sites[3],",
            "            ),",
            "        ]",
            "",
            "        cls.groups = [",
            "            DynamicGroup.objects.create(",
            "                name=\"Parent\",",
            "                slug=\"parent\",",
            "                description=\"The parent group with no filter\",",
            "                filter={},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Site-1 only",
            "            DynamicGroup.objects.create(",
            "                name=\"First Child\",",
            "                slug=\"first-child\",",
            "                description=\"The first child group\",",
            "                filter={\"site\": [\"site-1\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Site-2 only",
            "            DynamicGroup.objects.create(",
            "                name=\"Second Child\",",
            "                slug=\"second-child\",",
            "                description=\"A second child group\",",
            "                filter={\"site\": [\"site-3\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Empty filter to use for testing nesting.",
            "            DynamicGroup.objects.create(",
            "                name=\"Third Child\",",
            "                slug=\"third-child\",",
            "                description=\"A third child group with a child of its own\",",
            "                filter={},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # Nested child of third-child to test ancestors/descendants",
            "            DynamicGroup.objects.create(",
            "                name=\"Nested Child\",",
            "                slug=\"nested-child\",",
            "                description=\"This will be the child of third-child\",",
            "                filter={\"status\": [\"active\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            # No matches (bogus/invalid name match)",
            "            DynamicGroup.objects.create(",
            "                name=\"Invalid Filter\",",
            "                slug=\"invalid-filter\",",
            "                description=\"A group with a non-matching filter\",",
            "                filter={\"name\": [\"bogus\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"MultiValueCharFilter\",",
            "                slug=\"multivaluecharfilter\",",
            "                description=\"A group with a multivaluechar filter\",",
            "                filter={\"name\": [\"device-1\", \"device-2\", \"device-3\"]},",
            "                content_type=cls.device_ct,",
            "            ),",
            "        ]",
            "",
            "        cls.parent = cls.groups[0]",
            "        cls.first_child = cls.groups[1]",
            "        cls.second_child = cls.groups[2]",
            "        cls.third_child = cls.groups[3]",
            "        cls.nested_child = cls.groups[4]",
            "        cls.invalid_filter = cls.groups[5]",
            "",
            "        # Setup the group membership hiearchy to use for graph testing",
            "        cls.memberships = [",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.parent,",
            "                group=cls.first_child,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            ),",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.parent,",
            "                group=cls.second_child,",
            "                weight=20,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "            ),",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.parent,",
            "                group=cls.third_child,",
            "                weight=30,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            ),",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=cls.third_child,",
            "                group=cls.nested_child,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            ),",
            "        ]",
            "",
            "    def assertQuerySetEqual(self, left_qs, right_qs):",
            "        \"\"\"Compare two querysets and assert that they are equal.\"\"\"",
            "        self.assertEqual(",
            "            sorted(left_qs.values_list(\"pk\", flat=True)),",
            "            sorted(right_qs.values_list(\"pk\", flat=True)),",
            "        )",
            "",
            "",
            "class DynamicGroupModelTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroup model tests.\"\"\"",
            "",
            "    def test_content_type_is_immutable(self):",
            "        \"\"\"Test that `content_type` is immutable after create.\"\"\"",
            "        instance = self.groups[0]",
            "        with self.assertRaises(ValidationError):",
            "            instance.content_type = self.dynamicgroup_ct",
            "            instance.validated_save()",
            "",
            "    def test_full_clean_filter_not_dict(self):",
            "        \"\"\"Test that invalid filter types raise errors.\"\"\"",
            "        instance = self.groups[0]",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = None",
            "            instance.validated_save()",
            "",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = []",
            "            instance.validated_save()",
            "",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = \"site=ams01\"",
            "            instance.validated_save()",
            "",
            "    def test_full_clean_filter_not_valid(self):",
            "        \"\"\"Test that an invalid filter dict raises an error.\"\"\"",
            "        instance = self.groups[0]",
            "        with self.assertRaises(ValidationError):",
            "            instance.filter = {\"site\": -42}",
            "            instance.validated_save()",
            "",
            "    def test_clean_fields_exclude_filter(self):",
            "        \"\"\"Test that filter validation is skipped when an appropriate `exclude` parameter is provided.\"\"\"",
            "        instance = self.groups[0]",
            "        instance.filter = {\"platform\": -42}",
            "        instance.clean_fields(exclude=[\"filter\"])",
            "        instance.full_clean(exclude=[\"filter\"])",
            "",
            "        with self.assertRaises(ValidationError):",
            "            instance.clean_fields()",
            "        with self.assertRaises(ValidationError):",
            "            instance.full_clean()",
            "",
            "    def test_full_clean_valid(self):",
            "        \"\"\"Test a clean validation.\"\"\"",
            "        group = self.groups[0]",
            "        group.refresh_from_db()",
            "        old_filter = group.filter",
            "",
            "        # Overload the filter and validate that it is the same afterward.",
            "        new_filter = {\"interfaces\": True}",
            "        group.set_filter(new_filter)",
            "        group.validated_save()",
            "        self.assertEqual(group.filter, new_filter)",
            "",
            "        # Restore the old filter.",
            "        group.filter = old_filter",
            "        group.save()",
            "",
            "    def test_get_for_object(self):",
            "        \"\"\"Test `DynamicGroup.objects.get_for_object()`.\"\"\"",
            "        device1 = self.devices[0]  # site-1",
            "        device4 = self.devices[-1]  # site-4",
            "",
            "        # Assert that the groups we got from `get_for_object()` match the lookup",
            "        # from the group instance itself.",
            "        device1_groups = DynamicGroup.objects.get_for_object(device1)",
            "        self.assertQuerySetEqual(device1_groups, device1.dynamic_groups)",
            "",
            "        # Device4 should not be in ANY Dynamic Groups.",
            "        device4_groups = DynamicGroup.objects.get_for_object(device4)",
            "        self.assertEqual(list(device4_groups), [])",
            "        self.assertQuerySetEqual(device4_groups, device4.dynamic_groups)",
            "",
            "    def test_members(self):",
            "        \"\"\"Test `DynamicGroup.members`.\"\"\"",
            "        group = self.first_child",
            "        device1 = self.devices[0]",
            "        device2 = self.devices[1]",
            "",
            "        self.assertIn(device1, group.members)",
            "        self.assertNotIn(device2, group.members)",
            "",
            "    def test_members_tree_nodes(self):",
            "        \"\"\"",
            "        Test `DynamicGroup.members` when filtering on tree nodes like `Location`.",
            "        \"\"\"",
            "        # Grab some values we'll used to setup the test case.",
            "        device1 = self.devices[0]",
            "        device2 = self.devices[1]",
            "        site = device1.site",
            "        status = Status.objects.get(slug=\"active\")",
            "",
            "        # Create two LocationTypes (My Region > My Site)",
            "        loc_type_region = LocationType.objects.create(name=\"My Region\", slug=\"my-region\")",
            "        loc_type_region.content_types.add(self.device_ct)",
            "        loc_type_site = LocationType.objects.create(name=\"My Site\", slug=\"my-site\", parent=loc_type_region)",
            "        loc_type_site.content_types.add(self.device_ct)",
            "",
            "        loc_region = Location.objects.create(name=\"Location A\", location_type=loc_type_region, site=site, status=status)",
            "        loc_site = Location.objects.create(",
            "            name=\"Location B\", location_type=loc_type_site, parent=loc_region, status=status",
            "        )",
            "",
            "        # Add Location A to device1",
            "        device1.location = loc_region",
            "        device1.validated_save()",
            "",
            "        # Add Location B to device2",
            "        device2.site = device1.site",
            "        device2.location = loc_site",
            "        device2.validated_save()",
            "",
            "        expected = sorted([device1.name, device2.name])",
            "",
            "        # Create the Dynamic Group filtering on Location A",
            "        group = DynamicGroup.objects.create(",
            "            name=\"Devices Location\",",
            "            slug=\"devices-location\",",
            "            content_type=self.device_ct,",
            "            filter={\"location\": [\"location-a\"]},",
            "        )",
            "",
            "        # We are expecting that the group members here should be nested results from any devices",
            "        # that have a Location whose parent is \"Location A\".",
            "        self.assertEqual(",
            "            sorted(m.name for m in group.members),",
            "            expected,",
            "        )",
            "",
            "        # Now also test that an advancted (nested) dynamic group, also reports",
            "        # the same number of members.",
            "        parent_group = DynamicGroup.objects.create(",
            "            name=\"Parent of Devices Location\",",
            "            slug=\"parent-devices-location\",",
            "            content_type=self.device_ct,",
            "            filter={},",
            "        )",
            "        parent_group.add_child(",
            "            child=group,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            weight=10,",
            "        )",
            "        self.assertEqual(",
            "            sorted(m.name for m in parent_group.members),",
            "            expected,",
            "        )",
            "",
            "    def test_count(self):",
            "        \"\"\"Test `DynamicGroup.count`.\"\"\"",
            "        expected = {",
            "            self.parent.count: 2,",
            "            self.first_child.count: 1,",
            "            self.second_child.count: 1,",
            "            self.third_child.count: 2,",
            "            self.nested_child.count: 2,",
            "            self.invalid_filter.count: 0,",
            "        }",
            "        for grp, cnt in expected.items():",
            "            self.assertEqual(grp, cnt)",
            "",
            "    def test_get_queryset(self):",
            "        \"\"\"Test `DynamicGroup.get_queryset()`.\"\"\"",
            "        group = self.first_child",
            "        device1 = self.devices[0]",
            "",
            "        # Test that we can get a full queryset",
            "        qs = group.get_queryset()",
            "        devices = group.model.objects.filter(site=device1.site)",
            "",
            "        # Expect a single-member qs/list of Device names (only `device1`)",
            "        expected = [device1.name]",
            "        self.assertIn(device1, devices)",
            "        self.assertIn(device1, qs)",
            "        self.assertEqual(list(map(str, devices)), expected)",
            "        self.assertEqual(list(map(str, qs)), expected)",
            "        self.assertEqual(list(qs), list(devices))",
            "",
            "        # A new group that doesn't have a content_type and therefore",
            "        # `self.model`, should raise a RuntimeError",
            "        new_group = DynamicGroup()",
            "        with self.assertRaises(RuntimeError):",
            "            new_group.get_queryset()",
            "",
            "    def test_model(self):",
            "        \"\"\"Test `DynamicGroup.model`.\"\"\"",
            "        # New instances should not have a model unless `content_type` is set.",
            "        new_group = DynamicGroup(name=\"Unsaved Group\", slug=\"unsaved-group\")",
            "        self.assertIsNone(new_group.model)",
            "",
            "        # Setting the content_type will now allow `.model` to be accessed.",
            "        new_group.content_type = self.device_ct",
            "        self.assertIsNotNone(new_group.model)",
            "",
            "    def test_set_object_classes(self):",
            "        \"\"\"Test `DynamicGroup._set_object_classes()`.\"\"\"",
            "        # New instances should fail to map until `content_type` is set.",
            "        new_group = DynamicGroup(name=\"Unsaved Group\", slug=\"unsaved-group\")",
            "        objects_mapped = new_group._set_object_classes(new_group.model)",
            "        self.assertFalse(objects_mapped)",
            "",
            "        # Existing groups w/ `content_type` set work as expected.",
            "        group = self.groups[0]",
            "        model = group.content_type.model_class()",
            "        objects_mapped = group._set_object_classes(model)",
            "",
            "        self.assertTrue(objects_mapped)",
            "        self.assertEqual(group.model, model)",
            "        self.assertEqual(group.filterset_class, DeviceFilterSet)",
            "        self.assertEqual(group.filterform_class, DeviceFilterForm)",
            "        self.assertEqual(group.form_class, DeviceForm)",
            "",
            "    def test_get_group_members_url(self):",
            "        \"\"\"Test `DynamicGroup.get_group_members_url().\"\"\"",
            "",
            "        # First assert that a basic group with no children, then a group with children, will always",
            "        # link to the members tab on the detail view.",
            "        for group in [self.first_child, self.parent]:",
            "            detail_url = reverse(\"extras:dynamicgroup\", kwargs={\"slug\": group.slug})",
            "            params = \"tab=members\"",
            "            url = f\"{detail_url}?{params}\"",
            "            self.assertEqual(group.get_group_members_url(), url)",
            "",
            "        # If the new group has no attributes or map yet, expect an empty string.",
            "        new_group = DynamicGroup()",
            "        self.assertEqual(new_group.get_group_members_url(), \"\")",
            "",
            "    def test_map_filter_fields(self):",
            "        \"\"\"Test `DynamicGroup._map_filter_fields`.\"\"\"",
            "        group = self.groups[0]",
            "        fields = group._map_filter_fields",
            "",
            "        # Test that it's a dict with or without certain key fields.",
            "        self.assertIsInstance(fields, dict)",
            "        self.assertNotEqual(fields, {})",
            "        self.assertNotIn(\"comments\", fields)",
            "        self.assertIn(\"name\", fields)",
            "        # See if a CharField is properly converted to a MultiValueCharField In DynamicGroupEditForm.",
            "        self.assertIsInstance(fields[\"name\"], MultiValueCharField)",
            "        self.assertIsInstance(fields[\"name\"].widget, MultiValueCharInput)",
            "",
            "    def test_map_filter_fields_skip_missing(self):",
            "        \"\"\"",
            "        Test that missing fields are skipped in `DynamicGroup._map_filter_fields`",
            "        when `Model.dynamic_group_skip_missing_fields` is `True`.",
            "        \"\"\"",
            "        group = self.groups[0]",
            "",
            "        try:",
            "            group.model.dynamic_group_skip_missing_fields = True",
            "            fields = group._map_filter_fields",
            "            # Test that it's a dict with or without certain key fields.",
            "            self.assertIsInstance(fields, dict)",
            "            self.assertNotEqual(fields, {})",
            "            self.assertNotIn(\"name\", fields)",
            "            self.assertNotIn(\"asset_tag\", fields)",
            "            self.assertNotIn(\"serial\", fields)",
            "        finally:",
            "            del group.model.dynamic_group_skip_missing_fields",
            "",
            "    def test_map_filter_fields_skip_method_filters_generate_query(self):",
            "        \"\"\"",
            "        Test that method filters are skipped in `DynamicGroup._map_filter_fields` when the filterset",
            "        for the group's content type has a method named `generate_query_{filter_method}`.",
            "        \"\"\"",
            "        group = self.groups[0]",
            "        filterset = group.filterset_class()",
            "        fields = group._map_filter_fields",
            "",
            "        # We know that `has_primary_ip` fits this bill, so let's test that.",
            "        field_name = \"has_primary_ip\"",
            "        filter_field = filterset.filters[field_name]",
            "",
            "        # Make some field presence assertions",
            "        self.assertIn(field_name, fields)",
            "",
            "        # The filterset should have the method name and `generate_query_` method",
            "        self.assertTrue(hasattr(filterset, filter_field.method))",
            "        self.assertTrue(hasattr(filterset, \"generate_query_\" + filter_field.method))",
            "",
            "    # 2.0 TODO(jathan): This is done using `DeviceFilterSet.pass_through_ports` at this time and",
            "    # should be revised as filter fields are vetted.",
            "    def test_filter_method_generate_query(self):",
            "        \"\"\"",
            "        Test that a filter with a filter method's corresponding `generate_query_{filter_method}` works as intended.",
            "        \"\"\"",
            "        group = self.groups[0]",
            "",
            "        # We're going to test `pass_through_ports`",
            "        device = self.devices[0]",
            "        rear_port = RearPort.objects.create(device=device, name=\"rp1\", positions=1, type=PortTypeChoices.TYPE_8P8C)",
            "        FrontPort.objects.create(",
            "            device=device, name=\"fp1\", type=PortTypeChoices.TYPE_FC, rear_port=rear_port, rear_port_position=1",
            "        )",
            "",
            "        # Test that the filter returns the one device to which we added front/rear ports.",
            "        expected = [\"device-site-1\"]",
            "        filterset = group.filterset_class({\"pass_through_ports\": True}, Device.objects.all())",
            "        devices = list(filterset.qs.values_list(\"name\", flat=True))",
            "        self.assertEqual(expected, devices)",
            "",
            "    # 2.0 TODO(jathan): This is done using Prefix at this time and this should be revised as filter",
            "    # fields are vetted.",
            "    def test_map_filter_fields_skip_method_filters_no_generate_query(self):",
            "        \"\"\"",
            "        Test that method filters are skipped in `DynamicGroup._map_filter_fields` when the filterset",
            "        for the group's content type DOES NOT have a method named `generate_query_{filter_method}`.",
            "",
            "        \"\"\"",
            "        pfx_content_type = ContentType.objects.get_for_model(Prefix)",
            "        group = DynamicGroup(name=\"pfx\", slug=\"pfx\", content_type=pfx_content_type)",
            "        filterset = group.filterset_class()",
            "        fields = group._map_filter_fields",
            "",
            "        # We know that `within_include` does not have a `generate_query_{filter_method}` method.",
            "        field_name = \"within_include\"",
            "        filter_field = filterset.filters[field_name]",
            "",
            "        # Make some field presence assertions",
            "        self.assertNotIn(field_name, fields)",
            "",
            "        # The filterset should have the method name BUT NOT `generate_query_` method",
            "        self.assertTrue(hasattr(filterset, filter_field.method))",
            "        self.assertFalse(hasattr(filterset, \"generate_query_\" + filter_field.method))",
            "",
            "    def test_get_filter_fields(self):",
            "        \"\"\"Test `DynamicGroup.get_filter_fields()`.\"\"\"",
            "        # New instances should return {} `content_type` is set.",
            "        new_group = DynamicGroup(name=\"Unsaved Group\", slug=\"unsaved-group\")",
            "        new_filter_fields = new_group.get_filter_fields()",
            "        self.assertEqual(new_filter_fields, {})",
            "",
            "        # Existing groups should have actual fields.",
            "        group = self.groups[0]",
            "        filter_fields = group.get_filter_fields()",
            "        self.assertIsInstance(filter_fields, dict)",
            "        self.assertNotEqual(filter_fields, {})",
            "        self.assertNotIn(\"comments\", filter_fields)",
            "        self.assertIn(\"name\", filter_fields)",
            "",
            "    def test_generate_filter_form(self):",
            "        \"\"\"Test `DynamicGroup.generate_filter_form()`.\"\"\"",
            "        group = self.groups[0]",
            "        filter_fields = group.get_filter_fields()",
            "        form_class = group.generate_filter_form()",
            "        form = form_class(group.filter)",
            "",
            "        # Form should validate just fine from the group's filter",
            "        self.assertTrue(form.is_valid())",
            "",
            "        # Form instance should have identical field set to filter fields.",
            "        self.assertEqual(sorted(form.fields), sorted(filter_fields))",
            "",
            "    def test_get_initial(self):",
            "        \"\"\"Test `DynamicGroup.get_initial()`.\"\"\"",
            "        group1 = self.first_child  # Filter has `site`",
            "        self.assertEqual(group1.get_initial(), group1.filter)",
            "        # Test if MultiValueCharField is properly pre-populated",
            "        group2 = self.groups[6]  # Filter has `name`",
            "        initial = group2.get_initial()",
            "        expected = {\"name\": [\"device-1\", \"device-2\", \"device-3\"]}",
            "        self.assertEqual(initial, expected)",
            "",
            "    def test_set_filter(self):",
            "        \"\"\"Test `DynamicGroup.set_filter()`.\"\"\"",
            "        group = self.groups[0]",
            "",
            "        # Input can come from a form's cleaned_data, such as our generated form. In this case, the",
            "        # filter we set from the form should be identical to what was there already.",
            "        old_filter = group.filter",
            "        form_class = group.generate_filter_form()",
            "        form_class.prefix = None  # We don't want the prefix here right now.",
            "        form = form_class(group.filter)",
            "        form.is_valid()",
            "        group.set_filter(form.cleaned_data)",
            "        self.assertEqual(group.filter, old_filter)",
            "",
            "        # Now we'll do it using a manually crafted dict.",
            "        new_filter = {\"interfaces\": True}",
            "        group.set_filter(new_filter)",
            "        self.assertEqual(group.filter, new_filter)",
            "",
            "        # And a bad input",
            "        bad_filter = {\"site\": -42}",
            "        with self.assertRaises(ValidationError):",
            "            group.set_filter(bad_filter)",
            "",
            "        # Cleanup because we're using class-based fixtures in `setUpTestData()`",
            "        group.refresh_from_db()",
            "",
            "    def test_add_child(self):",
            "        \"\"\"Test `DynamicGroup.add_child()`.\"\"\"",
            "        self.parent.add_child(",
            "            child=self.invalid_filter,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            weight=10,",
            "        )",
            "        self.assertTrue(self.parent.children.filter(slug=self.invalid_filter.slug).exists())",
            "",
            "    def test_clean_child_validation(self):",
            "        \"\"\"Test various ways in which adding a child group should fail.\"\"\"",
            "        parent = self.parent",
            "        parent.filter = {\"site\": [\"site-1\"]}",
            "        child = self.invalid_filter",
            "",
            "        # parent.add_child() should fail",
            "        with self.assertRaises(ValidationError):",
            "            parent.add_child(",
            "                child=child,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "        # parent.children.add() should fail",
            "        with self.assertRaises(ValidationError):",
            "            parent.children.add(",
            "                child,",
            "                through_defaults={\"operator\": DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE, \"weight\": 10},",
            "            )",
            "",
            "    def test_remove_child(self):",
            "        \"\"\"Test `DynamicGroup.remove_child()`.\"\"\"",
            "        self.parent.remove_child(self.third_child)",
            "        self.assertFalse(self.parent.children.filter(slug=self.third_child.slug).exists())",
            "",
            "    def test_generate_query_for_filter(self):",
            "        \"\"\"Test `DynamicGroup.generate_query_for_filter()`.\"\"\"",
            "        group = self.parent  # Any group will do, so why not this one?",
            "        multi_value = [\"site-3\"]",
            "        fs = group.filterset_class()",
            "        multi_field = fs.filters[\"site\"]",
            "        multi_query = group.generate_query_for_filter(",
            "            filter_field=multi_field,",
            "            value=multi_value,",
            "        )",
            "",
            "        queryset = group.get_queryset()",
            "",
            "        # Assert that both querysets resturn the same results",
            "        group_qs = queryset.filter(multi_query)",
            "        device_qs = Device.objects.filter(site__slug__in=multi_value)",
            "        self.assertQuerySetEqual(group_qs, device_qs)",
            "",
            "        # Now do a non-multi-value filter.",
            "        # 2.0 TODO(jathan): When \"serial\" becomes a multi-value filter, this will need to be revised or removed.",
            "        solo_field = fs.filters[\"serial\"]",
            "        solo_value = \"abc123\"",
            "        solo_query = group.generate_query_for_filter(filter_field=solo_field, value=solo_value)",
            "        solo_qs = queryset.filter(solo_query)",
            "        serial_qs = Device.objects.filter(serial__iexact=solo_value)",
            "        self.assertQuerySetEqual(solo_qs, serial_qs)",
            "",
            "        # Test that a nested field_name w/ `generate_query` works as expected. This is explicitly to",
            "        # test a regression w/ nested slug-related values such as `DeviceFilterSet.region` which",
            "        # filters on `site__region`.",
            "        parent_region = Region.objects.filter(children__isnull=False).first()",
            "        nested_value = [parent_region.slug]",
            "        group.set_filter({\"region\": nested_value})",
            "        group.validated_save()",
            "",
            "        # We are making sure the filterset generated from the slug as an argument results in the same",
            "        # filtered queryset, and more importantly that the nested filter expression `site__region`",
            "        # is automatically used to get the related model name without failing.",
            "        nested_query = group.generate_query_for_filter(filter_field=fs.filters[\"region\"], value=nested_value)",
            "        nested_qs = queryset.filter(nested_query)",
            "        region_qs = Device.objects.filter(site__region__slug__in=nested_value)",
            "        self.assertQuerySetEqual(nested_qs, region_qs)",
            "",
            "    def test_generate_query_for_group(self):",
            "        \"\"\"Test `DynamicGroup.generate_query_for_group()`.\"\"\"",
            "        group = self.parent",
            "",
            "        # A group with an empty filter will have a null `Q` object",
            "        parent_q = group.generate_query_for_group(group)",
            "        self.assertFalse(parent_q)",
            "",
            "        # A child group with a filter set will result in a useful Q object.",
            "        child_q = group.generate_query_for_group(self.second_child)",
            "        lookup_kwargs = dict(child_q.children)  # {name: value}",
            "",
            "        # Assert that both querysets resturn the same results",
            "        group_qs = group.get_queryset().filter(child_q)",
            "        device_qs = Device.objects.filter(**lookup_kwargs)",
            "        self.assertQuerySetEqual(group_qs, device_qs)",
            "",
            "    def test_get_group_queryset(self):",
            "        \"\"\"Test `DynamicGroup.get_group_queryset()`.\"\"\"",
            "        # This is literally just calling `process_group_filters(self)` so let's",
            "        # just make sure that it stays consistent until we decide otherwise.",
            "        group = self.parent",
            "        group_qs = group.get_group_queryset()",
            "        process_query = group.generate_query()",
            "        base_qs = group.get_queryset()",
            "        process_qs = base_qs.filter(process_query)",
            "",
            "        self.assertQuerySetEqual(group_qs, process_qs)",
            "",
            "    def test_get_ancestors(self):",
            "        \"\"\"Test `DynamicGroup.get_ancestors()`.\"\"\"",
            "        expected = [\"third-child\", \"parent\"]",
            "        ancestors = [a.slug for a in self.nested_child.get_ancestors()]",
            "        self.assertEqual(ancestors, expected)",
            "",
            "    def test_get_descendants(self):",
            "        \"\"\"Test `DynamicGroup.get_descendants()`.\"\"\"",
            "        expected = [\"first-child\", \"second-child\", \"third-child\", \"nested-child\"]",
            "        descendants = [d.slug for d in self.parent.get_descendants()]",
            "        self.assertEqual(descendants, expected)",
            "",
            "    def test_get_siblings(self):",
            "        \"\"\"Test `DynamicGroup.get_siblings()`.\"\"\"",
            "        expected = [\"first-child\", \"second-child\"]",
            "        siblings = sorted(s.slug for s in self.third_child.get_siblings())",
            "        self.assertEqual(siblings, expected)",
            "",
            "    def test_is_root(self):",
            "        \"\"\"Test `DynamicGroup.is_root()`.\"\"\"",
            "        self.assertTrue(self.parent.is_root())",
            "        self.assertFalse(self.nested_child.is_root())",
            "",
            "    def test_is_leaf(self):",
            "        \"\"\"Test `DynamicGroup.is_leaf()`.\"\"\"",
            "        self.assertFalse(self.parent.is_leaf())",
            "        self.assertTrue(self.nested_child.is_leaf())",
            "",
            "    def test_get_ancestors_queryset(self):",
            "        \"\"\"Test `DynamicGroup.get_ancestors_queryset()`.\"\"\"",
            "        a1 = self.parent.get_ancestors()",
            "        a2 = self.parent.get_ancestors_queryset()",
            "        self.assertEqual(list(a1), list(a2))",
            "",
            "    def test_descendants(self):",
            "        \"\"\"Test `DynamicGroup.get_descendants_queryset()`.\"\"\"",
            "        d1 = self.parent.get_descendants()",
            "        d2 = self.parent.get_descendants_queryset()",
            "        self.assertEqual(list(d1), list(d2))",
            "",
            "    def test_ancestors_tree(self):",
            "        \"\"\"Test `DynamicGroup.ancestors_tree()`.\"\"\"",
            "        a_tree = self.nested_child.ancestors_tree()",
            "        self.assertIn(self.parent, a_tree[self.third_child])",
            "",
            "    def test_descendants_tree(self):",
            "        \"\"\"Test `DynamicGroup.descendants_tree()`.\"\"\"",
            "        d_tree = self.parent.descendants_tree()",
            "        self.assertIn(self.nested_child, d_tree[self.third_child])",
            "",
            "    def test_flatten_descendants_tree(self):",
            "        \"\"\"Test `DynamicGroup.flatten_descendants_tree()`.\"\"\"",
            "        # Assert descendants are deterministic",
            "        d_tree = self.parent.descendants_tree()",
            "        d_flat = self.parent.flatten_descendants_tree(d_tree)",
            "        expected = {\"first-child\": 1, \"second-child\": 1, \"third-child\": 1, \"nested-child\": 2}",
            "        seen = {d.slug: d.depth for d in d_flat}",
            "        self.assertEqual(seen, expected)",
            "",
            "        # Parent should not be here; nested-child should.",
            "        self.assertNotIn(self.parent, d_flat)",
            "        self.assertIn(self.nested_child, d_flat)",
            "",
            "    def test_flatten_ancestors_tree(self):",
            "        \"\"\"Test `DynamicGroup.flatten_ancestors_tree()`.\"\"\"",
            "        # Assert ancestors are deterministic",
            "        a_tree = self.nested_child.ancestors_tree()",
            "        a_flat = self.nested_child.flatten_ancestors_tree(a_tree)",
            "        expected = {\"third-child\": 1, \"parent\": 2}",
            "        seen = {a.slug: a.depth for a in a_flat}",
            "        self.assertEqual(seen, expected)",
            "",
            "        # Nested-child should not be here; parent should.",
            "        self.assertNotIn(self.nested_child, a_flat)",
            "        self.assertIn(self.parent, a_flat)",
            "",
            "    def test_membership_tree(self):",
            "        \"\"\"Test `DynamicGroup.membership_tree()`.\"\"\"",
            "        group = self.parent",
            "",
            "        d_tree = group.flatten_descendants_tree(group.descendants_tree())",
            "        m_tree = group.membership_tree()",
            "",
            "        d_groups = [d.slug for d in d_tree]",
            "        m_groups = [m.group.slug for m in m_tree]",
            "",
            "        d_depths = [d.depth for d in d_tree]",
            "        m_depths = [m.depth for m in m_tree]",
            "",
            "        # Assert same members, same order.",
            "        self.assertEqual(d_groups, m_groups)",
            "        # Assert same depths.",
            "        self.assertEqual(d_depths, m_depths)",
            "",
            "    def test_ordered_queryset_from_pks(self):",
            "        \"\"\"Test `DynamicGroup.ordered_queryset_from_pks()`.\"\"\"",
            "        descendants = self.parent.get_descendants()",
            "        pk_list = [d.pk for d in descendants]",
            "",
            "        # Assert that ordering is always deterministic by shuffling the list of pks and asserting",
            "        # that the ordered pk matches that shuffled order.",
            "        random.shuffle(pk_list)",
            "        ordered_qs = self.parent.ordered_queryset_from_pks(pk_list)",
            "        self.assertEqual(",
            "            pk_list,",
            "            [o.pk for o in ordered_qs],",
            "        )",
            "",
            "    def test_generate_query(self):",
            "        \"\"\"Test `DynamicGroup.generate_query()`.\"\"\"",
            "        # Start with parent. Enumerate descendants and their operators to assert correct results.",
            "        group = self.parent",
            "        group_query = group.generate_query()",
            "        group_qs = group.get_queryset().filter(group_query)",
            "",
            "        # <DynamicGroupMembership: First Child: intersection (10)>",
            "        # <DynamicGroupMembership: Second Child: union (20)>",
            "        # <DynamicGroupMembership: Third Child: difference (30)>",
            "        group_members = group.dynamic_group_memberships.all()",
            "",
            "        # Manually iterate over the groups to assert the same result that the queryset should have,",
            "        # igoring weight since each set of members are already ordered by weight when queried from",
            "        # the database.",
            "        child_set = set(group.get_queryset())",
            "        for member in group_members:",
            "            child_members = set(member.members)",
            "            operator = member.operator",
            "            # Use operator value to call a set method; one of intersection, union, difference and",
            "            # update the results set. (e.g. `child_set.difference(child_members)`",
            "            if operator == \"union\":",
            "                child_set = child_set | child_members",
            "            elif operator == \"difference\":",
            "                child_set = child_set - child_members",
            "            elif operator == \"intersection\":",
            "                child_set = child_set & child_members",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(group_qs.count(), len(child_set))",
            "",
            "        # And have the same members...",
            "        expected = [\"device-site-3\"]",
            "        self.assertEqual(sorted(group_qs.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_delete(self):",
            "        \"\"\"Test `DynamicGroup(instance).delete()`.\"\"\"",
            "        # Has parents",
            "        with self.assertRaises(ProtectedError):",
            "            self.nested_child.delete()",
            "",
            "        # Clear the deeply nested child's parents then delete it!",
            "        self.nested_child.parents.clear()",
            "        self.nested_child.delete()",
            "",
            "    def test_filter_relationships(self):",
            "        \"\"\"Test that relationships can be used in filters.\"\"\"",
            "        prefix_ct = ContentType.objects.get_for_model(Prefix)",
            "",
            "        device = self.devices[0]",
            "        prefix = Prefix.objects.first()",
            "",
            "        relationship = Relationship(",
            "            name=\"Device to Prefix\",",
            "            slug=\"device_to_prefix\",",
            "            source_type=self.device_ct,",
            "            source_label=\"My Prefixes\",",
            "            source_filter=None,",
            "            destination_type=prefix_ct,",
            "            destination_label=\"My Devices\",",
            "            type=RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "        )",
            "        relationship.validated_save()",
            "",
            "        ra = RelationshipAssociation(",
            "            relationship=relationship,",
            "            source=device,",
            "            destination=prefix,",
            "        )",
            "        ra.validated_save()",
            "",
            "        dg = DynamicGroup(",
            "            name=\"relationships\",",
            "            slug=\"relationships\",",
            "            description=\"I filter on relationships.\",",
            "            filter={\"cr_device_to_prefix__destination\": [prefix.pk]},",
            "            content_type=self.device_ct,",
            "        )",
            "        dg.validated_save()",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(dg.count, 1)",
            "",
            "        # And have the same members...",
            "        self.assertIn(device, dg.members)",
            "        expected = [str(device)]",
            "        self.assertEqual(sorted(dg.members.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_filter_custom_fields(self):",
            "        \"\"\"Test that relationships can be used in filters.\"\"\"",
            "",
            "        device = self.devices[0]",
            "",
            "        cf = CustomField.objects.create(",
            "            name=\"favorite_food\",",
            "            type=CustomFieldTypeChoices.TYPE_TEXT,",
            "            filter_logic=CustomFieldFilterLogicChoices.FILTER_LOOSE,",
            "        )",
            "        cf.content_types.add(self.device_ct)",
            "",
            "        device._custom_field_data = {\"favorite_food\": \"bacon\"}",
            "        device.validated_save()",
            "        device.refresh_from_db()",
            "",
            "        dg = DynamicGroup(",
            "            name=\"custom_fields\",",
            "            slug=\"custom_fields\",",
            "            description=\"I filter on custom fields.\",",
            "            filter={\"cf_favorite_food\": \"bacon\"},",
            "            content_type=self.device_ct,",
            "        )",
            "        dg.validated_save()",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(dg.count, 1)",
            "",
            "        # And have the same members...",
            "        self.assertIn(device, dg.members)",
            "        expected = [str(device)]",
            "        self.assertEqual(sorted(dg.members.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_filter_search(self):",
            "        \"\"\"Test that search (`q` filter) can be used in filters.\"\"\"",
            "",
            "        # Rename the device to explicitly match on search.",
            "        device = self.devices[0]",
            "        device.name = \"pizza-party-machine\"",
            "        device.save()",
            "",
            "        dg = DynamicGroup(",
            "            name=\"custom_fields\",",
            "            slug=\"custom_fields\",",
            "            description=\"I filter on the q field\",",
            "            filter={\"q\": \"party\"},  # Let's party! \ud83c\udf89",
            "            content_type=self.device_ct,",
            "        )",
            "        dg.validated_save()",
            "",
            "        # These should be the same length.",
            "        self.assertEqual(dg.count, 1)",
            "",
            "        # And have the same members...",
            "        self.assertIn(device, dg.members)",
            "        expected = [str(device)]",
            "        self.assertEqual(sorted(dg.members.values_list(\"name\", flat=True)), expected)",
            "",
            "    def test_group_overloaded_filter_form_field(self):",
            "        \"\"\"FilterForm fields can overload how they pass in the values.\"\"\"",
            "",
            "        prefix_ct = ContentType.objects.get_for_model(Prefix)",
            "",
            "        a_tenant = Tenant.objects.first()",
            "",
            "        this_dg = DynamicGroup(",
            "            name=\"Prefix Group\",",
            "            slug=\"prefix-dg\",",
            "            description=\"A group of prefixes with a specific Tenant name.\",",
            "            filter={},",
            "            content_type=prefix_ct,",
            "        )",
            "        this_dg.validated_save()",
            "",
            "        this_dg.set_filter({\"example_plugin_prefix_tenant_name\": [a_tenant]})",
            "        this_dg.validated_save()",
            "",
            "    def test_member_caching_output(self):",
            "        group = self.first_child",
            "",
            "        # Ensure the cache is empty from previous tests",
            "        cache.delete(group.members_cache_key)",
            "",
            "        self.assertEqual(sorted(list(group.members)), sorted(list(group.members_cached)))",
            "",
            "    @override_settings(DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT=2)",
            "    def test_member_caching_enabled(self):",
            "        \"\"\"",
            "        Verify that the members list of the DynamicGroup is cached and expires.",
            "        \"\"\"",
            "        group = self.first_child",
            "",
            "        class FakeQuerySet:",
            "            def all(self):",
            "                return []",
            "",
            "        # Ensure the cache is empty from previous tests",
            "        cache.delete(group.members_cache_key)",
            "",
            "        with patch.object(group, \"get_queryset\", return_value=FakeQuerySet()) as mock_get_queryset:",
            "            group.members_cached",
            "            group.members_cached",
            "            group.members_cached",
            "            self.assertEqual(mock_get_queryset.call_count, 1)",
            "",
            "            time.sleep(3)  # Let the cache expire",
            "",
            "            group.members_cached",
            "            self.assertEqual(mock_get_queryset.call_count, 2)",
            "",
            "        # Clean-up after ourselves",
            "        cache.delete(f\"{group.__class__.__name__}.{group.id}.cached_members\")",
            "",
            "    @override_settings(DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT=0)",
            "    def test_member_caching_disabled(self):",
            "        \"\"\"",
            "        Verify that the members list of the DynamicGroup is not cached.",
            "        \"\"\"",
            "        group = self.first_child",
            "",
            "        class FakeQuerySet:",
            "            def all(self):",
            "                return []",
            "",
            "        # Ensure the cache is empty from previous tests",
            "        cache.delete(group.members_cache_key)",
            "",
            "        with patch.object(group, \"get_queryset\", return_value=FakeQuerySet()) as mock_get_queryset:",
            "            group.members_cached",
            "            group.members_cached",
            "            self.assertEqual(mock_get_queryset.call_count, 2)",
            "",
            "",
            "class DynamicGroupMembershipModelTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroupMembership model tests.\"\"\"",
            "",
            "    def test_clean_content_type(self):",
            "        \"\"\"Assert that content_type b/w parent/group must match.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.first_child.content_type = self.dynamicgroup_ct",
            "            self.parent.add_child(",
            "                child=self.first_child,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "        # Cleanup because we're using class-based fixtures in `setUpTestData()`",
            "        self.first_child.refresh_from_db()",
            "",
            "    def test_clean_block_self(self):",
            "        \"\"\"Assert that a group cannot be its own child.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.parent.add_child(",
            "                child=self.parent,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "    def test_clean_loop_detection(self):",
            "        \"\"\"Assert that graph loops are blocked (ancestors can't be a child).\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.third_child.add_child(",
            "                child=self.parent,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                weight=10,",
            "            )",
            "",
            "    def test_clean_child_uniqueness(self):",
            "        \"\"\"Assert that membership uniqueness criteria are enforced.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            self.third_child.add_child(",
            "                child=self.nested_child,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            )",
            "",
            "    def test_clean_parent_filter_exclusivity(self):",
            "        \"\"\"Assert that if `parent_group.filter` is set that it blocks creation.\"\"\"",
            "        with self.assertRaises(ValidationError):",
            "            DynamicGroupMembership.objects.create(",
            "                parent_group=self.first_child,",
            "                group=self.invalid_filter,",
            "                weight=10,",
            "                operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            )",
            "",
            "    def test_group_attributes(self):",
            "        \"\"\"Test passthrough attributes to `self.group`.\"\"\"",
            "        mem = self.memberships[0]",
            "        grp = mem.group",
            "",
            "        self.assertEqual(mem.name, grp.name)",
            "        self.assertEqual(sorted(mem.members), sorted(grp.members))",
            "        self.assertEqual(mem.count, grp.count)",
            "        self.assertEqual(mem.get_absolute_url(), grp.get_absolute_url())",
            "        self.assertEqual(mem.get_group_members_url(), grp.get_group_members_url())",
            "",
            "",
            "class DynamicGroupFilterTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroup instance filterset tests.\"\"\"",
            "",
            "    queryset = DynamicGroup.objects.all()",
            "    filterset = DynamicGroupFilterSet",
            "",
            "    def test_id(self):",
            "        params = {\"id\": self.queryset.values_list(\"pk\", flat=True)[:2]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_name(self):",
            "        params = {\"name\": [\"First Child\", \"Third Child\"]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_slug(self):",
            "        params = {\"slug\": [\"invalid-filter\"]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 1)",
            "",
            "    def test_content_type(self):",
            "        params = {\"content_type\": [\"dcim.device\", \"virtualization.virtualmachine\"]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 7)",
            "",
            "    def test_search(self):",
            "        tests = {",
            "            \"Devices No Filter\": 0,  # name",
            "            \"Invalid Filter\": 1,  # name",
            "            \"invalid-filter\": 1,  # slug",
            "            \"A group with a non-matching filter\": 1,  # description",
            "            \"dcim\": 7,  # content_type__app_label",
            "            \"device\": 7,  # content_type__model",
            "        }",
            "        for value, cnt in tests.items():",
            "            params = {\"q\": value}",
            "            self.assertEqual(self.filterset(params, self.queryset).qs.count(), cnt)",
            "",
            "",
            "class DynamicGroupMembershipFilterTest(DynamicGroupTestBase):",
            "    \"\"\"DynamicGroupMembership instance filterset tests.\"\"\"",
            "",
            "    queryset = DynamicGroupMembership.objects.all()",
            "    filterset = DynamicGroupMembershipFilterSet",
            "",
            "    def test_id(self):",
            "        params = {\"id\": self.queryset.values_list(\"pk\", flat=True)[:2]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_operator(self):",
            "        params = {\"operator\": DynamicGroupOperatorChoices.OPERATOR_INTERSECTION}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_weight(self):",
            "        params = {\"weight\": [10]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_group(self):",
            "        group_pk = self.queryset.first().group.pk  # expecting 1",
            "        group_slug = self.queryset.last().group.slug  # expecting 1",
            "        params = {\"group\": [group_pk, group_slug]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 2)",
            "",
            "    def test_parent_group(self):",
            "        parent_group_pk = self.queryset.first().parent_group.pk  # expecting 3",
            "        parent_group_slug = self.queryset.last().parent_group.slug  # expecting 1",
            "        params = {\"parent_group\": [parent_group_pk, parent_group_slug]}",
            "        self.assertEqual(self.filterset(params, self.queryset).qs.count(), 4)",
            "",
            "    def test_search(self):",
            "        tests = {",
            "            \"intersection\": 2,  # operator",
            "            \"First Child\": 1,  # group__name",
            "            \"second-child\": 1,  # group__slug",
            "            \"Parent\": 3,  # parent_group__name,",
            "            \"third-child\": 2,  # parent_group__slug OR group__slug,",
            "        }",
            "        for value, cnt in tests.items():",
            "            params = {\"q\": value}",
            "            self.assertEqual(self.filterset(params, self.queryset).qs.count(), cnt)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1005": [
                "DynamicGroupModelTest",
                "test_member_caching_enabled"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/tests/test_views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " from nautobot.ipam.factory import VLANFactory"
            },
            "1": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " from nautobot.ipam.models import VLAN, VLANGroup"
            },
            "2": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " from nautobot.users.models import ObjectPermission"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+from nautobot.utilities.permissions import get_permission_for_model"
            },
            "4": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " from nautobot.utilities.testing import ViewTestCases, TestCase, extract_page_body, extract_form_failures"
            },
            "5": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " from nautobot.utilities.testing.utils import disable_warnings, post_data"
            },
            "6": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " from nautobot.utilities.utils import slugify_dashes_to_underscores"
            },
            "7": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": 615,
                "PatchRowcode": "         content_type = ContentType.objects.get_for_model(Device)"
            },
            "8": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": 616,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": 617,
                "PatchRowcode": "         # DynamicGroup objects to test."
            },
            "10": {
                "beforePatchRowNumber": 617,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        DynamicGroup.objects.create(name=\"DG 1\", slug=\"dg-1\", content_type=content_type)"
            },
            "11": {
                "beforePatchRowNumber": 618,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        DynamicGroup.objects.create(name=\"DG 2\", slug=\"dg-2\", content_type=content_type)"
            },
            "12": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        DynamicGroup.objects.create(name=\"DG 3\", slug=\"dg-3\", content_type=content_type)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+        cls.dynamic_groups = ["
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+            DynamicGroup.objects.create(name=\"DG 1\", slug=\"dg-1\", content_type=content_type),"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+            DynamicGroup.objects.create(name=\"DG 2\", slug=\"dg-2\", content_type=content_type),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+            DynamicGroup.objects.create(name=\"DG 3\", slug=\"dg-3\", content_type=content_type),"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+        ]"
            },
            "18": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": 623,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 621,
                "afterPatchRowNumber": 624,
                "PatchRowcode": "         manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")"
            },
            "20": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "         devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")"
            },
            "21": {
                "beforePatchRowNumber": 637,
                "afterPatchRowNumber": 640,
                "PatchRowcode": "             \"dynamic_group_memberships-MAX_NUM_FORMS\": \"1000\","
            },
            "22": {
                "beforePatchRowNumber": 638,
                "afterPatchRowNumber": 641,
                "PatchRowcode": "         }"
            },
            "23": {
                "beforePatchRowNumber": 639,
                "afterPatchRowNumber": 642,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 643,
                "PatchRowcode": "+    def test_get_object_with_permission(self):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 644,
                "PatchRowcode": "+        instance = self._get_queryset().first()"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 645,
                "PatchRowcode": "+        # Add view permissions for the group's members:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 646,
                "PatchRowcode": "+        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 647,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 648,
                "PatchRowcode": "+        response = super().test_get_object_with_permission()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 650,
                "PatchRowcode": "+        response_body = extract_page_body(response.content.decode(response.charset))"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 651,
                "PatchRowcode": "+        # Check that the \"members\" table in the detail view includes all appropriate member objects"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 652,
                "PatchRowcode": "+        for member in instance.members:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 653,
                "PatchRowcode": "+            self.assertIn(str(member.pk), response_body)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 654,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 655,
                "PatchRowcode": "+    def test_get_object_with_constrained_permission(self):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 656,
                "PatchRowcode": "+        instance = self._get_queryset().first()"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 657,
                "PatchRowcode": "+        # Add view permission for one of the group's members but not the others:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 658,
                "PatchRowcode": "+        member1, member2 = instance.members[:2]"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 659,
                "PatchRowcode": "+        obj_perm = ObjectPermission("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 660,
                "PatchRowcode": "+            name=\"Members permission\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 661,
                "PatchRowcode": "+            constraints={\"pk\": member1.pk},"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 662,
                "PatchRowcode": "+            actions=[\"view\"],"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 663,
                "PatchRowcode": "+        )"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 664,
                "PatchRowcode": "+        obj_perm.save()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 665,
                "PatchRowcode": "+        obj_perm.users.add(self.user)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 666,
                "PatchRowcode": "+        obj_perm.object_types.add(instance.content_type)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 667,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 668,
                "PatchRowcode": "+        response = super().test_get_object_with_constrained_permission()"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 669,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 670,
                "PatchRowcode": "+        response_body = extract_page_body(response.content.decode(response.charset))"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 671,
                "PatchRowcode": "+        # Check that the \"members\" table in the detail view includes all permitted member objects"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 672,
                "PatchRowcode": "+        self.assertIn(str(member1.pk), response_body)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 673,
                "PatchRowcode": "+        self.assertNotIn(str(member2.pk), response_body)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 674,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": 640,
                "afterPatchRowNumber": 675,
                "PatchRowcode": "     def test_get_object_dynamic_groups_anonymous(self):"
            },
            "57": {
                "beforePatchRowNumber": 641,
                "afterPatchRowNumber": 676,
                "PatchRowcode": "         url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})"
            },
            "58": {
                "beforePatchRowNumber": 642,
                "afterPatchRowNumber": 677,
                "PatchRowcode": "         self.client.logout()"
            },
            "59": {
                "beforePatchRowNumber": 660,
                "afterPatchRowNumber": 695,
                "PatchRowcode": "         self.assertIn(\"DG 3\", response_body, msg=response_body)"
            },
            "60": {
                "beforePatchRowNumber": 661,
                "afterPatchRowNumber": 696,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 662,
                "afterPatchRowNumber": 697,
                "PatchRowcode": "     def test_get_object_dynamic_groups_with_constrained_permission(self):"
            },
            "62": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.add_permissions(\"extras.view_dynamicgroup\")"
            },
            "63": {
                "beforePatchRowNumber": 664,
                "afterPatchRowNumber": 698,
                "PatchRowcode": "         obj_perm = ObjectPermission("
            },
            "64": {
                "beforePatchRowNumber": 665,
                "afterPatchRowNumber": 699,
                "PatchRowcode": "             name=\"View a device\","
            },
            "65": {
                "beforePatchRowNumber": 666,
                "afterPatchRowNumber": 700,
                "PatchRowcode": "             constraints={\"pk\": Device.objects.first().pk},"
            },
            "66": {
                "beforePatchRowNumber": 669,
                "afterPatchRowNumber": 703,
                "PatchRowcode": "         obj_perm.save()"
            },
            "67": {
                "beforePatchRowNumber": 670,
                "afterPatchRowNumber": 704,
                "PatchRowcode": "         obj_perm.users.add(self.user)"
            },
            "68": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": 705,
                "PatchRowcode": "         obj_perm.object_types.add(ContentType.objects.get_for_model(Device))"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 706,
                "PatchRowcode": "+        obj_perm_2 = ObjectPermission("
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+            name=\"View a Dynamic Group\","
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 708,
                "PatchRowcode": "+            constraints={\"pk\": self.dynamic_groups[0].pk},"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 709,
                "PatchRowcode": "+            actions=[\"view\"],"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 710,
                "PatchRowcode": "+        )"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 711,
                "PatchRowcode": "+        obj_perm_2.save()"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 712,
                "PatchRowcode": "+        obj_perm_2.users.add(self.user)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 713,
                "PatchRowcode": "+        obj_perm_2.object_types.add(ContentType.objects.get_for_model(DynamicGroup))"
            },
            "77": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 714,
                "PatchRowcode": " "
            },
            "78": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": 715,
                "PatchRowcode": "         url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})"
            },
            "79": {
                "beforePatchRowNumber": 674,
                "afterPatchRowNumber": 716,
                "PatchRowcode": "         response = self.client.get(url)"
            },
            "80": {
                "beforePatchRowNumber": 675,
                "afterPatchRowNumber": 717,
                "PatchRowcode": "         self.assertHttpStatus(response, 200)"
            },
            "81": {
                "beforePatchRowNumber": 676,
                "afterPatchRowNumber": 718,
                "PatchRowcode": "         response_body = response.content.decode(response.charset)"
            },
            "82": {
                "beforePatchRowNumber": 677,
                "afterPatchRowNumber": 719,
                "PatchRowcode": "         self.assertIn(\"DG 1\", response_body, msg=response_body)"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 720,
                "PatchRowcode": "+        self.assertNotIn(\"DG 2\", response_body, msg=response_body)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 721,
                "PatchRowcode": "+        self.assertNotIn(\"DG 3\", response_body, msg=response_body)"
            },
            "85": {
                "beforePatchRowNumber": 678,
                "afterPatchRowNumber": 722,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 679,
                "afterPatchRowNumber": 723,
                "PatchRowcode": "         url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.last().pk})"
            },
            "87": {
                "beforePatchRowNumber": 680,
                "afterPatchRowNumber": 724,
                "PatchRowcode": "         response = self.client.get(url)"
            }
        },
        "frontPatchFile": [
            "from datetime import datetime, timedelta",
            "import urllib.parse",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.html import format_html",
            "from unittest import mock",
            "",
            "from nautobot.dcim.models import (",
            "    ConsolePort,",
            "    Device,",
            "    DeviceRole,",
            "    DeviceType,",
            "    Interface,",
            "    LocationType,",
            "    Manufacturer,",
            "    Site,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.choices import (",
            "    CustomFieldTypeChoices,",
            "    JobExecutionType,",
            "    JobSourceChoices,",
            "    LogLevelChoices,",
            "    ObjectChangeActionChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            ")",
            "from nautobot.extras.constants import HTTP_CONTENT_TYPE_JSON",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    Job,",
            "    JobButton,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.templatetags.job_buttons import NO_CONFIRM_BUTTON",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import get_job_content_type, TaggableClassesQuery",
            "from nautobot.ipam.factory import VLANFactory",
            "from nautobot.ipam.models import VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.testing import ViewTestCases, TestCase, extract_page_body, extract_form_failures",
            "from nautobot.utilities.testing.utils import disable_warnings, post_data",
            "from nautobot.utilities.utils import slugify_dashes_to_underscores",
            "",
            "",
            "# Use the proper swappable User model",
            "User = get_user_model()",
            "",
            "",
            "class ComputedFieldTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ComputedField",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        computed_fields = (",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field One\",",
            "                slug=\"computed_field_one\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                slug=\"computed_field_two\",",
            "                label=\"Computed Field Two\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                slug=\"computed_field_three\",",
            "                label=\"Computed Field Three\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field Five\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "        )",
            "",
            "        cls.site1 = Site(name=\"NYC\")",
            "        cls.site1.save()",
            "",
            "        for cf in computed_fields:",
            "            cf.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"slug\": \"computed_field_four\",",
            "            \"label\": \"Computed Field Four\",",
            "            \"template\": \"{{ obj.name }} is the best Site!\",",
            "            \"fallback_value\": \":skull_emoji:\",",
            "            \"weight\": 100,",
            "        }",
            "",
            "        cls.slug_test_object = \"Computed Field Five\"",
            "",
            "",
            "class ComputedFieldRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of ComputedFields, distinct from tests of the ComputedField views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.computedfield = ComputedField(",
            "            content_type=ContentType.objects.get_for_model(LocationType),",
            "            slug=\"test\",",
            "            label=\"Computed Field\",",
            "            template=\"FOO {{ obj.name }} BAR\",",
            "            fallback_value=\"Fallback Value\",",
            "            weight=100,",
            "        )",
            "        self.computedfield.validated_save()",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_computed_field(self):",
            "        \"\"\"Ensure that the computed field template is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {self.location_type.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_computed_field_fallback_value(self):",
            "        \"\"\"Ensure that the fallback_value is rendered if the template fails to render.\"\"\"",
            "        # Make the template invalid to demonstrate the fallback value",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"Fallback Value\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_template(self):",
            "        \"\"\"Ensure that computed field templates can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_fallback_value(self):",
            "        \"\"\"Ensure that computed field fallback values can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.fallback_value = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "# TODO: Change base class to PrimaryObjectViewTestCase",
            "# Blocked by absence of standard create/edit, bulk create views",
            "class ConfigContextTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ConfigContext",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site = Site.objects.first()",
            "",
            "        # Create three ConfigContexts",
            "        for i in range(1, 4):",
            "            configcontext = ConfigContext(name=f\"Config Context {i}\", data={\"foo\": i})",
            "            configcontext.save()",
            "            configcontext.sites.add(site)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Config Context X\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"sites\": [site.pk],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": 123}',",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"weight\": 300,",
            "            \"is_active\": False,",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"sites\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(self._get_queryset().get(name=\"Config Context with schema\").schema.pk, schema.pk)",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"sites\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 200)",
            "        self.assertEqual(self._get_queryset().filter(name=\"Config Context with schema\").count(), 0)",
            "",
            "",
            "# This OrganizationalObjectViewTestCase less BulkImportObjectsViewTestCase",
            "# because it doesn't make sense to support CSV for schemas.",
            "class ConfigContextSchemaTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "):",
            "    model = ConfigContextSchema",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create three ConfigContextSchema records",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", slug=\"schema-2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", slug=\"schema-3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 4\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Schema X\",",
            "            \"slug\": \"schema-x\",",
            "            \"data_schema\": '{\"type\": \"object\",\"properties\": {\"baz\": {\"type\": \"string\"}}}',  # Intentionally misformatted (missing space) to ensure proper formatting on output",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Schema 4\"",
            "",
            "",
            "class CustomLinkTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomLink",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        customlinks = (",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-1\",",
            "                text=\"customlink text 1\",",
            "                target_url=\"http://customlink1.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-2\",",
            "                text=\"customlink text 2\",",
            "                target_url=\"http://customlink2.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-3\",",
            "                text=\"customlink text 3\",",
            "                target_url=\"http://customlink3.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "        )",
            "",
            "        for link in customlinks:",
            "            link.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"name\": \"customlink-4\",",
            "            \"text\": \"customlink text 4\",",
            "            \"target_url\": \"http://customlink4.com\",",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"new_window\": False,",
            "        }",
            "",
            "",
            "class CustomFieldTestCase(",
            "    # No NotesViewTestCase or BulkImportObjectsViewTestCase, at least for now",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomField",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        custom_fields = [",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_BOOLEAN,",
            "                name=\"Custom Field Boolean\",",
            "                label=\"Custom Field Boolean\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                name=\"Custom Field Text\",",
            "                label=\"Custom Field Text\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_INTEGER,",
            "                name=\"Custom Field Integer\",",
            "                label=\"Custom Field Integer\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                # https://github.com/nautobot/nautobot/issues/1962",
            "                name=\"Custom field? With special / unusual characters!\",",
            "                default=\"\",",
            "            ),",
            "        ]",
            "",
            "        cls.slug_test_object = \"Custom Field Integer\"",
            "",
            "        for custom_field in custom_fields:",
            "            custom_field.validated_save()",
            "            custom_field.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [obj_type.pk],",
            "            \"type\": CustomFieldTypeChoices.TYPE_BOOLEAN,  # type is mandatory but cannot be changed once set.",
            "            \"slug\": \"custom_field_boolean\",  # slug is mandatory but cannot be changed once set.",
            "            \"label\": \"Custom Field Boolean\",",
            "            \"default\": None,",
            "            \"filter_logic\": \"loose\",",
            "            \"weight\": 100,",
            "            # These are the \"management_form\" fields required by the dynamic CustomFieldChoice formsets.",
            "            \"choices-TOTAL_FORMS\": \"0\",  # Set to 0 so validation succeeds until we need it",
            "            \"choices-INITIAL_FORMS\": \"1\",",
            "            \"choices-MIN_NUM_FORMS\": \"0\",",
            "            \"choices-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_create_object_without_permission(self):",
            "        # Can't have two CustomFields with the same \"slug\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"slug\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_without_permission()",
            "",
            "    def test_create_object_with_permission(self):",
            "        # Can't have two CustomFields with the same \"slug\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"slug\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_permission()",
            "        instance = self._get_queryset().get(slug=\"custom_field_boolean_2\")",
            "        # 2.0 TODO: #824 removal of `name` field altogether",
            "        # Assure that `name` was auto-populated from the given slug",
            "        self.assertEqual(instance.name, instance.slug)",
            "",
            "    def test_create_object_with_constrained_permission(self):",
            "        # Can't have two CustomFields with the same \"slug\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"slug\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_constrained_permission()",
            "",
            "",
            "class CustomLinkRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of CustomLinks, distinct from tests of the CustomLink views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_site\"]",
            "",
            "    def test_view_object_with_custom_link(self):",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name=\"Test\",",
            "            text=\"FOO {{ obj.name }} BAR\",",
            "            target_url=\"http://example.com/?site={{ obj.slug }}\",",
            "            new_window=False,",
            "        )",
            "        customlink.save()",
            "",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {site.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_text(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name=\"Test\",",
            "            text='<script>alert(\"Hello world!\")</script>',",
            "            target_url=\"http://example.com/?location=None\",",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_url(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name=\"Test\",",
            "            text=\"Hello\",",
            "            target_url='\"><script>alert(\"Hello world!\")</script><a href=\"',",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_name(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name='<script>alert(\"Hello World\")</script>',",
            "            text=\"Hello\",",
            "            target_url=\"http://example.com/?site={{ obj.name \",  # intentionally bad jinja2 to trigger error case",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "class DynamicGroupTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # NOTE: This isn't using `ViewTestCases.PrimaryObjectViewTestCase` because bulk-import/edit",
            "    # views for DynamicGroup do not make sense at this time, primarily because `content_type` is",
            "    # immutable after create.",
            "):",
            "    model = DynamicGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        # DynamicGroup objects to test.",
            "        DynamicGroup.objects.create(name=\"DG 1\", slug=\"dg-1\", content_type=content_type)",
            "        DynamicGroup.objects.create(name=\"DG 2\", slug=\"dg-2\", content_type=content_type)",
            "        DynamicGroup.objects.create(name=\"DG 3\", slug=\"dg-3\", content_type=content_type)",
            "",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        site = Site.objects.first()",
            "        Device.objects.create(name=\"Device 1\", device_type=devicetype, device_role=devicerole, site=site)",
            "        Device.objects.create(name=\"Device 2\", device_type=devicetype, device_role=devicerole, site=site)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_dynamic_group\",",
            "            \"slug\": \"new-dynamic-group\",",
            "            \"description\": \"I am a new dynamic group object.\",",
            "            \"content_type\": content_type.pk,",
            "            # Management form fields required for the dynamic formset",
            "            \"dynamic_group_memberships-TOTAL_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-INITIAL_FORMS\": \"1\",",
            "            \"dynamic_group_memberships-MIN_NUM_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_get_object_dynamic_groups_anonymous(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_object_dynamic_groups_without_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_object_dynamic_groups_with_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.add_permissions(\"dcim.view_device\", \"extras.view_dynamicgroup\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 2\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 3\", response_body, msg=response_body)",
            "",
            "    def test_get_object_dynamic_groups_with_constrained_permission(self):",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        obj_perm = ObjectPermission(",
            "            name=\"View a device\",",
            "            constraints={\"pk\": Device.objects.first().pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Device))",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.last().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_edit_saved_filter(self):",
            "        \"\"\"Test that editing a filter works using the edit view.\"\"\"",
            "        self.add_permissions(\"extras.add_dynamicgroup\", \"extras.change_dynamicgroup\")",
            "",
            "        # Create the object first.",
            "        data = self.form_data.copy()",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        # Now update it.",
            "        instance = self._get_queryset().get(name=data[\"name\"])",
            "        data[\"filter-serial\"] = \"abc123\"",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", instance),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.filter, {\"serial\": data[\"filter-serial\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_filter_by_content_type(self):",
            "        \"\"\"",
            "        Test that filtering by `content_type` in the UI succeeds.",
            "",
            "        This is a regression test for https://github.com/nautobot/nautobot/issues/3612",
            "        \"\"\"",
            "        path = self._get_url(\"list\")",
            "        response = self.client.get(path + \"?content_type=dcim.device\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class ExportTemplateTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ExportTemplate",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        templates = (",
            "            ExportTemplate(",
            "                name=\"template-1\",",
            "                template_code=\"template-1 test1\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-2\",",
            "                template_code=\"template-2 test2\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-3\",",
            "                template_code=\"template-3 test3\",",
            "                content_type=obj_type,",
            "            ),",
            "        )",
            "",
            "        for template in templates:",
            "            template.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"template-4\",",
            "            \"content_type\": obj_type.pk,",
            "            \"template_code\": \"template-4 test4\",",
            "        }",
            "",
            "",
            "class GitRepositoryTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkImportObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GitRepository",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\", slug=\"secrets-group-1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\", slug=\"secrets-group-2\"),",
            "        )",
            "",
            "        # Create four GitRepository records",
            "        repos = (",
            "            GitRepository(name=\"Repo 1\", slug=\"repo-1\", remote_url=\"https://example.com/repo1.git\"),",
            "            GitRepository(name=\"Repo 2\", slug=\"repo-2\", remote_url=\"https://example.com/repo2.git\"),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo-3\", remote_url=\"https://example.com/repo3.git\"),",
            "            GitRepository(name=\"Repo 4\", remote_url=\"https://example.com/repo4.git\", secrets_group=secrets_groups[0]),",
            "        )",
            "        for repo in repos:",
            "            repo.save(trigger_resync=False)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"A new Git repository\",",
            "            \"slug\": \"a-new-git-repository\",",
            "            \"remote_url\": \"http://example.com/a_new_git_repository.git\",",
            "            \"branch\": \"develop\",",
            "            \"_token\": \"1234567890abcdef1234567890abcdef\",",
            "            \"secrets_group\": secrets_groups[1].pk,",
            "            \"provided_contents\": [",
            "                \"extras.configcontext\",",
            "                \"extras.job\",",
            "                \"extras.exporttemplate\",",
            "            ],",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,remote_url,branch,secrets_group,provided_contents\",",
            "            \"Git Repository 5,git-repo-5,https://example.com,main,,extras.configcontext\",",
            "            \"Git Repository 6,git-repo-6,https://example.com,develop,Secrets Group 2,\",",
            "            'Git Repository 7,git-repo-7,https://example.com,next,Secrets Group 2,\"extras.job,extras.exporttemplate\"',",
            "        )",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Repo 4\"",
            "",
            "    def test_post_sync_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_sync_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_pull_git_repository_and_refresh_data` and test successful POST with permissions",
            "",
            "    def test_post_dryrun_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_dryrun_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_git_repository_diff_origin_and_local` and test successful POST with permissions",
            "",
            "",
            "class NoteTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "):",
            "    model = Note",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Site)",
            "        cls.site = Site.objects.first()",
            "        user = User.objects.first()",
            "",
            "        # Notes Objects to test",
            "        Note.objects.create(",
            "            note=\"Site has been placed on maintenance.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.site.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site maintenance has ended.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.site.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site is under duress.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.site.pk,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"note\": \"This is Site note.\",",
            "            \"assigned_object_type\": content_type.pk,",
            "            \"assigned_object_id\": cls.site.pk,",
            "        }",
            "        cls.expected_object_note = '<textarea name=\"object_note\" cols=\"40\" rows=\"10\" class=\"form-control\" placeholder=\"Note\" id=\"id_object_note\"></textarea>'",
            "",
            "    def test_note_on_bulk_update_perms(self):",
            "        self.add_permissions(\"dcim.add_site\", \"extras.add_note\")",
            "        response = self.client.get(reverse(\"dcim:site_add\"))",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_bulk_update_no_perms(self):",
            "        self.add_permissions(\"dcim.add_site\")",
            "        response = self.client.get(reverse(\"dcim:site_add\"))",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_perms(self):",
            "        self.add_permissions(\"dcim.change_site\", \"extras.add_note\")",
            "        response = self.client.post(reverse(\"dcim:site_bulk_edit\"), data={\"pk\": self.site.pk})",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_no_perms(self):",
            "        self.add_permissions(\"dcim.change_site\")",
            "        response = self.client.post(reverse(\"dcim:site_bulk_edit\"), data={\"pk\": self.site.pk})",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "",
            "# Not a full-fledged PrimaryObjectViewTestCase as there's no BulkEditView for Secrets",
            "class SecretTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkImportObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = Secret",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"View Test 1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_1\"},",
            "                tags=[t.pk for t in Tag.objects.get_for_model(Secret)],",
            "            ),",
            "            Secret(",
            "                name=\"View Test 2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"View Test 3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"View Test 4\",",
            "            \"slug\": \"view-test-4\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": '{\"variable\": \"VIEW_TEST_4\"}',",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,provider,parameters\",",
            "            'View Test 5,view-test-5,environment-variable,{\"variable\": \"VIEW_TEST_5\"}',",
            "            'View Test 6,,environment-variable,{\"variable\": \"VIEW_TEST_6\"}',",
            "            'View Test 7,,environment-variable,{\"variable\": \"VIEW_TEST_7\"}',",
            "        )",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"View Test 3\"",
            "",
            "",
            "# Not a full-fledged OrganizationalObjectViewTestCase as there's no BulkImportView for SecretsGroups",
            "class SecretsGroupTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = SecretsGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group 1\", slug=\"group-1\", description=\"First Group\"),",
            "            SecretsGroup.objects.create(name=\"Group 2\", slug=\"group-2\"),",
            "            SecretsGroup.objects.create(name=\"Group 3\", slug=\"group-3\"),",
            "        )",
            "",
            "        secrets = (",
            "            Secret.objects.create(name=\"secret 1\", slug=\"secret-1\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),",
            "            Secret.objects.create(name=\"secret 2\", slug=\"secret-2\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),",
            "            Secret.objects.create(name=\"secret 3\", slug=\"secret-3\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            group=secrets_groups[0],",
            "            secret=secrets[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            group=secrets_groups[0],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            group=secrets_groups[1],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Group 4\",",
            "            \"slug\": \"group-4\",",
            "            \"description\": \"Some description\",",
            "            # Management form fields required for the dynamic Secret formset",
            "            \"secretsgroupassociation_set-TOTAL_FORMS\": \"0\",",
            "            \"secretsgroupassociation_set-INITIAL_FORMS\": \"1\",",
            "            \"secretsgroupassociation_set-MIN_NUM_FORMS\": \"0\",",
            "            \"secretsgroupassociation_set-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Group 3\"",
            "",
            "",
            "class GraphQLQueriesTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GraphQLQuery",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                slug=\"graphql-query-1\",",
            "                query=\"{ query: sites {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                slug=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                slug=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"Graphql Query 5\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "            ),",
            "        )",
            "",
            "        for query in graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"graphql-query-4\",",
            "            \"slug\": \"graphql-query-4\",",
            "            \"query\": \"{query: sites {name}}\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Graphql Query 5\"",
            "",
            "",
            "#",
            "# Jobs, Scheduling, and Approvals",
            "#",
            "",
            "",
            "class ScheduledJobTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "    def test_only_enabled_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        # this should not appear, since it\u2019s not enabled",
            "        ScheduledJob.objects.create(",
            "            enabled=False,",
            "            name=\"test4\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    def test_non_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        def scheduled_job_factory(name, crontab):",
            "            ScheduledJob.objects.create(",
            "                enabled=True,",
            "                name=name,",
            "                task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "                job_class=\"local/test_pass/TestPass\",",
            "                interval=JobExecutionType.TYPE_CUSTOM,",
            "                user=self.user,",
            "                start_time=timezone.now(),",
            "                crontab=crontab,",
            "            )",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test5\", None)",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test6\", \"\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test7\", \"not_enough_values_to_unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test8\", \"one too many values to unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test9\", \"-1 * * * *\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test10\", \"invalid literal * * *\")",
            "",
            "    def test_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            enabled=True,",
            "            name=\"test11\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_CUSTOM,",
            "            user=self.user,",
            "            start_time=datetime.now(),",
            "            crontab=\"*/15 9,17 3 * 1-5\",",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(\"test11\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "",
            "class ApprovalQueueTestCase(",
            "    # It would be nice to use ViewTestCases.GetObjectViewTestCase as well,",
            "    # but we can't directly use it as it uses instance.get_absolute_url() rather than self._get_url(\"view\", instance)",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    # Many interactions with a ScheduledJob also require permissions to view the associated Job",
            "    user_permissions = (\"extras.view_job\",)",
            "",
            "    def _get_url(self, action, instance=None):",
            "        if action == \"list\":",
            "            return reverse(\"extras:scheduledjob_approval_queue_list\")",
            "        if action == \"view\" and instance is not None:",
            "            return reverse(\"extras:scheduledjob_approval_request_view\", kwargs={\"pk\": instance.pk})",
            "        raise ValueError(\"This override is only valid for list and view test cases\")",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        self.job_model_2 = Job.objects.get_for_class_path(\"local/test_fail/TestFail\")",
            "        self.job_model_3 = Job.objects.get_for_class_path(\"local/test_read_only_pass/TestReadOnlyPass\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model,",
            "            job_class=self.job_model.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model_2,",
            "            job_class=self.job_model_2.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model_3,",
            "            job_class=self.job_model_3.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "    def test_only_approvable_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test4\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model,",
            "            job_class=self.job_model.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=False,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    #",
            "    # Reimplementations of ViewTestCases.GetObjectViewTestCase test functions.",
            "    # Needed because those use instance.get_absolute_url() instead of self._get_url(\"view\", instance)...",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_get_object_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_without_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        with disable_warnings(\"django.request\"):",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance)), 403)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        # Add model-level permission",
            "        obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET with model-level permission",
            "        response = self.client.get(self._get_url(\"view\", instance))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "",
            "        # The object's display name or string representation should appear in the response",
            "        self.assertIn(getattr(instance, \"display\", str(instance)), response_body, msg=response_body)",
            "",
            "        # skip GetObjectViewTestCase checks for Relationships and Custom Fields since this isn't actually a detail view",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_constrained_permission(self):",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "        # Add object-level permission",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": instance1.pk},",
            "            # To get a different rendering flow than the \"test_get_object_with_permission\" test above,",
            "            # enable additional permissions for this object so that interaction buttons are rendered.",
            "            actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET to permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance1)), 200)",
            "",
            "        # Try GET to non-permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance2)), 404)",
            "",
            "    #",
            "    # Additional test cases specific to the job approval view",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_anonymous(self):",
            "        \"\"\"Anonymous users may not take any action with regard to job approval requests.\"\"\"",
            "        self.client.logout()",
            "        response = self.client.post(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run jobs\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_not_runnable(self):",
            "        \"\"\"A non-enabled job cannot be dry-run.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"This job cannot be run at this time\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_job_run_permission(self):",
            "        \"\"\"A user without run_job permission cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_specific_job_run_permission(self):",
            "        \"\"\"A user without run_job permission FOR THAT SPECIFIC JOB cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "        data = {\"_dry_run\": True}",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance1.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        instance1.job_model.enabled = True",
            "        instance1.job_model.save()",
            "        instance2.job_model.enabled = True",
            "        instance2.job_model.save()",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance2), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_post_dry_run_success(self, _):",
            "        \"\"\"Successfully request a dry run based on object-based run_job permissions.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        # Job was submitted",
            "        self.assertEqual(",
            "            1, len(JobResult.objects.all()), msg=extract_page_body(response.content.decode(response.charset))",
            "        )",
            "        job_result = JobResult.objects.first()",
            "        self.assertEqual(job_result.job_model, instance.job_model)",
            "        self.assertEqual(job_result.user, self.user)",
            "        self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": job_result.pk}))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both delete_scheduledjob and approve_job permissions to deny a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 delete_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Delete\", actions=[\"delete\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not delete_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_deny\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Request was not deleted",
            "            self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can deny a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and delete_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"delete\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_deny\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Request was deleted",
            "        self.assertEqual(0, len(ScheduledJob.objects.filter(pk=instance.pk)))",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().first()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Request was not deleted",
            "        self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_cannot_self_approve(self):",
            "        self.add_permissions(\"extras.change_scheduledjob\")",
            "        self.add_permissions(\"extras.approve_job\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You cannot approve your own job request\", response_body)",
            "        # Job was not approved",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both change_scheduledjob and approve_job permissions to approve a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 change_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Change\", actions=[\"change\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not change_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Job was not approved",
            "            instance.refresh_from_db()",
            "            self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can approve a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and change_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"change\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_approve\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Job was scheduled",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.approved_by_user, user)",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().last()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Job was not scheduled",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "",
            "class JobResultTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = JobResult",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = get_job_content_type()",
            "        JobResult.objects.create(",
            "            name=\"local/test_pass/TestPass\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=obj_type,",
            "        )",
            "        JobResult.objects.create(",
            "            name=\"local/test_fail/TestFail\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=obj_type,",
            "        )",
            "        JobResult.objects.create(",
            "            name=\"local/test_read_only_fail/TestReadOnlyFail\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=obj_type,",
            "        )",
            "        JobLogEntry.objects.create(",
            "            log_level=LogLevelChoices.LOG_INFO,",
            "            job_result=JobResult.objects.first(),",
            "            grouping=\"run\",",
            "            message=\"This is a test\",",
            "        )",
            "",
            "    def test_get_joblogentrytable_anonymous(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_joblogentrytable_without_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_joblogentrytable_with_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.add_permissions(\"extras.view_jobresult\", \"extras.view_joblogentry\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"This is a test\", response_body)",
            "",
            "    # TODO test with constrained permissions on both JobResult and JobLogEntry records",
            "",
            "",
            "class JobTestCase(",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    \"\"\"",
            "    The Job view test cases.",
            "    \"\"\"",
            "",
            "    model = Job",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"Don't include hidden Jobs, non-installed Jobs, JobHookReceivers or JobButtonReceivers as they won't appear in the UI by default.\"\"\"",
            "        return self.model.objects.filter(",
            "            installed=True, hidden=False, is_job_hook_receiver=False, is_job_button_receiver=False",
            "        )",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Job model objects are automatically created during database migrations",
            "",
            "        # But we do need to make sure the ones we're testing are flagged appropriately",
            "        cls.test_pass = Job.objects.get(job_class_name=\"TestPass\")",
            "        cls.test_pass.enabled = True",
            "        cls.test_pass.save()",
            "",
            "        cls.run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job\", kwargs={\"class_path\": cls.test_pass.class_path}),",
            "            # Current URL (job model slug based)",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": cls.test_pass.slug}),",
            "        )",
            "",
            "        cls.test_required_args = Job.objects.get(job_class_name=\"TestRequired\")",
            "        cls.test_required_args.enabled = True",
            "        cls.test_required_args.save()",
            "",
            "        cls.extra_run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job\", kwargs={\"class_path\": cls.test_required_args.class_path}),",
            "            # Current URL (job model slug based)",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": cls.test_required_args.slug}),",
            "        )",
            "",
            "        # Create an entry for a non-installed Job as well",
            "        cls.test_not_installed = Job(",
            "            source=JobSourceChoices.SOURCE_LOCAL,",
            "            module_name=\"nonexistent\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Nonexistent Jobs\",",
            "            name=\"No such job\",",
            "            enabled=True,",
            "            installed=False,",
            "        )",
            "        cls.test_not_installed.validated_save()",
            "",
            "        cls.data_run_immediately = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "",
            "        cls.form_data = {",
            "            \"slug\": \"custom-job-slug\",",
            "            \"enabled\": True,",
            "            \"grouping_override\": True,",
            "            \"grouping\": \"Overridden Grouping\",",
            "            \"name_override\": True,",
            "            \"name\": \"Overridden Name\",",
            "            \"description_override\": True,",
            "            \"description\": \"This is an overridden description of a job.\",",
            "            \"commit_default_override\": True,",
            "            \"commit_default\": False,",
            "            \"hidden_override\": True,",
            "            \"hidden\": False,",
            "            \"read_only_override\": True,",
            "            \"read_only\": False,",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "            \"soft_time_limit_override\": True,",
            "            \"soft_time_limit\": 350,",
            "            \"time_limit_override\": True,",
            "            \"time_limit\": 650,",
            "            \"has_sensitive_variables\": False,",
            "            \"has_sensitive_variables_override\": True,",
            "            \"task_queues\": \"overridden,priority\",",
            "            \"task_queues_override\": True,",
            "        }",
            "",
            "    #",
            "    # Additional test cases for the \"job\" (legacy run) and \"job_run\" (updated run) views follow",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 403, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_permission(self):",
            "        \"\"\"",
            "        Get view with appropriate global permissions.",
            "",
            "        Note that this view is conditional on run_job permission, not view_job permission,",
            "        so EXEMPT_VIEW_PERMISSIONS=[\"*\"] does NOT apply here.",
            "        \"\"\"",
            "        self.add_permissions(\"extras.run_job\")",
            "        for run_url in self.run_urls:",
            "            response = self.client.get(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"TestPass\", response_body)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_constrained_permission(self):",
            "        \"\"\"Get view with appropriate object-based permissions.\"\"\"",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try GET with a permitted object",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 200, msg=run_url)",
            "",
            "        # Try GET with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 404, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url), 403, msg=run_url)",
            "",
            "    def test_run_missing_schedule(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_type: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=0)",
            "    def test_run_now_no_worker(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Celery worker process not running.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_constrained_permissions(self, _):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        # Try POST with a permitted object",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertIsNotNone(result, msg=run_url)",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "        # Try POST with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url, self.data_run_immediately), 404, msg=run_url)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_installed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job\", kwargs={\"class_path\": self.test_not_installed.class_path}),",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": self.test_not_installed.slug}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not presently installed\", response_body)",
            "",
            "            self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_enabled(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job\", kwargs={\"class_path\": \"local/test_fail/TestFail\"}),",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": Job.objects.get(job_class_name=\"TestFail\").slug}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not enabled to be run\", response_body)",
            "",
            "            self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    def test_run_now_missing_args(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"var: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_with_args(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"var\": \"12\",",
            "        }",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, data)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_name(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_name: Please provide a name for the job schedule.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_date(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_date_passed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(datetime.now() - timedelta(minutes=1)),",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertRedirects(response, reverse(\"extras:scheduledjob_list\"))",
            "",
            "            scheduled = ScheduledJob.objects.last()",
            "            self.assertEqual(scheduled.name, \"test\")",
            "            self.assertEqual(scheduled.start_time, start_time)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_sets_scheduled_job_kwargs_pk(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertRedirects(response, reverse(\"extras:scheduledjob_list\"))",
            "",
            "            scheduled = ScheduledJob.objects.last()",
            "            self.assertEqual(scheduled.kwargs[\"scheduled_job_pk\"], str(scheduled.pk))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_for_future(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.has_sensitive_variables_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Unable to schedule job: Job may have sensitive input variables.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_invalid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        self.test_pass.task_queues = []",
            "        self.test_pass.task_queues_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"_task_queue\": \"invalid\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [\"_task_queue: Select a valid choice. invalid is not one of the available choices.\"],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_and_requires_approval(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.approval_required = True",
            "        self.test_pass.save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "        for run_url in self.run_urls:",
            "            # Assert warning message shows in get",
            "            response = self.client.get(run_url)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\",",
            "                content,",
            "            )",
            "",
            "            # Assert run button is disabled",
            "            self.assertInHTML(",
            "                \"\"\"",
            "                <button type=\"submit\" name=\"_run\" id=\"id__run\" class=\"btn btn-primary\" disabled=\"disabled\">",
            "                    <i class=\"mdi mdi-play\"></i> Run Job Now",
            "                </button>",
            "                \"\"\",",
            "                content,",
            "            )",
            "            # Assert error message shows after post",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "                content,",
            "            )",
            "",
            "    def test_job_object_change_log_view(self):",
            "        \"\"\"Assert Job change log view displays appropriate header\"\"\"",
            "        instance = self.test_pass",
            "        self.add_permissions(\"extras.view_objectchange\", \"extras.view_job\")",
            "        response = self.client.get(instance.get_changelog_url())",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(f\"<h1>{instance.name} - Change Log</h1>\", content)",
            "",
            "",
            "class JobButtonTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobButton",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        job_buttons = (",
            "            JobButton.objects.create(",
            "                name=\"JobButton1\",",
            "                text=\"JobButton1\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=True,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton2\",",
            "                text=\"JobButton2\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=False,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton3\",",
            "                text=\"JobButton3\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "                confirmation=True,",
            "                weight=50,",
            "            ),",
            "        )",
            "",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "        for jb in job_buttons:",
            "            jb.content_types.set([site_ct])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [site_ct.pk],",
            "            \"name\": \"jobbutton-4\",",
            "            \"text\": \"jobbutton text 4\",",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"confirmation\": False,",
            "        }",
            "",
            "",
            "class JobButtonRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the rendering of JobButtons, distinct from tests of the JobButton views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job = Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\")",
            "        self.job_button_1 = JobButton(",
            "            name=\"JobButton 1\",",
            "            text=\"JobButton {{ obj.name }}\",",
            "            job=self.job,",
            "            confirmation=False,",
            "        )",
            "        self.job_button_1.validated_save()",
            "        self.job_button_1.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.job_button_2 = JobButton(",
            "            name=\"JobButton 2\",",
            "            text=\"Click me!\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            confirmation=False,",
            "        )",
            "        self.job_button_2.validated_save()",
            "        self.job_button_2.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_job_button(self):",
            "        \"\"\"Ensure that the job button is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"JobButton {self.location_type.name}\", content, content)",
            "        self.assertIn(\"Click me!\", content, content)",
            "",
            "    def test_task_queue_hidden_input_is_present(self):",
            "        \"\"\"",
            "        Ensure that the job button respects the job class' task_queues and the job class task_queues[0]/default is passed as a hidden form input.",
            "        \"\"\"",
            "        self.job.task_queues_override = True",
            "        self.job.task_queues = [\"overriden_queue\", \"default\", \"priority\"]",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f'<input type=\"hidden\" name=\"_task_queue\" value=\"{self.job.task_queues[0]}\">', content, content)",
            "        self.job.task_queues_override = False",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(",
            "            f'<input type=\"hidden\" name=\"_task_queue\" value=\"{settings.CELERY_TASK_DEFAULT_QUEUE}\">', content, content",
            "        )",
            "",
            "    def test_view_object_with_unsafe_text(self):",
            "        \"\"\"Ensure that JobButton text can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = '<script>alert(\"Hello world!\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "        # Make sure grouped rendering is safe too",
            "        self.job_button_1.group_name = '<script>alert(\"Goodbye\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_unsafe_name(self):",
            "        \"\"\"Ensure that JobButton names can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = \"JobButton {{ obj\"",
            "        self.job_button_1.name = '<script>alert(\"Yo\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_render_constrained_run_permissions(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.job_button_1.job.pk},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        with self.subTest(\"Ungrouped buttons\"):",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=self.job_button_1.button_class,",
            "                    disabled=\"\",",
            "                ),",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=self.job_button_2.button_class,",
            "                    disabled=\"disabled\",",
            "                ),",
            "                content,",
            "            )",
            "",
            "        with self.subTest(\"Grouped buttons\"):",
            "            self.job_button_1.group_name = \"Grouping\"",
            "            self.job_button_1.validated_save()",
            "            self.job_button_2.group_name = \"Grouping\"",
            "            self.job_button_2.validated_save()",
            "",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=\"link\",",
            "                    disabled=\"\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=\"link\",",
            "                    disabled=\"disabled\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "",
            "",
            "# TODO: Convert to StandardTestCases.Views",
            "class ObjectChangeTestCase(TestCase):",
            "    user_permissions = (\"extras.view_objectchange\",)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site = Site(name=\"Site 1\", slug=\"site-1\")",
            "        site.save()",
            "",
            "        # Create three ObjectChanges",
            "        user = User.objects.create_user(username=\"testuser2\")",
            "        for _ in range(1, 4):",
            "            oc = site.to_objectchange(action=ObjectChangeActionChoices.ACTION_UPDATE)",
            "            oc.user = user",
            "            oc.request_id = uuid.uuid4()",
            "            oc.save()",
            "",
            "    def test_objectchange_list(self):",
            "        url = reverse(\"extras:objectchange_list\")",
            "        params = {",
            "            \"user\": User.objects.first().pk,",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_objectchange(self):",
            "        objectchange = ObjectChange.objects.first()",
            "        response = self.client.get(objectchange.get_absolute_url())",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class RelationshipTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    RequiredRelationshipTestMixin,",
            "):",
            "    model = Relationship",
            "    slug_source = \"name\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        interface_type = ContentType.objects.get_for_model(Interface)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "",
            "        Relationship(",
            "            name=\"Device VLANs\",",
            "            slug=\"device-vlans\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            name=\"Primary VLAN\",",
            "            slug=\"primary-vlan\",",
            "            type=\"one-to-many\",",
            "            source_type=vlan_type,",
            "            destination_type=device_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            name=\"Primary Interface\",",
            "            type=\"one-to-one\",",
            "            source_type=device_type,",
            "            destination_type=interface_type,",
            "        ).validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"VLAN-to-Interface\",",
            "            \"slug\": \"vlan-to-interface\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": vlan_type.pk,",
            "            \"source_label\": \"Interfaces\",",
            "            \"source_hidden\": False,",
            "            \"source_filter\": '{\"status\": [\"active\"]}',",
            "            \"destination_type\": interface_type.pk,",
            "            \"destination_label\": \"VLANs\",",
            "            \"destination_hidden\": True,",
            "            \"destination_filter\": None,",
            "        }",
            "",
            "        cls.slug_test_object = \"Primary Interface\"",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test bulk edit",
            "        \"\"\"",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"ui\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        vlans = VLANFactory.create_batch(6)",
            "",
            "        # Try deleting all devices and then editing the 6 VLANs (fails):",
            "        Device.objects.all().delete()",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(response, \"VLANs require at least one device, but no devices exist yet.\")",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "",
            "        # Try editing all 6 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "        # Try editing 3 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans[:3]], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"These VLANs require a device for the required \"",
            "            \"relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "        for vlan in vlans[:3]:",
            "            self.assertContains(response, f\"{str(vlan)}\")",
            "",
            "        # Try editing 6 VLANs and adding the required device (succeeds):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"add_cr_vlans-devices-m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertContains(response, \"Updated 6 VLANs\")",
            "",
            "        # Try editing 6 VLANs and removing the required device (fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"remove_cr_vlans-devices-m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "",
            "class RelationshipAssociationTestCase(",
            "    # TODO? ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    # TODO? ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # TODO? ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = RelationshipAssociation",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "",
            "        relationship = Relationship(",
            "            name=\"Device VLANs\",",
            "            slug=\"device-vlans\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        relationship.validated_save()",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        site = Site.objects.first()",
            "        devices = (",
            "            Device.objects.create(name=\"Device 1\", device_type=devicetype, device_role=devicerole, site=site),",
            "            Device.objects.create(name=\"Device 2\", device_type=devicetype, device_role=devicerole, site=site),",
            "            Device.objects.create(name=\"Device 3\", device_type=devicetype, device_role=devicerole, site=site),",
            "        )",
            "        vlans = (",
            "            VLAN.objects.create(vid=1, name=\"VLAN 1\"),",
            "            VLAN.objects.create(vid=2, name=\"VLAN 2\"),",
            "            VLAN.objects.create(vid=3, name=\"VLAN 3\"),",
            "        )",
            "",
            "        RelationshipAssociation(",
            "            relationship=relationship,",
            "            source_type=device_type,",
            "            source_id=devices[0].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[0].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship,",
            "            source_type=device_type,",
            "            source_id=devices[1].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[1].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship,",
            "            source_type=device_type,",
            "            source_id=devices[2].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[2].pk,",
            "        ).validated_save()",
            "",
            "",
            "class StatusTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Status",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Status objects to test.",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_status\",",
            "            \"slug\": \"new-status\",",
            "            \"description\": \"I am a new status object.\",",
            "            \"color\": \"ffcc00\",",
            "            \"content_types\": [content_type.pk],",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,color,content_types\"",
            "            'test_status1,test-status1,ffffff,\"dcim.device\"'",
            "            'test_status2,test-status2,ffffff,\"dcim.device,dcim.rack\"'",
            "            'test_status3,test-status3,ffffff,\"dcim.device,dcim.site\"'",
            "            'test_status4,,ffffff,\"dcim.device,dcim.site\"'",
            "        )",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"000000\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = Status.objects.first().name",
            "",
            "",
            "class TagTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = Tag",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"Tag X\",",
            "            \"slug\": \"tag-x\",",
            "            \"color\": \"c0c0c0\",",
            "            \"comments\": \"Some comments\",",
            "            \"content_types\": [ct.id for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,color,description\",",
            "            \"Tag 4,tag-4,ff0000,Fourth tag\",",
            "            \"Tag 5,tag-5,00ff00,Fifth tag\",",
            "            \"Tag 6,tag-6,0000ff,Sixth tag\",",
            "        )",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"00ff00\",",
            "        }",
            "",
            "    def test_create_tags_with_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        site_content_type = ContentType.objects.get_for_model(Site)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [site_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        tag = Tag.objects.filter(slug=self.form_data[\"slug\"])",
            "        self.assertTrue(tag.exists())",
            "        self.assertEqual(tag[0].content_types.first(), site_content_type)",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        vlangroup_content_type = ContentType.objects.get_for_model(VLANGroup)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [vlangroup_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        tag = Tag.objects.filter(slug=self.form_data[\"slug\"])",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(\"content_types: Select a valid choice\", str(response.content))",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.get_for_model(Site).first()",
            "        site = Site.objects.first()",
            "        site.tags.add(tag_1)",
            "",
            "        form_data = {",
            "            \"name\": tag_1.name,",
            "            \"slug\": tag_1.slug,",
            "            \"color\": \"c0c0c0\",",
            "            \"content_types\": [ContentType.objects.get_for_model(Device).id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", tag_1),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        self.assertHttpStatus(",
            "            response, 200, [\"content_types: Unable to remove dcim.site. Dependent objects were found.\"]",
            "        )",
            "",
            "",
            "class WebhookTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Webhook",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        webhooks = (",
            "            Webhook(",
            "                name=\"webhook-1\",",
            "                enabled=True,",
            "                type_create=True,",
            "                payload_url=\"http://test-url.com/test-1\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-2\",",
            "                enabled=True,",
            "                type_update=True,",
            "                payload_url=\"http://test-url.com/test-2\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-3\",",
            "                enabled=True,",
            "                type_delete=True,",
            "                payload_url=\"http://test-url.com/test-3\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(ConsolePort)",
            "",
            "        for webhook in webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"name\": \"webhook-4\",",
            "            \"content_types\": [obj_type.pk],",
            "            \"enabled\": True,",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://test-url.com/test-4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "        }"
        ],
        "afterPatchFile": [
            "from datetime import datetime, timedelta",
            "import urllib.parse",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.html import format_html",
            "from unittest import mock",
            "",
            "from nautobot.dcim.models import (",
            "    ConsolePort,",
            "    Device,",
            "    DeviceRole,",
            "    DeviceType,",
            "    Interface,",
            "    LocationType,",
            "    Manufacturer,",
            "    Site,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.choices import (",
            "    CustomFieldTypeChoices,",
            "    JobExecutionType,",
            "    JobSourceChoices,",
            "    LogLevelChoices,",
            "    ObjectChangeActionChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            ")",
            "from nautobot.extras.constants import HTTP_CONTENT_TYPE_JSON",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    Job,",
            "    JobButton,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.templatetags.job_buttons import NO_CONFIRM_BUTTON",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import get_job_content_type, TaggableClassesQuery",
            "from nautobot.ipam.factory import VLANFactory",
            "from nautobot.ipam.models import VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.testing import ViewTestCases, TestCase, extract_page_body, extract_form_failures",
            "from nautobot.utilities.testing.utils import disable_warnings, post_data",
            "from nautobot.utilities.utils import slugify_dashes_to_underscores",
            "",
            "",
            "# Use the proper swappable User model",
            "User = get_user_model()",
            "",
            "",
            "class ComputedFieldTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ComputedField",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        computed_fields = (",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field One\",",
            "                slug=\"computed_field_one\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                slug=\"computed_field_two\",",
            "                label=\"Computed Field Two\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                slug=\"computed_field_three\",",
            "                label=\"Computed Field Three\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field Five\",",
            "                template=\"Site name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "        )",
            "",
            "        cls.site1 = Site(name=\"NYC\")",
            "        cls.site1.save()",
            "",
            "        for cf in computed_fields:",
            "            cf.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"slug\": \"computed_field_four\",",
            "            \"label\": \"Computed Field Four\",",
            "            \"template\": \"{{ obj.name }} is the best Site!\",",
            "            \"fallback_value\": \":skull_emoji:\",",
            "            \"weight\": 100,",
            "        }",
            "",
            "        cls.slug_test_object = \"Computed Field Five\"",
            "",
            "",
            "class ComputedFieldRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of ComputedFields, distinct from tests of the ComputedField views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.computedfield = ComputedField(",
            "            content_type=ContentType.objects.get_for_model(LocationType),",
            "            slug=\"test\",",
            "            label=\"Computed Field\",",
            "            template=\"FOO {{ obj.name }} BAR\",",
            "            fallback_value=\"Fallback Value\",",
            "            weight=100,",
            "        )",
            "        self.computedfield.validated_save()",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_computed_field(self):",
            "        \"\"\"Ensure that the computed field template is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {self.location_type.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_computed_field_fallback_value(self):",
            "        \"\"\"Ensure that the fallback_value is rendered if the template fails to render.\"\"\"",
            "        # Make the template invalid to demonstrate the fallback value",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"Fallback Value\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_template(self):",
            "        \"\"\"Ensure that computed field templates can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_fallback_value(self):",
            "        \"\"\"Ensure that computed field fallback values can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.fallback_value = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "# TODO: Change base class to PrimaryObjectViewTestCase",
            "# Blocked by absence of standard create/edit, bulk create views",
            "class ConfigContextTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ConfigContext",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site = Site.objects.first()",
            "",
            "        # Create three ConfigContexts",
            "        for i in range(1, 4):",
            "            configcontext = ConfigContext(name=f\"Config Context {i}\", data={\"foo\": i})",
            "            configcontext.save()",
            "            configcontext.sites.add(site)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Config Context X\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"sites\": [site.pk],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": 123}',",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"weight\": 300,",
            "            \"is_active\": False,",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"sites\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(self._get_queryset().get(name=\"Config Context with schema\").schema.pk, schema.pk)",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"sites\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 200)",
            "        self.assertEqual(self._get_queryset().filter(name=\"Config Context with schema\").count(), 0)",
            "",
            "",
            "# This OrganizationalObjectViewTestCase less BulkImportObjectsViewTestCase",
            "# because it doesn't make sense to support CSV for schemas.",
            "class ConfigContextSchemaTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "):",
            "    model = ConfigContextSchema",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create three ConfigContextSchema records",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", slug=\"schema-1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", slug=\"schema-2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", slug=\"schema-3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 4\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Schema X\",",
            "            \"slug\": \"schema-x\",",
            "            \"data_schema\": '{\"type\": \"object\",\"properties\": {\"baz\": {\"type\": \"string\"}}}',  # Intentionally misformatted (missing space) to ensure proper formatting on output",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Schema 4\"",
            "",
            "",
            "class CustomLinkTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomLink",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        customlinks = (",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-1\",",
            "                text=\"customlink text 1\",",
            "                target_url=\"http://customlink1.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-2\",",
            "                text=\"customlink text 2\",",
            "                target_url=\"http://customlink2.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-3\",",
            "                text=\"customlink text 3\",",
            "                target_url=\"http://customlink3.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "        )",
            "",
            "        for link in customlinks:",
            "            link.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"name\": \"customlink-4\",",
            "            \"text\": \"customlink text 4\",",
            "            \"target_url\": \"http://customlink4.com\",",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"new_window\": False,",
            "        }",
            "",
            "",
            "class CustomFieldTestCase(",
            "    # No NotesViewTestCase or BulkImportObjectsViewTestCase, at least for now",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomField",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        custom_fields = [",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_BOOLEAN,",
            "                name=\"Custom Field Boolean\",",
            "                label=\"Custom Field Boolean\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                name=\"Custom Field Text\",",
            "                label=\"Custom Field Text\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_INTEGER,",
            "                name=\"Custom Field Integer\",",
            "                label=\"Custom Field Integer\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                # https://github.com/nautobot/nautobot/issues/1962",
            "                name=\"Custom field? With special / unusual characters!\",",
            "                default=\"\",",
            "            ),",
            "        ]",
            "",
            "        cls.slug_test_object = \"Custom Field Integer\"",
            "",
            "        for custom_field in custom_fields:",
            "            custom_field.validated_save()",
            "            custom_field.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [obj_type.pk],",
            "            \"type\": CustomFieldTypeChoices.TYPE_BOOLEAN,  # type is mandatory but cannot be changed once set.",
            "            \"slug\": \"custom_field_boolean\",  # slug is mandatory but cannot be changed once set.",
            "            \"label\": \"Custom Field Boolean\",",
            "            \"default\": None,",
            "            \"filter_logic\": \"loose\",",
            "            \"weight\": 100,",
            "            # These are the \"management_form\" fields required by the dynamic CustomFieldChoice formsets.",
            "            \"choices-TOTAL_FORMS\": \"0\",  # Set to 0 so validation succeeds until we need it",
            "            \"choices-INITIAL_FORMS\": \"1\",",
            "            \"choices-MIN_NUM_FORMS\": \"0\",",
            "            \"choices-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_create_object_without_permission(self):",
            "        # Can't have two CustomFields with the same \"slug\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"slug\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_without_permission()",
            "",
            "    def test_create_object_with_permission(self):",
            "        # Can't have two CustomFields with the same \"slug\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"slug\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_permission()",
            "        instance = self._get_queryset().get(slug=\"custom_field_boolean_2\")",
            "        # 2.0 TODO: #824 removal of `name` field altogether",
            "        # Assure that `name` was auto-populated from the given slug",
            "        self.assertEqual(instance.name, instance.slug)",
            "",
            "    def test_create_object_with_constrained_permission(self):",
            "        # Can't have two CustomFields with the same \"slug\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"slug\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_constrained_permission()",
            "",
            "",
            "class CustomLinkRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of CustomLinks, distinct from tests of the CustomLink views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_site\"]",
            "",
            "    def test_view_object_with_custom_link(self):",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name=\"Test\",",
            "            text=\"FOO {{ obj.name }} BAR\",",
            "            target_url=\"http://example.com/?site={{ obj.slug }}\",",
            "            new_window=False,",
            "        )",
            "        customlink.save()",
            "",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {site.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_text(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name=\"Test\",",
            "            text='<script>alert(\"Hello world!\")</script>',",
            "            target_url=\"http://example.com/?location=None\",",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_url(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name=\"Test\",",
            "            text=\"Hello\",",
            "            target_url='\"><script>alert(\"Hello world!\")</script><a href=\"',",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_name(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Site),",
            "            name='<script>alert(\"Hello World\")</script>',",
            "            text=\"Hello\",",
            "            target_url=\"http://example.com/?site={{ obj.name \",  # intentionally bad jinja2 to trigger error case",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        site = Site(name=\"Test Site\", slug=\"test-site\")",
            "        site.save()",
            "",
            "        response = self.client.get(site.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "class DynamicGroupTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # NOTE: This isn't using `ViewTestCases.PrimaryObjectViewTestCase` because bulk-import/edit",
            "    # views for DynamicGroup do not make sense at this time, primarily because `content_type` is",
            "    # immutable after create.",
            "):",
            "    model = DynamicGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        # DynamicGroup objects to test.",
            "        cls.dynamic_groups = [",
            "            DynamicGroup.objects.create(name=\"DG 1\", slug=\"dg-1\", content_type=content_type),",
            "            DynamicGroup.objects.create(name=\"DG 2\", slug=\"dg-2\", content_type=content_type),",
            "            DynamicGroup.objects.create(name=\"DG 3\", slug=\"dg-3\", content_type=content_type),",
            "        ]",
            "",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        site = Site.objects.first()",
            "        Device.objects.create(name=\"Device 1\", device_type=devicetype, device_role=devicerole, site=site)",
            "        Device.objects.create(name=\"Device 2\", device_type=devicetype, device_role=devicerole, site=site)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_dynamic_group\",",
            "            \"slug\": \"new-dynamic-group\",",
            "            \"description\": \"I am a new dynamic group object.\",",
            "            \"content_type\": content_type.pk,",
            "            # Management form fields required for the dynamic formset",
            "            \"dynamic_group_memberships-TOTAL_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-INITIAL_FORMS\": \"1\",",
            "            \"dynamic_group_memberships-MIN_NUM_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_get_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "        # Add view permissions for the group's members:",
            "        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))",
            "",
            "        response = super().test_get_object_with_permission()",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        # Check that the \"members\" table in the detail view includes all appropriate member objects",
            "        for member in instance.members:",
            "            self.assertIn(str(member.pk), response_body)",
            "",
            "    def test_get_object_with_constrained_permission(self):",
            "        instance = self._get_queryset().first()",
            "        # Add view permission for one of the group's members but not the others:",
            "        member1, member2 = instance.members[:2]",
            "        obj_perm = ObjectPermission(",
            "            name=\"Members permission\",",
            "            constraints={\"pk\": member1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(instance.content_type)",
            "",
            "        response = super().test_get_object_with_constrained_permission()",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        # Check that the \"members\" table in the detail view includes all permitted member objects",
            "        self.assertIn(str(member1.pk), response_body)",
            "        self.assertNotIn(str(member2.pk), response_body)",
            "",
            "    def test_get_object_dynamic_groups_anonymous(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_object_dynamic_groups_without_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_object_dynamic_groups_with_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.add_permissions(\"dcim.view_device\", \"extras.view_dynamicgroup\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 2\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 3\", response_body, msg=response_body)",
            "",
            "    def test_get_object_dynamic_groups_with_constrained_permission(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"View a device\",",
            "            constraints={\"pk\": Device.objects.first().pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Device))",
            "        obj_perm_2 = ObjectPermission(",
            "            name=\"View a Dynamic Group\",",
            "            constraints={\"pk\": self.dynamic_groups[0].pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm_2.save()",
            "        obj_perm_2.users.add(self.user)",
            "        obj_perm_2.object_types.add(ContentType.objects.get_for_model(DynamicGroup))",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "        self.assertNotIn(\"DG 2\", response_body, msg=response_body)",
            "        self.assertNotIn(\"DG 3\", response_body, msg=response_body)",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.last().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_edit_saved_filter(self):",
            "        \"\"\"Test that editing a filter works using the edit view.\"\"\"",
            "        self.add_permissions(\"extras.add_dynamicgroup\", \"extras.change_dynamicgroup\")",
            "",
            "        # Create the object first.",
            "        data = self.form_data.copy()",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        # Now update it.",
            "        instance = self._get_queryset().get(name=data[\"name\"])",
            "        data[\"filter-serial\"] = \"abc123\"",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", instance),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.filter, {\"serial\": data[\"filter-serial\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_filter_by_content_type(self):",
            "        \"\"\"",
            "        Test that filtering by `content_type` in the UI succeeds.",
            "",
            "        This is a regression test for https://github.com/nautobot/nautobot/issues/3612",
            "        \"\"\"",
            "        path = self._get_url(\"list\")",
            "        response = self.client.get(path + \"?content_type=dcim.device\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class ExportTemplateTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ExportTemplate",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Site)",
            "",
            "        templates = (",
            "            ExportTemplate(",
            "                name=\"template-1\",",
            "                template_code=\"template-1 test1\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-2\",",
            "                template_code=\"template-2 test2\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-3\",",
            "                template_code=\"template-3 test3\",",
            "                content_type=obj_type,",
            "            ),",
            "        )",
            "",
            "        for template in templates:",
            "            template.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"template-4\",",
            "            \"content_type\": obj_type.pk,",
            "            \"template_code\": \"template-4 test4\",",
            "        }",
            "",
            "",
            "class GitRepositoryTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkImportObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GitRepository",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\", slug=\"secrets-group-1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\", slug=\"secrets-group-2\"),",
            "        )",
            "",
            "        # Create four GitRepository records",
            "        repos = (",
            "            GitRepository(name=\"Repo 1\", slug=\"repo-1\", remote_url=\"https://example.com/repo1.git\"),",
            "            GitRepository(name=\"Repo 2\", slug=\"repo-2\", remote_url=\"https://example.com/repo2.git\"),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo-3\", remote_url=\"https://example.com/repo3.git\"),",
            "            GitRepository(name=\"Repo 4\", remote_url=\"https://example.com/repo4.git\", secrets_group=secrets_groups[0]),",
            "        )",
            "        for repo in repos:",
            "            repo.save(trigger_resync=False)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"A new Git repository\",",
            "            \"slug\": \"a-new-git-repository\",",
            "            \"remote_url\": \"http://example.com/a_new_git_repository.git\",",
            "            \"branch\": \"develop\",",
            "            \"_token\": \"1234567890abcdef1234567890abcdef\",",
            "            \"secrets_group\": secrets_groups[1].pk,",
            "            \"provided_contents\": [",
            "                \"extras.configcontext\",",
            "                \"extras.job\",",
            "                \"extras.exporttemplate\",",
            "            ],",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,remote_url,branch,secrets_group,provided_contents\",",
            "            \"Git Repository 5,git-repo-5,https://example.com,main,,extras.configcontext\",",
            "            \"Git Repository 6,git-repo-6,https://example.com,develop,Secrets Group 2,\",",
            "            'Git Repository 7,git-repo-7,https://example.com,next,Secrets Group 2,\"extras.job,extras.exporttemplate\"',",
            "        )",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Repo 4\"",
            "",
            "    def test_post_sync_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_sync_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_pull_git_repository_and_refresh_data` and test successful POST with permissions",
            "",
            "    def test_post_dryrun_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_dryrun_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"slug\": self._get_queryset().first().slug})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_git_repository_diff_origin_and_local` and test successful POST with permissions",
            "",
            "",
            "class NoteTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "):",
            "    model = Note",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Site)",
            "        cls.site = Site.objects.first()",
            "        user = User.objects.first()",
            "",
            "        # Notes Objects to test",
            "        Note.objects.create(",
            "            note=\"Site has been placed on maintenance.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.site.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site maintenance has ended.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.site.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Site is under duress.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.site.pk,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"note\": \"This is Site note.\",",
            "            \"assigned_object_type\": content_type.pk,",
            "            \"assigned_object_id\": cls.site.pk,",
            "        }",
            "        cls.expected_object_note = '<textarea name=\"object_note\" cols=\"40\" rows=\"10\" class=\"form-control\" placeholder=\"Note\" id=\"id_object_note\"></textarea>'",
            "",
            "    def test_note_on_bulk_update_perms(self):",
            "        self.add_permissions(\"dcim.add_site\", \"extras.add_note\")",
            "        response = self.client.get(reverse(\"dcim:site_add\"))",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_bulk_update_no_perms(self):",
            "        self.add_permissions(\"dcim.add_site\")",
            "        response = self.client.get(reverse(\"dcim:site_add\"))",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_perms(self):",
            "        self.add_permissions(\"dcim.change_site\", \"extras.add_note\")",
            "        response = self.client.post(reverse(\"dcim:site_bulk_edit\"), data={\"pk\": self.site.pk})",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_no_perms(self):",
            "        self.add_permissions(\"dcim.change_site\")",
            "        response = self.client.post(reverse(\"dcim:site_bulk_edit\"), data={\"pk\": self.site.pk})",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "",
            "# Not a full-fledged PrimaryObjectViewTestCase as there's no BulkEditView for Secrets",
            "class SecretTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkImportObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = Secret",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"View Test 1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_1\"},",
            "                tags=[t.pk for t in Tag.objects.get_for_model(Secret)],",
            "            ),",
            "            Secret(",
            "                name=\"View Test 2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"View Test 3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"View Test 4\",",
            "            \"slug\": \"view-test-4\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": '{\"variable\": \"VIEW_TEST_4\"}',",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,provider,parameters\",",
            "            'View Test 5,view-test-5,environment-variable,{\"variable\": \"VIEW_TEST_5\"}',",
            "            'View Test 6,,environment-variable,{\"variable\": \"VIEW_TEST_6\"}',",
            "            'View Test 7,,environment-variable,{\"variable\": \"VIEW_TEST_7\"}',",
            "        )",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"View Test 3\"",
            "",
            "",
            "# Not a full-fledged OrganizationalObjectViewTestCase as there's no BulkImportView for SecretsGroups",
            "class SecretsGroupTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = SecretsGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group 1\", slug=\"group-1\", description=\"First Group\"),",
            "            SecretsGroup.objects.create(name=\"Group 2\", slug=\"group-2\"),",
            "            SecretsGroup.objects.create(name=\"Group 3\", slug=\"group-3\"),",
            "        )",
            "",
            "        secrets = (",
            "            Secret.objects.create(name=\"secret 1\", slug=\"secret-1\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),",
            "            Secret.objects.create(name=\"secret 2\", slug=\"secret-2\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),",
            "            Secret.objects.create(name=\"secret 3\", slug=\"secret-3\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            group=secrets_groups[0],",
            "            secret=secrets[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            group=secrets_groups[0],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            group=secrets_groups[1],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Group 4\",",
            "            \"slug\": \"group-4\",",
            "            \"description\": \"Some description\",",
            "            # Management form fields required for the dynamic Secret formset",
            "            \"secretsgroupassociation_set-TOTAL_FORMS\": \"0\",",
            "            \"secretsgroupassociation_set-INITIAL_FORMS\": \"1\",",
            "            \"secretsgroupassociation_set-MIN_NUM_FORMS\": \"0\",",
            "            \"secretsgroupassociation_set-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Group 3\"",
            "",
            "",
            "class GraphQLQueriesTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GraphQLQuery",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                slug=\"graphql-query-1\",",
            "                query=\"{ query: sites {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                slug=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                slug=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"Graphql Query 5\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name slug } } }',",
            "            ),",
            "        )",
            "",
            "        for query in graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"graphql-query-4\",",
            "            \"slug\": \"graphql-query-4\",",
            "            \"query\": \"{query: sites {name}}\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Graphql Query 5\"",
            "",
            "",
            "#",
            "# Jobs, Scheduling, and Approvals",
            "#",
            "",
            "",
            "class ScheduledJobTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "    def test_only_enabled_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        # this should not appear, since it\u2019s not enabled",
            "        ScheduledJob.objects.create(",
            "            enabled=False,",
            "            name=\"test4\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    def test_non_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        def scheduled_job_factory(name, crontab):",
            "            ScheduledJob.objects.create(",
            "                enabled=True,",
            "                name=name,",
            "                task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "                job_class=\"local/test_pass/TestPass\",",
            "                interval=JobExecutionType.TYPE_CUSTOM,",
            "                user=self.user,",
            "                start_time=timezone.now(),",
            "                crontab=crontab,",
            "            )",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test5\", None)",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test6\", \"\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test7\", \"not_enough_values_to_unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test8\", \"one too many values to unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test9\", \"-1 * * * *\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test10\", \"invalid literal * * *\")",
            "",
            "    def test_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            enabled=True,",
            "            name=\"test11\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_class=\"local/test_pass/TestPass\",",
            "            interval=JobExecutionType.TYPE_CUSTOM,",
            "            user=self.user,",
            "            start_time=datetime.now(),",
            "            crontab=\"*/15 9,17 3 * 1-5\",",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(\"test11\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "",
            "class ApprovalQueueTestCase(",
            "    # It would be nice to use ViewTestCases.GetObjectViewTestCase as well,",
            "    # but we can't directly use it as it uses instance.get_absolute_url() rather than self._get_url(\"view\", instance)",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    # Many interactions with a ScheduledJob also require permissions to view the associated Job",
            "    user_permissions = (\"extras.view_job\",)",
            "",
            "    def _get_url(self, action, instance=None):",
            "        if action == \"list\":",
            "            return reverse(\"extras:scheduledjob_approval_queue_list\")",
            "        if action == \"view\" and instance is not None:",
            "            return reverse(\"extras:scheduledjob_approval_request_view\", kwargs={\"pk\": instance.pk})",
            "        raise ValueError(\"This override is only valid for list and view test cases\")",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job_model = Job.objects.get_for_class_path(\"local/test_pass/TestPass\")",
            "        self.job_model_2 = Job.objects.get_for_class_path(\"local/test_fail/TestFail\")",
            "        self.job_model_3 = Job.objects.get_for_class_path(\"local/test_read_only_pass/TestReadOnlyPass\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model,",
            "            job_class=self.job_model.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model_2,",
            "            job_class=self.job_model_2.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=datetime.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model_3,",
            "            job_class=self.job_model_3.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "    def test_only_approvable_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test4\",",
            "            task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "            job_model=self.job_model,",
            "            job_class=self.job_model.class_path,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=False,",
            "            start_time=datetime.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    #",
            "    # Reimplementations of ViewTestCases.GetObjectViewTestCase test functions.",
            "    # Needed because those use instance.get_absolute_url() instead of self._get_url(\"view\", instance)...",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_get_object_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_without_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        with disable_warnings(\"django.request\"):",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance)), 403)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        # Add model-level permission",
            "        obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET with model-level permission",
            "        response = self.client.get(self._get_url(\"view\", instance))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "",
            "        # The object's display name or string representation should appear in the response",
            "        self.assertIn(getattr(instance, \"display\", str(instance)), response_body, msg=response_body)",
            "",
            "        # skip GetObjectViewTestCase checks for Relationships and Custom Fields since this isn't actually a detail view",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_constrained_permission(self):",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "        # Add object-level permission",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": instance1.pk},",
            "            # To get a different rendering flow than the \"test_get_object_with_permission\" test above,",
            "            # enable additional permissions for this object so that interaction buttons are rendered.",
            "            actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET to permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance1)), 200)",
            "",
            "        # Try GET to non-permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance2)), 404)",
            "",
            "    #",
            "    # Additional test cases specific to the job approval view",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_anonymous(self):",
            "        \"\"\"Anonymous users may not take any action with regard to job approval requests.\"\"\"",
            "        self.client.logout()",
            "        response = self.client.post(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run jobs\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_not_runnable(self):",
            "        \"\"\"A non-enabled job cannot be dry-run.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"This job cannot be run at this time\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_job_run_permission(self):",
            "        \"\"\"A user without run_job permission cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_specific_job_run_permission(self):",
            "        \"\"\"A user without run_job permission FOR THAT SPECIFIC JOB cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "        data = {\"_dry_run\": True}",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance1.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        instance1.job_model.enabled = True",
            "        instance1.job_model.save()",
            "        instance2.job_model.enabled = True",
            "        instance2.job_model.save()",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance2), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_post_dry_run_success(self, _):",
            "        \"\"\"Successfully request a dry run based on object-based run_job permissions.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        # Job was submitted",
            "        self.assertEqual(",
            "            1, len(JobResult.objects.all()), msg=extract_page_body(response.content.decode(response.charset))",
            "        )",
            "        job_result = JobResult.objects.first()",
            "        self.assertEqual(job_result.job_model, instance.job_model)",
            "        self.assertEqual(job_result.user, self.user)",
            "        self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": job_result.pk}))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both delete_scheduledjob and approve_job permissions to deny a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 delete_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Delete\", actions=[\"delete\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not delete_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_deny\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Request was not deleted",
            "            self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can deny a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and delete_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"delete\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_deny\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Request was deleted",
            "        self.assertEqual(0, len(ScheduledJob.objects.filter(pk=instance.pk)))",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().first()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Request was not deleted",
            "        self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_cannot_self_approve(self):",
            "        self.add_permissions(\"extras.change_scheduledjob\")",
            "        self.add_permissions(\"extras.approve_job\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You cannot approve your own job request\", response_body)",
            "        # Job was not approved",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both change_scheduledjob and approve_job permissions to approve a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 change_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Change\", actions=[\"change\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not change_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Job was not approved",
            "            instance.refresh_from_db()",
            "            self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can approve a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and change_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"change\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_approve\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Job was scheduled",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.approved_by_user, user)",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().last()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Job was not scheduled",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "",
            "class JobResultTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = JobResult",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = get_job_content_type()",
            "        JobResult.objects.create(",
            "            name=\"local/test_pass/TestPass\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=obj_type,",
            "        )",
            "        JobResult.objects.create(",
            "            name=\"local/test_fail/TestFail\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=obj_type,",
            "        )",
            "        JobResult.objects.create(",
            "            name=\"local/test_read_only_fail/TestReadOnlyFail\",",
            "            job_id=uuid.uuid4(),",
            "            obj_type=obj_type,",
            "        )",
            "        JobLogEntry.objects.create(",
            "            log_level=LogLevelChoices.LOG_INFO,",
            "            job_result=JobResult.objects.first(),",
            "            grouping=\"run\",",
            "            message=\"This is a test\",",
            "        )",
            "",
            "    def test_get_joblogentrytable_anonymous(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_joblogentrytable_without_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_joblogentrytable_with_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.add_permissions(\"extras.view_jobresult\", \"extras.view_joblogentry\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"This is a test\", response_body)",
            "",
            "    # TODO test with constrained permissions on both JobResult and JobLogEntry records",
            "",
            "",
            "class JobTestCase(",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    \"\"\"",
            "    The Job view test cases.",
            "    \"\"\"",
            "",
            "    model = Job",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"Don't include hidden Jobs, non-installed Jobs, JobHookReceivers or JobButtonReceivers as they won't appear in the UI by default.\"\"\"",
            "        return self.model.objects.filter(",
            "            installed=True, hidden=False, is_job_hook_receiver=False, is_job_button_receiver=False",
            "        )",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Job model objects are automatically created during database migrations",
            "",
            "        # But we do need to make sure the ones we're testing are flagged appropriately",
            "        cls.test_pass = Job.objects.get(job_class_name=\"TestPass\")",
            "        cls.test_pass.enabled = True",
            "        cls.test_pass.save()",
            "",
            "        cls.run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job\", kwargs={\"class_path\": cls.test_pass.class_path}),",
            "            # Current URL (job model slug based)",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": cls.test_pass.slug}),",
            "        )",
            "",
            "        cls.test_required_args = Job.objects.get(job_class_name=\"TestRequired\")",
            "        cls.test_required_args.enabled = True",
            "        cls.test_required_args.save()",
            "",
            "        cls.extra_run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job\", kwargs={\"class_path\": cls.test_required_args.class_path}),",
            "            # Current URL (job model slug based)",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": cls.test_required_args.slug}),",
            "        )",
            "",
            "        # Create an entry for a non-installed Job as well",
            "        cls.test_not_installed = Job(",
            "            source=JobSourceChoices.SOURCE_LOCAL,",
            "            module_name=\"nonexistent\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Nonexistent Jobs\",",
            "            name=\"No such job\",",
            "            enabled=True,",
            "            installed=False,",
            "        )",
            "        cls.test_not_installed.validated_save()",
            "",
            "        cls.data_run_immediately = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "",
            "        cls.form_data = {",
            "            \"slug\": \"custom-job-slug\",",
            "            \"enabled\": True,",
            "            \"grouping_override\": True,",
            "            \"grouping\": \"Overridden Grouping\",",
            "            \"name_override\": True,",
            "            \"name\": \"Overridden Name\",",
            "            \"description_override\": True,",
            "            \"description\": \"This is an overridden description of a job.\",",
            "            \"commit_default_override\": True,",
            "            \"commit_default\": False,",
            "            \"hidden_override\": True,",
            "            \"hidden\": False,",
            "            \"read_only_override\": True,",
            "            \"read_only\": False,",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "            \"soft_time_limit_override\": True,",
            "            \"soft_time_limit\": 350,",
            "            \"time_limit_override\": True,",
            "            \"time_limit\": 650,",
            "            \"has_sensitive_variables\": False,",
            "            \"has_sensitive_variables_override\": True,",
            "            \"task_queues\": \"overridden,priority\",",
            "            \"task_queues_override\": True,",
            "        }",
            "",
            "    #",
            "    # Additional test cases for the \"job\" (legacy run) and \"job_run\" (updated run) views follow",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 403, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_permission(self):",
            "        \"\"\"",
            "        Get view with appropriate global permissions.",
            "",
            "        Note that this view is conditional on run_job permission, not view_job permission,",
            "        so EXEMPT_VIEW_PERMISSIONS=[\"*\"] does NOT apply here.",
            "        \"\"\"",
            "        self.add_permissions(\"extras.run_job\")",
            "        for run_url in self.run_urls:",
            "            response = self.client.get(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"TestPass\", response_body)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_constrained_permission(self):",
            "        \"\"\"Get view with appropriate object-based permissions.\"\"\"",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try GET with a permitted object",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 200, msg=run_url)",
            "",
            "        # Try GET with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 404, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url), 403, msg=run_url)",
            "",
            "    def test_run_missing_schedule(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_type: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=0)",
            "    def test_run_now_no_worker(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Celery worker process not running.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_constrained_permissions(self, _):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        # Try POST with a permitted object",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertIsNotNone(result, msg=run_url)",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "        # Try POST with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url, self.data_run_immediately), 404, msg=run_url)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_installed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job\", kwargs={\"class_path\": self.test_not_installed.class_path}),",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": self.test_not_installed.slug}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not presently installed\", response_body)",
            "",
            "            self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_enabled(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job\", kwargs={\"class_path\": \"local/test_fail/TestFail\"}),",
            "            reverse(\"extras:job_run\", kwargs={\"slug\": Job.objects.get(job_class_name=\"TestFail\").slug}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not enabled to be run\", response_body)",
            "",
            "            self.assertEqual(0, len(JobResult.objects.all()))",
            "",
            "    def test_run_now_missing_args(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"var: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_with_args(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"var\": \"12\",",
            "        }",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, data)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_name(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_name: Please provide a name for the job schedule.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_date(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_date_passed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(datetime.now() - timedelta(minutes=1)),",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertRedirects(response, reverse(\"extras:scheduledjob_list\"))",
            "",
            "            scheduled = ScheduledJob.objects.last()",
            "            self.assertEqual(scheduled.name, \"test\")",
            "            self.assertEqual(scheduled.start_time, start_time)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_sets_scheduled_job_kwargs_pk(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertRedirects(response, reverse(\"extras:scheduledjob_list\"))",
            "",
            "            scheduled = ScheduledJob.objects.last()",
            "            self.assertEqual(scheduled.kwargs[\"scheduled_job_pk\"], str(scheduled.pk))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_for_future(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.has_sensitive_variables_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Unable to schedule job: Job may have sensitive input variables.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_invalid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        self.test_pass.task_queues = []",
            "        self.test_pass.task_queues_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"_task_queue\": \"invalid\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [\"_task_queue: Select a valid choice. invalid is not one of the available choices.\"],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_and_requires_approval(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.approval_required = True",
            "        self.test_pass.save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "        for run_url in self.run_urls:",
            "            # Assert warning message shows in get",
            "            response = self.client.get(run_url)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\",",
            "                content,",
            "            )",
            "",
            "            # Assert run button is disabled",
            "            self.assertInHTML(",
            "                \"\"\"",
            "                <button type=\"submit\" name=\"_run\" id=\"id__run\" class=\"btn btn-primary\" disabled=\"disabled\">",
            "                    <i class=\"mdi mdi-play\"></i> Run Job Now",
            "                </button>",
            "                \"\"\",",
            "                content,",
            "            )",
            "            # Assert error message shows after post",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "                content,",
            "            )",
            "",
            "    def test_job_object_change_log_view(self):",
            "        \"\"\"Assert Job change log view displays appropriate header\"\"\"",
            "        instance = self.test_pass",
            "        self.add_permissions(\"extras.view_objectchange\", \"extras.view_job\")",
            "        response = self.client.get(instance.get_changelog_url())",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(f\"<h1>{instance.name} - Change Log</h1>\", content)",
            "",
            "",
            "class JobButtonTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobButton",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        job_buttons = (",
            "            JobButton.objects.create(",
            "                name=\"JobButton1\",",
            "                text=\"JobButton1\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=True,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton2\",",
            "                text=\"JobButton2\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=False,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton3\",",
            "                text=\"JobButton3\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "                confirmation=True,",
            "                weight=50,",
            "            ),",
            "        )",
            "",
            "        site_ct = ContentType.objects.get_for_model(Site)",
            "        for jb in job_buttons:",
            "            jb.content_types.set([site_ct])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [site_ct.pk],",
            "            \"name\": \"jobbutton-4\",",
            "            \"text\": \"jobbutton text 4\",",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"confirmation\": False,",
            "        }",
            "",
            "",
            "class JobButtonRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the rendering of JobButtons, distinct from tests of the JobButton views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job = Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\")",
            "        self.job_button_1 = JobButton(",
            "            name=\"JobButton 1\",",
            "            text=\"JobButton {{ obj.name }}\",",
            "            job=self.job,",
            "            confirmation=False,",
            "        )",
            "        self.job_button_1.validated_save()",
            "        self.job_button_1.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.job_button_2 = JobButton(",
            "            name=\"JobButton 2\",",
            "            text=\"Click me!\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            confirmation=False,",
            "        )",
            "        self.job_button_2.validated_save()",
            "        self.job_button_2.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_job_button(self):",
            "        \"\"\"Ensure that the job button is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"JobButton {self.location_type.name}\", content, content)",
            "        self.assertIn(\"Click me!\", content, content)",
            "",
            "    def test_task_queue_hidden_input_is_present(self):",
            "        \"\"\"",
            "        Ensure that the job button respects the job class' task_queues and the job class task_queues[0]/default is passed as a hidden form input.",
            "        \"\"\"",
            "        self.job.task_queues_override = True",
            "        self.job.task_queues = [\"overriden_queue\", \"default\", \"priority\"]",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f'<input type=\"hidden\" name=\"_task_queue\" value=\"{self.job.task_queues[0]}\">', content, content)",
            "        self.job.task_queues_override = False",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(",
            "            f'<input type=\"hidden\" name=\"_task_queue\" value=\"{settings.CELERY_TASK_DEFAULT_QUEUE}\">', content, content",
            "        )",
            "",
            "    def test_view_object_with_unsafe_text(self):",
            "        \"\"\"Ensure that JobButton text can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = '<script>alert(\"Hello world!\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "        # Make sure grouped rendering is safe too",
            "        self.job_button_1.group_name = '<script>alert(\"Goodbye\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_unsafe_name(self):",
            "        \"\"\"Ensure that JobButton names can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = \"JobButton {{ obj\"",
            "        self.job_button_1.name = '<script>alert(\"Yo\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_render_constrained_run_permissions(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.job_button_1.job.pk},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        with self.subTest(\"Ungrouped buttons\"):",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=self.job_button_1.button_class,",
            "                    disabled=\"\",",
            "                ),",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=self.job_button_2.button_class,",
            "                    disabled=\"disabled\",",
            "                ),",
            "                content,",
            "            )",
            "",
            "        with self.subTest(\"Grouped buttons\"):",
            "            self.job_button_1.group_name = \"Grouping\"",
            "            self.job_button_1.validated_save()",
            "            self.job_button_2.group_name = \"Grouping\"",
            "            self.job_button_2.validated_save()",
            "",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=\"link\",",
            "                    disabled=\"\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=\"link\",",
            "                    disabled=\"disabled\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "",
            "",
            "# TODO: Convert to StandardTestCases.Views",
            "class ObjectChangeTestCase(TestCase):",
            "    user_permissions = (\"extras.view_objectchange\",)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        site = Site(name=\"Site 1\", slug=\"site-1\")",
            "        site.save()",
            "",
            "        # Create three ObjectChanges",
            "        user = User.objects.create_user(username=\"testuser2\")",
            "        for _ in range(1, 4):",
            "            oc = site.to_objectchange(action=ObjectChangeActionChoices.ACTION_UPDATE)",
            "            oc.user = user",
            "            oc.request_id = uuid.uuid4()",
            "            oc.save()",
            "",
            "    def test_objectchange_list(self):",
            "        url = reverse(\"extras:objectchange_list\")",
            "        params = {",
            "            \"user\": User.objects.first().pk,",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_objectchange(self):",
            "        objectchange = ObjectChange.objects.first()",
            "        response = self.client.get(objectchange.get_absolute_url())",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class RelationshipTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    RequiredRelationshipTestMixin,",
            "):",
            "    model = Relationship",
            "    slug_source = \"name\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        interface_type = ContentType.objects.get_for_model(Interface)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "",
            "        Relationship(",
            "            name=\"Device VLANs\",",
            "            slug=\"device-vlans\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            name=\"Primary VLAN\",",
            "            slug=\"primary-vlan\",",
            "            type=\"one-to-many\",",
            "            source_type=vlan_type,",
            "            destination_type=device_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            name=\"Primary Interface\",",
            "            type=\"one-to-one\",",
            "            source_type=device_type,",
            "            destination_type=interface_type,",
            "        ).validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"VLAN-to-Interface\",",
            "            \"slug\": \"vlan-to-interface\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": vlan_type.pk,",
            "            \"source_label\": \"Interfaces\",",
            "            \"source_hidden\": False,",
            "            \"source_filter\": '{\"status\": [\"active\"]}',",
            "            \"destination_type\": interface_type.pk,",
            "            \"destination_label\": \"VLANs\",",
            "            \"destination_hidden\": True,",
            "            \"destination_filter\": None,",
            "        }",
            "",
            "        cls.slug_test_object = \"Primary Interface\"",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test bulk edit",
            "        \"\"\"",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"ui\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        vlans = VLANFactory.create_batch(6)",
            "",
            "        # Try deleting all devices and then editing the 6 VLANs (fails):",
            "        Device.objects.all().delete()",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(response, \"VLANs require at least one device, but no devices exist yet.\")",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "",
            "        # Try editing all 6 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "        # Try editing 3 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans[:3]], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"These VLANs require a device for the required \"",
            "            \"relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "        for vlan in vlans[:3]:",
            "            self.assertContains(response, f\"{str(vlan)}\")",
            "",
            "        # Try editing 6 VLANs and adding the required device (succeeds):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"add_cr_vlans-devices-m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertContains(response, \"Updated 6 VLANs\")",
            "",
            "        # Try editing 6 VLANs and removing the required device (fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"remove_cr_vlans-devices-m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "",
            "class RelationshipAssociationTestCase(",
            "    # TODO? ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    # TODO? ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # TODO? ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = RelationshipAssociation",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "",
            "        relationship = Relationship(",
            "            name=\"Device VLANs\",",
            "            slug=\"device-vlans\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        relationship.validated_save()",
            "        manufacturer = Manufacturer.objects.create(name=\"Manufacturer 1\", slug=\"manufacturer-1\")",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\", slug=\"device-type-1\")",
            "        devicerole = DeviceRole.objects.create(name=\"Device Role 1\", slug=\"device-role-1\")",
            "        site = Site.objects.first()",
            "        devices = (",
            "            Device.objects.create(name=\"Device 1\", device_type=devicetype, device_role=devicerole, site=site),",
            "            Device.objects.create(name=\"Device 2\", device_type=devicetype, device_role=devicerole, site=site),",
            "            Device.objects.create(name=\"Device 3\", device_type=devicetype, device_role=devicerole, site=site),",
            "        )",
            "        vlans = (",
            "            VLAN.objects.create(vid=1, name=\"VLAN 1\"),",
            "            VLAN.objects.create(vid=2, name=\"VLAN 2\"),",
            "            VLAN.objects.create(vid=3, name=\"VLAN 3\"),",
            "        )",
            "",
            "        RelationshipAssociation(",
            "            relationship=relationship,",
            "            source_type=device_type,",
            "            source_id=devices[0].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[0].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship,",
            "            source_type=device_type,",
            "            source_id=devices[1].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[1].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship,",
            "            source_type=device_type,",
            "            source_id=devices[2].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[2].pk,",
            "        ).validated_save()",
            "",
            "",
            "class StatusTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Status",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Status objects to test.",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_status\",",
            "            \"slug\": \"new-status\",",
            "            \"description\": \"I am a new status object.\",",
            "            \"color\": \"ffcc00\",",
            "            \"content_types\": [content_type.pk],",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,color,content_types\"",
            "            'test_status1,test-status1,ffffff,\"dcim.device\"'",
            "            'test_status2,test-status2,ffffff,\"dcim.device,dcim.rack\"'",
            "            'test_status3,test-status3,ffffff,\"dcim.device,dcim.site\"'",
            "            'test_status4,,ffffff,\"dcim.device,dcim.site\"'",
            "        )",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"000000\",",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = Status.objects.first().name",
            "",
            "",
            "class TagTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = Tag",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"Tag X\",",
            "            \"slug\": \"tag-x\",",
            "            \"color\": \"c0c0c0\",",
            "            \"comments\": \"Some comments\",",
            "            \"content_types\": [ct.id for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "",
            "        cls.csv_data = (",
            "            \"name,slug,color,description\",",
            "            \"Tag 4,tag-4,ff0000,Fourth tag\",",
            "            \"Tag 5,tag-5,00ff00,Fifth tag\",",
            "            \"Tag 6,tag-6,0000ff,Sixth tag\",",
            "        )",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"00ff00\",",
            "        }",
            "",
            "    def test_create_tags_with_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        site_content_type = ContentType.objects.get_for_model(Site)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [site_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        tag = Tag.objects.filter(slug=self.form_data[\"slug\"])",
            "        self.assertTrue(tag.exists())",
            "        self.assertEqual(tag[0].content_types.first(), site_content_type)",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        vlangroup_content_type = ContentType.objects.get_for_model(VLANGroup)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [vlangroup_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        tag = Tag.objects.filter(slug=self.form_data[\"slug\"])",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(\"content_types: Select a valid choice\", str(response.content))",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.get_for_model(Site).first()",
            "        site = Site.objects.first()",
            "        site.tags.add(tag_1)",
            "",
            "        form_data = {",
            "            \"name\": tag_1.name,",
            "            \"slug\": tag_1.slug,",
            "            \"color\": \"c0c0c0\",",
            "            \"content_types\": [ContentType.objects.get_for_model(Device).id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", tag_1),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        self.assertHttpStatus(",
            "            response, 200, [\"content_types: Unable to remove dcim.site. Dependent objects were found.\"]",
            "        )",
            "",
            "",
            "class WebhookTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Webhook",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        webhooks = (",
            "            Webhook(",
            "                name=\"webhook-1\",",
            "                enabled=True,",
            "                type_create=True,",
            "                payload_url=\"http://test-url.com/test-1\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-2\",",
            "                enabled=True,",
            "                type_update=True,",
            "                payload_url=\"http://test-url.com/test-2\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-3\",",
            "                enabled=True,",
            "                type_delete=True,",
            "                payload_url=\"http://test-url.com/test-3\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(ConsolePort)",
            "",
            "        for webhook in webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"name\": \"webhook-4\",",
            "            \"content_types\": [obj_type.pk],",
            "            \"enabled\": True,",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://test-url.com/test-4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "        }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "617": [
                "DynamicGroupTestCase",
                "setUpTestData"
            ],
            "618": [
                "DynamicGroupTestCase",
                "setUpTestData"
            ],
            "619": [
                "DynamicGroupTestCase",
                "setUpTestData"
            ],
            "663": [
                "DynamicGroupTestCase",
                "test_get_object_dynamic_groups_with_constrained_permission"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 550,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "         if table_class is not None:"
            },
            "2": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 552,
                "PatchRowcode": "             # Members table (for display on Members nav tab)"
            },
            "3": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            members_table = table_class(instance.members, orderable=False)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 553,
                "PatchRowcode": "+            members_table = table_class(instance.members.restrict(request.user, \"view\"), orderable=False)"
            },
            "5": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": 554,
                "PatchRowcode": "             paginate = {"
            },
            "6": {
                "beforePatchRowNumber": 555,
                "afterPatchRowNumber": 555,
                "PatchRowcode": "                 \"paginator_class\": EnhancedPaginator,"
            },
            "7": {
                "beforePatchRowNumber": 556,
                "afterPatchRowNumber": 556,
                "PatchRowcode": "                 \"per_page\": get_paginate_count(request),"
            },
            "8": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": 722,
                "PatchRowcode": "             obj = get_object_or_404(model, **kwargs)"
            },
            "9": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": 723,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": 724,
                "PatchRowcode": "         # Gather all dynamic groups for this object (and its related objects)"
            },
            "11": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        dynamicsgroups_table = tables.DynamicGroupTable(data=obj.dynamic_groups_cached, orderable=False)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 725,
                "PatchRowcode": "+        dynamicsgroups_table = tables.DynamicGroupTable("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 726,
                "PatchRowcode": "+            data=obj.dynamic_groups_cached.restrict(request.user, \"view\"), orderable=False"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 727,
                "PatchRowcode": "+        )"
            },
            "15": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 728,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 729,
                "PatchRowcode": "         # Apply the request context"
            },
            "17": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 730,
                "PatchRowcode": "         paginate = {"
            }
        },
        "frontPatchFile": [
            "import inspect",
            "from datetime import timedelta",
            "import logging",
            "",
            "from celery import chain",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.db import transaction",
            "from django.db.models import ProtectedError, Q",
            "from django.forms.utils import pretty_name",
            "from django.http import Http404, HttpResponse, HttpResponseForbidden",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.encoding import iri_to_uri",
            "from django.utils.html import format_html",
            "from django.utils.http import is_safe_url, url_has_allowed_host_and_scheme",
            "from django.views.generic import View",
            "from django.template.loader import get_template, TemplateDoesNotExist",
            "from django_tables2 import RequestConfig",
            "from jsonschema.validators import Draft7Validator",
            "",
            "from nautobot.core.views import generic",
            "from nautobot.core.views.viewsets import NautobotUIViewSet",
            "from nautobot.dcim.models import Device",
            "from nautobot.dcim.tables import DeviceTable",
            "from nautobot.extras.tasks import delete_custom_field_data",
            "from nautobot.extras.utils import get_base_template, get_job_content_type, get_worker_count",
            "from nautobot.utilities.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.utilities.forms import restrict_form_fields",
            "from nautobot.utilities.utils import (",
            "    copy_safe_request,",
            "    count_related,",
            "    csv_format,",
            "    get_table_for_model,",
            "    prepare_cloned_fields,",
            "    pretty_print_query,",
            ")",
            "from nautobot.utilities.tables import ButtonsColumn",
            "from nautobot.utilities.views import ObjectPermissionRequiredMixin",
            "from nautobot.utilities.utils import normalize_querydict",
            "from nautobot.virtualization.models import VirtualMachine",
            "from nautobot.virtualization.tables import VirtualMachineTable",
            "from . import filters, forms, tables",
            "from .api import serializers",
            "from .choices import JobExecutionType, JobResultStatusChoices",
            "from .datasources import (",
            "    enqueue_git_repository_diff_origin_and_local,",
            "    enqueue_pull_git_repository_and_refresh_data,",
            "    get_datasource_contents,",
            ")",
            "from .jobs import get_job, run_job, Job as JobClass",
            "from .models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job as JobModel,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    ObjectChange,",
            "    JobResult,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Webhook,",
            "    Note,",
            ")",
            "from .registry import registry",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldListView(generic.ObjectListView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "    filterset = filters.ComputedFieldFilterSet",
            "    filterset_form = forms.ComputedFieldFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ComputedFieldView(generic.ObjectView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldEditView(generic.ObjectEditView):",
            "    queryset = ComputedField.objects.all()",
            "    model_form = forms.ComputedFieldForm",
            "    template_name = \"extras/computedfield_edit.html\"",
            "",
            "",
            "class ComputedFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config contexts that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextListView(generic.ObjectListView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    filterset_form = forms.ConfigContextFilterForm",
            "    table = tables.ConfigContextTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextView(generic.ObjectView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"format\": format_,",
            "        }",
            "",
            "",
            "class ConfigContextEditView(generic.ObjectEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    model_form = forms.ConfigContextForm",
            "    template_name = \"extras/configcontext_edit.html\"",
            "",
            "",
            "class ConfigContextBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    table = tables.ConfigContextTable",
            "    form = forms.ConfigContextBulkEditForm",
            "",
            "",
            "class ConfigContextDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "",
            "class ConfigContextBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "    table = tables.ConfigContextTable",
            "",
            "",
            "class ObjectConfigContextView(generic.ObjectView):",
            "    base_template = None",
            "    template_name = \"extras/object_configcontext.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        source_contexts = ConfigContext.objects.restrict(request.user, \"view\").get_for_object(instance)",
            "",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"rendered_context\": instance.get_config_context(),",
            "            \"source_contexts\": source_contexts,",
            "            \"format\": format_,",
            "            \"base_template\": self.base_template,",
            "            \"active_tab\": \"config-context\",",
            "        }",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config context schemas that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextSchemaListView(generic.ObjectListView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    filterset_form = forms.ConfigContextSchemaFilterForm",
            "    table = tables.ConfigContextSchemaTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextSchemaView(generic.ObjectView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontextschema.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontextschema.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"format\": format_,",
            "        }",
            "",
            "",
            "class ConfigContextSchemaObjectValidationView(generic.ObjectView):",
            "    \"\"\"",
            "    This view renders a detail tab that shows tables of objects that utilize the given schema object",
            "    and their validation state.",
            "    \"\"\"",
            "",
            "    queryset = ConfigContextSchema.objects.all()",
            "    template_name = \"extras/configcontextschema_validation.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Reuse the model tables for config context, device, and virtual machine but inject",
            "        the `ConfigContextSchemaValidationStateColumn` and an object edit action button.",
            "        \"\"\"",
            "        # Prep the validator with the schema so it can be reused for all records",
            "        validator = Draft7Validator(instance.data_schema)",
            "",
            "        # Config context table",
            "        config_context_table = tables.ConfigContextTable(",
            "            data=instance.configcontext_set.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=ConfigContext, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(config_context_table)",
            "",
            "        # Device table",
            "        device_table = DeviceTable(",
            "            data=instance.device_set.select_related(",
            "                \"tenant\",",
            "                \"site\",",
            "                \"rack\",",
            "                \"device_type\",",
            "                \"device_role\",",
            "            ).prefetch_related(\"primary_ip\"),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"local_context_data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=Device, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        # Virtual machine table",
            "        virtual_machine_table = VirtualMachineTable(",
            "            data=instance.virtualmachine_set.select_related(",
            "                \"cluster\",",
            "                \"role\",",
            "                \"tenant\",",
            "            ).prefetch_related(\"primary_ip\"),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"local_context_data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=VirtualMachine, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(virtual_machine_table)",
            "",
            "        return {",
            "            \"config_context_table\": config_context_table,",
            "            \"device_table\": device_table,",
            "            \"virtual_machine_table\": virtual_machine_table,",
            "            \"active_tab\": \"validation\",",
            "        }",
            "",
            "",
            "class ConfigContextSchemaEditView(generic.ObjectEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    model_form = forms.ConfigContextSchemaForm",
            "    template_name = \"extras/configcontextschema_edit.html\"",
            "",
            "",
            "class ConfigContextSchemaBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    table = tables.ConfigContextSchemaTable",
            "    form = forms.ConfigContextSchemaBulkEditForm",
            "",
            "",
            "class ConfigContextSchemaDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "",
            "class ConfigContextSchemaBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    table = tables.ConfigContextSchemaTable",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "class CustomFieldListView(generic.ObjectListView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "    filterset = filters.CustomFieldFilterSet",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomFieldView(generic.ObjectView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldEditView(generic.ObjectEditView):",
            "    queryset = CustomField.objects.all()",
            "    model_form = forms.CustomFieldForm",
            "    template_name = \"extras/customfield_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # ---> BEGIN difference from ObjectEditView.post()",
            "                    # Process the formsets for choices",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    choices = ctx[\"choices\"]",
            "                    if choices.is_valid():",
            "                        choices.save()",
            "                    else:",
            "                        raise RuntimeError(choices.errors)",
            "                    # <--- END difference from ObjectEditView.post()",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                else:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # ---> BEGIN difference from ObjectEditView.post()",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving custom field choices. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # <--- END difference from ObjectEditView.post()",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class CustomFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "",
            "    def construct_custom_field_delete_tasks(self, queryset):",
            "        \"\"\"",
            "        Helper method to construct a list of celery tasks to execute when bulk deleting custom fields.",
            "        \"\"\"",
            "        tasks = [",
            "            # 2.0 TODO: #824 use obj.slug instead of obj.name",
            "            delete_custom_field_data.si(obj.name, set(obj.content_types.values_list(\"pk\", flat=True)))",
            "            for obj in queryset",
            "        ]",
            "        return tasks",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        \"\"\"",
            "        Remove all Custom Field Keys/Values from _custom_field_data of the related ContentType in the background.",
            "        \"\"\"",
            "        if not get_worker_count():",
            "            messages.error(",
            "                request, \"Celery worker process not running. Object custom fields may fail to reflect this deletion.\"",
            "            )",
            "            return",
            "        tasks = self.construct_custom_field_delete_tasks(queryset)",
            "        # Executing the tasks in the background sequentially using chain() aligns with how a single",
            "        # CustomField object is deleted.  We decided to not check the result because it needs at least one worker",
            "        # to be active and comes with extra performance penalty.",
            "        chain(*tasks).apply_async()",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkListView(generic.ObjectListView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "    filterset = filters.CustomLinkFilterSet",
            "    filterset_form = forms.CustomLinkFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomLinkView(generic.ObjectView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkEditView(generic.ObjectEditView):",
            "    queryset = CustomLink.objects.all()",
            "    model_form = forms.CustomLinkForm",
            "",
            "",
            "class CustomLinkDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupListView(generic.ObjectListView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "    filterset = filters.DynamicGroupFilterSet",
            "    filterset_form = forms.DynamicGroupFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class DynamicGroupView(generic.ObjectView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        model = instance.content_type.model_class()",
            "        table_class = get_table_for_model(model)",
            "",
            "        if table_class is not None:",
            "            # Members table (for display on Members nav tab)",
            "            members_table = table_class(instance.members, orderable=False)",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(members_table)",
            "",
            "            # Descendants table",
            "            descendants_memberships = instance.membership_tree()",
            "            descendants_table = tables.NestedDynamicGroupDescendantsTable(",
            "                descendants_memberships,",
            "                orderable=False,",
            "            )",
            "            descendants_tree = {m.pk: m.depth for m in descendants_memberships}",
            "",
            "            # Ancestors table",
            "            ancestors = instance.get_ancestors()",
            "            ancestors_table = tables.NestedDynamicGroupAncestorsTable(ancestors, orderable=False)",
            "            ancestors_tree = instance.flatten_ancestors_tree(instance.ancestors_tree())",
            "",
            "            context[\"raw_query\"] = pretty_print_query(instance.generate_query())",
            "            context[\"members_table\"] = members_table",
            "            context[\"ancestors_table\"] = ancestors_table",
            "            context[\"ancestors_tree\"] = ancestors_tree",
            "            context[\"descendants_table\"] = descendants_table",
            "            context[\"descendants_tree\"] = descendants_tree",
            "",
            "        return context",
            "",
            "",
            "class DynamicGroupEditView(generic.ObjectEditView):",
            "    queryset = DynamicGroup.objects.all()",
            "    model_form = forms.DynamicGroupForm",
            "    template_name = \"extras/dynamicgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        filterform_class = instance.generate_filter_form()",
            "",
            "        if filterform_class is None:",
            "            filter_form = None",
            "        elif request.POST:",
            "            filter_form = filterform_class(data=request.POST)",
            "        else:",
            "            initial = instance.get_initial()",
            "            filter_form = filterform_class(initial=initial)",
            "",
            "        ctx[\"filter_form\"] = filter_form",
            "",
            "        formset_kwargs = {\"instance\": instance}",
            "        if request.POST:",
            "            formset_kwargs[\"data\"] = request.POST",
            "",
            "        ctx[\"children\"] = forms.DynamicGroupMembershipFormSet(**formset_kwargs)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    # Obtain the instance, but do not yet `save()` it to the database.",
            "                    obj = form.save(commit=False)",
            "",
            "                    # Process the filter form and save the query filters to `obj.filter`.",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    filter_form = ctx[\"filter_form\"]",
            "                    if filter_form.is_valid():",
            "                        obj.set_filter(filter_form.cleaned_data)",
            "                    else:",
            "                        raise RuntimeError(filter_form.errors)",
            "",
            "                    # After filters have been set, now we save the object to the database.",
            "                    obj.save()",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for children",
            "                    children = ctx[\"children\"]",
            "                    if children.is_valid():",
            "                        children.save()",
            "                    else:",
            "                        raise RuntimeError(children.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                else:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving Dynamic Group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a something that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class DynamicGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "",
            "class DynamicGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "",
            "",
            "class ObjectDynamicGroupsView(generic.GenericView):",
            "    \"\"\"",
            "    Present a list of dynamic groups associated to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all dynamic groups for this object (and its related objects)",
            "        dynamicsgroups_table = tables.DynamicGroupTable(data=obj.dynamic_groups_cached, orderable=False)",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(dynamicsgroups_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_dynamicgroups.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": dynamicsgroups_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"dynamic-groups\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateListView(generic.ObjectListView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "    filterset = filters.ExportTemplateFilterSet",
            "    filterset_form = forms.ExportTemplateFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ExportTemplateView(generic.ObjectView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateEditView(generic.ObjectEditView):",
            "    queryset = ExportTemplate.objects.all()",
            "    model_form = forms.ExportTemplateForm",
            "",
            "",
            "class ExportTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryListView(generic.ObjectListView):",
            "    queryset = GitRepository.objects.all()",
            "    filterset = filters.GitRepositoryFilterSet",
            "    filterset_form = forms.GitRepositoryFilterForm",
            "    table = tables.GitRepositoryTable",
            "    template_name = \"extras/gitrepository_list.html\"",
            "",
            "    def extra_context(self):",
            "        git_repository_content_type = ContentType.objects.get(app_label=\"extras\", model=\"gitrepository\")",
            "        # Get the newest results for each repository name",
            "        results = {",
            "            r.name: r",
            "            for r in JobResult.objects.filter(",
            "                obj_type=git_repository_content_type,",
            "                status__in=JobResultStatusChoices.TERMINAL_STATE_CHOICES,",
            "            )",
            "            .order_by(\"completed\")",
            "            .defer(\"data\")",
            "        }",
            "        return {",
            "            \"job_results\": results,",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryView(generic.ObjectView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryEditView(generic.ObjectEditView):",
            "    queryset = GitRepository.objects.all()",
            "    model_form = forms.GitRepositoryForm",
            "    template_name = \"extras/gitrepository_object_edit.html\"",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.request = request",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def get_return_url(self, request, obj):",
            "        if request.method == \"POST\":",
            "            return reverse(\"extras:gitrepository_result\", kwargs={\"slug\": obj.slug})",
            "        return super().get_return_url(request, obj)",
            "",
            "",
            "class GitRepositoryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "",
            "class GitRepositoryBulkImportView(generic.BulkImportView):",
            "    queryset = GitRepository.objects.all()",
            "    model_form = forms.GitRepositoryCSVForm",
            "    table = tables.GitRepositoryBulkTable",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        \"\"\"Each GitRepository needs to know the originating request when it's saved so that it can enqueue using it.\"\"\"",
            "        instance = obj_form.save(commit=False)",
            "        instance.request = request",
            "        instance.save()",
            "",
            "        return instance",
            "",
            "",
            "class GitRepositoryBulkEditView(generic.BulkEditView):",
            "    queryset = GitRepository.objects.select_related(\"secrets_group\")",
            "    filterset = filters.GitRepositoryFilterSet",
            "    table = tables.GitRepositoryBulkTable",
            "    form = forms.GitRepositoryBulkEditForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.request = request",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "    table = tables.GitRepositoryBulkTable",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "def check_and_call_git_repository_function(request, slug, func):",
            "    \"\"\"Helper for checking Git permissions and worker availability, then calling provided function if all is well",
            "    Args:",
            "        request: request object.",
            "        slug (str): GitRepository slug value.",
            "        func (function): Enqueue git repo function.",
            "    Returns:",
            "        HttpResponseForbidden or a redirect",
            "    \"\"\"",
            "    if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "        return HttpResponseForbidden()",
            "",
            "    # Allow execution only if a worker process is running.",
            "    if not get_worker_count():",
            "        messages.error(request, \"Unable to run job: Celery worker process not running.\")",
            "    else:",
            "        repository = get_object_or_404(GitRepository.objects.restrict(request.user, \"change\"), slug=slug)",
            "        func(repository, request)",
            "",
            "    return redirect(\"extras:gitrepository_result\", slug=slug)",
            "",
            "",
            "class GitRepositorySyncView(generic.GenericView):",
            "    def post(self, request, slug):",
            "        return check_and_call_git_repository_function(request, slug, enqueue_pull_git_repository_and_refresh_data)",
            "",
            "",
            "class GitRepositoryDryRunView(generic.GenericView):",
            "    def post(self, request, slug):",
            "        return check_and_call_git_repository_function(request, slug, enqueue_git_repository_diff_origin_and_local)",
            "",
            "",
            "class GitRepositoryResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    template_name = \"extras/gitrepository_result.html\"",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.view_gitrepository\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        git_repository_content_type = ContentType.objects.get(app_label=\"extras\", model=\"gitrepository\")",
            "        job_result = (",
            "            JobResult.objects.filter(obj_type=git_repository_content_type, name=instance.name)",
            "            .order_by(\"-created\")",
            "            .first()",
            "        )",
            "",
            "        return {",
            "            \"result\": job_result,",
            "            \"base_template\": \"extras/gitrepository.html\",",
            "            \"object\": instance,",
            "            \"active_tab\": \"result\",",
            "        }",
            "",
            "",
            "#",
            "# Saved GraphQL queries",
            "#",
            "",
            "",
            "class GraphQLQueryListView(generic.ObjectListView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "    filterset = filters.GraphQLQueryFilterSet",
            "    filterset_form = forms.GraphQLQueryFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class GraphQLQueryView(generic.ObjectView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryEditView(generic.ObjectEditView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    model_form = forms.GraphQLQueryForm",
            "",
            "",
            "class GraphQLQueryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentEditView(generic.ObjectEditView):",
            "    \"\"\"",
            "    View for creating and editing ImageAttachments.",
            "",
            "    Note that a URL kwargs parameter of \"pk\" identifies an existing ImageAttachment to edit,",
            "    while kwargs of \"object_id\" or \"slug\" identify the parent model instance to attach an ImageAttachment to.",
            "    \"\"\"",
            "",
            "    queryset = ImageAttachment.objects.all()",
            "    model_form = forms.ImageAttachmentForm",
            "",
            "    def get_object(self, kwargs):",
            "        if \"pk\" in kwargs:",
            "            return get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        return self.queryset.model()",
            "",
            "    def alter_obj(self, imageattachment, request, args, kwargs):",
            "        if not imageattachment.present_in_database:",
            "            # Assign the parent object based on URL kwargs",
            "            model = kwargs.get(\"model\")",
            "            if \"object_id\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, pk=kwargs[\"object_id\"])",
            "            elif \"slug\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, slug=kwargs[\"slug\"])",
            "            else:",
            "                raise RuntimeError(\"Neither object_id nor slug were provided?\")",
            "        return imageattachment",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "class ImageAttachmentDeleteView(generic.ObjectDeleteView):",
            "    queryset = ImageAttachment.objects.all()",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobListView(generic.ObjectListView):",
            "    \"\"\"",
            "    Retrieve all of the available jobs from disk and the recorded JobResult (if any) for each.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "    table = tables.JobTable",
            "    filterset = filters.JobFilterSet",
            "    filterset_form = forms.JobFilterForm",
            "    action_buttons = ()",
            "    template_name = \"extras/job_list.html\"",
            "",
            "    def alter_queryset(self, request):",
            "        queryset = super().alter_queryset(request)",
            "        # Default to hiding \"hidden\", non-installed jobs and job hook receivers",
            "        if \"hidden\" not in request.GET:",
            "            queryset = queryset.filter(hidden=False)",
            "        if \"installed\" not in request.GET:",
            "            queryset = queryset.filter(installed=True)",
            "        if \"is_job_hook_receiver\" not in request.GET:",
            "            queryset = queryset.filter(is_job_hook_receiver=False)",
            "        if \"is_job_button_receiver\" not in request.GET:",
            "            queryset = queryset.filter(is_job_button_receiver=False)",
            "        queryset = queryset.prefetch_related(\"results\")",
            "        return queryset",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"table_inc_template\": \"extras/inc/job_table.html\",",
            "        }",
            "",
            "",
            "# 2.0 TODO: this should really be \"JobRunView\"",
            "class JobView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    View the parameters of a Job and enqueue it if desired.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.run_job\"",
            "",
            "    def _get_job_model_or_404(self, class_path=None, slug=None):",
            "        \"\"\"Helper function for get() and post().\"\"\"",
            "        if class_path:",
            "            try:",
            "                job_model = self.queryset.get_for_class_path(class_path)",
            "            except JobModel.DoesNotExist:",
            "                raise Http404",
            "        else:",
            "            job_model = get_object_or_404(self.queryset, slug=slug)",
            "",
            "        return job_model",
            "",
            "    def get(self, request, class_path=None, slug=None):",
            "        job_model = self._get_job_model_or_404(class_path, slug)",
            "",
            "        try:",
            "            job_class = job_model.job_class()",
            "            initial = normalize_querydict(request.GET, form_class=job_class.as_form_class())",
            "            if \"kwargs_from_job_result\" in initial:",
            "                job_result_pk = initial.pop(\"kwargs_from_job_result\")",
            "                try:",
            "                    job_result = job_model.results.get(pk=job_result_pk)",
            "                    # Allow explicitly specified arg values in request.GET to take precedence over the saved job_kwargs,",
            "                    # for example \"?kwargs_from_job_result=<UUID>&integervar=22&_commit=False\"",
            "                    explicit_initial = initial",
            "                    initial = job_result.job_kwargs.get(\"data\", {}).copy()",
            "                    commit = job_result.job_kwargs.get(\"commit\")",
            "                    if commit is not None:",
            "                        initial.setdefault(\"_commit\", commit)",
            "                    task_queue = job_result.job_kwargs.get(\"task_queue\")",
            "                    if task_queue is not None:",
            "                        initial.setdefault(\"_task_queue\", task_queue)",
            "                    initial.update(explicit_initial)",
            "                except JobResult.DoesNotExist:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"JobResult {job_result_pk} not found, cannot use it to pre-populate inputs.\",",
            "                    )",
            "",
            "            template_name = \"extras/job.html\"",
            "            job_form = job_class.as_form(initial=initial)",
            "            if hasattr(job_class, \"template_name\"):",
            "                try:",
            "                    get_template(job_class.template_name)",
            "                    template_name = job_class.template_name",
            "                except TemplateDoesNotExist as err:",
            "                    messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "        except RuntimeError as err:",
            "            messages.error(request, f\"Unable to run or schedule '{job_model}': {err}\")",
            "            return redirect(\"extras:job_list\")",
            "",
            "        schedule_form = forms.JobScheduleForm(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            template_name,  # 2.0 TODO: extras/job_submission.html",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "    def post(self, request, class_path=None, slug=None):",
            "        job_model = self._get_job_model_or_404(class_path, slug)",
            "",
            "        job_form = (",
            "            job_model.job_class().as_form(request.POST, request.FILES) if job_model.job_class is not None else None",
            "        )",
            "        schedule_form = forms.JobScheduleForm(request.POST)",
            "        task_queue = request.POST.get(\"_task_queue\")",
            "",
            "        return_url = request.POST.get(\"_return_url\")",
            "        if return_url is not None and url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "            return_url = iri_to_uri(return_url)",
            "        else:",
            "            return_url = None",
            "",
            "        # Allow execution only if a worker process is running and the job is runnable.",
            "        if not get_worker_count(queue=task_queue):",
            "            messages.error(request, \"Unable to run or schedule job: Celery worker process not running.\")",
            "        elif not job_model.installed or job_model.job_class is None:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not presently installed.\")",
            "        elif not job_model.enabled:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not enabled to be run.\")",
            "        elif (",
            "            job_model.has_sensitive_variables",
            "            and request.POST.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY",
            "        ):",
            "            messages.error(request, \"Unable to schedule job: Job may have sensitive input variables.\")",
            "        elif job_model.has_sensitive_variables and job_model.approval_required:",
            "            messages.error(",
            "                request,",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "            )",
            "        elif job_form is not None and job_form.is_valid() and schedule_form.is_valid():",
            "            # Run the job. A new JobResult is created.",
            "            commit = job_form.cleaned_data.pop(\"_commit\")",
            "            profile = job_form.cleaned_data.pop(\"_profile\")",
            "            schedule_type = schedule_form.cleaned_data[\"_schedule_type\"]",
            "",
            "            if job_model.approval_required or schedule_type in JobExecutionType.SCHEDULE_CHOICES:",
            "                crontab = \"\"",
            "",
            "                if schedule_type == JobExecutionType.TYPE_IMMEDIATELY:",
            "                    # The job must be approved.",
            "                    # If the schedule_type is immediate, we still create the task, but mark it for approval",
            "                    # as a once in the future task with the due date set to the current time. This means",
            "                    # when approval is granted, the task is immediately due for execution.",
            "                    schedule_type = JobExecutionType.TYPE_FUTURE",
            "                    schedule_datetime = timezone.now()",
            "                    schedule_name = f\"{job_model} - {schedule_datetime}\"",
            "",
            "                else:",
            "                    schedule_name = schedule_form.cleaned_data[\"_schedule_name\"]",
            "",
            "                    if schedule_type == JobExecutionType.TYPE_CUSTOM:",
            "                        crontab = schedule_form.cleaned_data[\"_recurrence_custom_time\"]",
            "                        # doing .get(\"key\", \"default\") returns None instead of \"default\" here for some reason",
            "                        schedule_datetime = schedule_form.cleaned_data.get(\"_schedule_start_time\")",
            "                        if schedule_datetime is None:",
            "                            # \"_schedule_start_time\" is checked against ScheduledJob.earliest_possible_time()",
            "                            # which returns timezone.now() + timedelta(seconds=15)",
            "                            schedule_datetime = timezone.now() + timedelta(seconds=20)",
            "                    else:",
            "                        schedule_datetime = schedule_form.cleaned_data[\"_schedule_start_time\"]",
            "",
            "                job_kwargs = {",
            "                    \"data\": job_model.job_class.serialize_data(job_form.cleaned_data),",
            "                    \"request\": copy_safe_request(request),",
            "                    \"user\": request.user.pk,",
            "                    \"commit\": commit,",
            "                    \"name\": job_model.class_path,",
            "                    \"task_queue\": job_form.cleaned_data.get(\"_task_queue\", None),",
            "                }",
            "                if task_queue:",
            "                    job_kwargs[\"celery_kwargs\"] = {\"queue\": task_queue}",
            "",
            "                scheduled_job = ScheduledJob(",
            "                    name=schedule_name,",
            "                    task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "                    job_class=job_model.class_path,",
            "                    job_model=job_model,",
            "                    start_time=schedule_datetime,",
            "                    description=f\"Nautobot job {schedule_name} scheduled by {request.user} for {schedule_datetime}\",",
            "                    kwargs=job_kwargs,",
            "                    interval=schedule_type,",
            "                    one_off=schedule_type == JobExecutionType.TYPE_FUTURE,",
            "                    queue=task_queue,",
            "                    user=request.user,",
            "                    approval_required=job_model.approval_required,",
            "                    crontab=crontab,",
            "                )",
            "                scheduled_job.save()",
            "",
            "                if job_model.approval_required:",
            "                    messages.success(request, f\"Job {schedule_name} successfully submitted for approval\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_approval_queue_list\")",
            "                else:",
            "                    messages.success(request, f\"Job {schedule_name} successfully scheduled\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_list\")",
            "",
            "            else:",
            "                # Enqueue job for immediate execution",
            "                job_content_type = get_job_content_type()",
            "                job_result = JobResult.enqueue_job(",
            "                    run_job,",
            "                    job_model.class_path,",
            "                    job_content_type,",
            "                    request.user,",
            "                    celery_kwargs={\"queue\": task_queue},",
            "                    data=job_model.job_class.serialize_data(job_form.cleaned_data),",
            "                    request=copy_safe_request(request),",
            "                    commit=commit,",
            "                    profile=profile,",
            "                    task_queue=job_form.cleaned_data.get(\"_task_queue\", None),",
            "                )",
            "",
            "                if return_url:",
            "                    messages.info(",
            "                        request,",
            "                        format_html(",
            "                            'Job enqueued. <a href=\"{}\">Click here for the results.</a>',",
            "                            job_result.get_absolute_url(),",
            "                        ),",
            "                    )",
            "                    return redirect(return_url)",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "",
            "        if return_url:",
            "            return redirect(return_url)",
            "",
            "        template_name = \"extras/job.html\"",
            "        if job_model.job_class is not None and hasattr(job_model.job_class, \"template_name\"):",
            "            try:",
            "                get_template(job_model.job_class.template_name)",
            "                template_name = job_model.job_class.template_name",
            "            except TemplateDoesNotExist as err:",
            "                messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "",
            "        return render(",
            "            request,",
            "            template_name,",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "",
            "# 2.0 TODO: this should really be \"JobView\"",
            "class JobDetailView(generic.ObjectView):",
            "    queryset = JobModel.objects.all()",
            "    template_name = \"extras/job_detail.html\"",
            "",
            "",
            "class JobEditView(generic.ObjectEditView):",
            "    queryset = JobModel.objects.all()",
            "    model_form = forms.JobEditForm",
            "    template_name = \"extras/job_edit.html\"",
            "",
            "",
            "class JobDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobModel.objects.all()",
            "",
            "",
            "class JobApprovalRequestView(generic.ObjectView):",
            "    \"\"\"",
            "    This view handles requests to view and approve a Job execution request.",
            "    It renders the Job's form in much the same way as `JobView` except all",
            "    form fields are disabled and actions on the form relate to approval of the",
            "    job's execution, rather than initial job form input.",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.filter(task=\"nautobot.extras.jobs.scheduled_job_handler\").needs_approved()",
            "    template_name = \"extras/job_approval_request.html\"",
            "    additional_permissions = (\"extras.view_job\",)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Render the job form with data from the scheduled_job instance, but mark all fields as disabled.",
            "        We don't care to actually get any data back from the form as we will not ever change it.",
            "        Instead, we offer the user three submit buttons, dry-run, approve, and deny, which we act upon in the post.",
            "        \"\"\"",
            "        job_model = instance.job_model",
            "        if job_model is not None:",
            "            job_class = job_model.job_class",
            "        else:",
            "            # 2.0 TODO: remove this fallback?",
            "            job_class = get_job(instance.job_class)",
            "",
            "        if job_class is not None:",
            "            # Render the form with all fields disabled",
            "            initial = instance.kwargs.get(\"data\", {})",
            "            initial[\"_commit\"] = instance.kwargs.get(\"commit\", True)",
            "            job_form = job_class().as_form(initial=initial, approval_view=True)",
            "        else:",
            "            job_form = None",
            "",
            "        return {",
            "            \"job_form\": job_form,",
            "        }",
            "",
            "    def post(self, request, pk):",
            "        \"\"\"",
            "        Act upon one of the 3 submit button actions from the user.",
            "",
            "        dry-run will immediately enqueue the job with commit=False and send the user to the normal JobResult view",
            "        deny will delete the scheduled_job instance",
            "        approve will mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        \"\"\"",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        post_data = request.POST",
            "",
            "        deny = \"_deny\" in post_data",
            "        approve = \"_approve\" in post_data",
            "        force_approve = \"_force_approve\" in post_data",
            "        dry_run = \"_dry_run\" in post_data",
            "",
            "        job_model = scheduled_job.job_model",
            "",
            "        if dry_run:",
            "            # To dry-run a job, a user needs the same permissions that would be needed to run the job directly",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not job_model.runnable:",
            "                messages.error(request, \"This job cannot be run at this time\")",
            "            elif not JobModel.objects.check_perms(self.request.user, instance=job_model, action=\"run\"):",
            "                messages.error(request, \"You do not have permission to run this job\")",
            "            else:",
            "                # Immediately enqueue the job with commit=False and send the user to the normal JobResult view",
            "                job_content_type = get_job_content_type()",
            "                initial = scheduled_job.kwargs.get(\"data\", {})",
            "                initial[\"_commit\"] = False",
            "                celery_kwargs = scheduled_job.kwargs.get(\"celery_kwargs\", {})",
            "                job_result = JobResult.enqueue_job(",
            "                    run_job,",
            "                    job_model.job_class.class_path,",
            "                    job_content_type,",
            "                    request.user,",
            "                    celery_kwargs=celery_kwargs,",
            "                    data=job_model.job_class.serialize_data(initial),",
            "                    request=copy_safe_request(request),",
            "                    commit=False,  # force a dry-run",
            "                    task_queue=scheduled_job.kwargs.get(\"task_queue\", None),",
            "                )",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "        elif deny:",
            "            if not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"delete\")",
            "                and job_model is not None",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to deny this request.\")",
            "            else:",
            "                # Delete the scheduled_job instance",
            "                scheduled_job.delete()",
            "                if request.user == scheduled_job.user:",
            "                    messages.error(request, f\"Approval request for {scheduled_job.name} was revoked\")",
            "                else:",
            "                    messages.error(request, f\"Approval of {scheduled_job.name} was denied\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        elif approve or force_approve:",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"change\")",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to approve this request.\")",
            "            elif request.user == scheduled_job.user:",
            "                # The requestor *cannot* approve their own job",
            "                messages.error(request, \"You cannot approve your own job request!\")",
            "            else:",
            "                # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "                if scheduled_job.one_off and scheduled_job.start_time < timezone.now() and not force_approve:",
            "                    return render(request, \"extras/job_approval_confirmation.html\", {\"scheduled_job\": scheduled_job})",
            "                scheduled_job.approved_by_user = request.user",
            "                scheduled_job.approved_at = timezone.now()",
            "                scheduled_job.save()",
            "",
            "                messages.success(request, f\"{scheduled_job.name} was approved and will now begin execution\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        return render(",
            "            request,",
            "            self.get_template_name(),",
            "            {",
            "                \"object\": scheduled_job,",
            "                **self.get_extra_context(request, scheduled_job),",
            "            },",
            "        )",
            "",
            "",
            "class ScheduledJobListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.filter(task=\"nautobot.extras.jobs.scheduled_job_handler\").enabled()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "",
            "",
            "class ScheduledJobBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "",
            "",
            "class ScheduledJobApprovalQueueListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.filter(task=\"nautobot.extras.jobs.scheduled_job_handler\").needs_approved()",
            "    table = tables.ScheduledJobApprovalQueueTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "    template_name = \"extras/scheduled_jobs_approval_queue_list.html\"",
            "",
            "",
            "class ScheduledJobView(generic.ObjectView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        job_class = get_job(instance.job_class)",
            "        labels = {}",
            "        if job_class is not None:",
            "            for name, var in job_class._get_vars().items():",
            "                field = var.as_field()",
            "                if field.label:",
            "                    labels[name] = var",
            "                else:",
            "                    labels[name] = pretty_name(name)",
            "        return {\"labels\": labels, \"job_class_found\": (job_class is not None)}",
            "",
            "",
            "class ScheduledJobDeleteView(generic.ObjectDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "",
            "#",
            "# Job hooks",
            "#",
            "",
            "",
            "class JobHookListView(generic.ObjectListView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "    filterset = filters.JobHookFilterSet",
            "    filterset_form = forms.JobHookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class JobHookView(generic.ObjectView):",
            "    queryset = JobHook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"content_types\": instance.content_types.order_by(\"app_label\", \"model\")}",
            "",
            "",
            "class JobHookEditView(generic.ObjectEditView):",
            "    queryset = JobHook.objects.all()",
            "    model_form = forms.JobHookForm",
            "",
            "",
            "class JobHookDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobHook.objects.all()",
            "",
            "",
            "class JobHookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "",
            "",
            "#",
            "# JobResult",
            "#",
            "",
            "",
            "class JobResultListView(generic.ObjectListView):",
            "    \"\"\"",
            "    List JobResults",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.defer(\"data\").select_related(\"job_model\", \"obj_type\", \"user\").prefetch_related(\"logs\")",
            "    filterset = filters.JobResultFilterSet",
            "    filterset_form = forms.JobResultFilterForm",
            "    table = tables.JobResultTable",
            "    action_buttons = ()",
            "",
            "",
            "class JobResultDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobResult.objects.all()",
            "",
            "",
            "class JobResultBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobResult.objects.defer(\"data\").all()",
            "    table = tables.JobResultTable",
            "",
            "",
            "class JobResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.prefetch_related(\"job_model\", \"obj_type\", \"user\")",
            "    template_name = \"extras/jobresult.html\"",
            "",
            "    def instance_to_csv(self, instance):",
            "        \"\"\"Format instance to csv.\"\"\"",
            "        csv_data = []",
            "        headers = JobLogEntry.csv_headers.copy()",
            "        csv_data.append(\",\".join(headers))",
            "",
            "        for log_entry in instance.logs.all():",
            "            data = log_entry.to_csv()",
            "            csv_data.append(csv_format(data))",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Generic GET handler for accessing an object by PK or slug",
            "        \"\"\"",
            "        instance = get_object_or_404(self.queryset, **kwargs)",
            "",
            "        if \"export\" in request.GET:",
            "            response = HttpResponse(self.instance_to_csv(instance), content_type=\"text/csv\")",
            "            underscore_filename = f\"{instance.job_model.slug.replace('-', '_')}\"",
            "            formated_completion_time = instance.completed.strftime(\"%Y-%m-%d_%H_%M\")",
            "            filename = f\"{underscore_filename}_{formated_completion_time}_logs.csv\"",
            "            response[\"Content-Disposition\"] = f\"attachment; filename={filename}\"",
            "            return response",
            "",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        associated_record = None",
            "        job_class = None",
            "        if instance.job_model is not None:",
            "            job_class = instance.job_model.job_class",
            "        # 2.0 TODO: remove JobResult.related_object entirely",
            "        related_object = instance.related_object",
            "        if inspect.isclass(related_object) and issubclass(related_object, JobClass):",
            "            if job_class is None:",
            "                job_class = related_object",
            "        elif related_object:",
            "            associated_record = related_object",
            "",
            "        return {",
            "            \"job\": job_class,",
            "            \"associated_record\": associated_record,",
            "            \"result\": instance,",
            "        }",
            "",
            "",
            "class JobLogEntryTableView(generic.GenericView):",
            "    \"\"\"",
            "    Display a table of `JobLogEntry` objects for a given `JobResult` instance.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.all()",
            "",
            "    def get(self, request, pk=None):",
            "        instance = get_object_or_404(self.queryset.restrict(request.user, \"view\"), pk=pk)",
            "        log_table = tables.JobLogEntryTable(data=instance.logs.all(), user=request.user)",
            "        RequestConfig(request).configure(log_table)",
            "        return HttpResponse(log_table.as_html(request))",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.JobButtonBulkEditForm",
            "    filterset_class = filters.JobButtonFilterSet",
            "    filterset_form_class = forms.JobButtonFilterForm",
            "    form_class = forms.JobButtonForm",
            "    lookup_field = \"pk\"",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    table_class = tables.JobButtonTable",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeListView(generic.ObjectListView):",
            "    queryset = ObjectChange.objects.all()",
            "    filterset = filters.ObjectChangeFilterSet",
            "    filterset_form = forms.ObjectChangeFilterForm",
            "    table = tables.ObjectChangeTable",
            "    template_name = \"extras/objectchange_list.html\"",
            "    action_buttons = (\"export\",)",
            "",
            "    # 2.0 TODO: Remove this remapping and solve it at the `BaseFilterSet` as it is addressing a breaking change.",
            "    def get(self, request, **kwargs):",
            "        # Remappings below allow previous queries of time_before and time_after to use",
            "        # newer methods specifying the lookup method.",
            "",
            "        # They will only use the previous arguments if the newer ones are undefined",
            "",
            "        if request.GET.get(\"time_after\") and request.GET.get(\"time__gte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__gte\": request.GET.get(\"time_after\")})",
            "            request.GET._mutable = False",
            "",
            "        if request.GET.get(\"time_before\") and request.GET.get(\"time__lte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__lte\": request.GET.get(\"time_before\")})",
            "            request.GET._mutable = False",
            "",
            "        return super().get(request=request, **kwargs)",
            "",
            "",
            "class ObjectChangeView(generic.ObjectView):",
            "    queryset = ObjectChange.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_changes = instance.get_related_changes(user=request.user).filter(request_id=instance.request_id)",
            "        related_changes_table = tables.ObjectChangeTable(data=related_changes[:50], orderable=False)",
            "",
            "        snapshots = instance.get_snapshots()",
            "        return {",
            "            \"diff_added\": snapshots[\"differences\"][\"added\"],",
            "            \"diff_removed\": snapshots[\"differences\"][\"removed\"],",
            "            \"next_change\": instance.get_next_change(request.user),",
            "            \"prev_change\": instance.get_prev_change(request.user),",
            "            \"related_changes_table\": related_changes_table,",
            "            \"related_changes_count\": related_changes.count(),",
            "        }",
            "",
            "",
            "class ObjectChangeLogView(generic.GenericView):",
            "    \"\"\"",
            "    Present a history of changes made to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all changes for this object (and its related objects)",
            "        content_type = ContentType.objects.get_for_model(model)",
            "        objectchanges = (",
            "            ObjectChange.objects.restrict(request.user, \"view\")",
            "            .select_related(\"user\", \"changed_object_type\")",
            "            .filter(",
            "                Q(changed_object_type=content_type, changed_object_id=obj.pk)",
            "                | Q(related_object_type=content_type, related_object_id=obj.pk)",
            "            )",
            "        )",
            "        objectchanges_table = tables.ObjectChangeTable(data=objectchanges, orderable=False)",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(objectchanges_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_changelog.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": objectchanges_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"changelog\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteView(generic.ObjectView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class NoteEditView(generic.ObjectEditView):",
            "    queryset = Note.objects.all()",
            "    model_form = forms.NoteForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        obj.user = request.user",
            "        return obj",
            "",
            "",
            "class NoteDeleteView(generic.ObjectDeleteView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class ObjectNotesView(generic.GenericView):",
            "    \"\"\"",
            "    Present a history of changes made to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        notes_form = forms.NoteForm(",
            "            initial={",
            "                \"assigned_object_type\": ContentType.objects.get_for_model(obj),",
            "                \"assigned_object_id\": obj.pk,",
            "            }",
            "        )",
            "        notes_table = tables.NoteTable(obj.notes.restrict(request.user, \"view\"))",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(notes_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_notes.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": notes_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"notes\",",
            "                \"form\": notes_form,",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipListView(generic.ObjectListView):",
            "    queryset = Relationship.objects.all()",
            "    filterset = filters.RelationshipFilterSet",
            "    filterset_form = forms.RelationshipFilterForm",
            "    table = tables.RelationshipTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class RelationshipView(generic.ObjectView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipEditView(generic.ObjectEditView):",
            "    queryset = Relationship.objects.all()",
            "    model_form = forms.RelationshipForm",
            "    template_name = \"extras/relationship_edit.html\"",
            "",
            "",
            "class RelationshipBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Relationship.objects.all()",
            "    table = tables.RelationshipTable",
            "",
            "",
            "class RelationshipDeleteView(generic.ObjectDeleteView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipAssociationListView(generic.ObjectListView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    filterset = filters.RelationshipAssociationFilterSet",
            "    filterset_form = forms.RelationshipAssociationFilterForm",
            "    table = tables.RelationshipAssociationTable",
            "    action_buttons = ()",
            "",
            "",
            "class RelationshipAssociationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    table = tables.RelationshipAssociationTable",
            "",
            "",
            "class RelationshipAssociationDeleteView(generic.ObjectDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretListView(generic.ObjectListView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    filterset_form = forms.SecretFilterForm",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretView(generic.ObjectView):",
            "    queryset = Secret.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        provider = registry[\"secrets_providers\"].get(instance.provider)",
            "",
            "        groups = instance.groups.distinct()",
            "        groups_table = tables.SecretsGroupTable(groups, orderable=False)",
            "",
            "        return {",
            "            \"format\": format_,",
            "            \"provider_name\": provider.name if provider else instance.provider,",
            "            \"groups_table\": groups_table,",
            "        }",
            "",
            "",
            "class SecretProviderParametersFormView(generic.GenericView):",
            "    \"\"\"",
            "    Helper view to SecretView; retrieve the HTML form appropriate for entering parameters for a given SecretsProvider.",
            "    \"\"\"",
            "",
            "    def get(self, request, provider_slug):",
            "        provider = registry[\"secrets_providers\"].get(provider_slug)",
            "        if not provider:",
            "            raise Http404",
            "        return render(",
            "            request,",
            "            \"extras/inc/secret_provider_parameters_form.html\",",
            "            {\"form\": provider.ParametersForm(initial=request.GET)},",
            "        )",
            "",
            "",
            "class SecretEditView(generic.ObjectEditView):",
            "    queryset = Secret.objects.all()",
            "    model_form = forms.SecretForm",
            "    template_name = \"extras/secret_edit.html\"",
            "",
            "",
            "class SecretDeleteView(generic.ObjectDeleteView):",
            "    queryset = Secret.objects.all()",
            "",
            "",
            "class SecretBulkImportView(generic.BulkImportView):",
            "    queryset = Secret.objects.all()",
            "    model_form = forms.SecretCSVForm",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretsGroupListView(generic.ObjectListView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    filterset_form = forms.SecretsGroupFilterForm",
            "    table = tables.SecretsGroupTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class SecretsGroupView(generic.ObjectView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"secrets_group_associations\": SecretsGroupAssociation.objects.filter(group=instance)}",
            "",
            "",
            "class SecretsGroupEditView(generic.ObjectEditView):",
            "    queryset = SecretsGroup.objects.all()",
            "    model_form = forms.SecretsGroupForm",
            "    template_name = \"extras/secretsgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for secrets",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    secrets = ctx[\"secrets\"]",
            "                    if secrets.is_valid():",
            "                        secrets.save()",
            "                    else:",
            "                        raise RuntimeError(secrets.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                else:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving secrets group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class SecretsGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "",
            "class SecretsGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    table = tables.SecretsGroupTable",
            "",
            "",
            "#",
            "# Custom statuses",
            "#",
            "",
            "",
            "class StatusListView(generic.ObjectListView):",
            "    \"\"\"List `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    filterset = filters.StatusFilterSet",
            "    filterset_form = forms.StatusFilterForm",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusEditView(generic.ObjectEditView):",
            "    \"\"\"Edit a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    model_form = forms.StatusForm",
            "",
            "",
            "class StatusBulkEditView(generic.BulkEditView):",
            "    \"\"\"Edit multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "    form = forms.StatusBulkEditForm",
            "",
            "",
            "class StatusBulkDeleteView(generic.BulkDeleteView):",
            "    \"\"\"Delete multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusDeleteView(generic.ObjectDeleteView):",
            "    \"\"\"Delete a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "",
            "class StatusBulkImportView(generic.BulkImportView):",
            "    \"\"\"Bulk CSV import of multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    model_form = forms.StatusCSVForm",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusView(generic.ObjectView):",
            "    \"\"\"Detail view for a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"Return ordered content types.\"\"\"",
            "        return {\"content_types\": instance.content_types.order_by(\"app_label\", \"model\")}",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagListView(generic.ObjectListView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    filterset = filters.TagFilterSet",
            "    filterset_form = forms.TagFilterForm",
            "    table = tables.TagTable",
            "",
            "",
            "class TagView(generic.ObjectView):",
            "    queryset = Tag.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        tagged_items = (",
            "            TaggedItem.objects.filter(tag=instance).select_related(\"content_type\").prefetch_related(\"content_object\")",
            "        )",
            "",
            "        # Generate a table of all items tagged with this Tag",
            "        items_table = tables.TaggedItemTable(tagged_items)",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(items_table)",
            "",
            "        return {",
            "            \"items_count\": tagged_items.count(),",
            "            \"items_table\": items_table,",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "        }",
            "",
            "",
            "class TagEditView(generic.ObjectEditView):",
            "    queryset = Tag.objects.all()",
            "    model_form = forms.TagForm",
            "    template_name = \"extras/tag_edit.html\"",
            "",
            "",
            "class TagDeleteView(generic.ObjectDeleteView):",
            "    queryset = Tag.objects.all()",
            "",
            "",
            "class TagBulkImportView(generic.BulkImportView):",
            "    queryset = Tag.objects.all()",
            "    model_form = forms.TagCSVForm",
            "    table = tables.TagTable",
            "",
            "",
            "class TagBulkEditView(generic.BulkEditView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "    form = forms.TagBulkEditForm",
            "",
            "",
            "class TagBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookListView(generic.ObjectListView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "    filterset = filters.WebhookFilterSet",
            "    filterset_form = forms.WebhookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class WebhookView(generic.ObjectView):",
            "    queryset = Webhook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"content_types\": instance.content_types.order_by(\"app_label\", \"model\")}",
            "",
            "",
            "class WebhookEditView(generic.ObjectEditView):",
            "    queryset = Webhook.objects.all()",
            "    model_form = forms.WebhookForm",
            "",
            "",
            "class WebhookDeleteView(generic.ObjectDeleteView):",
            "    queryset = Webhook.objects.all()",
            "",
            "",
            "class WebhookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "",
            "",
            "#",
            "# Job Extra Views",
            "#",
            "# NOTE: Due to inheritance, JobObjectChangeLogView and JobObjectNotesView can only be",
            "# constructed below # ObjectChangeLogView and ObjectNotesView.",
            "",
            "",
            "class JobObjectChangeLogView(ObjectChangeLogView):",
            "    base_template = \"extras/job_detail.html\"",
            "",
            "",
            "class JobObjectNotesView(ObjectNotesView):",
            "    base_template = \"extras/job_detail.html\""
        ],
        "afterPatchFile": [
            "import inspect",
            "from datetime import timedelta",
            "import logging",
            "",
            "from celery import chain",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.db import transaction",
            "from django.db.models import ProtectedError, Q",
            "from django.forms.utils import pretty_name",
            "from django.http import Http404, HttpResponse, HttpResponseForbidden",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.encoding import iri_to_uri",
            "from django.utils.html import format_html",
            "from django.utils.http import is_safe_url, url_has_allowed_host_and_scheme",
            "from django.views.generic import View",
            "from django.template.loader import get_template, TemplateDoesNotExist",
            "from django_tables2 import RequestConfig",
            "from jsonschema.validators import Draft7Validator",
            "",
            "from nautobot.core.views import generic",
            "from nautobot.core.views.viewsets import NautobotUIViewSet",
            "from nautobot.dcim.models import Device",
            "from nautobot.dcim.tables import DeviceTable",
            "from nautobot.extras.tasks import delete_custom_field_data",
            "from nautobot.extras.utils import get_base_template, get_job_content_type, get_worker_count",
            "from nautobot.utilities.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.utilities.forms import restrict_form_fields",
            "from nautobot.utilities.utils import (",
            "    copy_safe_request,",
            "    count_related,",
            "    csv_format,",
            "    get_table_for_model,",
            "    prepare_cloned_fields,",
            "    pretty_print_query,",
            ")",
            "from nautobot.utilities.tables import ButtonsColumn",
            "from nautobot.utilities.views import ObjectPermissionRequiredMixin",
            "from nautobot.utilities.utils import normalize_querydict",
            "from nautobot.virtualization.models import VirtualMachine",
            "from nautobot.virtualization.tables import VirtualMachineTable",
            "from . import filters, forms, tables",
            "from .api import serializers",
            "from .choices import JobExecutionType, JobResultStatusChoices",
            "from .datasources import (",
            "    enqueue_git_repository_diff_origin_and_local,",
            "    enqueue_pull_git_repository_and_refresh_data,",
            "    get_datasource_contents,",
            ")",
            "from .jobs import get_job, run_job, Job as JobClass",
            "from .models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job as JobModel,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    ObjectChange,",
            "    JobResult,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Webhook,",
            "    Note,",
            ")",
            "from .registry import registry",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldListView(generic.ObjectListView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "    filterset = filters.ComputedFieldFilterSet",
            "    filterset_form = forms.ComputedFieldFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ComputedFieldView(generic.ObjectView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldEditView(generic.ObjectEditView):",
            "    queryset = ComputedField.objects.all()",
            "    model_form = forms.ComputedFieldForm",
            "    template_name = \"extras/computedfield_edit.html\"",
            "",
            "",
            "class ComputedFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config contexts that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextListView(generic.ObjectListView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    filterset_form = forms.ConfigContextFilterForm",
            "    table = tables.ConfigContextTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextView(generic.ObjectView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"format\": format_,",
            "        }",
            "",
            "",
            "class ConfigContextEditView(generic.ObjectEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    model_form = forms.ConfigContextForm",
            "    template_name = \"extras/configcontext_edit.html\"",
            "",
            "",
            "class ConfigContextBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    table = tables.ConfigContextTable",
            "    form = forms.ConfigContextBulkEditForm",
            "",
            "",
            "class ConfigContextDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "",
            "class ConfigContextBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "    table = tables.ConfigContextTable",
            "",
            "",
            "class ObjectConfigContextView(generic.ObjectView):",
            "    base_template = None",
            "    template_name = \"extras/object_configcontext.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        source_contexts = ConfigContext.objects.restrict(request.user, \"view\").get_for_object(instance)",
            "",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"rendered_context\": instance.get_config_context(),",
            "            \"source_contexts\": source_contexts,",
            "            \"format\": format_,",
            "            \"base_template\": self.base_template,",
            "            \"active_tab\": \"config-context\",",
            "        }",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config context schemas that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextSchemaListView(generic.ObjectListView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    filterset_form = forms.ConfigContextSchemaFilterForm",
            "    table = tables.ConfigContextSchemaTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextSchemaView(generic.ObjectView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontextschema.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontextschema.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"format\": format_,",
            "        }",
            "",
            "",
            "class ConfigContextSchemaObjectValidationView(generic.ObjectView):",
            "    \"\"\"",
            "    This view renders a detail tab that shows tables of objects that utilize the given schema object",
            "    and their validation state.",
            "    \"\"\"",
            "",
            "    queryset = ConfigContextSchema.objects.all()",
            "    template_name = \"extras/configcontextschema_validation.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Reuse the model tables for config context, device, and virtual machine but inject",
            "        the `ConfigContextSchemaValidationStateColumn` and an object edit action button.",
            "        \"\"\"",
            "        # Prep the validator with the schema so it can be reused for all records",
            "        validator = Draft7Validator(instance.data_schema)",
            "",
            "        # Config context table",
            "        config_context_table = tables.ConfigContextTable(",
            "            data=instance.configcontext_set.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=ConfigContext, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(config_context_table)",
            "",
            "        # Device table",
            "        device_table = DeviceTable(",
            "            data=instance.device_set.select_related(",
            "                \"tenant\",",
            "                \"site\",",
            "                \"rack\",",
            "                \"device_type\",",
            "                \"device_role\",",
            "            ).prefetch_related(\"primary_ip\"),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"local_context_data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=Device, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        # Virtual machine table",
            "        virtual_machine_table = VirtualMachineTable(",
            "            data=instance.virtualmachine_set.select_related(",
            "                \"cluster\",",
            "                \"role\",",
            "                \"tenant\",",
            "            ).prefetch_related(\"primary_ip\"),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"local_context_data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=VirtualMachine, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(virtual_machine_table)",
            "",
            "        return {",
            "            \"config_context_table\": config_context_table,",
            "            \"device_table\": device_table,",
            "            \"virtual_machine_table\": virtual_machine_table,",
            "            \"active_tab\": \"validation\",",
            "        }",
            "",
            "",
            "class ConfigContextSchemaEditView(generic.ObjectEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    model_form = forms.ConfigContextSchemaForm",
            "    template_name = \"extras/configcontextschema_edit.html\"",
            "",
            "",
            "class ConfigContextSchemaBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    table = tables.ConfigContextSchemaTable",
            "    form = forms.ConfigContextSchemaBulkEditForm",
            "",
            "",
            "class ConfigContextSchemaDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "",
            "class ConfigContextSchemaBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    table = tables.ConfigContextSchemaTable",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "class CustomFieldListView(generic.ObjectListView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "    filterset = filters.CustomFieldFilterSet",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomFieldView(generic.ObjectView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldEditView(generic.ObjectEditView):",
            "    queryset = CustomField.objects.all()",
            "    model_form = forms.CustomFieldForm",
            "    template_name = \"extras/customfield_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # ---> BEGIN difference from ObjectEditView.post()",
            "                    # Process the formsets for choices",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    choices = ctx[\"choices\"]",
            "                    if choices.is_valid():",
            "                        choices.save()",
            "                    else:",
            "                        raise RuntimeError(choices.errors)",
            "                    # <--- END difference from ObjectEditView.post()",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                else:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # ---> BEGIN difference from ObjectEditView.post()",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving custom field choices. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # <--- END difference from ObjectEditView.post()",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class CustomFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "",
            "    def construct_custom_field_delete_tasks(self, queryset):",
            "        \"\"\"",
            "        Helper method to construct a list of celery tasks to execute when bulk deleting custom fields.",
            "        \"\"\"",
            "        tasks = [",
            "            # 2.0 TODO: #824 use obj.slug instead of obj.name",
            "            delete_custom_field_data.si(obj.name, set(obj.content_types.values_list(\"pk\", flat=True)))",
            "            for obj in queryset",
            "        ]",
            "        return tasks",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        \"\"\"",
            "        Remove all Custom Field Keys/Values from _custom_field_data of the related ContentType in the background.",
            "        \"\"\"",
            "        if not get_worker_count():",
            "            messages.error(",
            "                request, \"Celery worker process not running. Object custom fields may fail to reflect this deletion.\"",
            "            )",
            "            return",
            "        tasks = self.construct_custom_field_delete_tasks(queryset)",
            "        # Executing the tasks in the background sequentially using chain() aligns with how a single",
            "        # CustomField object is deleted.  We decided to not check the result because it needs at least one worker",
            "        # to be active and comes with extra performance penalty.",
            "        chain(*tasks).apply_async()",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkListView(generic.ObjectListView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "    filterset = filters.CustomLinkFilterSet",
            "    filterset_form = forms.CustomLinkFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomLinkView(generic.ObjectView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkEditView(generic.ObjectEditView):",
            "    queryset = CustomLink.objects.all()",
            "    model_form = forms.CustomLinkForm",
            "",
            "",
            "class CustomLinkDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupListView(generic.ObjectListView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "    filterset = filters.DynamicGroupFilterSet",
            "    filterset_form = forms.DynamicGroupFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class DynamicGroupView(generic.ObjectView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        model = instance.content_type.model_class()",
            "        table_class = get_table_for_model(model)",
            "",
            "        if table_class is not None:",
            "            # Members table (for display on Members nav tab)",
            "            members_table = table_class(instance.members.restrict(request.user, \"view\"), orderable=False)",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(members_table)",
            "",
            "            # Descendants table",
            "            descendants_memberships = instance.membership_tree()",
            "            descendants_table = tables.NestedDynamicGroupDescendantsTable(",
            "                descendants_memberships,",
            "                orderable=False,",
            "            )",
            "            descendants_tree = {m.pk: m.depth for m in descendants_memberships}",
            "",
            "            # Ancestors table",
            "            ancestors = instance.get_ancestors()",
            "            ancestors_table = tables.NestedDynamicGroupAncestorsTable(ancestors, orderable=False)",
            "            ancestors_tree = instance.flatten_ancestors_tree(instance.ancestors_tree())",
            "",
            "            context[\"raw_query\"] = pretty_print_query(instance.generate_query())",
            "            context[\"members_table\"] = members_table",
            "            context[\"ancestors_table\"] = ancestors_table",
            "            context[\"ancestors_tree\"] = ancestors_tree",
            "            context[\"descendants_table\"] = descendants_table",
            "            context[\"descendants_tree\"] = descendants_tree",
            "",
            "        return context",
            "",
            "",
            "class DynamicGroupEditView(generic.ObjectEditView):",
            "    queryset = DynamicGroup.objects.all()",
            "    model_form = forms.DynamicGroupForm",
            "    template_name = \"extras/dynamicgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        filterform_class = instance.generate_filter_form()",
            "",
            "        if filterform_class is None:",
            "            filter_form = None",
            "        elif request.POST:",
            "            filter_form = filterform_class(data=request.POST)",
            "        else:",
            "            initial = instance.get_initial()",
            "            filter_form = filterform_class(initial=initial)",
            "",
            "        ctx[\"filter_form\"] = filter_form",
            "",
            "        formset_kwargs = {\"instance\": instance}",
            "        if request.POST:",
            "            formset_kwargs[\"data\"] = request.POST",
            "",
            "        ctx[\"children\"] = forms.DynamicGroupMembershipFormSet(**formset_kwargs)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    # Obtain the instance, but do not yet `save()` it to the database.",
            "                    obj = form.save(commit=False)",
            "",
            "                    # Process the filter form and save the query filters to `obj.filter`.",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    filter_form = ctx[\"filter_form\"]",
            "                    if filter_form.is_valid():",
            "                        obj.set_filter(filter_form.cleaned_data)",
            "                    else:",
            "                        raise RuntimeError(filter_form.errors)",
            "",
            "                    # After filters have been set, now we save the object to the database.",
            "                    obj.save()",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for children",
            "                    children = ctx[\"children\"]",
            "                    if children.is_valid():",
            "                        children.save()",
            "                    else:",
            "                        raise RuntimeError(children.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                else:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving Dynamic Group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a something that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class DynamicGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "",
            "class DynamicGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "",
            "",
            "class ObjectDynamicGroupsView(generic.GenericView):",
            "    \"\"\"",
            "    Present a list of dynamic groups associated to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all dynamic groups for this object (and its related objects)",
            "        dynamicsgroups_table = tables.DynamicGroupTable(",
            "            data=obj.dynamic_groups_cached.restrict(request.user, \"view\"), orderable=False",
            "        )",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(dynamicsgroups_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_dynamicgroups.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": dynamicsgroups_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"dynamic-groups\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateListView(generic.ObjectListView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "    filterset = filters.ExportTemplateFilterSet",
            "    filterset_form = forms.ExportTemplateFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ExportTemplateView(generic.ObjectView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateEditView(generic.ObjectEditView):",
            "    queryset = ExportTemplate.objects.all()",
            "    model_form = forms.ExportTemplateForm",
            "",
            "",
            "class ExportTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryListView(generic.ObjectListView):",
            "    queryset = GitRepository.objects.all()",
            "    filterset = filters.GitRepositoryFilterSet",
            "    filterset_form = forms.GitRepositoryFilterForm",
            "    table = tables.GitRepositoryTable",
            "    template_name = \"extras/gitrepository_list.html\"",
            "",
            "    def extra_context(self):",
            "        git_repository_content_type = ContentType.objects.get(app_label=\"extras\", model=\"gitrepository\")",
            "        # Get the newest results for each repository name",
            "        results = {",
            "            r.name: r",
            "            for r in JobResult.objects.filter(",
            "                obj_type=git_repository_content_type,",
            "                status__in=JobResultStatusChoices.TERMINAL_STATE_CHOICES,",
            "            )",
            "            .order_by(\"completed\")",
            "            .defer(\"data\")",
            "        }",
            "        return {",
            "            \"job_results\": results,",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryView(generic.ObjectView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryEditView(generic.ObjectEditView):",
            "    queryset = GitRepository.objects.all()",
            "    model_form = forms.GitRepositoryForm",
            "    template_name = \"extras/gitrepository_object_edit.html\"",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.request = request",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def get_return_url(self, request, obj):",
            "        if request.method == \"POST\":",
            "            return reverse(\"extras:gitrepository_result\", kwargs={\"slug\": obj.slug})",
            "        return super().get_return_url(request, obj)",
            "",
            "",
            "class GitRepositoryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "",
            "class GitRepositoryBulkImportView(generic.BulkImportView):",
            "    queryset = GitRepository.objects.all()",
            "    model_form = forms.GitRepositoryCSVForm",
            "    table = tables.GitRepositoryBulkTable",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        \"\"\"Each GitRepository needs to know the originating request when it's saved so that it can enqueue using it.\"\"\"",
            "        instance = obj_form.save(commit=False)",
            "        instance.request = request",
            "        instance.save()",
            "",
            "        return instance",
            "",
            "",
            "class GitRepositoryBulkEditView(generic.BulkEditView):",
            "    queryset = GitRepository.objects.select_related(\"secrets_group\")",
            "    filterset = filters.GitRepositoryFilterSet",
            "    table = tables.GitRepositoryBulkTable",
            "    form = forms.GitRepositoryBulkEditForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.request = request",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "    table = tables.GitRepositoryBulkTable",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "def check_and_call_git_repository_function(request, slug, func):",
            "    \"\"\"Helper for checking Git permissions and worker availability, then calling provided function if all is well",
            "    Args:",
            "        request: request object.",
            "        slug (str): GitRepository slug value.",
            "        func (function): Enqueue git repo function.",
            "    Returns:",
            "        HttpResponseForbidden or a redirect",
            "    \"\"\"",
            "    if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "        return HttpResponseForbidden()",
            "",
            "    # Allow execution only if a worker process is running.",
            "    if not get_worker_count():",
            "        messages.error(request, \"Unable to run job: Celery worker process not running.\")",
            "    else:",
            "        repository = get_object_or_404(GitRepository.objects.restrict(request.user, \"change\"), slug=slug)",
            "        func(repository, request)",
            "",
            "    return redirect(\"extras:gitrepository_result\", slug=slug)",
            "",
            "",
            "class GitRepositorySyncView(generic.GenericView):",
            "    def post(self, request, slug):",
            "        return check_and_call_git_repository_function(request, slug, enqueue_pull_git_repository_and_refresh_data)",
            "",
            "",
            "class GitRepositoryDryRunView(generic.GenericView):",
            "    def post(self, request, slug):",
            "        return check_and_call_git_repository_function(request, slug, enqueue_git_repository_diff_origin_and_local)",
            "",
            "",
            "class GitRepositoryResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    template_name = \"extras/gitrepository_result.html\"",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.view_gitrepository\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        git_repository_content_type = ContentType.objects.get(app_label=\"extras\", model=\"gitrepository\")",
            "        job_result = (",
            "            JobResult.objects.filter(obj_type=git_repository_content_type, name=instance.name)",
            "            .order_by(\"-created\")",
            "            .first()",
            "        )",
            "",
            "        return {",
            "            \"result\": job_result,",
            "            \"base_template\": \"extras/gitrepository.html\",",
            "            \"object\": instance,",
            "            \"active_tab\": \"result\",",
            "        }",
            "",
            "",
            "#",
            "# Saved GraphQL queries",
            "#",
            "",
            "",
            "class GraphQLQueryListView(generic.ObjectListView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "    filterset = filters.GraphQLQueryFilterSet",
            "    filterset_form = forms.GraphQLQueryFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class GraphQLQueryView(generic.ObjectView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryEditView(generic.ObjectEditView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    model_form = forms.GraphQLQueryForm",
            "",
            "",
            "class GraphQLQueryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentEditView(generic.ObjectEditView):",
            "    \"\"\"",
            "    View for creating and editing ImageAttachments.",
            "",
            "    Note that a URL kwargs parameter of \"pk\" identifies an existing ImageAttachment to edit,",
            "    while kwargs of \"object_id\" or \"slug\" identify the parent model instance to attach an ImageAttachment to.",
            "    \"\"\"",
            "",
            "    queryset = ImageAttachment.objects.all()",
            "    model_form = forms.ImageAttachmentForm",
            "",
            "    def get_object(self, kwargs):",
            "        if \"pk\" in kwargs:",
            "            return get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        return self.queryset.model()",
            "",
            "    def alter_obj(self, imageattachment, request, args, kwargs):",
            "        if not imageattachment.present_in_database:",
            "            # Assign the parent object based on URL kwargs",
            "            model = kwargs.get(\"model\")",
            "            if \"object_id\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, pk=kwargs[\"object_id\"])",
            "            elif \"slug\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, slug=kwargs[\"slug\"])",
            "            else:",
            "                raise RuntimeError(\"Neither object_id nor slug were provided?\")",
            "        return imageattachment",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "class ImageAttachmentDeleteView(generic.ObjectDeleteView):",
            "    queryset = ImageAttachment.objects.all()",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobListView(generic.ObjectListView):",
            "    \"\"\"",
            "    Retrieve all of the available jobs from disk and the recorded JobResult (if any) for each.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "    table = tables.JobTable",
            "    filterset = filters.JobFilterSet",
            "    filterset_form = forms.JobFilterForm",
            "    action_buttons = ()",
            "    template_name = \"extras/job_list.html\"",
            "",
            "    def alter_queryset(self, request):",
            "        queryset = super().alter_queryset(request)",
            "        # Default to hiding \"hidden\", non-installed jobs and job hook receivers",
            "        if \"hidden\" not in request.GET:",
            "            queryset = queryset.filter(hidden=False)",
            "        if \"installed\" not in request.GET:",
            "            queryset = queryset.filter(installed=True)",
            "        if \"is_job_hook_receiver\" not in request.GET:",
            "            queryset = queryset.filter(is_job_hook_receiver=False)",
            "        if \"is_job_button_receiver\" not in request.GET:",
            "            queryset = queryset.filter(is_job_button_receiver=False)",
            "        queryset = queryset.prefetch_related(\"results\")",
            "        return queryset",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"table_inc_template\": \"extras/inc/job_table.html\",",
            "        }",
            "",
            "",
            "# 2.0 TODO: this should really be \"JobRunView\"",
            "class JobView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    View the parameters of a Job and enqueue it if desired.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.run_job\"",
            "",
            "    def _get_job_model_or_404(self, class_path=None, slug=None):",
            "        \"\"\"Helper function for get() and post().\"\"\"",
            "        if class_path:",
            "            try:",
            "                job_model = self.queryset.get_for_class_path(class_path)",
            "            except JobModel.DoesNotExist:",
            "                raise Http404",
            "        else:",
            "            job_model = get_object_or_404(self.queryset, slug=slug)",
            "",
            "        return job_model",
            "",
            "    def get(self, request, class_path=None, slug=None):",
            "        job_model = self._get_job_model_or_404(class_path, slug)",
            "",
            "        try:",
            "            job_class = job_model.job_class()",
            "            initial = normalize_querydict(request.GET, form_class=job_class.as_form_class())",
            "            if \"kwargs_from_job_result\" in initial:",
            "                job_result_pk = initial.pop(\"kwargs_from_job_result\")",
            "                try:",
            "                    job_result = job_model.results.get(pk=job_result_pk)",
            "                    # Allow explicitly specified arg values in request.GET to take precedence over the saved job_kwargs,",
            "                    # for example \"?kwargs_from_job_result=<UUID>&integervar=22&_commit=False\"",
            "                    explicit_initial = initial",
            "                    initial = job_result.job_kwargs.get(\"data\", {}).copy()",
            "                    commit = job_result.job_kwargs.get(\"commit\")",
            "                    if commit is not None:",
            "                        initial.setdefault(\"_commit\", commit)",
            "                    task_queue = job_result.job_kwargs.get(\"task_queue\")",
            "                    if task_queue is not None:",
            "                        initial.setdefault(\"_task_queue\", task_queue)",
            "                    initial.update(explicit_initial)",
            "                except JobResult.DoesNotExist:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"JobResult {job_result_pk} not found, cannot use it to pre-populate inputs.\",",
            "                    )",
            "",
            "            template_name = \"extras/job.html\"",
            "            job_form = job_class.as_form(initial=initial)",
            "            if hasattr(job_class, \"template_name\"):",
            "                try:",
            "                    get_template(job_class.template_name)",
            "                    template_name = job_class.template_name",
            "                except TemplateDoesNotExist as err:",
            "                    messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "        except RuntimeError as err:",
            "            messages.error(request, f\"Unable to run or schedule '{job_model}': {err}\")",
            "            return redirect(\"extras:job_list\")",
            "",
            "        schedule_form = forms.JobScheduleForm(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            template_name,  # 2.0 TODO: extras/job_submission.html",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "    def post(self, request, class_path=None, slug=None):",
            "        job_model = self._get_job_model_or_404(class_path, slug)",
            "",
            "        job_form = (",
            "            job_model.job_class().as_form(request.POST, request.FILES) if job_model.job_class is not None else None",
            "        )",
            "        schedule_form = forms.JobScheduleForm(request.POST)",
            "        task_queue = request.POST.get(\"_task_queue\")",
            "",
            "        return_url = request.POST.get(\"_return_url\")",
            "        if return_url is not None and url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "            return_url = iri_to_uri(return_url)",
            "        else:",
            "            return_url = None",
            "",
            "        # Allow execution only if a worker process is running and the job is runnable.",
            "        if not get_worker_count(queue=task_queue):",
            "            messages.error(request, \"Unable to run or schedule job: Celery worker process not running.\")",
            "        elif not job_model.installed or job_model.job_class is None:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not presently installed.\")",
            "        elif not job_model.enabled:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not enabled to be run.\")",
            "        elif (",
            "            job_model.has_sensitive_variables",
            "            and request.POST.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY",
            "        ):",
            "            messages.error(request, \"Unable to schedule job: Job may have sensitive input variables.\")",
            "        elif job_model.has_sensitive_variables and job_model.approval_required:",
            "            messages.error(",
            "                request,",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "            )",
            "        elif job_form is not None and job_form.is_valid() and schedule_form.is_valid():",
            "            # Run the job. A new JobResult is created.",
            "            commit = job_form.cleaned_data.pop(\"_commit\")",
            "            profile = job_form.cleaned_data.pop(\"_profile\")",
            "            schedule_type = schedule_form.cleaned_data[\"_schedule_type\"]",
            "",
            "            if job_model.approval_required or schedule_type in JobExecutionType.SCHEDULE_CHOICES:",
            "                crontab = \"\"",
            "",
            "                if schedule_type == JobExecutionType.TYPE_IMMEDIATELY:",
            "                    # The job must be approved.",
            "                    # If the schedule_type is immediate, we still create the task, but mark it for approval",
            "                    # as a once in the future task with the due date set to the current time. This means",
            "                    # when approval is granted, the task is immediately due for execution.",
            "                    schedule_type = JobExecutionType.TYPE_FUTURE",
            "                    schedule_datetime = timezone.now()",
            "                    schedule_name = f\"{job_model} - {schedule_datetime}\"",
            "",
            "                else:",
            "                    schedule_name = schedule_form.cleaned_data[\"_schedule_name\"]",
            "",
            "                    if schedule_type == JobExecutionType.TYPE_CUSTOM:",
            "                        crontab = schedule_form.cleaned_data[\"_recurrence_custom_time\"]",
            "                        # doing .get(\"key\", \"default\") returns None instead of \"default\" here for some reason",
            "                        schedule_datetime = schedule_form.cleaned_data.get(\"_schedule_start_time\")",
            "                        if schedule_datetime is None:",
            "                            # \"_schedule_start_time\" is checked against ScheduledJob.earliest_possible_time()",
            "                            # which returns timezone.now() + timedelta(seconds=15)",
            "                            schedule_datetime = timezone.now() + timedelta(seconds=20)",
            "                    else:",
            "                        schedule_datetime = schedule_form.cleaned_data[\"_schedule_start_time\"]",
            "",
            "                job_kwargs = {",
            "                    \"data\": job_model.job_class.serialize_data(job_form.cleaned_data),",
            "                    \"request\": copy_safe_request(request),",
            "                    \"user\": request.user.pk,",
            "                    \"commit\": commit,",
            "                    \"name\": job_model.class_path,",
            "                    \"task_queue\": job_form.cleaned_data.get(\"_task_queue\", None),",
            "                }",
            "                if task_queue:",
            "                    job_kwargs[\"celery_kwargs\"] = {\"queue\": task_queue}",
            "",
            "                scheduled_job = ScheduledJob(",
            "                    name=schedule_name,",
            "                    task=\"nautobot.extras.jobs.scheduled_job_handler\",",
            "                    job_class=job_model.class_path,",
            "                    job_model=job_model,",
            "                    start_time=schedule_datetime,",
            "                    description=f\"Nautobot job {schedule_name} scheduled by {request.user} for {schedule_datetime}\",",
            "                    kwargs=job_kwargs,",
            "                    interval=schedule_type,",
            "                    one_off=schedule_type == JobExecutionType.TYPE_FUTURE,",
            "                    queue=task_queue,",
            "                    user=request.user,",
            "                    approval_required=job_model.approval_required,",
            "                    crontab=crontab,",
            "                )",
            "                scheduled_job.save()",
            "",
            "                if job_model.approval_required:",
            "                    messages.success(request, f\"Job {schedule_name} successfully submitted for approval\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_approval_queue_list\")",
            "                else:",
            "                    messages.success(request, f\"Job {schedule_name} successfully scheduled\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_list\")",
            "",
            "            else:",
            "                # Enqueue job for immediate execution",
            "                job_content_type = get_job_content_type()",
            "                job_result = JobResult.enqueue_job(",
            "                    run_job,",
            "                    job_model.class_path,",
            "                    job_content_type,",
            "                    request.user,",
            "                    celery_kwargs={\"queue\": task_queue},",
            "                    data=job_model.job_class.serialize_data(job_form.cleaned_data),",
            "                    request=copy_safe_request(request),",
            "                    commit=commit,",
            "                    profile=profile,",
            "                    task_queue=job_form.cleaned_data.get(\"_task_queue\", None),",
            "                )",
            "",
            "                if return_url:",
            "                    messages.info(",
            "                        request,",
            "                        format_html(",
            "                            'Job enqueued. <a href=\"{}\">Click here for the results.</a>',",
            "                            job_result.get_absolute_url(),",
            "                        ),",
            "                    )",
            "                    return redirect(return_url)",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "",
            "        if return_url:",
            "            return redirect(return_url)",
            "",
            "        template_name = \"extras/job.html\"",
            "        if job_model.job_class is not None and hasattr(job_model.job_class, \"template_name\"):",
            "            try:",
            "                get_template(job_model.job_class.template_name)",
            "                template_name = job_model.job_class.template_name",
            "            except TemplateDoesNotExist as err:",
            "                messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "",
            "        return render(",
            "            request,",
            "            template_name,",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "",
            "# 2.0 TODO: this should really be \"JobView\"",
            "class JobDetailView(generic.ObjectView):",
            "    queryset = JobModel.objects.all()",
            "    template_name = \"extras/job_detail.html\"",
            "",
            "",
            "class JobEditView(generic.ObjectEditView):",
            "    queryset = JobModel.objects.all()",
            "    model_form = forms.JobEditForm",
            "    template_name = \"extras/job_edit.html\"",
            "",
            "",
            "class JobDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobModel.objects.all()",
            "",
            "",
            "class JobApprovalRequestView(generic.ObjectView):",
            "    \"\"\"",
            "    This view handles requests to view and approve a Job execution request.",
            "    It renders the Job's form in much the same way as `JobView` except all",
            "    form fields are disabled and actions on the form relate to approval of the",
            "    job's execution, rather than initial job form input.",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.filter(task=\"nautobot.extras.jobs.scheduled_job_handler\").needs_approved()",
            "    template_name = \"extras/job_approval_request.html\"",
            "    additional_permissions = (\"extras.view_job\",)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Render the job form with data from the scheduled_job instance, but mark all fields as disabled.",
            "        We don't care to actually get any data back from the form as we will not ever change it.",
            "        Instead, we offer the user three submit buttons, dry-run, approve, and deny, which we act upon in the post.",
            "        \"\"\"",
            "        job_model = instance.job_model",
            "        if job_model is not None:",
            "            job_class = job_model.job_class",
            "        else:",
            "            # 2.0 TODO: remove this fallback?",
            "            job_class = get_job(instance.job_class)",
            "",
            "        if job_class is not None:",
            "            # Render the form with all fields disabled",
            "            initial = instance.kwargs.get(\"data\", {})",
            "            initial[\"_commit\"] = instance.kwargs.get(\"commit\", True)",
            "            job_form = job_class().as_form(initial=initial, approval_view=True)",
            "        else:",
            "            job_form = None",
            "",
            "        return {",
            "            \"job_form\": job_form,",
            "        }",
            "",
            "    def post(self, request, pk):",
            "        \"\"\"",
            "        Act upon one of the 3 submit button actions from the user.",
            "",
            "        dry-run will immediately enqueue the job with commit=False and send the user to the normal JobResult view",
            "        deny will delete the scheduled_job instance",
            "        approve will mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        \"\"\"",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        post_data = request.POST",
            "",
            "        deny = \"_deny\" in post_data",
            "        approve = \"_approve\" in post_data",
            "        force_approve = \"_force_approve\" in post_data",
            "        dry_run = \"_dry_run\" in post_data",
            "",
            "        job_model = scheduled_job.job_model",
            "",
            "        if dry_run:",
            "            # To dry-run a job, a user needs the same permissions that would be needed to run the job directly",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not job_model.runnable:",
            "                messages.error(request, \"This job cannot be run at this time\")",
            "            elif not JobModel.objects.check_perms(self.request.user, instance=job_model, action=\"run\"):",
            "                messages.error(request, \"You do not have permission to run this job\")",
            "            else:",
            "                # Immediately enqueue the job with commit=False and send the user to the normal JobResult view",
            "                job_content_type = get_job_content_type()",
            "                initial = scheduled_job.kwargs.get(\"data\", {})",
            "                initial[\"_commit\"] = False",
            "                celery_kwargs = scheduled_job.kwargs.get(\"celery_kwargs\", {})",
            "                job_result = JobResult.enqueue_job(",
            "                    run_job,",
            "                    job_model.job_class.class_path,",
            "                    job_content_type,",
            "                    request.user,",
            "                    celery_kwargs=celery_kwargs,",
            "                    data=job_model.job_class.serialize_data(initial),",
            "                    request=copy_safe_request(request),",
            "                    commit=False,  # force a dry-run",
            "                    task_queue=scheduled_job.kwargs.get(\"task_queue\", None),",
            "                )",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "        elif deny:",
            "            if not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"delete\")",
            "                and job_model is not None",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to deny this request.\")",
            "            else:",
            "                # Delete the scheduled_job instance",
            "                scheduled_job.delete()",
            "                if request.user == scheduled_job.user:",
            "                    messages.error(request, f\"Approval request for {scheduled_job.name} was revoked\")",
            "                else:",
            "                    messages.error(request, f\"Approval of {scheduled_job.name} was denied\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        elif approve or force_approve:",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"change\")",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to approve this request.\")",
            "            elif request.user == scheduled_job.user:",
            "                # The requestor *cannot* approve their own job",
            "                messages.error(request, \"You cannot approve your own job request!\")",
            "            else:",
            "                # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "                if scheduled_job.one_off and scheduled_job.start_time < timezone.now() and not force_approve:",
            "                    return render(request, \"extras/job_approval_confirmation.html\", {\"scheduled_job\": scheduled_job})",
            "                scheduled_job.approved_by_user = request.user",
            "                scheduled_job.approved_at = timezone.now()",
            "                scheduled_job.save()",
            "",
            "                messages.success(request, f\"{scheduled_job.name} was approved and will now begin execution\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        return render(",
            "            request,",
            "            self.get_template_name(),",
            "            {",
            "                \"object\": scheduled_job,",
            "                **self.get_extra_context(request, scheduled_job),",
            "            },",
            "        )",
            "",
            "",
            "class ScheduledJobListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.filter(task=\"nautobot.extras.jobs.scheduled_job_handler\").enabled()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "",
            "",
            "class ScheduledJobBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "",
            "",
            "class ScheduledJobApprovalQueueListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.filter(task=\"nautobot.extras.jobs.scheduled_job_handler\").needs_approved()",
            "    table = tables.ScheduledJobApprovalQueueTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "    template_name = \"extras/scheduled_jobs_approval_queue_list.html\"",
            "",
            "",
            "class ScheduledJobView(generic.ObjectView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        job_class = get_job(instance.job_class)",
            "        labels = {}",
            "        if job_class is not None:",
            "            for name, var in job_class._get_vars().items():",
            "                field = var.as_field()",
            "                if field.label:",
            "                    labels[name] = var",
            "                else:",
            "                    labels[name] = pretty_name(name)",
            "        return {\"labels\": labels, \"job_class_found\": (job_class is not None)}",
            "",
            "",
            "class ScheduledJobDeleteView(generic.ObjectDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "",
            "#",
            "# Job hooks",
            "#",
            "",
            "",
            "class JobHookListView(generic.ObjectListView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "    filterset = filters.JobHookFilterSet",
            "    filterset_form = forms.JobHookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class JobHookView(generic.ObjectView):",
            "    queryset = JobHook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"content_types\": instance.content_types.order_by(\"app_label\", \"model\")}",
            "",
            "",
            "class JobHookEditView(generic.ObjectEditView):",
            "    queryset = JobHook.objects.all()",
            "    model_form = forms.JobHookForm",
            "",
            "",
            "class JobHookDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobHook.objects.all()",
            "",
            "",
            "class JobHookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "",
            "",
            "#",
            "# JobResult",
            "#",
            "",
            "",
            "class JobResultListView(generic.ObjectListView):",
            "    \"\"\"",
            "    List JobResults",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.defer(\"data\").select_related(\"job_model\", \"obj_type\", \"user\").prefetch_related(\"logs\")",
            "    filterset = filters.JobResultFilterSet",
            "    filterset_form = forms.JobResultFilterForm",
            "    table = tables.JobResultTable",
            "    action_buttons = ()",
            "",
            "",
            "class JobResultDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobResult.objects.all()",
            "",
            "",
            "class JobResultBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobResult.objects.defer(\"data\").all()",
            "    table = tables.JobResultTable",
            "",
            "",
            "class JobResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.prefetch_related(\"job_model\", \"obj_type\", \"user\")",
            "    template_name = \"extras/jobresult.html\"",
            "",
            "    def instance_to_csv(self, instance):",
            "        \"\"\"Format instance to csv.\"\"\"",
            "        csv_data = []",
            "        headers = JobLogEntry.csv_headers.copy()",
            "        csv_data.append(\",\".join(headers))",
            "",
            "        for log_entry in instance.logs.all():",
            "            data = log_entry.to_csv()",
            "            csv_data.append(csv_format(data))",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Generic GET handler for accessing an object by PK or slug",
            "        \"\"\"",
            "        instance = get_object_or_404(self.queryset, **kwargs)",
            "",
            "        if \"export\" in request.GET:",
            "            response = HttpResponse(self.instance_to_csv(instance), content_type=\"text/csv\")",
            "            underscore_filename = f\"{instance.job_model.slug.replace('-', '_')}\"",
            "            formated_completion_time = instance.completed.strftime(\"%Y-%m-%d_%H_%M\")",
            "            filename = f\"{underscore_filename}_{formated_completion_time}_logs.csv\"",
            "            response[\"Content-Disposition\"] = f\"attachment; filename={filename}\"",
            "            return response",
            "",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        associated_record = None",
            "        job_class = None",
            "        if instance.job_model is not None:",
            "            job_class = instance.job_model.job_class",
            "        # 2.0 TODO: remove JobResult.related_object entirely",
            "        related_object = instance.related_object",
            "        if inspect.isclass(related_object) and issubclass(related_object, JobClass):",
            "            if job_class is None:",
            "                job_class = related_object",
            "        elif related_object:",
            "            associated_record = related_object",
            "",
            "        return {",
            "            \"job\": job_class,",
            "            \"associated_record\": associated_record,",
            "            \"result\": instance,",
            "        }",
            "",
            "",
            "class JobLogEntryTableView(generic.GenericView):",
            "    \"\"\"",
            "    Display a table of `JobLogEntry` objects for a given `JobResult` instance.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.all()",
            "",
            "    def get(self, request, pk=None):",
            "        instance = get_object_or_404(self.queryset.restrict(request.user, \"view\"), pk=pk)",
            "        log_table = tables.JobLogEntryTable(data=instance.logs.all(), user=request.user)",
            "        RequestConfig(request).configure(log_table)",
            "        return HttpResponse(log_table.as_html(request))",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.JobButtonBulkEditForm",
            "    filterset_class = filters.JobButtonFilterSet",
            "    filterset_form_class = forms.JobButtonFilterForm",
            "    form_class = forms.JobButtonForm",
            "    lookup_field = \"pk\"",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    table_class = tables.JobButtonTable",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeListView(generic.ObjectListView):",
            "    queryset = ObjectChange.objects.all()",
            "    filterset = filters.ObjectChangeFilterSet",
            "    filterset_form = forms.ObjectChangeFilterForm",
            "    table = tables.ObjectChangeTable",
            "    template_name = \"extras/objectchange_list.html\"",
            "    action_buttons = (\"export\",)",
            "",
            "    # 2.0 TODO: Remove this remapping and solve it at the `BaseFilterSet` as it is addressing a breaking change.",
            "    def get(self, request, **kwargs):",
            "        # Remappings below allow previous queries of time_before and time_after to use",
            "        # newer methods specifying the lookup method.",
            "",
            "        # They will only use the previous arguments if the newer ones are undefined",
            "",
            "        if request.GET.get(\"time_after\") and request.GET.get(\"time__gte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__gte\": request.GET.get(\"time_after\")})",
            "            request.GET._mutable = False",
            "",
            "        if request.GET.get(\"time_before\") and request.GET.get(\"time__lte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__lte\": request.GET.get(\"time_before\")})",
            "            request.GET._mutable = False",
            "",
            "        return super().get(request=request, **kwargs)",
            "",
            "",
            "class ObjectChangeView(generic.ObjectView):",
            "    queryset = ObjectChange.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_changes = instance.get_related_changes(user=request.user).filter(request_id=instance.request_id)",
            "        related_changes_table = tables.ObjectChangeTable(data=related_changes[:50], orderable=False)",
            "",
            "        snapshots = instance.get_snapshots()",
            "        return {",
            "            \"diff_added\": snapshots[\"differences\"][\"added\"],",
            "            \"diff_removed\": snapshots[\"differences\"][\"removed\"],",
            "            \"next_change\": instance.get_next_change(request.user),",
            "            \"prev_change\": instance.get_prev_change(request.user),",
            "            \"related_changes_table\": related_changes_table,",
            "            \"related_changes_count\": related_changes.count(),",
            "        }",
            "",
            "",
            "class ObjectChangeLogView(generic.GenericView):",
            "    \"\"\"",
            "    Present a history of changes made to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all changes for this object (and its related objects)",
            "        content_type = ContentType.objects.get_for_model(model)",
            "        objectchanges = (",
            "            ObjectChange.objects.restrict(request.user, \"view\")",
            "            .select_related(\"user\", \"changed_object_type\")",
            "            .filter(",
            "                Q(changed_object_type=content_type, changed_object_id=obj.pk)",
            "                | Q(related_object_type=content_type, related_object_id=obj.pk)",
            "            )",
            "        )",
            "        objectchanges_table = tables.ObjectChangeTable(data=objectchanges, orderable=False)",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(objectchanges_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_changelog.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": objectchanges_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"changelog\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteView(generic.ObjectView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class NoteEditView(generic.ObjectEditView):",
            "    queryset = Note.objects.all()",
            "    model_form = forms.NoteForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        obj.user = request.user",
            "        return obj",
            "",
            "",
            "class NoteDeleteView(generic.ObjectDeleteView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class ObjectNotesView(generic.GenericView):",
            "    \"\"\"",
            "    Present a history of changes made to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        notes_form = forms.NoteForm(",
            "            initial={",
            "                \"assigned_object_type\": ContentType.objects.get_for_model(obj),",
            "                \"assigned_object_id\": obj.pk,",
            "            }",
            "        )",
            "        notes_table = tables.NoteTable(obj.notes.restrict(request.user, \"view\"))",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(notes_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_notes.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": notes_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"notes\",",
            "                \"form\": notes_form,",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipListView(generic.ObjectListView):",
            "    queryset = Relationship.objects.all()",
            "    filterset = filters.RelationshipFilterSet",
            "    filterset_form = forms.RelationshipFilterForm",
            "    table = tables.RelationshipTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class RelationshipView(generic.ObjectView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipEditView(generic.ObjectEditView):",
            "    queryset = Relationship.objects.all()",
            "    model_form = forms.RelationshipForm",
            "    template_name = \"extras/relationship_edit.html\"",
            "",
            "",
            "class RelationshipBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Relationship.objects.all()",
            "    table = tables.RelationshipTable",
            "",
            "",
            "class RelationshipDeleteView(generic.ObjectDeleteView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipAssociationListView(generic.ObjectListView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    filterset = filters.RelationshipAssociationFilterSet",
            "    filterset_form = forms.RelationshipAssociationFilterForm",
            "    table = tables.RelationshipAssociationTable",
            "    action_buttons = ()",
            "",
            "",
            "class RelationshipAssociationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    table = tables.RelationshipAssociationTable",
            "",
            "",
            "class RelationshipAssociationDeleteView(generic.ObjectDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretListView(generic.ObjectListView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    filterset_form = forms.SecretFilterForm",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretView(generic.ObjectView):",
            "    queryset = Secret.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        provider = registry[\"secrets_providers\"].get(instance.provider)",
            "",
            "        groups = instance.groups.distinct()",
            "        groups_table = tables.SecretsGroupTable(groups, orderable=False)",
            "",
            "        return {",
            "            \"format\": format_,",
            "            \"provider_name\": provider.name if provider else instance.provider,",
            "            \"groups_table\": groups_table,",
            "        }",
            "",
            "",
            "class SecretProviderParametersFormView(generic.GenericView):",
            "    \"\"\"",
            "    Helper view to SecretView; retrieve the HTML form appropriate for entering parameters for a given SecretsProvider.",
            "    \"\"\"",
            "",
            "    def get(self, request, provider_slug):",
            "        provider = registry[\"secrets_providers\"].get(provider_slug)",
            "        if not provider:",
            "            raise Http404",
            "        return render(",
            "            request,",
            "            \"extras/inc/secret_provider_parameters_form.html\",",
            "            {\"form\": provider.ParametersForm(initial=request.GET)},",
            "        )",
            "",
            "",
            "class SecretEditView(generic.ObjectEditView):",
            "    queryset = Secret.objects.all()",
            "    model_form = forms.SecretForm",
            "    template_name = \"extras/secret_edit.html\"",
            "",
            "",
            "class SecretDeleteView(generic.ObjectDeleteView):",
            "    queryset = Secret.objects.all()",
            "",
            "",
            "class SecretBulkImportView(generic.BulkImportView):",
            "    queryset = Secret.objects.all()",
            "    model_form = forms.SecretCSVForm",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretsGroupListView(generic.ObjectListView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    filterset_form = forms.SecretsGroupFilterForm",
            "    table = tables.SecretsGroupTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class SecretsGroupView(generic.ObjectView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"secrets_group_associations\": SecretsGroupAssociation.objects.filter(group=instance)}",
            "",
            "",
            "class SecretsGroupEditView(generic.ObjectEditView):",
            "    queryset = SecretsGroup.objects.all()",
            "    model_form = forms.SecretsGroupForm",
            "    template_name = \"extras/secretsgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for secrets",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    secrets = ctx[\"secrets\"]",
            "                    if secrets.is_valid():",
            "                        secrets.save()",
            "                    else:",
            "                        raise RuntimeError(secrets.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                else:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving secrets group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class SecretsGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "",
            "class SecretsGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    table = tables.SecretsGroupTable",
            "",
            "",
            "#",
            "# Custom statuses",
            "#",
            "",
            "",
            "class StatusListView(generic.ObjectListView):",
            "    \"\"\"List `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    filterset = filters.StatusFilterSet",
            "    filterset_form = forms.StatusFilterForm",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusEditView(generic.ObjectEditView):",
            "    \"\"\"Edit a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    model_form = forms.StatusForm",
            "",
            "",
            "class StatusBulkEditView(generic.BulkEditView):",
            "    \"\"\"Edit multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "    form = forms.StatusBulkEditForm",
            "",
            "",
            "class StatusBulkDeleteView(generic.BulkDeleteView):",
            "    \"\"\"Delete multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusDeleteView(generic.ObjectDeleteView):",
            "    \"\"\"Delete a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "",
            "class StatusBulkImportView(generic.BulkImportView):",
            "    \"\"\"Bulk CSV import of multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    model_form = forms.StatusCSVForm",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusView(generic.ObjectView):",
            "    \"\"\"Detail view for a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"Return ordered content types.\"\"\"",
            "        return {\"content_types\": instance.content_types.order_by(\"app_label\", \"model\")}",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagListView(generic.ObjectListView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    filterset = filters.TagFilterSet",
            "    filterset_form = forms.TagFilterForm",
            "    table = tables.TagTable",
            "",
            "",
            "class TagView(generic.ObjectView):",
            "    queryset = Tag.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        tagged_items = (",
            "            TaggedItem.objects.filter(tag=instance).select_related(\"content_type\").prefetch_related(\"content_object\")",
            "        )",
            "",
            "        # Generate a table of all items tagged with this Tag",
            "        items_table = tables.TaggedItemTable(tagged_items)",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(items_table)",
            "",
            "        return {",
            "            \"items_count\": tagged_items.count(),",
            "            \"items_table\": items_table,",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "        }",
            "",
            "",
            "class TagEditView(generic.ObjectEditView):",
            "    queryset = Tag.objects.all()",
            "    model_form = forms.TagForm",
            "    template_name = \"extras/tag_edit.html\"",
            "",
            "",
            "class TagDeleteView(generic.ObjectDeleteView):",
            "    queryset = Tag.objects.all()",
            "",
            "",
            "class TagBulkImportView(generic.BulkImportView):",
            "    queryset = Tag.objects.all()",
            "    model_form = forms.TagCSVForm",
            "    table = tables.TagTable",
            "",
            "",
            "class TagBulkEditView(generic.BulkEditView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "    form = forms.TagBulkEditForm",
            "",
            "",
            "class TagBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookListView(generic.ObjectListView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "    filterset = filters.WebhookFilterSet",
            "    filterset_form = forms.WebhookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class WebhookView(generic.ObjectView):",
            "    queryset = Webhook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"content_types\": instance.content_types.order_by(\"app_label\", \"model\")}",
            "",
            "",
            "class WebhookEditView(generic.ObjectEditView):",
            "    queryset = Webhook.objects.all()",
            "    model_form = forms.WebhookForm",
            "",
            "",
            "class WebhookDeleteView(generic.ObjectDeleteView):",
            "    queryset = Webhook.objects.all()",
            "",
            "",
            "class WebhookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "",
            "",
            "#",
            "# Job Extra Views",
            "#",
            "# NOTE: Due to inheritance, JobObjectChangeLogView and JobObjectNotesView can only be",
            "# constructed below # ObjectChangeLogView and ObjectNotesView.",
            "",
            "",
            "class JobObjectChangeLogView(ObjectChangeLogView):",
            "    base_template = \"extras/job_detail.html\"",
            "",
            "",
            "class JobObjectNotesView(ObjectNotesView):",
            "    base_template = \"extras/job_detail.html\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "553": [
                "DynamicGroupView",
                "get_extra_context"
            ],
            "725": [
                "ObjectDynamicGroupsView",
                "get"
            ]
        },
        "addLocation": []
    },
    "nautobot/utilities/testing/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "                             escape(str(instance.cf.get(custom_field.name) or \"\")), response_body, msg=response_body"
            },
            "1": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "                         )"
            },
            "2": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 211,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+            return response  # for consumption by child test cases if desired"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         @override_settings(EXEMPT_VIEW_PERMISSIONS=[])"
            },
            "6": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "         def test_get_object_with_constrained_permission(self):"
            },
            "7": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "             instance1, instance2 = self._get_queryset().all()[:2]"
            },
            "8": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "             obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))"
            },
            "9": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 229,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "             # Try GET to permitted object"
            },
            "11": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertHttpStatus(self.client.get(instance1.get_absolute_url()), 200)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+            response = self.client.get(instance1.get_absolute_url())"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            self.assertHttpStatus(response, 200)"
            },
            "14": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             # Try GET to non-permitted object"
            },
            "16": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             self.assertHttpStatus(self.client.get(instance2.get_absolute_url()), 404)"
            },
            "17": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+            return response  # for consumption by child test cases if desired"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         @override_settings(EXEMPT_VIEW_PERMISSIONS=[])"
            },
            "21": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         def test_has_advanced_tab(self):"
            },
            "22": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "             instance = self._get_queryset().first()"
            }
        },
        "frontPatchFile": [
            "import csv",
            "import re",
            "from io import StringIO",
            "from tree_queries.models import TreeNode",
            "from typing import Optional, Sequence",
            "from unittest import skipIf",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import TestCase as _TestCase, override_settings, tag",
            "from django.urls import reverse, NoReverseMatch",
            "from django.utils.text import slugify",
            "from django.utils.html import escape",
            "from django.utils.http import urlencode",
            "",
            "from nautobot.core.models.generics import PrimaryModel",
            "from nautobot.extras.choices import CustomFieldTypeChoices, RelationshipSideChoices, ObjectChangeActionChoices",
            "from nautobot.extras.forms.mixins import CustomFieldModelFormMixin, RelationshipModelFormMixin",
            "from nautobot.extras.models import ChangeLoggedModel, CustomField, CustomFieldModel, Relationship, RelationshipModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.templatetags.helpers import bettertitle, validated_viewname",
            "from nautobot.utilities.testing.mixins import NautobotTestCaseMixin",
            "from nautobot.utilities.utils import get_changes_for_model, get_filterset_for_model, get_form_for_model, csv_format",
            "from .utils import disable_warnings, extract_page_body, get_deletable_objects, post_data",
            "",
            "",
            "__all__ = (",
            "    \"TestCase\",",
            "    \"ModelTestCase\",",
            "    \"ModelViewTestCase\",",
            "    \"ViewTestCases\",",
            ")",
            "",
            "",
            "@tag(\"unit\")",
            "@override_settings(PAGINATE_COUNT=65000)",
            "class TestCase(NautobotTestCaseMixin, _TestCase):",
            "    \"\"\"Base class for all Nautobot-specific unit tests.\"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"Initialize user and client.\"\"\"",
            "        super().setUpNautobot()",
            "",
            "",
            "class ModelTestCase(TestCase):",
            "    \"\"\"",
            "    Parent class for TestCases which deal with models.",
            "    \"\"\"",
            "",
            "    model = None",
            "    # Optional, list of Relationships populated in setUpTestData for testing with this model",
            "    # Be sure to also create RelationshipAssociations using these Relationships!",
            "    relationships: Optional[Sequence[Relationship]] = None",
            "    # Optional, list of CustomFields populated in setUpTestData for testing with this model",
            "    # Be sure to also populate these fields on your test data!",
            "    custom_fields: Optional[Sequence[CustomField]] = None",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"",
            "        Return a base queryset suitable for use in test methods.",
            "        \"\"\"",
            "        return self.model.objects.all()",
            "",
            "",
            "#",
            "# UI Tests",
            "#",
            "",
            "",
            "@tag(\"performance\")",
            "class ModelViewTestCase(ModelTestCase):",
            "    \"\"\"",
            "    Base TestCase for model views. Subclass to test individual views.",
            "    \"\"\"",
            "",
            "    reverse_url_attribute = None",
            "    \"\"\"",
            "    Name of instance field to pass as a kwarg when looking up action URLs for creating/editing/deleting a model instance.",
            "",
            "    If unspecified, \"slug\" and \"pk\" will be tried, in that order.",
            "    \"\"\"",
            "",
            "    # 2.0 TODO(jathan): Eliminate the need to overload `_get_base_url()` at all and just rely on `get_route_for_model()`",
            "    def _get_base_url(self):",
            "        \"\"\"",
            "        Return the base format for a URL for the test's model. Override this to test for a model which belongs",
            "        to a different app (e.g. testing Interfaces within the virtualization app).",
            "        \"\"\"",
            "        if self.model._meta.app_label in settings.PLUGINS:",
            "            return f\"plugins:{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "        return f\"{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "",
            "    # 2.0 TODO(jathan): Eliminate the need to overload `_get_url()` at all and just rely on `get_route_for_model()`",
            "    def _get_url(self, action, instance=None):",
            "        \"\"\"",
            "        Return the URL name for a specific action and optionally a specific instance",
            "        \"\"\"",
            "        url_format = self._get_base_url()",
            "",
            "        # If no instance was provided, assume we don't need a unique identifier",
            "        if instance is None:",
            "            return reverse(url_format.format(action))",
            "",
            "        if self.reverse_url_attribute:",
            "            return reverse(",
            "                url_format.format(action),",
            "                kwargs={self.reverse_url_attribute: getattr(instance, self.reverse_url_attribute)},",
            "            )",
            "",
            "        # Attempt to resolve using slug as the unique identifier if one exists",
            "        if hasattr(self.model, \"slug\"):",
            "            try:",
            "                return reverse(url_format.format(action), kwargs={\"slug\": instance.slug})",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        # Default to using the numeric PK to retrieve the URL for an object",
            "        return reverse(url_format.format(action), kwargs={\"pk\": instance.pk})",
            "",
            "",
            "@tag(\"unit\")",
            "class ViewTestCases:",
            "    \"\"\"",
            "    We keep any TestCases with test_* methods inside a class to prevent unittest from trying to run them.",
            "    \"\"\"",
            "",
            "    class GetObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve a single instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_queryset().first().get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(",
            "                \"/login/?next=\" + self._get_queryset().first().get_absolute_url(), response_body, msg=response_body",
            "            )",
            "",
            "            # The \"Change Log\" tab should appear in the response since we have all exempt permissions",
            "            if issubclass(self.model, ChangeLoggedModel):",
            "                response_body = extract_page_body(response.content.decode(response.charset))",
            "                self.assertIn(\"Change Log\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                response = self.client.get(instance.get_absolute_url())",
            "                self.assertHttpStatus(response, [403, 404])",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(instance.get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "",
            "            # The object's display name or string representation should appear in the response",
            "            self.assertIn(escape(getattr(instance, \"display\", str(instance))), response_body, msg=response_body)",
            "",
            "            # If any Relationships are defined, they should appear in the response",
            "            if self.relationships is not None:",
            "                for relationship in self.relationships:  # false positive pylint: disable=not-an-iterable",
            "                    content_type = ContentType.objects.get_for_model(instance)",
            "                    if content_type == relationship.source_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(RelationshipSideChoices.SIDE_SOURCE)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "                    if content_type == relationship.destination_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(RelationshipSideChoices.SIDE_DESTINATION)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "",
            "            # If any Custom Fields are defined, they should appear in the response",
            "            if self.custom_fields is not None:",
            "                for custom_field in self.custom_fields:  # false positive pylint: disable=not-an-iterable",
            "                    self.assertIn(escape(str(custom_field)), response_body, msg=response_body)",
            "                    # 2.0 TODO: #824 custom_field.slug rather than custom_field.name",
            "                    if custom_field.type == CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "                        for value in instance.cf.get(custom_field.name):",
            "                            self.assertIn(escape(str(value)), response_body, msg=response_body)",
            "                    else:",
            "                        self.assertIn(",
            "                            escape(str(instance.cf.get(custom_field.name) or \"\")), response_body, msg=response_body",
            "                        )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                # To get a different rendering flow than the `test_get_object_with_permission` test above,",
            "                # enable additional permissions for this object so that add/edit/delete buttons are rendered.",
            "                actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET to permitted object",
            "            self.assertHttpStatus(self.client.get(instance1.get_absolute_url()), 200)",
            "",
            "            # Try GET to non-permitted object",
            "            self.assertHttpStatus(self.client.get(instance2.get_absolute_url()), 404)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_has_advanced_tab(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            response = self.client.get(instance.get_absolute_url())",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            advanced_tab_href = f\"{instance.get_absolute_url()}#advanced\"",
            "",
            "            self.assertIn(advanced_tab_href, response_body)",
            "            self.assertIn(\"Advanced\", response_body)",
            "",
            "    class GetObjectChangelogViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the changelog for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_changelog(self):",
            "            url = self._get_url(\"changelog\", self._get_queryset().first())",
            "            response = self.client.get(url)",
            "            self.assertHttpStatus(response, 200)",
            "",
            "    class GetObjectNotesViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the notes for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_notes(self):",
            "            if hasattr(self.model, \"notes\"):",
            "                url = self._get_url(\"notes\", self._get_queryset().first())",
            "                response = self.client.get(url)",
            "                self.assertHttpStatus(response, 200)",
            "",
            "    class CreateObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create a single new instance.",
            "",
            "        :form_data: Data to be used when creating a new object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "        slug_source = None",
            "        slugify_function = staticmethod(slugify)",
            "        slug_test_object = \"\"",
            "",
            "        def test_create_object_without_permission(self):",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 403)",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            response = self.client.post(**request)",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(response, 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                instance = self._get_queryset().get(slug=self.form_data.get(\"slug\"))",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    instance = self._get_queryset().order_by(\"last_updated\").last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "                else:",
            "                    instance = self._get_queryset().last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_CREATE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try to create an object (not permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(initial_count, self._get_queryset().count())  # Check that no object was created",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}",
            "            obj_perm.save()",
            "",
            "            # Try to create an object (permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                instance = self._get_queryset().get(slug=self.form_data.get(\"slug\"))",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    self.assertInstanceEqual(self._get_queryset().order_by(\"last_updated\").last(), self.form_data)",
            "                else:",
            "                    self.assertInstanceEqual(self._get_queryset().last(), self.form_data)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_extra_feature_form_fields_present(self):",
            "            model_class = self.model",
            "            model_form = get_form_for_model(model_class)",
            "            fields = model_form.base_fields",
            "            if isinstance(model_class, CustomFieldModel):",
            "                self.assertTrue(issubclass(CustomFieldModelFormMixin, model_form))",
            "            if isinstance(model_class, RelationshipModel):",
            "                self.assertTrue(issubclass(RelationshipModelFormMixin, model_form))",
            "            if isinstance(model_class, NotesMixin):",
            "                self.assertIsNotNone(fields.get(\"object_note\"))",
            "            if isinstance(model_class, PrimaryModel):",
            "                self.assertIsNotNone(fields.get(\"tags\"))",
            "",
            "        def test_slug_autocreation(self):",
            "            \"\"\"Test that slug is autocreated through ORM.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if self.slug_source is not None:",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "        def test_slug_not_modified(self):",
            "            \"\"\"Ensure save method does not modify slug that is passed in.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if self.slug_source is not None:",
            "                new_slug_source_value = \"kwyjibo\"",
            "",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                # Update slug source field str",
            "                filter_ = self.slug_source + \"__exact\"",
            "                self.model.objects.filter(**{filter_: self.slug_test_object}).update(",
            "                    **{self.slug_source: new_slug_source_value}",
            "                )",
            "",
            "                obj.refresh_from_db()",
            "                self.assertEqual(getattr(obj, self.slug_source), new_slug_source_value)",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "    class EditObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit a single existing instance.",
            "",
            "        :form_data: Data to be used when updating the first existing object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "",
            "        def test_edit_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance.pk), self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_UPDATE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance2)), 404)",
            "",
            "            # Try to edit a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance1),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance1.pk), self.form_data)",
            "",
            "            # Try to edit a non-permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance2),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "",
            "    class DeleteObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete a single instance.",
            "        \"\"\"",
            "",
            "        def get_deletable_object(self):",
            "            \"\"\"",
            "            Get an instance that can be deleted.",
            "",
            "            For some models this may just be any random object, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            instance = get_deletable_objects(self.model, self._get_queryset()).first()",
            "            if instance is None:",
            "                self.fail(\"Couldn't find a single deletable object!\")",
            "            return instance",
            "",
            "        def test_delete_object_without_permission(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission_and_xwwwformurlencoded(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": urlencode({\"confirm\": True}),",
            "                \"content_type\": \"application/x-www-form-urlencoded\",",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_constrained_permission(self):",
            "            instance1 = self.get_deletable_object()",
            "            instance2 = self._get_queryset().exclude(pk=instance1.pk)[0]",
            "",
            "            # Assign object-level permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance2)), 404)",
            "",
            "            # Try to delete a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance1),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance1.pk)",
            "",
            "            # Try to delete a non-permitted object",
            "            # Note that in the case of tree models, deleting instance1 above may have cascade-deleted to instance2,",
            "            # so to be safe, we need to get another object instance that definitely exists:",
            "            instance3 = self._get_queryset().first()",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance3),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "            self.assertTrue(self._get_queryset().filter(pk=instance3.pk).exists())",
            "",
            "    class ListObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve multiple instances.",
            "        \"\"\"",
            "",
            "        filterset = None",
            "",
            "        def get_filterset(self):",
            "            return self.filterset or get_filterset_for_model(self.model)",
            "",
            "        # Helper methods to be overriden by special cases.",
            "        # See ConsoleConnectionsTestCase, InterfaceConnectionsTestCase and PowerConnectionsTestCase",
            "        def get_list_url(self):",
            "            return reverse(validated_viewname(self.model, \"list\"))",
            "",
            "        def get_title(self):",
            "            return bettertitle(self.model._meta.verbose_name_plural)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(\"/login/?next=\" + self._get_url(\"list\"), response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_filtered(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            response = self.client.get(f\"{self._get_url('list')}?id={instance1.pk}\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertNotRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            try:",
            "                self.assertIn(self._get_url(\"view\", instance=instance1), content, msg=content)",
            "                self.assertNotIn(self._get_url(\"view\", instance=instance2), content, msg=content)",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=True)",
            "        def test_list_objects_unknown_filter_strict_filtering(self):",
            "            \"\"\"Verify that with STRICT_FILTERING, an unknown filter results in an error message and no matches.\"\"\"",
            "            response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertIn(\"Unknown filter field\", content, msg=content)",
            "            # There should be no table rows displayed except for the empty results row",
            "            self.assertIn(f\"No {self.model._meta.verbose_name_plural} found\", content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=False)",
            "        def test_list_objects_unknown_filter_no_strict_filtering(self):",
            "            \"\"\"Verify that without STRICT_FILTERING, an unknown filter is ignored.\"\"\"",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            with self.assertLogs(\"nautobot.utilities.filters\") as cm:",
            "                response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            filterset = self.get_filterset()",
            "            if not filterset:",
            "                self.fail(",
            "                    f\"Couldn't find filterset for model {self.model}. The FilterSet class is expected to be in the \"",
            "                    \"filters module within the application associated with the model and its name is expected to be \"",
            "                    f\"{self.model.__name__}FilterSet.\"",
            "                )",
            "            self.assertEqual(",
            "                cm.output,",
            "                [",
            "                    f\"WARNING:nautobot.utilities.filters:{filterset.__name__}: \"",
            "                    'Unknown filter field \"ice_cream_flavor\"',",
            "                ],",
            "            )",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertNotIn(\"Unknown filter field\", content, msg=content)",
            "            self.assertNotIn(f\"No {self.model._meta.verbose_name_plural} found\", content, msg=content)",
            "            if hasattr(self.model, \"name\"):",
            "                # TODO: https://github.com/nautobot/nautobot/issues/2580",
            "                #       This is fragile as we move toward more autogenerated test fixtures,",
            "                #       as \"instance.name\" may appear coincidentally in other page text if we're not careful.",
            "                self.assertIn(escape(instance1.name), content, msg=content)",
            "                self.assertIn(escape(instance2.name), content, msg=content)",
            "            try:",
            "                self.assertIn(self._get_url(\"view\", instance=instance1), content, msg=content)",
            "                self.assertIn(self._get_url(\"view\", instance=instance2), content, msg=content)",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_without_permission(self):",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                response = self.client.get(self._get_url(\"list\"))",
            "                self.assertHttpStatus(response, 403)",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_permission(self):",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            list_url = self.get_list_url()",
            "            title = self.get_title()",
            "",
            "            # Check if breadcrumb is rendered correctly",
            "            self.assertIn(",
            "                f'<a href=\"{list_url}\">{title}</a>',",
            "                response_body,",
            "            )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"view\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertIn(escape(instance1.name), content, msg=content)",
            "                self.assertNotIn(escape(instance2.name), content, msg=content)",
            "            elif hasattr(self.model, \"get_absolute_url\"):",
            "                self.assertIn(instance1.get_absolute_url(), content, msg=content)",
            "                self.assertNotIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "        @skipIf(",
            "            \"example_plugin\" not in settings.PLUGINS,",
            "            \"example_plugin not in settings.PLUGINS\",",
            "        )",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_view_plugin_banner(self):",
            "            \"\"\"",
            "            If example plugin is installed, check if the plugin banner is rendered correctly in ObjectListView.",
            "            \"\"\"",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            # Check plugin banner is rendered correctly",
            "            self.assertIn(",
            "                f\"<div>You are viewing a table of {self.model._meta.verbose_name_plural}</div>\", response_body",
            "            )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_queryset_to_csv(self):",
            "            # Built-in CSV export",
            "            if not hasattr(self.model, \"csv_headers\"):",
            "                self.skipTest(f\"{self.model} has no csv_headers attribute?\")",
            "            response = self.client.get(f\"{self._get_url('list')}?export\")",
            "            self.assertHttpStatus(response, 200)",
            "            self.assertEqual(response.get(\"Content-Type\"), \"text/csv\")",
            "            instance1 = self._get_queryset().first()",
            "            # With filtering",
            "            response = self.client.get(f\"{self._get_url('list')}?export&id={instance1.pk}\")",
            "            self.assertHttpStatus(response, 200)",
            "            self.assertEqual(response.get(\"Content-Type\"), \"text/csv\")",
            "            response_body = response.content.decode(response.charset)",
            "            reader = csv.DictReader(StringIO(response_body))",
            "            # This line will make data a dictionary with csv headers as keys and corresponding csv values as values.",
            "            # For example:",
            "            # {'name': 'AFRINIC', 'slug': 'afrinic', 'is_private': '', 'description': ...'}",
            "            data = [dict(row) for row in reader][0]",
            "",
            "            # Get expected data",
            "            instance1_unformatted_data = [",
            "                *instance1.to_csv(),",
            "                *instance1.get_custom_fields().values(),",
            "            ]",
            "            # Format expected data using `csv_format`, parse back with `csv` and get first row",
            "            instance1_csv_data = next(iter(csv.reader([csv_format(instance1_unformatted_data)])))",
            "",
            "            instance1_cf_headers = [\"cf_\" + str(cf.slug) for cf in instance1.get_custom_fields().keys()]",
            "            instance1_csv_headers = list(self.model.csv_headers) + instance1_cf_headers",
            "            self.assertEqual(instance1_csv_headers, list(data.keys()))",
            "            self.assertEqual(instance1_csv_data, list(data.values()))",
            "",
            "    class CreateMultipleObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create multiple instances using a single form. Expects the creation of three new instances by default.",
            "",
            "        :bulk_create_count: The number of objects expected to be created (default: 3).",
            "        :bulk_create_data: A dictionary of data to be used for bulk object creation.",
            "        \"\"\"",
            "",
            "        bulk_create_count = 3",
            "        bulk_create_data = {}",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_without_permission(self):",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign non-constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Bulk create objects",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "                constraints={\"pk\": uuid.uuid4()},  # Match a non-existent pk (i.e., deny all)",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to make the request with unmet constraints",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Set constraint to allow all",
            "            obj_perm.save()",
            "",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "    class BulkImportObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create multiple instances from imported data.",
            "",
            "        :csv_data: A list of CSV-formatted lines (starting with the headers) to be used for bulk object import.",
            "        \"\"\"",
            "",
            "        csv_data = ()",
            "",
            "        def _get_csv_data(self):",
            "            return \"\\n\".join(self.csv_data)",
            "",
            "        def test_bulk_import_objects_without_permission(self):",
            "            data = {",
            "                \"csv_data\": self._get_csv_data(),",
            "            }",
            "",
            "            # Test GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"import\")), 403)",
            "",
            "            # Try POST without permission",
            "            response = self.client.post(self._get_url(\"import\"), data)",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(response, 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_import_objects_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"csv_data\": self._get_csv_data(),",
            "            }",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"import\")), 200)",
            "",
            "            # Test POST with permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count + len(self.csv_data) - 1)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_import_objects_with_permission_csv_file(self):",
            "            initial_count = self._get_queryset().count()",
            "            self.file_contents = bytes(self._get_csv_data(), \"utf-8\")",
            "            self.bulk_import_file = SimpleUploadedFile(name=\"bulk_import_data.csv\", content=self.file_contents)",
            "            data = {",
            "                \"csv_file\": self.bulk_import_file,",
            "            }",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"import\")), 200)",
            "",
            "            # Test POST with permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count + len(self.csv_data) - 1)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_import_objects_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"csv_data\": self._get_csv_data(),",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to import non-permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Set permission to allow all",
            "            obj_perm.save()",
            "",
            "            # Import permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count + len(self.csv_data) - 1)",
            "",
            "    class BulkEditObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit multiple instances.",
            "",
            "        :bulk_edit_data: A dictionary of data to be used when bulk editing a set of objects. This data should differ",
            "                         from that used for initial object creation within setUpTestData().",
            "        \"\"\"",
            "",
            "        bulk_edit_data = {}",
            "",
            "        def test_bulk_edit_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Append the form data to the request",
            "            data.update(post_data(self.bulk_edit_data))",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertInstanceEqual(instance, self.bulk_edit_data)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_edit with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pk\"",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"_all\": \"on\",",
            "            }",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk edit table.",
            "            # after pressing Edit Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkEditForm/BulkUpdateForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_constrained_permission(self):",
            "            # Select some objects that are *not* already set to match the first value in self.bulk_edit_data or null.",
            "            # We have to exclude null cases because Django filter()/exclude() doesn't like `__in=[None]` as a case.",
            "            attr_name = list(self.bulk_edit_data.keys())[0]",
            "            objects = (",
            "                self._get_queryset()",
            "                .exclude(**{attr_name: self.bulk_edit_data[attr_name]})",
            "                .exclude(**{f\"{attr_name}__isnull\": True})",
            "            )[:3]",
            "            self.assertEqual(objects.count(), 3)",
            "            pk_list = list(objects.values_list(\"pk\", flat=True))",
            "",
            "            # Define a permission that permits the above objects, but will not permit them after updating them.",
            "            field = self.model._meta.get_field(attr_name)",
            "            values = [field.value_from_object(obj) for obj in objects]",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={f\"{attr_name}__in\": values},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Build form data",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(post_data(self.bulk_edit_data))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), data)",
            "            # 200 because we're sent back to the edit form to try again; if the update were successful it'd be a 302",
            "            self.assertHttpStatus(response, 200)",
            "            # Assert that the objects are NOT updated",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertIn(field.value_from_object(instance), values)",
            "                self.assertNotEqual(field.value_from_object(instance), self.bulk_edit_data[attr_name])",
            "",
            "            # Update permission constraints to permit all objects",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk edit permitted objects and expect a redirect back to the list view",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            # Assert that the objects were all updated correctly",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertInstanceEqual(instance, self.bulk_edit_data)",
            "",
            "    class BulkDeleteObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete multiple instances.",
            "        \"\"\"",
            "",
            "        def get_deletable_object_pks(self):",
            "            \"\"\"",
            "            Get a list of PKs corresponding to objects that can be safely bulk-deleted.",
            "",
            "            For some models this may just be any random objects, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            return get_deletable_objects(self.model, self._get_queryset()).values_list(\"pk\", flat=True)[:3]",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_without_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_delete with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pks\".",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"confirm\": True,",
            "                \"_all\": \"on\",",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with the selected data first. Emulating selecting all -> pressing Delete Selected button.",
            "            response = self.client.post(self._get_url(\"bulk_delete\"), selected_data)",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkDeleteForm/BulkDestroyForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_constrained_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk delete non-permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Match a non-existent pk (i.e., allow all)",
            "            obj_perm.save()",
            "",
            "            # Bulk delete permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "    class BulkRenameObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Rename multiple instances.",
            "        \"\"\"",
            "",
            "        rename_data = {",
            "            \"find\": \"^(.*)$\",",
            "            \"replace\": \"\\\\1X\",  # Append an X to the original value",
            "            \"use_regex\": True,",
            "        }",
            "",
            "        def test_bulk_rename_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Test GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"bulk_rename\")), 403)",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_constrained_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"name__regex\": \"[^X]$\"},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk rename permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "    class PrimaryObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkImportObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing all standard View functions for primary objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class OrganizationalObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkImportObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for all organizational objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentTemplateViewTestCase(",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component template models (ConsolePortTemplates, InterfaceTemplates, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkImportObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component models (ConsolePorts, Interfaces, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "        bulk_add_data = None",
            "        \"\"\"Used for bulk-add (distinct from bulk-create) view testing; self.bulk_create_data will be used if unset.\"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_add_component(self):",
            "            \"\"\"Test bulk-adding this component to devices/virtual-machines.\"\"\"",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            initial_count = self._get_queryset().count()",
            "",
            "            data = (self.bulk_add_data or self.bulk_create_data).copy()",
            "",
            "            # Load the device-bulk-add or virtualmachine-bulk-add form",
            "            if \"device\" in data:",
            "                url = reverse(f\"dcim:device_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": post_data({\"pk\": data[\"device\"]}),",
            "                }",
            "            else:",
            "                url = reverse(f\"virtualization:virtualmachine_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": post_data({\"pk\": data[\"virtual_machine\"]}),",
            "                }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "",
            "            # Post to the device-bulk-add or virtualmachine-bulk-add form to create records",
            "            if \"device\" in data:",
            "                data[\"pk\"] = data.pop(\"device\")",
            "            else:",
            "                data[\"pk\"] = data.pop(\"virtual_machine\")",
            "            data[\"_create\"] = \"\"",
            "            request[\"data\"] = post_data(data)",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "            updated_count = self._get_queryset().count()",
            "            self.assertEqual(updated_count, initial_count + self.bulk_create_count)",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, (self.bulk_add_data or self.bulk_create_data))",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename(self):",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            objects = self.selected_objects",
            "            pk_list = [obj.pk for obj in objects]",
            "            # Apply button not yet clicked",
            "            data = {\"pk\": pk_list}",
            "            data.update(self.rename_data)",
            "            verbose_name_plural = self.model._meta.verbose_name_plural",
            "",
            "            with self.subTest(\"Assert device name in HTML\"):",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                message = (",
            "                    f\"Renaming {len(objects)} {bettertitle(verbose_name_plural)} on {self.selected_objects_parent_name}\"",
            "                )",
            "                self.assertInHTML(message, response.content.decode(response.charset))",
            "",
            "            with self.subTest(\"Assert update successfully\"):",
            "                data[\"_apply\"] = True  # Form Apply button",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                self.assertHttpStatus(response, 302)",
            "                queryset = self._get_queryset().filter(pk__in=pk_list)",
            "                for instance in objects:",
            "                    self.assertEqual(queryset.get(pk=instance.pk).name, f\"{instance.name}X\")",
            "",
            "            with self.subTest(\"Assert if no valid objects selected return with error\"):",
            "                for values in ([], [str(uuid.uuid4())]):",
            "                    data[\"pk\"] = values",
            "                    response = self.client.post(self._get_url(\"bulk_rename\"), data, follow=True)",
            "                    expected_message = f\"No valid {verbose_name_plural} were selected.\"",
            "                    self.assertIn(expected_message, response.content.decode(response.charset))"
        ],
        "afterPatchFile": [
            "import csv",
            "import re",
            "from io import StringIO",
            "from tree_queries.models import TreeNode",
            "from typing import Optional, Sequence",
            "from unittest import skipIf",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import TestCase as _TestCase, override_settings, tag",
            "from django.urls import reverse, NoReverseMatch",
            "from django.utils.text import slugify",
            "from django.utils.html import escape",
            "from django.utils.http import urlencode",
            "",
            "from nautobot.core.models.generics import PrimaryModel",
            "from nautobot.extras.choices import CustomFieldTypeChoices, RelationshipSideChoices, ObjectChangeActionChoices",
            "from nautobot.extras.forms.mixins import CustomFieldModelFormMixin, RelationshipModelFormMixin",
            "from nautobot.extras.models import ChangeLoggedModel, CustomField, CustomFieldModel, Relationship, RelationshipModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.templatetags.helpers import bettertitle, validated_viewname",
            "from nautobot.utilities.testing.mixins import NautobotTestCaseMixin",
            "from nautobot.utilities.utils import get_changes_for_model, get_filterset_for_model, get_form_for_model, csv_format",
            "from .utils import disable_warnings, extract_page_body, get_deletable_objects, post_data",
            "",
            "",
            "__all__ = (",
            "    \"TestCase\",",
            "    \"ModelTestCase\",",
            "    \"ModelViewTestCase\",",
            "    \"ViewTestCases\",",
            ")",
            "",
            "",
            "@tag(\"unit\")",
            "@override_settings(PAGINATE_COUNT=65000)",
            "class TestCase(NautobotTestCaseMixin, _TestCase):",
            "    \"\"\"Base class for all Nautobot-specific unit tests.\"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"Initialize user and client.\"\"\"",
            "        super().setUpNautobot()",
            "",
            "",
            "class ModelTestCase(TestCase):",
            "    \"\"\"",
            "    Parent class for TestCases which deal with models.",
            "    \"\"\"",
            "",
            "    model = None",
            "    # Optional, list of Relationships populated in setUpTestData for testing with this model",
            "    # Be sure to also create RelationshipAssociations using these Relationships!",
            "    relationships: Optional[Sequence[Relationship]] = None",
            "    # Optional, list of CustomFields populated in setUpTestData for testing with this model",
            "    # Be sure to also populate these fields on your test data!",
            "    custom_fields: Optional[Sequence[CustomField]] = None",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"",
            "        Return a base queryset suitable for use in test methods.",
            "        \"\"\"",
            "        return self.model.objects.all()",
            "",
            "",
            "#",
            "# UI Tests",
            "#",
            "",
            "",
            "@tag(\"performance\")",
            "class ModelViewTestCase(ModelTestCase):",
            "    \"\"\"",
            "    Base TestCase for model views. Subclass to test individual views.",
            "    \"\"\"",
            "",
            "    reverse_url_attribute = None",
            "    \"\"\"",
            "    Name of instance field to pass as a kwarg when looking up action URLs for creating/editing/deleting a model instance.",
            "",
            "    If unspecified, \"slug\" and \"pk\" will be tried, in that order.",
            "    \"\"\"",
            "",
            "    # 2.0 TODO(jathan): Eliminate the need to overload `_get_base_url()` at all and just rely on `get_route_for_model()`",
            "    def _get_base_url(self):",
            "        \"\"\"",
            "        Return the base format for a URL for the test's model. Override this to test for a model which belongs",
            "        to a different app (e.g. testing Interfaces within the virtualization app).",
            "        \"\"\"",
            "        if self.model._meta.app_label in settings.PLUGINS:",
            "            return f\"plugins:{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "        return f\"{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "",
            "    # 2.0 TODO(jathan): Eliminate the need to overload `_get_url()` at all and just rely on `get_route_for_model()`",
            "    def _get_url(self, action, instance=None):",
            "        \"\"\"",
            "        Return the URL name for a specific action and optionally a specific instance",
            "        \"\"\"",
            "        url_format = self._get_base_url()",
            "",
            "        # If no instance was provided, assume we don't need a unique identifier",
            "        if instance is None:",
            "            return reverse(url_format.format(action))",
            "",
            "        if self.reverse_url_attribute:",
            "            return reverse(",
            "                url_format.format(action),",
            "                kwargs={self.reverse_url_attribute: getattr(instance, self.reverse_url_attribute)},",
            "            )",
            "",
            "        # Attempt to resolve using slug as the unique identifier if one exists",
            "        if hasattr(self.model, \"slug\"):",
            "            try:",
            "                return reverse(url_format.format(action), kwargs={\"slug\": instance.slug})",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        # Default to using the numeric PK to retrieve the URL for an object",
            "        return reverse(url_format.format(action), kwargs={\"pk\": instance.pk})",
            "",
            "",
            "@tag(\"unit\")",
            "class ViewTestCases:",
            "    \"\"\"",
            "    We keep any TestCases with test_* methods inside a class to prevent unittest from trying to run them.",
            "    \"\"\"",
            "",
            "    class GetObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve a single instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_queryset().first().get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(",
            "                \"/login/?next=\" + self._get_queryset().first().get_absolute_url(), response_body, msg=response_body",
            "            )",
            "",
            "            # The \"Change Log\" tab should appear in the response since we have all exempt permissions",
            "            if issubclass(self.model, ChangeLoggedModel):",
            "                response_body = extract_page_body(response.content.decode(response.charset))",
            "                self.assertIn(\"Change Log\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                response = self.client.get(instance.get_absolute_url())",
            "                self.assertHttpStatus(response, [403, 404])",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(instance.get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "",
            "            # The object's display name or string representation should appear in the response",
            "            self.assertIn(escape(getattr(instance, \"display\", str(instance))), response_body, msg=response_body)",
            "",
            "            # If any Relationships are defined, they should appear in the response",
            "            if self.relationships is not None:",
            "                for relationship in self.relationships:  # false positive pylint: disable=not-an-iterable",
            "                    content_type = ContentType.objects.get_for_model(instance)",
            "                    if content_type == relationship.source_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(RelationshipSideChoices.SIDE_SOURCE)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "                    if content_type == relationship.destination_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(RelationshipSideChoices.SIDE_DESTINATION)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "",
            "            # If any Custom Fields are defined, they should appear in the response",
            "            if self.custom_fields is not None:",
            "                for custom_field in self.custom_fields:  # false positive pylint: disable=not-an-iterable",
            "                    self.assertIn(escape(str(custom_field)), response_body, msg=response_body)",
            "                    # 2.0 TODO: #824 custom_field.slug rather than custom_field.name",
            "                    if custom_field.type == CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "                        for value in instance.cf.get(custom_field.name):",
            "                            self.assertIn(escape(str(value)), response_body, msg=response_body)",
            "                    else:",
            "                        self.assertIn(",
            "                            escape(str(instance.cf.get(custom_field.name) or \"\")), response_body, msg=response_body",
            "                        )",
            "",
            "            return response  # for consumption by child test cases if desired",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                # To get a different rendering flow than the `test_get_object_with_permission` test above,",
            "                # enable additional permissions for this object so that add/edit/delete buttons are rendered.",
            "                actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET to permitted object",
            "            response = self.client.get(instance1.get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            # Try GET to non-permitted object",
            "            self.assertHttpStatus(self.client.get(instance2.get_absolute_url()), 404)",
            "",
            "            return response  # for consumption by child test cases if desired",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_has_advanced_tab(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            response = self.client.get(instance.get_absolute_url())",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            advanced_tab_href = f\"{instance.get_absolute_url()}#advanced\"",
            "",
            "            self.assertIn(advanced_tab_href, response_body)",
            "            self.assertIn(\"Advanced\", response_body)",
            "",
            "    class GetObjectChangelogViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the changelog for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_changelog(self):",
            "            url = self._get_url(\"changelog\", self._get_queryset().first())",
            "            response = self.client.get(url)",
            "            self.assertHttpStatus(response, 200)",
            "",
            "    class GetObjectNotesViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the notes for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_notes(self):",
            "            if hasattr(self.model, \"notes\"):",
            "                url = self._get_url(\"notes\", self._get_queryset().first())",
            "                response = self.client.get(url)",
            "                self.assertHttpStatus(response, 200)",
            "",
            "    class CreateObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create a single new instance.",
            "",
            "        :form_data: Data to be used when creating a new object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "        slug_source = None",
            "        slugify_function = staticmethod(slugify)",
            "        slug_test_object = \"\"",
            "",
            "        def test_create_object_without_permission(self):",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 403)",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            response = self.client.post(**request)",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(response, 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                instance = self._get_queryset().get(slug=self.form_data.get(\"slug\"))",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    instance = self._get_queryset().order_by(\"last_updated\").last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "                else:",
            "                    instance = self._get_queryset().last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_CREATE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try to create an object (not permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(initial_count, self._get_queryset().count())  # Check that no object was created",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}",
            "            obj_perm.save()",
            "",
            "            # Try to create an object (permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                instance = self._get_queryset().get(slug=self.form_data.get(\"slug\"))",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    self.assertInstanceEqual(self._get_queryset().order_by(\"last_updated\").last(), self.form_data)",
            "                else:",
            "                    self.assertInstanceEqual(self._get_queryset().last(), self.form_data)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_extra_feature_form_fields_present(self):",
            "            model_class = self.model",
            "            model_form = get_form_for_model(model_class)",
            "            fields = model_form.base_fields",
            "            if isinstance(model_class, CustomFieldModel):",
            "                self.assertTrue(issubclass(CustomFieldModelFormMixin, model_form))",
            "            if isinstance(model_class, RelationshipModel):",
            "                self.assertTrue(issubclass(RelationshipModelFormMixin, model_form))",
            "            if isinstance(model_class, NotesMixin):",
            "                self.assertIsNotNone(fields.get(\"object_note\"))",
            "            if isinstance(model_class, PrimaryModel):",
            "                self.assertIsNotNone(fields.get(\"tags\"))",
            "",
            "        def test_slug_autocreation(self):",
            "            \"\"\"Test that slug is autocreated through ORM.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if self.slug_source is not None:",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "        def test_slug_not_modified(self):",
            "            \"\"\"Ensure save method does not modify slug that is passed in.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if self.slug_source is not None:",
            "                new_slug_source_value = \"kwyjibo\"",
            "",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                # Update slug source field str",
            "                filter_ = self.slug_source + \"__exact\"",
            "                self.model.objects.filter(**{filter_: self.slug_test_object}).update(",
            "                    **{self.slug_source: new_slug_source_value}",
            "                )",
            "",
            "                obj.refresh_from_db()",
            "                self.assertEqual(getattr(obj, self.slug_source), new_slug_source_value)",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "    class EditObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit a single existing instance.",
            "",
            "        :form_data: Data to be used when updating the first existing object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "",
            "        def test_edit_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance.pk), self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_UPDATE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance2)), 404)",
            "",
            "            # Try to edit a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance1),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance1.pk), self.form_data)",
            "",
            "            # Try to edit a non-permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance2),",
            "                \"data\": post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "",
            "    class DeleteObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete a single instance.",
            "        \"\"\"",
            "",
            "        def get_deletable_object(self):",
            "            \"\"\"",
            "            Get an instance that can be deleted.",
            "",
            "            For some models this may just be any random object, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            instance = get_deletable_objects(self.model, self._get_queryset()).first()",
            "            if instance is None:",
            "                self.fail(\"Couldn't find a single deletable object!\")",
            "            return instance",
            "",
            "        def test_delete_object_without_permission(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission_and_xwwwformurlencoded(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": urlencode({\"confirm\": True}),",
            "                \"content_type\": \"application/x-www-form-urlencoded\",",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_constrained_permission(self):",
            "            instance1 = self.get_deletable_object()",
            "            instance2 = self._get_queryset().exclude(pk=instance1.pk)[0]",
            "",
            "            # Assign object-level permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance2)), 404)",
            "",
            "            # Try to delete a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance1),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance1.pk)",
            "",
            "            # Try to delete a non-permitted object",
            "            # Note that in the case of tree models, deleting instance1 above may have cascade-deleted to instance2,",
            "            # so to be safe, we need to get another object instance that definitely exists:",
            "            instance3 = self._get_queryset().first()",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance3),",
            "                \"data\": post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "            self.assertTrue(self._get_queryset().filter(pk=instance3.pk).exists())",
            "",
            "    class ListObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve multiple instances.",
            "        \"\"\"",
            "",
            "        filterset = None",
            "",
            "        def get_filterset(self):",
            "            return self.filterset or get_filterset_for_model(self.model)",
            "",
            "        # Helper methods to be overriden by special cases.",
            "        # See ConsoleConnectionsTestCase, InterfaceConnectionsTestCase and PowerConnectionsTestCase",
            "        def get_list_url(self):",
            "            return reverse(validated_viewname(self.model, \"list\"))",
            "",
            "        def get_title(self):",
            "            return bettertitle(self.model._meta.verbose_name_plural)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(\"/login/?next=\" + self._get_url(\"list\"), response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_filtered(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            response = self.client.get(f\"{self._get_url('list')}?id={instance1.pk}\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertNotRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            try:",
            "                self.assertIn(self._get_url(\"view\", instance=instance1), content, msg=content)",
            "                self.assertNotIn(self._get_url(\"view\", instance=instance2), content, msg=content)",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=True)",
            "        def test_list_objects_unknown_filter_strict_filtering(self):",
            "            \"\"\"Verify that with STRICT_FILTERING, an unknown filter results in an error message and no matches.\"\"\"",
            "            response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertIn(\"Unknown filter field\", content, msg=content)",
            "            # There should be no table rows displayed except for the empty results row",
            "            self.assertIn(f\"No {self.model._meta.verbose_name_plural} found\", content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=False)",
            "        def test_list_objects_unknown_filter_no_strict_filtering(self):",
            "            \"\"\"Verify that without STRICT_FILTERING, an unknown filter is ignored.\"\"\"",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            with self.assertLogs(\"nautobot.utilities.filters\") as cm:",
            "                response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            filterset = self.get_filterset()",
            "            if not filterset:",
            "                self.fail(",
            "                    f\"Couldn't find filterset for model {self.model}. The FilterSet class is expected to be in the \"",
            "                    \"filters module within the application associated with the model and its name is expected to be \"",
            "                    f\"{self.model.__name__}FilterSet.\"",
            "                )",
            "            self.assertEqual(",
            "                cm.output,",
            "                [",
            "                    f\"WARNING:nautobot.utilities.filters:{filterset.__name__}: \"",
            "                    'Unknown filter field \"ice_cream_flavor\"',",
            "                ],",
            "            )",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertNotIn(\"Unknown filter field\", content, msg=content)",
            "            self.assertNotIn(f\"No {self.model._meta.verbose_name_plural} found\", content, msg=content)",
            "            if hasattr(self.model, \"name\"):",
            "                # TODO: https://github.com/nautobot/nautobot/issues/2580",
            "                #       This is fragile as we move toward more autogenerated test fixtures,",
            "                #       as \"instance.name\" may appear coincidentally in other page text if we're not careful.",
            "                self.assertIn(escape(instance1.name), content, msg=content)",
            "                self.assertIn(escape(instance2.name), content, msg=content)",
            "            try:",
            "                self.assertIn(self._get_url(\"view\", instance=instance1), content, msg=content)",
            "                self.assertIn(self._get_url(\"view\", instance=instance2), content, msg=content)",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_without_permission(self):",
            "            # Try GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                response = self.client.get(self._get_url(\"list\"))",
            "                self.assertHttpStatus(response, 403)",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_permission(self):",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            list_url = self.get_list_url()",
            "            title = self.get_title()",
            "",
            "            # Check if breadcrumb is rendered correctly",
            "            self.assertIn(",
            "                f'<a href=\"{list_url}\">{title}</a>',",
            "                response_body,",
            "            )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"view\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertIn(escape(instance1.name), content, msg=content)",
            "                self.assertNotIn(escape(instance2.name), content, msg=content)",
            "            elif hasattr(self.model, \"get_absolute_url\"):",
            "                self.assertIn(instance1.get_absolute_url(), content, msg=content)",
            "                self.assertNotIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "        @skipIf(",
            "            \"example_plugin\" not in settings.PLUGINS,",
            "            \"example_plugin not in settings.PLUGINS\",",
            "        )",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_view_plugin_banner(self):",
            "            \"\"\"",
            "            If example plugin is installed, check if the plugin banner is rendered correctly in ObjectListView.",
            "            \"\"\"",
            "            # Add model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            # Check plugin banner is rendered correctly",
            "            self.assertIn(",
            "                f\"<div>You are viewing a table of {self.model._meta.verbose_name_plural}</div>\", response_body",
            "            )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_queryset_to_csv(self):",
            "            # Built-in CSV export",
            "            if not hasattr(self.model, \"csv_headers\"):",
            "                self.skipTest(f\"{self.model} has no csv_headers attribute?\")",
            "            response = self.client.get(f\"{self._get_url('list')}?export\")",
            "            self.assertHttpStatus(response, 200)",
            "            self.assertEqual(response.get(\"Content-Type\"), \"text/csv\")",
            "            instance1 = self._get_queryset().first()",
            "            # With filtering",
            "            response = self.client.get(f\"{self._get_url('list')}?export&id={instance1.pk}\")",
            "            self.assertHttpStatus(response, 200)",
            "            self.assertEqual(response.get(\"Content-Type\"), \"text/csv\")",
            "            response_body = response.content.decode(response.charset)",
            "            reader = csv.DictReader(StringIO(response_body))",
            "            # This line will make data a dictionary with csv headers as keys and corresponding csv values as values.",
            "            # For example:",
            "            # {'name': 'AFRINIC', 'slug': 'afrinic', 'is_private': '', 'description': ...'}",
            "            data = [dict(row) for row in reader][0]",
            "",
            "            # Get expected data",
            "            instance1_unformatted_data = [",
            "                *instance1.to_csv(),",
            "                *instance1.get_custom_fields().values(),",
            "            ]",
            "            # Format expected data using `csv_format`, parse back with `csv` and get first row",
            "            instance1_csv_data = next(iter(csv.reader([csv_format(instance1_unformatted_data)])))",
            "",
            "            instance1_cf_headers = [\"cf_\" + str(cf.slug) for cf in instance1.get_custom_fields().keys()]",
            "            instance1_csv_headers = list(self.model.csv_headers) + instance1_cf_headers",
            "            self.assertEqual(instance1_csv_headers, list(data.keys()))",
            "            self.assertEqual(instance1_csv_data, list(data.values()))",
            "",
            "    class CreateMultipleObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create multiple instances using a single form. Expects the creation of three new instances by default.",
            "",
            "        :bulk_create_count: The number of objects expected to be created (default: 3).",
            "        :bulk_create_data: A dictionary of data to be used for bulk object creation.",
            "        \"\"\"",
            "",
            "        bulk_create_count = 3",
            "        bulk_create_data = {}",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_without_permission(self):",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign non-constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Bulk create objects",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "                constraints={\"pk\": uuid.uuid4()},  # Match a non-existent pk (i.e., deny all)",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to make the request with unmet constraints",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Set constraint to allow all",
            "            obj_perm.save()",
            "",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "    class BulkImportObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create multiple instances from imported data.",
            "",
            "        :csv_data: A list of CSV-formatted lines (starting with the headers) to be used for bulk object import.",
            "        \"\"\"",
            "",
            "        csv_data = ()",
            "",
            "        def _get_csv_data(self):",
            "            return \"\\n\".join(self.csv_data)",
            "",
            "        def test_bulk_import_objects_without_permission(self):",
            "            data = {",
            "                \"csv_data\": self._get_csv_data(),",
            "            }",
            "",
            "            # Test GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"import\")), 403)",
            "",
            "            # Try POST without permission",
            "            response = self.client.post(self._get_url(\"import\"), data)",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(response, 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_import_objects_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"csv_data\": self._get_csv_data(),",
            "            }",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"import\")), 200)",
            "",
            "            # Test POST with permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count + len(self.csv_data) - 1)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_import_objects_with_permission_csv_file(self):",
            "            initial_count = self._get_queryset().count()",
            "            self.file_contents = bytes(self._get_csv_data(), \"utf-8\")",
            "            self.bulk_import_file = SimpleUploadedFile(name=\"bulk_import_data.csv\", content=self.file_contents)",
            "            data = {",
            "                \"csv_file\": self.bulk_import_file,",
            "            }",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"import\")), 200)",
            "",
            "            # Test POST with permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count + len(self.csv_data) - 1)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_import_objects_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"csv_data\": self._get_csv_data(),",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to import non-permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Set permission to allow all",
            "            obj_perm.save()",
            "",
            "            # Import permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"import\"), data), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count + len(self.csv_data) - 1)",
            "",
            "    class BulkEditObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit multiple instances.",
            "",
            "        :bulk_edit_data: A dictionary of data to be used when bulk editing a set of objects. This data should differ",
            "                         from that used for initial object creation within setUpTestData().",
            "        \"\"\"",
            "",
            "        bulk_edit_data = {}",
            "",
            "        def test_bulk_edit_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Append the form data to the request",
            "            data.update(post_data(self.bulk_edit_data))",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertInstanceEqual(instance, self.bulk_edit_data)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_edit with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pk\"",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"_all\": \"on\",",
            "            }",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk edit table.",
            "            # after pressing Edit Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkEditForm/BulkUpdateForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_constrained_permission(self):",
            "            # Select some objects that are *not* already set to match the first value in self.bulk_edit_data or null.",
            "            # We have to exclude null cases because Django filter()/exclude() doesn't like `__in=[None]` as a case.",
            "            attr_name = list(self.bulk_edit_data.keys())[0]",
            "            objects = (",
            "                self._get_queryset()",
            "                .exclude(**{attr_name: self.bulk_edit_data[attr_name]})",
            "                .exclude(**{f\"{attr_name}__isnull\": True})",
            "            )[:3]",
            "            self.assertEqual(objects.count(), 3)",
            "            pk_list = list(objects.values_list(\"pk\", flat=True))",
            "",
            "            # Define a permission that permits the above objects, but will not permit them after updating them.",
            "            field = self.model._meta.get_field(attr_name)",
            "            values = [field.value_from_object(obj) for obj in objects]",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={f\"{attr_name}__in\": values},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Build form data",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(post_data(self.bulk_edit_data))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), data)",
            "            # 200 because we're sent back to the edit form to try again; if the update were successful it'd be a 302",
            "            self.assertHttpStatus(response, 200)",
            "            # Assert that the objects are NOT updated",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertIn(field.value_from_object(instance), values)",
            "                self.assertNotEqual(field.value_from_object(instance), self.bulk_edit_data[attr_name])",
            "",
            "            # Update permission constraints to permit all objects",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk edit permitted objects and expect a redirect back to the list view",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            # Assert that the objects were all updated correctly",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertInstanceEqual(instance, self.bulk_edit_data)",
            "",
            "    class BulkDeleteObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete multiple instances.",
            "        \"\"\"",
            "",
            "        def get_deletable_object_pks(self):",
            "            \"\"\"",
            "            Get a list of PKs corresponding to objects that can be safely bulk-deleted.",
            "",
            "            For some models this may just be any random objects, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            return get_deletable_objects(self.model, self._get_queryset()).values_list(\"pk\", flat=True)[:3]",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_without_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_delete with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pks\".",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"confirm\": True,",
            "                \"_all\": \"on\",",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with the selected data first. Emulating selecting all -> pressing Delete Selected button.",
            "            response = self.client.post(self._get_url(\"bulk_delete\"), selected_data)",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkDeleteForm/BulkDestroyForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_constrained_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk delete non-permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Match a non-existent pk (i.e., allow all)",
            "            obj_perm.save()",
            "",
            "            # Bulk delete permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "    class BulkRenameObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Rename multiple instances.",
            "        \"\"\"",
            "",
            "        rename_data = {",
            "            \"find\": \"^(.*)$\",",
            "            \"replace\": \"\\\\1X\",  # Append an X to the original value",
            "            \"use_regex\": True,",
            "        }",
            "",
            "        def test_bulk_rename_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Test GET without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"bulk_rename\")), 403)",
            "",
            "            # Try POST without permission",
            "            with disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign model-level permission",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_constrained_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign constrained permission",
            "            obj_perm = ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"name__regex\": \"[^X]$\"},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk rename permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "    class PrimaryObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkImportObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing all standard View functions for primary objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class OrganizationalObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkImportObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for all organizational objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentTemplateViewTestCase(",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component template models (ConsolePortTemplates, InterfaceTemplates, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkImportObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component models (ConsolePorts, Interfaces, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "        bulk_add_data = None",
            "        \"\"\"Used for bulk-add (distinct from bulk-create) view testing; self.bulk_create_data will be used if unset.\"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_add_component(self):",
            "            \"\"\"Test bulk-adding this component to devices/virtual-machines.\"\"\"",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            initial_count = self._get_queryset().count()",
            "",
            "            data = (self.bulk_add_data or self.bulk_create_data).copy()",
            "",
            "            # Load the device-bulk-add or virtualmachine-bulk-add form",
            "            if \"device\" in data:",
            "                url = reverse(f\"dcim:device_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": post_data({\"pk\": data[\"device\"]}),",
            "                }",
            "            else:",
            "                url = reverse(f\"virtualization:virtualmachine_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": post_data({\"pk\": data[\"virtual_machine\"]}),",
            "                }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "",
            "            # Post to the device-bulk-add or virtualmachine-bulk-add form to create records",
            "            if \"device\" in data:",
            "                data[\"pk\"] = data.pop(\"device\")",
            "            else:",
            "                data[\"pk\"] = data.pop(\"virtual_machine\")",
            "            data[\"_create\"] = \"\"",
            "            request[\"data\"] = post_data(data)",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "            updated_count = self._get_queryset().count()",
            "            self.assertEqual(updated_count, initial_count + self.bulk_create_count)",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, (self.bulk_add_data or self.bulk_create_data))",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename(self):",
            "            obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            objects = self.selected_objects",
            "            pk_list = [obj.pk for obj in objects]",
            "            # Apply button not yet clicked",
            "            data = {\"pk\": pk_list}",
            "            data.update(self.rename_data)",
            "            verbose_name_plural = self.model._meta.verbose_name_plural",
            "",
            "            with self.subTest(\"Assert device name in HTML\"):",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                message = (",
            "                    f\"Renaming {len(objects)} {bettertitle(verbose_name_plural)} on {self.selected_objects_parent_name}\"",
            "                )",
            "                self.assertInHTML(message, response.content.decode(response.charset))",
            "",
            "            with self.subTest(\"Assert update successfully\"):",
            "                data[\"_apply\"] = True  # Form Apply button",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                self.assertHttpStatus(response, 302)",
            "                queryset = self._get_queryset().filter(pk__in=pk_list)",
            "                for instance in objects:",
            "                    self.assertEqual(queryset.get(pk=instance.pk).name, f\"{instance.name}X\")",
            "",
            "            with self.subTest(\"Assert if no valid objects selected return with error\"):",
            "                for values in ([], [str(uuid.uuid4())]):",
            "                    data[\"pk\"] = values",
            "                    response = self.client.post(self._get_url(\"bulk_rename\"), data, follow=True)",
            "                    expected_message = f\"No valid {verbose_name_plural} were selected.\"",
            "                    self.assertIn(expected_message, response.content.decode(response.charset))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "229": [
                "ViewTestCases",
                "GetObjectViewTestCase",
                "test_get_object_with_constrained_permission"
            ]
        },
        "addLocation": [
            "nautobot.utilities.testing.views.ViewTestCases.GetObjectViewTestCase.self",
            "nautobot.utilities.testing.views.ModelTestCase.self",
            "tensorflow.python.kernel_tests.quantization_ops.quantization_ops_test"
        ]
    }
}