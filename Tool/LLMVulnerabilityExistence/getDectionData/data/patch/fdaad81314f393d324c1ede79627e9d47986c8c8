{
    "mobsf/MobSF/init.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-VERSION = '4.0.4'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+VERSION = '4.0.5'"
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " BANNER = \"\"\""
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "   __  __       _    ____  _____       _  _    ___  "
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "  |  \\/  | ___ | |__/ ___||  ___|_   _| || |  / _ \\ "
            }
        },
        "frontPatchFile": [
            "\"\"\"Initialize on first run.\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import subprocess",
            "import sys",
            "import shutil",
            "",
            "from mobsf.install.windows.setup import windows_config_local",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "VERSION = '4.0.4'",
            "BANNER = \"\"\"",
            "  __  __       _    ____  _____       _  _    ___  ",
            " |  \\/  | ___ | |__/ ___||  ___|_   _| || |  / _ \\ ",
            " | |\\/| |/ _ \\| '_ \\___ \\| |_  \\ \\ / / || |_| | | |",
            " | |  | | (_) | |_) |__) |  _|  \\ V /|__   _| |_| |",
            " |_|  |_|\\___/|_.__/____/|_|     \\_/    |_|(_)___/ ",
            "\"\"\"  # noqa: W291",
            "# ASCII Font: Standard",
            "",
            "",
            "def first_run(secret_file, base_dir, mobsf_home):",
            "    # Based on https://gist.github.com/ndarville/3452907#file-secret-key-gen-py",
            "    if 'MOBSF_SECRET_KEY' in os.environ:",
            "        secret_key = os.environ['MOBSF_SECRET_KEY']",
            "    elif os.path.isfile(secret_file):",
            "        secret_key = open(secret_file).read().strip()",
            "    else:",
            "        try:",
            "            secret_key = get_random()",
            "            secret = open(secret_file, 'w')",
            "            secret.write(secret_key)",
            "            secret.close()",
            "        except IOError:",
            "            raise Exception('Secret file generation failed' % secret_file)",
            "        # Run Once",
            "        make_migrations(base_dir)",
            "        migrate(base_dir)",
            "        # Windows Setup",
            "        windows_config_local(mobsf_home)",
            "    return secret_key",
            "",
            "",
            "def create_user_conf(mobsf_home, base_dir):",
            "    try:",
            "        config_path = os.path.join(mobsf_home, 'config.py')",
            "        if not os.path.isfile(config_path):",
            "            sample_conf = os.path.join(base_dir, 'MobSF/settings.py')",
            "            with open(sample_conf, 'r') as f:",
            "                dat = f.readlines()",
            "            config = []",
            "            add = False",
            "            for line in dat:",
            "                if '^CONFIG-START^' in line:",
            "                    add = True",
            "                if '^CONFIG-END^' in line:",
            "                    break",
            "                if add:",
            "                    config.append(line.lstrip())",
            "            config.pop(0)",
            "            conf_str = ''.join(config)",
            "            with open(config_path, 'w') as f:",
            "                f.write(conf_str)",
            "    except Exception:",
            "        logger.exception('Cannot create config file')",
            "",
            "",
            "def django_operation(cmds, base_dir):",
            "    \"\"\"Generic Function for Djano operations.\"\"\"",
            "    manage = os.path.join(base_dir, '../manage.py')",
            "    if not os.path.exists(manage):",
            "        # Bail out for package",
            "        return",
            "    args = [sys.executable, manage]",
            "    args.extend(cmds)",
            "    subprocess.call(args)",
            "",
            "",
            "def make_migrations(base_dir):",
            "    \"\"\"Create Database Migrations.\"\"\"",
            "    try:",
            "        django_operation(['makemigrations'], base_dir)",
            "        django_operation(['makemigrations', 'StaticAnalyzer'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Make Migrations')",
            "",
            "",
            "def migrate(base_dir):",
            "    \"\"\"Migrate Database.\"\"\"",
            "    try:",
            "        django_operation(['migrate'], base_dir)",
            "        django_operation(['migrate', '--run-syncdb'], base_dir)",
            "        django_operation(['create_roles'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Migrate')",
            "",
            "",
            "def get_random():",
            "    choice = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'",
            "    return ''.join([random.SystemRandom().choice(choice) for i in range(50)])",
            "",
            "",
            "def get_mobsf_home(use_home, base_dir):",
            "    try:",
            "        mobsf_home = ''",
            "        if use_home:",
            "            mobsf_home = os.path.join(os.path.expanduser('~'), '.MobSF')",
            "            # MobSF Home Directory",
            "            if not os.path.exists(mobsf_home):",
            "                os.makedirs(mobsf_home)",
            "            create_user_conf(mobsf_home, base_dir)",
            "        else:",
            "            mobsf_home = base_dir",
            "        # Download Directory",
            "        dwd_dir = os.path.join(mobsf_home, 'downloads/')",
            "        if not os.path.exists(dwd_dir):",
            "            os.makedirs(dwd_dir)",
            "        # Screenshot Directory",
            "        screen_dir = os.path.join(dwd_dir, 'screen/')",
            "        if not os.path.exists(screen_dir):",
            "            os.makedirs(screen_dir)",
            "        # Upload Directory",
            "        upload_dir = os.path.join(mobsf_home, 'uploads/')",
            "        if not os.path.exists(upload_dir):",
            "            os.makedirs(upload_dir)",
            "        # Signature Directory",
            "        sig_dir = os.path.join(mobsf_home, 'signatures/')",
            "        if use_home:",
            "            src = os.path.join(base_dir, 'signatures/')",
            "            try:",
            "                shutil.copytree(src, sig_dir)",
            "            except Exception:",
            "                pass",
            "        elif not os.path.exists(sig_dir):",
            "            os.makedirs(sig_dir)",
            "        return mobsf_home",
            "    except Exception:",
            "        logger.exception('Creating MobSF Home Directory')",
            "",
            "",
            "def get_mobsf_version():",
            "    return BANNER, VERSION, f'v{VERSION}'"
        ],
        "afterPatchFile": [
            "\"\"\"Initialize on first run.\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import subprocess",
            "import sys",
            "import shutil",
            "",
            "from mobsf.install.windows.setup import windows_config_local",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "VERSION = '4.0.5'",
            "BANNER = \"\"\"",
            "  __  __       _    ____  _____       _  _    ___  ",
            " |  \\/  | ___ | |__/ ___||  ___|_   _| || |  / _ \\ ",
            " | |\\/| |/ _ \\| '_ \\___ \\| |_  \\ \\ / / || |_| | | |",
            " | |  | | (_) | |_) |__) |  _|  \\ V /|__   _| |_| |",
            " |_|  |_|\\___/|_.__/____/|_|     \\_/    |_|(_)___/ ",
            "\"\"\"  # noqa: W291",
            "# ASCII Font: Standard",
            "",
            "",
            "def first_run(secret_file, base_dir, mobsf_home):",
            "    # Based on https://gist.github.com/ndarville/3452907#file-secret-key-gen-py",
            "    if 'MOBSF_SECRET_KEY' in os.environ:",
            "        secret_key = os.environ['MOBSF_SECRET_KEY']",
            "    elif os.path.isfile(secret_file):",
            "        secret_key = open(secret_file).read().strip()",
            "    else:",
            "        try:",
            "            secret_key = get_random()",
            "            secret = open(secret_file, 'w')",
            "            secret.write(secret_key)",
            "            secret.close()",
            "        except IOError:",
            "            raise Exception('Secret file generation failed' % secret_file)",
            "        # Run Once",
            "        make_migrations(base_dir)",
            "        migrate(base_dir)",
            "        # Windows Setup",
            "        windows_config_local(mobsf_home)",
            "    return secret_key",
            "",
            "",
            "def create_user_conf(mobsf_home, base_dir):",
            "    try:",
            "        config_path = os.path.join(mobsf_home, 'config.py')",
            "        if not os.path.isfile(config_path):",
            "            sample_conf = os.path.join(base_dir, 'MobSF/settings.py')",
            "            with open(sample_conf, 'r') as f:",
            "                dat = f.readlines()",
            "            config = []",
            "            add = False",
            "            for line in dat:",
            "                if '^CONFIG-START^' in line:",
            "                    add = True",
            "                if '^CONFIG-END^' in line:",
            "                    break",
            "                if add:",
            "                    config.append(line.lstrip())",
            "            config.pop(0)",
            "            conf_str = ''.join(config)",
            "            with open(config_path, 'w') as f:",
            "                f.write(conf_str)",
            "    except Exception:",
            "        logger.exception('Cannot create config file')",
            "",
            "",
            "def django_operation(cmds, base_dir):",
            "    \"\"\"Generic Function for Djano operations.\"\"\"",
            "    manage = os.path.join(base_dir, '../manage.py')",
            "    if not os.path.exists(manage):",
            "        # Bail out for package",
            "        return",
            "    args = [sys.executable, manage]",
            "    args.extend(cmds)",
            "    subprocess.call(args)",
            "",
            "",
            "def make_migrations(base_dir):",
            "    \"\"\"Create Database Migrations.\"\"\"",
            "    try:",
            "        django_operation(['makemigrations'], base_dir)",
            "        django_operation(['makemigrations', 'StaticAnalyzer'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Make Migrations')",
            "",
            "",
            "def migrate(base_dir):",
            "    \"\"\"Migrate Database.\"\"\"",
            "    try:",
            "        django_operation(['migrate'], base_dir)",
            "        django_operation(['migrate', '--run-syncdb'], base_dir)",
            "        django_operation(['create_roles'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Migrate')",
            "",
            "",
            "def get_random():",
            "    choice = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'",
            "    return ''.join([random.SystemRandom().choice(choice) for i in range(50)])",
            "",
            "",
            "def get_mobsf_home(use_home, base_dir):",
            "    try:",
            "        mobsf_home = ''",
            "        if use_home:",
            "            mobsf_home = os.path.join(os.path.expanduser('~'), '.MobSF')",
            "            # MobSF Home Directory",
            "            if not os.path.exists(mobsf_home):",
            "                os.makedirs(mobsf_home)",
            "            create_user_conf(mobsf_home, base_dir)",
            "        else:",
            "            mobsf_home = base_dir",
            "        # Download Directory",
            "        dwd_dir = os.path.join(mobsf_home, 'downloads/')",
            "        if not os.path.exists(dwd_dir):",
            "            os.makedirs(dwd_dir)",
            "        # Screenshot Directory",
            "        screen_dir = os.path.join(dwd_dir, 'screen/')",
            "        if not os.path.exists(screen_dir):",
            "            os.makedirs(screen_dir)",
            "        # Upload Directory",
            "        upload_dir = os.path.join(mobsf_home, 'uploads/')",
            "        if not os.path.exists(upload_dir):",
            "            os.makedirs(upload_dir)",
            "        # Signature Directory",
            "        sig_dir = os.path.join(mobsf_home, 'signatures/')",
            "        if use_home:",
            "            src = os.path.join(base_dir, 'signatures/')",
            "            try:",
            "                shutil.copytree(src, sig_dir)",
            "            except Exception:",
            "                pass",
            "        elif not os.path.exists(sig_dir):",
            "            os.makedirs(sig_dir)",
            "        return mobsf_home",
            "    except Exception:",
            "        logger.exception('Creating MobSF Home Directory')",
            "",
            "",
            "def get_mobsf_version():",
            "    return BANNER, VERSION, f'v{VERSION}'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [
                "VERSION"
            ]
        },
        "addLocation": []
    },
    "mobsf/MobSF/security.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "     def run(*args, **kwargs):"
            },
            "1": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         return newfunction(oldfunction, *args, **kwargs)"
            },
            "2": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     return run"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+def sanitize_redirect(url):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+    \"\"\"Sanitize Redirect URL.\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+    root = '/'"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+    if url.startswith('//'):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+        return root"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+    elif url.startswith('/'):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+        return url"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+    return root"
            }
        },
        "frontPatchFile": [
            "\"\"\"Runtime Executable Tampering Detection.\"\"\"",
            "import subprocess",
            "import functools",
            "import logging",
            "import sys",
            "from shutil import which",
            "from pathlib import Path",
            "from concurrent.futures import ThreadPoolExecutor",
            "",
            "",
            "from mobsf.MobSF.utils import (",
            "    find_java_binary,",
            "    gen_sha256_hash,",
            "    get_adb,",
            "    sha256,",
            ")",
            "",
            "from django.conf import settings",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "# Non executable files at host level",
            "_SKIP = [",
            "    '.pyc', '.js',",
            "    '.json', '.txt', '.md']",
            "EXECUTABLE_HASH_MAP = None",
            "",
            "",
            "def get_sha256(filepath):",
            "    \"\"\"Calculate sha256 hash of a file.\"\"\"",
            "    return (filepath.as_posix(), sha256(filepath))",
            "",
            "",
            "def get_all_files(dirlocs):",
            "    \"\"\"Get all files from a list of directories/files.\"\"\"",
            "    for dirloc in dirlocs:",
            "        if dirloc.is_file() and dirloc.suffix not in _SKIP:",
            "            yield dirloc",
            "        elif dirloc.is_dir():",
            "            # Use a generator expression for efficient filtering",
            "            files_in_dir = (",
            "                efile for efile in dirloc.rglob('*')",
            "                if efile.is_file() and efile.suffix not in _SKIP",
            "            )",
            "            # Yield all files from the filtered generator",
            "            yield from files_in_dir",
            "",
            "",
            "def generate_hashes(dirlocs):",
            "    \"\"\"Generate master hash for all files.\"\"\"",
            "    exec_hashes = {}",
            "    with ThreadPoolExecutor() as executor:",
            "        futures = []",
            "        for efile in get_all_files(dirlocs):",
            "            futures.append(",
            "                executor.submit(get_sha256, efile))",
            "        for future in futures:",
            "            sha = future.result()",
            "            exec_hashes[sha[0]] = sha[1]",
            "    return exec_hashes, gen_sha256_hash(str(exec_hashes))",
            "",
            "",
            "def get_executable_hashes():",
            "    # Internal Binaries shipped with MobSF",
            "    base = Path(settings.BASE_DIR)",
            "    manage_py = base.parent / 'manage.py'",
            "    exec_loc = [",
            "        base / 'DynamicAnalyzer' / 'tools',",
            "        base / 'StaticAnalyzer' / 'tools',",
            "        manage_py,",
            "    ]",
            "    # External binaries used directly by MobSF",
            "    system_bins = [",
            "        'adb',",
            "        'which',",
            "        'wkhtmltopdf',",
            "        'httptools',",
            "        'mitmdump',",
            "        'unzip',",
            "        'lipo',",
            "        'ar',",
            "        'nm',",
            "        'objdump',",
            "        'strings',",
            "        'xcrun',",
            "        'BinSkim.exe',",
            "        'BinScope.exe',",
            "        'nuget.exe',",
            "    ]",
            "    for sbin in system_bins:",
            "        bin_path = which(sbin)",
            "        if bin_path:",
            "            exec_loc.append(Path(bin_path))",
            "    # User defined path/binaries",
            "    if settings.JAVA_DIRECTORY:",
            "        exec_loc.append(Path(settings.JAVA_DIRECTORY))",
            "    user_defined_bins = [",
            "        sys.executable,",
            "        settings.JADX_BINARY,",
            "        settings.BACKSMALI_BINARY,",
            "        settings.VD2SVG_BINARY,",
            "        settings.APKTOOL_BINARY,",
            "        settings.ADB_BINARY,",
            "        settings.JTOOL_BINARY,",
            "        settings.CLASSDUMP_BINARY,",
            "        settings.CLASSDUMP_SWIFT_BINARY,",
            "        getattr(settings, 'BUNDLE_TOOL', ''),",
            "    ]",
            "    for ubin in user_defined_bins:",
            "        if ubin:",
            "            exec_loc.append(Path(ubin))",
            "    # Add ADB and Java binaries",
            "    adb = get_adb()",
            "    java = find_java_binary()",
            "    if adb == 'adb':",
            "        adb = which('adb')",
            "    if java == 'java':",
            "        java = which('java')",
            "    if adb:",
            "        exec_loc.append(Path(adb))",
            "    if java:",
            "        exec_loc.append(Path(java))",
            "    return generate_hashes(exec_loc)",
            "",
            "",
            "def store_exec_hashes_at_first_run():",
            "    \"\"\"Store executable hashes at first run.\"\"\"",
            "    try:",
            "        global EXECUTABLE_HASH_MAP",
            "        hashes, signature = get_executable_hashes()",
            "        hashes['signature'] = signature",
            "        EXECUTABLE_HASH_MAP = hashes",
            "    except Exception:",
            "        logger.exception('Cannot calculate executable hashes, '",
            "                         'disabling runtime executable '",
            "                         'tampering detection')",
            "",
            "",
            "def subprocess_hook(oldfunc, *args, **kwargs):",
            "    global EXECUTABLE_HASH_MAP",
            "    if isinstance(args[0], str):",
            "        # arg is a string",
            "        agmtz = args[0].split()",
            "        exec1 = agmtz[0]",
            "    else:",
            "        # list of args",
            "        agmtz = args[0]",
            "        exec1 = agmtz[0]  # executable",
            "    exec2 = None  # secondary executable",
            "    for arg in agmtz:",
            "        if arg.endswith('.jar'):",
            "            exec2 = Path(arg).as_posix()",
            "            break",
            "    if '/' in exec1 or '\\\\' in exec1:",
            "        exec1 = Path(exec1).as_posix()",
            "    else:",
            "        exec1 = Path(which(exec1)).as_posix()",
            "    executable_in_hash_map = False",
            "    if exec1 in EXECUTABLE_HASH_MAP:",
            "        executable_in_hash_map = True",
            "        if EXECUTABLE_HASH_MAP[exec1] != sha256(exec1):",
            "            msg = (",
            "                f'Executable Tampering Detected. [{exec1}]'",
            "                ' has been modified during runtime')",
            "            logger.error(msg)",
            "            raise Exception(msg)",
            "    if exec2 and exec2 in EXECUTABLE_HASH_MAP:",
            "        executable_in_hash_map = True",
            "        if EXECUTABLE_HASH_MAP[exec2] != sha256(exec2):",
            "            msg = (",
            "                f'JAR Tampering Detected. [{exec2}]'",
            "                ' has been modified during runtime')",
            "            logger.error(msg)",
            "            raise Exception(msg)",
            "    if not executable_in_hash_map:",
            "        logger.warning('Executable [%s] not found in known hashes, '",
            "                       'skipping runtime executable '",
            "                       'tampering detection', exec1)",
            "        _, signature = get_executable_hashes()",
            "        if EXECUTABLE_HASH_MAP['signature'] != signature:",
            "            msg = 'Executable/Library Tampering Detected'",
            "            logger.error(msg)",
            "            raise Exception(msg)",
            "    return oldfunc(*args, **kwargs)",
            "",
            "",
            "def init_exec_hooks():",
            "    subprocess.Popen = wrap_function(",
            "        subprocess.Popen,",
            "        subprocess_hook)",
            "",
            "",
            "def wrap_function(oldfunction, newfunction):",
            "    @functools.wraps(oldfunction)",
            "    def run(*args, **kwargs):",
            "        return newfunction(oldfunction, *args, **kwargs)",
            "    return run"
        ],
        "afterPatchFile": [
            "\"\"\"Runtime Executable Tampering Detection.\"\"\"",
            "import subprocess",
            "import functools",
            "import logging",
            "import sys",
            "from shutil import which",
            "from pathlib import Path",
            "from concurrent.futures import ThreadPoolExecutor",
            "",
            "",
            "from mobsf.MobSF.utils import (",
            "    find_java_binary,",
            "    gen_sha256_hash,",
            "    get_adb,",
            "    sha256,",
            ")",
            "",
            "from django.conf import settings",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "# Non executable files at host level",
            "_SKIP = [",
            "    '.pyc', '.js',",
            "    '.json', '.txt', '.md']",
            "EXECUTABLE_HASH_MAP = None",
            "",
            "",
            "def get_sha256(filepath):",
            "    \"\"\"Calculate sha256 hash of a file.\"\"\"",
            "    return (filepath.as_posix(), sha256(filepath))",
            "",
            "",
            "def get_all_files(dirlocs):",
            "    \"\"\"Get all files from a list of directories/files.\"\"\"",
            "    for dirloc in dirlocs:",
            "        if dirloc.is_file() and dirloc.suffix not in _SKIP:",
            "            yield dirloc",
            "        elif dirloc.is_dir():",
            "            # Use a generator expression for efficient filtering",
            "            files_in_dir = (",
            "                efile for efile in dirloc.rglob('*')",
            "                if efile.is_file() and efile.suffix not in _SKIP",
            "            )",
            "            # Yield all files from the filtered generator",
            "            yield from files_in_dir",
            "",
            "",
            "def generate_hashes(dirlocs):",
            "    \"\"\"Generate master hash for all files.\"\"\"",
            "    exec_hashes = {}",
            "    with ThreadPoolExecutor() as executor:",
            "        futures = []",
            "        for efile in get_all_files(dirlocs):",
            "            futures.append(",
            "                executor.submit(get_sha256, efile))",
            "        for future in futures:",
            "            sha = future.result()",
            "            exec_hashes[sha[0]] = sha[1]",
            "    return exec_hashes, gen_sha256_hash(str(exec_hashes))",
            "",
            "",
            "def get_executable_hashes():",
            "    # Internal Binaries shipped with MobSF",
            "    base = Path(settings.BASE_DIR)",
            "    manage_py = base.parent / 'manage.py'",
            "    exec_loc = [",
            "        base / 'DynamicAnalyzer' / 'tools',",
            "        base / 'StaticAnalyzer' / 'tools',",
            "        manage_py,",
            "    ]",
            "    # External binaries used directly by MobSF",
            "    system_bins = [",
            "        'adb',",
            "        'which',",
            "        'wkhtmltopdf',",
            "        'httptools',",
            "        'mitmdump',",
            "        'unzip',",
            "        'lipo',",
            "        'ar',",
            "        'nm',",
            "        'objdump',",
            "        'strings',",
            "        'xcrun',",
            "        'BinSkim.exe',",
            "        'BinScope.exe',",
            "        'nuget.exe',",
            "    ]",
            "    for sbin in system_bins:",
            "        bin_path = which(sbin)",
            "        if bin_path:",
            "            exec_loc.append(Path(bin_path))",
            "    # User defined path/binaries",
            "    if settings.JAVA_DIRECTORY:",
            "        exec_loc.append(Path(settings.JAVA_DIRECTORY))",
            "    user_defined_bins = [",
            "        sys.executable,",
            "        settings.JADX_BINARY,",
            "        settings.BACKSMALI_BINARY,",
            "        settings.VD2SVG_BINARY,",
            "        settings.APKTOOL_BINARY,",
            "        settings.ADB_BINARY,",
            "        settings.JTOOL_BINARY,",
            "        settings.CLASSDUMP_BINARY,",
            "        settings.CLASSDUMP_SWIFT_BINARY,",
            "        getattr(settings, 'BUNDLE_TOOL', ''),",
            "    ]",
            "    for ubin in user_defined_bins:",
            "        if ubin:",
            "            exec_loc.append(Path(ubin))",
            "    # Add ADB and Java binaries",
            "    adb = get_adb()",
            "    java = find_java_binary()",
            "    if adb == 'adb':",
            "        adb = which('adb')",
            "    if java == 'java':",
            "        java = which('java')",
            "    if adb:",
            "        exec_loc.append(Path(adb))",
            "    if java:",
            "        exec_loc.append(Path(java))",
            "    return generate_hashes(exec_loc)",
            "",
            "",
            "def store_exec_hashes_at_first_run():",
            "    \"\"\"Store executable hashes at first run.\"\"\"",
            "    try:",
            "        global EXECUTABLE_HASH_MAP",
            "        hashes, signature = get_executable_hashes()",
            "        hashes['signature'] = signature",
            "        EXECUTABLE_HASH_MAP = hashes",
            "    except Exception:",
            "        logger.exception('Cannot calculate executable hashes, '",
            "                         'disabling runtime executable '",
            "                         'tampering detection')",
            "",
            "",
            "def subprocess_hook(oldfunc, *args, **kwargs):",
            "    global EXECUTABLE_HASH_MAP",
            "    if isinstance(args[0], str):",
            "        # arg is a string",
            "        agmtz = args[0].split()",
            "        exec1 = agmtz[0]",
            "    else:",
            "        # list of args",
            "        agmtz = args[0]",
            "        exec1 = agmtz[0]  # executable",
            "    exec2 = None  # secondary executable",
            "    for arg in agmtz:",
            "        if arg.endswith('.jar'):",
            "            exec2 = Path(arg).as_posix()",
            "            break",
            "    if '/' in exec1 or '\\\\' in exec1:",
            "        exec1 = Path(exec1).as_posix()",
            "    else:",
            "        exec1 = Path(which(exec1)).as_posix()",
            "    executable_in_hash_map = False",
            "    if exec1 in EXECUTABLE_HASH_MAP:",
            "        executable_in_hash_map = True",
            "        if EXECUTABLE_HASH_MAP[exec1] != sha256(exec1):",
            "            msg = (",
            "                f'Executable Tampering Detected. [{exec1}]'",
            "                ' has been modified during runtime')",
            "            logger.error(msg)",
            "            raise Exception(msg)",
            "    if exec2 and exec2 in EXECUTABLE_HASH_MAP:",
            "        executable_in_hash_map = True",
            "        if EXECUTABLE_HASH_MAP[exec2] != sha256(exec2):",
            "            msg = (",
            "                f'JAR Tampering Detected. [{exec2}]'",
            "                ' has been modified during runtime')",
            "            logger.error(msg)",
            "            raise Exception(msg)",
            "    if not executable_in_hash_map:",
            "        logger.warning('Executable [%s] not found in known hashes, '",
            "                       'skipping runtime executable '",
            "                       'tampering detection', exec1)",
            "        _, signature = get_executable_hashes()",
            "        if EXECUTABLE_HASH_MAP['signature'] != signature:",
            "            msg = 'Executable/Library Tampering Detected'",
            "            logger.error(msg)",
            "            raise Exception(msg)",
            "    return oldfunc(*args, **kwargs)",
            "",
            "",
            "def init_exec_hooks():",
            "    subprocess.Popen = wrap_function(",
            "        subprocess.Popen,",
            "        subprocess_hook)",
            "",
            "",
            "def wrap_function(oldfunction, newfunction):",
            "    @functools.wraps(oldfunction)",
            "    def run(*args, **kwargs):",
            "        return newfunction(oldfunction, *args, **kwargs)",
            "    return run",
            "",
            "",
            "def sanitize_redirect(url):",
            "    \"\"\"Sanitize Redirect URL.\"\"\"",
            "    root = '/'",
            "    if url.startswith('//'):",
            "        return root",
            "    elif url.startswith('/'):",
            "        return url",
            "    return root"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "esphome.dashboard.web_server"
        ]
    },
    "mobsf/MobSF/views/authentication.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django.contrib import messages"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django.contrib.auth.decorators import login_required as lg"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from mobsf.MobSF.security import ("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    sanitize_redirect,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from brake.decorators import ratelimit"
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     else:"
            },
            "11": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         allow_pwd = False"
            },
            "12": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     nextp = request.GET.get('next', '')"
            },
            "13": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    redirect_url = nextp if nextp.startswith('/') else '/'"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    redirect_url = sanitize_redirect(nextp)"
            },
            "15": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     if request.user.is_authenticated:"
            },
            "16": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         return redirect(redirect_url)"
            },
            "17": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     if request.method == 'POST':"
            }
        },
        "frontPatchFile": [
            "\"\"\"User Login and Logout.\"\"\"",
            "from inspect import signature",
            "",
            "from django.shortcuts import (",
            "    redirect,",
            "    render,",
            ")",
            "from django.contrib.auth import (",
            "    login,",
            "    logout,",
            "    update_session_auth_hash,",
            ")",
            "from django.contrib.auth.forms import (",
            "    AuthenticationForm,",
            "    PasswordChangeForm,",
            ")",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.auth.decorators import login_required as lg",
            "",
            "from brake.decorators import ratelimit",
            "",
            "",
            "def login_required(func):",
            "    \"\"\"Login required decorator.\"\"\"",
            "    sig = signature(func)",
            "",
            "    def wrapper(request, *args, **kwargs):",
            "        arguments = sig.bind(request, *args, **kwargs)",
            "        api = arguments.arguments.get('api')",
            "        # Handle functions that are used by API and Web",
            "        if settings.DISABLE_AUTHENTICATION == '1' or api:",
            "            # Disable authentication for all functions",
            "            return func(request, *args, **kwargs)",
            "        # Force authentication for all",
            "        # web function calls",
            "        return lg(func)(request, *args, **kwargs)",
            "    return wrapper",
            "",
            "",
            "@ratelimit(ip=True,",
            "           method='POST',",
            "           rate=settings.RATELIMIT,",
            "           block=True)",
            "def login_view(request):",
            "    \"\"\"Login Controller.\"\"\"",
            "    if settings.DISABLE_AUTHENTICATION == '1':",
            "        return redirect('/')",
            "    sso = (settings.IDP_METADATA_URL",
            "           or (settings.IDP_SSO_URL",
            "               and settings.IDP_ENTITY_ID",
            "               and settings.IDP_X509CERT))",
            "    if not sso:",
            "        allow_pwd = True",
            "    elif bool(settings.SP_ALLOW_PASSWORD == '1'):",
            "        allow_pwd = True",
            "    else:",
            "        allow_pwd = False",
            "    nextp = request.GET.get('next', '')",
            "    redirect_url = nextp if nextp.startswith('/') else '/'",
            "    if request.user.is_authenticated:",
            "        return redirect(redirect_url)",
            "    if request.method == 'POST':",
            "        if sso and not allow_pwd:",
            "            return redirect('/')",
            "        form = AuthenticationForm(request, request.POST)",
            "        if form.is_valid():",
            "            user = form.get_user()",
            "            login(request, user)",
            "            return redirect(redirect_url)",
            "    else:",
            "        form = AuthenticationForm()",
            "    context = {",
            "        'title': 'Sign In',",
            "        'version': settings.VERSION,",
            "        'next': redirect_url,",
            "        'form': form,",
            "        'sso': sso,",
            "        'allow_pwd': allow_pwd,",
            "    }",
            "    return render(request, 'auth/login.html', context)",
            "",
            "",
            "def logout_view(request):",
            "    \"\"\"Logout Controller.\"\"\"",
            "    logout(request)",
            "    return redirect(settings.LOGIN_URL)",
            "",
            "",
            "@login_required",
            "def change_password(request):",
            "    if settings.DISABLE_AUTHENTICATION == '1':",
            "        return redirect('/')",
            "    if request.method == 'POST':",
            "        form = PasswordChangeForm(request.user, request.POST)",
            "        if form.is_valid():",
            "            user = form.save()",
            "            update_session_auth_hash(request, user)",
            "            messages.success(",
            "                request,",
            "                'Your password was successfully updated!')",
            "            return redirect('change_password')",
            "        else:",
            "            messages.error(",
            "                request,",
            "                'Please correct the error below.')",
            "    else:",
            "        form = PasswordChangeForm(request.user)",
            "    context = {",
            "        'title': 'Change Password',",
            "        'version': settings.VERSION,",
            "        'form': form,",
            "    }",
            "    return render(",
            "        request,",
            "        'auth/change_password.html',",
            "        context)"
        ],
        "afterPatchFile": [
            "\"\"\"User Login and Logout.\"\"\"",
            "from inspect import signature",
            "",
            "from django.shortcuts import (",
            "    redirect,",
            "    render,",
            ")",
            "from django.contrib.auth import (",
            "    login,",
            "    logout,",
            "    update_session_auth_hash,",
            ")",
            "from django.contrib.auth.forms import (",
            "    AuthenticationForm,",
            "    PasswordChangeForm,",
            ")",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.auth.decorators import login_required as lg",
            "",
            "from mobsf.MobSF.security import (",
            "    sanitize_redirect,",
            ")",
            "",
            "from brake.decorators import ratelimit",
            "",
            "",
            "def login_required(func):",
            "    \"\"\"Login required decorator.\"\"\"",
            "    sig = signature(func)",
            "",
            "    def wrapper(request, *args, **kwargs):",
            "        arguments = sig.bind(request, *args, **kwargs)",
            "        api = arguments.arguments.get('api')",
            "        # Handle functions that are used by API and Web",
            "        if settings.DISABLE_AUTHENTICATION == '1' or api:",
            "            # Disable authentication for all functions",
            "            return func(request, *args, **kwargs)",
            "        # Force authentication for all",
            "        # web function calls",
            "        return lg(func)(request, *args, **kwargs)",
            "    return wrapper",
            "",
            "",
            "@ratelimit(ip=True,",
            "           method='POST',",
            "           rate=settings.RATELIMIT,",
            "           block=True)",
            "def login_view(request):",
            "    \"\"\"Login Controller.\"\"\"",
            "    if settings.DISABLE_AUTHENTICATION == '1':",
            "        return redirect('/')",
            "    sso = (settings.IDP_METADATA_URL",
            "           or (settings.IDP_SSO_URL",
            "               and settings.IDP_ENTITY_ID",
            "               and settings.IDP_X509CERT))",
            "    if not sso:",
            "        allow_pwd = True",
            "    elif bool(settings.SP_ALLOW_PASSWORD == '1'):",
            "        allow_pwd = True",
            "    else:",
            "        allow_pwd = False",
            "    nextp = request.GET.get('next', '')",
            "    redirect_url = sanitize_redirect(nextp)",
            "    if request.user.is_authenticated:",
            "        return redirect(redirect_url)",
            "    if request.method == 'POST':",
            "        if sso and not allow_pwd:",
            "            return redirect('/')",
            "        form = AuthenticationForm(request, request.POST)",
            "        if form.is_valid():",
            "            user = form.get_user()",
            "            login(request, user)",
            "            return redirect(redirect_url)",
            "    else:",
            "        form = AuthenticationForm()",
            "    context = {",
            "        'title': 'Sign In',",
            "        'version': settings.VERSION,",
            "        'next': redirect_url,",
            "        'form': form,",
            "        'sso': sso,",
            "        'allow_pwd': allow_pwd,",
            "    }",
            "    return render(request, 'auth/login.html', context)",
            "",
            "",
            "def logout_view(request):",
            "    \"\"\"Logout Controller.\"\"\"",
            "    logout(request)",
            "    return redirect(settings.LOGIN_URL)",
            "",
            "",
            "@login_required",
            "def change_password(request):",
            "    if settings.DISABLE_AUTHENTICATION == '1':",
            "        return redirect('/')",
            "    if request.method == 'POST':",
            "        form = PasswordChangeForm(request.user, request.POST)",
            "        if form.is_valid():",
            "            user = form.save()",
            "            update_session_auth_hash(request, user)",
            "            messages.success(",
            "                request,",
            "                'Your password was successfully updated!')",
            "            return redirect('change_password')",
            "        else:",
            "            messages.error(",
            "                request,",
            "                'Please correct the error below.')",
            "    else:",
            "        form = PasswordChangeForm(request.user)",
            "    context = {",
            "        'title': 'Change Password',",
            "        'version': settings.VERSION,",
            "        'form': form,",
            "    }",
            "    return render(",
            "        request,",
            "        'auth/change_password.html',",
            "        context)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "60": [
                "login_view"
            ]
        },
        "addLocation": []
    },
    "mobsf/MobSF/views/saml2.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from mobsf.MobSF.utils import ("
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     print_n_send_error_response,"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from mobsf.MobSF.security import ("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    sanitize_redirect,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+)"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " ASSERTION_IDS = set()"
            },
            "9": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         return redirect_url"
            },
            "10": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     relay_state = req['post_data']['RelayState']"
            },
            "11": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     # Allow only relative URLs"
            },
            "12": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if (relay_state and relay_state.startswith('/')):"
            },
            "13": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        redirect_url = relay_state"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    if relay_state:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        redirect_url = sanitize_redirect(relay_state)"
            },
            "16": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     return redirect_url"
            },
            "17": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         req = prepare_django_request(request)"
            },
            "20": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         auth = init_saml_auth(req)"
            },
            "21": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         nextp = request.GET.get('next', '')"
            },
            "22": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        redirect_url = nextp if nextp.startswith('/') else '/'"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        redirect_url = sanitize_redirect(nextp)"
            },
            "24": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         return redirect(auth.login(return_to=redirect_url))"
            },
            "25": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     except Exception as exp:"
            },
            "26": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         return print_n_send_error_response("
            }
        },
        "frontPatchFile": [
            "\"\"\"SAML2 SSO logic.\"\"\"",
            "from urllib.parse import urlparse",
            "import logging",
            "",
            "from onelogin.saml2.auth import (",
            "    OneLogin_Saml2_Auth,",
            ")",
            "from onelogin.saml2.idp_metadata_parser import (",
            "    OneLogin_Saml2_IdPMetadataParser,",
            ")",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.models import (",
            "    Group,",
            "    User,",
            ")",
            "from django.contrib.auth import login",
            "from django.urls import reverse",
            "from django.shortcuts import redirect",
            "from django.views.decorators.http import require_http_methods",
            "",
            "from mobsf.MobSF.views.authorization import (",
            "    MAINTAINER_GROUP,",
            "    VIEWER_GROUP,",
            ")",
            "from mobsf.MobSF.utils import (",
            "    print_n_send_error_response,",
            ")",
            "",
            "logger = logging.getLogger(__name__)",
            "ASSERTION_IDS = set()",
            "",
            "",
            "def get_url_components(url):",
            "    \"\"\"Get URL components.\"\"\"",
            "    purl = urlparse(url)",
            "    return purl.scheme, purl.netloc, purl.port",
            "",
            "",
            "def init_saml_auth(req):",
            "    \"\"\"Initialize SAML auth.\"\"\"",
            "    host = req['sp_url']",
            "    acs_route = reverse('saml_acs')",
            "    saml_settings = {",
            "        'strict': True,",
            "        'debug': True,",
            "        'sp': {",
            "            'entityId': f'{host}{acs_route}',",
            "            'assertionConsumerService': {",
            "                'url': f'{host}{acs_route}',",
            "                'binding': ('urn:oasis:names:tc:'",
            "                            'SAML:2.0:bindings:HTTP-POST'),",
            "            },",
            "        },",
            "        'idp': {",
            "            'entityId': settings.IDP_ENTITY_ID,",
            "            'singleSignOnService': {",
            "                'url': settings.IDP_SSO_URL,",
            "                'binding': ('urn:oasis:names:tc:'",
            "                            'SAML:2.0:bindings:HTTP-Redirect'),",
            "            },",
            "            'x509cert': settings.IDP_X509CERT,",
            "        },",
            "    }",
            "    try:",
            "        idp_data = None",
            "        if settings.IDP_METADATA_URL:",
            "            idp_data = OneLogin_Saml2_IdPMetadataParser.parse_remote(",
            "                settings.IDP_METADATA_URL,",
            "                timeout=5)",
            "        if idp_data:",
            "            saml_settings['idp'] = idp_data['idp']",
            "    except Exception:",
            "        logger.exception('[ERROR] parsing IdP metadata URL.')",
            "    return OneLogin_Saml2_Auth(req, saml_settings)",
            "",
            "",
            "def prepare_django_request(request):",
            "    \"\"\"Prepare Django request for SAML.\"\"\"",
            "    scheme = 'https' if request.is_secure() else 'http'",
            "    netloc = request.get_host()",
            "    port = request.get_port()",
            "    if settings.SP_HOST:",
            "        scheme, netloc, port = get_url_components(",
            "            settings.SP_HOST.strip('/'))",
            "        if not port:",
            "            port = 443 if scheme == 'https' else 80",
            "    https_state = 'on' if scheme == 'https' else 'off'",
            "    sp_url = f'{scheme}://{netloc}'",
            "    result = {",
            "        'https': https_state,",
            "        'http_host': netloc,",
            "        'server_port': port,",
            "        'script_name': request.get_full_path_info(),",
            "        'get_data': request.GET.copy(),",
            "        'post_data': request.POST.copy(),",
            "        'lowercase_urlencoding': bool(settings.IDP_IS_ADFS == '1'),",
            "        'query_string': request.META['QUERY_STRING'],",
            "        'sp_url': sp_url,",
            "    }",
            "    return result",
            "",
            "",
            "def check_replay(auth):",
            "    \"\"\"Check for replay attack.\"\"\"",
            "    request_id = auth.get_last_assertion_id()",
            "    if request_id:",
            "        if request_id in ASSERTION_IDS:",
            "            raise Exception('Replay attack detected.')",
            "        ASSERTION_IDS.add(request_id)",
            "",
            "",
            "def get_redirect_url(req):",
            "    \"\"\"Check for open redirect and return redirect url.\"\"\"",
            "    redirect_url = '/'",
            "    if 'RelayState' not in req['post_data']:",
            "        return redirect_url",
            "    relay_state = req['post_data']['RelayState']",
            "    # Allow only relative URLs",
            "    if (relay_state and relay_state.startswith('/')):",
            "        redirect_url = relay_state",
            "    return redirect_url",
            "",
            "",
            "def get_user_role(roles):",
            "    \"\"\"Get user role.\"\"\"",
            "    mrole = any(MAINTAINER_GROUP.lower() in gp.lower() for gp in roles)",
            "    if mrole:",
            "        return MAINTAINER_GROUP",
            "    return VIEWER_GROUP",
            "",
            "",
            "@require_http_methods(['GET'])",
            "def saml_login(request):",
            "    \"\"\"Handle SSO Login.\"\"\"",
            "    try:",
            "        if settings.DISABLE_AUTHENTICATION == '1':",
            "            return redirect('/')",
            "        req = prepare_django_request(request)",
            "        auth = init_saml_auth(req)",
            "        nextp = request.GET.get('next', '')",
            "        redirect_url = nextp if nextp.startswith('/') else '/'",
            "        return redirect(auth.login(return_to=redirect_url))",
            "    except Exception as exp:",
            "        return print_n_send_error_response(",
            "            request,",
            "            exp,",
            "            False)",
            "",
            "",
            "@require_http_methods(['POST'])",
            "def saml_acs(request):",
            "    \"\"\"Handle SSO Assertion Consumer Service.\"\"\"",
            "    try:",
            "        if settings.DISABLE_AUTHENTICATION == '1':",
            "            return redirect('/')",
            "        req = prepare_django_request(request)",
            "        auth = init_saml_auth(req)",
            "        auth.process_response()",
            "        check_replay(auth)",
            "        if not auth.is_authenticated():",
            "            raise Exception(",
            "                'SAML authentication failed.')",
            "        # Extract user attributes for AuthZ and AuthN",
            "        attributes = auth.get_attributes()",
            "        if not attributes.get('email'):",
            "            raise Exception(",
            "                'email attribute not found in SAML response.')",
            "        if not attributes.get('role'):",
            "            raise Exception(",
            "                'role attribute not found in SAML response.')",
            "        email = attributes['email'][0]",
            "        role = get_user_role(attributes['role'])",
            "        if User.objects.filter(username=email).exists():",
            "            user = User.objects.get(username=email)",
            "            user.groups.clear()",
            "            user.groups.add(Group.objects.get(name=role))",
            "            login(request, user)",
            "        else:",
            "            user = User.objects.create_user(",
            "                username=email,",
            "                email=email)",
            "            user.is_staff = False",
            "            user.groups.add(Group.objects.get(name=role))",
            "            login(request, user)",
            "        return redirect(get_redirect_url(req))",
            "    except Exception as exp:",
            "        return print_n_send_error_response(",
            "            request,",
            "            exp,",
            "            False)"
        ],
        "afterPatchFile": [
            "\"\"\"SAML2 SSO logic.\"\"\"",
            "from urllib.parse import urlparse",
            "import logging",
            "",
            "from onelogin.saml2.auth import (",
            "    OneLogin_Saml2_Auth,",
            ")",
            "from onelogin.saml2.idp_metadata_parser import (",
            "    OneLogin_Saml2_IdPMetadataParser,",
            ")",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.models import (",
            "    Group,",
            "    User,",
            ")",
            "from django.contrib.auth import login",
            "from django.urls import reverse",
            "from django.shortcuts import redirect",
            "from django.views.decorators.http import require_http_methods",
            "",
            "from mobsf.MobSF.views.authorization import (",
            "    MAINTAINER_GROUP,",
            "    VIEWER_GROUP,",
            ")",
            "from mobsf.MobSF.utils import (",
            "    print_n_send_error_response,",
            ")",
            "from mobsf.MobSF.security import (",
            "    sanitize_redirect,",
            ")",
            "",
            "logger = logging.getLogger(__name__)",
            "ASSERTION_IDS = set()",
            "",
            "",
            "def get_url_components(url):",
            "    \"\"\"Get URL components.\"\"\"",
            "    purl = urlparse(url)",
            "    return purl.scheme, purl.netloc, purl.port",
            "",
            "",
            "def init_saml_auth(req):",
            "    \"\"\"Initialize SAML auth.\"\"\"",
            "    host = req['sp_url']",
            "    acs_route = reverse('saml_acs')",
            "    saml_settings = {",
            "        'strict': True,",
            "        'debug': True,",
            "        'sp': {",
            "            'entityId': f'{host}{acs_route}',",
            "            'assertionConsumerService': {",
            "                'url': f'{host}{acs_route}',",
            "                'binding': ('urn:oasis:names:tc:'",
            "                            'SAML:2.0:bindings:HTTP-POST'),",
            "            },",
            "        },",
            "        'idp': {",
            "            'entityId': settings.IDP_ENTITY_ID,",
            "            'singleSignOnService': {",
            "                'url': settings.IDP_SSO_URL,",
            "                'binding': ('urn:oasis:names:tc:'",
            "                            'SAML:2.0:bindings:HTTP-Redirect'),",
            "            },",
            "            'x509cert': settings.IDP_X509CERT,",
            "        },",
            "    }",
            "    try:",
            "        idp_data = None",
            "        if settings.IDP_METADATA_URL:",
            "            idp_data = OneLogin_Saml2_IdPMetadataParser.parse_remote(",
            "                settings.IDP_METADATA_URL,",
            "                timeout=5)",
            "        if idp_data:",
            "            saml_settings['idp'] = idp_data['idp']",
            "    except Exception:",
            "        logger.exception('[ERROR] parsing IdP metadata URL.')",
            "    return OneLogin_Saml2_Auth(req, saml_settings)",
            "",
            "",
            "def prepare_django_request(request):",
            "    \"\"\"Prepare Django request for SAML.\"\"\"",
            "    scheme = 'https' if request.is_secure() else 'http'",
            "    netloc = request.get_host()",
            "    port = request.get_port()",
            "    if settings.SP_HOST:",
            "        scheme, netloc, port = get_url_components(",
            "            settings.SP_HOST.strip('/'))",
            "        if not port:",
            "            port = 443 if scheme == 'https' else 80",
            "    https_state = 'on' if scheme == 'https' else 'off'",
            "    sp_url = f'{scheme}://{netloc}'",
            "    result = {",
            "        'https': https_state,",
            "        'http_host': netloc,",
            "        'server_port': port,",
            "        'script_name': request.get_full_path_info(),",
            "        'get_data': request.GET.copy(),",
            "        'post_data': request.POST.copy(),",
            "        'lowercase_urlencoding': bool(settings.IDP_IS_ADFS == '1'),",
            "        'query_string': request.META['QUERY_STRING'],",
            "        'sp_url': sp_url,",
            "    }",
            "    return result",
            "",
            "",
            "def check_replay(auth):",
            "    \"\"\"Check for replay attack.\"\"\"",
            "    request_id = auth.get_last_assertion_id()",
            "    if request_id:",
            "        if request_id in ASSERTION_IDS:",
            "            raise Exception('Replay attack detected.')",
            "        ASSERTION_IDS.add(request_id)",
            "",
            "",
            "def get_redirect_url(req):",
            "    \"\"\"Check for open redirect and return redirect url.\"\"\"",
            "    redirect_url = '/'",
            "    if 'RelayState' not in req['post_data']:",
            "        return redirect_url",
            "    relay_state = req['post_data']['RelayState']",
            "    # Allow only relative URLs",
            "    if relay_state:",
            "        redirect_url = sanitize_redirect(relay_state)",
            "    return redirect_url",
            "",
            "",
            "def get_user_role(roles):",
            "    \"\"\"Get user role.\"\"\"",
            "    mrole = any(MAINTAINER_GROUP.lower() in gp.lower() for gp in roles)",
            "    if mrole:",
            "        return MAINTAINER_GROUP",
            "    return VIEWER_GROUP",
            "",
            "",
            "@require_http_methods(['GET'])",
            "def saml_login(request):",
            "    \"\"\"Handle SSO Login.\"\"\"",
            "    try:",
            "        if settings.DISABLE_AUTHENTICATION == '1':",
            "            return redirect('/')",
            "        req = prepare_django_request(request)",
            "        auth = init_saml_auth(req)",
            "        nextp = request.GET.get('next', '')",
            "        redirect_url = sanitize_redirect(nextp)",
            "        return redirect(auth.login(return_to=redirect_url))",
            "    except Exception as exp:",
            "        return print_n_send_error_response(",
            "            request,",
            "            exp,",
            "            False)",
            "",
            "",
            "@require_http_methods(['POST'])",
            "def saml_acs(request):",
            "    \"\"\"Handle SSO Assertion Consumer Service.\"\"\"",
            "    try:",
            "        if settings.DISABLE_AUTHENTICATION == '1':",
            "            return redirect('/')",
            "        req = prepare_django_request(request)",
            "        auth = init_saml_auth(req)",
            "        auth.process_response()",
            "        check_replay(auth)",
            "        if not auth.is_authenticated():",
            "            raise Exception(",
            "                'SAML authentication failed.')",
            "        # Extract user attributes for AuthZ and AuthN",
            "        attributes = auth.get_attributes()",
            "        if not attributes.get('email'):",
            "            raise Exception(",
            "                'email attribute not found in SAML response.')",
            "        if not attributes.get('role'):",
            "            raise Exception(",
            "                'role attribute not found in SAML response.')",
            "        email = attributes['email'][0]",
            "        role = get_user_role(attributes['role'])",
            "        if User.objects.filter(username=email).exists():",
            "            user = User.objects.get(username=email)",
            "            user.groups.clear()",
            "            user.groups.add(Group.objects.get(name=role))",
            "            login(request, user)",
            "        else:",
            "            user = User.objects.create_user(",
            "                username=email,",
            "                email=email)",
            "            user.is_staff = False",
            "            user.groups.add(Group.objects.get(name=role))",
            "            login(request, user)",
            "        return redirect(get_redirect_url(req))",
            "    except Exception as exp:",
            "        return print_n_send_error_response(",
            "            request,",
            "            exp,",
            "            False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "120": [
                "get_redirect_url"
            ],
            "121": [
                "get_redirect_url"
            ],
            "142": [
                "saml_login"
            ]
        },
        "addLocation": []
    }
}