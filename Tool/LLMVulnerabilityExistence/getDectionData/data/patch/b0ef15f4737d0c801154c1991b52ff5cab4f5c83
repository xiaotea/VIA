{
    "scout/server/blueprints/alignviewers/controllers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " CUSTOM_TRACK_NAMES = [\"Genes\", \"ClinVar\", \"ClinVar CNVs\"]"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+def check_session_tracks(resource):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+    \"\"\"Make sure that a user requesting a resource is authenticated and resource is in session IGV tracks"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    Args:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+        resource(str): a resource on the server or on a remote URL"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    Returns"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+        True is user has access to resource else False"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    # Check that user is logged in or that file extension is valid"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    if current_user.is_authenticated is False:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        LOG.warning(\"Unauthenticated user requesting resource via remote_static\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        return False"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    if resource not in session.get(\"igv_tracks\", []):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        LOG.warning(f\"{resource} not in {session.get('igv_tracks', [])}\")"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        return False"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    return True"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " def set_session_tracks(display_obj):"
            },
            "23": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     \"\"\"Save igv tracks as a session object. This way it's easy to verify that a user is requesting one of these files from remote_static view endpoint"
            },
            "24": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     \"\"\""
            },
            "26": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     session_tracks = list(display_obj.get(\"reference_track\", {}).values())"
            },
            "27": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     for key, track_items in display_obj.items():"
            },
            "28": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if key not in [\"tracks\", \"custom_tracks\", \"sample_tracks\"]:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        if key not in [\"tracks\", \"custom_tracks\", \"sample_tracks\", \"cloud_public_tracks\"]:"
            },
            "30": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             continue"
            },
            "31": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         for track_item in track_items:"
            },
            "32": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             session_tracks += list(track_item.values())"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import logging",
            "import os.path",
            "",
            "from flask import flash, session",
            "from flask_login import current_user",
            "",
            "from scout.constants import CASE_SPECIFIC_TRACKS, HUMAN_REFERENCE, IGV_TRACKS",
            "from scout.server.extensions import cloud_tracks, store",
            "from scout.server.utils import case_append_alignments, institute_and_case",
            "from scout.utils.ensembl_rest_clients import EnsemblRestApiClient",
            "",
            "LOG = logging.getLogger(__name__)",
            "CUSTOM_TRACK_NAMES = [\"Genes\", \"ClinVar\", \"ClinVar CNVs\"]",
            "",
            "",
            "def set_session_tracks(display_obj):",
            "    \"\"\"Save igv tracks as a session object. This way it's easy to verify that a user is requesting one of these files from remote_static view endpoint",
            "",
            "    Args:",
            "        display_obj(dict): A display object containing case name, list of genes, lucus and tracks",
            "    \"\"\"",
            "    session_tracks = list(display_obj.get(\"reference_track\", {}).values())",
            "    for key, track_items in display_obj.items():",
            "        if key not in [\"tracks\", \"custom_tracks\", \"sample_tracks\"]:",
            "            continue",
            "        for track_item in track_items:",
            "            session_tracks += list(track_item.values())",
            "",
            "    session[\"igv_tracks\"] = session_tracks",
            "",
            "",
            "def make_igv_tracks(case_obj, variant_id, chrom=None, start=None, stop=None):",
            "    \"\"\"Create a dictionary containing the required tracks for displaying IGV tracks for case or a group of cases",
            "",
            "    Args:",
            "        institute_id(str): institute _id",
            "        case_obj(scout.models.Case)",
            "        variant_id(str): _id of a variant",
            "        chrom(str/None): requested chromosome [1-22], X, Y, [M-MT]",
            "        start(int/None): start of the genomic interval to be displayed",
            "        stop(int/None): stop of the genomic interval to be displayed",
            "",
            "    Returns:",
            "        display_obj(dict): A display object containing case name, list of genes, lucus and tracks",
            "    \"\"\"",
            "    display_obj = {}",
            "    variant_obj = store.variant(document_id=variant_id)",
            "",
            "    if variant_obj:",
            "        # Set display locus",
            "        start = start or variant_obj[\"position\"]",
            "        stop = stop or variant_obj[\"end\"]",
            "",
            "        chromosome = chrom or variant_obj.get(\"chromosome\")",
            "        chromosome = chromosome.replace(\"MT\", \"M\")",
            "        display_obj[\"locus\"] = \"chr{0}:{1}-{2}\".format(chromosome, start, stop)",
            "    else:",
            "        chromosome = \"All\"",
            "",
            "    # Set genome build for displaying alignments:",
            "    if \"38\" in str(case_obj.get(\"genome_build\", \"37\")) or chromosome == \"M\":",
            "        build = \"38\"",
            "    else:",
            "        build = \"37\"",
            "",
            "    # Set general tracks (Genes, Clinvar and ClinVar SNVs are shown according to user preferences)",
            "    set_common_tracks(display_obj, build)",
            "",
            "    # Build tracks for main case and all connected cases (cases grouped with main case)",
            "    grouped_cases = []",
            "    for group in case_obj.get(\"group\", []):",
            "        group_cases = list(store.cases(group=group))",
            "        for case in group_cases:",
            "            case_append_alignments(case)  # Add track data to connected case dictionary",
            "            grouped_cases.append(case)",
            "",
            "    if not grouped_cases:  # Display case individuals tracks only",
            "        case_append_alignments(case_obj)  # Add track data to main case dictionary",
            "        grouped_cases.append(case_obj)",
            "",
            "    # Set up bam/cram alignments for case group samples:",
            "    set_sample_tracks(display_obj, grouped_cases, chromosome)",
            "",
            "    # When chrom != MT, set up case-specific tracks (might be present according to the pipeline)",
            "    if chrom != \"M\":",
            "        set_case_specific_tracks(display_obj, case_obj)",
            "",
            "    # Set up custom cloud public tracks, if available",
            "    set_cloud_public_tracks(display_obj, build)",
            "",
            "    display_obj[\"display_center_guide\"] = True",
            "",
            "    return display_obj",
            "",
            "",
            "def make_sashimi_tracks(case_obj, variant_id):",
            "    \"\"\"Create a dictionary containing the required tracks for a splice junction plot",
            "",
            "    Args:",
            "        case_obj(scout.models.Case)",
            "        variant_id(str) _id of a variant",
            "    Returns:",
            "        display_obj(dict): A display object containing case name, list of genes, lucus and tracks",
            "    \"\"\"",
            "    build = \"38\"  # This feature is only available for RNA tracks in build 38",
            "",
            "    variant_obj = store.variant(document_id=variant_id)",
            "",
            "    # Initialize locus coordinates it with variant coordinates so it won't crash if variant gene(s) no longer exist in database",
            "    locus_start_coords = []",
            "    locus_end_coords = []",
            "",
            "    # Check if variant coordinates are in genome build 38",
            "    # Otherwise do variant coords liftover",
            "    if build not in str(case_obj.get(\"genome_build\")):",
            "        client = EnsemblRestApiClient()",
            "        mapped_coords = client.liftover(",
            "            case_obj.get(\"genome_build\"),",
            "            variant_obj.get(\"chromosome\"),",
            "            variant_obj.get(\"position\"),",
            "            variant_obj.get(\"end\"),",
            "        )",
            "        if mapped_coords:",
            "            mapped_start = mapped_coords[0][\"mapped\"].get(\"start\")",
            "            mapped_end = mapped_coords[0][\"mapped\"].get(\"end\") or mapped_start",
            "            locus_start_coords.append(mapped_start)",
            "            locus_end_coords.append(mapped_end)",
            "",
            "    # Use original coordinates only genome build was already 38 or liftover didn't work",
            "    if not locus_start_coords:",
            "        locus_start_coords.append(variant_obj.get(\"position\"))",
            "    if not locus_end_coords:",
            "        locus_end_coords.append(variant_obj.get(\"end\"))",
            "",
            "    # Collect locus coordinates. Take into account that variant can hit multiple genes",
            "    variant_genes_ids = [gene[\"hgnc_id\"] for gene in variant_obj.get(\"genes\", [])]",
            "    for gene_id in variant_genes_ids:",
            "        gene_caption = store.hgnc_gene_caption(hgnc_identifier=gene_id, build=build)",
            "        if gene_caption is None:",
            "            continue",
            "        locus_start_coords.append(gene_caption[\"start\"])",
            "        locus_end_coords.append(gene_caption[\"end\"])",
            "",
            "    locus_start = min(locus_start_coords)",
            "    locus_end = max(locus_end_coords)",
            "",
            "    locus = f\"{variant_obj['chromosome']}:{locus_start}-{locus_end}\"  # Locus will span all genes the variant falls into",
            "    display_obj = {\"locus\": locus, \"tracks\": []}",
            "",
            "    # Add Genes and reference tracks to display object",
            "    set_common_tracks(display_obj, build)",
            "",
            "    # Populate tracks for each individual with splice junction track data",
            "    for ind in case_obj.get(\"individuals\", []):",
            "        if not all([ind.get(\"splice_junctions_bed\"), ind.get(\"rna_coverage_bigwig\")]):",
            "            continue",
            "",
            "        coverage_wig = ind[\"rna_coverage_bigwig\"]",
            "        splicej_bed = ind[\"splice_junctions_bed\"]",
            "        splicej_bed_index = f\"{splicej_bed}.tbi\" if os.path.isfile(f\"{splicej_bed}.tbi\") else None",
            "        if splicej_bed_index is None:",
            "            flash(f\"Missing bed file index for individual {ind['display_name']}\")",
            "",
            "        track = {",
            "            \"name\": ind[\"display_name\"],",
            "            \"coverage_wig\": coverage_wig,",
            "            \"splicej_bed\": splicej_bed,",
            "            \"splicej_bed_index\": splicej_bed_index,",
            "        }",
            "        display_obj[\"tracks\"].append(track)",
            "",
            "    display_obj[\"case\"] = case_obj[\"display_name\"]",
            "",
            "    return display_obj",
            "",
            "",
            "def set_tracks(name, file_list):",
            "    \"\"\"Return a dict according to IGV track format.\"\"\"",
            "    track_list = []",
            "    for track in file_list:",
            "        track_list.append({\"name\": name, \"url\": track, \"min\": 0.0, \"max\": 30.0})",
            "    return track_list",
            "",
            "",
            "def set_common_tracks(display_obj, build):",
            "    \"\"\"Set up tracks common to all cases (Genes, ClinVar ClinVar CNVs) according to user preferences",
            "",
            "    Args:",
            "        display_obj(dict) dictionary containing all tracks info",
            "        build(string) \"37\" or \"38\"",
            "    \"\"\"",
            "    user_obj = store.user(email=current_user.email)",
            "",
            "    # Set up IGV tracks that are common for all cases:",
            "    display_obj[\"reference_track\"] = HUMAN_REFERENCE[build]  # Human reference is always present",
            "",
            "    # if user settings for igv tracks exist -> use these settings, otherwise display all tracks",
            "    custom_tracks_names = user_obj.get(\"igv_tracks\") or CUSTOM_TRACK_NAMES",
            "",
            "    display_obj[\"custom_tracks\"] = []",
            "    for track in IGV_TRACKS[build]:",
            "        # if track is selected, add it to track display object",
            "        if track[\"name\"] in custom_tracks_names:",
            "            display_obj[\"custom_tracks\"].append(track)",
            "",
            "",
            "def set_sample_tracks(display_obj, case_groups, chromosome):",
            "    \"\"\"Set up individual-specific alignment tracks (bam/cram files)",
            "",
            "    Args:",
            "        display_obj(dict): dictionary containing all tracks info",
            "        case_groups(list): a list of case dictionaries",
            "        chromosome(str) [1-22],X,Y,M or \"All\"",
            "    \"\"\"",
            "    sample_tracks = []",
            "",
            "    track_items = \"mt_bams\" if chromosome == \"M\" else \"bam_files\"",
            "    track_index_items = \"mt_bais\" if track_items == \"mt_bams\" else \"bai_files\"",
            "",
            "    # Loop over a group of cases and add tracks for every individual of of every case",
            "    for case in case_groups:",
            "        if None in [",
            "            case.get(\"sample_names\"),",
            "            case.get(track_items),",
            "            case.get(track_index_items),",
            "        ]:",
            "            case[\"sample_tracks\"] = []",
            "            return",
            "",
            "        for count, sample in enumerate(case.get(\"sample_names\")):",
            "            sample_tracks.append(",
            "                {",
            "                    \"name\": sample,",
            "                    \"url\": case[track_items][count],",
            "                    \"indexURL\": case[track_index_items][count],",
            "                    \"format\": case[track_items][count].split(\".\")[-1],  # \"bam\" or \"cram\"",
            "                    \"height\": 700,",
            "                }",
            "            )",
            "        display_obj[\"sample_tracks\"] = sample_tracks",
            "",
            "",
            "def set_case_specific_tracks(display_obj, case_obj):",
            "    \"\"\"Set up tracks from files that might be present or not at the case level",
            "        (rhocall files, tiddit coverage files, upd regions and sites files)",
            "    Args:",
            "        display_obj(dict) dictionary containing all tracks info",
            "        form(dict) flask request form dictionary",
            "    \"\"\"",
            "    for track, label in CASE_SPECIFIC_TRACKS.items():",
            "        if case_obj.get(track) is None:",
            "            continue",
            "        track_info = set_tracks(label, case_obj.get(track).split(\",\"))",
            "        display_obj[track] = track_info",
            "",
            "",
            "def set_cloud_public_tracks(display_obj, build):",
            "    \"\"\"Set up custom public tracks stored in a cloud bucket, according to the user preferences",
            "",
            "    Args:",
            "        display_obj(dict) dictionary containing all tracks info",
            "        build(string) \"37\" or \"38\"",
            "    \"\"\"",
            "    user_obj = store.user(email=current_user.email)",
            "    custom_tracks_names = user_obj.get(\"igv_tracks\")",
            "",
            "    cloud_public_tracks = []",
            "    if hasattr(cloud_tracks, \"public_tracks\"):",
            "        build_tracks = cloud_tracks.public_tracks.get(build, [])",
            "        for track in build_tracks:",
            "            # Do not display track if user doesn't want to see it",
            "            if custom_tracks_names and track[\"name\"] not in custom_tracks_names:",
            "                continue",
            "            cloud_public_tracks.append(track)",
            "    if cloud_public_tracks:",
            "        display_obj[\"cloud_public_tracks\"] = cloud_public_tracks"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import logging",
            "import os.path",
            "",
            "from flask import flash, session",
            "from flask_login import current_user",
            "",
            "from scout.constants import CASE_SPECIFIC_TRACKS, HUMAN_REFERENCE, IGV_TRACKS",
            "from scout.server.extensions import cloud_tracks, store",
            "from scout.server.utils import case_append_alignments, institute_and_case",
            "from scout.utils.ensembl_rest_clients import EnsemblRestApiClient",
            "",
            "LOG = logging.getLogger(__name__)",
            "CUSTOM_TRACK_NAMES = [\"Genes\", \"ClinVar\", \"ClinVar CNVs\"]",
            "",
            "",
            "def check_session_tracks(resource):",
            "    \"\"\"Make sure that a user requesting a resource is authenticated and resource is in session IGV tracks",
            "",
            "    Args:",
            "        resource(str): a resource on the server or on a remote URL",
            "",
            "    Returns",
            "        True is user has access to resource else False",
            "    \"\"\"",
            "    # Check that user is logged in or that file extension is valid",
            "    if current_user.is_authenticated is False:",
            "        LOG.warning(\"Unauthenticated user requesting resource via remote_static\")",
            "        return False",
            "    if resource not in session.get(\"igv_tracks\", []):",
            "        LOG.warning(f\"{resource} not in {session.get('igv_tracks', [])}\")",
            "        return False",
            "    return True",
            "",
            "",
            "def set_session_tracks(display_obj):",
            "    \"\"\"Save igv tracks as a session object. This way it's easy to verify that a user is requesting one of these files from remote_static view endpoint",
            "",
            "    Args:",
            "        display_obj(dict): A display object containing case name, list of genes, lucus and tracks",
            "    \"\"\"",
            "    session_tracks = list(display_obj.get(\"reference_track\", {}).values())",
            "    for key, track_items in display_obj.items():",
            "        if key not in [\"tracks\", \"custom_tracks\", \"sample_tracks\", \"cloud_public_tracks\"]:",
            "            continue",
            "        for track_item in track_items:",
            "            session_tracks += list(track_item.values())",
            "",
            "    session[\"igv_tracks\"] = session_tracks",
            "",
            "",
            "def make_igv_tracks(case_obj, variant_id, chrom=None, start=None, stop=None):",
            "    \"\"\"Create a dictionary containing the required tracks for displaying IGV tracks for case or a group of cases",
            "",
            "    Args:",
            "        institute_id(str): institute _id",
            "        case_obj(scout.models.Case)",
            "        variant_id(str): _id of a variant",
            "        chrom(str/None): requested chromosome [1-22], X, Y, [M-MT]",
            "        start(int/None): start of the genomic interval to be displayed",
            "        stop(int/None): stop of the genomic interval to be displayed",
            "",
            "    Returns:",
            "        display_obj(dict): A display object containing case name, list of genes, lucus and tracks",
            "    \"\"\"",
            "    display_obj = {}",
            "    variant_obj = store.variant(document_id=variant_id)",
            "",
            "    if variant_obj:",
            "        # Set display locus",
            "        start = start or variant_obj[\"position\"]",
            "        stop = stop or variant_obj[\"end\"]",
            "",
            "        chromosome = chrom or variant_obj.get(\"chromosome\")",
            "        chromosome = chromosome.replace(\"MT\", \"M\")",
            "        display_obj[\"locus\"] = \"chr{0}:{1}-{2}\".format(chromosome, start, stop)",
            "    else:",
            "        chromosome = \"All\"",
            "",
            "    # Set genome build for displaying alignments:",
            "    if \"38\" in str(case_obj.get(\"genome_build\", \"37\")) or chromosome == \"M\":",
            "        build = \"38\"",
            "    else:",
            "        build = \"37\"",
            "",
            "    # Set general tracks (Genes, Clinvar and ClinVar SNVs are shown according to user preferences)",
            "    set_common_tracks(display_obj, build)",
            "",
            "    # Build tracks for main case and all connected cases (cases grouped with main case)",
            "    grouped_cases = []",
            "    for group in case_obj.get(\"group\", []):",
            "        group_cases = list(store.cases(group=group))",
            "        for case in group_cases:",
            "            case_append_alignments(case)  # Add track data to connected case dictionary",
            "            grouped_cases.append(case)",
            "",
            "    if not grouped_cases:  # Display case individuals tracks only",
            "        case_append_alignments(case_obj)  # Add track data to main case dictionary",
            "        grouped_cases.append(case_obj)",
            "",
            "    # Set up bam/cram alignments for case group samples:",
            "    set_sample_tracks(display_obj, grouped_cases, chromosome)",
            "",
            "    # When chrom != MT, set up case-specific tracks (might be present according to the pipeline)",
            "    if chrom != \"M\":",
            "        set_case_specific_tracks(display_obj, case_obj)",
            "",
            "    # Set up custom cloud public tracks, if available",
            "    set_cloud_public_tracks(display_obj, build)",
            "",
            "    display_obj[\"display_center_guide\"] = True",
            "",
            "    return display_obj",
            "",
            "",
            "def make_sashimi_tracks(case_obj, variant_id):",
            "    \"\"\"Create a dictionary containing the required tracks for a splice junction plot",
            "",
            "    Args:",
            "        case_obj(scout.models.Case)",
            "        variant_id(str) _id of a variant",
            "    Returns:",
            "        display_obj(dict): A display object containing case name, list of genes, lucus and tracks",
            "    \"\"\"",
            "    build = \"38\"  # This feature is only available for RNA tracks in build 38",
            "",
            "    variant_obj = store.variant(document_id=variant_id)",
            "",
            "    # Initialize locus coordinates it with variant coordinates so it won't crash if variant gene(s) no longer exist in database",
            "    locus_start_coords = []",
            "    locus_end_coords = []",
            "",
            "    # Check if variant coordinates are in genome build 38",
            "    # Otherwise do variant coords liftover",
            "    if build not in str(case_obj.get(\"genome_build\")):",
            "        client = EnsemblRestApiClient()",
            "        mapped_coords = client.liftover(",
            "            case_obj.get(\"genome_build\"),",
            "            variant_obj.get(\"chromosome\"),",
            "            variant_obj.get(\"position\"),",
            "            variant_obj.get(\"end\"),",
            "        )",
            "        if mapped_coords:",
            "            mapped_start = mapped_coords[0][\"mapped\"].get(\"start\")",
            "            mapped_end = mapped_coords[0][\"mapped\"].get(\"end\") or mapped_start",
            "            locus_start_coords.append(mapped_start)",
            "            locus_end_coords.append(mapped_end)",
            "",
            "    # Use original coordinates only genome build was already 38 or liftover didn't work",
            "    if not locus_start_coords:",
            "        locus_start_coords.append(variant_obj.get(\"position\"))",
            "    if not locus_end_coords:",
            "        locus_end_coords.append(variant_obj.get(\"end\"))",
            "",
            "    # Collect locus coordinates. Take into account that variant can hit multiple genes",
            "    variant_genes_ids = [gene[\"hgnc_id\"] for gene in variant_obj.get(\"genes\", [])]",
            "    for gene_id in variant_genes_ids:",
            "        gene_caption = store.hgnc_gene_caption(hgnc_identifier=gene_id, build=build)",
            "        if gene_caption is None:",
            "            continue",
            "        locus_start_coords.append(gene_caption[\"start\"])",
            "        locus_end_coords.append(gene_caption[\"end\"])",
            "",
            "    locus_start = min(locus_start_coords)",
            "    locus_end = max(locus_end_coords)",
            "",
            "    locus = f\"{variant_obj['chromosome']}:{locus_start}-{locus_end}\"  # Locus will span all genes the variant falls into",
            "    display_obj = {\"locus\": locus, \"tracks\": []}",
            "",
            "    # Add Genes and reference tracks to display object",
            "    set_common_tracks(display_obj, build)",
            "",
            "    # Populate tracks for each individual with splice junction track data",
            "    for ind in case_obj.get(\"individuals\", []):",
            "        if not all([ind.get(\"splice_junctions_bed\"), ind.get(\"rna_coverage_bigwig\")]):",
            "            continue",
            "",
            "        coverage_wig = ind[\"rna_coverage_bigwig\"]",
            "        splicej_bed = ind[\"splice_junctions_bed\"]",
            "        splicej_bed_index = f\"{splicej_bed}.tbi\" if os.path.isfile(f\"{splicej_bed}.tbi\") else None",
            "        if splicej_bed_index is None:",
            "            flash(f\"Missing bed file index for individual {ind['display_name']}\")",
            "",
            "        track = {",
            "            \"name\": ind[\"display_name\"],",
            "            \"coverage_wig\": coverage_wig,",
            "            \"splicej_bed\": splicej_bed,",
            "            \"splicej_bed_index\": splicej_bed_index,",
            "        }",
            "        display_obj[\"tracks\"].append(track)",
            "",
            "    display_obj[\"case\"] = case_obj[\"display_name\"]",
            "",
            "    return display_obj",
            "",
            "",
            "def set_tracks(name, file_list):",
            "    \"\"\"Return a dict according to IGV track format.\"\"\"",
            "    track_list = []",
            "    for track in file_list:",
            "        track_list.append({\"name\": name, \"url\": track, \"min\": 0.0, \"max\": 30.0})",
            "    return track_list",
            "",
            "",
            "def set_common_tracks(display_obj, build):",
            "    \"\"\"Set up tracks common to all cases (Genes, ClinVar ClinVar CNVs) according to user preferences",
            "",
            "    Args:",
            "        display_obj(dict) dictionary containing all tracks info",
            "        build(string) \"37\" or \"38\"",
            "    \"\"\"",
            "    user_obj = store.user(email=current_user.email)",
            "",
            "    # Set up IGV tracks that are common for all cases:",
            "    display_obj[\"reference_track\"] = HUMAN_REFERENCE[build]  # Human reference is always present",
            "",
            "    # if user settings for igv tracks exist -> use these settings, otherwise display all tracks",
            "    custom_tracks_names = user_obj.get(\"igv_tracks\") or CUSTOM_TRACK_NAMES",
            "",
            "    display_obj[\"custom_tracks\"] = []",
            "    for track in IGV_TRACKS[build]:",
            "        # if track is selected, add it to track display object",
            "        if track[\"name\"] in custom_tracks_names:",
            "            display_obj[\"custom_tracks\"].append(track)",
            "",
            "",
            "def set_sample_tracks(display_obj, case_groups, chromosome):",
            "    \"\"\"Set up individual-specific alignment tracks (bam/cram files)",
            "",
            "    Args:",
            "        display_obj(dict): dictionary containing all tracks info",
            "        case_groups(list): a list of case dictionaries",
            "        chromosome(str) [1-22],X,Y,M or \"All\"",
            "    \"\"\"",
            "    sample_tracks = []",
            "",
            "    track_items = \"mt_bams\" if chromosome == \"M\" else \"bam_files\"",
            "    track_index_items = \"mt_bais\" if track_items == \"mt_bams\" else \"bai_files\"",
            "",
            "    # Loop over a group of cases and add tracks for every individual of of every case",
            "    for case in case_groups:",
            "        if None in [",
            "            case.get(\"sample_names\"),",
            "            case.get(track_items),",
            "            case.get(track_index_items),",
            "        ]:",
            "            case[\"sample_tracks\"] = []",
            "            return",
            "",
            "        for count, sample in enumerate(case.get(\"sample_names\")):",
            "            sample_tracks.append(",
            "                {",
            "                    \"name\": sample,",
            "                    \"url\": case[track_items][count],",
            "                    \"indexURL\": case[track_index_items][count],",
            "                    \"format\": case[track_items][count].split(\".\")[-1],  # \"bam\" or \"cram\"",
            "                    \"height\": 700,",
            "                }",
            "            )",
            "        display_obj[\"sample_tracks\"] = sample_tracks",
            "",
            "",
            "def set_case_specific_tracks(display_obj, case_obj):",
            "    \"\"\"Set up tracks from files that might be present or not at the case level",
            "        (rhocall files, tiddit coverage files, upd regions and sites files)",
            "    Args:",
            "        display_obj(dict) dictionary containing all tracks info",
            "        form(dict) flask request form dictionary",
            "    \"\"\"",
            "    for track, label in CASE_SPECIFIC_TRACKS.items():",
            "        if case_obj.get(track) is None:",
            "            continue",
            "        track_info = set_tracks(label, case_obj.get(track).split(\",\"))",
            "        display_obj[track] = track_info",
            "",
            "",
            "def set_cloud_public_tracks(display_obj, build):",
            "    \"\"\"Set up custom public tracks stored in a cloud bucket, according to the user preferences",
            "",
            "    Args:",
            "        display_obj(dict) dictionary containing all tracks info",
            "        build(string) \"37\" or \"38\"",
            "    \"\"\"",
            "    user_obj = store.user(email=current_user.email)",
            "    custom_tracks_names = user_obj.get(\"igv_tracks\")",
            "",
            "    cloud_public_tracks = []",
            "    if hasattr(cloud_tracks, \"public_tracks\"):",
            "        build_tracks = cloud_tracks.public_tracks.get(build, [])",
            "        for track in build_tracks:",
            "            # Do not display track if user doesn't want to see it",
            "            if custom_tracks_names and track[\"name\"] not in custom_tracks_names:",
            "                continue",
            "            cloud_public_tracks.append(track)",
            "    if cloud_public_tracks:",
            "        display_obj[\"cloud_public_tracks\"] = cloud_public_tracks"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "25": [
                "set_session_tracks"
            ]
        },
        "addLocation": [
            "lib.ansible.plugins.action.ActionBase._execute_module"
        ]
    },
    "scout/server/blueprints/alignviewers/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     Based on code from answers to this thread:"
            },
            "1": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         https://stackoverflow.com/questions/6656363/proxying-to-another-web-service-with-flask/"
            },
            "2": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     \"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    # Check that user is logged in or that file extension is valid"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    if controllers.check_session_tracks(remote_url) is False:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        return abort(403)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     resp = requests.request("
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         method=request.method,"
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         url=remote_url,"
            },
            "10": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     file_path = request.args.get(\"file\") or \".\""
            },
            "11": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     # Check that user is logged in or that file extension is valid"
            },
            "13": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if current_user.is_authenticated is False or file_path not in session.get(\"igv_tracks\", []):"
            },
            "14": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        LOG.warning(f\"{file_path} not in {session.get('igv_tracks', [])}\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    if controllers.check_session_tracks(file_path) is False:"
            },
            "16": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         return abort(403)"
            },
            "17": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     range_header = request.headers.get(\"Range\", None)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import logging",
            "",
            "import requests",
            "from flask import (",
            "    Blueprint,",
            "    Response,",
            "    abort,",
            "    copy_current_request_context,",
            "    render_template,",
            "    request,",
            "    session,",
            ")",
            "from flask_login import current_user",
            "",
            "from scout.server.extensions import store",
            "from scout.server.utils import institute_and_case",
            "",
            "from . import controllers",
            "from .partial import send_file_partial",
            "",
            "alignviewers_bp = Blueprint(",
            "    \"alignviewers\",",
            "    __name__,",
            "    template_folder=\"templates\",",
            "    static_folder=\"static\",",
            "    static_url_path=\"/alignviewers/static\",",
            ")",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "@alignviewers_bp.route(\"/remote/cors/<path:remote_url>\", methods=[\"OPTIONS\", \"GET\"])",
            "def remote_cors(remote_url):",
            "    \"\"\"Proxy a remote URL.",
            "    Useful to e.g. eliminate CORS issues when the remote site does not",
            "        communicate CORS headers well, as in cloud tracks on figshare for IGV.js.",
            "",
            "    Based on code from answers to this thread:",
            "        https://stackoverflow.com/questions/6656363/proxying-to-another-web-service-with-flask/",
            "    \"\"\"",
            "    resp = requests.request(",
            "        method=request.method,",
            "        url=remote_url,",
            "        headers={key: value for (key, value) in request.headers if key != \"Host\"},",
            "        data=request.get_data(),",
            "        cookies=request.cookies,",
            "        allow_redirects=True,",
            "    )",
            "",
            "    excluded_headers = [",
            "        \"content-encoding\",",
            "        \"content-length\",",
            "        \"transfer-encoding\",",
            "        \"connection\",",
            "    ]",
            "    headers = [",
            "        (name, value)",
            "        for (name, value) in resp.raw.headers.items()",
            "        if name.lower() not in excluded_headers",
            "    ]",
            "",
            "    response = Response(resp.content, resp.status_code, headers)",
            "    return response",
            "",
            "",
            "@alignviewers_bp.route(\"/remote/static\", methods=[\"OPTIONS\", \"GET\"])",
            "def remote_static():",
            "    \"\"\"Stream *large* static files with special requirements.\"\"\"",
            "    file_path = request.args.get(\"file\") or \".\"",
            "",
            "    # Check that user is logged in or that file extension is valid",
            "    if current_user.is_authenticated is False or file_path not in session.get(\"igv_tracks\", []):",
            "        LOG.warning(f\"{file_path} not in {session.get('igv_tracks', [])}\")",
            "        return abort(403)",
            "",
            "    range_header = request.headers.get(\"Range\", None)",
            "    if not range_header and (file_path.endswith(\".bam\") or file_path.endswith(\".cram\")):",
            "        return abort(500)",
            "",
            "    new_resp = send_file_partial(file_path)",
            "    return new_resp",
            "",
            "",
            "@alignviewers_bp.route(",
            "    \"/<institute_id>/<case_name>/<variant_id>/igv-splice-junctions\", methods=[\"GET\"]",
            ")",
            "def sashimi_igv(institute_id, case_name, variant_id):",
            "    \"\"\"Visualize splice junctions on igv.js sashimi-like viewer for one or more individuals of a case.",
            "    wiki: https://github.com/igvteam/igv.js/wiki/Splice-Junctions",
            "    \"\"\"",
            "    _, case_obj = institute_and_case(",
            "        store, institute_id, case_name",
            "    )  # This function takes care of checking if user is authorized to see resource",
            "",
            "    display_obj = controllers.make_sashimi_tracks(case_obj, variant_id)",
            "    controllers.set_session_tracks(display_obj)",
            "",
            "    response = Response(render_template(\"alignviewers/igv_sashimi_viewer.html\", **display_obj))",
            "",
            "    @response.call_on_close",
            "    @copy_current_request_context",
            "    def clear_session_tracks():",
            "        session.pop(\"igv_tracks\", None)  # clean up igv session tracks",
            "",
            "    return response",
            "",
            "",
            "@alignviewers_bp.route(\"/<institute_id>/<case_name>/igv\", methods=[\"GET\"])  # from case page",
            "@alignviewers_bp.route(",
            "    \"/<institute_id>/<case_name>/<variant_id>/igv\", methods=[\"GET\"]",
            ")  # from SNV and STR variant page",
            "@alignviewers_bp.route(",
            "    \"/<institute_id>/<case_name>/<variant_id>/<chrom>/<start>/<stop>/igv\", methods=[\"GET\"]",
            ")  # from SV variant page, where you have to pass breakpoints coordinates",
            "def igv(institute_id, case_name, variant_id=None, chrom=None, start=None, stop=None):",
            "    \"\"\"Visualize BAM alignments using igv.js (https://github.com/igvteam/igv.js)",
            "",
            "    Args:",
            "        institute_id(str): _id of an institute",
            "        case_name(str): dislay_name of a case",
            "        variant_id(str/None): variant _id or None",
            "        chrom(str/None): requested chromosome [1-22], X, Y, [M-MT]",
            "        start(int/None): start of the genomic interval to be displayed",
            "        stop(int/None): stop of the genomic interval to be displayed",
            "",
            "    Returns:",
            "        a string, corresponging to the HTML rendering of the IGV alignments page",
            "    \"\"\"",
            "    _, case_obj = institute_and_case(",
            "        store, institute_id, case_name",
            "    )  # This function takes care of checking if user is authorized to see resource",
            "",
            "    display_obj = controllers.make_igv_tracks(case_obj, variant_id, chrom, start, stop)",
            "    controllers.set_session_tracks(display_obj)",
            "",
            "    response = Response(render_template(\"alignviewers/igv_viewer.html\", **display_obj))",
            "",
            "    @response.call_on_close",
            "    @copy_current_request_context",
            "    def clear_session_tracks():",
            "        session.pop(\"igv_tracks\", None)  # clean up igv session tracks",
            "",
            "    return response"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import logging",
            "",
            "import requests",
            "from flask import (",
            "    Blueprint,",
            "    Response,",
            "    abort,",
            "    copy_current_request_context,",
            "    render_template,",
            "    request,",
            "    session,",
            ")",
            "from flask_login import current_user",
            "",
            "from scout.server.extensions import store",
            "from scout.server.utils import institute_and_case",
            "",
            "from . import controllers",
            "from .partial import send_file_partial",
            "",
            "alignviewers_bp = Blueprint(",
            "    \"alignviewers\",",
            "    __name__,",
            "    template_folder=\"templates\",",
            "    static_folder=\"static\",",
            "    static_url_path=\"/alignviewers/static\",",
            ")",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "@alignviewers_bp.route(\"/remote/cors/<path:remote_url>\", methods=[\"OPTIONS\", \"GET\"])",
            "def remote_cors(remote_url):",
            "    \"\"\"Proxy a remote URL.",
            "    Useful to e.g. eliminate CORS issues when the remote site does not",
            "        communicate CORS headers well, as in cloud tracks on figshare for IGV.js.",
            "",
            "    Based on code from answers to this thread:",
            "        https://stackoverflow.com/questions/6656363/proxying-to-another-web-service-with-flask/",
            "    \"\"\"",
            "    # Check that user is logged in or that file extension is valid",
            "    if controllers.check_session_tracks(remote_url) is False:",
            "        return abort(403)",
            "",
            "    resp = requests.request(",
            "        method=request.method,",
            "        url=remote_url,",
            "        headers={key: value for (key, value) in request.headers if key != \"Host\"},",
            "        data=request.get_data(),",
            "        cookies=request.cookies,",
            "        allow_redirects=True,",
            "    )",
            "",
            "    excluded_headers = [",
            "        \"content-encoding\",",
            "        \"content-length\",",
            "        \"transfer-encoding\",",
            "        \"connection\",",
            "    ]",
            "    headers = [",
            "        (name, value)",
            "        for (name, value) in resp.raw.headers.items()",
            "        if name.lower() not in excluded_headers",
            "    ]",
            "",
            "    response = Response(resp.content, resp.status_code, headers)",
            "    return response",
            "",
            "",
            "@alignviewers_bp.route(\"/remote/static\", methods=[\"OPTIONS\", \"GET\"])",
            "def remote_static():",
            "    \"\"\"Stream *large* static files with special requirements.\"\"\"",
            "    file_path = request.args.get(\"file\") or \".\"",
            "",
            "    # Check that user is logged in or that file extension is valid",
            "    if controllers.check_session_tracks(file_path) is False:",
            "        return abort(403)",
            "",
            "    range_header = request.headers.get(\"Range\", None)",
            "    if not range_header and (file_path.endswith(\".bam\") or file_path.endswith(\".cram\")):",
            "        return abort(500)",
            "",
            "    new_resp = send_file_partial(file_path)",
            "    return new_resp",
            "",
            "",
            "@alignviewers_bp.route(",
            "    \"/<institute_id>/<case_name>/<variant_id>/igv-splice-junctions\", methods=[\"GET\"]",
            ")",
            "def sashimi_igv(institute_id, case_name, variant_id):",
            "    \"\"\"Visualize splice junctions on igv.js sashimi-like viewer for one or more individuals of a case.",
            "    wiki: https://github.com/igvteam/igv.js/wiki/Splice-Junctions",
            "    \"\"\"",
            "    _, case_obj = institute_and_case(",
            "        store, institute_id, case_name",
            "    )  # This function takes care of checking if user is authorized to see resource",
            "",
            "    display_obj = controllers.make_sashimi_tracks(case_obj, variant_id)",
            "    controllers.set_session_tracks(display_obj)",
            "",
            "    response = Response(render_template(\"alignviewers/igv_sashimi_viewer.html\", **display_obj))",
            "",
            "    @response.call_on_close",
            "    @copy_current_request_context",
            "    def clear_session_tracks():",
            "        session.pop(\"igv_tracks\", None)  # clean up igv session tracks",
            "",
            "    return response",
            "",
            "",
            "@alignviewers_bp.route(\"/<institute_id>/<case_name>/igv\", methods=[\"GET\"])  # from case page",
            "@alignviewers_bp.route(",
            "    \"/<institute_id>/<case_name>/<variant_id>/igv\", methods=[\"GET\"]",
            ")  # from SNV and STR variant page",
            "@alignviewers_bp.route(",
            "    \"/<institute_id>/<case_name>/<variant_id>/<chrom>/<start>/<stop>/igv\", methods=[\"GET\"]",
            ")  # from SV variant page, where you have to pass breakpoints coordinates",
            "def igv(institute_id, case_name, variant_id=None, chrom=None, start=None, stop=None):",
            "    \"\"\"Visualize BAM alignments using igv.js (https://github.com/igvteam/igv.js)",
            "",
            "    Args:",
            "        institute_id(str): _id of an institute",
            "        case_name(str): dislay_name of a case",
            "        variant_id(str/None): variant _id or None",
            "        chrom(str/None): requested chromosome [1-22], X, Y, [M-MT]",
            "        start(int/None): start of the genomic interval to be displayed",
            "        stop(int/None): stop of the genomic interval to be displayed",
            "",
            "    Returns:",
            "        a string, corresponging to the HTML rendering of the IGV alignments page",
            "    \"\"\"",
            "    _, case_obj = institute_and_case(",
            "        store, institute_id, case_name",
            "    )  # This function takes care of checking if user is authorized to see resource",
            "",
            "    display_obj = controllers.make_igv_tracks(case_obj, variant_id, chrom, start, stop)",
            "    controllers.set_session_tracks(display_obj)",
            "",
            "    response = Response(render_template(\"alignviewers/igv_viewer.html\", **display_obj))",
            "",
            "    @response.call_on_close",
            "    @copy_current_request_context",
            "    def clear_session_tracks():",
            "        session.pop(\"igv_tracks\", None)  # clean up igv session tracks",
            "",
            "    return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "73": [
                "remote_static"
            ],
            "74": [
                "remote_static"
            ]
        },
        "addLocation": [
            "scout.server.blueprints.alignviewers.views.remote_cors.excluded_headers",
            "lib.ansible.plugins.action.ActionBase._execute_module"
        ]
    }
}