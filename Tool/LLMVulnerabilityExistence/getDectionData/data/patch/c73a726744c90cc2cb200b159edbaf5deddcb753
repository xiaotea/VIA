{
    "ipycache.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " # Imports"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " #------------------------------------------------------------------------------"
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+import hashlib"
            },
            "4": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " # Stdlib"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import inspect, os, sys, textwrap, re"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+import io"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+import os"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+import re"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+import sys"
            },
            "10": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " # Our own"
            },
            "12": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from IPython.config.configurable import Configurable"
            },
            "13": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from IPython.core import magic_arguments"
            },
            "14": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from IPython.core.magic import Magics, magics_class, line_magic, cell_magic"
            },
            "15": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from IPython.utils.traitlets import Unicode"
            },
            "16": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from IPython.utils.io import CapturedIO, capture_output"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from IPython.core.magic import Magics, magics_class, cell_magic"
            },
            "18": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from IPython.display import clear_output"
            },
            "19": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import hashlib"
            },
            "20": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from IPython.utils.io import CapturedIO"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from IPython.utils.traitlets import Unicode"
            },
            "23": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " #------------------------------------------------------------------------------"
            },
            "25": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " # Six utility functions for Python 2/3 compatibility"
            },
            "26": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     with open(path, 'rb') as f:"
            },
            "27": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         # Load the variables from the cache."
            },
            "28": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         try:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            restricted_loads(f.read())"
            },
            "30": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "             cache = pickle.load(f)"
            },
            "31": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         except EOFError as e:"
            },
            "32": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "             cache={}"
            },
            "33": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     \"\"\""
            },
            "34": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     with open(path, 'wb') as f:"
            },
            "35": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         dump(vars_d, f)"
            },
            "36": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "37": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    "
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+# ------------------------------------------------------------------------------"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+# RestrictedUnpickler - For mitigating arbitrary code execution while unpickling"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+# This function provides restriction of using only the io module"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+# ------------------------------------------------------------------------------"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+class RestrictedUnpickler(pickle.Unpickler):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    def find_class(self, module, name):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        if module == '_io' and name == 'StringIO':"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            return getattr(sys.modules[module], name)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        # Forbid everything else."
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                                     (module, name))"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+def restricted_loads(s):"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    \"\"\"Helper function analogous to pickle.loads().\"\"\""
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+    return RestrictedUnpickler(io.BytesIO(s)).load()"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " #------------------------------------------------------------------------------"
            },
            "59": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " # CapturedIO"
            },
            "60": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " #------------------------------------------------------------------------------"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Defines a %%cache cell magic in the notebook to persistent-cache results of ",
            "long-lasting computations.",
            "\"\"\"",
            "",
            "#------------------------------------------------------------------------------",
            "# Imports",
            "#------------------------------------------------------------------------------",
            "",
            "# Stdlib",
            "import inspect, os, sys, textwrap, re",
            "",
            "# Our own",
            "from IPython.config.configurable import Configurable",
            "from IPython.core import magic_arguments",
            "from IPython.core.magic import Magics, magics_class, line_magic, cell_magic",
            "from IPython.utils.traitlets import Unicode",
            "from IPython.utils.io import CapturedIO, capture_output",
            "from IPython.display import clear_output",
            "import hashlib",
            "",
            "",
            "#------------------------------------------------------------------------------",
            "# Six utility functions for Python 2/3 compatibility",
            "#------------------------------------------------------------------------------",
            "# Author: \"Benjamin Peterson <benjamin@python.org>\"",
            "    ",
            "PY2 = sys.version_info[0] == 2",
            "PY3 = sys.version_info[0] == 3",
            "",
            "if PY3:",
            "    import pickle, builtins",
            "    from io import StringIO",
            "    _iteritems = \"items\"",
            "    ",
            "    exec_ = getattr(builtins, \"exec\")",
            "else:",
            "    import cPickle as pickle",
            "    from StringIO import StringIO        ",
            "    _iteritems = \"iteritems\"",
            "",
            "    def exec_(_code_, _globs_=None, _locs_=None):",
            "        \"\"\"Execute code in a namespace.\"\"\"",
            "        if _globs_ is None:",
            "            frame = sys._getframe(1)",
            "            _globs_ = frame.f_globals",
            "            if _locs_ is None:",
            "                _locs_ = frame.f_locals",
            "            del frame",
            "        elif _locs_ is None:",
            "            _locs_ = _globs_",
            "        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")",
            "    ",
            "def iteritems(d, **kw):",
            "    \"\"\"Return an iterator over the (key, value) pairs of a dictionary.\"\"\"",
            "    return iter(getattr(d, _iteritems)(**kw))",
            "",
            "#------------------------------------------------------------------------------",
            "# cloudpickle ",
            "#------------------------------------------------------------------------------",
            "",
            "try:",
            "   import cloudpickle",
            "   dump = cloudpickle.dump",
            "except ImportError:",
            "   dump = pickle.dump",
            "",
            "#------------------------------------------------------------------------------",
            "# Functions",
            "#------------------------------------------------------------------------------",
            "def conditional_eval(var, variables):",
            "    \"\"\"",
            "    Evaluates the variable string if it starts with $.",
            "    If the variable string contains one or several {code} statements, the code",
            "    is executed and the result stringified (wrapped in str()) into the rest of",
            "    the string.",
            "    \"\"\"",
            "    if var[0] == '$':",
            "        return variables.get(var[1:], var)",
            "    def evalfun(x):",
            "        code=x.group(0)[1:-1]",
            "        return str(eval(code, variables))",
            "    return re.sub(r'{.*?}', evalfun, var, flags=re.DOTALL)",
            "",
            "def clean_var(var):",
            "    \"\"\"Clean variable name, removing accidental commas, etc.\"\"\"",
            "    return var.strip().replace(',', '')",
            "",
            "def clean_vars(vars):",
            "    \"\"\"Clean variable names, removing accidental commas, etc.\"\"\"",
            "    return sorted(map(clean_var, vars))",
            "",
            "def do_save(path, force=False, read=False):",
            "    \"\"\"Return True or False whether the variables need to be saved or not.\"\"\"",
            "    if force and read:",
            "        raise ValueError((\"The 'force' and 'read' options are \"",
            "                          \"mutually exclusive.\"))",
            "         ",
            "    # Execute the cell and save the variables.",
            "    return force or (not read and not os.path.exists(path))",
            "    ",
            "def load_vars(path, vars):",
            "    \"\"\"Load variables from a pickle file.",
            "    ",
            "    Arguments:",
            "    ",
            "      * path: the path to the pickle file.",
            "      * vars: a list of variable names.",
            "    ",
            "    Returns:",
            "    ",
            "      * cache: a dictionary {var_name: var_value}.",
            "    ",
            "    \"\"\"",
            "    with open(path, 'rb') as f:",
            "        # Load the variables from the cache.",
            "        try:",
            "            cache = pickle.load(f)",
            "        except EOFError as e:",
            "            cache={}",
            "            #raise IOError(str(e))",
            "        ",
            "        # Check that all requested variables could be loaded successfully",
            "        # from the cache.",
            "        missing_vars = sorted(set(vars) - set(cache.keys()))",
            "        if missing_vars:",
            "            raise ValueError((\"The following variables could not be loaded \"",
            "                \"from the cache: {0:s}\").format(",
            "                ', '.join([\"'{0:s}'\".format(var) for var in missing_vars])))",
            "        additional_vars = sorted(set(cache.keys()) - set(vars))",
            "        for hidden_variable in '_captured_io', '_cell_md5':",
            "            try:",
            "                additional_vars.remove(hidden_variable)",
            "            except ValueError:",
            "                pass",
            "        if additional_vars:",
            "            raise ValueError(\"The following variables were present in the cache, \"",
            "                    \"but removed from the storage request: {0:s}\".format(",
            "                ', '.join([\"'{0:s}'\".format(var) for var in additional_vars])))",
            "        ",
            "        return cache",
            "",
            "def save_vars(path, vars_d):",
            "    \"\"\"Save variables into a pickle file.",
            "    ",
            "    Arguments:",
            "    ",
            "      * path: the path to the pickle file.",
            "      * vars_d: a dictionary {var_name: var_value}.",
            "    ",
            "    \"\"\"",
            "    with open(path, 'wb') as f:",
            "        dump(vars_d, f)",
            "    ",
            "    ",
            "#------------------------------------------------------------------------------",
            "# CapturedIO",
            "#------------------------------------------------------------------------------",
            "def save_captured_io(io):",
            "    return dict(",
            "            stdout=StringIO(io._stdout.getvalue()),",
            "            stderr=StringIO(io._stderr.getvalue()),",
            "            outputs=getattr(io, '_outputs', []), # Only IPython master has this",
            "        )",
            "        ",
            "def load_captured_io(captured_io):",
            "    try:",
            "        return CapturedIO(captured_io.get('stdout', None),",
            "                          captured_io.get('stderr', None),",
            "                          outputs=captured_io.get('outputs', []),",
            "                          )",
            "    except TypeError:",
            "        return CapturedIO(captured_io.get('stdout', None),",
            "                          captured_io.get('stderr', None),",
            "                          )",
            "                            ",
            "class myStringIO(StringIO):",
            "    \"\"\"class to simultaneously capture and output\"\"\"",
            "    def __init__(self, out=None, buf=\"\"):",
            "        self._out=out",
            "        StringIO.__init__(self,buf)",
            "    def write(self,s):",
            "        self._out.write(s)",
            "        StringIO.write(self,s)",
            "",
            "import IPython.utils.io",
            "class capture_output_and_print(object):",
            "    \"\"\"",
            "    Taken from IPython.utils.io and modified to use myStringIO.",
            "    context manager for capturing stdout/err",
            "    \"\"\"",
            "    stdout = True",
            "    stderr = True",
            "    display = True",
            "    ",
            "    def __init__(self, stdout=True, stderr=True, display=True):",
            "        self.stdout = stdout",
            "        self.stderr = stderr",
            "        self.display = display",
            "        self.shell = None",
            "    ",
            "    def __enter__(self):",
            "        from IPython.core.getipython import get_ipython",
            "        from IPython.core.displaypub import CapturingDisplayPublisher",
            "        ",
            "        self.sys_stdout = sys.stdout",
            "        self.sys_stderr = sys.stderr",
            "        ",
            "        if self.display:",
            "            self.shell = get_ipython()",
            "            if self.shell is None:",
            "                self.save_display_pub = None",
            "                self.display = False",
            "        ",
            "        stdout = stderr = outputs = None",
            "        if self.stdout:",
            "            #stdout = sys.stdout = StringIO()",
            "            stdout = sys.stdout = myStringIO(out=IPython.utils.io.stdout)",
            "        if self.stderr:",
            "            #stderr = sys.stderr = StringIO()",
            "            stderr = sys.stderr = myStringIO(out=self.sys_stderr)            ",
            "        if self.display:",
            "            self.save_display_pub = self.shell.display_pub",
            "            self.shell.display_pub = CapturingDisplayPublisher()",
            "            outputs = self.shell.display_pub.outputs",
            "",
            "        return CapturedIO(stdout, stderr, outputs)",
            "    ",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        sys.stdout = self.sys_stdout",
            "        sys.stderr = self.sys_stderr",
            "        if self.display and self.shell:",
            "            self.shell.display_pub = self.save_display_pub",
            "            ",
            "#-----------------------------------------------------------------------------",
            "# %%cache Magics",
            "#------------------------------------------------------------------------------",
            "def cache(cell, path, vars=[],",
            "          # HACK: this function implementing the magic's logic is testable",
            "          # without IPython, by giving mock functions here instead of IPython",
            "          # methods.",
            "          ip_user_ns={}, ip_run_cell=None, ip_push=None, ip_clear_output=lambda : None,",
            "          force=False, read=False, verbose=True):",
            "    ",
            "    if not path:",
            "        raise ValueError(\"The path needs to be specified as a first argument.\")",
            "    ",
            "    path = os.path.abspath(path)",
            "    cell_md5 = hashlib.md5(cell.encode()).hexdigest()",
            "        ",
            "    if do_save(path, force=force, read=read):",
            "        # Capture the outputs of the cell.",
            "        with capture_output_and_print() as io:",
            "            try:",
            "                ip_run_cell(cell)",
            "            except:",
            "                # Display input/output.",
            "                io()",
            "                return",
            "        # Create the cache from the namespace.",
            "        try:",
            "            cached = {var: ip_user_ns[var] for var in vars}",
            "        except KeyError:",
            "            vars_missing = set(vars) - set(ip_user_ns.keys())",
            "            vars_missing_str = ', '.join([\"'{0:s}'\".format(_) ",
            "                for _ in vars_missing])",
            "            raise ValueError((\"Variable(s) {0:s} could not be found in the \"",
            "                              \"interactive namespace\").format(vars_missing_str))",
            "        # Save the outputs in the cache.",
            "        cached['_captured_io'] = save_captured_io(io)",
            "        cached['_cell_md5'] = cell_md5",
            "        # Save the cache in the pickle file.",
            "        save_vars(path, cached)",
            "        ip_clear_output() # clear away the temporary output and replace with the saved output (ideal?)",
            "        if verbose:",
            "            print(\"[Saved variables '{0:s}' to file '{1:s}'.]\".format(",
            "                ', '.join(vars), path))",
            "        ",
            "    # If the cache file exists, and no --force mode, load the requested ",
            "    # variables from the specified file into the interactive namespace.",
            "    else:",
            "        # Load the variables from cache in inject them in the namespace.",
            "        force_recalc = False",
            "        try:",
            "            cached = load_vars(path, vars)",
            "        except ValueError as e:",
            "            if 'The following variables' in str(e):",
            "                if read:",
            "                    raise",
            "                force_recalc = True",
            "            else:",
            "                raise",
            "            cached = {}",
            "        if not '_cell_md5' in cached or cell_md5 != cached['_cell_md5']:",
            "            force_recalc = True",
            "        if force_recalc and not read:",
            "            return cache(cell, path, vars, ip_user_ns, ip_run_cell, ip_push, ip_clear_output, True, read, verbose)",
            "        # Handle the outputs separately.",
            "        io = load_captured_io(cached.get('_captured_io', {}))",
            "        # Push the remaining variables in the namespace.",
            "        ip_push(cached)",
            "        if verbose:",
            "            print((\"[Skipped the cell's code and loaded variables {0:s} \"",
            "                   \"from file '{1:s}'.]\").format(', '.join(vars), path))",
            "",
            "    # Display the outputs, whether they come from the cell's execution",
            "    # or the pickle file.",
            "    io() # output is only printed when loading file    ",
            "",
            "        ",
            "    ",
            "@magics_class",
            "class CacheMagics(Magics, Configurable):",
            "    \"\"\"Variable caching.",
            "",
            "    Provides the %cache magic.\"\"\"",
            "    ",
            "    cachedir = Unicode('', config=True)",
            "    ",
            "    def __init__(self, shell=None):",
            "        Magics.__init__(self, shell)",
            "        Configurable.__init__(self, config=shell.config)",
            "     ",
            "    @magic_arguments.magic_arguments()",
            "    @magic_arguments.argument(",
            "        'to', nargs=1, type=str,",
            "        help=\"Path to the file containing the cached variables.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        'vars', nargs='*', type=str,",
            "        help=\"Variables to save.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-s', '--silent', action='store_true', default=False,",
            "        help=\"Do not display information when loading/saving variables.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-d', '--cachedir',",
            "        help=\"Cache directory as an absolute or relative path.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-f', '--force', action='store_true', default=False,",
            "        help=\"Force the cell's execution and save the variables.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-r', '--read', action='store_true', default=False,",
            "        help=(\"Always read from the file and prevent the cell's execution, \"",
            "              \"raising an error if the file does not exist.\")",
            "    )",
            "    @cell_magic",
            "    def cache(self, line, cell):",
            "        \"\"\"Cache user variables in a file, and skip the cell if the cached",
            "        variables exist.",
            "        ",
            "        Usage:",
            "        ",
            "            %%cache myfile.pkl var1 var2",
            "            # If myfile.pkl doesn't exist, this cell is executed and ",
            "            # var1 and var2 are saved in this file.",
            "            # Otherwise, the cell is skipped and these variables are",
            "            # injected from the file to the interactive namespace.",
            "            var1 = ...",
            "            var2 = ...",
            "        ",
            "        \"\"\"",
            "        ip = self.shell",
            "        args = magic_arguments.parse_argstring(self.cache, line)",
            "        code = cell if cell.endswith('\\n') else cell+'\\n'",
            "        vars = clean_vars(args.vars)",
            "        path = conditional_eval(args.to[0], ip.user_ns)",
            "        cachedir_from_path = os.path.split(path)[0]",
            "        # The cachedir can be specified with --cachedir or inferred from the",
            "        # path or in ipython_config.py",
            "        cachedir = args.cachedir or cachedir_from_path or self.cachedir",
            "        # If path is relative, use the user-specified cache cachedir.",
            "        if not os.path.isabs(path) and cachedir:",
            "            # Try to create the cachedir if it does not already exist.",
            "            if not os.path.exists(cachedir):",
            "                try:",
            "                    os.mkdir(cachedir)",
            "                    print(\"[Created cachedir '{0:s}'.]\".format(cachedir))",
            "                except:",
            "                    pass",
            "            path = os.path.join(cachedir, path)",
            "        cache(cell, path, vars=vars, ",
            "              force=args.force, verbose=not args.silent, read=args.read,",
            "              # IPython methods",
            "              ip_user_ns=ip.user_ns, ",
            "              ip_run_cell=ip.run_cell,",
            "              ip_push=ip.push,",
            "              ip_clear_output=clear_output",
            "              )",
            "",
            "def load_ipython_extension(ip):",
            "    \"\"\"Load the extension in IPython.\"\"\"",
            "    ip.register_magics(CacheMagics)",
            "    "
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Defines a %%cache cell magic in the notebook to persistent-cache results of ",
            "long-lasting computations.",
            "\"\"\"",
            "",
            "#------------------------------------------------------------------------------",
            "# Imports",
            "#------------------------------------------------------------------------------",
            "",
            "import hashlib",
            "# Stdlib",
            "import io",
            "import os",
            "import re",
            "import sys",
            "",
            "# Our own",
            "from IPython.config.configurable import Configurable",
            "from IPython.core import magic_arguments",
            "from IPython.core.magic import Magics, magics_class, cell_magic",
            "from IPython.display import clear_output",
            "from IPython.utils.io import CapturedIO",
            "from IPython.utils.traitlets import Unicode",
            "",
            "#------------------------------------------------------------------------------",
            "# Six utility functions for Python 2/3 compatibility",
            "#------------------------------------------------------------------------------",
            "# Author: \"Benjamin Peterson <benjamin@python.org>\"",
            "    ",
            "PY2 = sys.version_info[0] == 2",
            "PY3 = sys.version_info[0] == 3",
            "",
            "if PY3:",
            "    import pickle, builtins",
            "    from io import StringIO",
            "    _iteritems = \"items\"",
            "    ",
            "    exec_ = getattr(builtins, \"exec\")",
            "else:",
            "    import cPickle as pickle",
            "    from StringIO import StringIO        ",
            "    _iteritems = \"iteritems\"",
            "",
            "    def exec_(_code_, _globs_=None, _locs_=None):",
            "        \"\"\"Execute code in a namespace.\"\"\"",
            "        if _globs_ is None:",
            "            frame = sys._getframe(1)",
            "            _globs_ = frame.f_globals",
            "            if _locs_ is None:",
            "                _locs_ = frame.f_locals",
            "            del frame",
            "        elif _locs_ is None:",
            "            _locs_ = _globs_",
            "        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")",
            "    ",
            "def iteritems(d, **kw):",
            "    \"\"\"Return an iterator over the (key, value) pairs of a dictionary.\"\"\"",
            "    return iter(getattr(d, _iteritems)(**kw))",
            "",
            "#------------------------------------------------------------------------------",
            "# cloudpickle ",
            "#------------------------------------------------------------------------------",
            "",
            "try:",
            "   import cloudpickle",
            "   dump = cloudpickle.dump",
            "except ImportError:",
            "   dump = pickle.dump",
            "",
            "#------------------------------------------------------------------------------",
            "# Functions",
            "#------------------------------------------------------------------------------",
            "def conditional_eval(var, variables):",
            "    \"\"\"",
            "    Evaluates the variable string if it starts with $.",
            "    If the variable string contains one or several {code} statements, the code",
            "    is executed and the result stringified (wrapped in str()) into the rest of",
            "    the string.",
            "    \"\"\"",
            "    if var[0] == '$':",
            "        return variables.get(var[1:], var)",
            "    def evalfun(x):",
            "        code=x.group(0)[1:-1]",
            "        return str(eval(code, variables))",
            "    return re.sub(r'{.*?}', evalfun, var, flags=re.DOTALL)",
            "",
            "def clean_var(var):",
            "    \"\"\"Clean variable name, removing accidental commas, etc.\"\"\"",
            "    return var.strip().replace(',', '')",
            "",
            "def clean_vars(vars):",
            "    \"\"\"Clean variable names, removing accidental commas, etc.\"\"\"",
            "    return sorted(map(clean_var, vars))",
            "",
            "def do_save(path, force=False, read=False):",
            "    \"\"\"Return True or False whether the variables need to be saved or not.\"\"\"",
            "    if force and read:",
            "        raise ValueError((\"The 'force' and 'read' options are \"",
            "                          \"mutually exclusive.\"))",
            "         ",
            "    # Execute the cell and save the variables.",
            "    return force or (not read and not os.path.exists(path))",
            "    ",
            "def load_vars(path, vars):",
            "    \"\"\"Load variables from a pickle file.",
            "    ",
            "    Arguments:",
            "    ",
            "      * path: the path to the pickle file.",
            "      * vars: a list of variable names.",
            "    ",
            "    Returns:",
            "    ",
            "      * cache: a dictionary {var_name: var_value}.",
            "    ",
            "    \"\"\"",
            "    with open(path, 'rb') as f:",
            "        # Load the variables from the cache.",
            "        try:",
            "            restricted_loads(f.read())",
            "            cache = pickle.load(f)",
            "        except EOFError as e:",
            "            cache={}",
            "            #raise IOError(str(e))",
            "        ",
            "        # Check that all requested variables could be loaded successfully",
            "        # from the cache.",
            "        missing_vars = sorted(set(vars) - set(cache.keys()))",
            "        if missing_vars:",
            "            raise ValueError((\"The following variables could not be loaded \"",
            "                \"from the cache: {0:s}\").format(",
            "                ', '.join([\"'{0:s}'\".format(var) for var in missing_vars])))",
            "        additional_vars = sorted(set(cache.keys()) - set(vars))",
            "        for hidden_variable in '_captured_io', '_cell_md5':",
            "            try:",
            "                additional_vars.remove(hidden_variable)",
            "            except ValueError:",
            "                pass",
            "        if additional_vars:",
            "            raise ValueError(\"The following variables were present in the cache, \"",
            "                    \"but removed from the storage request: {0:s}\".format(",
            "                ', '.join([\"'{0:s}'\".format(var) for var in additional_vars])))",
            "        ",
            "        return cache",
            "",
            "def save_vars(path, vars_d):",
            "    \"\"\"Save variables into a pickle file.",
            "    ",
            "    Arguments:",
            "    ",
            "      * path: the path to the pickle file.",
            "      * vars_d: a dictionary {var_name: var_value}.",
            "    ",
            "    \"\"\"",
            "    with open(path, 'wb') as f:",
            "        dump(vars_d, f)",
            "",
            "",
            "# ------------------------------------------------------------------------------",
            "# RestrictedUnpickler - For mitigating arbitrary code execution while unpickling",
            "# This function provides restriction of using only the io module",
            "# ------------------------------------------------------------------------------",
            "class RestrictedUnpickler(pickle.Unpickler):",
            "",
            "    def find_class(self, module, name):",
            "        if module == '_io' and name == 'StringIO':",
            "            return getattr(sys.modules[module], name)",
            "        # Forbid everything else.",
            "        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %",
            "                                     (module, name))",
            "",
            "",
            "def restricted_loads(s):",
            "    \"\"\"Helper function analogous to pickle.loads().\"\"\"",
            "    return RestrictedUnpickler(io.BytesIO(s)).load()",
            "",
            "#------------------------------------------------------------------------------",
            "# CapturedIO",
            "#------------------------------------------------------------------------------",
            "def save_captured_io(io):",
            "    return dict(",
            "            stdout=StringIO(io._stdout.getvalue()),",
            "            stderr=StringIO(io._stderr.getvalue()),",
            "            outputs=getattr(io, '_outputs', []), # Only IPython master has this",
            "        )",
            "        ",
            "def load_captured_io(captured_io):",
            "    try:",
            "        return CapturedIO(captured_io.get('stdout', None),",
            "                          captured_io.get('stderr', None),",
            "                          outputs=captured_io.get('outputs', []),",
            "                          )",
            "    except TypeError:",
            "        return CapturedIO(captured_io.get('stdout', None),",
            "                          captured_io.get('stderr', None),",
            "                          )",
            "                            ",
            "class myStringIO(StringIO):",
            "    \"\"\"class to simultaneously capture and output\"\"\"",
            "    def __init__(self, out=None, buf=\"\"):",
            "        self._out=out",
            "        StringIO.__init__(self,buf)",
            "    def write(self,s):",
            "        self._out.write(s)",
            "        StringIO.write(self,s)",
            "",
            "import IPython.utils.io",
            "class capture_output_and_print(object):",
            "    \"\"\"",
            "    Taken from IPython.utils.io and modified to use myStringIO.",
            "    context manager for capturing stdout/err",
            "    \"\"\"",
            "    stdout = True",
            "    stderr = True",
            "    display = True",
            "    ",
            "    def __init__(self, stdout=True, stderr=True, display=True):",
            "        self.stdout = stdout",
            "        self.stderr = stderr",
            "        self.display = display",
            "        self.shell = None",
            "    ",
            "    def __enter__(self):",
            "        from IPython.core.getipython import get_ipython",
            "        from IPython.core.displaypub import CapturingDisplayPublisher",
            "        ",
            "        self.sys_stdout = sys.stdout",
            "        self.sys_stderr = sys.stderr",
            "        ",
            "        if self.display:",
            "            self.shell = get_ipython()",
            "            if self.shell is None:",
            "                self.save_display_pub = None",
            "                self.display = False",
            "        ",
            "        stdout = stderr = outputs = None",
            "        if self.stdout:",
            "            #stdout = sys.stdout = StringIO()",
            "            stdout = sys.stdout = myStringIO(out=IPython.utils.io.stdout)",
            "        if self.stderr:",
            "            #stderr = sys.stderr = StringIO()",
            "            stderr = sys.stderr = myStringIO(out=self.sys_stderr)            ",
            "        if self.display:",
            "            self.save_display_pub = self.shell.display_pub",
            "            self.shell.display_pub = CapturingDisplayPublisher()",
            "            outputs = self.shell.display_pub.outputs",
            "",
            "        return CapturedIO(stdout, stderr, outputs)",
            "    ",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        sys.stdout = self.sys_stdout",
            "        sys.stderr = self.sys_stderr",
            "        if self.display and self.shell:",
            "            self.shell.display_pub = self.save_display_pub",
            "            ",
            "#-----------------------------------------------------------------------------",
            "# %%cache Magics",
            "#------------------------------------------------------------------------------",
            "def cache(cell, path, vars=[],",
            "          # HACK: this function implementing the magic's logic is testable",
            "          # without IPython, by giving mock functions here instead of IPython",
            "          # methods.",
            "          ip_user_ns={}, ip_run_cell=None, ip_push=None, ip_clear_output=lambda : None,",
            "          force=False, read=False, verbose=True):",
            "    ",
            "    if not path:",
            "        raise ValueError(\"The path needs to be specified as a first argument.\")",
            "    ",
            "    path = os.path.abspath(path)",
            "    cell_md5 = hashlib.md5(cell.encode()).hexdigest()",
            "        ",
            "    if do_save(path, force=force, read=read):",
            "        # Capture the outputs of the cell.",
            "        with capture_output_and_print() as io:",
            "            try:",
            "                ip_run_cell(cell)",
            "            except:",
            "                # Display input/output.",
            "                io()",
            "                return",
            "        # Create the cache from the namespace.",
            "        try:",
            "            cached = {var: ip_user_ns[var] for var in vars}",
            "        except KeyError:",
            "            vars_missing = set(vars) - set(ip_user_ns.keys())",
            "            vars_missing_str = ', '.join([\"'{0:s}'\".format(_) ",
            "                for _ in vars_missing])",
            "            raise ValueError((\"Variable(s) {0:s} could not be found in the \"",
            "                              \"interactive namespace\").format(vars_missing_str))",
            "        # Save the outputs in the cache.",
            "        cached['_captured_io'] = save_captured_io(io)",
            "        cached['_cell_md5'] = cell_md5",
            "        # Save the cache in the pickle file.",
            "        save_vars(path, cached)",
            "        ip_clear_output() # clear away the temporary output and replace with the saved output (ideal?)",
            "        if verbose:",
            "            print(\"[Saved variables '{0:s}' to file '{1:s}'.]\".format(",
            "                ', '.join(vars), path))",
            "        ",
            "    # If the cache file exists, and no --force mode, load the requested ",
            "    # variables from the specified file into the interactive namespace.",
            "    else:",
            "        # Load the variables from cache in inject them in the namespace.",
            "        force_recalc = False",
            "        try:",
            "            cached = load_vars(path, vars)",
            "        except ValueError as e:",
            "            if 'The following variables' in str(e):",
            "                if read:",
            "                    raise",
            "                force_recalc = True",
            "            else:",
            "                raise",
            "            cached = {}",
            "        if not '_cell_md5' in cached or cell_md5 != cached['_cell_md5']:",
            "            force_recalc = True",
            "        if force_recalc and not read:",
            "            return cache(cell, path, vars, ip_user_ns, ip_run_cell, ip_push, ip_clear_output, True, read, verbose)",
            "        # Handle the outputs separately.",
            "        io = load_captured_io(cached.get('_captured_io', {}))",
            "        # Push the remaining variables in the namespace.",
            "        ip_push(cached)",
            "        if verbose:",
            "            print((\"[Skipped the cell's code and loaded variables {0:s} \"",
            "                   \"from file '{1:s}'.]\").format(', '.join(vars), path))",
            "",
            "    # Display the outputs, whether they come from the cell's execution",
            "    # or the pickle file.",
            "    io() # output is only printed when loading file    ",
            "",
            "        ",
            "    ",
            "@magics_class",
            "class CacheMagics(Magics, Configurable):",
            "    \"\"\"Variable caching.",
            "",
            "    Provides the %cache magic.\"\"\"",
            "    ",
            "    cachedir = Unicode('', config=True)",
            "    ",
            "    def __init__(self, shell=None):",
            "        Magics.__init__(self, shell)",
            "        Configurable.__init__(self, config=shell.config)",
            "     ",
            "    @magic_arguments.magic_arguments()",
            "    @magic_arguments.argument(",
            "        'to', nargs=1, type=str,",
            "        help=\"Path to the file containing the cached variables.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        'vars', nargs='*', type=str,",
            "        help=\"Variables to save.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-s', '--silent', action='store_true', default=False,",
            "        help=\"Do not display information when loading/saving variables.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-d', '--cachedir',",
            "        help=\"Cache directory as an absolute or relative path.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-f', '--force', action='store_true', default=False,",
            "        help=\"Force the cell's execution and save the variables.\"",
            "    )",
            "    @magic_arguments.argument(",
            "        '-r', '--read', action='store_true', default=False,",
            "        help=(\"Always read from the file and prevent the cell's execution, \"",
            "              \"raising an error if the file does not exist.\")",
            "    )",
            "    @cell_magic",
            "    def cache(self, line, cell):",
            "        \"\"\"Cache user variables in a file, and skip the cell if the cached",
            "        variables exist.",
            "        ",
            "        Usage:",
            "        ",
            "            %%cache myfile.pkl var1 var2",
            "            # If myfile.pkl doesn't exist, this cell is executed and ",
            "            # var1 and var2 are saved in this file.",
            "            # Otherwise, the cell is skipped and these variables are",
            "            # injected from the file to the interactive namespace.",
            "            var1 = ...",
            "            var2 = ...",
            "        ",
            "        \"\"\"",
            "        ip = self.shell",
            "        args = magic_arguments.parse_argstring(self.cache, line)",
            "        code = cell if cell.endswith('\\n') else cell+'\\n'",
            "        vars = clean_vars(args.vars)",
            "        path = conditional_eval(args.to[0], ip.user_ns)",
            "        cachedir_from_path = os.path.split(path)[0]",
            "        # The cachedir can be specified with --cachedir or inferred from the",
            "        # path or in ipython_config.py",
            "        cachedir = args.cachedir or cachedir_from_path or self.cachedir",
            "        # If path is relative, use the user-specified cache cachedir.",
            "        if not os.path.isabs(path) and cachedir:",
            "            # Try to create the cachedir if it does not already exist.",
            "            if not os.path.exists(cachedir):",
            "                try:",
            "                    os.mkdir(cachedir)",
            "                    print(\"[Created cachedir '{0:s}'.]\".format(cachedir))",
            "                except:",
            "                    pass",
            "            path = os.path.join(cachedir, path)",
            "        cache(cell, path, vars=vars, ",
            "              force=args.force, verbose=not args.silent, read=args.read,",
            "              # IPython methods",
            "              ip_user_ns=ip.user_ns, ",
            "              ip_run_cell=ip.run_cell,",
            "              ip_push=ip.push,",
            "              ip_clear_output=clear_output",
            "              )",
            "",
            "def load_ipython_extension(ip):",
            "    \"\"\"Load the extension in IPython.\"\"\"",
            "    ip.register_magics(CacheMagics)",
            "    "
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "16": [],
            "17": [],
            "18": [],
            "20": [],
            "21": [],
            "154": [],
            "155": []
        },
        "addLocation": []
    },
    "test_ipycache.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "           ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)"
            },
            "1": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "     "
            },
            "2": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "     os.remove(path)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+def test_load_exploitPickle():"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+    class vulnLoad():"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        def __init__(self):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+            self.a = 1"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        def __reduce__(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            return (os.system, ('uname -a',))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    payload = vulnLoad()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+    path = \"malicious.pkl\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+    with open(\"malicious.pkl\", \"wb\") as f:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        pickle.dump(payload, f)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+    assert_raises(pickle.UnpicklingError, load_vars, path, ['a'])"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Tests for ipycache.",
            "\"\"\"",
            "",
            "#------------------------------------------------------------------------------",
            "# Imports",
            "#------------------------------------------------------------------------------",
            "import os",
            "import sys",
            "",
            "PY2 = sys.version_info[0] == 2",
            "PY3 = sys.version_info[0] == 3",
            "",
            "if PY2:",
            "    from cStringIO import StringIO",
            "else:",
            "    from io import StringIO",
            "    ",
            "from nose.tools import raises, assert_raises",
            "from ipycache import (save_vars, load_vars, clean_var, clean_vars, do_save, ",
            "    cache, exec_, conditional_eval)",
            "import hashlib",
            "import pickle",
            "",
            "",
            "#------------------------------------------------------------------------------",
            "# Functions tests",
            "#------------------------------------------------------------------------------",
            "def test_conditional_eval():",
            "    test_var = 'abc'",
            "    assert conditional_eval('$test_var', locals()) == 'abc'",
            "    x,fun=10,lambda x: x",
            "    test_eval='abc_{\"10\" if x==10 else \"not_10\"}_{fun(10)}'",
            "    expect='abc_10_10'",
            "    assert conditional_eval(test_eval, locals())==expect",
            "                             ",
            "def test_clean_var():",
            "    assert clean_var('abc') == 'abc'",
            "    assert clean_var('abc ') == 'abc'",
            "    assert clean_var('abc,') == 'abc'",
            "    assert clean_var(',abc') == 'abc'",
            "    ",
            "def test_clean_vars():",
            "    assert clean_vars(['abc', 'abc,']) == ['abc'] * 2",
            "",
            "def test_do_save():",
            "    path = 'myvars.pkl'",
            "    ",
            "    # File exists.",
            "    open(path, 'wb').close()",
            "    assert_raises(ValueError, do_save, path, force=True, read=True)",
            "    assert do_save(path, force=True, read=False)",
            "    assert not do_save(path, force=False, read=False)",
            "    assert not do_save(path, force=False, read=True)",
            "    os.remove(path)",
            "    ",
            "    # File does not exist.",
            "    assert_raises(ValueError, do_save, path, force=True, read=True)",
            "    assert do_save(path, force=True, read=False)",
            "    assert do_save(path, force=False, read=False)",
            "    assert not do_save(path, force=False, read=True)",
            "    ",
            "@raises(IOError)",
            "def test_load_fail():",
            "    path = 'myvars.pkl'",
            "    load_vars(path, ['a', 'b'])",
            "",
            "def test_save_load():",
            "    path = 'myvars.pkl'",
            "    vars = {'a': 1, 'b': '2'}",
            "    save_vars(path, vars)",
            "    vars2 = load_vars(path, list(vars.keys()))",
            "    assert vars == vars2",
            "    ",
            "    os.remove(path)",
            "    ",
            "",
            "#------------------------------------------------------------------------------",
            "# Cache magic tests",
            "#------------------------------------------------------------------------------",
            "def test_cache_1():",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "    ",
            "    # We modify the variable in the namespace,",
            "    user_ns['a'] = 2",
            "    # and execute the cell again. The value should be loaded from the pickle",
            "    # file. Note how we did not change cell contents",
            "    cache(\"\"\"a = 1\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "",
            "    # changing  the cell will trigger reload",
            "    # file. Note how we did not change cell contents",
            "    cache(\"\"\"a = 2\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 2",
            "     ",
            "    #store 1 again",
            "    user_ns['a'] = 1 ",
            "    cache(\"\"\"a = 1\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    #hack the md5 so code change does not retrigger",
            "    with open(path, 'rb') as op:",
            "        data = pickle.load(op)",
            "    data['_cell_md5'] = hashlib.md5(\"\"\"a = 2\"\"\".encode()).hexdigest()",
            "    with open(path, 'wb') as op:",
            "        pickle.dump(data, op)",
            "    #ensure we don't rerun",
            "    user_ns['a'] = 2",
            "    # and execute the cell again. The value should be loaded from the pickle",
            "    # file. Note how we did not change cell contents",
            "    cache(\"\"\"a = 1\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "",
            "    # Now, we force the cell's execution.",
            "    cache(\"\"\"a = 2\"\"\", path, vars=['a'], force=True, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 2",
            "    ",
            "    # Now, we prevent the cell's execution.",
            "    user_ns['a'] = 0",
            "    cache(\"\"\"a = 3\"\"\", path, vars=['a'], force=False, read=True,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 2",
            "    ",
            "    os.remove(path)",
            "    ",
            "def test_cache_exception():",
            "    \"\"\"Check that, if an exception is raised during the cell's execution,",
            "    the pickle file is not written.\"\"\"",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1;b = 1/0\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "",
            "    assert not os.path.exists(path), os.remove(path)",
            "    ",
            "def test_cache_outputs():",
            "    \"\"\"Test the capture of stdout.\"\"\"",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1;print(a+1)\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a'], verbose=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "    ",
            "    # Capture stdout.",
            "    old_stdout = sys.stdout",
            "    sys.stdout = mystdout = StringIO()",
            "",
            "    user_ns = {}",
            "    cache(cell, path, vars=['a'], verbose=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "    ",
            "    sys.stdout = old_stdout",
            "    ",
            "    # Check that stdout contains the print statement of the cached cell.",
            "    assert mystdout.getvalue() == '2\\n'",
            "    ",
            "    os.remove(path)",
            "",
            "@raises(ValueError)",
            "def test_cache_fail_1():",
            "    \"\"\"Fails when saving inexistent variables.\"\"\"",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a', 'b'],",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    ",
            "    os.remove(path)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Tests for ipycache.",
            "\"\"\"",
            "",
            "#------------------------------------------------------------------------------",
            "# Imports",
            "#------------------------------------------------------------------------------",
            "import os",
            "import sys",
            "",
            "PY2 = sys.version_info[0] == 2",
            "PY3 = sys.version_info[0] == 3",
            "",
            "if PY2:",
            "    from cStringIO import StringIO",
            "else:",
            "    from io import StringIO",
            "    ",
            "from nose.tools import raises, assert_raises",
            "from ipycache import (save_vars, load_vars, clean_var, clean_vars, do_save, ",
            "    cache, exec_, conditional_eval)",
            "import hashlib",
            "import pickle",
            "",
            "",
            "#------------------------------------------------------------------------------",
            "# Functions tests",
            "#------------------------------------------------------------------------------",
            "def test_conditional_eval():",
            "    test_var = 'abc'",
            "    assert conditional_eval('$test_var', locals()) == 'abc'",
            "    x,fun=10,lambda x: x",
            "    test_eval='abc_{\"10\" if x==10 else \"not_10\"}_{fun(10)}'",
            "    expect='abc_10_10'",
            "    assert conditional_eval(test_eval, locals())==expect",
            "                             ",
            "def test_clean_var():",
            "    assert clean_var('abc') == 'abc'",
            "    assert clean_var('abc ') == 'abc'",
            "    assert clean_var('abc,') == 'abc'",
            "    assert clean_var(',abc') == 'abc'",
            "    ",
            "def test_clean_vars():",
            "    assert clean_vars(['abc', 'abc,']) == ['abc'] * 2",
            "",
            "def test_do_save():",
            "    path = 'myvars.pkl'",
            "    ",
            "    # File exists.",
            "    open(path, 'wb').close()",
            "    assert_raises(ValueError, do_save, path, force=True, read=True)",
            "    assert do_save(path, force=True, read=False)",
            "    assert not do_save(path, force=False, read=False)",
            "    assert not do_save(path, force=False, read=True)",
            "    os.remove(path)",
            "    ",
            "    # File does not exist.",
            "    assert_raises(ValueError, do_save, path, force=True, read=True)",
            "    assert do_save(path, force=True, read=False)",
            "    assert do_save(path, force=False, read=False)",
            "    assert not do_save(path, force=False, read=True)",
            "    ",
            "@raises(IOError)",
            "def test_load_fail():",
            "    path = 'myvars.pkl'",
            "    load_vars(path, ['a', 'b'])",
            "",
            "def test_save_load():",
            "    path = 'myvars.pkl'",
            "    vars = {'a': 1, 'b': '2'}",
            "    save_vars(path, vars)",
            "    vars2 = load_vars(path, list(vars.keys()))",
            "    assert vars == vars2",
            "    ",
            "    os.remove(path)",
            "    ",
            "",
            "#------------------------------------------------------------------------------",
            "# Cache magic tests",
            "#------------------------------------------------------------------------------",
            "def test_cache_1():",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "    ",
            "    # We modify the variable in the namespace,",
            "    user_ns['a'] = 2",
            "    # and execute the cell again. The value should be loaded from the pickle",
            "    # file. Note how we did not change cell contents",
            "    cache(\"\"\"a = 1\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "",
            "    # changing  the cell will trigger reload",
            "    # file. Note how we did not change cell contents",
            "    cache(\"\"\"a = 2\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 2",
            "     ",
            "    #store 1 again",
            "    user_ns['a'] = 1 ",
            "    cache(\"\"\"a = 1\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    #hack the md5 so code change does not retrigger",
            "    with open(path, 'rb') as op:",
            "        data = pickle.load(op)",
            "    data['_cell_md5'] = hashlib.md5(\"\"\"a = 2\"\"\".encode()).hexdigest()",
            "    with open(path, 'wb') as op:",
            "        pickle.dump(data, op)",
            "    #ensure we don't rerun",
            "    user_ns['a'] = 2",
            "    # and execute the cell again. The value should be loaded from the pickle",
            "    # file. Note how we did not change cell contents",
            "    cache(\"\"\"a = 1\"\"\", path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "",
            "    # Now, we force the cell's execution.",
            "    cache(\"\"\"a = 2\"\"\", path, vars=['a'], force=True, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 2",
            "    ",
            "    # Now, we prevent the cell's execution.",
            "    user_ns['a'] = 0",
            "    cache(\"\"\"a = 3\"\"\", path, vars=['a'], force=False, read=True,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 2",
            "    ",
            "    os.remove(path)",
            "    ",
            "def test_cache_exception():",
            "    \"\"\"Check that, if an exception is raised during the cell's execution,",
            "    the pickle file is not written.\"\"\"",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1;b = 1/0\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a'], force=False, read=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "",
            "    assert not os.path.exists(path), os.remove(path)",
            "    ",
            "def test_cache_outputs():",
            "    \"\"\"Test the capture of stdout.\"\"\"",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1;print(a+1)\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a'], verbose=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "    ",
            "    # Capture stdout.",
            "    old_stdout = sys.stdout",
            "    sys.stdout = mystdout = StringIO()",
            "",
            "    user_ns = {}",
            "    cache(cell, path, vars=['a'], verbose=False,",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    assert user_ns['a'] == 1",
            "    ",
            "    sys.stdout = old_stdout",
            "    ",
            "    # Check that stdout contains the print statement of the cached cell.",
            "    assert mystdout.getvalue() == '2\\n'",
            "    ",
            "    os.remove(path)",
            "",
            "@raises(ValueError)",
            "def test_cache_fail_1():",
            "    \"\"\"Fails when saving inexistent variables.\"\"\"",
            "    path = 'myvars.pkl'",
            "    cell = \"\"\"a = 1\"\"\"",
            "    ",
            "    user_ns = {}",
            "    def ip_run_cell(cell):",
            "        exec_(cell, {}, user_ns)",
            "    ",
            "    def ip_push(vars):",
            "        user_ns.update(vars)",
            "    ",
            "    cache(cell, path, vars=['a', 'b'],",
            "          ip_user_ns=user_ns, ip_run_cell=ip_run_cell, ip_push=ip_push)",
            "    ",
            "    os.remove(path)",
            "",
            "",
            "def test_load_exploitPickle():",
            "    class vulnLoad():",
            "        def __init__(self):",
            "            self.a = 1",
            "",
            "        def __reduce__(self):",
            "            return (os.system, ('uname -a',))",
            "",
            "    payload = vulnLoad()",
            "    path = \"malicious.pkl\"",
            "    with open(\"malicious.pkl\", \"wb\") as f:",
            "        pickle.dump(payload, f)",
            "    assert_raises(pickle.UnpicklingError, load_vars, path, ['a'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "litellm.utils.exception_type"
        ]
    }
}