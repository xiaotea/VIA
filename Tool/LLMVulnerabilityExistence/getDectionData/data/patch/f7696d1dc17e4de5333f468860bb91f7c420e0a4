{
    "embedchain/loaders/json.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         return [\"\\n\".join(useful_lines)]"
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-VALID_URL_PATTERN = \"^https:\\/\\/[0-9A-z.]+.[0-9A-z.]+.[a-z]+\\/.*\\.json$\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+VALID_URL_PATTERN = \"^https:\\/\\/[0-9A-Za-z]+(\\.[0-9A-Za-z]+)*\\/[0-9A-Za-z_\\/]*\\.json$\""
            },
            "5": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " class JSONLoader(BaseLoader):"
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "import json",
            "import os",
            "import re",
            "from typing import Dict, List, Union",
            "",
            "import requests",
            "",
            "from embedchain.loaders.base_loader import BaseLoader",
            "from embedchain.utils.misc import clean_string, is_valid_json_string",
            "",
            "",
            "class JSONReader:",
            "    def __init__(self) -> None:",
            "        \"\"\"Initialize the JSONReader.\"\"\"",
            "        pass",
            "",
            "    def load_data(self, json_data: Union[Dict, str]) -> List[str]:",
            "        \"\"\"Load data from a JSON structure.",
            "",
            "        Args:",
            "            json_data (Union[Dict, str]): The JSON data to load.",
            "",
            "        Returns:",
            "            List[str]: A list of strings representing the leaf nodes of the JSON.",
            "        \"\"\"",
            "        if isinstance(json_data, str):",
            "            json_data = json.loads(json_data)",
            "        else:",
            "            json_data = json_data",
            "",
            "        json_output = json.dumps(json_data, indent=0)",
            "        lines = json_output.split(\"\\n\")",
            "        useful_lines = [line for line in lines if not re.match(r\"^[{}\\[\\],]*$\", line)]",
            "        return [\"\\n\".join(useful_lines)]",
            "",
            "",
            "VALID_URL_PATTERN = \"^https:\\/\\/[0-9A-z.]+.[0-9A-z.]+.[a-z]+\\/.*\\.json$\"",
            "",
            "",
            "class JSONLoader(BaseLoader):",
            "    @staticmethod",
            "    def _check_content(content):",
            "        if not isinstance(content, str):",
            "            raise ValueError(",
            "                \"Invaid content input. \\",
            "                If you want to upload (list, dict, etc.), do \\",
            "                    `json.dump(data, indent=0)` and add the stringified JSON. \\",
            "                        Check - `https://docs.embedchain.ai/data-sources/json`\"",
            "            )",
            "",
            "    @staticmethod",
            "    def load_data(content):",
            "        \"\"\"Load a json file. Each data point is a key value pair.\"\"\"",
            "",
            "        JSONLoader._check_content(content)",
            "        loader = JSONReader()",
            "",
            "        data = []",
            "        data_content = []",
            "",
            "        content_url_str = content",
            "",
            "        if os.path.isfile(content):",
            "            with open(content, \"r\", encoding=\"utf-8\") as json_file:",
            "                json_data = json.load(json_file)",
            "        elif re.match(VALID_URL_PATTERN, content):",
            "            response = requests.get(content)",
            "            if response.status_code == 200:",
            "                json_data = response.json()",
            "            else:",
            "                raise ValueError(",
            "                    f\"Loading data from the given url: {content} failed. \\",
            "                    Make sure the url is working.\"",
            "                )",
            "        elif is_valid_json_string(content):",
            "            json_data = content",
            "            content_url_str = hashlib.sha256((content).encode(\"utf-8\")).hexdigest()",
            "        else:",
            "            raise ValueError(f\"Invalid content to load json data from: {content}\")",
            "",
            "        docs = loader.load_data(json_data)",
            "        for doc in docs:",
            "            text = doc if isinstance(doc, str) else doc[\"text\"]",
            "            doc_content = clean_string(text)",
            "            data.append({\"content\": doc_content, \"meta_data\": {\"url\": content_url_str}})",
            "            data_content.append(doc_content)",
            "",
            "        doc_id = hashlib.sha256((content_url_str + \", \".join(data_content)).encode()).hexdigest()",
            "        return {\"doc_id\": doc_id, \"data\": data}"
        ],
        "afterPatchFile": [
            "import hashlib",
            "import json",
            "import os",
            "import re",
            "from typing import Dict, List, Union",
            "",
            "import requests",
            "",
            "from embedchain.loaders.base_loader import BaseLoader",
            "from embedchain.utils.misc import clean_string, is_valid_json_string",
            "",
            "",
            "class JSONReader:",
            "    def __init__(self) -> None:",
            "        \"\"\"Initialize the JSONReader.\"\"\"",
            "        pass",
            "",
            "    def load_data(self, json_data: Union[Dict, str]) -> List[str]:",
            "        \"\"\"Load data from a JSON structure.",
            "",
            "        Args:",
            "            json_data (Union[Dict, str]): The JSON data to load.",
            "",
            "        Returns:",
            "            List[str]: A list of strings representing the leaf nodes of the JSON.",
            "        \"\"\"",
            "        if isinstance(json_data, str):",
            "            json_data = json.loads(json_data)",
            "        else:",
            "            json_data = json_data",
            "",
            "        json_output = json.dumps(json_data, indent=0)",
            "        lines = json_output.split(\"\\n\")",
            "        useful_lines = [line for line in lines if not re.match(r\"^[{}\\[\\],]*$\", line)]",
            "        return [\"\\n\".join(useful_lines)]",
            "",
            "",
            "VALID_URL_PATTERN = \"^https:\\/\\/[0-9A-Za-z]+(\\.[0-9A-Za-z]+)*\\/[0-9A-Za-z_\\/]*\\.json$\"",
            "",
            "",
            "class JSONLoader(BaseLoader):",
            "    @staticmethod",
            "    def _check_content(content):",
            "        if not isinstance(content, str):",
            "            raise ValueError(",
            "                \"Invaid content input. \\",
            "                If you want to upload (list, dict, etc.), do \\",
            "                    `json.dump(data, indent=0)` and add the stringified JSON. \\",
            "                        Check - `https://docs.embedchain.ai/data-sources/json`\"",
            "            )",
            "",
            "    @staticmethod",
            "    def load_data(content):",
            "        \"\"\"Load a json file. Each data point is a key value pair.\"\"\"",
            "",
            "        JSONLoader._check_content(content)",
            "        loader = JSONReader()",
            "",
            "        data = []",
            "        data_content = []",
            "",
            "        content_url_str = content",
            "",
            "        if os.path.isfile(content):",
            "            with open(content, \"r\", encoding=\"utf-8\") as json_file:",
            "                json_data = json.load(json_file)",
            "        elif re.match(VALID_URL_PATTERN, content):",
            "            response = requests.get(content)",
            "            if response.status_code == 200:",
            "                json_data = response.json()",
            "            else:",
            "                raise ValueError(",
            "                    f\"Loading data from the given url: {content} failed. \\",
            "                    Make sure the url is working.\"",
            "                )",
            "        elif is_valid_json_string(content):",
            "            json_data = content",
            "            content_url_str = hashlib.sha256((content).encode(\"utf-8\")).hexdigest()",
            "        else:",
            "            raise ValueError(f\"Invalid content to load json data from: {content}\")",
            "",
            "        docs = loader.load_data(json_data)",
            "        for doc in docs:",
            "            text = doc if isinstance(doc, str) else doc[\"text\"]",
            "            doc_content = clean_string(text)",
            "            data.append({\"content\": doc_content, \"meta_data\": {\"url\": content_url_str}})",
            "            data_content.append(doc_content)",
            "",
            "        doc_id = hashlib.sha256((content_url_str + \", \".join(data_content)).encode()).hexdigest()",
            "        return {\"doc_id\": doc_id, \"data\": data}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "38": [
                "VALID_URL_PATTERN"
            ]
        },
        "addLocation": []
    },
    "embedchain/loaders/openapi.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         file_path = content"
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         data_content = []"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         with OpenAPILoader._get_file_content(content=content) as file:"
            },
            "3": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            yaml_data = yaml.load(file, Loader=yaml.Loader)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+            yaml_data = yaml.load(file, Loader=yaml.SafeLoader)"
            },
            "5": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "             for i, (key, value) in enumerate(yaml_data.items()):"
            },
            "6": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "                 string_data = f\"{key}: {value}\""
            },
            "7": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "                 meta_data = {\"url\": file_path, \"row\": i + 1}"
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "from io import StringIO",
            "from urllib.parse import urlparse",
            "",
            "import requests",
            "import yaml",
            "",
            "from embedchain.loaders.base_loader import BaseLoader",
            "",
            "",
            "class OpenAPILoader(BaseLoader):",
            "    @staticmethod",
            "    def _get_file_content(content):",
            "        url = urlparse(content)",
            "        if all([url.scheme, url.netloc]) and url.scheme not in [\"file\", \"http\", \"https\"]:",
            "            raise ValueError(\"Not a valid URL.\")",
            "",
            "        if url.scheme in [\"http\", \"https\"]:",
            "            response = requests.get(content)",
            "            response.raise_for_status()",
            "            return StringIO(response.text)",
            "        elif url.scheme == \"file\":",
            "            path = url.path",
            "            return open(path)",
            "        else:",
            "            return open(content)",
            "",
            "    @staticmethod",
            "    def load_data(content):",
            "        \"\"\"Load yaml file of openapi. Each pair is a document.\"\"\"",
            "        data = []",
            "        file_path = content",
            "        data_content = []",
            "        with OpenAPILoader._get_file_content(content=content) as file:",
            "            yaml_data = yaml.load(file, Loader=yaml.Loader)",
            "            for i, (key, value) in enumerate(yaml_data.items()):",
            "                string_data = f\"{key}: {value}\"",
            "                meta_data = {\"url\": file_path, \"row\": i + 1}",
            "                data.append({\"content\": string_data, \"meta_data\": meta_data})",
            "                data_content.append(string_data)",
            "        doc_id = hashlib.sha256((content + \", \".join(data_content)).encode()).hexdigest()",
            "        return {\"doc_id\": doc_id, \"data\": data}"
        ],
        "afterPatchFile": [
            "import hashlib",
            "from io import StringIO",
            "from urllib.parse import urlparse",
            "",
            "import requests",
            "import yaml",
            "",
            "from embedchain.loaders.base_loader import BaseLoader",
            "",
            "",
            "class OpenAPILoader(BaseLoader):",
            "    @staticmethod",
            "    def _get_file_content(content):",
            "        url = urlparse(content)",
            "        if all([url.scheme, url.netloc]) and url.scheme not in [\"file\", \"http\", \"https\"]:",
            "            raise ValueError(\"Not a valid URL.\")",
            "",
            "        if url.scheme in [\"http\", \"https\"]:",
            "            response = requests.get(content)",
            "            response.raise_for_status()",
            "            return StringIO(response.text)",
            "        elif url.scheme == \"file\":",
            "            path = url.path",
            "            return open(path)",
            "        else:",
            "            return open(content)",
            "",
            "    @staticmethod",
            "    def load_data(content):",
            "        \"\"\"Load yaml file of openapi. Each pair is a document.\"\"\"",
            "        data = []",
            "        file_path = content",
            "        data_content = []",
            "        with OpenAPILoader._get_file_content(content=content) as file:",
            "            yaml_data = yaml.load(file, Loader=yaml.SafeLoader)",
            "            for i, (key, value) in enumerate(yaml_data.items()):",
            "                string_data = f\"{key}: {value}\"",
            "                meta_data = {\"url\": file_path, \"row\": i + 1}",
            "                data.append({\"content\": string_data, \"meta_data\": meta_data})",
            "                data_content.append(string_data)",
            "        doc_id = hashlib.sha256((content + \", \".join(data_content)).encode()).hexdigest()",
            "        return {\"doc_id\": doc_id, \"data\": data}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "35": [
                "OpenAPILoader",
                "load_data"
            ]
        },
        "addLocation": []
    }
}