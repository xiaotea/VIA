{
    "nautobot/core/settings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": 671,
                "PatchRowcode": "     ],"
            },
            "1": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 672,
                "PatchRowcode": "     \"SUPPORT_MESSAGE\": ["
            },
            "2": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": 673,
                "PatchRowcode": "         \"\","
            },
            "3": {
                "beforePatchRowNumber": 674,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"Help message to include on 4xx and 5xx error pages. Markdown is supported.\\n\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 674,
                "PatchRowcode": "+        \"Help message to include on 4xx and 5xx error pages. \""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 675,
                "PatchRowcode": "+        \"Markdown is supported, as are some HTML tags and attributes.\\n\""
            },
            "6": {
                "beforePatchRowNumber": 675,
                "afterPatchRowNumber": 676,
                "PatchRowcode": "         \"If unspecified, instructions to join Network to Code's Slack community will be provided.\","
            },
            "7": {
                "beforePatchRowNumber": 676,
                "afterPatchRowNumber": 677,
                "PatchRowcode": "     ],"
            },
            "8": {
                "beforePatchRowNumber": 677,
                "afterPatchRowNumber": 678,
                "PatchRowcode": " }"
            }
        },
        "frontPatchFile": [
            "import os",
            "import platform",
            "import re",
            "import sys",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.settings_funcs import is_truthy, parse_redis_connection  # noqa: F401",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can\u2019t do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "ALLOWED_URL_SCHEMES = (",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            ")",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# By default, Nautobot will permit users to create duplicate prefixes and IP addresses in the global",
            "# table (that is, those which are not assigned to any VRF). This behavior can be disabled by setting",
            "# ENFORCE_GLOBAL_UNIQUE to True.",
            "ENFORCE_GLOBAL_UNIQUE = is_truthy(os.getenv(\"NAUTOBOT_ENFORCE_GLOBAL_UNIQUE\", \"False\"))",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (re.compile(r\"(username|password|passwd|pwd)((?:\\s+is.?|:)?\\s+)\\S+\", re.IGNORECASE), r\"\\1\\2{replacement}\"),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django cryptography",
            "#",
            "",
            "# CRYPTOGRAPHY_BACKEND = cryptography.hazmat.backends.default_backend()",
            "# CRYPTOGRAPHY_DIGEST = cryptography.hazmat.primitives.hashes.SHA256",
            "CRYPTOGRAPHY_KEY = None  # Defaults to SECRET_KEY if unset",
            "CRYPTOGRAPHY_SALT = \"nautobot-cryptography\"",
            "",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "current_major, current_minor = REST_FRAMEWORK_VERSION.split(\".\")",
            "# We support all major.minor API versions from 1.2 to the present latest version.",
            "# This will need to be elaborated upon when we move to version 2.0",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "assert current_major == \"1\", f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {current_major}\"",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{current_major}.{minor}\" for minor in range(2, int(current_minor) + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (\"nautobot.core.api.filter_backends.NautobotFilterBackend\",),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.BulkOperationMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"rest_framework.renderers.JSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (\"rest_framework.parsers.JSONParser\",),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise.",
            "    # This should only change (if at all) with Nautobot major (breaking) releases.",
            "    \"DEFAULT_VERSION\": \"1.2\",",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.utilities.api.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # Each of these StatusModels has bulk and non-bulk serializers, with the same status options,",
            "        # which confounds drf-spectacular's automatic naming of enums, resulting in the below warning:",
            "        #   enum naming encountered a non-optimally resolvable collision for fields named \"status\"",
            "        # By explicitly naming the enums ourselves we avoid this warning.",
            "        \"CableStatusChoices\": \"nautobot.dcim.api.serializers.CableSerializer.status_choices\",",
            "        \"CircuitStatusChoices\": \"nautobot.circuits.api.serializers.CircuitSerializer.status_choices\",",
            "        \"DeviceStatusChoices\": \"nautobot.dcim.api.serializers.DeviceWithConfigContextSerializer.status_choices\",",
            "        \"InterfaceStatusChoices\": \"nautobot.dcim.api.serializers.InterfaceSerializer.status_choices\",",
            "        \"IPAddressStatusChoices\": \"nautobot.ipam.api.serializers.IPAddressSerializer.status_choices\",",
            "        \"LocationStatusChoices\": \"nautobot.dcim.api.serializers.LocationSerializer.status_choices\",",
            "        \"PowerFeedStatusChoices\": \"nautobot.dcim.api.serializers.PowerFeedSerializer.status_choices\",",
            "        \"PrefixStatusChoices\": \"nautobot.ipam.api.serializers.PrefixSerializer.status_choices\",",
            "        \"RackStatusChoices\": \"nautobot.dcim.api.serializers.RackSerializer.status_choices\",",
            "        \"VirtualMachineStatusChoices\": \"nautobot.virtualization.api.serializers.VirtualMachineWithConfigContextSerializer.status_choices\",",
            "        \"VLANStatusChoices\": \"nautobot.ipam.api.serializers.VLANSerializer.status_choices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "# Only PostgresSQL is supported, so database driver is hard-coded. This can",
            "# still be overloaded in custom settings.",
            "# https://docs.djangoproject.com/en/stable/ref/settings/#databases",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\")",
            "",
            "# Default overrides",
            "ALLOWED_HOSTS = os.getenv(\"NAUTOBOT_ALLOWED_HOSTS\", \"\").split(\" \")",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = (\"127.0.0.1\", \"::1\")",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = len(sys.argv) > 1 and sys.argv[1] == \"test\"",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # keep log quiet by default when running unit/integration tests",
            "    LOGGING = {}",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "SHORT_TIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_TIME_FORMAT\", \"H:i:s\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"cacheops\",  # v2 TODO(jathan); Remove cacheops.",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"mptt\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.utilities\",",
            "    \"nautobot.virtualization\",",
            "    \"django_rq\",  # Must come after nautobot.extras to allow overriding management commands",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (os.path.join(BASE_DIR, \"project-static\"),)",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.utilities.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"BANNER_BOTTOM\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the bottom of all pages.\",",
            "    ],",
            "    \"BANNER_LOGIN\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of the login page.\",",
            "    ],",
            "    \"BANNER_TOP\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of all pages.\",",
            "    ],",
            "    \"CHANGELOG_RETENTION\": [",
            "        90,",
            "        \"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "    ],",
            "    \"DEPLOYMENT_ID\": [",
            "        \"\",",
            "        \"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "    ],",
            "    \"DISABLE_PREFIX_LIST_HIERARCHY\": [",
            "        False,",
            "        \"Disable rendering parent/child relationships in the IPAM Prefix list view and instead show a flat list.\",",
            "    ],",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": [",
            "        0,",
            "        \"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "    ],",
            "    \"HIDE_RESTRICTED_UI\": [",
            "        False,",
            "        \"If set to True, users with limited permissions will not be shown menu items and home-page elements that \"",
            "        \"they do not have permission to access.\",",
            "    ],",
            "    \"MAX_PAGE_SIZE\": [",
            "        1000,",
            "        \"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "    ],",
            "    \"NETWORK_DRIVERS\": [",
            "        {},",
            "        mark_safe(  # noqa: S308",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            \"<pre>{\\n\"",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        \"optional_json_field\",",
            "    ],",
            "    \"PAGINATE_COUNT\": [",
            "        50,",
            "        \"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "    ],",
            "    \"PER_PAGE_DEFAULTS\": [",
            "        [25, 50, 100, 250, 500, 1000],",
            "        \"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        \"per_page_defaults_field\",",
            "    ],",
            "    \"PREFER_IPV4\": [",
            "        False,",
            "        \"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": [",
            "        22,",
            "        \"Default height (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": [",
            "        230,",
            "        \"Default width (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RELEASE_CHECK_TIMEOUT\": [",
            "        24 * 3600,",
            "        \"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        \"release_check_timeout_field\",",
            "    ],",
            "    \"RELEASE_CHECK_URL\": [",
            "        \"\",",
            "        \"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        \"release_check_url_field\",",
            "    ],",
            "    \"SUPPORT_MESSAGE\": [",
            "        \"\",",
            "        \"Help message to include on 4xx and 5xx error pages. Markdown is supported.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"],",
            "    \"Rack Elevation Rendering\": [\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"DISABLE_PREFIX_LIST_HIERARCHY\", \"HIDE_RESTRICTED_UI\", \"SUPPORT_MESSAGE\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# v2 TODO(jathan): Remove all cacheops settings.",
            "# The django-cacheops plugin is used to cache querysets. The built-in Django",
            "# caching is not used.",
            "CACHEOPS = {",
            "    \"auth.user\": {\"ops\": \"get\", \"timeout\": 60 * 15},",
            "    \"auth.*\": {\"ops\": (\"fetch\", \"get\")},",
            "    \"auth.permission\": {\"ops\": \"all\"},",
            "    \"circuits.*\": {\"ops\": \"all\"},",
            "    \"dcim.inventoryitem\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.region\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.rackgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.*\": {\"ops\": \"all\"},",
            "    \"ipam.*\": {\"ops\": \"all\"},",
            "    \"extras.*\": {\"ops\": \"all\"},",
            "    \"users.*\": {\"ops\": \"all\"},",
            "    \"tenancy.tenantgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"tenancy.*\": {\"ops\": \"all\"},",
            "    \"virtualization.*\": {\"ops\": \"all\"},",
            "}",
            "CACHEOPS_DEGRADE_ON_FAILURE = True",
            "CACHEOPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CACHEOPS_ENABLED\", \"False\"))",
            "CACHEOPS_REDIS = os.getenv(\"NAUTOBOT_CACHEOPS_REDIS\", parse_redis_connection(redis_database=1))",
            "CACHEOPS_DEFAULTS = {\"timeout\": int(os.getenv(\"NAUTOBOT_CACHEOPS_TIMEOUT\", \"900\"))}",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis. The",
            "# django-rq settings will use the same instance/database by default.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=0),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Django RQ (used for legacy background processesing)",
            "#",
            "",
            "# These defaults utilize the Django caches setting defined for django-redis.",
            "# See: https://github.com/rq/django-rq#support-for-django-redis-and-django-redis-cache",
            "RQ_QUEUES = {",
            "    \"default\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"check_releases\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"custom_fields\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"webhooks\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "}",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results",
            "CELERY_RESULT_BACKEND = os.getenv(\"NAUTOBOT_CELERY_RESULT_BACKEND\", parse_redis_connection(redis_database=0))",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(\",\")",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]"
        ],
        "afterPatchFile": [
            "import os",
            "import platform",
            "import re",
            "import sys",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.settings_funcs import is_truthy, parse_redis_connection  # noqa: F401",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can\u2019t do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "ALLOWED_URL_SCHEMES = (",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            ")",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# By default, Nautobot will permit users to create duplicate prefixes and IP addresses in the global",
            "# table (that is, those which are not assigned to any VRF). This behavior can be disabled by setting",
            "# ENFORCE_GLOBAL_UNIQUE to True.",
            "ENFORCE_GLOBAL_UNIQUE = is_truthy(os.getenv(\"NAUTOBOT_ENFORCE_GLOBAL_UNIQUE\", \"False\"))",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (re.compile(r\"(username|password|passwd|pwd)((?:\\s+is.?|:)?\\s+)\\S+\", re.IGNORECASE), r\"\\1\\2{replacement}\"),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django cryptography",
            "#",
            "",
            "# CRYPTOGRAPHY_BACKEND = cryptography.hazmat.backends.default_backend()",
            "# CRYPTOGRAPHY_DIGEST = cryptography.hazmat.primitives.hashes.SHA256",
            "CRYPTOGRAPHY_KEY = None  # Defaults to SECRET_KEY if unset",
            "CRYPTOGRAPHY_SALT = \"nautobot-cryptography\"",
            "",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "current_major, current_minor = REST_FRAMEWORK_VERSION.split(\".\")",
            "# We support all major.minor API versions from 1.2 to the present latest version.",
            "# This will need to be elaborated upon when we move to version 2.0",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "assert current_major == \"1\", f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {current_major}\"",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{current_major}.{minor}\" for minor in range(2, int(current_minor) + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (\"nautobot.core.api.filter_backends.NautobotFilterBackend\",),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.BulkOperationMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"rest_framework.renderers.JSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (\"rest_framework.parsers.JSONParser\",),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise.",
            "    # This should only change (if at all) with Nautobot major (breaking) releases.",
            "    \"DEFAULT_VERSION\": \"1.2\",",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.utilities.api.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # Each of these StatusModels has bulk and non-bulk serializers, with the same status options,",
            "        # which confounds drf-spectacular's automatic naming of enums, resulting in the below warning:",
            "        #   enum naming encountered a non-optimally resolvable collision for fields named \"status\"",
            "        # By explicitly naming the enums ourselves we avoid this warning.",
            "        \"CableStatusChoices\": \"nautobot.dcim.api.serializers.CableSerializer.status_choices\",",
            "        \"CircuitStatusChoices\": \"nautobot.circuits.api.serializers.CircuitSerializer.status_choices\",",
            "        \"DeviceStatusChoices\": \"nautobot.dcim.api.serializers.DeviceWithConfigContextSerializer.status_choices\",",
            "        \"InterfaceStatusChoices\": \"nautobot.dcim.api.serializers.InterfaceSerializer.status_choices\",",
            "        \"IPAddressStatusChoices\": \"nautobot.ipam.api.serializers.IPAddressSerializer.status_choices\",",
            "        \"LocationStatusChoices\": \"nautobot.dcim.api.serializers.LocationSerializer.status_choices\",",
            "        \"PowerFeedStatusChoices\": \"nautobot.dcim.api.serializers.PowerFeedSerializer.status_choices\",",
            "        \"PrefixStatusChoices\": \"nautobot.ipam.api.serializers.PrefixSerializer.status_choices\",",
            "        \"RackStatusChoices\": \"nautobot.dcim.api.serializers.RackSerializer.status_choices\",",
            "        \"VirtualMachineStatusChoices\": \"nautobot.virtualization.api.serializers.VirtualMachineWithConfigContextSerializer.status_choices\",",
            "        \"VLANStatusChoices\": \"nautobot.ipam.api.serializers.VLANSerializer.status_choices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "# Only PostgresSQL is supported, so database driver is hard-coded. This can",
            "# still be overloaded in custom settings.",
            "# https://docs.djangoproject.com/en/stable/ref/settings/#databases",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\")",
            "",
            "# Default overrides",
            "ALLOWED_HOSTS = os.getenv(\"NAUTOBOT_ALLOWED_HOSTS\", \"\").split(\" \")",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = (\"127.0.0.1\", \"::1\")",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = len(sys.argv) > 1 and sys.argv[1] == \"test\"",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # keep log quiet by default when running unit/integration tests",
            "    LOGGING = {}",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "SHORT_TIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_TIME_FORMAT\", \"H:i:s\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"cacheops\",  # v2 TODO(jathan); Remove cacheops.",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"mptt\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.utilities\",",
            "    \"nautobot.virtualization\",",
            "    \"django_rq\",  # Must come after nautobot.extras to allow overriding management commands",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (os.path.join(BASE_DIR, \"project-static\"),)",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.utilities.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"BANNER_BOTTOM\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the bottom of all pages.\",",
            "    ],",
            "    \"BANNER_LOGIN\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of the login page.\",",
            "    ],",
            "    \"BANNER_TOP\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of all pages.\",",
            "    ],",
            "    \"CHANGELOG_RETENTION\": [",
            "        90,",
            "        \"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "    ],",
            "    \"DEPLOYMENT_ID\": [",
            "        \"\",",
            "        \"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "    ],",
            "    \"DISABLE_PREFIX_LIST_HIERARCHY\": [",
            "        False,",
            "        \"Disable rendering parent/child relationships in the IPAM Prefix list view and instead show a flat list.\",",
            "    ],",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": [",
            "        0,",
            "        \"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "    ],",
            "    \"HIDE_RESTRICTED_UI\": [",
            "        False,",
            "        \"If set to True, users with limited permissions will not be shown menu items and home-page elements that \"",
            "        \"they do not have permission to access.\",",
            "    ],",
            "    \"MAX_PAGE_SIZE\": [",
            "        1000,",
            "        \"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "    ],",
            "    \"NETWORK_DRIVERS\": [",
            "        {},",
            "        mark_safe(  # noqa: S308",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            \"<pre>{\\n\"",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        \"optional_json_field\",",
            "    ],",
            "    \"PAGINATE_COUNT\": [",
            "        50,",
            "        \"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "    ],",
            "    \"PER_PAGE_DEFAULTS\": [",
            "        [25, 50, 100, 250, 500, 1000],",
            "        \"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        \"per_page_defaults_field\",",
            "    ],",
            "    \"PREFER_IPV4\": [",
            "        False,",
            "        \"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": [",
            "        22,",
            "        \"Default height (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": [",
            "        230,",
            "        \"Default width (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RELEASE_CHECK_TIMEOUT\": [",
            "        24 * 3600,",
            "        \"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        \"release_check_timeout_field\",",
            "    ],",
            "    \"RELEASE_CHECK_URL\": [",
            "        \"\",",
            "        \"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        \"release_check_url_field\",",
            "    ],",
            "    \"SUPPORT_MESSAGE\": [",
            "        \"\",",
            "        \"Help message to include on 4xx and 5xx error pages. \"",
            "        \"Markdown is supported, as are some HTML tags and attributes.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"],",
            "    \"Rack Elevation Rendering\": [\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"DISABLE_PREFIX_LIST_HIERARCHY\", \"HIDE_RESTRICTED_UI\", \"SUPPORT_MESSAGE\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# v2 TODO(jathan): Remove all cacheops settings.",
            "# The django-cacheops plugin is used to cache querysets. The built-in Django",
            "# caching is not used.",
            "CACHEOPS = {",
            "    \"auth.user\": {\"ops\": \"get\", \"timeout\": 60 * 15},",
            "    \"auth.*\": {\"ops\": (\"fetch\", \"get\")},",
            "    \"auth.permission\": {\"ops\": \"all\"},",
            "    \"circuits.*\": {\"ops\": \"all\"},",
            "    \"dcim.inventoryitem\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.region\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.rackgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.*\": {\"ops\": \"all\"},",
            "    \"ipam.*\": {\"ops\": \"all\"},",
            "    \"extras.*\": {\"ops\": \"all\"},",
            "    \"users.*\": {\"ops\": \"all\"},",
            "    \"tenancy.tenantgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"tenancy.*\": {\"ops\": \"all\"},",
            "    \"virtualization.*\": {\"ops\": \"all\"},",
            "}",
            "CACHEOPS_DEGRADE_ON_FAILURE = True",
            "CACHEOPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CACHEOPS_ENABLED\", \"False\"))",
            "CACHEOPS_REDIS = os.getenv(\"NAUTOBOT_CACHEOPS_REDIS\", parse_redis_connection(redis_database=1))",
            "CACHEOPS_DEFAULTS = {\"timeout\": int(os.getenv(\"NAUTOBOT_CACHEOPS_TIMEOUT\", \"900\"))}",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis. The",
            "# django-rq settings will use the same instance/database by default.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=0),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Django RQ (used for legacy background processesing)",
            "#",
            "",
            "# These defaults utilize the Django caches setting defined for django-redis.",
            "# See: https://github.com/rq/django-rq#support-for-django-redis-and-django-redis-cache",
            "RQ_QUEUES = {",
            "    \"default\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"check_releases\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"custom_fields\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"webhooks\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "}",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results",
            "CELERY_RESULT_BACKEND = os.getenv(\"NAUTOBOT_CELERY_RESULT_BACKEND\", parse_redis_connection(redis_database=0))",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(\",\")",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "674": []
        },
        "addLocation": []
    },
    "nautobot/core/tests/test_views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "         self.assertContains(response, \"Network to Code\", status_code=404)"
            },
            "1": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "         response_content = response.content.decode(response.charset)"
            },
            "2": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "         self.assertInHTML("
            },
            "3": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"If further assistance is required, please join the <code>#nautobot</code> channel \""
            },
            "4": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'on <a href=\"https://slack.networktocode.com/\">Network to Code\\'s Slack community</a> '"
            },
            "5": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"and post your question.\","
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+            \"If further assistance is required, please join the <code>#nautobot</code> channel on \""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+            \"Slack community</a> and post your question.\","
            },
            "9": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "             response_content,"
            },
            "10": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "         )"
            },
            "11": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 378,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         self.assertContains(response, \"Network to Code\", status_code=500)"
            },
            "13": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "         response_content = response.content.decode(response.charset)"
            },
            "14": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "         self.assertInHTML("
            },
            "15": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"If further assistance is required, please join the <code>#nautobot</code> channel \""
            },
            "16": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'on <a href=\"https://slack.networktocode.com/\">Network to Code\\'s Slack community</a> '"
            },
            "17": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"and post your question.\","
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+            \"If further assistance is required, please join the <code>#nautobot</code> channel on \""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+            \"Slack community</a> and post your question.\","
            },
            "21": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "             response_content,"
            },
            "22": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "         )"
            },
            "23": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 404,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "     @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")"
            },
            "25": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "     @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)"
            },
            "26": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "     def test_500_custom_support_message(self, mock_get):"
            },
            "27": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Nautobot's custom 500 page should be used and should include a default support message.\"\"\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+        \"\"\"Nautobot's custom 500 page should be used and should include a custom support message if defined.\"\"\""
            },
            "29": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "         url = reverse(\"home\")"
            },
            "30": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "         with self.assertTemplateUsed(\"500.html\"):"
            },
            "31": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "             self.client.raise_request_exception = False"
            }
        },
        "frontPatchFile": [
            "import re",
            "from unittest import mock",
            "import urllib.parse",
            "",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings",
            "from django.test.utils import override_script_prefix",
            "from django.urls import get_script_prefix, reverse",
            "from prometheus_client.parser import text_string_to_metric_families",
            "",
            "from nautobot.extras.models import FileProxy",
            "from nautobot.extras.registry import registry",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.testing import TestCase",
            "",
            "",
            "class HomeViewTestCase(TestCase):",
            "    def test_home(self):",
            "        url = reverse(\"home\")",
            "",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_search(self):",
            "        url = reverse(\"search\")",
            "        params = {",
            "            \"q\": \"foo\",",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def make_request(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "",
            "        # Search bar in nav",
            "        nav_search_bar_pattern = re.compile(",
            "            '<nav.*<form action=\"/search/\" method=\"get\" class=\"navbar-form navbar-right\" id=\"navbar_search\" role=\"search\">.*</form>.*</nav>'",
            "        )",
            "        nav_search_bar_result = nav_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        # Global search bar in body/container-fluid wrapper",
            "        body_search_bar_pattern = re.compile(",
            "            '<div class=\"container-fluid wrapper\">.*<form action=\"/search/\" method=\"get\" class=\"form-inline\">.*</form>.*</div>'",
            "        )",
            "        body_search_bar_result = body_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        return nav_search_bar_result, body_search_bar_result",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True)",
            "    def test_search_bar_not_visible_if_user_not_authenticated_and_hide_restricted_ui_True(self):",
            "        self.client.logout()",
            "",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNone(nav_search_bar_result)",
            "        self.assertIsNone(body_search_bar_result)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_search_bar_visible_if_user_authenticated_and_hide_restricted_ui_True(self):",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_search_bar_visible_if_hide_restricted_ui_False(self):",
            "        # Assert if user is authenticated",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "        # Assert if user is logout",
            "        self.client.logout()",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "    @override_settings(VERSION=\"1.2.3\")",
            "    def test_footer_version_visible_authenticated_users_only(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "",
            "        footer_hostname_version_pattern = re.compile(r'<p class=\"text-muted\">\\s+\\S+\\s+\\(v1\\.2\\.3\\)\\s+</p>')",
            "        self.assertRegex(response_content, footer_hostname_version_pattern)",
            "",
            "        self.client.logout()",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        self.assertNotRegex(response_content, footer_hostname_version_pattern)",
            "",
            "",
            "@override_settings(BRANDING_TITLE=\"Nautobot\")",
            "class SearchFieldsTestCase(TestCase):",
            "    def test_search_bar_redirect_to_login(self):",
            "        self.client.logout()",
            "        response = self.client.get(reverse(\"search\") + \"?q=prefix\")",
            "        # Assert that if the user is not logged in",
            "        # SearchForm will redirect the user to the login Page",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "    def test_global_and_model_search_bar(self):",
            "        self.add_permissions(\"dcim.view_site\", \"dcim.view_device\")",
            "",
            "        # Assert model search bar present in list UI",
            "        response = self.client.get(reverse(\"dcim:site_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Sites\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"dcim:device_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Devices\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        # Assert global search bar present in UI",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" placeholder=\"Search Nautobot\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "",
            "class FilterFormsTestCase(TestCase):",
            "    def test_support_for_both_default_and_dynamic_filter_form_in_ui(self):",
            "        self.add_permissions(\"dcim.view_site\", \"circuits.view_circuit\")",
            "",
            "        filter_tabs = \"\"\"",
            "            <ul id=\"tabs\" class=\"nav nav-tabs\">",
            "                <li role=\"presentation\" class=\"active\">",
            "                    <a href=\"#default-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Default",
            "                    </a>",
            "                </li>",
            "                <li role=\"presentation\" class=\"\">",
            "                    <a href=\"#advanced-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Advanced",
            "                    </a>",
            "                </li>",
            "            </ul>",
            "            \"\"\"",
            "",
            "        response = self.client.get(reverse(\"dcim:site_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"circuits:circuit_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "",
            "class ForceScriptNameTestcase(TestCase):",
            "    \"\"\"Basic test to assert that `settings.FORCE_SCRIPT_NAME` works as intended.\"\"\"",
            "",
            "    @override_settings(",
            "        FORCE_SCRIPT_NAME=\"/nautobot/\",",
            "    )",
            "    @override_script_prefix(\"/nautobot/\")",
            "    def test_subdirectory_routes(self):",
            "        # We must call `set_script_prefix()` to set the URL resolver script prefix outside of the",
            "        # request/response cycle (e.g. in scripts/tests) to generate correct URLs when `SCRIPT_NAME`",
            "        # is not `/`.",
            "        #",
            "        # We must then call it again to reset the script pefix after we're done because",
            "        # the state is stored in the thread-local scope and will \"infect\" other tests.",
            "        prefix = get_script_prefix()",
            "        self.assertEqual(prefix, \"/nautobot/\")",
            "",
            "        # And that routes will start w/ the prefix vs. just \"/\" (the default).",
            "        routes = (\"home\", \"login\", \"search\", \"api-root\")",
            "        for route in routes:",
            "            url = reverse(route)",
            "            self.assertTrue(url.startswith(prefix))",
            "",
            "",
            "class NavRestrictedUI(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.url = reverse(\"plugins:plugins_list\")",
            "        self.item_weight = 100  # TODO: not easy to introspect from the nav menu struct, so hard-code it here for now",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"home\"))",
            "        return response.content.decode(response.charset)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True)",
            "    def test_installed_plugins_visible_to_staff_with_hide_restricted_ui_true(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be available to is_staff user regardless of HIDE_RESTRICTED_UI.\"\"\"",
            "        # Make user admin",
            "        self.user.is_staff = True",
            "        self.user.save()",
            "",
            "        response_content = self.make_request()",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <li>",
            "              <div class=\"buttons pull-right\"></div>",
            "              <a href=\"{self.url}\" data-item-weight=\"{self.item_weight}\">Installed Plugins</a>",
            "            </li>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_installed_plugins_visible_to_staff_with_hide_restricted_ui_false(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be available to is_staff user regardless of HIDE_RESTRICTED_UI.\"\"\"",
            "        # Make user admin",
            "        self.user.is_staff = True",
            "        self.user.save()",
            "",
            "        response_content = self.make_request()",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <li>",
            "              <div class=\"buttons pull-right\"></div>",
            "              <a href=\"{self.url}\" data-item-weight=\"{self.item_weight}\">Installed Plugins</a>",
            "            </li>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True)",
            "    def test_installed_plugins_not_visible_to_non_staff_user_with_hide_restricted_ui_true(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be hidden from a non-staff user when HIDE_RESTRICTED_UI=True.\"\"\"",
            "        response_content = self.make_request()",
            "",
            "        self.assertNotRegex(response_content, r\"Installed\\s+Plugins\")",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_installed_plugins_disabled_to_non_staff_user_with_hide_restricted_ui_false(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be disabled for a non-staff user when HIDE_RESTRICTED_UI=False.\"\"\"",
            "        response_content = self.make_request()",
            "",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <li class=\"disabled\">",
            "              <div class=\"buttons pull-right\"></div>",
            "              <a href=\"{self.url}\" data-item-weight=\"{self.item_weight}\">Installed Plugins</a>",
            "            </li>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "",
            "class LoginUI(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.footer_elements = [",
            "            '<a href=\"#theme_modal\" data-toggle=\"modal\" data-target=\"#theme_modal\" id=\"btn-theme-modal\"><i class=\"mdi mdi-theme-light-dark text-primary\"></i>Theme</a>',",
            "            '<a href=\"/static/docs/index.html\">Docs</a>',",
            "            '<i class=\"mdi mdi-cloud-braces text-primary\"></i> <a href=\"/api/docs/\">API</a>',",
            "            '<i class=\"mdi mdi-graphql text-primary\"></i> <a href=\"/graphql/\">GraphQL</a>',",
            "            '<i class=\"mdi mdi-xml text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot\">Code</a>',",
            "            '<i class=\"mdi mdi-lifebuoy text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot/wiki\">Help</a>',",
            "        ]",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"login\"))",
            "        sso_login_pattern = re.compile('<a href=\".*\">Continue with SSO</a>')",
            "        return sso_login_pattern.search(response.content.decode(response.charset))",
            "",
            "    def test_sso_login_button_not_visible(self):",
            "        \"\"\"Test Continue with SSO button not visible if SSO is enabled\"\"\"",
            "        self.client.logout()",
            "",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNone(sso_login_search_result)",
            "",
            "    @override_settings(",
            "        AUTHENTICATION_BACKENDS=[",
            "            \"social_core.backends.google.GoogleOAuth2\",",
            "            \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "        ]",
            "    )",
            "    def test_sso_login_button_visible(self):",
            "        self.client.logout()",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNotNone(sso_login_search_result)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True, BANNER_TOP=\"Hello, Banner Top\", BANNER_BOTTOM=\"Hello, Banner Bottom\")",
            "    def test_routes_redirect_back_to_login_if_hide_restricted_ui_true(self):",
            "        \"\"\"Assert that api docs and graphql redirects to login page if user is unauthenticated and HIDE_RESTRICTED_UI=True.\"\"\"",
            "        self.client.logout()",
            "        headers = {\"HTTP_ACCEPT\": \"text/html\"}",
            "        urls = [reverse(\"api_docs\"), reverse(\"graphql\")]",
            "        for url in urls:",
            "            response = self.client.get(url, follow=True, **headers)",
            "            self.assertHttpStatus(response, 200)",
            "            redirect_chain = [(f\"/login/?next={url}\", 302)]",
            "            self.assertEqual(response.redirect_chain, redirect_chain)",
            "            response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "            # Assert Footer items(`self.footer_elements`), Banner and Banner Top is hidden",
            "            for footer_text in self.footer_elements:",
            "                self.assertNotIn(footer_text, response_content)",
            "            # Only API Docs implements BANNERS",
            "            if url == urls[0]:",
            "                self.assertNotIn(\"Hello, Banner Top\", response_content)",
            "                self.assertNotIn(\"Hello, Banner Bottom\", response_content)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False, BANNER_TOP=\"Hello, Banner Top\", BANNER_BOTTOM=\"Hello, Banner Bottom\")",
            "    def test_routes_no_redirect_back_to_login_if_hide_restricted_ui_false(self):",
            "        \"\"\"Assert that api docs and graphql do not redirects to login page if user is unauthenticated and HIDE_RESTRICTED_UI=False.\"\"\"",
            "        self.client.logout()",
            "        headers = {\"HTTP_ACCEPT\": \"text/html\"}",
            "        urls = [reverse(\"api_docs\"), reverse(\"graphql\")]",
            "        for url in urls:",
            "            response = self.client.get(url, **headers)",
            "            self.assertHttpStatus(response, 200)",
            "            self.assertEqual(response.request[\"PATH_INFO\"], url)",
            "            response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "            # Assert Footer items(`self.footer_elements`), Banner and Banner Top is not hidden",
            "            for footer_text in self.footer_elements:",
            "                self.assertInHTML(footer_text, response_content)",
            "",
            "            # Only API Docs implements BANNERS",
            "            if url == urls[0]:",
            "                self.assertInHTML(\"Hello, Banner Top\", response_content)",
            "                self.assertInHTML(\"Hello, Banner Bottom\", response_content)",
            "",
            "",
            "class MetricsViewTestCase(TestCase):",
            "    def query_and_parse_metrics(self):",
            "        response = self.client.get(reverse(\"metrics\"))",
            "        self.assertHttpStatus(response, 200, msg=\"/metrics should return a 200 HTTP status code.\")",
            "        page_content = response.content.decode(response.charset)",
            "        return text_string_to_metric_families(page_content)",
            "",
            "    def test_metrics_extensibility(self):",
            "        \"\"\"Assert that the example metric from the example plugin shows up _exactly_ when the plugin is enabled.\"\"\"",
            "        test_metric_name = \"nautobot_example_metric_count\"",
            "        metrics_with_plugin = self.query_and_parse_metrics()",
            "        metric_names_with_plugin = {metric.name for metric in metrics_with_plugin}",
            "        self.assertIn(test_metric_name, metric_names_with_plugin)",
            "        with override_settings(PLUGINS=[]):",
            "            # Clear out the app metric registry because it is not updated when settings are changed but Nautobot is not",
            "            # restarted.",
            "            registry[\"app_metrics\"].clear()",
            "            metrics_without_plugin = self.query_and_parse_metrics()",
            "            metric_names_without_plugin = {metric.name for metric in metrics_without_plugin}",
            "            self.assertNotIn(test_metric_name, metric_names_without_plugin)",
            "        metric_names_with_plugin.remove(test_metric_name)",
            "        self.assertSetEqual(metric_names_with_plugin, metric_names_without_plugin)",
            "",
            "",
            "class ErrorPagesTestCase(TestCase):",
            "    \"\"\"Tests for 4xx and 5xx error page rendering.\"\"\"",
            "",
            "    @override_settings(DEBUG=False)",
            "    def test_404_default_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a default support message.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel \"",
            "            'on <a href=\"https://slack.networktocode.com/\">Network to Code\\'s Slack community</a> '",
            "            \"and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    def test_404_custom_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a custom support message if defined.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertNotContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "    @override_settings(DEBUG=False)",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_default_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a default support message.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel \"",
            "            'on <a href=\"https://slack.networktocode.com/\">Network to Code\\'s Slack community</a> '",
            "            \"and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_custom_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a default support message.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertNotContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "",
            "class DBFileStorageViewTestCase(TestCase):",
            "    \"\"\"Test authentication/permission enforcement for django_db_file_storage views.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.test_file_1 = SimpleUploadedFile(name=\"test_file_1.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_1 = FileProxy.objects.create(name=self.test_file_1.name, file=self.test_file_1)",
            "        self.test_file_2 = SimpleUploadedFile(name=\"test_file_2.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_2 = FileProxy.objects.create(name=self.test_file_2.name, file=self.test_file_2)",
            "        self.url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_1.file.name}\"",
            "",
            "    def test_get_file_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_file_without_permission(self):",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_object_with_permission(self):",
            "        self.add_permissions(get_permission_for_model(FileProxy, \"view\"))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_get_object_with_constrained_permission(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.file_proxy_1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(FileProxy))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "        url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_2.file.name}\"",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)"
        ],
        "afterPatchFile": [
            "import re",
            "from unittest import mock",
            "import urllib.parse",
            "",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings",
            "from django.test.utils import override_script_prefix",
            "from django.urls import get_script_prefix, reverse",
            "from prometheus_client.parser import text_string_to_metric_families",
            "",
            "from nautobot.extras.models import FileProxy",
            "from nautobot.extras.registry import registry",
            "from nautobot.users.models import ObjectPermission",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.testing import TestCase",
            "",
            "",
            "class HomeViewTestCase(TestCase):",
            "    def test_home(self):",
            "        url = reverse(\"home\")",
            "",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_search(self):",
            "        url = reverse(\"search\")",
            "        params = {",
            "            \"q\": \"foo\",",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def make_request(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "",
            "        # Search bar in nav",
            "        nav_search_bar_pattern = re.compile(",
            "            '<nav.*<form action=\"/search/\" method=\"get\" class=\"navbar-form navbar-right\" id=\"navbar_search\" role=\"search\">.*</form>.*</nav>'",
            "        )",
            "        nav_search_bar_result = nav_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        # Global search bar in body/container-fluid wrapper",
            "        body_search_bar_pattern = re.compile(",
            "            '<div class=\"container-fluid wrapper\">.*<form action=\"/search/\" method=\"get\" class=\"form-inline\">.*</form>.*</div>'",
            "        )",
            "        body_search_bar_result = body_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        return nav_search_bar_result, body_search_bar_result",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True)",
            "    def test_search_bar_not_visible_if_user_not_authenticated_and_hide_restricted_ui_True(self):",
            "        self.client.logout()",
            "",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNone(nav_search_bar_result)",
            "        self.assertIsNone(body_search_bar_result)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_search_bar_visible_if_user_authenticated_and_hide_restricted_ui_True(self):",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_search_bar_visible_if_hide_restricted_ui_False(self):",
            "        # Assert if user is authenticated",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "        # Assert if user is logout",
            "        self.client.logout()",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "    @override_settings(VERSION=\"1.2.3\")",
            "    def test_footer_version_visible_authenticated_users_only(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "",
            "        footer_hostname_version_pattern = re.compile(r'<p class=\"text-muted\">\\s+\\S+\\s+\\(v1\\.2\\.3\\)\\s+</p>')",
            "        self.assertRegex(response_content, footer_hostname_version_pattern)",
            "",
            "        self.client.logout()",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        self.assertNotRegex(response_content, footer_hostname_version_pattern)",
            "",
            "",
            "@override_settings(BRANDING_TITLE=\"Nautobot\")",
            "class SearchFieldsTestCase(TestCase):",
            "    def test_search_bar_redirect_to_login(self):",
            "        self.client.logout()",
            "        response = self.client.get(reverse(\"search\") + \"?q=prefix\")",
            "        # Assert that if the user is not logged in",
            "        # SearchForm will redirect the user to the login Page",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "    def test_global_and_model_search_bar(self):",
            "        self.add_permissions(\"dcim.view_site\", \"dcim.view_device\")",
            "",
            "        # Assert model search bar present in list UI",
            "        response = self.client.get(reverse(\"dcim:site_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Sites\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"dcim:device_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Devices\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        # Assert global search bar present in UI",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" placeholder=\"Search Nautobot\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "",
            "class FilterFormsTestCase(TestCase):",
            "    def test_support_for_both_default_and_dynamic_filter_form_in_ui(self):",
            "        self.add_permissions(\"dcim.view_site\", \"circuits.view_circuit\")",
            "",
            "        filter_tabs = \"\"\"",
            "            <ul id=\"tabs\" class=\"nav nav-tabs\">",
            "                <li role=\"presentation\" class=\"active\">",
            "                    <a href=\"#default-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Default",
            "                    </a>",
            "                </li>",
            "                <li role=\"presentation\" class=\"\">",
            "                    <a href=\"#advanced-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Advanced",
            "                    </a>",
            "                </li>",
            "            </ul>",
            "            \"\"\"",
            "",
            "        response = self.client.get(reverse(\"dcim:site_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"circuits:circuit_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "",
            "class ForceScriptNameTestcase(TestCase):",
            "    \"\"\"Basic test to assert that `settings.FORCE_SCRIPT_NAME` works as intended.\"\"\"",
            "",
            "    @override_settings(",
            "        FORCE_SCRIPT_NAME=\"/nautobot/\",",
            "    )",
            "    @override_script_prefix(\"/nautobot/\")",
            "    def test_subdirectory_routes(self):",
            "        # We must call `set_script_prefix()` to set the URL resolver script prefix outside of the",
            "        # request/response cycle (e.g. in scripts/tests) to generate correct URLs when `SCRIPT_NAME`",
            "        # is not `/`.",
            "        #",
            "        # We must then call it again to reset the script pefix after we're done because",
            "        # the state is stored in the thread-local scope and will \"infect\" other tests.",
            "        prefix = get_script_prefix()",
            "        self.assertEqual(prefix, \"/nautobot/\")",
            "",
            "        # And that routes will start w/ the prefix vs. just \"/\" (the default).",
            "        routes = (\"home\", \"login\", \"search\", \"api-root\")",
            "        for route in routes:",
            "            url = reverse(route)",
            "            self.assertTrue(url.startswith(prefix))",
            "",
            "",
            "class NavRestrictedUI(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.url = reverse(\"plugins:plugins_list\")",
            "        self.item_weight = 100  # TODO: not easy to introspect from the nav menu struct, so hard-code it here for now",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"home\"))",
            "        return response.content.decode(response.charset)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True)",
            "    def test_installed_plugins_visible_to_staff_with_hide_restricted_ui_true(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be available to is_staff user regardless of HIDE_RESTRICTED_UI.\"\"\"",
            "        # Make user admin",
            "        self.user.is_staff = True",
            "        self.user.save()",
            "",
            "        response_content = self.make_request()",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <li>",
            "              <div class=\"buttons pull-right\"></div>",
            "              <a href=\"{self.url}\" data-item-weight=\"{self.item_weight}\">Installed Plugins</a>",
            "            </li>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_installed_plugins_visible_to_staff_with_hide_restricted_ui_false(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be available to is_staff user regardless of HIDE_RESTRICTED_UI.\"\"\"",
            "        # Make user admin",
            "        self.user.is_staff = True",
            "        self.user.save()",
            "",
            "        response_content = self.make_request()",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <li>",
            "              <div class=\"buttons pull-right\"></div>",
            "              <a href=\"{self.url}\" data-item-weight=\"{self.item_weight}\">Installed Plugins</a>",
            "            </li>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True)",
            "    def test_installed_plugins_not_visible_to_non_staff_user_with_hide_restricted_ui_true(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be hidden from a non-staff user when HIDE_RESTRICTED_UI=True.\"\"\"",
            "        response_content = self.make_request()",
            "",
            "        self.assertNotRegex(response_content, r\"Installed\\s+Plugins\")",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False)",
            "    def test_installed_plugins_disabled_to_non_staff_user_with_hide_restricted_ui_false(self):",
            "        \"\"\"The \"Installed Plugins\" menu item should be disabled for a non-staff user when HIDE_RESTRICTED_UI=False.\"\"\"",
            "        response_content = self.make_request()",
            "",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <li class=\"disabled\">",
            "              <div class=\"buttons pull-right\"></div>",
            "              <a href=\"{self.url}\" data-item-weight=\"{self.item_weight}\">Installed Plugins</a>",
            "            </li>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "",
            "class LoginUI(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.footer_elements = [",
            "            '<a href=\"#theme_modal\" data-toggle=\"modal\" data-target=\"#theme_modal\" id=\"btn-theme-modal\"><i class=\"mdi mdi-theme-light-dark text-primary\"></i>Theme</a>',",
            "            '<a href=\"/static/docs/index.html\">Docs</a>',",
            "            '<i class=\"mdi mdi-cloud-braces text-primary\"></i> <a href=\"/api/docs/\">API</a>',",
            "            '<i class=\"mdi mdi-graphql text-primary\"></i> <a href=\"/graphql/\">GraphQL</a>',",
            "            '<i class=\"mdi mdi-xml text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot\">Code</a>',",
            "            '<i class=\"mdi mdi-lifebuoy text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot/wiki\">Help</a>',",
            "        ]",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"login\"))",
            "        sso_login_pattern = re.compile('<a href=\".*\">Continue with SSO</a>')",
            "        return sso_login_pattern.search(response.content.decode(response.charset))",
            "",
            "    def test_sso_login_button_not_visible(self):",
            "        \"\"\"Test Continue with SSO button not visible if SSO is enabled\"\"\"",
            "        self.client.logout()",
            "",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNone(sso_login_search_result)",
            "",
            "    @override_settings(",
            "        AUTHENTICATION_BACKENDS=[",
            "            \"social_core.backends.google.GoogleOAuth2\",",
            "            \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "        ]",
            "    )",
            "    def test_sso_login_button_visible(self):",
            "        self.client.logout()",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNotNone(sso_login_search_result)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=True, BANNER_TOP=\"Hello, Banner Top\", BANNER_BOTTOM=\"Hello, Banner Bottom\")",
            "    def test_routes_redirect_back_to_login_if_hide_restricted_ui_true(self):",
            "        \"\"\"Assert that api docs and graphql redirects to login page if user is unauthenticated and HIDE_RESTRICTED_UI=True.\"\"\"",
            "        self.client.logout()",
            "        headers = {\"HTTP_ACCEPT\": \"text/html\"}",
            "        urls = [reverse(\"api_docs\"), reverse(\"graphql\")]",
            "        for url in urls:",
            "            response = self.client.get(url, follow=True, **headers)",
            "            self.assertHttpStatus(response, 200)",
            "            redirect_chain = [(f\"/login/?next={url}\", 302)]",
            "            self.assertEqual(response.redirect_chain, redirect_chain)",
            "            response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "            # Assert Footer items(`self.footer_elements`), Banner and Banner Top is hidden",
            "            for footer_text in self.footer_elements:",
            "                self.assertNotIn(footer_text, response_content)",
            "            # Only API Docs implements BANNERS",
            "            if url == urls[0]:",
            "                self.assertNotIn(\"Hello, Banner Top\", response_content)",
            "                self.assertNotIn(\"Hello, Banner Bottom\", response_content)",
            "",
            "    @override_settings(HIDE_RESTRICTED_UI=False, BANNER_TOP=\"Hello, Banner Top\", BANNER_BOTTOM=\"Hello, Banner Bottom\")",
            "    def test_routes_no_redirect_back_to_login_if_hide_restricted_ui_false(self):",
            "        \"\"\"Assert that api docs and graphql do not redirects to login page if user is unauthenticated and HIDE_RESTRICTED_UI=False.\"\"\"",
            "        self.client.logout()",
            "        headers = {\"HTTP_ACCEPT\": \"text/html\"}",
            "        urls = [reverse(\"api_docs\"), reverse(\"graphql\")]",
            "        for url in urls:",
            "            response = self.client.get(url, **headers)",
            "            self.assertHttpStatus(response, 200)",
            "            self.assertEqual(response.request[\"PATH_INFO\"], url)",
            "            response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "            # Assert Footer items(`self.footer_elements`), Banner and Banner Top is not hidden",
            "            for footer_text in self.footer_elements:",
            "                self.assertInHTML(footer_text, response_content)",
            "",
            "            # Only API Docs implements BANNERS",
            "            if url == urls[0]:",
            "                self.assertInHTML(\"Hello, Banner Top\", response_content)",
            "                self.assertInHTML(\"Hello, Banner Bottom\", response_content)",
            "",
            "",
            "class MetricsViewTestCase(TestCase):",
            "    def query_and_parse_metrics(self):",
            "        response = self.client.get(reverse(\"metrics\"))",
            "        self.assertHttpStatus(response, 200, msg=\"/metrics should return a 200 HTTP status code.\")",
            "        page_content = response.content.decode(response.charset)",
            "        return text_string_to_metric_families(page_content)",
            "",
            "    def test_metrics_extensibility(self):",
            "        \"\"\"Assert that the example metric from the example plugin shows up _exactly_ when the plugin is enabled.\"\"\"",
            "        test_metric_name = \"nautobot_example_metric_count\"",
            "        metrics_with_plugin = self.query_and_parse_metrics()",
            "        metric_names_with_plugin = {metric.name for metric in metrics_with_plugin}",
            "        self.assertIn(test_metric_name, metric_names_with_plugin)",
            "        with override_settings(PLUGINS=[]):",
            "            # Clear out the app metric registry because it is not updated when settings are changed but Nautobot is not",
            "            # restarted.",
            "            registry[\"app_metrics\"].clear()",
            "            metrics_without_plugin = self.query_and_parse_metrics()",
            "            metric_names_without_plugin = {metric.name for metric in metrics_without_plugin}",
            "            self.assertNotIn(test_metric_name, metric_names_without_plugin)",
            "        metric_names_with_plugin.remove(test_metric_name)",
            "        self.assertSetEqual(metric_names_with_plugin, metric_names_without_plugin)",
            "",
            "",
            "class ErrorPagesTestCase(TestCase):",
            "    \"\"\"Tests for 4xx and 5xx error page rendering.\"\"\"",
            "",
            "    @override_settings(DEBUG=False)",
            "    def test_404_default_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a default support message.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel on \"",
            "            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '",
            "            \"Slack community</a> and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    def test_404_custom_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a custom support message if defined.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertNotContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "    @override_settings(DEBUG=False)",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_default_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a default support message.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel on \"",
            "            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '",
            "            \"Slack community</a> and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_custom_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a custom support message if defined.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertNotContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "",
            "class DBFileStorageViewTestCase(TestCase):",
            "    \"\"\"Test authentication/permission enforcement for django_db_file_storage views.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.test_file_1 = SimpleUploadedFile(name=\"test_file_1.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_1 = FileProxy.objects.create(name=self.test_file_1.name, file=self.test_file_1)",
            "        self.test_file_2 = SimpleUploadedFile(name=\"test_file_2.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_2 = FileProxy.objects.create(name=self.test_file_2.name, file=self.test_file_2)",
            "        self.url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_1.file.name}\"",
            "",
            "    def test_get_file_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_file_without_permission(self):",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_object_with_permission(self):",
            "        self.add_permissions(get_permission_for_model(FileProxy, \"view\"))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_get_object_with_constrained_permission(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.file_proxy_1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(FileProxy))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "        url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_2.file.name}\"",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "373": [
                "ErrorPagesTestCase",
                "test_404_default_support_message"
            ],
            "374": [
                "ErrorPagesTestCase",
                "test_404_default_support_message"
            ],
            "375": [
                "ErrorPagesTestCase",
                "test_404_default_support_message"
            ],
            "399": [
                "ErrorPagesTestCase",
                "test_500_default_support_message"
            ],
            "400": [
                "ErrorPagesTestCase",
                "test_500_default_support_message"
            ],
            "401": [
                "ErrorPagesTestCase",
                "test_500_default_support_message"
            ],
            "408": [
                "ErrorPagesTestCase",
                "test_500_custom_support_message"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/forms/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 360,
                "PatchRowcode": " )"
            },
            "1": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 361,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 362,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+class CustomFieldDescriptionField(CommentField):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+    @property"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+    def default_helptext(self):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+        return \"Also used as the help text when editing models using this custom field.<br>\" + super().default_helptext"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 369,
                "PatchRowcode": " class CustomFieldForm(BootstrapMixin, forms.ModelForm):"
            },
            "10": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "     label = forms.CharField(required=True, max_length=50, help_text=\"Name of the field as displayed to users.\")"
            },
            "11": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "     slug = SlugField("
            },
            "12": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "         max_length=50,"
            },
            "13": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         slug_source=\"label\","
            },
            "14": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "         help_text=\"Internal name of this field. Please use underscores rather than dashes.\","
            },
            "15": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "     )"
            },
            "16": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    description = forms.CharField("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+    description = CustomFieldDescriptionField("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+        label=\"Description\","
            },
            "19": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "         required=False,"
            },
            "20": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=\"Also used as the help text when editing models using this custom field.<br>\""
            },
            "21": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        '<a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\">'"
            },
            "22": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"Markdown</a> syntax is supported.\","
            },
            "23": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "     )"
            },
            "24": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "     content_types = MultipleContentTypeField("
            },
            "25": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         feature=\"custom_fields\", help_text=\"The object(s) to which this field applies.\""
            },
            "26": {
                "beforePatchRowNumber": 1083,
                "afterPatchRowNumber": 1087,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 1084,
                "afterPatchRowNumber": 1088,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 1085,
                "afterPatchRowNumber": 1089,
                "PatchRowcode": " class NoteForm(BootstrapMixin, forms.ModelForm):"
            },
            "29": {
                "beforePatchRowNumber": 1086,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    note = CommentField"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1090,
                "PatchRowcode": "+    note = CommentField()"
            },
            "31": {
                "beforePatchRowNumber": 1087,
                "afterPatchRowNumber": 1091,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 1088,
                "afterPatchRowNumber": 1092,
                "PatchRowcode": "     class Meta:"
            },
            "33": {
                "beforePatchRowNumber": 1089,
                "afterPatchRowNumber": 1093,
                "PatchRowcode": "         model = Note"
            }
        },
        "frontPatchFile": [
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.db.models.fields import TextField",
            "from django.forms import ModelMultipleChoiceField, inlineformset_factory",
            "from django.urls.base import reverse",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.dcim.models import DeviceRedundancyGroup, DeviceRole, DeviceType, Location, Platform, Region, Site",
            "from nautobot.tenancy.models import Tenant, TenantGroup",
            "from nautobot.utilities.deprecation import class_deprecated_in_favor_of",
            "from nautobot.utilities.forms import (",
            "    add_blank_choice,",
            "    APISelect,",
            "    APISelectMultiple,",
            "    BootstrapMixin,",
            "    BulkEditForm,",
            "    BulkEditNullBooleanSelect,",
            "    ColorSelect,",
            "    CommentField,",
            "    CSVContentTypeField,",
            "    CSVModelChoiceField,",
            "    CSVModelForm,",
            "    CSVMultipleChoiceField,",
            "    CSVMultipleContentTypeField,",
            "    DateTimePicker,",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    JSONField,",
            "    MultipleContentTypeField,",
            "    SlugField,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    TagFilterField,",
            ")",
            "from nautobot.utilities.forms.constants import BOOLEAN_WITH_BLANK_CHOICES",
            "from nautobot.virtualization.models import Cluster, ClusterGroup",
            "from nautobot.extras.choices import (",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    ObjectChangeActionChoices,",
            "    RelationshipTypeChoices,",
            ")",
            "from nautobot.extras.constants import JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.datasources import get_datasource_content_choices",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomFieldChoice,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.registry import registry",
            "from nautobot.extras.utils import ChangeLoggedModelsQuery, FeatureQuery, TaggableClassesQuery",
            "from .base import (",
            "    NautobotBulkEditForm,",
            "    NautobotFilterForm,",
            "    NautobotModelForm,",
            ")",
            "from .mixins import (",
            "    CustomFieldModelBulkEditFormMixin,",
            "    CustomFieldModelFormMixin,",
            "    NoteModelBulkEditFormMixin,",
            "    NoteModelFormMixin,",
            "    RelationshipModelFormMixin,",
            ")",
            "",
            "",
            "__all__ = (",
            "    \"BaseDynamicGroupMembershipFormSet\",",
            "    \"ComputedFieldForm\",",
            "    \"ComputedFieldFilterForm\",",
            "    \"ConfigContextForm\",",
            "    \"ConfigContextBulkEditForm\",",
            "    \"ConfigContextFilterForm\",",
            "    \"ConfigContextSchemaForm\",",
            "    \"ConfigContextSchemaBulkEditForm\",",
            "    \"ConfigContextSchemaFilterForm\",",
            "    \"CustomFieldForm\",",
            "    \"CustomFieldModelCSVForm\",",
            "    \"CustomFieldBulkCreateForm\",  # 2.0 TODO remove this deprecated class",
            "    \"CustomFieldChoiceFormSet\",",
            "    \"CustomLinkForm\",",
            "    \"CustomLinkFilterForm\",",
            "    \"DynamicGroupForm\",",
            "    \"DynamicGroupFilterForm\",",
            "    \"DynamicGroupMembershipFormSet\",",
            "    \"ExportTemplateForm\",",
            "    \"ExportTemplateFilterForm\",",
            "    \"GitRepositoryForm\",",
            "    \"GitRepositoryCSVForm\",",
            "    \"GitRepositoryBulkEditForm\",",
            "    \"GitRepositoryFilterForm\",",
            "    \"GraphQLQueryForm\",",
            "    \"GraphQLQueryFilterForm\",",
            "    \"ImageAttachmentForm\",",
            "    \"JobForm\",",
            "    \"JobButtonForm\",",
            "    \"JobButtonBulkEditForm\",",
            "    \"JobButtonFilterForm\",",
            "    \"JobEditForm\",",
            "    \"JobFilterForm\",",
            "    \"JobHookForm\",",
            "    \"JobHookFilterForm\",",
            "    \"JobScheduleForm\",",
            "    \"JobResultFilterForm\",",
            "    \"LocalContextFilterForm\",",
            "    \"LocalContextModelForm\",",
            "    \"LocalContextModelBulkEditForm\",",
            "    \"NoteForm\",",
            "    \"ObjectChangeFilterForm\",",
            "    \"PasswordInputWithPlaceholder\",",
            "    \"RelationshipForm\",",
            "    \"RelationshipFilterForm\",",
            "    \"RelationshipAssociationFilterForm\",",
            "    \"ScheduledJobFilterForm\",",
            "    \"SecretForm\",",
            "    \"SecretCSVForm\",",
            "    \"SecretFilterForm\",",
            "    \"SecretsGroupForm\",",
            "    \"SecretsGroupFilterForm\",",
            "    \"SecretsGroupAssociationFormSet\",",
            "    \"StatusForm\",",
            "    \"StatusCSVForm\",",
            "    \"StatusFilterForm\",",
            "    \"StatusBulkEditForm\",",
            "    \"TagForm\",",
            "    \"TagCSVForm\",",
            "    \"TagFilterForm\",",
            "    \"TagBulkEditForm\",",
            "    \"WebhookForm\",",
            "    \"WebhookFilterForm\",",
            ")",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=True,",
            "        label=\"Content Type\",",
            "    )",
            "    slug = SlugField(",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    template = forms.CharField(",
            "        widget=forms.Textarea,",
            "        help_text=(",
            "            \"Jinja2 template code for field value.<br>\"",
            "            \"Use <code>obj</code> to refer to the object to which this computed field is attached.\"",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = ComputedField",
            "        fields = (",
            "            \"content_type\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"template\",",
            "            \"fallback_value\",",
            "            \"weight\",",
            "            \"advanced_ui\",",
            "        )",
            "",
            "",
            "class ComputedFieldFilterForm(BootstrapMixin, forms.Form):",
            "    model = ComputedField",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextForm(BootstrapMixin, NoteModelFormMixin, forms.ModelForm):",
            "    regions = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), required=False)",
            "    sites = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), required=False)",
            "    locations = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), required=False)",
            "    roles = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), required=False)",
            "    device_types = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), required=False)",
            "    platforms = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), required=False)",
            "    cluster_groups = DynamicModelMultipleChoiceField(queryset=ClusterGroup.objects.all(), required=False)",
            "    clusters = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False)",
            "    tenant_groups = DynamicModelMultipleChoiceField(queryset=TenantGroup.objects.all(), required=False)",
            "    tenants = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    device_redundancy_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), required=False",
            "    )",
            "    tags = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    # Conditional enablement of dynamic groups filtering",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "    data = JSONField(label=\"\")",
            "",
            "    class Meta:",
            "        model = ConfigContext",
            "        fields = (",
            "            \"name\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"schema\",",
            "            \"is_active\",",
            "            \"regions\",",
            "            \"sites\",",
            "            \"locations\",",
            "            \"roles\",",
            "            \"device_types\",",
            "            \"platforms\",",
            "            \"cluster_groups\",",
            "            \"clusters\",",
            "            \"tenant_groups\",",
            "            \"tenants\",",
            "            \"device_redundancy_groups\",",
            "            \"tags\",",
            "            \"dynamic_groups\",",
            "            \"data\",",
            "        )",
            "",
            "",
            "class ConfigContextBulkEditForm(BootstrapMixin, NoteModelBulkEditFormMixin, BulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContext.objects.all(), widget=forms.MultipleHiddenInput)",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    weight = forms.IntegerField(required=False, min_value=0)",
            "    is_active = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect())",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "            \"schema\",",
            "        ]",
            "",
            "",
            "class ConfigContextFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False)",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), to_field_name=\"slug\", required=False)",
            "    location = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    role = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), to_field_name=\"slug\", required=False)",
            "    type = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), to_field_name=\"slug\", required=False)",
            "    platform = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), to_field_name=\"slug\", required=False)",
            "    cluster_group = DynamicModelMultipleChoiceField(",
            "        queryset=ClusterGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    cluster_id = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False, label=\"Cluster\")",
            "    tenant_group = DynamicModelMultipleChoiceField(",
            "        queryset=TenantGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), to_field_name=\"slug\", required=False)",
            "    device_redundancy_group = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tag = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), to_field_name=\"slug\", required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaForm(NautobotModelForm):",
            "    data_schema = JSONField(label=\"\")",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = ConfigContextSchema",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"data_schema\",",
            "        )",
            "",
            "",
            "class ConfigContextSchemaBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContextSchema.objects.all(), widget=forms.MultipleHiddenInput)",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class ConfigContextSchemaFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "# CustomFieldChoice inline formset for use with providing dynamic rows when creating/editing choices",
            "# for `CustomField` objects in UI views. Fields/exclude must be set but since we're using all the",
            "# fields we're just setting `exclude=()` here.",
            "CustomFieldChoiceFormSet = inlineformset_factory(",
            "    parent_model=CustomField,",
            "    model=CustomFieldChoice,",
            "    exclude=(),",
            "    extra=5,",
            "    widgets={",
            "        \"value\": forms.TextInput(attrs={\"class\": \"form-control\"}),",
            "        \"weight\": forms.NumberInput(attrs={\"class\": \"form-control\"}),",
            "    },",
            ")",
            "",
            "",
            "class CustomFieldForm(BootstrapMixin, forms.ModelForm):",
            "    label = forms.CharField(required=True, max_length=50, help_text=\"Name of the field as displayed to users.\")",
            "    slug = SlugField(",
            "        max_length=50,",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    description = forms.CharField(",
            "        required=False,",
            "        help_text=\"Also used as the help text when editing models using this custom field.<br>\"",
            "        '<a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\">'",
            "        \"Markdown</a> syntax is supported.\",",
            "    )",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"custom_fields\", help_text=\"The object(s) to which this field applies.\"",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomField",
            "        fields = (",
            "            \"label\",",
            "            \"grouping\",",
            "            \"slug\",",
            "            \"type\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"required\",",
            "            \"default\",",
            "            \"filter_logic\",",
            "            \"advanced_ui\",",
            "            \"content_types\",",
            "            \"validation_minimum\",",
            "            \"validation_maximum\",",
            "            \"validation_regex\",",
            "        )",
            "",
            "",
            "class CustomFieldModelCSVForm(CSVModelForm, CustomFieldModelFormMixin):",
            "    \"\"\"Base class for CSV export of models that support custom fields.\"\"\"",
            "",
            "    def _append_customfield_fields(self):",
            "        # Append form fields",
            "        for cf in CustomField.objects.filter(content_types=self.obj_type):",
            "            field_name = f\"cf_{cf.slug}\"",
            "            self.fields[field_name] = cf.to_form_field(for_csv_import=True)",
            "",
            "            # Annotate the field in the list of CustomField form fields",
            "            self.custom_fields.append(field_name)",
            "",
            "",
            "# 2.0 TODO: remove this class",
            "@class_deprecated_in_favor_of(CustomFieldModelBulkEditFormMixin)",
            "class CustomFieldBulkCreateForm(CustomFieldModelBulkEditFormMixin):",
            "    \"\"\"No longer needed as a separate class - use CustomFieldModelBulkEditFormMixin instead.\"\"\"",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomLink",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"text\",",
            "            \"target_url\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"new_window\",",
            "        )",
            "",
            "",
            "class CustomLinkFilterForm(BootstrapMixin, forms.Form):",
            "    model = CustomLink",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupForm(NautobotModelForm):",
            "    \"\"\"DynamicGroup model form.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"dynamic_groups\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"content_type\",",
            "        ]",
            "",
            "",
            "class DynamicGroupMembershipFormSetForm(forms.ModelForm):",
            "    \"\"\"DynamicGroupMembership model form for use inline on DynamicGroupFormSet.\"\"\"",
            "",
            "    group = DynamicModelChoiceField(",
            "        queryset=DynamicGroup.objects.all(),",
            "        query_params={\"content_type\": \"$content_type\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroupMembership",
            "        fields = (\"operator\", \"group\", \"weight\")",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "# DynamicGroups to a parent DynamicGroup.",
            "BaseDynamicGroupMembershipFormSet = inlineformset_factory(",
            "    parent_model=DynamicGroup,",
            "    model=DynamicGroupMembership,",
            "    form=DynamicGroupMembershipFormSetForm,",
            "    extra=4,",
            "    fk_name=\"parent_group\",",
            "    widgets={",
            "        \"operator\": StaticSelect2,",
            "        \"weight\": forms.HiddenInput(),",
            "    },",
            ")",
            "",
            "",
            "class DynamicGroupMembershipFormSet(BaseDynamicGroupMembershipFormSet):",
            "    \"\"\"",
            "    Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "    groups to a parent DynamicGroup.",
            "    \"\"\"",
            "",
            "",
            "class DynamicGroupFilterForm(BootstrapMixin, forms.Form):",
            "    \"\"\"DynamicGroup filter form.\"\"\"",
            "",
            "    model = DynamicGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = MultipleContentTypeField(feature=\"dynamic_groups\", choices_as_strings=True, label=\"Content Type\")",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = ExportTemplate",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"description\",",
            "            \"template_code\",",
            "            \"mime_type\",",
            "            \"file_extension\",",
            "        )",
            "",
            "",
            "class ExportTemplateFilterForm(BootstrapMixin, forms.Form):",
            "    model = ExportTemplate",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Git repositories and other data sources",
            "#",
            "",
            "",
            "def get_git_datasource_content_choices():",
            "    return get_datasource_content_choices(\"extras.gitrepository\")",
            "",
            "",
            "class PasswordInputWithPlaceholder(forms.PasswordInput):",
            "    \"\"\"PasswordInput that is populated with a placeholder value if any existing value is present.\"\"\"",
            "",
            "    def __init__(self, attrs=None, placeholder=\"\", render_value=False):",
            "        if placeholder:",
            "            render_value = True",
            "        self._placeholder = placeholder",
            "        super().__init__(attrs=attrs, render_value=render_value)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        if value:",
            "            value = self._placeholder",
            "        return super().get_context(name, value, attrs)",
            "",
            "",
            "class GitRepositoryForm(BootstrapMixin, RelationshipModelFormMixin):",
            "    slug = SlugField(help_text=\"Filesystem-friendly unique shorthand\")",
            "",
            "    remote_url = forms.URLField(",
            "        required=True,",
            "        label=\"Remote URL\",",
            "        help_text=\"Only http:// and https:// URLs are presently supported\",",
            "    )",
            "",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"Username for token authentication.<br><em>Deprecated</em> - use a secrets group instead\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    provided_contents = forms.MultipleChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=get_git_datasource_content_choices,",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"username\",",
            "            \"_token\",",
            "            \"secrets_group\",",
            "            \"provided_contents\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # set dryrun after a successful clean",
            "        if \"_dryrun_create\" in self.data or \"_dryrun_update\" in self.data:",
            "            self.instance.set_dryrun()",
            "",
            "",
            "class GitRepositoryCSVForm(CSVModelForm):",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Secrets group for repository access (if any)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = GitRepository.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.fields[\"provided_contents\"] = CSVMultipleChoiceField(",
            "            choices=get_git_datasource_content_choices(),",
            "            required=False,",
            "            help_text=mark_safe(  # noqa: S308",
            "                \"The data types this repository provides. Multiple values must be comma-separated and wrapped in \"",
            "                'double quotes (e.g. <code>\"extras.job,extras.configcontext\"</code>).'",
            "            ),",
            "        )",
            "",
            "",
            "class GitRepositoryBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=GitRepository.objects.all(),",
            "        widget=forms.MultipleHiddenInput(),",
            "    )",
            "    remote_url = forms.CharField(",
            "        label=\"Remote URL\",",
            "        required=False,",
            "    )",
            "    branch = forms.CharField(",
            "        required=False,",
            "    )",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        nullable_fields = [\"secrets_group\"]",
            "",
            "",
            "class GitRepositoryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GitRepository",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    branch = forms.CharField(required=False)",
            "    provided_contents = forms.ChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=add_blank_choice(get_git_datasource_content_choices()),",
            "    )",
            "",
            "",
            "#",
            "# GraphQL saved queries",
            "#",
            "",
            "",
            "class GraphQLQueryForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField()",
            "    query = TextField()",
            "",
            "    class Meta:",
            "        model = GraphQLQuery",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"query\",",
            "        )",
            "",
            "    def get_action_url(self):",
            "        return reverse(\"extras:graphqlquery_add\")",
            "",
            "",
            "class GraphQLQueryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GraphQLQuery",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentForm(BootstrapMixin, forms.ModelForm):",
            "    class Meta:",
            "        model = ImageAttachment",
            "        fields = [",
            "            \"name\",",
            "            \"image\",",
            "        ]",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is used to render the user input fields for a Job class. Its fields are dynamically",
            "    controlled by the job definition. See `nautobot.extras.jobs.BaseJob.as_form`",
            "    \"\"\"",
            "",
            "    _commit = forms.BooleanField(",
            "        required=False,",
            "        initial=True,",
            "        label=\"Commit changes\",",
            "        help_text=\"Commit changes to the database (uncheck for a dry-run)\",",
            "    )",
            "    _profile = forms.BooleanField(",
            "        required=False,",
            "        initial=False,",
            "        label=\"Profile job execution\",",
            "        help_text=\"Profiles the job execution using cProfile and outputs a report to /tmp/\",",
            "    )",
            "    _task_queue = forms.ChoiceField(",
            "        required=False,",
            "        help_text=\"The task queue to route this job to\",",
            "        label=\"Task queue\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Move special fields to the end of the form",
            "        for field in [\"_task_queue\", \"_commit\", \"_profile\"]:",
            "            value = self.fields.pop(field)",
            "            self.fields[field] = value",
            "",
            "    @property",
            "    def requires_input(self):",
            "        \"\"\"",
            "        A boolean indicating whether the form requires user input (ignore the _commit field).",
            "        \"\"\"",
            "        return bool(len(self.fields) > 1)",
            "",
            "",
            "class JobEditForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Job",
            "        fields = [",
            "            \"slug\",",
            "            \"enabled\",",
            "            \"name_override\",",
            "            \"name\",",
            "            \"grouping_override\",",
            "            \"grouping\",",
            "            \"description_override\",",
            "            \"description\",",
            "            \"commit_default_override\",",
            "            \"commit_default\",",
            "            \"hidden_override\",",
            "            \"hidden\",",
            "            \"read_only_override\",",
            "            \"read_only\",",
            "            \"approval_required_override\",",
            "            \"approval_required\",",
            "            \"soft_time_limit_override\",",
            "            \"soft_time_limit\",",
            "            \"time_limit_override\",",
            "            \"time_limit\",",
            "            \"has_sensitive_variables_override\",",
            "            \"has_sensitive_variables\",",
            "            \"task_queues_override\",",
            "            \"task_queues\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        For all overridable fields, if they aren't marked as overridden, revert them to the underlying value if known.",
            "        \"\"\"",
            "        cleaned_data = super().clean() or self.cleaned_data",
            "        job_class = self.instance.job_class",
            "        if job_class is not None:",
            "            for field_name in JOB_OVERRIDABLE_FIELDS:",
            "                if not cleaned_data.get(f\"{field_name}_override\", False):",
            "                    cleaned_data[field_name] = getattr(job_class, field_name)",
            "        return cleaned_data",
            "",
            "",
            "class JobFilterForm(BootstrapMixin, forms.Form):",
            "    model = Job",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    installed = forms.NullBooleanField(",
            "        initial=True,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    has_sensitive_variables = forms.NullBooleanField(",
            "        required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES)",
            "    )",
            "    commit_default = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    hidden = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    read_only = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    approval_required = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    is_job_hook_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    is_job_button_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class JobHookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(), required=True, label=\"Content Type(s)\"",
            "    )",
            "",
            "    class Meta:",
            "        model = JobHook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = JobHook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            job=self.cleaned_data.get(\"job\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class JobHookFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobHook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(),",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    job = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "",
            "",
            "class JobScheduleForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is rendered alongside the JobForm but deals specifically with the fields needed to either",
            "    execute the job immediately, or schedule it for later. Each field name is prefixed with an underscore",
            "    because in the POST body, they share a namespace with the JobForm which includes fields defined by the",
            "    job author, so the underscore prefix helps to avoid name collisions.",
            "    \"\"\"",
            "",
            "    _schedule_type = forms.ChoiceField(",
            "        choices=JobExecutionType,",
            "        help_text=\"The job can either run immediately, once in the future, or on a recurring schedule.\",",
            "        label=\"Type\",",
            "    )",
            "    _schedule_name = forms.CharField(",
            "        required=False,",
            "        label=\"Schedule name\",",
            "        help_text=\"Name for the job schedule.\",",
            "    )",
            "    _schedule_start_time = forms.DateTimeField(",
            "        required=False,",
            "        label=\"Starting date and time\",",
            "        widget=DateTimePicker(),",
            "        help_text=f\"The scheduled time is relative to the Nautobot configured timezone: {settings.TIME_ZONE}.\",",
            "    )",
            "    _recurrence_custom_time = forms.CharField(",
            "        required=False,",
            "        label=\"Crontab\",",
            "        help_text=\"Custom crontab syntax (* * * * *)\",",
            "    )",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Validate all required information is present if the job needs to be scheduled",
            "        \"\"\"",
            "        cleaned_data = super().clean()",
            "",
            "        if \"_schedule_type\" in cleaned_data and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY:",
            "            if not cleaned_data.get(\"_schedule_name\"):",
            "                raise ValidationError({\"_schedule_name\": \"Please provide a name for the job schedule.\"})",
            "",
            "            if (",
            "                not cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_CUSTOM",
            "            ) or (",
            "                cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_start_time\") < ScheduledJob.earliest_possible_time()",
            "            ):",
            "                raise ValidationError(",
            "                    {",
            "                        \"_schedule_start_time\": \"Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                    }",
            "                )",
            "",
            "            if cleaned_data.get(\"_schedule_type\") == JobExecutionType.TYPE_CUSTOM:",
            "                try:",
            "                    ScheduledJob.get_crontab(cleaned_data.get(\"_recurrence_custom_time\"))",
            "                except Exception as e:",
            "                    raise ValidationError({\"_recurrence_custom_time\": e})",
            "",
            "",
            "class JobResultFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobResult",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    # 2.0 TODO(glenn) filtering by obj_type should be solved by dynamic filter form generation",
            "    name = forms.CharField(required=False)",
            "    user = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    status = forms.MultipleChoiceField(",
            "        choices=JobResultStatusChoices,",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "",
            "",
            "class ScheduledJobFilterForm(BootstrapMixin, forms.Form):",
            "    model = ScheduledJob",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/job-models/\"),",
            "    )",
            "    total_run_count = forms.IntegerField(required=False)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = JobButton",
            "        fields = (",
            "            \"content_types\",",
            "            \"name\",",
            "            \"text\",",
            "            \"job\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"confirmation\",",
            "        )",
            "",
            "",
            "class JobButtonBulkEditForm(BootstrapMixin, BulkEditForm):",
            "    \"\"\"Bulk edit form for `JobButton` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=JobButton.objects.all(), widget=forms.MultipleHiddenInput)",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "        required=False,",
            "    )",
            "    weight = forms.IntegerField(required=False)",
            "    group_name = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"group_name\"]",
            "",
            "",
            "class JobButtonFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobButton",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Types\",",
            "    )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteForm(BootstrapMixin, forms.ModelForm):",
            "    note = CommentField",
            "",
            "    class Meta:",
            "        model = Note",
            "        fields = [\"assigned_object_type\", \"assigned_object_id\", \"note\"]",
            "        widgets = {",
            "            \"assigned_object_type\": forms.HiddenInput,",
            "            \"assigned_object_id\": forms.HiddenInput,",
            "        }",
            "",
            "",
            "#",
            "# Filter form for local config context data",
            "#",
            "",
            "",
            "class LocalContextFilterForm(forms.Form):",
            "    local_context_data = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has local config context data\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    local_context_schema = DynamicModelMultipleChoiceField(",
            "        queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "",
            "#",
            "# Model form for local config context data",
            "#",
            "",
            "",
            "class LocalContextModelForm(forms.ModelForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    local_context_data = JSONField(required=False, label=\"\")",
            "",
            "",
            "class LocalContextModelBulkEditForm(BulkEditForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # append nullable fields",
            "        self.nullable_fields.append(\"local_context_schema\")",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeFilterForm(BootstrapMixin, forms.Form):",
            "    model = ObjectChange",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    time__gte = forms.DateTimeField(label=\"After\", required=False, widget=DateTimePicker())",
            "    time__lte = forms.DateTimeField(label=\"Before\", required=False, widget=DateTimePicker())",
            "    action = forms.ChoiceField(",
            "        choices=add_blank_choice(ObjectChangeActionChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    user_id = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    changed_object_type_id = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Type\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField(help_text=\"Internal name of this relationship. Please use underscores rather than dashes.\")",
            "    source_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The source object type to which this relationship applies.\",",
            "    )",
            "    source_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable source objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "    destination_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The destination object type to which this relationship applies.\",",
            "    )",
            "    destination_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable destination objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "",
            "    class Meta:",
            "        model = Relationship",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"type\",",
            "            \"required_on\",",
            "            \"advanced_ui\",",
            "            \"source_type\",",
            "            \"source_label\",",
            "            \"source_hidden\",",
            "            \"source_filter\",",
            "            \"destination_type\",",
            "            \"destination_label\",",
            "            \"destination_hidden\",",
            "            \"destination_filter\",",
            "        ]",
            "",
            "    def save(self, commit=True):",
            "        # TODO add support for owner when a CR is created in the UI",
            "        obj = super().save(commit)",
            "",
            "        return obj",
            "",
            "",
            "class RelationshipFilterForm(BootstrapMixin, forms.Form):",
            "    model = Relationship",
            "",
            "    type = forms.MultipleChoiceField(choices=RelationshipTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "class RelationshipAssociationFilterForm(BootstrapMixin, forms.Form):",
            "    model = RelationshipAssociation",
            "",
            "    relationship = DynamicModelMultipleChoiceField(",
            "        queryset=Relationship.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "    )",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "def provider_choices():",
            "    return sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()])",
            "",
            "",
            "class SecretForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `Secret` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    provider = forms.ChoiceField(choices=provider_choices, widget=StaticSelect2())",
            "",
            "    parameters = JSONField(help_text='Enter parameters in <a href=\"https://json.org/\">JSON</a> format.')",
            "",
            "    class Meta:",
            "        model = Secret",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"provider\",",
            "            \"parameters\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class SecretCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = Secret",
            "        fields = Secret.csv_headers",
            "",
            "",
            "def provider_choices_with_blank():",
            "    return add_blank_choice(sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()]))",
            "",
            "",
            "class SecretFilterForm(NautobotFilterForm):",
            "    model = Secret",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    provider = forms.MultipleChoiceField(",
            "        choices=provider_choices_with_blank, widget=StaticSelect2Multiple(), required=False",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing assignments of Secrets to SecretsGroups.",
            "SecretsGroupAssociationFormSet = inlineformset_factory(",
            "    parent_model=SecretsGroup,",
            "    model=SecretsGroupAssociation,",
            "    fields=(\"access_type\", \"secret_type\", \"secret\"),",
            "    extra=5,",
            "    widgets={",
            "        \"access_type\": StaticSelect2,",
            "        \"secret_type\": StaticSelect2,",
            "        \"secret\": APISelect(api_url=\"/api/extras/secrets/\"),",
            "    },",
            ")",
            "",
            "",
            "class SecretsGroupForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `SecretsGroup` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = SecretsGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class SecretsGroupFilterForm(NautobotFilterForm):",
            "    model = SecretsGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusForm(NautobotModelForm):",
            "    \"\"\"Generic create/update form for `Status` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Status",
            "        widgets = {\"color\": ColorSelect()}",
            "        fields = [\"name\", \"slug\", \"description\", \"content_types\", \"color\"]",
            "",
            "",
            "class StatusCSVForm(CustomFieldModelCSVForm):",
            "    \"\"\"Generic CSV bulk import form for `Status` objects.\"\"\"",
            "",
            "    content_types = CSVMultipleContentTypeField(",
            "        feature=\"statuses\",",
            "        choices_as_strings=True,",
            "        help_text=mark_safe(  # noqa: S308",
            "            \"The object types to which this status applies. Multiple values \"",
            "            \"must be comma-separated and wrapped in double quotes. (e.g. \"",
            "            '<code>\"dcim.device,dcim.rack\"</code>)'",
            "        ),",
            "        label=\"Content type(s)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Status",
            "        fields = Status.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "class StatusFilterForm(NautobotFilterForm):",
            "    \"\"\"Filtering/search form for `Status` objects.\"\"\"",
            "",
            "    model = Status",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"statuses\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "",
            "",
            "class StatusBulkEditForm(NautobotBulkEditForm):",
            "    \"\"\"Bulk edit/delete form for `Status` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=Status.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagForm(NautobotModelForm):",
            "    slug = SlugField()",
            "    content_types = ModelMultipleChoiceField(",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = [\"name\", \"slug\", \"color\", \"description\", \"content_types\"]",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        if self.instance.present_in_database:",
            "            # check if tag is assigned to any of the removed content_types",
            "            content_types_id = [content_type.id for content_type in self.cleaned_data[\"content_types\"]]",
            "            errors = self.instance.validate_content_types_removal(content_types_id)",
            "",
            "            if errors:",
            "                raise ValidationError(errors)",
            "",
            "        return data",
            "",
            "",
            "class TagCSVForm(CustomFieldModelCSVForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = Tag.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "class TagFilterForm(NautobotFilterForm):",
            "    model = Tag",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "",
            "class TagBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Tag.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    description = forms.CharField(max_length=200, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(feature=\"webhooks\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Webhook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "            \"payload_url\",",
            "            \"http_method\",",
            "            \"http_content_type\",",
            "            \"additional_headers\",",
            "            \"body_template\",",
            "            \"secret\",",
            "            \"ssl_verification\",",
            "            \"ca_file_path\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = Webhook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            payload_url=self.cleaned_data.get(\"payload_url\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class WebhookFilterForm(BootstrapMixin, forms.Form):",
            "    model = Webhook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"webhooks\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))"
        ],
        "afterPatchFile": [
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.db.models.fields import TextField",
            "from django.forms import ModelMultipleChoiceField, inlineformset_factory",
            "from django.urls.base import reverse",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.dcim.models import DeviceRedundancyGroup, DeviceRole, DeviceType, Location, Platform, Region, Site",
            "from nautobot.tenancy.models import Tenant, TenantGroup",
            "from nautobot.utilities.deprecation import class_deprecated_in_favor_of",
            "from nautobot.utilities.forms import (",
            "    add_blank_choice,",
            "    APISelect,",
            "    APISelectMultiple,",
            "    BootstrapMixin,",
            "    BulkEditForm,",
            "    BulkEditNullBooleanSelect,",
            "    ColorSelect,",
            "    CommentField,",
            "    CSVContentTypeField,",
            "    CSVModelChoiceField,",
            "    CSVModelForm,",
            "    CSVMultipleChoiceField,",
            "    CSVMultipleContentTypeField,",
            "    DateTimePicker,",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    JSONField,",
            "    MultipleContentTypeField,",
            "    SlugField,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    TagFilterField,",
            ")",
            "from nautobot.utilities.forms.constants import BOOLEAN_WITH_BLANK_CHOICES",
            "from nautobot.virtualization.models import Cluster, ClusterGroup",
            "from nautobot.extras.choices import (",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    ObjectChangeActionChoices,",
            "    RelationshipTypeChoices,",
            ")",
            "from nautobot.extras.constants import JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.datasources import get_datasource_content_choices",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomFieldChoice,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.registry import registry",
            "from nautobot.extras.utils import ChangeLoggedModelsQuery, FeatureQuery, TaggableClassesQuery",
            "from .base import (",
            "    NautobotBulkEditForm,",
            "    NautobotFilterForm,",
            "    NautobotModelForm,",
            ")",
            "from .mixins import (",
            "    CustomFieldModelBulkEditFormMixin,",
            "    CustomFieldModelFormMixin,",
            "    NoteModelBulkEditFormMixin,",
            "    NoteModelFormMixin,",
            "    RelationshipModelFormMixin,",
            ")",
            "",
            "",
            "__all__ = (",
            "    \"BaseDynamicGroupMembershipFormSet\",",
            "    \"ComputedFieldForm\",",
            "    \"ComputedFieldFilterForm\",",
            "    \"ConfigContextForm\",",
            "    \"ConfigContextBulkEditForm\",",
            "    \"ConfigContextFilterForm\",",
            "    \"ConfigContextSchemaForm\",",
            "    \"ConfigContextSchemaBulkEditForm\",",
            "    \"ConfigContextSchemaFilterForm\",",
            "    \"CustomFieldForm\",",
            "    \"CustomFieldModelCSVForm\",",
            "    \"CustomFieldBulkCreateForm\",  # 2.0 TODO remove this deprecated class",
            "    \"CustomFieldChoiceFormSet\",",
            "    \"CustomLinkForm\",",
            "    \"CustomLinkFilterForm\",",
            "    \"DynamicGroupForm\",",
            "    \"DynamicGroupFilterForm\",",
            "    \"DynamicGroupMembershipFormSet\",",
            "    \"ExportTemplateForm\",",
            "    \"ExportTemplateFilterForm\",",
            "    \"GitRepositoryForm\",",
            "    \"GitRepositoryCSVForm\",",
            "    \"GitRepositoryBulkEditForm\",",
            "    \"GitRepositoryFilterForm\",",
            "    \"GraphQLQueryForm\",",
            "    \"GraphQLQueryFilterForm\",",
            "    \"ImageAttachmentForm\",",
            "    \"JobForm\",",
            "    \"JobButtonForm\",",
            "    \"JobButtonBulkEditForm\",",
            "    \"JobButtonFilterForm\",",
            "    \"JobEditForm\",",
            "    \"JobFilterForm\",",
            "    \"JobHookForm\",",
            "    \"JobHookFilterForm\",",
            "    \"JobScheduleForm\",",
            "    \"JobResultFilterForm\",",
            "    \"LocalContextFilterForm\",",
            "    \"LocalContextModelForm\",",
            "    \"LocalContextModelBulkEditForm\",",
            "    \"NoteForm\",",
            "    \"ObjectChangeFilterForm\",",
            "    \"PasswordInputWithPlaceholder\",",
            "    \"RelationshipForm\",",
            "    \"RelationshipFilterForm\",",
            "    \"RelationshipAssociationFilterForm\",",
            "    \"ScheduledJobFilterForm\",",
            "    \"SecretForm\",",
            "    \"SecretCSVForm\",",
            "    \"SecretFilterForm\",",
            "    \"SecretsGroupForm\",",
            "    \"SecretsGroupFilterForm\",",
            "    \"SecretsGroupAssociationFormSet\",",
            "    \"StatusForm\",",
            "    \"StatusCSVForm\",",
            "    \"StatusFilterForm\",",
            "    \"StatusBulkEditForm\",",
            "    \"TagForm\",",
            "    \"TagCSVForm\",",
            "    \"TagFilterForm\",",
            "    \"TagBulkEditForm\",",
            "    \"WebhookForm\",",
            "    \"WebhookFilterForm\",",
            ")",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=True,",
            "        label=\"Content Type\",",
            "    )",
            "    slug = SlugField(",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    template = forms.CharField(",
            "        widget=forms.Textarea,",
            "        help_text=(",
            "            \"Jinja2 template code for field value.<br>\"",
            "            \"Use <code>obj</code> to refer to the object to which this computed field is attached.\"",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = ComputedField",
            "        fields = (",
            "            \"content_type\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"template\",",
            "            \"fallback_value\",",
            "            \"weight\",",
            "            \"advanced_ui\",",
            "        )",
            "",
            "",
            "class ComputedFieldFilterForm(BootstrapMixin, forms.Form):",
            "    model = ComputedField",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextForm(BootstrapMixin, NoteModelFormMixin, forms.ModelForm):",
            "    regions = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), required=False)",
            "    sites = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), required=False)",
            "    locations = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), required=False)",
            "    roles = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), required=False)",
            "    device_types = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), required=False)",
            "    platforms = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), required=False)",
            "    cluster_groups = DynamicModelMultipleChoiceField(queryset=ClusterGroup.objects.all(), required=False)",
            "    clusters = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False)",
            "    tenant_groups = DynamicModelMultipleChoiceField(queryset=TenantGroup.objects.all(), required=False)",
            "    tenants = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    device_redundancy_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), required=False",
            "    )",
            "    tags = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    # Conditional enablement of dynamic groups filtering",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "    data = JSONField(label=\"\")",
            "",
            "    class Meta:",
            "        model = ConfigContext",
            "        fields = (",
            "            \"name\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"schema\",",
            "            \"is_active\",",
            "            \"regions\",",
            "            \"sites\",",
            "            \"locations\",",
            "            \"roles\",",
            "            \"device_types\",",
            "            \"platforms\",",
            "            \"cluster_groups\",",
            "            \"clusters\",",
            "            \"tenant_groups\",",
            "            \"tenants\",",
            "            \"device_redundancy_groups\",",
            "            \"tags\",",
            "            \"dynamic_groups\",",
            "            \"data\",",
            "        )",
            "",
            "",
            "class ConfigContextBulkEditForm(BootstrapMixin, NoteModelBulkEditFormMixin, BulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContext.objects.all(), widget=forms.MultipleHiddenInput)",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    weight = forms.IntegerField(required=False, min_value=0)",
            "    is_active = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect())",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "            \"schema\",",
            "        ]",
            "",
            "",
            "class ConfigContextFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False)",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), to_field_name=\"slug\", required=False)",
            "    location = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    role = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), to_field_name=\"slug\", required=False)",
            "    type = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), to_field_name=\"slug\", required=False)",
            "    platform = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), to_field_name=\"slug\", required=False)",
            "    cluster_group = DynamicModelMultipleChoiceField(",
            "        queryset=ClusterGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    cluster_id = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False, label=\"Cluster\")",
            "    tenant_group = DynamicModelMultipleChoiceField(",
            "        queryset=TenantGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), to_field_name=\"slug\", required=False)",
            "    device_redundancy_group = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tag = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), to_field_name=\"slug\", required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaForm(NautobotModelForm):",
            "    data_schema = JSONField(label=\"\")",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = ConfigContextSchema",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"data_schema\",",
            "        )",
            "",
            "",
            "class ConfigContextSchemaBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContextSchema.objects.all(), widget=forms.MultipleHiddenInput)",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class ConfigContextSchemaFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "# CustomFieldChoice inline formset for use with providing dynamic rows when creating/editing choices",
            "# for `CustomField` objects in UI views. Fields/exclude must be set but since we're using all the",
            "# fields we're just setting `exclude=()` here.",
            "CustomFieldChoiceFormSet = inlineformset_factory(",
            "    parent_model=CustomField,",
            "    model=CustomFieldChoice,",
            "    exclude=(),",
            "    extra=5,",
            "    widgets={",
            "        \"value\": forms.TextInput(attrs={\"class\": \"form-control\"}),",
            "        \"weight\": forms.NumberInput(attrs={\"class\": \"form-control\"}),",
            "    },",
            ")",
            "",
            "",
            "class CustomFieldDescriptionField(CommentField):",
            "    @property",
            "    def default_helptext(self):",
            "        return \"Also used as the help text when editing models using this custom field.<br>\" + super().default_helptext",
            "",
            "",
            "class CustomFieldForm(BootstrapMixin, forms.ModelForm):",
            "    label = forms.CharField(required=True, max_length=50, help_text=\"Name of the field as displayed to users.\")",
            "    slug = SlugField(",
            "        max_length=50,",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    description = CustomFieldDescriptionField(",
            "        label=\"Description\",",
            "        required=False,",
            "    )",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"custom_fields\", help_text=\"The object(s) to which this field applies.\"",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomField",
            "        fields = (",
            "            \"label\",",
            "            \"grouping\",",
            "            \"slug\",",
            "            \"type\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"required\",",
            "            \"default\",",
            "            \"filter_logic\",",
            "            \"advanced_ui\",",
            "            \"content_types\",",
            "            \"validation_minimum\",",
            "            \"validation_maximum\",",
            "            \"validation_regex\",",
            "        )",
            "",
            "",
            "class CustomFieldModelCSVForm(CSVModelForm, CustomFieldModelFormMixin):",
            "    \"\"\"Base class for CSV export of models that support custom fields.\"\"\"",
            "",
            "    def _append_customfield_fields(self):",
            "        # Append form fields",
            "        for cf in CustomField.objects.filter(content_types=self.obj_type):",
            "            field_name = f\"cf_{cf.slug}\"",
            "            self.fields[field_name] = cf.to_form_field(for_csv_import=True)",
            "",
            "            # Annotate the field in the list of CustomField form fields",
            "            self.custom_fields.append(field_name)",
            "",
            "",
            "# 2.0 TODO: remove this class",
            "@class_deprecated_in_favor_of(CustomFieldModelBulkEditFormMixin)",
            "class CustomFieldBulkCreateForm(CustomFieldModelBulkEditFormMixin):",
            "    \"\"\"No longer needed as a separate class - use CustomFieldModelBulkEditFormMixin instead.\"\"\"",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomLink",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"text\",",
            "            \"target_url\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"new_window\",",
            "        )",
            "",
            "",
            "class CustomLinkFilterForm(BootstrapMixin, forms.Form):",
            "    model = CustomLink",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupForm(NautobotModelForm):",
            "    \"\"\"DynamicGroup model form.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"dynamic_groups\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"content_type\",",
            "        ]",
            "",
            "",
            "class DynamicGroupMembershipFormSetForm(forms.ModelForm):",
            "    \"\"\"DynamicGroupMembership model form for use inline on DynamicGroupFormSet.\"\"\"",
            "",
            "    group = DynamicModelChoiceField(",
            "        queryset=DynamicGroup.objects.all(),",
            "        query_params={\"content_type\": \"$content_type\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroupMembership",
            "        fields = (\"operator\", \"group\", \"weight\")",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "# DynamicGroups to a parent DynamicGroup.",
            "BaseDynamicGroupMembershipFormSet = inlineformset_factory(",
            "    parent_model=DynamicGroup,",
            "    model=DynamicGroupMembership,",
            "    form=DynamicGroupMembershipFormSetForm,",
            "    extra=4,",
            "    fk_name=\"parent_group\",",
            "    widgets={",
            "        \"operator\": StaticSelect2,",
            "        \"weight\": forms.HiddenInput(),",
            "    },",
            ")",
            "",
            "",
            "class DynamicGroupMembershipFormSet(BaseDynamicGroupMembershipFormSet):",
            "    \"\"\"",
            "    Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "    groups to a parent DynamicGroup.",
            "    \"\"\"",
            "",
            "",
            "class DynamicGroupFilterForm(BootstrapMixin, forms.Form):",
            "    \"\"\"DynamicGroup filter form.\"\"\"",
            "",
            "    model = DynamicGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = MultipleContentTypeField(feature=\"dynamic_groups\", choices_as_strings=True, label=\"Content Type\")",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = ExportTemplate",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"description\",",
            "            \"template_code\",",
            "            \"mime_type\",",
            "            \"file_extension\",",
            "        )",
            "",
            "",
            "class ExportTemplateFilterForm(BootstrapMixin, forms.Form):",
            "    model = ExportTemplate",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Git repositories and other data sources",
            "#",
            "",
            "",
            "def get_git_datasource_content_choices():",
            "    return get_datasource_content_choices(\"extras.gitrepository\")",
            "",
            "",
            "class PasswordInputWithPlaceholder(forms.PasswordInput):",
            "    \"\"\"PasswordInput that is populated with a placeholder value if any existing value is present.\"\"\"",
            "",
            "    def __init__(self, attrs=None, placeholder=\"\", render_value=False):",
            "        if placeholder:",
            "            render_value = True",
            "        self._placeholder = placeholder",
            "        super().__init__(attrs=attrs, render_value=render_value)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        if value:",
            "            value = self._placeholder",
            "        return super().get_context(name, value, attrs)",
            "",
            "",
            "class GitRepositoryForm(BootstrapMixin, RelationshipModelFormMixin):",
            "    slug = SlugField(help_text=\"Filesystem-friendly unique shorthand\")",
            "",
            "    remote_url = forms.URLField(",
            "        required=True,",
            "        label=\"Remote URL\",",
            "        help_text=\"Only http:// and https:// URLs are presently supported\",",
            "    )",
            "",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"Username for token authentication.<br><em>Deprecated</em> - use a secrets group instead\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    provided_contents = forms.MultipleChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=get_git_datasource_content_choices,",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"username\",",
            "            \"_token\",",
            "            \"secrets_group\",",
            "            \"provided_contents\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # set dryrun after a successful clean",
            "        if \"_dryrun_create\" in self.data or \"_dryrun_update\" in self.data:",
            "            self.instance.set_dryrun()",
            "",
            "",
            "class GitRepositoryCSVForm(CSVModelForm):",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Secrets group for repository access (if any)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = GitRepository.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.fields[\"provided_contents\"] = CSVMultipleChoiceField(",
            "            choices=get_git_datasource_content_choices(),",
            "            required=False,",
            "            help_text=mark_safe(  # noqa: S308",
            "                \"The data types this repository provides. Multiple values must be comma-separated and wrapped in \"",
            "                'double quotes (e.g. <code>\"extras.job,extras.configcontext\"</code>).'",
            "            ),",
            "        )",
            "",
            "",
            "class GitRepositoryBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=GitRepository.objects.all(),",
            "        widget=forms.MultipleHiddenInput(),",
            "    )",
            "    remote_url = forms.CharField(",
            "        label=\"Remote URL\",",
            "        required=False,",
            "    )",
            "    branch = forms.CharField(",
            "        required=False,",
            "    )",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        nullable_fields = [\"secrets_group\"]",
            "",
            "",
            "class GitRepositoryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GitRepository",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    branch = forms.CharField(required=False)",
            "    provided_contents = forms.ChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=add_blank_choice(get_git_datasource_content_choices()),",
            "    )",
            "",
            "",
            "#",
            "# GraphQL saved queries",
            "#",
            "",
            "",
            "class GraphQLQueryForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField()",
            "    query = TextField()",
            "",
            "    class Meta:",
            "        model = GraphQLQuery",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"query\",",
            "        )",
            "",
            "    def get_action_url(self):",
            "        return reverse(\"extras:graphqlquery_add\")",
            "",
            "",
            "class GraphQLQueryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GraphQLQuery",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentForm(BootstrapMixin, forms.ModelForm):",
            "    class Meta:",
            "        model = ImageAttachment",
            "        fields = [",
            "            \"name\",",
            "            \"image\",",
            "        ]",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is used to render the user input fields for a Job class. Its fields are dynamically",
            "    controlled by the job definition. See `nautobot.extras.jobs.BaseJob.as_form`",
            "    \"\"\"",
            "",
            "    _commit = forms.BooleanField(",
            "        required=False,",
            "        initial=True,",
            "        label=\"Commit changes\",",
            "        help_text=\"Commit changes to the database (uncheck for a dry-run)\",",
            "    )",
            "    _profile = forms.BooleanField(",
            "        required=False,",
            "        initial=False,",
            "        label=\"Profile job execution\",",
            "        help_text=\"Profiles the job execution using cProfile and outputs a report to /tmp/\",",
            "    )",
            "    _task_queue = forms.ChoiceField(",
            "        required=False,",
            "        help_text=\"The task queue to route this job to\",",
            "        label=\"Task queue\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Move special fields to the end of the form",
            "        for field in [\"_task_queue\", \"_commit\", \"_profile\"]:",
            "            value = self.fields.pop(field)",
            "            self.fields[field] = value",
            "",
            "    @property",
            "    def requires_input(self):",
            "        \"\"\"",
            "        A boolean indicating whether the form requires user input (ignore the _commit field).",
            "        \"\"\"",
            "        return bool(len(self.fields) > 1)",
            "",
            "",
            "class JobEditForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Job",
            "        fields = [",
            "            \"slug\",",
            "            \"enabled\",",
            "            \"name_override\",",
            "            \"name\",",
            "            \"grouping_override\",",
            "            \"grouping\",",
            "            \"description_override\",",
            "            \"description\",",
            "            \"commit_default_override\",",
            "            \"commit_default\",",
            "            \"hidden_override\",",
            "            \"hidden\",",
            "            \"read_only_override\",",
            "            \"read_only\",",
            "            \"approval_required_override\",",
            "            \"approval_required\",",
            "            \"soft_time_limit_override\",",
            "            \"soft_time_limit\",",
            "            \"time_limit_override\",",
            "            \"time_limit\",",
            "            \"has_sensitive_variables_override\",",
            "            \"has_sensitive_variables\",",
            "            \"task_queues_override\",",
            "            \"task_queues\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        For all overridable fields, if they aren't marked as overridden, revert them to the underlying value if known.",
            "        \"\"\"",
            "        cleaned_data = super().clean() or self.cleaned_data",
            "        job_class = self.instance.job_class",
            "        if job_class is not None:",
            "            for field_name in JOB_OVERRIDABLE_FIELDS:",
            "                if not cleaned_data.get(f\"{field_name}_override\", False):",
            "                    cleaned_data[field_name] = getattr(job_class, field_name)",
            "        return cleaned_data",
            "",
            "",
            "class JobFilterForm(BootstrapMixin, forms.Form):",
            "    model = Job",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    installed = forms.NullBooleanField(",
            "        initial=True,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    has_sensitive_variables = forms.NullBooleanField(",
            "        required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES)",
            "    )",
            "    commit_default = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    hidden = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    read_only = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    approval_required = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    is_job_hook_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    is_job_button_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class JobHookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(), required=True, label=\"Content Type(s)\"",
            "    )",
            "",
            "    class Meta:",
            "        model = JobHook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = JobHook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            job=self.cleaned_data.get(\"job\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class JobHookFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobHook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(),",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    job = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "",
            "",
            "class JobScheduleForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is rendered alongside the JobForm but deals specifically with the fields needed to either",
            "    execute the job immediately, or schedule it for later. Each field name is prefixed with an underscore",
            "    because in the POST body, they share a namespace with the JobForm which includes fields defined by the",
            "    job author, so the underscore prefix helps to avoid name collisions.",
            "    \"\"\"",
            "",
            "    _schedule_type = forms.ChoiceField(",
            "        choices=JobExecutionType,",
            "        help_text=\"The job can either run immediately, once in the future, or on a recurring schedule.\",",
            "        label=\"Type\",",
            "    )",
            "    _schedule_name = forms.CharField(",
            "        required=False,",
            "        label=\"Schedule name\",",
            "        help_text=\"Name for the job schedule.\",",
            "    )",
            "    _schedule_start_time = forms.DateTimeField(",
            "        required=False,",
            "        label=\"Starting date and time\",",
            "        widget=DateTimePicker(),",
            "        help_text=f\"The scheduled time is relative to the Nautobot configured timezone: {settings.TIME_ZONE}.\",",
            "    )",
            "    _recurrence_custom_time = forms.CharField(",
            "        required=False,",
            "        label=\"Crontab\",",
            "        help_text=\"Custom crontab syntax (* * * * *)\",",
            "    )",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Validate all required information is present if the job needs to be scheduled",
            "        \"\"\"",
            "        cleaned_data = super().clean()",
            "",
            "        if \"_schedule_type\" in cleaned_data and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY:",
            "            if not cleaned_data.get(\"_schedule_name\"):",
            "                raise ValidationError({\"_schedule_name\": \"Please provide a name for the job schedule.\"})",
            "",
            "            if (",
            "                not cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_CUSTOM",
            "            ) or (",
            "                cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_start_time\") < ScheduledJob.earliest_possible_time()",
            "            ):",
            "                raise ValidationError(",
            "                    {",
            "                        \"_schedule_start_time\": \"Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                    }",
            "                )",
            "",
            "            if cleaned_data.get(\"_schedule_type\") == JobExecutionType.TYPE_CUSTOM:",
            "                try:",
            "                    ScheduledJob.get_crontab(cleaned_data.get(\"_recurrence_custom_time\"))",
            "                except Exception as e:",
            "                    raise ValidationError({\"_recurrence_custom_time\": e})",
            "",
            "",
            "class JobResultFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobResult",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    # 2.0 TODO(glenn) filtering by obj_type should be solved by dynamic filter form generation",
            "    name = forms.CharField(required=False)",
            "    user = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    status = forms.MultipleChoiceField(",
            "        choices=JobResultStatusChoices,",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "",
            "",
            "class ScheduledJobFilterForm(BootstrapMixin, forms.Form):",
            "    model = ScheduledJob",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/job-models/\"),",
            "    )",
            "    total_run_count = forms.IntegerField(required=False)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = JobButton",
            "        fields = (",
            "            \"content_types\",",
            "            \"name\",",
            "            \"text\",",
            "            \"job\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"confirmation\",",
            "        )",
            "",
            "",
            "class JobButtonBulkEditForm(BootstrapMixin, BulkEditForm):",
            "    \"\"\"Bulk edit form for `JobButton` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=JobButton.objects.all(), widget=forms.MultipleHiddenInput)",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "        required=False,",
            "    )",
            "    weight = forms.IntegerField(required=False)",
            "    group_name = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"group_name\"]",
            "",
            "",
            "class JobButtonFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobButton",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Types\",",
            "    )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteForm(BootstrapMixin, forms.ModelForm):",
            "    note = CommentField()",
            "",
            "    class Meta:",
            "        model = Note",
            "        fields = [\"assigned_object_type\", \"assigned_object_id\", \"note\"]",
            "        widgets = {",
            "            \"assigned_object_type\": forms.HiddenInput,",
            "            \"assigned_object_id\": forms.HiddenInput,",
            "        }",
            "",
            "",
            "#",
            "# Filter form for local config context data",
            "#",
            "",
            "",
            "class LocalContextFilterForm(forms.Form):",
            "    local_context_data = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has local config context data\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    local_context_schema = DynamicModelMultipleChoiceField(",
            "        queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "",
            "#",
            "# Model form for local config context data",
            "#",
            "",
            "",
            "class LocalContextModelForm(forms.ModelForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    local_context_data = JSONField(required=False, label=\"\")",
            "",
            "",
            "class LocalContextModelBulkEditForm(BulkEditForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # append nullable fields",
            "        self.nullable_fields.append(\"local_context_schema\")",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeFilterForm(BootstrapMixin, forms.Form):",
            "    model = ObjectChange",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    time__gte = forms.DateTimeField(label=\"After\", required=False, widget=DateTimePicker())",
            "    time__lte = forms.DateTimeField(label=\"Before\", required=False, widget=DateTimePicker())",
            "    action = forms.ChoiceField(",
            "        choices=add_blank_choice(ObjectChangeActionChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    user_id = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    changed_object_type_id = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Type\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField(help_text=\"Internal name of this relationship. Please use underscores rather than dashes.\")",
            "    source_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The source object type to which this relationship applies.\",",
            "    )",
            "    source_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable source objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "    destination_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The destination object type to which this relationship applies.\",",
            "    )",
            "    destination_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable destination objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "",
            "    class Meta:",
            "        model = Relationship",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"type\",",
            "            \"required_on\",",
            "            \"advanced_ui\",",
            "            \"source_type\",",
            "            \"source_label\",",
            "            \"source_hidden\",",
            "            \"source_filter\",",
            "            \"destination_type\",",
            "            \"destination_label\",",
            "            \"destination_hidden\",",
            "            \"destination_filter\",",
            "        ]",
            "",
            "    def save(self, commit=True):",
            "        # TODO add support for owner when a CR is created in the UI",
            "        obj = super().save(commit)",
            "",
            "        return obj",
            "",
            "",
            "class RelationshipFilterForm(BootstrapMixin, forms.Form):",
            "    model = Relationship",
            "",
            "    type = forms.MultipleChoiceField(choices=RelationshipTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "class RelationshipAssociationFilterForm(BootstrapMixin, forms.Form):",
            "    model = RelationshipAssociation",
            "",
            "    relationship = DynamicModelMultipleChoiceField(",
            "        queryset=Relationship.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "    )",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "def provider_choices():",
            "    return sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()])",
            "",
            "",
            "class SecretForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `Secret` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    provider = forms.ChoiceField(choices=provider_choices, widget=StaticSelect2())",
            "",
            "    parameters = JSONField(help_text='Enter parameters in <a href=\"https://json.org/\">JSON</a> format.')",
            "",
            "    class Meta:",
            "        model = Secret",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"provider\",",
            "            \"parameters\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class SecretCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = Secret",
            "        fields = Secret.csv_headers",
            "",
            "",
            "def provider_choices_with_blank():",
            "    return add_blank_choice(sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()]))",
            "",
            "",
            "class SecretFilterForm(NautobotFilterForm):",
            "    model = Secret",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    provider = forms.MultipleChoiceField(",
            "        choices=provider_choices_with_blank, widget=StaticSelect2Multiple(), required=False",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing assignments of Secrets to SecretsGroups.",
            "SecretsGroupAssociationFormSet = inlineformset_factory(",
            "    parent_model=SecretsGroup,",
            "    model=SecretsGroupAssociation,",
            "    fields=(\"access_type\", \"secret_type\", \"secret\"),",
            "    extra=5,",
            "    widgets={",
            "        \"access_type\": StaticSelect2,",
            "        \"secret_type\": StaticSelect2,",
            "        \"secret\": APISelect(api_url=\"/api/extras/secrets/\"),",
            "    },",
            ")",
            "",
            "",
            "class SecretsGroupForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `SecretsGroup` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = SecretsGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class SecretsGroupFilterForm(NautobotFilterForm):",
            "    model = SecretsGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusForm(NautobotModelForm):",
            "    \"\"\"Generic create/update form for `Status` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Status",
            "        widgets = {\"color\": ColorSelect()}",
            "        fields = [\"name\", \"slug\", \"description\", \"content_types\", \"color\"]",
            "",
            "",
            "class StatusCSVForm(CustomFieldModelCSVForm):",
            "    \"\"\"Generic CSV bulk import form for `Status` objects.\"\"\"",
            "",
            "    content_types = CSVMultipleContentTypeField(",
            "        feature=\"statuses\",",
            "        choices_as_strings=True,",
            "        help_text=mark_safe(  # noqa: S308",
            "            \"The object types to which this status applies. Multiple values \"",
            "            \"must be comma-separated and wrapped in double quotes. (e.g. \"",
            "            '<code>\"dcim.device,dcim.rack\"</code>)'",
            "        ),",
            "        label=\"Content type(s)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Status",
            "        fields = Status.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "class StatusFilterForm(NautobotFilterForm):",
            "    \"\"\"Filtering/search form for `Status` objects.\"\"\"",
            "",
            "    model = Status",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"statuses\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "",
            "",
            "class StatusBulkEditForm(NautobotBulkEditForm):",
            "    \"\"\"Bulk edit/delete form for `Status` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=Status.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagForm(NautobotModelForm):",
            "    slug = SlugField()",
            "    content_types = ModelMultipleChoiceField(",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = [\"name\", \"slug\", \"color\", \"description\", \"content_types\"]",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        if self.instance.present_in_database:",
            "            # check if tag is assigned to any of the removed content_types",
            "            content_types_id = [content_type.id for content_type in self.cleaned_data[\"content_types\"]]",
            "            errors = self.instance.validate_content_types_removal(content_types_id)",
            "",
            "            if errors:",
            "                raise ValidationError(errors)",
            "",
            "        return data",
            "",
            "",
            "class TagCSVForm(CustomFieldModelCSVForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = Tag.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "class TagFilterForm(NautobotFilterForm):",
            "    model = Tag",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "",
            "class TagBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Tag.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    description = forms.CharField(max_length=200, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(feature=\"webhooks\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Webhook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "            \"payload_url\",",
            "            \"http_method\",",
            "            \"http_content_type\",",
            "            \"additional_headers\",",
            "            \"body_template\",",
            "            \"secret\",",
            "            \"ssl_verification\",",
            "            \"ca_file_path\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = Webhook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            payload_url=self.cleaned_data.get(\"payload_url\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class WebhookFilterForm(BootstrapMixin, forms.Form):",
            "    model = Webhook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"webhooks\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "370": [
                "CustomFieldForm"
            ],
            "372": [
                "CustomFieldForm"
            ],
            "373": [
                "CustomFieldForm"
            ],
            "374": [
                "CustomFieldForm"
            ],
            "1086": [
                "NoteForm"
            ]
        },
        "addLocation": [
            "src.urllib3.util.retry",
            "nautobot.extras.forms.forms.CustomFieldForm.description"
        ]
    },
    "nautobot/extras/models/jobs.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         help_text=\"Human-readable name of this job\","
            },
            "1": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         db_index=True,"
            },
            "2": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     )"
            },
            "3": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    description = models.TextField(blank=True, help_text=\"Markdown formatting is supported\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    description = models.TextField("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        blank=True,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        help_text=\"Markdown formatting and a limited subset of HTML are supported\","
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    )"
            },
            "8": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     # Control flags"
            },
            "10": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     installed = models.BooleanField("
            }
        },
        "frontPatchFile": [
            "# Data models relating to Jobs",
            "",
            "from datetime import timedelta",
            "import logging",
            "import os",
            "import uuid",
            "",
            "from celery import schedules",
            "",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.validators import MinValueValidator",
            "from django.db import models, transaction",
            "from django.db.models import signals",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "",
            "from django_celery_beat.clockedschedule import clocked",
            "from django_celery_beat.managers import ExtendedManager",
            "from prometheus_client import Histogram",
            "",
            "from nautobot.core.celery import NautobotKombuJSONEncoder",
            "from nautobot.core.fields import AutoSlugField, slugify_dots_to_dashes",
            "from nautobot.core.models import BaseModel",
            "from nautobot.core.models.generics import OrganizationalModel, PrimaryModel",
            "from nautobot.extras.choices import (",
            "    ButtonClassChoices,",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    JobSourceChoices,",
            "    LogLevelChoices,",
            ")",
            "from nautobot.extras.constants import (",
            "    JOB_LOG_MAX_ABSOLUTE_URL_LENGTH,",
            "    JOB_LOG_MAX_GROUPING_LENGTH,",
            "    JOB_LOG_MAX_LOG_OBJECT_LENGTH,",
            "    JOB_MAX_GROUPING_LENGTH,",
            "    JOB_MAX_NAME_LENGTH,",
            "    JOB_MAX_SLUG_LENGTH,",
            "    JOB_MAX_SOURCE_LENGTH,",
            "    JOB_OVERRIDABLE_FIELDS,",
            ")",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.extras.plugins.utils import import_object",
            "from nautobot.extras.querysets import JobQuerySet, ScheduledJobExtendedQuerySet",
            "from nautobot.extras.utils import (",
            "    ChangeLoggedModelsQuery,",
            "    FeatureQuery,",
            "    extras_features,",
            "    get_job_content_type,",
            "    jobs_in_directory,",
            ")",
            "from nautobot.utilities.fields import JSONArrayField",
            "from nautobot.utilities.logging import sanitize",
            "",
            "from .customfields import CustomFieldModel",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# The JOB_LOGS variable is used to tell the JobLogEntry model the database to store to.",
            "# We default this to job_logs, and creating at the Global level allows easy override",
            "# during testing. This needs to point to the same physical database so that the",
            "# foreign key relationship works, but needs its own connection to avoid JobLogEntry",
            "# objects being created within transaction.atomic().",
            "JOB_LOGS = \"job_logs\"",
            "",
            "# The JOB_RESULT_METRIC variable is a counter metric that counts executions of jobs,",
            "# including information beyond what a tool like flower could get by introspecting",
            "# the celery task queue. This is accomplished by looking one abstraction deeper into",
            "# the job model of Nautobot.",
            "JOB_RESULT_METRIC = Histogram(",
            "    \"nautobot_job_duration_seconds\", \"Results of Nautobot jobs.\", [\"grouping\", \"name\", \"status\"]",
            ")",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"graphql\",",
            "    \"job_results\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class Job(PrimaryModel):",
            "    \"\"\"",
            "    Database model representing an installed Job class.",
            "    \"\"\"",
            "",
            "    # Information used to locate the Job source code",
            "    source = models.CharField(",
            "        max_length=JOB_MAX_SOURCE_LENGTH,",
            "        choices=JobSourceChoices,",
            "        editable=False,",
            "        db_index=True,",
            "        help_text=\"Source of the Python code for this job - local, Git repository, or plugins\",",
            "    )",
            "    git_repository = models.ForeignKey(",
            "        to=\"extras.GitRepository\",",
            "        blank=True,",
            "        null=True,",
            "        default=None,",
            "        on_delete=models.SET_NULL,",
            "        db_index=True,",
            "        related_name=\"jobs\",",
            "        help_text=\"Git repository that provides this job\",",
            "    )",
            "    module_name = models.CharField(",
            "        max_length=JOB_MAX_NAME_LENGTH,",
            "        editable=False,",
            "        db_index=True,",
            "        help_text=\"Dotted name of the Python module providing this job\",",
            "    )",
            "    job_class_name = models.CharField(",
            "        max_length=JOB_MAX_NAME_LENGTH,",
            "        editable=False,",
            "        db_index=True,",
            "        help_text=\"Name of the Python class providing this job\",",
            "    )",
            "",
            "    slug = AutoSlugField(",
            "        max_length=JOB_MAX_SLUG_LENGTH,",
            "        populate_from=[\"class_path\"],",
            "        slugify_function=slugify_dots_to_dashes,",
            "    )",
            "",
            "    # Human-readable information, potentially inherited from the source code",
            "    # See also the docstring of nautobot.extras.jobs.BaseJob.Meta.",
            "    grouping = models.CharField(",
            "        max_length=JOB_MAX_GROUPING_LENGTH,",
            "        help_text=\"Human-readable grouping that this job belongs to\",",
            "        db_index=True,",
            "    )",
            "    name = models.CharField(",
            "        max_length=JOB_MAX_NAME_LENGTH,",
            "        help_text=\"Human-readable name of this job\",",
            "        db_index=True,",
            "    )",
            "    description = models.TextField(blank=True, help_text=\"Markdown formatting is supported\")",
            "",
            "    # Control flags",
            "    installed = models.BooleanField(",
            "        default=True,",
            "        db_index=True,",
            "        editable=False,",
            "        help_text=\"Whether the Python module and class providing this job are presently installed and loadable\",",
            "    )",
            "    enabled = models.BooleanField(default=False, help_text=\"Whether this job can be executed by users\")",
            "",
            "    is_job_hook_receiver = models.BooleanField(",
            "        default=False, editable=False, help_text=\"Whether this job is a job hook receiver\"",
            "    )",
            "",
            "    is_job_button_receiver = models.BooleanField(",
            "        default=False, editable=False, help_text=\"Whether this job is a job button receiver\"",
            "    )",
            "",
            "    has_sensitive_variables = models.BooleanField(",
            "        default=True, help_text=\"Whether this job contains sensitive variables\"",
            "    )",
            "",
            "    # Additional properties, potentially inherited from the source code",
            "    # See also the docstring of nautobot.extras.jobs.BaseJob.Meta.",
            "    approval_required = models.BooleanField(",
            "        default=False, help_text=\"Whether the job requires approval from another user before running\"",
            "    )",
            "    commit_default = models.BooleanField(",
            "        default=True, help_text=\"Whether the job defaults to committing changes when run, or defaults to a dry-run\"",
            "    )",
            "    hidden = models.BooleanField(",
            "        default=False,",
            "        db_index=True,",
            "        help_text=\"Whether the job defaults to not being shown in the UI\",",
            "    )",
            "    # Job.Meta.field_order is not overridable in this model",
            "    read_only = models.BooleanField(",
            "        default=False, help_text=\"Whether the job is prevented from making lasting changes to the database\"",
            "    )",
            "    soft_time_limit = models.FloatField(",
            "        default=0,",
            "        validators=[MinValueValidator(0)],",
            "        help_text=\"Maximum runtime in seconds before the job will receive a <code>SoftTimeLimitExceeded</code> \"",
            "        \"exception.<br>Set to 0 to use Nautobot system default\",",
            "    )",
            "    time_limit = models.FloatField(",
            "        default=0,",
            "        validators=[MinValueValidator(0)],",
            "        help_text=\"Maximum runtime in seconds before the job will be forcibly terminated.\"",
            "        \"<br>Set to 0 to use Nautobot system default\",",
            "    )",
            "    task_queues = JSONArrayField(",
            "        base_field=models.CharField(max_length=100, blank=True),",
            "        default=list,",
            "        blank=True,",
            "        help_text=\"Comma separated list of task queues that this job can run on. A blank list will use the default queue\",",
            "    )",
            "",
            "    # Flags to indicate whether the above properties are inherited from the source code or overridden by the database",
            "    grouping_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured grouping will remain even if the underlying Job source code changes\",",
            "    )",
            "    name_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured name will remain even if the underlying Job source code changes\",",
            "    )",
            "    description_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured description will remain even if the underlying Job source code changes\",",
            "    )",
            "",
            "    approval_required_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    commit_default_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    hidden_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    read_only_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    soft_time_limit_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    time_limit_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    has_sensitive_variables_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    task_queues_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "",
            "    objects = JobQuerySet.as_manager()",
            "",
            "    class Meta:",
            "        managed = True",
            "        ordering = [\"grouping\", \"name\"]",
            "        unique_together = [",
            "            (\"source\", \"git_repository\", \"module_name\", \"job_class_name\"),",
            "            (\"grouping\", \"name\"),",
            "        ]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self._job_class = None",
            "        self._latest_result = None",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def validate_unique(self, exclude=None):",
            "        \"\"\"",
            "        Check for duplicate (source, module_name, job_class_name) in the case where git_repository is None.",
            "",
            "        This is needed because NULL != NULL and so the unique_together constraint will not flag this case.",
            "        \"\"\"",
            "        if self.git_repository is None:",
            "            if Job.objects.exclude(pk=self.pk).filter(",
            "                source=self.source, module_name=self.module_name, job_class_name=self.job_class_name",
            "            ):",
            "                raise ValidationError(",
            "                    {\"job_class_name\": \"A Job already exists with this source, module_name, and job_class_name\"}",
            "                )",
            "",
            "        super().validate_unique(exclude=exclude)",
            "",
            "    @property",
            "    def job_class(self):",
            "        \"\"\"Get the Job class (source code) associated with this Job model.\"\"\"",
            "        if not self.installed:",
            "            return None",
            "        if self._job_class is None:",
            "            if self.source == JobSourceChoices.SOURCE_LOCAL:",
            "                path = settings.JOBS_ROOT",
            "                for job_info in jobs_in_directory(settings.JOBS_ROOT, module_name=self.module_name):",
            "                    if job_info.job_class_name == self.job_class_name:",
            "                        self._job_class = job_info.job_class",
            "                        break",
            "                else:",
            "                    logger.warning(\"Module %s job class %s not found!\", self.module_name, self.job_class_name)",
            "            elif self.source == JobSourceChoices.SOURCE_GIT:",
            "                from nautobot.extras.datasources.git import ensure_git_repository",
            "",
            "                if self.git_repository is None:",
            "                    logger.warning(\"Job %s %s has no associated Git repository\", self.module_name, self.job_class_name)",
            "                    return None",
            "                try:",
            "                    # In the case where we have multiple Nautobot instances, or multiple worker instances,",
            "                    # they are not required to share a common filesystem; therefore, we may need to refresh our local",
            "                    # clone of the Git repository to ensure that it is in sync with the latest repository clone",
            "                    # from any instance.",
            "                    ensure_git_repository(",
            "                        self.git_repository,",
            "                        head=self.git_repository.current_head,",
            "                        logger=logger,",
            "                    )",
            "                    path = os.path.join(self.git_repository.filesystem_path, \"jobs\")",
            "                    for job_info in jobs_in_directory(path, module_name=self.module_name):",
            "                        if job_info.job_class_name == self.job_class_name:",
            "                            self._job_class = job_info.job_class",
            "                            break",
            "                    else:",
            "                        logger.warning(",
            "                            \"Module %s job class %s not found in repository %s\",",
            "                            self.module_name,",
            "                            self.job_class_name,",
            "                            self.git_repository,",
            "                        )",
            "                except ObjectDoesNotExist:",
            "                    return None",
            "                except Exception as exc:",
            "                    logger.error(f\"Error during local clone/refresh of Git repository {self.git_repository}: {exc}\")",
            "                    return None",
            "            elif self.source == JobSourceChoices.SOURCE_PLUGIN:",
            "                # pkgutil.resolve_name is only available in Python 3.9 and later",
            "                self._job_class = import_object(f\"{self.module_name}.{self.job_class_name}\")",
            "",
            "        return self._job_class",
            "",
            "    @property",
            "    def class_path(self):",
            "        if self.git_repository is not None:",
            "            return f\"{self.source}.{self.git_repository.slug}/{self.module_name}/{self.job_class_name}\"",
            "        return f\"{self.source}/{self.module_name}/{self.job_class_name}\"",
            "",
            "    @property",
            "    def latest_result(self):",
            "        \"\"\"",
            "        Return the most recent JobResult object associated with this Job.",
            "",
            "        Note that, as a performance optimization for this function's repeated use in",
            "        JobListview, the returned object only includes its `status` field.",
            "        \"\"\"",
            "        if self._latest_result is None:",
            "            self._latest_result = self.results.only(\"status\").first()",
            "        return self._latest_result",
            "",
            "    @property",
            "    def description_first_line(self):",
            "        return self.description.splitlines()[0]",
            "",
            "    @property",
            "    def runnable(self):",
            "        return (",
            "            self.enabled",
            "            and self.installed",
            "            and self.job_class is not None",
            "            and not (self.has_sensitive_variables and self.approval_required)",
            "        )",
            "",
            "    def clean(self):",
            "        \"\"\"For any non-overridden fields, make sure they get reset to the actual underlying class value if known.\"\"\"",
            "        if self.job_class is not None:",
            "            for field_name in JOB_OVERRIDABLE_FIELDS:",
            "                if not getattr(self, f\"{field_name}_override\", False):",
            "                    setattr(self, field_name, getattr(self.job_class, field_name))",
            "",
            "        if self.git_repository is not None and self.source != JobSourceChoices.SOURCE_GIT:",
            "            raise ValidationError('A Git repository may only be specified when the source is \"git\"')",
            "",
            "        # Protect against invalid input when auto-creating Job records",
            "        if len(self.source) > JOB_MAX_SOURCE_LENGTH:",
            "            raise ValidationError(f\"Source may not exceed {JOB_MAX_SOURCE_LENGTH} characters in length\")",
            "        if len(self.module_name) > JOB_MAX_NAME_LENGTH:",
            "            raise ValidationError(f\"Module name may not exceed {JOB_MAX_NAME_LENGTH} characters in length\")",
            "        if len(self.job_class_name) > JOB_MAX_NAME_LENGTH:",
            "            raise ValidationError(f\"Job class name may not exceed {JOB_MAX_NAME_LENGTH} characters in length\")",
            "        if len(self.grouping) > JOB_MAX_GROUPING_LENGTH:",
            "            raise ValidationError(\"Grouping may not exceed {JOB_MAX_GROUPING_LENGTH} characters in length\")",
            "        if len(self.name) > JOB_MAX_NAME_LENGTH:",
            "            raise ValidationError(f\"Name may not exceed {JOB_MAX_NAME_LENGTH} characters in length\")",
            "        if len(self.slug) > JOB_MAX_SLUG_LENGTH:",
            "            raise ValidationError(f\"Slug may not exceed {JOB_MAX_SLUG_LENGTH} characters in length\")",
            "",
            "        if self.has_sensitive_variables is True and self.approval_required is True:",
            "            raise ValidationError(",
            "                {\"approval_required\": \"A job that may have sensitive variables cannot be marked as requiring approval\"}",
            "            )",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:job_detail\", kwargs={\"slug\": self.slug})",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class JobHook(OrganizationalModel):",
            "    \"\"\"",
            "    A job hook defines a request that will trigger a job hook receiver when an object is created, updated, and/or",
            "    deleted in Nautobot. Each job hook can be limited to firing only on certain actions or certain object types.",
            "    \"\"\"",
            "",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"job_hooks\",",
            "        verbose_name=\"Object types\",",
            "        # 2.0 TODO: standardize verbose name for ContentType fields",
            "        limit_choices_to=ChangeLoggedModelsQuery,",
            "        help_text=\"The object(s) to which this job hook applies.\",",
            "    )",
            "    enabled = models.BooleanField(default=True)",
            "    job = models.ForeignKey(",
            "        to=Job,",
            "        related_name=\"job_hook\",",
            "        verbose_name=\"Job\",",
            "        help_text=\"The job that this job hook will initiate\",",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to={\"is_job_hook_receiver\": True},",
            "    )",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    type_create = models.BooleanField(default=False, help_text=\"Call this job hook when a matching object is created.\")",
            "    type_delete = models.BooleanField(default=False, help_text=\"Call this job hook when a matching object is deleted.\")",
            "    type_update = models.BooleanField(default=False, help_text=\"Call this job hook when a matching object is updated.\")",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # At least one action type must be selected",
            "        if not self.type_create and not self.type_delete and not self.type_update:",
            "            raise ValidationError(\"You must select at least one type: create, update, and/or delete.\")",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:jobhook\", kwargs={\"slug\": self.slug})",
            "",
            "    @classmethod",
            "    def check_for_conflicts(",
            "        cls, instance=None, content_types=None, job=None, type_create=None, type_update=None, type_delete=None",
            "    ):",
            "        \"\"\"",
            "        Helper method for enforcing uniqueness.",
            "",
            "        Don't allow two job hooks with the same content_type, same job, and any action(s) in common.",
            "        Called by JobHookForm.clean() and JobHookSerializer.validate()",
            "        \"\"\"",
            "",
            "        conflicts = {}",
            "        job_hook_error_msg = \"A job hook already exists for {action} on {content_type} to job {job}\"",
            "",
            "        if instance is not None and instance.present_in_database:",
            "            # This is a PATCH and might not include all relevant data",
            "            # Therefore we get data not available from instance",
            "            content_types = instance.content_types.all() if content_types is None else content_types",
            "            type_create = instance.type_create if type_create is None else type_create",
            "            type_update = instance.type_update if type_update is None else type_update",
            "            type_delete = instance.type_delete if type_delete is None else type_delete",
            "",
            "        if content_types is not None:",
            "            for content_type in content_types:",
            "                job_hooks = cls.objects.filter(content_types__in=[content_type], job=job)",
            "                if instance and instance.present_in_database:",
            "                    job_hooks = job_hooks.exclude(pk=instance.pk)",
            "",
            "                existing_type_create = job_hooks.filter(type_create=type_create).exists() if type_create else False",
            "                existing_type_update = job_hooks.filter(type_update=type_update).exists() if type_update else False",
            "                existing_type_delete = job_hooks.filter(type_delete=type_delete).exists() if type_delete else False",
            "",
            "                if existing_type_create:",
            "                    conflicts.setdefault(\"type_create\", []).append(",
            "                        job_hook_error_msg.format(content_type=content_type, action=\"create\", job=job),",
            "                    )",
            "",
            "                if existing_type_update:",
            "                    conflicts.setdefault(\"type_update\", []).append(",
            "                        job_hook_error_msg.format(content_type=content_type, action=\"update\", job=job),",
            "                    )",
            "",
            "                if existing_type_delete:",
            "                    conflicts.setdefault(\"type_delete\", []).append(",
            "                        job_hook_error_msg.format(content_type=content_type, action=\"delete\", job=job),",
            "                    )",
            "",
            "        return conflicts",
            "",
            "",
            "@extras_features(",
            "    \"graphql\",",
            ")",
            "class JobLogEntry(BaseModel):",
            "    \"\"\"Stores each log entry for the JobResult.\"\"\"",
            "",
            "    job_result = models.ForeignKey(to=\"extras.JobResult\", on_delete=models.CASCADE, related_name=\"logs\")",
            "    log_level = models.CharField(",
            "        max_length=32, choices=LogLevelChoices, default=LogLevelChoices.LOG_DEFAULT, db_index=True",
            "    )",
            "    grouping = models.CharField(max_length=JOB_LOG_MAX_GROUPING_LENGTH, default=\"main\")",
            "    message = models.TextField(blank=True)",
            "    created = models.DateTimeField(default=timezone.now)",
            "    # Storing both of the below as strings instead of using GenericForeignKey to support",
            "    # compatibility with existing JobResult logs. GFK would pose a problem with dangling foreign-key",
            "    # references, whereas this allows us to retain all records for as long as the entry exists.",
            "    # This also simplifies migration from the JobResult Data field as these were stored as strings.",
            "    log_object = models.CharField(max_length=JOB_LOG_MAX_LOG_OBJECT_LENGTH, null=True, blank=True)",
            "    absolute_url = models.CharField(max_length=JOB_LOG_MAX_ABSOLUTE_URL_LENGTH, null=True, blank=True)",
            "",
            "    csv_headers = [\"created\", \"grouping\", \"log_level\", \"log_object\", \"message\"]",
            "",
            "    def __str__(self):",
            "        return self.message",
            "",
            "    class Meta:",
            "        ordering = [\"created\"]",
            "        get_latest_by = \"created\"",
            "        verbose_name_plural = \"job log entries\"",
            "",
            "    def to_csv(self):",
            "        \"\"\"Indicates model fields to return as csv.\"\"\"",
            "        return (str(self.created), self.grouping, self.log_level, self.log_object, self.message)",
            "",
            "",
            "#",
            "# Job results",
            "#",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"graphql\",",
            ")",
            "class JobResult(BaseModel, CustomFieldModel):",
            "    \"\"\"",
            "    This model stores the results from running a Job.",
            "    \"\"\"",
            "",
            "    # Note that we allow job_model to be null and use models.SET_NULL here.",
            "    # This is because we want to be able to keep JobResult records for tracking and auditing purposes even after",
            "    # deleting the corresponding Job record.",
            "    job_model = models.ForeignKey(",
            "        to=\"extras.Job\", null=True, blank=True, on_delete=models.SET_NULL, related_name=\"results\"",
            "    )",
            "",
            "    name = models.CharField(max_length=255, db_index=True)",
            "    obj_type = models.ForeignKey(",
            "        to=ContentType,",
            "        related_name=\"job_results\",",
            "        verbose_name=\"Object types\",",
            "        limit_choices_to=FeatureQuery(\"job_results\"),",
            "        help_text=\"The object type to which this job result applies\",",
            "        on_delete=models.CASCADE,",
            "    )",
            "    created = models.DateTimeField(auto_now_add=True, db_index=True)",
            "    completed = models.DateTimeField(null=True, blank=True, db_index=True)",
            "    user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, related_name=\"+\", blank=True, null=True",
            "    )",
            "    # todoindex:",
            "    status = models.CharField(",
            "        max_length=30,",
            "        choices=JobResultStatusChoices,",
            "        default=JobResultStatusChoices.STATUS_PENDING,",
            "    )",
            "    data = models.JSONField(encoder=DjangoJSONEncoder, null=True, blank=True)",
            "    job_kwargs = models.JSONField(blank=True, null=True, encoder=NautobotKombuJSONEncoder)",
            "    schedule = models.ForeignKey(to=\"extras.ScheduledJob\", on_delete=models.SET_NULL, null=True, blank=True)",
            "    \"\"\"",
            "    Although \"data\" is technically an unstructured field, we have a standard structure that we try to adhere to.",
            "",
            "    This structure is created loosely as a superset of the formats used by Scripts and Reports in NetBox 2.10.",
            "",
            "    Log Messages now go to their own object, the JobLogEntry.",
            "",
            "    data = {",
            "        \"output\": <optional string, such as captured stdout/stderr>,",
            "    }",
            "    \"\"\"",
            "",
            "    job_id = models.UUIDField(unique=True)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.use_job_logs_db = True",
            "",
            "    class Meta:",
            "        ordering = [\"-created\"]",
            "        get_latest_by = \"created\"",
            "        indexes = [",
            "            models.Index(",
            "                name=\"extras_jobresult_rcreated_idx\",",
            "                fields=[\"-created\"],",
            "            ),",
            "            models.Index(",
            "                name=\"extras_jr_rcompleted_idx\",",
            "                fields=[\"-completed\"],",
            "            ),",
            "            models.Index(",
            "                name=\"extras_jr_statrcreate_idx\",",
            "                fields=[\"status\", \"-created\"],",
            "            ),",
            "            models.Index(",
            "                name=\"extras_jr_statrcompl_idx\",",
            "                fields=[\"status\", \"-completed\"],",
            "            ),",
            "        ]",
            "",
            "    def __str__(self):",
            "        return str(self.job_id)",
            "",
            "    @property",
            "    def duration(self):",
            "        if not self.completed:",
            "            return None",
            "",
            "        duration = self.completed - self.created",
            "        minutes, seconds = divmod(duration.total_seconds(), 60)",
            "",
            "        return f\"{int(minutes)} minutes, {seconds:.2f} seconds\"",
            "",
            "    @property",
            "    def related_object(self):",
            "        \"\"\"Get the related object, if any, identified by the `obj_type`, `name`, and/or `job_id` fields.",
            "",
            "        If `obj_type` is extras.Job, then the `name` is used to look up an extras.jobs.Job subclass based on the",
            "        `class_path` of the Job subclass.",
            "        Note that this is **not** the extras.models.Job model class nor an instance thereof.",
            "",
            "        Else, if the the model class referenced by `obj_type` has a `name` field, our `name` field will be used",
            "        to look up a corresponding model instance. This is used, for example, to look up a related `GitRepository`;",
            "        more generally it can be used by any model that 1) has a unique `name` field and 2) needs to have a many-to-one",
            "        relationship between JobResults and model instances.",
            "",
            "        Else, the `obj_type` and `job_id` will be used together as a quasi-GenericForeignKey to look up a model",
            "        instance whose PK corresponds to the `job_id`. This behavior is currently unused in the Nautobot core,",
            "        but may be of use to plugin developers wishing to create JobResults that have a one-to-one relationship",
            "        to plugin model instances.",
            "",
            "        This method is potentially rather slow as get_job() may need to actually load the Job class from disk;",
            "        consider carefully whether you actually need to use it.",
            "        \"\"\"",
            "        from nautobot.extras.jobs import get_job  # needed here to avoid a circular import issue",
            "",
            "        if self.obj_type == get_job_content_type():",
            "            # Related object is an extras.Job subclass, our `name` matches its `class_path`",
            "            return get_job(self.name)",
            "",
            "        model_class = self.obj_type.model_class()",
            "",
            "        if model_class is not None:",
            "            if hasattr(model_class, \"name\"):",
            "                # See if we have a many-to-one relationship from JobResult to model_class record, based on `name`",
            "                try:",
            "                    return model_class.objects.get(name=self.name)",
            "                except model_class.DoesNotExist:",
            "                    pass",
            "",
            "            # See if we have a one-to-one relationship from JobResult to model_class record based on `job_id`",
            "            try:",
            "                return model_class.objects.get(id=self.job_id)",
            "            except model_class.DoesNotExist:",
            "                pass",
            "",
            "        return None",
            "",
            "    @property",
            "    def related_name(self):",
            "        \"\"\"",
            "        A human-friendlier \"name\" for the Job Result.",
            "",
            "        This is commonly the name for extras.Job based jobs, but if the definition of the Job",
            "        or in cases of Git Repositories or other Related Objects there is no Job name definition available.",
            "",
            "        Properly handle those cases.",
            "        \"\"\"",
            "        if self.job_model:",
            "            # No need to call related_object(), getting the Job class name if we already have a job_model",
            "            return self.job_model.name",
            "        elif self.obj_type == get_job_content_type():",
            "            # Related object is an extras.Job subclass but the Job Model has been deleted",
            "            # Calling self.related_object will call ensure_git_repository() but will ultimately return None",
            "            return self.name",
            "",
            "        # At this point related_object is likely a GitRepository",
            "        related_object = self.related_object",
            "        if not related_object:",
            "            return self.name",
            "        if hasattr(related_object, \"name\"):",
            "            return related_object.name",
            "        return str(related_object)",
            "",
            "    @property",
            "    def linked_record(self):",
            "        \"\"\"",
            "        A newer alternative to self.related_object that looks up an extras.models.Job instead of an extras.jobs.Job.",
            "        \"\"\"",
            "        if self.job_model is not None:",
            "            return self.job_model",
            "        model_class = self.obj_type.model_class()",
            "        if model_class is not None:",
            "            if hasattr(model_class, \"name\"):",
            "                try:",
            "                    return model_class.objects.get(name=self.name)",
            "                except model_class.DoesNotExist:",
            "                    pass",
            "            if hasattr(model_class, \"class_path\"):",
            "                try:",
            "                    return model_class.objects.get(class_path=self.name)",
            "                except model_class.DoesNotExist:",
            "                    pass",
            "        return None",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:jobresult\", kwargs={\"pk\": self.pk})",
            "",
            "    def set_status(self, status):",
            "        \"\"\"",
            "        Helper method to change the status of the job result. If the target status is terminal, the  completion",
            "        time is also set.",
            "        \"\"\"",
            "        self.status = status",
            "        if status in JobResultStatusChoices.TERMINAL_STATE_CHOICES:",
            "            # Only add metrics if we have a related job model. If we are moving to a terminal state we should always",
            "            # have a related job model, so this shouldn't be too tight of a restriction.",
            "            self.completed = timezone.now()",
            "            if self.job_model:",
            "                duration = self.completed - self.created",
            "                JOB_RESULT_METRIC.labels(self.job_model.grouping, self.job_model.name, status).observe(",
            "                    duration.total_seconds()",
            "                )",
            "",
            "    @classmethod",
            "    def enqueue_job(cls, func, name, obj_type, user, *args, celery_kwargs=None, schedule=None, **kwargs):",
            "        \"\"\"",
            "        Create a JobResult instance and enqueue a job using the given callable",
            "",
            "        func: The callable object to be enqueued for execution",
            "        name: Name for the JobResult instance - corresponds to the desired Job class's \"class_path\" attribute,",
            "            if obj_type is extras.Job; for other funcs and obj_types it may differ.",
            "        obj_type: ContentType to link to the JobResult instance obj_type",
            "        user: User object to link to the JobResult instance",
            "        celery_kwargs: Dictionary of kwargs to pass as **kwargs to Celery when job is queued",
            "        args: additional args passed to the callable",
            "        schedule: Optional ScheduledJob instance to link to the JobResult",
            "        kwargs: additional kwargs passed to the callable",
            "        \"\"\"",
            "        # Discard \"request\" parameter from the kwargs that we save in the job_result, as it's not relevant to re-runs,",
            "        # and will likely go away in the future.",
            "        job_result_kwargs = {key: value for key, value in kwargs.items() if key != \"request\"}",
            "        job_result = cls.objects.create(",
            "            name=name,",
            "            obj_type=obj_type,",
            "            user=user,",
            "            job_id=uuid.uuid4(),",
            "            schedule=schedule,",
            "        )",
            "",
            "        kwargs[\"job_result_pk\"] = job_result.pk",
            "",
            "        # Prepare kwargs that will be sent to Celery",
            "        if celery_kwargs is None:",
            "            celery_kwargs = {}",
            "",
            "        if obj_type.app_label == \"extras\" and obj_type.model.lower() == \"job\":",
            "            try:",
            "                job_model = Job.objects.get_for_class_path(name)",
            "                if job_model.soft_time_limit > 0:",
            "                    celery_kwargs[\"soft_time_limit\"] = job_model.soft_time_limit",
            "                if job_model.time_limit > 0:",
            "                    celery_kwargs[\"time_limit\"] = job_model.time_limit",
            "                if not job_model.has_sensitive_variables:",
            "                    job_result.job_kwargs = job_result_kwargs",
            "                job_result.job_model = job_model",
            "                job_result.save()",
            "            except Job.DoesNotExist:",
            "                # 2.0 TODO: remove this fallback logic, database records should always exist",
            "                from nautobot.extras.jobs import get_job  # needed here to avoid a circular import issue",
            "",
            "                job_class = get_job(name)",
            "                if job_class is not None:",
            "                    logger.error(\"No Job instance found in the database corresponding to %s\", name)",
            "                    if hasattr(job_class.Meta, \"soft_time_limit\"):",
            "                        celery_kwargs[\"soft_time_limit\"] = job_class.Meta.soft_time_limit",
            "                    if hasattr(job_class.Meta, \"time_limit\"):",
            "                        celery_kwargs[\"time_limit\"] = job_class.Meta.time_limit",
            "                    if not job_class.has_sensitive_variables:",
            "                        job_result.job_kwargs = job_result_kwargs",
            "                        job_result.save()",
            "                else:",
            "                    logger.error(\"Neither a Job database record nor a Job source class were found for %s\", name)",
            "",
            "        # Jobs queued inside of a transaction need to run after the transaction completes and the JobResult is saved to the database",
            "        transaction.on_commit(",
            "            lambda: func.apply_async(args=args, kwargs=kwargs, task_id=str(job_result.job_id), **celery_kwargs)",
            "        )",
            "",
            "        return job_result",
            "",
            "    def log(",
            "        self,",
            "        message,",
            "        obj=None,",
            "        level_choice=LogLevelChoices.LOG_DEFAULT,",
            "        grouping=\"main\",",
            "        logger=None,  # pylint: disable=redefined-outer-name",
            "    ):",
            "        \"\"\"",
            "        General-purpose API for storing log messages in a JobResult's 'data' field.",
            "",
            "        message (str): Message to log (an attempt will be made to sanitize sensitive information from this message)",
            "        obj (object): Object associated with this message, if any",
            "        level_choice (LogLevelChoices): Message severity level",
            "        grouping (str): Grouping to store the log message under",
            "        logger (logging.logger): Optional logger to also output the message to",
            "        \"\"\"",
            "        if level_choice not in LogLevelChoices.as_dict():",
            "            raise ValueError(f\"Unknown logging level: {level_choice}\")",
            "",
            "        message = sanitize(str(message))",
            "",
            "        obj_absolute_url = None",
            "        if obj is not None and hasattr(obj, \"get_absolute_url\"):",
            "            try:",
            "                absolute_url = obj.get_absolute_url()",
            "                # If absolute_url is longer than we can store, we discard it instead of truncating,",
            "                # since a truncated URL is pretty useless.",
            "                if len(absolute_url) <= JOB_LOG_MAX_ABSOLUTE_URL_LENGTH:",
            "                    obj_absolute_url = absolute_url",
            "            except Exception:",
            "                pass",
            "",
            "        log = JobLogEntry(",
            "            job_result=self,",
            "            log_level=level_choice,",
            "            grouping=grouping[:JOB_LOG_MAX_GROUPING_LENGTH],",
            "            message=message,",
            "            created=timezone.now().isoformat(),",
            "            log_object=str(obj)[:JOB_LOG_MAX_LOG_OBJECT_LENGTH] if obj else None,",
            "            absolute_url=obj_absolute_url,",
            "        )",
            "",
            "        # If the override is provided, we want to use the default database(pass no using argument)",
            "        # Otherwise we want to use a separate database here so that the logs are created immediately",
            "        # instead of within transaction.atomic(). This allows us to be able to report logs when the jobs",
            "        # are running, and allow us to rollback the database without losing the log entries.",
            "        if not self.use_job_logs_db or not JOB_LOGS:",
            "            log.save()",
            "        else:",
            "            log.save(using=JOB_LOGS)",
            "",
            "        if logger:",
            "            if level_choice == LogLevelChoices.LOG_FAILURE:",
            "                log_level = logging.ERROR",
            "            elif level_choice == LogLevelChoices.LOG_WARNING:",
            "                log_level = logging.WARNING",
            "            else:",
            "                log_level = logging.INFO",
            "            logger.log(log_level, message)",
            "",
            "        return log",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class JobButton(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    A predefined button that includes all necessary information to run a Nautobot Job based on a single object as a source.",
            "    The button text field accepts Jinja2 template code to be rendered with an object as context.",
            "    \"\"\"",
            "",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"job_buttons\",",
            "        verbose_name=\"Object types\",",
            "        help_text=\"The object type(s) to which this job button applies.\",",
            "    )",
            "    name = models.CharField(max_length=100, unique=True)",
            "    text = models.CharField(",
            "        max_length=500,",
            "        help_text=\"Jinja2 template code for button text. Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>. Buttons which render as empty text will not be displayed.\",",
            "    )",
            "    job = models.ForeignKey(",
            "        to=\"extras.Job\",",
            "        on_delete=models.CASCADE,",
            "        help_text=\"Job this button will run\",",
            "        limit_choices_to={\"is_job_button_receiver\": True},",
            "    )",
            "    weight = models.PositiveSmallIntegerField(default=100)",
            "    group_name = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        help_text=\"Buttons with the same group will appear as a dropdown menu. Group dropdown buttons will inherit the button class from the button with the lowest weight in the group.\",",
            "    )",
            "    button_class = models.CharField(",
            "        max_length=30,",
            "        choices=ButtonClassChoices,",
            "        default=ButtonClassChoices.CLASS_DEFAULT,",
            "    )",
            "    confirmation = models.BooleanField(",
            "        help_text=\"Enable confirmation pop-up box. <span class='text-danger'>WARNING: unselecting this option will allow the Job to run (and commit changes) with a single click!</span>\",",
            "        default=True,",
            "    )",
            "",
            "    class Meta:",
            "        ordering = [\"group_name\", \"weight\", \"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:jobbutton\", kwargs={\"pk\": self.pk})",
            "",
            "",
            "class ScheduledJobs(models.Model):",
            "    \"\"\"Helper table for tracking updates to scheduled tasks.",
            "    This stores a single row with ident=1.  last_update is updated",
            "    via django signals whenever anything is changed in the ScheduledJob model.",
            "    Basically this acts like a DB data audit trigger.",
            "    Doing this so we also track deletions, and not just insert/update.",
            "    \"\"\"",
            "",
            "    ident = models.SmallIntegerField(default=1, primary_key=True, unique=True)",
            "    last_update = models.DateTimeField(null=False)",
            "",
            "    objects = ExtendedManager()",
            "",
            "    @classmethod",
            "    def changed(cls, instance, raw=False, **kwargs):",
            "        \"\"\"This function acts as a signal handler to track changes to the scheduled job that is triggered before a change\"\"\"",
            "        if raw:",
            "            return",
            "        if not instance.no_changes:",
            "            cls.update_changed()",
            "",
            "    @classmethod",
            "    def update_changed(cls, raw=False, **kwargs):",
            "        \"\"\"This function acts as a signal handler to track changes to the scheduled job that is triggered after a change\"\"\"",
            "        if raw:",
            "            return",
            "        cls.objects.update_or_create(ident=1, defaults={\"last_update\": timezone.now()})",
            "",
            "    @classmethod",
            "    def last_change(cls):",
            "        \"\"\"This function acts as a getter for the last update on scheduled jobs\"\"\"",
            "        try:",
            "            return cls.objects.get(ident=1).last_update",
            "        except cls.DoesNotExist:",
            "            return None",
            "",
            "",
            "class ScheduledJob(BaseModel):",
            "    \"\"\"Model representing a periodic task.\"\"\"",
            "",
            "    name = models.CharField(",
            "        max_length=200, verbose_name=\"Name\", help_text=\"Short Description For This Task\", db_index=True",
            "    )",
            "    task = models.CharField(",
            "        max_length=200,",
            "        verbose_name=\"Task Name\",",
            "        help_text='The name of the Celery task that should be run. (Example: \"proj.tasks.import_contacts\")',",
            "        db_index=True,",
            "    )",
            "    # Note that we allow job_model to be null and use models.SET_NULL here.",
            "    # This is because we want to be able to keep ScheduledJob records for tracking and auditing purposes even after",
            "    # deleting the corresponding Job record.",
            "    job_model = models.ForeignKey(",
            "        to=\"extras.Job\", null=True, blank=True, on_delete=models.SET_NULL, related_name=\"scheduled_jobs\"",
            "    )",
            "    job_class = models.CharField(",
            "        max_length=255,",
            "        verbose_name=\"Job Class\",",
            "        help_text=\"Name of the fully qualified Nautobot Job class path\",",
            "        db_index=True,",
            "    )",
            "    interval = models.CharField(choices=JobExecutionType, max_length=255)",
            "    args = models.JSONField(blank=True, default=list, encoder=NautobotKombuJSONEncoder)",
            "    kwargs = models.JSONField(blank=True, default=dict, encoder=NautobotKombuJSONEncoder)",
            "    queue = models.CharField(",
            "        max_length=200,",
            "        blank=True,",
            "        null=True,",
            "        default=None,",
            "        verbose_name=\"Queue Override\",",
            "        help_text=\"Queue defined in CELERY_TASK_QUEUES. Leave None for default queuing.\",",
            "        db_index=True,",
            "    )",
            "    one_off = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"One-off Task\",",
            "        help_text=\"If True, the schedule will only run the task a single time\",",
            "    )",
            "    start_time = models.DateTimeField(",
            "        verbose_name=\"Start Datetime\",",
            "        help_text=\"Datetime when the schedule should begin triggering the task to run\",",
            "    )",
            "    # todoindex:",
            "    enabled = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"Enabled\",",
            "        help_text=\"Set to False to disable the schedule\",",
            "    )",
            "    last_run_at = models.DateTimeField(",
            "        editable=False,",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Most Recent Run\",",
            "        help_text=\"Datetime that the schedule last triggered the task to run. \"",
            "        \"Reset to None if enabled is set to False.\",",
            "    )",
            "    total_run_count = models.PositiveIntegerField(",
            "        default=0,",
            "        editable=False,",
            "        verbose_name=\"Total Run Count\",",
            "        help_text=\"Running count of how many times the schedule has triggered the task\",",
            "    )",
            "    date_changed = models.DateTimeField(",
            "        auto_now=True,",
            "        verbose_name=\"Last Modified\",",
            "        help_text=\"Datetime that this scheduled job was last modified\",",
            "    )",
            "    description = models.TextField(",
            "        blank=True,",
            "        verbose_name=\"Description\",",
            "        help_text=\"Detailed description about the details of this scheduled job\",",
            "    )",
            "    user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL,",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"+\",",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"User that requested the schedule\",",
            "    )",
            "    approved_by_user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL,",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"+\",",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"User that approved the schedule\",",
            "    )",
            "    # todoindex:",
            "    approval_required = models.BooleanField(default=False)",
            "    approved_at = models.DateTimeField(",
            "        editable=False,",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Approval date/time\",",
            "        help_text=\"Datetime that the schedule was approved\",",
            "    )",
            "    crontab = models.CharField(",
            "        max_length=255,",
            "        blank=True,",
            "        verbose_name=\"Custom cronjob\",",
            "        help_text=\"Cronjob syntax string for custom scheduling\",",
            "    )",
            "",
            "    objects = ScheduledJobExtendedQuerySet.as_manager()",
            "    no_changes = False",
            "",
            "    def __str__(self):",
            "        return f\"{self.name}: {self.interval}\"",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:scheduledjob\", kwargs={\"pk\": self.pk})",
            "",
            "    def save(self, *args, **kwargs):",
            "        self.queue = self.queue or None",
            "        # pass pk to worker task in kwargs, celery doesn't provide the full object to the worker",
            "        self.kwargs[\"scheduled_job_pk\"] = self.pk",
            "        # make sure non-valid crontab doesn't get saved",
            "        if self.interval == JobExecutionType.TYPE_CUSTOM:",
            "            try:",
            "                self.get_crontab(self.crontab)",
            "            except Exception as e:",
            "                raise ValidationError({\"crontab\": e})",
            "        if not self.enabled:",
            "            self.last_run_at = None",
            "        elif not self.last_run_at:",
            "            # I'm not sure if this is a bug, or \"works as designed\", but if self.last_run_at is not set,",
            "            # the celery beat scheduler will never pick up a recurring job. One-off jobs work just fine though.",
            "            if self.interval in [",
            "                JobExecutionType.TYPE_HOURLY,",
            "                JobExecutionType.TYPE_DAILY,",
            "                JobExecutionType.TYPE_WEEKLY,",
            "            ]:",
            "                # A week is 7 days, otherwise the iteration is set to 1",
            "                multiplier = 7 if self.interval == JobExecutionType.TYPE_WEEKLY else 1",
            "                # Set the \"last run at\" time to one interval before the scheduled start time",
            "                self.last_run_at = self.start_time - timedelta(",
            "                    **{JobExecutionType.CELERY_INTERVAL_MAP[self.interval]: multiplier},",
            "                )",
            "",
            "        super().save(*args, **kwargs)",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Model Validation",
            "        \"\"\"",
            "        if self.user and self.approved_by_user and self.user == self.approved_by_user:",
            "            raise ValidationError(\"The requesting and approving users cannot be the same\")",
            "        # bitwise xor also works on booleans, but not on complex values",
            "        if bool(self.approved_by_user) ^ bool(self.approved_at):",
            "            raise ValidationError(\"Approval by user and approval time must either both be set or both be undefined\")",
            "",
            "    @property",
            "    def schedule(self):",
            "        if self.interval == JobExecutionType.TYPE_FUTURE:",
            "            # This is one-time clocked task",
            "            return clocked(clocked_time=self.start_time)",
            "",
            "        return self.to_cron()",
            "",
            "    @staticmethod",
            "    def earliest_possible_time():",
            "        return timezone.now() + timedelta(seconds=15)",
            "",
            "    @classmethod",
            "    def get_crontab(cls, crontab):",
            "        \"\"\"",
            "        Wrapper method translates crontab syntax to Celery crontab.",
            "",
            "        Supports following symbols:",
            "",
            "        \u2022 Asterisk (*) - signifies all possible values",
            "        \u2022 Comma (,) - lists multiple values",
            "        \u2022 Hyphen (-) - determine a range of values",
            "        \u2022 Slash (/) - divide a value ({*/15 * * * *} runs every 15 minutes)",
            "",
            "        No support for Last (L), Weekday (W), Number symbol (#), Question mark (?), and special @ strings.",
            "        \"\"\"",
            "        minute, hour, day_of_month, month_of_year, day_of_week = crontab.split(\" \")",
            "        return schedules.crontab(",
            "            minute=minute,",
            "            hour=hour,",
            "            day_of_month=day_of_month,",
            "            month_of_year=month_of_year,",
            "            day_of_week=day_of_week,",
            "        )",
            "",
            "    def to_cron(self):",
            "        t = self.start_time",
            "        if self.interval == JobExecutionType.TYPE_HOURLY:",
            "            return schedules.crontab(minute=t.minute)",
            "        elif self.interval == JobExecutionType.TYPE_DAILY:",
            "            return schedules.crontab(minute=t.minute, hour=t.hour)",
            "        elif self.interval == JobExecutionType.TYPE_WEEKLY:",
            "            return schedules.crontab(minute=t.minute, hour=t.hour, day_of_week=t.strftime(\"%w\"))",
            "        elif self.interval == JobExecutionType.TYPE_CUSTOM:",
            "            return self.get_crontab(self.crontab)",
            "        raise ValueError(f\"I do not know to convert {self.interval} to a Cronjob!\")",
            "",
            "",
            "signals.pre_delete.connect(ScheduledJobs.changed, sender=ScheduledJob)",
            "signals.pre_save.connect(ScheduledJobs.changed, sender=ScheduledJob)",
            "signals.post_save.connect(ScheduledJobs.update_changed, sender=ScheduledJob)"
        ],
        "afterPatchFile": [
            "# Data models relating to Jobs",
            "",
            "from datetime import timedelta",
            "import logging",
            "import os",
            "import uuid",
            "",
            "from celery import schedules",
            "",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.validators import MinValueValidator",
            "from django.db import models, transaction",
            "from django.db.models import signals",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "",
            "from django_celery_beat.clockedschedule import clocked",
            "from django_celery_beat.managers import ExtendedManager",
            "from prometheus_client import Histogram",
            "",
            "from nautobot.core.celery import NautobotKombuJSONEncoder",
            "from nautobot.core.fields import AutoSlugField, slugify_dots_to_dashes",
            "from nautobot.core.models import BaseModel",
            "from nautobot.core.models.generics import OrganizationalModel, PrimaryModel",
            "from nautobot.extras.choices import (",
            "    ButtonClassChoices,",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    JobSourceChoices,",
            "    LogLevelChoices,",
            ")",
            "from nautobot.extras.constants import (",
            "    JOB_LOG_MAX_ABSOLUTE_URL_LENGTH,",
            "    JOB_LOG_MAX_GROUPING_LENGTH,",
            "    JOB_LOG_MAX_LOG_OBJECT_LENGTH,",
            "    JOB_MAX_GROUPING_LENGTH,",
            "    JOB_MAX_NAME_LENGTH,",
            "    JOB_MAX_SLUG_LENGTH,",
            "    JOB_MAX_SOURCE_LENGTH,",
            "    JOB_OVERRIDABLE_FIELDS,",
            ")",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.extras.plugins.utils import import_object",
            "from nautobot.extras.querysets import JobQuerySet, ScheduledJobExtendedQuerySet",
            "from nautobot.extras.utils import (",
            "    ChangeLoggedModelsQuery,",
            "    FeatureQuery,",
            "    extras_features,",
            "    get_job_content_type,",
            "    jobs_in_directory,",
            ")",
            "from nautobot.utilities.fields import JSONArrayField",
            "from nautobot.utilities.logging import sanitize",
            "",
            "from .customfields import CustomFieldModel",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# The JOB_LOGS variable is used to tell the JobLogEntry model the database to store to.",
            "# We default this to job_logs, and creating at the Global level allows easy override",
            "# during testing. This needs to point to the same physical database so that the",
            "# foreign key relationship works, but needs its own connection to avoid JobLogEntry",
            "# objects being created within transaction.atomic().",
            "JOB_LOGS = \"job_logs\"",
            "",
            "# The JOB_RESULT_METRIC variable is a counter metric that counts executions of jobs,",
            "# including information beyond what a tool like flower could get by introspecting",
            "# the celery task queue. This is accomplished by looking one abstraction deeper into",
            "# the job model of Nautobot.",
            "JOB_RESULT_METRIC = Histogram(",
            "    \"nautobot_job_duration_seconds\", \"Results of Nautobot jobs.\", [\"grouping\", \"name\", \"status\"]",
            ")",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"graphql\",",
            "    \"job_results\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class Job(PrimaryModel):",
            "    \"\"\"",
            "    Database model representing an installed Job class.",
            "    \"\"\"",
            "",
            "    # Information used to locate the Job source code",
            "    source = models.CharField(",
            "        max_length=JOB_MAX_SOURCE_LENGTH,",
            "        choices=JobSourceChoices,",
            "        editable=False,",
            "        db_index=True,",
            "        help_text=\"Source of the Python code for this job - local, Git repository, or plugins\",",
            "    )",
            "    git_repository = models.ForeignKey(",
            "        to=\"extras.GitRepository\",",
            "        blank=True,",
            "        null=True,",
            "        default=None,",
            "        on_delete=models.SET_NULL,",
            "        db_index=True,",
            "        related_name=\"jobs\",",
            "        help_text=\"Git repository that provides this job\",",
            "    )",
            "    module_name = models.CharField(",
            "        max_length=JOB_MAX_NAME_LENGTH,",
            "        editable=False,",
            "        db_index=True,",
            "        help_text=\"Dotted name of the Python module providing this job\",",
            "    )",
            "    job_class_name = models.CharField(",
            "        max_length=JOB_MAX_NAME_LENGTH,",
            "        editable=False,",
            "        db_index=True,",
            "        help_text=\"Name of the Python class providing this job\",",
            "    )",
            "",
            "    slug = AutoSlugField(",
            "        max_length=JOB_MAX_SLUG_LENGTH,",
            "        populate_from=[\"class_path\"],",
            "        slugify_function=slugify_dots_to_dashes,",
            "    )",
            "",
            "    # Human-readable information, potentially inherited from the source code",
            "    # See also the docstring of nautobot.extras.jobs.BaseJob.Meta.",
            "    grouping = models.CharField(",
            "        max_length=JOB_MAX_GROUPING_LENGTH,",
            "        help_text=\"Human-readable grouping that this job belongs to\",",
            "        db_index=True,",
            "    )",
            "    name = models.CharField(",
            "        max_length=JOB_MAX_NAME_LENGTH,",
            "        help_text=\"Human-readable name of this job\",",
            "        db_index=True,",
            "    )",
            "    description = models.TextField(",
            "        blank=True,",
            "        help_text=\"Markdown formatting and a limited subset of HTML are supported\",",
            "    )",
            "",
            "    # Control flags",
            "    installed = models.BooleanField(",
            "        default=True,",
            "        db_index=True,",
            "        editable=False,",
            "        help_text=\"Whether the Python module and class providing this job are presently installed and loadable\",",
            "    )",
            "    enabled = models.BooleanField(default=False, help_text=\"Whether this job can be executed by users\")",
            "",
            "    is_job_hook_receiver = models.BooleanField(",
            "        default=False, editable=False, help_text=\"Whether this job is a job hook receiver\"",
            "    )",
            "",
            "    is_job_button_receiver = models.BooleanField(",
            "        default=False, editable=False, help_text=\"Whether this job is a job button receiver\"",
            "    )",
            "",
            "    has_sensitive_variables = models.BooleanField(",
            "        default=True, help_text=\"Whether this job contains sensitive variables\"",
            "    )",
            "",
            "    # Additional properties, potentially inherited from the source code",
            "    # See also the docstring of nautobot.extras.jobs.BaseJob.Meta.",
            "    approval_required = models.BooleanField(",
            "        default=False, help_text=\"Whether the job requires approval from another user before running\"",
            "    )",
            "    commit_default = models.BooleanField(",
            "        default=True, help_text=\"Whether the job defaults to committing changes when run, or defaults to a dry-run\"",
            "    )",
            "    hidden = models.BooleanField(",
            "        default=False,",
            "        db_index=True,",
            "        help_text=\"Whether the job defaults to not being shown in the UI\",",
            "    )",
            "    # Job.Meta.field_order is not overridable in this model",
            "    read_only = models.BooleanField(",
            "        default=False, help_text=\"Whether the job is prevented from making lasting changes to the database\"",
            "    )",
            "    soft_time_limit = models.FloatField(",
            "        default=0,",
            "        validators=[MinValueValidator(0)],",
            "        help_text=\"Maximum runtime in seconds before the job will receive a <code>SoftTimeLimitExceeded</code> \"",
            "        \"exception.<br>Set to 0 to use Nautobot system default\",",
            "    )",
            "    time_limit = models.FloatField(",
            "        default=0,",
            "        validators=[MinValueValidator(0)],",
            "        help_text=\"Maximum runtime in seconds before the job will be forcibly terminated.\"",
            "        \"<br>Set to 0 to use Nautobot system default\",",
            "    )",
            "    task_queues = JSONArrayField(",
            "        base_field=models.CharField(max_length=100, blank=True),",
            "        default=list,",
            "        blank=True,",
            "        help_text=\"Comma separated list of task queues that this job can run on. A blank list will use the default queue\",",
            "    )",
            "",
            "    # Flags to indicate whether the above properties are inherited from the source code or overridden by the database",
            "    grouping_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured grouping will remain even if the underlying Job source code changes\",",
            "    )",
            "    name_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured name will remain even if the underlying Job source code changes\",",
            "    )",
            "    description_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured description will remain even if the underlying Job source code changes\",",
            "    )",
            "",
            "    approval_required_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    commit_default_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    hidden_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    read_only_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    soft_time_limit_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    time_limit_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    has_sensitive_variables_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "    task_queues_override = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If set, the configured value will remain even if the underlying Job source code changes\",",
            "    )",
            "",
            "    objects = JobQuerySet.as_manager()",
            "",
            "    class Meta:",
            "        managed = True",
            "        ordering = [\"grouping\", \"name\"]",
            "        unique_together = [",
            "            (\"source\", \"git_repository\", \"module_name\", \"job_class_name\"),",
            "            (\"grouping\", \"name\"),",
            "        ]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self._job_class = None",
            "        self._latest_result = None",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def validate_unique(self, exclude=None):",
            "        \"\"\"",
            "        Check for duplicate (source, module_name, job_class_name) in the case where git_repository is None.",
            "",
            "        This is needed because NULL != NULL and so the unique_together constraint will not flag this case.",
            "        \"\"\"",
            "        if self.git_repository is None:",
            "            if Job.objects.exclude(pk=self.pk).filter(",
            "                source=self.source, module_name=self.module_name, job_class_name=self.job_class_name",
            "            ):",
            "                raise ValidationError(",
            "                    {\"job_class_name\": \"A Job already exists with this source, module_name, and job_class_name\"}",
            "                )",
            "",
            "        super().validate_unique(exclude=exclude)",
            "",
            "    @property",
            "    def job_class(self):",
            "        \"\"\"Get the Job class (source code) associated with this Job model.\"\"\"",
            "        if not self.installed:",
            "            return None",
            "        if self._job_class is None:",
            "            if self.source == JobSourceChoices.SOURCE_LOCAL:",
            "                path = settings.JOBS_ROOT",
            "                for job_info in jobs_in_directory(settings.JOBS_ROOT, module_name=self.module_name):",
            "                    if job_info.job_class_name == self.job_class_name:",
            "                        self._job_class = job_info.job_class",
            "                        break",
            "                else:",
            "                    logger.warning(\"Module %s job class %s not found!\", self.module_name, self.job_class_name)",
            "            elif self.source == JobSourceChoices.SOURCE_GIT:",
            "                from nautobot.extras.datasources.git import ensure_git_repository",
            "",
            "                if self.git_repository is None:",
            "                    logger.warning(\"Job %s %s has no associated Git repository\", self.module_name, self.job_class_name)",
            "                    return None",
            "                try:",
            "                    # In the case where we have multiple Nautobot instances, or multiple worker instances,",
            "                    # they are not required to share a common filesystem; therefore, we may need to refresh our local",
            "                    # clone of the Git repository to ensure that it is in sync with the latest repository clone",
            "                    # from any instance.",
            "                    ensure_git_repository(",
            "                        self.git_repository,",
            "                        head=self.git_repository.current_head,",
            "                        logger=logger,",
            "                    )",
            "                    path = os.path.join(self.git_repository.filesystem_path, \"jobs\")",
            "                    for job_info in jobs_in_directory(path, module_name=self.module_name):",
            "                        if job_info.job_class_name == self.job_class_name:",
            "                            self._job_class = job_info.job_class",
            "                            break",
            "                    else:",
            "                        logger.warning(",
            "                            \"Module %s job class %s not found in repository %s\",",
            "                            self.module_name,",
            "                            self.job_class_name,",
            "                            self.git_repository,",
            "                        )",
            "                except ObjectDoesNotExist:",
            "                    return None",
            "                except Exception as exc:",
            "                    logger.error(f\"Error during local clone/refresh of Git repository {self.git_repository}: {exc}\")",
            "                    return None",
            "            elif self.source == JobSourceChoices.SOURCE_PLUGIN:",
            "                # pkgutil.resolve_name is only available in Python 3.9 and later",
            "                self._job_class = import_object(f\"{self.module_name}.{self.job_class_name}\")",
            "",
            "        return self._job_class",
            "",
            "    @property",
            "    def class_path(self):",
            "        if self.git_repository is not None:",
            "            return f\"{self.source}.{self.git_repository.slug}/{self.module_name}/{self.job_class_name}\"",
            "        return f\"{self.source}/{self.module_name}/{self.job_class_name}\"",
            "",
            "    @property",
            "    def latest_result(self):",
            "        \"\"\"",
            "        Return the most recent JobResult object associated with this Job.",
            "",
            "        Note that, as a performance optimization for this function's repeated use in",
            "        JobListview, the returned object only includes its `status` field.",
            "        \"\"\"",
            "        if self._latest_result is None:",
            "            self._latest_result = self.results.only(\"status\").first()",
            "        return self._latest_result",
            "",
            "    @property",
            "    def description_first_line(self):",
            "        return self.description.splitlines()[0]",
            "",
            "    @property",
            "    def runnable(self):",
            "        return (",
            "            self.enabled",
            "            and self.installed",
            "            and self.job_class is not None",
            "            and not (self.has_sensitive_variables and self.approval_required)",
            "        )",
            "",
            "    def clean(self):",
            "        \"\"\"For any non-overridden fields, make sure they get reset to the actual underlying class value if known.\"\"\"",
            "        if self.job_class is not None:",
            "            for field_name in JOB_OVERRIDABLE_FIELDS:",
            "                if not getattr(self, f\"{field_name}_override\", False):",
            "                    setattr(self, field_name, getattr(self.job_class, field_name))",
            "",
            "        if self.git_repository is not None and self.source != JobSourceChoices.SOURCE_GIT:",
            "            raise ValidationError('A Git repository may only be specified when the source is \"git\"')",
            "",
            "        # Protect against invalid input when auto-creating Job records",
            "        if len(self.source) > JOB_MAX_SOURCE_LENGTH:",
            "            raise ValidationError(f\"Source may not exceed {JOB_MAX_SOURCE_LENGTH} characters in length\")",
            "        if len(self.module_name) > JOB_MAX_NAME_LENGTH:",
            "            raise ValidationError(f\"Module name may not exceed {JOB_MAX_NAME_LENGTH} characters in length\")",
            "        if len(self.job_class_name) > JOB_MAX_NAME_LENGTH:",
            "            raise ValidationError(f\"Job class name may not exceed {JOB_MAX_NAME_LENGTH} characters in length\")",
            "        if len(self.grouping) > JOB_MAX_GROUPING_LENGTH:",
            "            raise ValidationError(\"Grouping may not exceed {JOB_MAX_GROUPING_LENGTH} characters in length\")",
            "        if len(self.name) > JOB_MAX_NAME_LENGTH:",
            "            raise ValidationError(f\"Name may not exceed {JOB_MAX_NAME_LENGTH} characters in length\")",
            "        if len(self.slug) > JOB_MAX_SLUG_LENGTH:",
            "            raise ValidationError(f\"Slug may not exceed {JOB_MAX_SLUG_LENGTH} characters in length\")",
            "",
            "        if self.has_sensitive_variables is True and self.approval_required is True:",
            "            raise ValidationError(",
            "                {\"approval_required\": \"A job that may have sensitive variables cannot be marked as requiring approval\"}",
            "            )",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:job_detail\", kwargs={\"slug\": self.slug})",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class JobHook(OrganizationalModel):",
            "    \"\"\"",
            "    A job hook defines a request that will trigger a job hook receiver when an object is created, updated, and/or",
            "    deleted in Nautobot. Each job hook can be limited to firing only on certain actions or certain object types.",
            "    \"\"\"",
            "",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"job_hooks\",",
            "        verbose_name=\"Object types\",",
            "        # 2.0 TODO: standardize verbose name for ContentType fields",
            "        limit_choices_to=ChangeLoggedModelsQuery,",
            "        help_text=\"The object(s) to which this job hook applies.\",",
            "    )",
            "    enabled = models.BooleanField(default=True)",
            "    job = models.ForeignKey(",
            "        to=Job,",
            "        related_name=\"job_hook\",",
            "        verbose_name=\"Job\",",
            "        help_text=\"The job that this job hook will initiate\",",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to={\"is_job_hook_receiver\": True},",
            "    )",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    type_create = models.BooleanField(default=False, help_text=\"Call this job hook when a matching object is created.\")",
            "    type_delete = models.BooleanField(default=False, help_text=\"Call this job hook when a matching object is deleted.\")",
            "    type_update = models.BooleanField(default=False, help_text=\"Call this job hook when a matching object is updated.\")",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # At least one action type must be selected",
            "        if not self.type_create and not self.type_delete and not self.type_update:",
            "            raise ValidationError(\"You must select at least one type: create, update, and/or delete.\")",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:jobhook\", kwargs={\"slug\": self.slug})",
            "",
            "    @classmethod",
            "    def check_for_conflicts(",
            "        cls, instance=None, content_types=None, job=None, type_create=None, type_update=None, type_delete=None",
            "    ):",
            "        \"\"\"",
            "        Helper method for enforcing uniqueness.",
            "",
            "        Don't allow two job hooks with the same content_type, same job, and any action(s) in common.",
            "        Called by JobHookForm.clean() and JobHookSerializer.validate()",
            "        \"\"\"",
            "",
            "        conflicts = {}",
            "        job_hook_error_msg = \"A job hook already exists for {action} on {content_type} to job {job}\"",
            "",
            "        if instance is not None and instance.present_in_database:",
            "            # This is a PATCH and might not include all relevant data",
            "            # Therefore we get data not available from instance",
            "            content_types = instance.content_types.all() if content_types is None else content_types",
            "            type_create = instance.type_create if type_create is None else type_create",
            "            type_update = instance.type_update if type_update is None else type_update",
            "            type_delete = instance.type_delete if type_delete is None else type_delete",
            "",
            "        if content_types is not None:",
            "            for content_type in content_types:",
            "                job_hooks = cls.objects.filter(content_types__in=[content_type], job=job)",
            "                if instance and instance.present_in_database:",
            "                    job_hooks = job_hooks.exclude(pk=instance.pk)",
            "",
            "                existing_type_create = job_hooks.filter(type_create=type_create).exists() if type_create else False",
            "                existing_type_update = job_hooks.filter(type_update=type_update).exists() if type_update else False",
            "                existing_type_delete = job_hooks.filter(type_delete=type_delete).exists() if type_delete else False",
            "",
            "                if existing_type_create:",
            "                    conflicts.setdefault(\"type_create\", []).append(",
            "                        job_hook_error_msg.format(content_type=content_type, action=\"create\", job=job),",
            "                    )",
            "",
            "                if existing_type_update:",
            "                    conflicts.setdefault(\"type_update\", []).append(",
            "                        job_hook_error_msg.format(content_type=content_type, action=\"update\", job=job),",
            "                    )",
            "",
            "                if existing_type_delete:",
            "                    conflicts.setdefault(\"type_delete\", []).append(",
            "                        job_hook_error_msg.format(content_type=content_type, action=\"delete\", job=job),",
            "                    )",
            "",
            "        return conflicts",
            "",
            "",
            "@extras_features(",
            "    \"graphql\",",
            ")",
            "class JobLogEntry(BaseModel):",
            "    \"\"\"Stores each log entry for the JobResult.\"\"\"",
            "",
            "    job_result = models.ForeignKey(to=\"extras.JobResult\", on_delete=models.CASCADE, related_name=\"logs\")",
            "    log_level = models.CharField(",
            "        max_length=32, choices=LogLevelChoices, default=LogLevelChoices.LOG_DEFAULT, db_index=True",
            "    )",
            "    grouping = models.CharField(max_length=JOB_LOG_MAX_GROUPING_LENGTH, default=\"main\")",
            "    message = models.TextField(blank=True)",
            "    created = models.DateTimeField(default=timezone.now)",
            "    # Storing both of the below as strings instead of using GenericForeignKey to support",
            "    # compatibility with existing JobResult logs. GFK would pose a problem with dangling foreign-key",
            "    # references, whereas this allows us to retain all records for as long as the entry exists.",
            "    # This also simplifies migration from the JobResult Data field as these were stored as strings.",
            "    log_object = models.CharField(max_length=JOB_LOG_MAX_LOG_OBJECT_LENGTH, null=True, blank=True)",
            "    absolute_url = models.CharField(max_length=JOB_LOG_MAX_ABSOLUTE_URL_LENGTH, null=True, blank=True)",
            "",
            "    csv_headers = [\"created\", \"grouping\", \"log_level\", \"log_object\", \"message\"]",
            "",
            "    def __str__(self):",
            "        return self.message",
            "",
            "    class Meta:",
            "        ordering = [\"created\"]",
            "        get_latest_by = \"created\"",
            "        verbose_name_plural = \"job log entries\"",
            "",
            "    def to_csv(self):",
            "        \"\"\"Indicates model fields to return as csv.\"\"\"",
            "        return (str(self.created), self.grouping, self.log_level, self.log_object, self.message)",
            "",
            "",
            "#",
            "# Job results",
            "#",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"graphql\",",
            ")",
            "class JobResult(BaseModel, CustomFieldModel):",
            "    \"\"\"",
            "    This model stores the results from running a Job.",
            "    \"\"\"",
            "",
            "    # Note that we allow job_model to be null and use models.SET_NULL here.",
            "    # This is because we want to be able to keep JobResult records for tracking and auditing purposes even after",
            "    # deleting the corresponding Job record.",
            "    job_model = models.ForeignKey(",
            "        to=\"extras.Job\", null=True, blank=True, on_delete=models.SET_NULL, related_name=\"results\"",
            "    )",
            "",
            "    name = models.CharField(max_length=255, db_index=True)",
            "    obj_type = models.ForeignKey(",
            "        to=ContentType,",
            "        related_name=\"job_results\",",
            "        verbose_name=\"Object types\",",
            "        limit_choices_to=FeatureQuery(\"job_results\"),",
            "        help_text=\"The object type to which this job result applies\",",
            "        on_delete=models.CASCADE,",
            "    )",
            "    created = models.DateTimeField(auto_now_add=True, db_index=True)",
            "    completed = models.DateTimeField(null=True, blank=True, db_index=True)",
            "    user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, related_name=\"+\", blank=True, null=True",
            "    )",
            "    # todoindex:",
            "    status = models.CharField(",
            "        max_length=30,",
            "        choices=JobResultStatusChoices,",
            "        default=JobResultStatusChoices.STATUS_PENDING,",
            "    )",
            "    data = models.JSONField(encoder=DjangoJSONEncoder, null=True, blank=True)",
            "    job_kwargs = models.JSONField(blank=True, null=True, encoder=NautobotKombuJSONEncoder)",
            "    schedule = models.ForeignKey(to=\"extras.ScheduledJob\", on_delete=models.SET_NULL, null=True, blank=True)",
            "    \"\"\"",
            "    Although \"data\" is technically an unstructured field, we have a standard structure that we try to adhere to.",
            "",
            "    This structure is created loosely as a superset of the formats used by Scripts and Reports in NetBox 2.10.",
            "",
            "    Log Messages now go to their own object, the JobLogEntry.",
            "",
            "    data = {",
            "        \"output\": <optional string, such as captured stdout/stderr>,",
            "    }",
            "    \"\"\"",
            "",
            "    job_id = models.UUIDField(unique=True)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.use_job_logs_db = True",
            "",
            "    class Meta:",
            "        ordering = [\"-created\"]",
            "        get_latest_by = \"created\"",
            "        indexes = [",
            "            models.Index(",
            "                name=\"extras_jobresult_rcreated_idx\",",
            "                fields=[\"-created\"],",
            "            ),",
            "            models.Index(",
            "                name=\"extras_jr_rcompleted_idx\",",
            "                fields=[\"-completed\"],",
            "            ),",
            "            models.Index(",
            "                name=\"extras_jr_statrcreate_idx\",",
            "                fields=[\"status\", \"-created\"],",
            "            ),",
            "            models.Index(",
            "                name=\"extras_jr_statrcompl_idx\",",
            "                fields=[\"status\", \"-completed\"],",
            "            ),",
            "        ]",
            "",
            "    def __str__(self):",
            "        return str(self.job_id)",
            "",
            "    @property",
            "    def duration(self):",
            "        if not self.completed:",
            "            return None",
            "",
            "        duration = self.completed - self.created",
            "        minutes, seconds = divmod(duration.total_seconds(), 60)",
            "",
            "        return f\"{int(minutes)} minutes, {seconds:.2f} seconds\"",
            "",
            "    @property",
            "    def related_object(self):",
            "        \"\"\"Get the related object, if any, identified by the `obj_type`, `name`, and/or `job_id` fields.",
            "",
            "        If `obj_type` is extras.Job, then the `name` is used to look up an extras.jobs.Job subclass based on the",
            "        `class_path` of the Job subclass.",
            "        Note that this is **not** the extras.models.Job model class nor an instance thereof.",
            "",
            "        Else, if the the model class referenced by `obj_type` has a `name` field, our `name` field will be used",
            "        to look up a corresponding model instance. This is used, for example, to look up a related `GitRepository`;",
            "        more generally it can be used by any model that 1) has a unique `name` field and 2) needs to have a many-to-one",
            "        relationship between JobResults and model instances.",
            "",
            "        Else, the `obj_type` and `job_id` will be used together as a quasi-GenericForeignKey to look up a model",
            "        instance whose PK corresponds to the `job_id`. This behavior is currently unused in the Nautobot core,",
            "        but may be of use to plugin developers wishing to create JobResults that have a one-to-one relationship",
            "        to plugin model instances.",
            "",
            "        This method is potentially rather slow as get_job() may need to actually load the Job class from disk;",
            "        consider carefully whether you actually need to use it.",
            "        \"\"\"",
            "        from nautobot.extras.jobs import get_job  # needed here to avoid a circular import issue",
            "",
            "        if self.obj_type == get_job_content_type():",
            "            # Related object is an extras.Job subclass, our `name` matches its `class_path`",
            "            return get_job(self.name)",
            "",
            "        model_class = self.obj_type.model_class()",
            "",
            "        if model_class is not None:",
            "            if hasattr(model_class, \"name\"):",
            "                # See if we have a many-to-one relationship from JobResult to model_class record, based on `name`",
            "                try:",
            "                    return model_class.objects.get(name=self.name)",
            "                except model_class.DoesNotExist:",
            "                    pass",
            "",
            "            # See if we have a one-to-one relationship from JobResult to model_class record based on `job_id`",
            "            try:",
            "                return model_class.objects.get(id=self.job_id)",
            "            except model_class.DoesNotExist:",
            "                pass",
            "",
            "        return None",
            "",
            "    @property",
            "    def related_name(self):",
            "        \"\"\"",
            "        A human-friendlier \"name\" for the Job Result.",
            "",
            "        This is commonly the name for extras.Job based jobs, but if the definition of the Job",
            "        or in cases of Git Repositories or other Related Objects there is no Job name definition available.",
            "",
            "        Properly handle those cases.",
            "        \"\"\"",
            "        if self.job_model:",
            "            # No need to call related_object(), getting the Job class name if we already have a job_model",
            "            return self.job_model.name",
            "        elif self.obj_type == get_job_content_type():",
            "            # Related object is an extras.Job subclass but the Job Model has been deleted",
            "            # Calling self.related_object will call ensure_git_repository() but will ultimately return None",
            "            return self.name",
            "",
            "        # At this point related_object is likely a GitRepository",
            "        related_object = self.related_object",
            "        if not related_object:",
            "            return self.name",
            "        if hasattr(related_object, \"name\"):",
            "            return related_object.name",
            "        return str(related_object)",
            "",
            "    @property",
            "    def linked_record(self):",
            "        \"\"\"",
            "        A newer alternative to self.related_object that looks up an extras.models.Job instead of an extras.jobs.Job.",
            "        \"\"\"",
            "        if self.job_model is not None:",
            "            return self.job_model",
            "        model_class = self.obj_type.model_class()",
            "        if model_class is not None:",
            "            if hasattr(model_class, \"name\"):",
            "                try:",
            "                    return model_class.objects.get(name=self.name)",
            "                except model_class.DoesNotExist:",
            "                    pass",
            "            if hasattr(model_class, \"class_path\"):",
            "                try:",
            "                    return model_class.objects.get(class_path=self.name)",
            "                except model_class.DoesNotExist:",
            "                    pass",
            "        return None",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:jobresult\", kwargs={\"pk\": self.pk})",
            "",
            "    def set_status(self, status):",
            "        \"\"\"",
            "        Helper method to change the status of the job result. If the target status is terminal, the  completion",
            "        time is also set.",
            "        \"\"\"",
            "        self.status = status",
            "        if status in JobResultStatusChoices.TERMINAL_STATE_CHOICES:",
            "            # Only add metrics if we have a related job model. If we are moving to a terminal state we should always",
            "            # have a related job model, so this shouldn't be too tight of a restriction.",
            "            self.completed = timezone.now()",
            "            if self.job_model:",
            "                duration = self.completed - self.created",
            "                JOB_RESULT_METRIC.labels(self.job_model.grouping, self.job_model.name, status).observe(",
            "                    duration.total_seconds()",
            "                )",
            "",
            "    @classmethod",
            "    def enqueue_job(cls, func, name, obj_type, user, *args, celery_kwargs=None, schedule=None, **kwargs):",
            "        \"\"\"",
            "        Create a JobResult instance and enqueue a job using the given callable",
            "",
            "        func: The callable object to be enqueued for execution",
            "        name: Name for the JobResult instance - corresponds to the desired Job class's \"class_path\" attribute,",
            "            if obj_type is extras.Job; for other funcs and obj_types it may differ.",
            "        obj_type: ContentType to link to the JobResult instance obj_type",
            "        user: User object to link to the JobResult instance",
            "        celery_kwargs: Dictionary of kwargs to pass as **kwargs to Celery when job is queued",
            "        args: additional args passed to the callable",
            "        schedule: Optional ScheduledJob instance to link to the JobResult",
            "        kwargs: additional kwargs passed to the callable",
            "        \"\"\"",
            "        # Discard \"request\" parameter from the kwargs that we save in the job_result, as it's not relevant to re-runs,",
            "        # and will likely go away in the future.",
            "        job_result_kwargs = {key: value for key, value in kwargs.items() if key != \"request\"}",
            "        job_result = cls.objects.create(",
            "            name=name,",
            "            obj_type=obj_type,",
            "            user=user,",
            "            job_id=uuid.uuid4(),",
            "            schedule=schedule,",
            "        )",
            "",
            "        kwargs[\"job_result_pk\"] = job_result.pk",
            "",
            "        # Prepare kwargs that will be sent to Celery",
            "        if celery_kwargs is None:",
            "            celery_kwargs = {}",
            "",
            "        if obj_type.app_label == \"extras\" and obj_type.model.lower() == \"job\":",
            "            try:",
            "                job_model = Job.objects.get_for_class_path(name)",
            "                if job_model.soft_time_limit > 0:",
            "                    celery_kwargs[\"soft_time_limit\"] = job_model.soft_time_limit",
            "                if job_model.time_limit > 0:",
            "                    celery_kwargs[\"time_limit\"] = job_model.time_limit",
            "                if not job_model.has_sensitive_variables:",
            "                    job_result.job_kwargs = job_result_kwargs",
            "                job_result.job_model = job_model",
            "                job_result.save()",
            "            except Job.DoesNotExist:",
            "                # 2.0 TODO: remove this fallback logic, database records should always exist",
            "                from nautobot.extras.jobs import get_job  # needed here to avoid a circular import issue",
            "",
            "                job_class = get_job(name)",
            "                if job_class is not None:",
            "                    logger.error(\"No Job instance found in the database corresponding to %s\", name)",
            "                    if hasattr(job_class.Meta, \"soft_time_limit\"):",
            "                        celery_kwargs[\"soft_time_limit\"] = job_class.Meta.soft_time_limit",
            "                    if hasattr(job_class.Meta, \"time_limit\"):",
            "                        celery_kwargs[\"time_limit\"] = job_class.Meta.time_limit",
            "                    if not job_class.has_sensitive_variables:",
            "                        job_result.job_kwargs = job_result_kwargs",
            "                        job_result.save()",
            "                else:",
            "                    logger.error(\"Neither a Job database record nor a Job source class were found for %s\", name)",
            "",
            "        # Jobs queued inside of a transaction need to run after the transaction completes and the JobResult is saved to the database",
            "        transaction.on_commit(",
            "            lambda: func.apply_async(args=args, kwargs=kwargs, task_id=str(job_result.job_id), **celery_kwargs)",
            "        )",
            "",
            "        return job_result",
            "",
            "    def log(",
            "        self,",
            "        message,",
            "        obj=None,",
            "        level_choice=LogLevelChoices.LOG_DEFAULT,",
            "        grouping=\"main\",",
            "        logger=None,  # pylint: disable=redefined-outer-name",
            "    ):",
            "        \"\"\"",
            "        General-purpose API for storing log messages in a JobResult's 'data' field.",
            "",
            "        message (str): Message to log (an attempt will be made to sanitize sensitive information from this message)",
            "        obj (object): Object associated with this message, if any",
            "        level_choice (LogLevelChoices): Message severity level",
            "        grouping (str): Grouping to store the log message under",
            "        logger (logging.logger): Optional logger to also output the message to",
            "        \"\"\"",
            "        if level_choice not in LogLevelChoices.as_dict():",
            "            raise ValueError(f\"Unknown logging level: {level_choice}\")",
            "",
            "        message = sanitize(str(message))",
            "",
            "        obj_absolute_url = None",
            "        if obj is not None and hasattr(obj, \"get_absolute_url\"):",
            "            try:",
            "                absolute_url = obj.get_absolute_url()",
            "                # If absolute_url is longer than we can store, we discard it instead of truncating,",
            "                # since a truncated URL is pretty useless.",
            "                if len(absolute_url) <= JOB_LOG_MAX_ABSOLUTE_URL_LENGTH:",
            "                    obj_absolute_url = absolute_url",
            "            except Exception:",
            "                pass",
            "",
            "        log = JobLogEntry(",
            "            job_result=self,",
            "            log_level=level_choice,",
            "            grouping=grouping[:JOB_LOG_MAX_GROUPING_LENGTH],",
            "            message=message,",
            "            created=timezone.now().isoformat(),",
            "            log_object=str(obj)[:JOB_LOG_MAX_LOG_OBJECT_LENGTH] if obj else None,",
            "            absolute_url=obj_absolute_url,",
            "        )",
            "",
            "        # If the override is provided, we want to use the default database(pass no using argument)",
            "        # Otherwise we want to use a separate database here so that the logs are created immediately",
            "        # instead of within transaction.atomic(). This allows us to be able to report logs when the jobs",
            "        # are running, and allow us to rollback the database without losing the log entries.",
            "        if not self.use_job_logs_db or not JOB_LOGS:",
            "            log.save()",
            "        else:",
            "            log.save(using=JOB_LOGS)",
            "",
            "        if logger:",
            "            if level_choice == LogLevelChoices.LOG_FAILURE:",
            "                log_level = logging.ERROR",
            "            elif level_choice == LogLevelChoices.LOG_WARNING:",
            "                log_level = logging.WARNING",
            "            else:",
            "                log_level = logging.INFO",
            "            logger.log(log_level, message)",
            "",
            "        return log",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class JobButton(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    A predefined button that includes all necessary information to run a Nautobot Job based on a single object as a source.",
            "    The button text field accepts Jinja2 template code to be rendered with an object as context.",
            "    \"\"\"",
            "",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"job_buttons\",",
            "        verbose_name=\"Object types\",",
            "        help_text=\"The object type(s) to which this job button applies.\",",
            "    )",
            "    name = models.CharField(max_length=100, unique=True)",
            "    text = models.CharField(",
            "        max_length=500,",
            "        help_text=\"Jinja2 template code for button text. Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>. Buttons which render as empty text will not be displayed.\",",
            "    )",
            "    job = models.ForeignKey(",
            "        to=\"extras.Job\",",
            "        on_delete=models.CASCADE,",
            "        help_text=\"Job this button will run\",",
            "        limit_choices_to={\"is_job_button_receiver\": True},",
            "    )",
            "    weight = models.PositiveSmallIntegerField(default=100)",
            "    group_name = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        help_text=\"Buttons with the same group will appear as a dropdown menu. Group dropdown buttons will inherit the button class from the button with the lowest weight in the group.\",",
            "    )",
            "    button_class = models.CharField(",
            "        max_length=30,",
            "        choices=ButtonClassChoices,",
            "        default=ButtonClassChoices.CLASS_DEFAULT,",
            "    )",
            "    confirmation = models.BooleanField(",
            "        help_text=\"Enable confirmation pop-up box. <span class='text-danger'>WARNING: unselecting this option will allow the Job to run (and commit changes) with a single click!</span>\",",
            "        default=True,",
            "    )",
            "",
            "    class Meta:",
            "        ordering = [\"group_name\", \"weight\", \"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:jobbutton\", kwargs={\"pk\": self.pk})",
            "",
            "",
            "class ScheduledJobs(models.Model):",
            "    \"\"\"Helper table for tracking updates to scheduled tasks.",
            "    This stores a single row with ident=1.  last_update is updated",
            "    via django signals whenever anything is changed in the ScheduledJob model.",
            "    Basically this acts like a DB data audit trigger.",
            "    Doing this so we also track deletions, and not just insert/update.",
            "    \"\"\"",
            "",
            "    ident = models.SmallIntegerField(default=1, primary_key=True, unique=True)",
            "    last_update = models.DateTimeField(null=False)",
            "",
            "    objects = ExtendedManager()",
            "",
            "    @classmethod",
            "    def changed(cls, instance, raw=False, **kwargs):",
            "        \"\"\"This function acts as a signal handler to track changes to the scheduled job that is triggered before a change\"\"\"",
            "        if raw:",
            "            return",
            "        if not instance.no_changes:",
            "            cls.update_changed()",
            "",
            "    @classmethod",
            "    def update_changed(cls, raw=False, **kwargs):",
            "        \"\"\"This function acts as a signal handler to track changes to the scheduled job that is triggered after a change\"\"\"",
            "        if raw:",
            "            return",
            "        cls.objects.update_or_create(ident=1, defaults={\"last_update\": timezone.now()})",
            "",
            "    @classmethod",
            "    def last_change(cls):",
            "        \"\"\"This function acts as a getter for the last update on scheduled jobs\"\"\"",
            "        try:",
            "            return cls.objects.get(ident=1).last_update",
            "        except cls.DoesNotExist:",
            "            return None",
            "",
            "",
            "class ScheduledJob(BaseModel):",
            "    \"\"\"Model representing a periodic task.\"\"\"",
            "",
            "    name = models.CharField(",
            "        max_length=200, verbose_name=\"Name\", help_text=\"Short Description For This Task\", db_index=True",
            "    )",
            "    task = models.CharField(",
            "        max_length=200,",
            "        verbose_name=\"Task Name\",",
            "        help_text='The name of the Celery task that should be run. (Example: \"proj.tasks.import_contacts\")',",
            "        db_index=True,",
            "    )",
            "    # Note that we allow job_model to be null and use models.SET_NULL here.",
            "    # This is because we want to be able to keep ScheduledJob records for tracking and auditing purposes even after",
            "    # deleting the corresponding Job record.",
            "    job_model = models.ForeignKey(",
            "        to=\"extras.Job\", null=True, blank=True, on_delete=models.SET_NULL, related_name=\"scheduled_jobs\"",
            "    )",
            "    job_class = models.CharField(",
            "        max_length=255,",
            "        verbose_name=\"Job Class\",",
            "        help_text=\"Name of the fully qualified Nautobot Job class path\",",
            "        db_index=True,",
            "    )",
            "    interval = models.CharField(choices=JobExecutionType, max_length=255)",
            "    args = models.JSONField(blank=True, default=list, encoder=NautobotKombuJSONEncoder)",
            "    kwargs = models.JSONField(blank=True, default=dict, encoder=NautobotKombuJSONEncoder)",
            "    queue = models.CharField(",
            "        max_length=200,",
            "        blank=True,",
            "        null=True,",
            "        default=None,",
            "        verbose_name=\"Queue Override\",",
            "        help_text=\"Queue defined in CELERY_TASK_QUEUES. Leave None for default queuing.\",",
            "        db_index=True,",
            "    )",
            "    one_off = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"One-off Task\",",
            "        help_text=\"If True, the schedule will only run the task a single time\",",
            "    )",
            "    start_time = models.DateTimeField(",
            "        verbose_name=\"Start Datetime\",",
            "        help_text=\"Datetime when the schedule should begin triggering the task to run\",",
            "    )",
            "    # todoindex:",
            "    enabled = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"Enabled\",",
            "        help_text=\"Set to False to disable the schedule\",",
            "    )",
            "    last_run_at = models.DateTimeField(",
            "        editable=False,",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Most Recent Run\",",
            "        help_text=\"Datetime that the schedule last triggered the task to run. \"",
            "        \"Reset to None if enabled is set to False.\",",
            "    )",
            "    total_run_count = models.PositiveIntegerField(",
            "        default=0,",
            "        editable=False,",
            "        verbose_name=\"Total Run Count\",",
            "        help_text=\"Running count of how many times the schedule has triggered the task\",",
            "    )",
            "    date_changed = models.DateTimeField(",
            "        auto_now=True,",
            "        verbose_name=\"Last Modified\",",
            "        help_text=\"Datetime that this scheduled job was last modified\",",
            "    )",
            "    description = models.TextField(",
            "        blank=True,",
            "        verbose_name=\"Description\",",
            "        help_text=\"Detailed description about the details of this scheduled job\",",
            "    )",
            "    user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL,",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"+\",",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"User that requested the schedule\",",
            "    )",
            "    approved_by_user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL,",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"+\",",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"User that approved the schedule\",",
            "    )",
            "    # todoindex:",
            "    approval_required = models.BooleanField(default=False)",
            "    approved_at = models.DateTimeField(",
            "        editable=False,",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Approval date/time\",",
            "        help_text=\"Datetime that the schedule was approved\",",
            "    )",
            "    crontab = models.CharField(",
            "        max_length=255,",
            "        blank=True,",
            "        verbose_name=\"Custom cronjob\",",
            "        help_text=\"Cronjob syntax string for custom scheduling\",",
            "    )",
            "",
            "    objects = ScheduledJobExtendedQuerySet.as_manager()",
            "    no_changes = False",
            "",
            "    def __str__(self):",
            "        return f\"{self.name}: {self.interval}\"",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:scheduledjob\", kwargs={\"pk\": self.pk})",
            "",
            "    def save(self, *args, **kwargs):",
            "        self.queue = self.queue or None",
            "        # pass pk to worker task in kwargs, celery doesn't provide the full object to the worker",
            "        self.kwargs[\"scheduled_job_pk\"] = self.pk",
            "        # make sure non-valid crontab doesn't get saved",
            "        if self.interval == JobExecutionType.TYPE_CUSTOM:",
            "            try:",
            "                self.get_crontab(self.crontab)",
            "            except Exception as e:",
            "                raise ValidationError({\"crontab\": e})",
            "        if not self.enabled:",
            "            self.last_run_at = None",
            "        elif not self.last_run_at:",
            "            # I'm not sure if this is a bug, or \"works as designed\", but if self.last_run_at is not set,",
            "            # the celery beat scheduler will never pick up a recurring job. One-off jobs work just fine though.",
            "            if self.interval in [",
            "                JobExecutionType.TYPE_HOURLY,",
            "                JobExecutionType.TYPE_DAILY,",
            "                JobExecutionType.TYPE_WEEKLY,",
            "            ]:",
            "                # A week is 7 days, otherwise the iteration is set to 1",
            "                multiplier = 7 if self.interval == JobExecutionType.TYPE_WEEKLY else 1",
            "                # Set the \"last run at\" time to one interval before the scheduled start time",
            "                self.last_run_at = self.start_time - timedelta(",
            "                    **{JobExecutionType.CELERY_INTERVAL_MAP[self.interval]: multiplier},",
            "                )",
            "",
            "        super().save(*args, **kwargs)",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Model Validation",
            "        \"\"\"",
            "        if self.user and self.approved_by_user and self.user == self.approved_by_user:",
            "            raise ValidationError(\"The requesting and approving users cannot be the same\")",
            "        # bitwise xor also works on booleans, but not on complex values",
            "        if bool(self.approved_by_user) ^ bool(self.approved_at):",
            "            raise ValidationError(\"Approval by user and approval time must either both be set or both be undefined\")",
            "",
            "    @property",
            "    def schedule(self):",
            "        if self.interval == JobExecutionType.TYPE_FUTURE:",
            "            # This is one-time clocked task",
            "            return clocked(clocked_time=self.start_time)",
            "",
            "        return self.to_cron()",
            "",
            "    @staticmethod",
            "    def earliest_possible_time():",
            "        return timezone.now() + timedelta(seconds=15)",
            "",
            "    @classmethod",
            "    def get_crontab(cls, crontab):",
            "        \"\"\"",
            "        Wrapper method translates crontab syntax to Celery crontab.",
            "",
            "        Supports following symbols:",
            "",
            "        \u2022 Asterisk (*) - signifies all possible values",
            "        \u2022 Comma (,) - lists multiple values",
            "        \u2022 Hyphen (-) - determine a range of values",
            "        \u2022 Slash (/) - divide a value ({*/15 * * * *} runs every 15 minutes)",
            "",
            "        No support for Last (L), Weekday (W), Number symbol (#), Question mark (?), and special @ strings.",
            "        \"\"\"",
            "        minute, hour, day_of_month, month_of_year, day_of_week = crontab.split(\" \")",
            "        return schedules.crontab(",
            "            minute=minute,",
            "            hour=hour,",
            "            day_of_month=day_of_month,",
            "            month_of_year=month_of_year,",
            "            day_of_week=day_of_week,",
            "        )",
            "",
            "    def to_cron(self):",
            "        t = self.start_time",
            "        if self.interval == JobExecutionType.TYPE_HOURLY:",
            "            return schedules.crontab(minute=t.minute)",
            "        elif self.interval == JobExecutionType.TYPE_DAILY:",
            "            return schedules.crontab(minute=t.minute, hour=t.hour)",
            "        elif self.interval == JobExecutionType.TYPE_WEEKLY:",
            "            return schedules.crontab(minute=t.minute, hour=t.hour, day_of_week=t.strftime(\"%w\"))",
            "        elif self.interval == JobExecutionType.TYPE_CUSTOM:",
            "            return self.get_crontab(self.crontab)",
            "        raise ValueError(f\"I do not know to convert {self.interval} to a Cronjob!\")",
            "",
            "",
            "signals.pre_delete.connect(ScheduledJobs.changed, sender=ScheduledJob)",
            "signals.pre_save.connect(ScheduledJobs.changed, sender=ScheduledJob)",
            "signals.post_save.connect(ScheduledJobs.update_changed, sender=ScheduledJob)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "143": [
                "Job"
            ]
        },
        "addLocation": []
    },
    "nautobot/utilities/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from copy import deepcopy"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import nh3"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " #"
            },
            "5": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " # Filter lookup expressions"
            },
            "6": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " #"
            },
            "7": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " FILTER_NEGATION_LOOKUP_MAP = {\"n\": \"exact\"}"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+#"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+# User input sanitization"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+#"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+# Subset of the HTML tags allowed by default by ammonia:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+# https://github.com/rust-ammonia/ammonia/blob/master/src/lib.rs"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+HTML_ALLOWED_TAGS = nh3.ALLOWED_TAGS - {"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    # no image maps at present"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    \"area\","
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    \"map\","
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    # no document-level markup at present"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    \"article\","
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    \"aside\","
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    \"footer\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    \"header\","
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    \"nav\","
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    # miscellaneous out-of-scope for now"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    \"data\","
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    \"dfn\","
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    \"figcaption\","
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    \"figure\","
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+}"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+# Variant of the HTML attributes allowed by default by ammonia:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+# https://github.com/rust-ammonia/ammonia/blob/master/src/lib.rs"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+# at present we just copy nh3.ALLOWED_ATTRIBUTES but we can modify this later as desired and appropriate"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+HTML_ALLOWED_ATTRIBUTES = deepcopy(nh3.ALLOWED_ATTRIBUTES)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " #"
            },
            "40": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " # HTTP Request META safe copy"
            },
            "41": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " #"
            }
        },
        "frontPatchFile": [
            "#",
            "# Filter lookup expressions",
            "#",
            "",
            "FILTER_CHAR_BASED_LOOKUP_MAP = {",
            "    \"n\": \"exact\",",
            "    \"ic\": \"icontains\",",
            "    \"nic\": \"icontains\",",
            "    \"iew\": \"iendswith\",",
            "    \"niew\": \"iendswith\",",
            "    \"isw\": \"istartswith\",",
            "    \"nisw\": \"istartswith\",",
            "    \"ie\": \"iexact\",",
            "    \"nie\": \"iexact\",",
            "    \"re\": \"regex\",",
            "    \"nre\": \"regex\",",
            "    \"ire\": \"iregex\",",
            "    \"nire\": \"iregex\",",
            "}",
            "",
            "FILTER_NUMERIC_BASED_LOOKUP_MAP = {",
            "    \"n\": \"exact\",",
            "    \"lte\": \"lte\",",
            "    \"lt\": \"lt\",",
            "    \"gte\": \"gte\",",
            "    \"gt\": \"gt\",",
            "}",
            "",
            "FILTER_NEGATION_LOOKUP_MAP = {\"n\": \"exact\"}",
            "",
            "",
            "#",
            "# HTTP Request META safe copy",
            "#",
            "",
            "HTTP_REQUEST_META_SAFE_COPY = [",
            "    \"CONTENT_LENGTH\",",
            "    \"CONTENT_TYPE\",",
            "    \"HTTP_ACCEPT\",",
            "    \"HTTP_ACCEPT_ENCODING\",",
            "    \"HTTP_ACCEPT_LANGUAGE\",",
            "    \"HTTP_HOST\",",
            "    \"HTTP_REFERER\",",
            "    \"HTTP_USER_AGENT\",",
            "    \"QUERY_STRING\",",
            "    \"REMOTE_ADDR\",",
            "    \"REMOTE_HOST\",",
            "    \"REMOTE_USER\",",
            "    \"REQUEST_METHOD\",",
            "    \"SERVER_NAME\",",
            "    \"SERVER_PORT\",",
            "]"
        ],
        "afterPatchFile": [
            "from copy import deepcopy",
            "",
            "import nh3",
            "",
            "#",
            "# Filter lookup expressions",
            "#",
            "",
            "FILTER_CHAR_BASED_LOOKUP_MAP = {",
            "    \"n\": \"exact\",",
            "    \"ic\": \"icontains\",",
            "    \"nic\": \"icontains\",",
            "    \"iew\": \"iendswith\",",
            "    \"niew\": \"iendswith\",",
            "    \"isw\": \"istartswith\",",
            "    \"nisw\": \"istartswith\",",
            "    \"ie\": \"iexact\",",
            "    \"nie\": \"iexact\",",
            "    \"re\": \"regex\",",
            "    \"nre\": \"regex\",",
            "    \"ire\": \"iregex\",",
            "    \"nire\": \"iregex\",",
            "}",
            "",
            "FILTER_NUMERIC_BASED_LOOKUP_MAP = {",
            "    \"n\": \"exact\",",
            "    \"lte\": \"lte\",",
            "    \"lt\": \"lt\",",
            "    \"gte\": \"gte\",",
            "    \"gt\": \"gt\",",
            "}",
            "",
            "FILTER_NEGATION_LOOKUP_MAP = {\"n\": \"exact\"}",
            "",
            "",
            "#",
            "# User input sanitization",
            "#",
            "",
            "# Subset of the HTML tags allowed by default by ammonia:",
            "# https://github.com/rust-ammonia/ammonia/blob/master/src/lib.rs",
            "HTML_ALLOWED_TAGS = nh3.ALLOWED_TAGS - {",
            "    # no image maps at present",
            "    \"area\",",
            "    \"map\",",
            "    # no document-level markup at present",
            "    \"article\",",
            "    \"aside\",",
            "    \"footer\",",
            "    \"header\",",
            "    \"nav\",",
            "    # miscellaneous out-of-scope for now",
            "    \"data\",",
            "    \"dfn\",",
            "    \"figcaption\",",
            "    \"figure\",",
            "}",
            "",
            "# Variant of the HTML attributes allowed by default by ammonia:",
            "# https://github.com/rust-ammonia/ammonia/blob/master/src/lib.rs",
            "# at present we just copy nh3.ALLOWED_ATTRIBUTES but we can modify this later as desired and appropriate",
            "HTML_ALLOWED_ATTRIBUTES = deepcopy(nh3.ALLOWED_ATTRIBUTES)",
            "",
            "",
            "#",
            "# HTTP Request META safe copy",
            "#",
            "",
            "HTTP_REQUEST_META_SAFE_COPY = [",
            "    \"CONTENT_LENGTH\",",
            "    \"CONTENT_TYPE\",",
            "    \"HTTP_ACCEPT\",",
            "    \"HTTP_ACCEPT_ENCODING\",",
            "    \"HTTP_ACCEPT_LANGUAGE\",",
            "    \"HTTP_HOST\",",
            "    \"HTTP_REFERER\",",
            "    \"HTTP_USER_AGENT\",",
            "    \"QUERY_STRING\",",
            "    \"REMOTE_ADDR\",",
            "    \"REMOTE_HOST\",",
            "    \"REMOTE_USER\",",
            "    \"REQUEST_METHOD\",",
            "    \"SERVER_NAME\",",
            "    \"SERVER_PORT\",",
            "]"
        ],
        "action": [
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "nautobot/utilities/forms/fields.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from django.core.exceptions import MultipleObjectsReturned, ObjectDoesNotExist, ValidationError"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from django.db.models import Q"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from django.forms.fields import BoundField, JSONField as _JSONField, InvalidJSONInput"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from django.templatetags.static import static"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from django.urls import reverse"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from nautobot.extras.utils import FeatureQuery"
            },
            "8": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from nautobot.utilities.choices import unpack_grouped_choices"
            },
            "9": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 393,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "     widget = forms.Textarea"
            },
            "11": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "     default_label = \"\""
            },
            "12": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # TODO: Port Markdown cheat sheet to internal documentation"
            },
            "13": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    default_helptext = ("
            },
            "14": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        '<i class=\"mdi mdi-information-outline\"></i> '"
            },
            "15": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        '<a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\">'"
            },
            "16": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"Markdown</a> syntax is supported\""
            },
            "17": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    )"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+    @property"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+    def default_helptext(self):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+        # TODO: Port Markdown cheat sheet to internal documentation"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+        return format_html("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+            '<i class=\"mdi mdi-information-outline\"></i> '"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+            '<a href=\"https://www.markdownguide.org/cheat-sheet/#basic-syntax\" rel=\"noopener noreferrer\">Markdown</a> '"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+            'syntax is supported, as well as <a href=\"{}#render_markdown\">a limited subset of HTML</a>.',"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+            static(\"docs/additional-features/template-filters.html\"),"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+        )"
            },
            "28": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 406,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "     def __init__(self, *args, **kwargs):"
            },
            "30": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         required = kwargs.pop(\"required\", False)"
            }
        },
        "frontPatchFile": [
            "import csv",
            "import json",
            "import re",
            "from io import StringIO",
            "",
            "import django_filters",
            "from django import forms",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.postgres.forms import SimpleArrayField",
            "from django.core.exceptions import MultipleObjectsReturned, ObjectDoesNotExist, ValidationError",
            "from django.db.models import Q",
            "from django.forms.fields import BoundField, JSONField as _JSONField, InvalidJSONInput",
            "from django.urls import reverse",
            "",
            "from nautobot.extras.utils import FeatureQuery",
            "from nautobot.utilities.choices import unpack_grouped_choices",
            "from nautobot.utilities.utils import get_route_for_model, is_uuid",
            "from nautobot.utilities.validators import EnhancedURLValidator",
            "from . import widgets",
            "from .constants import ALPHANUMERIC_EXPANSION_PATTERN, IP4_EXPANSION_PATTERN, IP6_EXPANSION_PATTERN",
            "from .utils import expand_alphanumeric_pattern, expand_ipaddress_pattern, parse_numeric_range, parse_csv, validate_csv",
            "",
            "__all__ = (",
            "    \"CommentField\",",
            "    \"CSVChoiceField\",",
            "    \"CSVContentTypeField\",",
            "    \"CSVDataField\",",
            "    \"CSVFileField\",",
            "    \"CSVModelChoiceField\",",
            "    \"CSVMultipleChoiceField\",",
            "    \"CSVMultipleContentTypeField\",",
            "    \"DynamicModelChoiceField\",",
            "    \"DynamicModelMultipleChoiceField\",",
            "    \"ExpandableIPAddressField\",",
            "    \"ExpandableNameField\",",
            "    \"JSONField\",",
            "    \"JSONArrayFormField\",",
            "    \"LaxURLField\",",
            "    \"MultipleContentTypeField\",",
            "    \"MultiMatchModelMultipleChoiceField\",",
            "    \"NumericArrayField\",",
            "    \"SlugField\",",
            "    \"TagFilterField\",",
            ")",
            "",
            "",
            "class CSVDataField(forms.CharField):",
            "    \"\"\"",
            "    A CharField (rendered as a Textarea) which accepts CSV-formatted data. It returns data as a two-tuple: The first",
            "    item is a dictionary of column headers, mapping field names to the attribute by which they match a related object",
            "    (where applicable). The second item is a list of dictionaries, each representing a discrete row of CSV data.",
            "",
            "    :param from_form: The form from which the field derives its validation rules.",
            "    \"\"\"",
            "",
            "    widget = forms.Textarea",
            "",
            "    def __init__(self, from_form, *args, **kwargs):",
            "        form = from_form()",
            "        self.model = form.Meta.model",
            "        self.fields = form.fields",
            "        self.required_fields = [name for name, field in form.fields.items() if field.required]",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.strip = False",
            "        if not self.label:",
            "            self.label = \"\"",
            "        if not self.initial:",
            "            self.initial = \",\".join(self.required_fields) + \"\\n\"",
            "        if not self.help_text:",
            "            self.help_text = (",
            "                \"Enter the list of column headers followed by one line per record to be imported, using \"",
            "                \"commas to separate values. Multi-line data and values containing commas may be wrapped \"",
            "                \"in double quotes.\"",
            "            )",
            "",
            "    def to_python(self, value):",
            "        if value is None:",
            "            return None",
            "        reader = csv.reader(StringIO(value.strip()))",
            "        return parse_csv(reader)",
            "",
            "    def validate(self, value):",
            "        if value is None:",
            "            return None",
            "        headers, _records = value",
            "        validate_csv(headers, self.fields, self.required_fields)",
            "",
            "        return value",
            "",
            "",
            "class CSVFileField(forms.FileField):",
            "    \"\"\"",
            "    A FileField (rendered as a ClearableFileInput) which accepts a file containing CSV-formatted data. It returns",
            "    data as a two-tuple: The first item is a dictionary of column headers, mapping field names to the attribute",
            "    by which they match a related object (where applicable). The second item is a list of dictionaries, each",
            "    representing a discrete row of CSV data.",
            "",
            "    :param from_form: The form from which the field derives its validation rules.",
            "    \"\"\"",
            "",
            "    def __init__(self, from_form, *args, **kwargs):",
            "        form = from_form()",
            "        self.model = form.Meta.model",
            "        self.fields = form.fields",
            "        self.required_fields = [name for name, field in form.fields.items() if field.required]",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if not self.label:",
            "            self.label = \"CSV File\"",
            "        if not self.help_text:",
            "            self.help_text = (",
            "                \"Select a CSV file to upload. It should contain column headers in the first row and use commas \"",
            "                \"to separate values. Multi-line data and values containing commas may be wrapped \"",
            "                \"in double quotes.\"",
            "            )",
            "",
            "    def to_python(self, file):",
            "        if file is None:",
            "            return None",
            "",
            "        file = super().to_python(file)",
            "        csv_str = file.read().decode(\"utf-8-sig\").strip()",
            "        # Check if there is only one column of input",
            "        # If so a delimiter cannot be determined and it will raise an exception.",
            "        # In that case we will use csv.excel class",
            "        # Which defines the usual properties of an Excel-generated CSV file.",
            "        try:",
            "            dialect = csv.Sniffer().sniff(csv_str, delimiters=\",\")",
            "        except csv.Error:",
            "            dialect = csv.excel",
            "        reader = csv.reader(csv_str.splitlines(), dialect)",
            "        headers, records = parse_csv(reader)",
            "",
            "        return headers, records",
            "",
            "    def validate(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        headers, _records = value",
            "        validate_csv(headers, self.fields, self.required_fields)",
            "",
            "        return value",
            "",
            "",
            "class CSVChoiceField(forms.ChoiceField):",
            "    \"\"\"",
            "    Invert the provided set of choices to take the human-friendly label as input, and return the database value.",
            "    \"\"\"",
            "",
            "    STATIC_CHOICES = True",
            "",
            "    def __init__(self, *, choices=(), **kwargs):",
            "        super().__init__(choices=choices, **kwargs)",
            "        self.choices = unpack_grouped_choices(choices)",
            "",
            "",
            "class CSVMultipleChoiceField(CSVChoiceField):",
            "    \"\"\"",
            "    A version of CSVChoiceField that supports and emits a list of choice values",
            "    \"\"\"",
            "",
            "    def to_python(self, value):",
            "        \"\"\"Return a list of strings.\"\"\"",
            "        if value in self.empty_values:",
            "            return \"\"",
            "        return [v.strip() for v in str(value).split(\",\")]",
            "",
            "    def validate(self, value):",
            "        \"\"\"Validate that each of the input values is in self.choices.\"\"\"",
            "        for v in value:",
            "            super().validate(v)",
            "",
            "",
            "class CSVModelChoiceField(forms.ModelChoiceField):",
            "    \"\"\"",
            "    Provides additional validation for model choices entered as CSV data.",
            "    \"\"\"",
            "",
            "    default_error_messages = {",
            "        \"invalid_choice\": \"Object not found.\",",
            "    }",
            "",
            "    def to_python(self, value):",
            "        try:",
            "            return super().to_python(value)",
            "        except MultipleObjectsReturned:",
            "            raise forms.ValidationError(f'\"{value}\" is not a unique value for this field; multiple objects were found')",
            "",
            "",
            "class CSVContentTypeField(CSVModelChoiceField):",
            "    \"\"\"",
            "    Reference a ContentType in the form `{app_label}.{model}`.",
            "    \"\"\"",
            "",
            "    STATIC_CHOICES = True",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"",
            "        Allow this field to support `{app_label}.{model}` style, null values, or PK-based lookups",
            "        depending on how the field is used.",
            "        \"\"\"",
            "        if value is None:",
            "            return \"\"",
            "",
            "        # Only pass through strings if they aren't numeric. Otherwise cast to `int`.",
            "        if isinstance(value, str):",
            "            if not value.isdigit():",
            "                return value",
            "            else:",
            "                value = int(value)",
            "",
            "        # Integers are PKs",
            "        if isinstance(value, int):",
            "            value = self.queryset.get(pk=value)",
            "",
            "        return f\"{value.app_label}.{value.model}\"",
            "",
            "    def to_python(self, value):",
            "        value = self.prepare_value(value)",
            "        try:",
            "            app_label, model = value.split(\".\")",
            "        except ValueError:",
            "            raise forms.ValidationError('Object type must be specified as \"<app_label>.<model>\"')",
            "        try:",
            "            return self.queryset.get(app_label=app_label, model=model)",
            "        except ObjectDoesNotExist:",
            "            raise forms.ValidationError(\"Invalid object type\")",
            "",
            "",
            "class MultipleContentTypeField(forms.ModelMultipleChoiceField):",
            "    \"\"\"",
            "    Field for choosing any number of `ContentType` objects.",
            "",
            "    Optionally can restrict the available ContentTypes to those supporting a particular feature only.",
            "    Optionally can pass the selection through as a list of `{app_label}.{model}` strings instead of PK values.",
            "    \"\"\"",
            "",
            "    STATIC_CHOICES = True",
            "",
            "    def __init__(self, *args, feature=None, choices_as_strings=False, **kwargs):",
            "        \"\"\"",
            "        Construct a MultipleContentTypeField.",
            "",
            "        Args:",
            "            feature (str): Feature name to use in constructing a FeatureQuery to restrict the available ContentTypes.",
            "            choices_as_strings (bool): If True, render selection as a list of `\"{app_label}.{model}\"` strings.",
            "        \"\"\"",
            "        if \"queryset\" not in kwargs:",
            "            if feature is not None:",
            "                kwargs[\"queryset\"] = ContentType.objects.filter(FeatureQuery(feature).get_query()).order_by(",
            "                    \"app_label\", \"model\"",
            "                )",
            "            else:",
            "                kwargs[\"queryset\"] = ContentType.objects.order_by(\"app_label\", \"model\")",
            "        if \"widget\" not in kwargs:",
            "            kwargs[\"widget\"] = widgets.StaticSelect2Multiple()",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if choices_as_strings:",
            "            self.choices = self._string_choices_from_queryset",
            "",
            "    def _string_choices_from_queryset(self):",
            "        \"\"\"Overload choices to return `{app_label}.{model}` instead of PKs.\"\"\"",
            "        return [(f\"{m.app_label}.{m.model}\", m.app_labeled_name) for m in self.queryset.all()]",
            "",
            "",
            "class MultiValueCharField(forms.CharField):",
            "    \"\"\"",
            "    CharField that takes multiple user character inputs and render them as tags in the form field.",
            "    Press enter to complete an input.",
            "    \"\"\"",
            "",
            "    widget = widgets.MultiValueCharInput()",
            "",
            "    def get_bound_field(self, form, field_name):",
            "        bound_field = BoundField(form, self, field_name)",
            "        value = bound_field.value()",
            "        widget = bound_field.field.widget",
            "        # Save the selected choices in the widget even after the filterform is submitted",
            "        if value is not None:",
            "            widget.choices = [(v, v) for v in value]",
            "",
            "        return bound_field",
            "",
            "    def to_python(self, value):",
            "        self.field_class = forms.CharField",
            "        if not value:",
            "            return []",
            "",
            "        # Make it a list if it's a string.",
            "        if isinstance(value, str):",
            "            value = [value]",
            "",
            "        return [",
            "            # Only append non-empty values (this avoids e.g. trying to cast '' as an integer)",
            "            super(self.field_class, self).to_python(v)  # pylint: disable=bad-super-call",
            "            for v in value",
            "            if v",
            "        ]",
            "",
            "",
            "class CSVMultipleContentTypeField(MultipleContentTypeField):",
            "    \"\"\"",
            "    Reference a list of `ContentType` objects in the form `{app_label}.{model}'.",
            "    \"\"\"",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"Parse a comma-separated string of model names into a list of PKs.\"\"\"",
            "        # \"\".split(\",\") yields [\"\"] rather than [], which we don't want!",
            "        if isinstance(value, str) and value:",
            "            value = value.split(\",\")",
            "",
            "        # For each model name, retrieve the model object and extract its",
            "        # content-type PK.",
            "        pk_list = []",
            "        if isinstance(value, (list, tuple)):",
            "            for v in value:",
            "                try:",
            "                    model = apps.get_model(v)",
            "                except (ValueError, LookupError):",
            "                    raise forms.ValidationError(",
            "                        self.error_messages[\"invalid_choice\"],",
            "                        code=\"invalid_choice\",",
            "                        params={\"value\": v},",
            "                    )",
            "                ct = self.queryset.model.objects.get_for_model(model)",
            "                pk_list.append(ct.pk)",
            "",
            "        return super().prepare_value(pk_list)",
            "",
            "",
            "class ExpandableNameField(forms.CharField):",
            "    \"\"\"",
            "    A field which allows for numeric range expansion",
            "      Example: 'Gi0/[1-3]' => ['Gi0/1', 'Gi0/2', 'Gi0/3']",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not self.help_text:",
            "            self.help_text = \"\"\"",
            "                Alphanumeric ranges are supported for bulk creation. Mixed cases and types within a single range",
            "                are not supported. Examples:",
            "                <ul>",
            "                    <li><code>[ge,xe]-0/0/[0-9]</code></li>",
            "                    <li><code>e[0-3][a-d,f]</code></li>",
            "                </ul>",
            "                \"\"\"",
            "",
            "    def to_python(self, value):",
            "        if not value:",
            "            return \"\"",
            "        if re.search(ALPHANUMERIC_EXPANSION_PATTERN, value):",
            "            return list(expand_alphanumeric_pattern(value))",
            "        return [value]",
            "",
            "",
            "class ExpandableIPAddressField(forms.CharField):",
            "    \"\"\"",
            "    A field which allows for expansion of IP address ranges",
            "      Example: '192.0.2.[1-254]/24' => ['192.0.2.1/24', '192.0.2.2/24', '192.0.2.3/24' ... '192.0.2.254/24']",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not self.help_text:",
            "            self.help_text = (",
            "                \"Specify a numeric range to create multiple IPs.<br />Example: <code>192.0.2.[1,5,100-254]/24</code>\"",
            "            )",
            "",
            "    def to_python(self, value):",
            "        # Hackish address family detection but it's all we have to work with",
            "        if \".\" in value and re.search(IP4_EXPANSION_PATTERN, value):",
            "            return list(expand_ipaddress_pattern(value, 4))",
            "        elif \":\" in value and re.search(IP6_EXPANSION_PATTERN, value):",
            "            return list(expand_ipaddress_pattern(value, 6))",
            "        return [value]",
            "",
            "",
            "class CommentField(forms.CharField):",
            "    \"\"\"",
            "    A textarea with support for Markdown rendering. Exists mostly just to add a standard help_text.",
            "    \"\"\"",
            "",
            "    widget = forms.Textarea",
            "    default_label = \"\"",
            "    # TODO: Port Markdown cheat sheet to internal documentation",
            "    default_helptext = (",
            "        '<i class=\"mdi mdi-information-outline\"></i> '",
            "        '<a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\">'",
            "        \"Markdown</a> syntax is supported\"",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        required = kwargs.pop(\"required\", False)",
            "        label = kwargs.pop(\"label\", self.default_label)",
            "        help_text = kwargs.pop(\"help_text\", self.default_helptext)",
            "        super().__init__(required=required, label=label, help_text=help_text, *args, **kwargs)",
            "",
            "",
            "class NullableDateField(forms.DateField):",
            "    def to_python(self, value):",
            "        if not value:",
            "            return None",
            "        elif value == \"null\":",
            "            return value",
            "        return super().to_python(value)",
            "",
            "",
            "class SlugField(forms.SlugField):",
            "    \"\"\"",
            "    Extend the built-in SlugField to automatically populate from a field called `name` unless otherwise specified.",
            "    \"\"\"",
            "",
            "    def __init__(self, slug_source=\"name\", *args, **kwargs):",
            "        \"\"\"",
            "        Instantiate a SlugField.",
            "",
            "        Args:",
            "            slug_source (str, tuple): Name of the field (or a list of field names) that will be used to suggest a slug.",
            "        \"\"\"",
            "        kwargs.setdefault(\"label\", \"Slug\")",
            "        kwargs.setdefault(\"help_text\", \"URL-friendly unique shorthand\")",
            "        kwargs.setdefault(\"widget\", widgets.SlugWidget)",
            "        super().__init__(*args, **kwargs)",
            "        if isinstance(slug_source, (tuple, list)):",
            "            slug_source = \" \".join(slug_source)",
            "        self.widget.attrs[\"slug-source\"] = slug_source",
            "",
            "",
            "class DynamicModelChoiceMixin:",
            "    \"\"\"",
            "    :param display_field: The name of the attribute of an API response object to display in the selection list",
            "    :param query_params: A dictionary of additional key/value pairs to attach to the API request",
            "    :param initial_params: A dictionary of child field references to use for selecting a parent field's initial value",
            "    :param null_option: The string used to represent a null selection (if any)",
            "    :param disabled_indicator: The name of the field which, if populated, will disable selection of the",
            "        choice (optional)",
            "    :param brief_mode: Use the \"brief\" format (?brief=true) when making API requests (default)",
            "    \"\"\"",
            "",
            "    filter = django_filters.ModelChoiceFilter  # 2.0 TODO(Glenn): can we rename this? pylint: disable=redefined-builtin",
            "    widget = widgets.APISelect",
            "",
            "    def __init__(",
            "        self,",
            "        display_field=\"display\",",
            "        query_params=None,",
            "        initial_params=None,",
            "        null_option=None,",
            "        disabled_indicator=None,",
            "        brief_mode=True,",
            "        *args,",
            "        **kwargs,",
            "    ):",
            "        self.display_field = display_field",
            "        self.query_params = query_params or {}",
            "        self.initial_params = initial_params or {}",
            "        self.null_option = null_option",
            "        self.disabled_indicator = disabled_indicator",
            "        self.brief_mode = brief_mode",
            "",
            "        # to_field_name is set by ModelChoiceField.__init__(), but we need to set it early for reference",
            "        # by widget_attrs()",
            "        self.to_field_name = kwargs.get(\"to_field_name\")",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def widget_attrs(self, widget):",
            "        attrs = {",
            "            \"display-field\": self.display_field,",
            "        }",
            "",
            "        # Set value-field attribute if the field specifies to_field_name",
            "        if self.to_field_name:",
            "            attrs[\"value-field\"] = self.to_field_name",
            "",
            "        # Set the string used to represent a null option",
            "        if self.null_option is not None:",
            "            attrs[\"data-null-option\"] = self.null_option",
            "",
            "        # Set the disabled indicator, if any",
            "        if self.disabled_indicator is not None:",
            "            attrs[\"disabled-indicator\"] = self.disabled_indicator",
            "",
            "        # Toggle brief mode",
            "        if not self.brief_mode:",
            "            attrs[\"data-full\"] = \"true\"",
            "",
            "        # Attach any static query parameters",
            "        for key, value in self.query_params.items():",
            "            widget.add_query_param(key, value)",
            "",
            "        return attrs",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"",
            "        Augment the behavior of forms.ModelChoiceField.prepare_value().",
            "",
            "        Specifically, if `value` is a PK, but we have `to_field_name` set, we need to look up the model instance",
            "        from the given PK, so that the base class will get the appropriate field value rather than just keeping the PK,",
            "        because the rendered form field needs this in order to correctly prepopulate a default selection.",
            "        \"\"\"",
            "        if self.to_field_name and is_uuid(value):",
            "            try:",
            "                value = self.queryset.get(pk=value)",
            "            except ObjectDoesNotExist:",
            "                pass",
            "        return super().prepare_value(value)",
            "",
            "    def get_bound_field(self, form, field_name):",
            "        bound_field = BoundField(form, self, field_name)",
            "",
            "        # Set initial value based on prescribed child fields (if not already set)",
            "        if not self.initial and self.initial_params:",
            "            filter_kwargs = {}",
            "            for kwarg, child_field in self.initial_params.items():",
            "                value = form.initial.get(child_field.lstrip(\"$\"))",
            "                if value:",
            "                    filter_kwargs[kwarg] = value",
            "            if filter_kwargs:",
            "                self.initial = self.queryset.filter(**filter_kwargs).first()",
            "",
            "        # Modify the QuerySet of the field before we return it. Limit choices to any data already bound: Options",
            "        # will be populated on-demand via the APISelect widget.",
            "        data = bound_field.value()",
            "        if data:",
            "            field_name = getattr(self, \"to_field_name\") or \"pk\"",
            "            filter_ = self.filter(field_name=field_name)",
            "            try:",
            "                self.queryset = filter_.filter(self.queryset, data)",
            "            except (TypeError, ValidationError):",
            "                # Catch any error caused by invalid initial data passed from the user",
            "                self.queryset = self.queryset.none()",
            "        else:",
            "            self.queryset = self.queryset.none()",
            "",
            "        # Set the data URL on the APISelect widget (if not already set)",
            "        widget = bound_field.field.widget",
            "        if not widget.attrs.get(\"data-url\"):",
            "            route = get_route_for_model(self.queryset.model, \"list\", api=True)",
            "            data_url = reverse(route)",
            "            widget.attrs[\"data-url\"] = data_url",
            "",
            "        return bound_field",
            "",
            "",
            "class DynamicModelChoiceField(DynamicModelChoiceMixin, forms.ModelChoiceField):",
            "    \"\"\"",
            "    Override get_bound_field() to avoid pre-populating field choices with a SQL query. The field will be",
            "    rendered only with choices set via bound data. Choices are populated on-demand via the APISelect widget.",
            "    \"\"\"",
            "",
            "    def clean(self, value):",
            "        \"\"\"",
            "        When null option is enabled and \"None\" is sent as part of a form to be submitted, it is sent as the",
            "        string 'null'.  This will check for that condition and gracefully handle the conversion to a NoneType.",
            "        \"\"\"",
            "        if self.null_option is not None and value == settings.FILTERS_NULL_CHOICE_VALUE:",
            "            return None",
            "        return super().clean(value)",
            "",
            "",
            "class DynamicModelMultipleChoiceField(DynamicModelChoiceMixin, forms.ModelMultipleChoiceField):",
            "    \"\"\"",
            "    A multiple-choice version of DynamicModelChoiceField.",
            "    \"\"\"",
            "",
            "    filter = django_filters.ModelMultipleChoiceFilter",
            "    widget = widgets.APISelectMultiple",
            "",
            "",
            "class LaxURLField(forms.URLField):",
            "    \"\"\"",
            "    Modifies Django's built-in URLField to remove the requirement for fully-qualified domain names",
            "    (e.g. http://myserver/ is valid)",
            "    \"\"\"",
            "",
            "    default_validators = [EnhancedURLValidator()]",
            "",
            "",
            "class JSONField(_JSONField):",
            "    \"\"\"",
            "    Custom wrapper around Django's built-in JSONField to avoid presenting \"null\" as the default text.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not self.help_text:",
            "            self.help_text = 'Enter context data in <a href=\"https://json.org/\">JSON</a> format.'",
            "            self.widget.attrs[\"placeholder\"] = \"\"",
            "",
            "    def prepare_value(self, value):",
            "        if isinstance(value, InvalidJSONInput):",
            "            return value",
            "        if value is None:",
            "            return \"\"",
            "        return json.dumps(value, sort_keys=True, indent=4, ensure_ascii=False)",
            "",
            "    # TODO: remove this when we upgrade to Django 4",
            "    def bound_data(self, data, initial):",
            "        if data is None:",
            "            return None",
            "        return super().bound_data(data, initial)",
            "",
            "",
            "class JSONArrayFormField(forms.JSONField):",
            "    \"\"\"",
            "    A FormField counterpart to JSONArrayField.",
            "    Replicates ArrayFormField's base field validation: Field values are validated as JSON Arrays,",
            "    and each Array element is validated by `base_field` validators.",
            "    \"\"\"",
            "",
            "    def __init__(self, base_field, *, delimiter=\",\", **kwargs):",
            "        self.base_field = base_field",
            "        self.delimiter = delimiter",
            "        super().__init__(**kwargs)",
            "",
            "    def clean(self, value):",
            "        \"\"\"",
            "        Validate `value` and return its \"cleaned\" value as an appropriate",
            "        Python object. Raise ValidationError for any errors.",
            "        \"\"\"",
            "        value = super().clean(value)",
            "        return [self.base_field.clean(val) for val in value]",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"",
            "        Return a string of this value.",
            "        \"\"\"",
            "        if isinstance(value, list):",
            "            return self.delimiter.join(str(self.base_field.prepare_value(v)) for v in value)",
            "        return value",
            "",
            "    def to_python(self, value):",
            "        \"\"\"",
            "        Convert `value` into JSON, raising django.core.exceptions.ValidationError",
            "        if the data can't be converted. Return the converted value.",
            "        \"\"\"",
            "        if isinstance(value, list):",
            "            items = value",
            "        elif value:",
            "            try:",
            "                items = value.split(self.delimiter)",
            "            except Exception as e:",
            "                raise ValidationError(e)",
            "        else:",
            "            items = []",
            "",
            "        errors = []",
            "        values = []",
            "        for item in items:",
            "            try:",
            "                values.append(self.base_field.to_python(item))",
            "            except ValidationError as error:",
            "                errors.append(error)",
            "        if errors:",
            "            raise ValidationError(errors)",
            "        return values",
            "",
            "    def validate(self, value):",
            "        \"\"\"",
            "        Validate `value` and raise ValidationError if necessary.",
            "        \"\"\"",
            "        super().validate(value)",
            "        errors = []",
            "        for item in value:",
            "            try:",
            "                self.base_field.validate(item)",
            "            except ValidationError as error:",
            "                errors.append(error)",
            "        if errors:",
            "            raise ValidationError(errors)",
            "",
            "    def run_validators(self, value):",
            "        \"\"\"",
            "        Runs all validators against `value` and raise ValidationError if necessary.",
            "        Some validators can't be created at field initialization time.",
            "        \"\"\"",
            "        super().run_validators(value)",
            "        errors = []",
            "        for item in value:",
            "            try:",
            "                self.base_field.run_validators(item)",
            "            except ValidationError as error:",
            "                errors.append(error)",
            "        if errors:",
            "            raise ValidationError(errors)",
            "",
            "    def has_changed(self, initial, data):",
            "        \"\"\"",
            "        Return True if `data` differs from `initial`.",
            "        \"\"\"",
            "        value = self.to_python(data)",
            "        if initial in self.empty_values and value in self.empty_values:",
            "            return False",
            "        return super().has_changed(initial, data)",
            "",
            "",
            "class NumericArrayField(SimpleArrayField):",
            "    \"\"\"Basic array field that takes comma-separated or hyphenated ranges.\"\"\"",
            "",
            "    def to_python(self, value):",
            "        try:",
            "            value = \",\".join([str(n) for n in parse_numeric_range(value)])",
            "        except ValueError as error:",
            "            raise ValidationError(error)",
            "        return super().to_python(value)",
            "",
            "",
            "class MultiMatchModelMultipleChoiceField(django_filters.fields.ModelMultipleChoiceField):",
            "    \"\"\"",
            "    Filter field to support matching on the PK *or* `to_field_name` fields (defaulting to `slug` if not specified).",
            "",
            "    Raises ValidationError if none of the fields match the requested value.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.natural_key = kwargs.setdefault(\"to_field_name\", \"slug\")",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def _check_values(self, values):",
            "        \"\"\"",
            "        This method overloads the grandparent method in `django.forms.models.ModelMultipleChoiceField`,",
            "        re-using some of that method's existing logic and adding support for coupling this field with",
            "        multiple model fields.",
            "        \"\"\"",
            "        null = self.null_label is not None and values and self.null_value in values",
            "        if null:",
            "            values = [v for v in values if v != self.null_value]",
            "        # deduplicate given values to avoid creating many querysets or",
            "        # requiring the database backend deduplicate efficiently.",
            "        try:",
            "            values = frozenset(values)",
            "        except TypeError:",
            "            # list of lists isn't hashable, for example",
            "            raise ValidationError(",
            "                self.error_messages[\"invalid_list\"],",
            "                code=\"invalid_list\",",
            "            )",
            "        pk_values = set()",
            "        natural_key_values = set()",
            "        for item in values:",
            "            query = Q()",
            "            if is_uuid(item):",
            "                pk_values.add(item)",
            "                query |= Q(pk=item)",
            "            else:",
            "                natural_key_values.add(item)",
            "                query |= Q(**{self.natural_key: item})",
            "            qs = self.queryset.filter(query)",
            "            if not qs.exists():",
            "                raise ValidationError(",
            "                    self.error_messages[\"invalid_choice\"],",
            "                    code=\"invalid_choice\",",
            "                    params={\"value\": item},",
            "                )",
            "        query = Q(pk__in=pk_values) | Q(**{f\"{self.natural_key}__in\": natural_key_values})",
            "        qs = self.queryset.filter(query)",
            "        result = list(qs)",
            "        if null:",
            "            result += [self.null_value]",
            "        return result",
            "",
            "",
            "class TagFilterField(DynamicModelMultipleChoiceField):",
            "    \"\"\"",
            "    A filter field for the tags of a model. Only the tags used by a model are displayed.",
            "",
            "    :param model: The model of the filter",
            "    \"\"\"",
            "",
            "    def __init__(self, model, *args, query_params=None, queryset=None, **kwargs):",
            "        if queryset is None:",
            "            queryset = model.tags.all()",
            "        query_params = query_params or {}",
            "        query_params.update({\"content_types\": model._meta.label_lower})",
            "        super().__init__(",
            "            label=\"Tags\",",
            "            query_params=query_params,",
            "            queryset=queryset,",
            "            required=False,",
            "            to_field_name=\"slug\",",
            "            *args,",
            "            **kwargs,",
            "        )"
        ],
        "afterPatchFile": [
            "import csv",
            "import json",
            "import re",
            "from io import StringIO",
            "",
            "import django_filters",
            "from django import forms",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.postgres.forms import SimpleArrayField",
            "from django.core.exceptions import MultipleObjectsReturned, ObjectDoesNotExist, ValidationError",
            "from django.db.models import Q",
            "from django.forms.fields import BoundField, JSONField as _JSONField, InvalidJSONInput",
            "from django.templatetags.static import static",
            "from django.urls import reverse",
            "from django.utils.html import format_html",
            "",
            "from nautobot.extras.utils import FeatureQuery",
            "from nautobot.utilities.choices import unpack_grouped_choices",
            "from nautobot.utilities.utils import get_route_for_model, is_uuid",
            "from nautobot.utilities.validators import EnhancedURLValidator",
            "from . import widgets",
            "from .constants import ALPHANUMERIC_EXPANSION_PATTERN, IP4_EXPANSION_PATTERN, IP6_EXPANSION_PATTERN",
            "from .utils import expand_alphanumeric_pattern, expand_ipaddress_pattern, parse_numeric_range, parse_csv, validate_csv",
            "",
            "__all__ = (",
            "    \"CommentField\",",
            "    \"CSVChoiceField\",",
            "    \"CSVContentTypeField\",",
            "    \"CSVDataField\",",
            "    \"CSVFileField\",",
            "    \"CSVModelChoiceField\",",
            "    \"CSVMultipleChoiceField\",",
            "    \"CSVMultipleContentTypeField\",",
            "    \"DynamicModelChoiceField\",",
            "    \"DynamicModelMultipleChoiceField\",",
            "    \"ExpandableIPAddressField\",",
            "    \"ExpandableNameField\",",
            "    \"JSONField\",",
            "    \"JSONArrayFormField\",",
            "    \"LaxURLField\",",
            "    \"MultipleContentTypeField\",",
            "    \"MultiMatchModelMultipleChoiceField\",",
            "    \"NumericArrayField\",",
            "    \"SlugField\",",
            "    \"TagFilterField\",",
            ")",
            "",
            "",
            "class CSVDataField(forms.CharField):",
            "    \"\"\"",
            "    A CharField (rendered as a Textarea) which accepts CSV-formatted data. It returns data as a two-tuple: The first",
            "    item is a dictionary of column headers, mapping field names to the attribute by which they match a related object",
            "    (where applicable). The second item is a list of dictionaries, each representing a discrete row of CSV data.",
            "",
            "    :param from_form: The form from which the field derives its validation rules.",
            "    \"\"\"",
            "",
            "    widget = forms.Textarea",
            "",
            "    def __init__(self, from_form, *args, **kwargs):",
            "        form = from_form()",
            "        self.model = form.Meta.model",
            "        self.fields = form.fields",
            "        self.required_fields = [name for name, field in form.fields.items() if field.required]",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.strip = False",
            "        if not self.label:",
            "            self.label = \"\"",
            "        if not self.initial:",
            "            self.initial = \",\".join(self.required_fields) + \"\\n\"",
            "        if not self.help_text:",
            "            self.help_text = (",
            "                \"Enter the list of column headers followed by one line per record to be imported, using \"",
            "                \"commas to separate values. Multi-line data and values containing commas may be wrapped \"",
            "                \"in double quotes.\"",
            "            )",
            "",
            "    def to_python(self, value):",
            "        if value is None:",
            "            return None",
            "        reader = csv.reader(StringIO(value.strip()))",
            "        return parse_csv(reader)",
            "",
            "    def validate(self, value):",
            "        if value is None:",
            "            return None",
            "        headers, _records = value",
            "        validate_csv(headers, self.fields, self.required_fields)",
            "",
            "        return value",
            "",
            "",
            "class CSVFileField(forms.FileField):",
            "    \"\"\"",
            "    A FileField (rendered as a ClearableFileInput) which accepts a file containing CSV-formatted data. It returns",
            "    data as a two-tuple: The first item is a dictionary of column headers, mapping field names to the attribute",
            "    by which they match a related object (where applicable). The second item is a list of dictionaries, each",
            "    representing a discrete row of CSV data.",
            "",
            "    :param from_form: The form from which the field derives its validation rules.",
            "    \"\"\"",
            "",
            "    def __init__(self, from_form, *args, **kwargs):",
            "        form = from_form()",
            "        self.model = form.Meta.model",
            "        self.fields = form.fields",
            "        self.required_fields = [name for name, field in form.fields.items() if field.required]",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if not self.label:",
            "            self.label = \"CSV File\"",
            "        if not self.help_text:",
            "            self.help_text = (",
            "                \"Select a CSV file to upload. It should contain column headers in the first row and use commas \"",
            "                \"to separate values. Multi-line data and values containing commas may be wrapped \"",
            "                \"in double quotes.\"",
            "            )",
            "",
            "    def to_python(self, file):",
            "        if file is None:",
            "            return None",
            "",
            "        file = super().to_python(file)",
            "        csv_str = file.read().decode(\"utf-8-sig\").strip()",
            "        # Check if there is only one column of input",
            "        # If so a delimiter cannot be determined and it will raise an exception.",
            "        # In that case we will use csv.excel class",
            "        # Which defines the usual properties of an Excel-generated CSV file.",
            "        try:",
            "            dialect = csv.Sniffer().sniff(csv_str, delimiters=\",\")",
            "        except csv.Error:",
            "            dialect = csv.excel",
            "        reader = csv.reader(csv_str.splitlines(), dialect)",
            "        headers, records = parse_csv(reader)",
            "",
            "        return headers, records",
            "",
            "    def validate(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        headers, _records = value",
            "        validate_csv(headers, self.fields, self.required_fields)",
            "",
            "        return value",
            "",
            "",
            "class CSVChoiceField(forms.ChoiceField):",
            "    \"\"\"",
            "    Invert the provided set of choices to take the human-friendly label as input, and return the database value.",
            "    \"\"\"",
            "",
            "    STATIC_CHOICES = True",
            "",
            "    def __init__(self, *, choices=(), **kwargs):",
            "        super().__init__(choices=choices, **kwargs)",
            "        self.choices = unpack_grouped_choices(choices)",
            "",
            "",
            "class CSVMultipleChoiceField(CSVChoiceField):",
            "    \"\"\"",
            "    A version of CSVChoiceField that supports and emits a list of choice values",
            "    \"\"\"",
            "",
            "    def to_python(self, value):",
            "        \"\"\"Return a list of strings.\"\"\"",
            "        if value in self.empty_values:",
            "            return \"\"",
            "        return [v.strip() for v in str(value).split(\",\")]",
            "",
            "    def validate(self, value):",
            "        \"\"\"Validate that each of the input values is in self.choices.\"\"\"",
            "        for v in value:",
            "            super().validate(v)",
            "",
            "",
            "class CSVModelChoiceField(forms.ModelChoiceField):",
            "    \"\"\"",
            "    Provides additional validation for model choices entered as CSV data.",
            "    \"\"\"",
            "",
            "    default_error_messages = {",
            "        \"invalid_choice\": \"Object not found.\",",
            "    }",
            "",
            "    def to_python(self, value):",
            "        try:",
            "            return super().to_python(value)",
            "        except MultipleObjectsReturned:",
            "            raise forms.ValidationError(f'\"{value}\" is not a unique value for this field; multiple objects were found')",
            "",
            "",
            "class CSVContentTypeField(CSVModelChoiceField):",
            "    \"\"\"",
            "    Reference a ContentType in the form `{app_label}.{model}`.",
            "    \"\"\"",
            "",
            "    STATIC_CHOICES = True",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"",
            "        Allow this field to support `{app_label}.{model}` style, null values, or PK-based lookups",
            "        depending on how the field is used.",
            "        \"\"\"",
            "        if value is None:",
            "            return \"\"",
            "",
            "        # Only pass through strings if they aren't numeric. Otherwise cast to `int`.",
            "        if isinstance(value, str):",
            "            if not value.isdigit():",
            "                return value",
            "            else:",
            "                value = int(value)",
            "",
            "        # Integers are PKs",
            "        if isinstance(value, int):",
            "            value = self.queryset.get(pk=value)",
            "",
            "        return f\"{value.app_label}.{value.model}\"",
            "",
            "    def to_python(self, value):",
            "        value = self.prepare_value(value)",
            "        try:",
            "            app_label, model = value.split(\".\")",
            "        except ValueError:",
            "            raise forms.ValidationError('Object type must be specified as \"<app_label>.<model>\"')",
            "        try:",
            "            return self.queryset.get(app_label=app_label, model=model)",
            "        except ObjectDoesNotExist:",
            "            raise forms.ValidationError(\"Invalid object type\")",
            "",
            "",
            "class MultipleContentTypeField(forms.ModelMultipleChoiceField):",
            "    \"\"\"",
            "    Field for choosing any number of `ContentType` objects.",
            "",
            "    Optionally can restrict the available ContentTypes to those supporting a particular feature only.",
            "    Optionally can pass the selection through as a list of `{app_label}.{model}` strings instead of PK values.",
            "    \"\"\"",
            "",
            "    STATIC_CHOICES = True",
            "",
            "    def __init__(self, *args, feature=None, choices_as_strings=False, **kwargs):",
            "        \"\"\"",
            "        Construct a MultipleContentTypeField.",
            "",
            "        Args:",
            "            feature (str): Feature name to use in constructing a FeatureQuery to restrict the available ContentTypes.",
            "            choices_as_strings (bool): If True, render selection as a list of `\"{app_label}.{model}\"` strings.",
            "        \"\"\"",
            "        if \"queryset\" not in kwargs:",
            "            if feature is not None:",
            "                kwargs[\"queryset\"] = ContentType.objects.filter(FeatureQuery(feature).get_query()).order_by(",
            "                    \"app_label\", \"model\"",
            "                )",
            "            else:",
            "                kwargs[\"queryset\"] = ContentType.objects.order_by(\"app_label\", \"model\")",
            "        if \"widget\" not in kwargs:",
            "            kwargs[\"widget\"] = widgets.StaticSelect2Multiple()",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if choices_as_strings:",
            "            self.choices = self._string_choices_from_queryset",
            "",
            "    def _string_choices_from_queryset(self):",
            "        \"\"\"Overload choices to return `{app_label}.{model}` instead of PKs.\"\"\"",
            "        return [(f\"{m.app_label}.{m.model}\", m.app_labeled_name) for m in self.queryset.all()]",
            "",
            "",
            "class MultiValueCharField(forms.CharField):",
            "    \"\"\"",
            "    CharField that takes multiple user character inputs and render them as tags in the form field.",
            "    Press enter to complete an input.",
            "    \"\"\"",
            "",
            "    widget = widgets.MultiValueCharInput()",
            "",
            "    def get_bound_field(self, form, field_name):",
            "        bound_field = BoundField(form, self, field_name)",
            "        value = bound_field.value()",
            "        widget = bound_field.field.widget",
            "        # Save the selected choices in the widget even after the filterform is submitted",
            "        if value is not None:",
            "            widget.choices = [(v, v) for v in value]",
            "",
            "        return bound_field",
            "",
            "    def to_python(self, value):",
            "        self.field_class = forms.CharField",
            "        if not value:",
            "            return []",
            "",
            "        # Make it a list if it's a string.",
            "        if isinstance(value, str):",
            "            value = [value]",
            "",
            "        return [",
            "            # Only append non-empty values (this avoids e.g. trying to cast '' as an integer)",
            "            super(self.field_class, self).to_python(v)  # pylint: disable=bad-super-call",
            "            for v in value",
            "            if v",
            "        ]",
            "",
            "",
            "class CSVMultipleContentTypeField(MultipleContentTypeField):",
            "    \"\"\"",
            "    Reference a list of `ContentType` objects in the form `{app_label}.{model}'.",
            "    \"\"\"",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"Parse a comma-separated string of model names into a list of PKs.\"\"\"",
            "        # \"\".split(\",\") yields [\"\"] rather than [], which we don't want!",
            "        if isinstance(value, str) and value:",
            "            value = value.split(\",\")",
            "",
            "        # For each model name, retrieve the model object and extract its",
            "        # content-type PK.",
            "        pk_list = []",
            "        if isinstance(value, (list, tuple)):",
            "            for v in value:",
            "                try:",
            "                    model = apps.get_model(v)",
            "                except (ValueError, LookupError):",
            "                    raise forms.ValidationError(",
            "                        self.error_messages[\"invalid_choice\"],",
            "                        code=\"invalid_choice\",",
            "                        params={\"value\": v},",
            "                    )",
            "                ct = self.queryset.model.objects.get_for_model(model)",
            "                pk_list.append(ct.pk)",
            "",
            "        return super().prepare_value(pk_list)",
            "",
            "",
            "class ExpandableNameField(forms.CharField):",
            "    \"\"\"",
            "    A field which allows for numeric range expansion",
            "      Example: 'Gi0/[1-3]' => ['Gi0/1', 'Gi0/2', 'Gi0/3']",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not self.help_text:",
            "            self.help_text = \"\"\"",
            "                Alphanumeric ranges are supported for bulk creation. Mixed cases and types within a single range",
            "                are not supported. Examples:",
            "                <ul>",
            "                    <li><code>[ge,xe]-0/0/[0-9]</code></li>",
            "                    <li><code>e[0-3][a-d,f]</code></li>",
            "                </ul>",
            "                \"\"\"",
            "",
            "    def to_python(self, value):",
            "        if not value:",
            "            return \"\"",
            "        if re.search(ALPHANUMERIC_EXPANSION_PATTERN, value):",
            "            return list(expand_alphanumeric_pattern(value))",
            "        return [value]",
            "",
            "",
            "class ExpandableIPAddressField(forms.CharField):",
            "    \"\"\"",
            "    A field which allows for expansion of IP address ranges",
            "      Example: '192.0.2.[1-254]/24' => ['192.0.2.1/24', '192.0.2.2/24', '192.0.2.3/24' ... '192.0.2.254/24']",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not self.help_text:",
            "            self.help_text = (",
            "                \"Specify a numeric range to create multiple IPs.<br />Example: <code>192.0.2.[1,5,100-254]/24</code>\"",
            "            )",
            "",
            "    def to_python(self, value):",
            "        # Hackish address family detection but it's all we have to work with",
            "        if \".\" in value and re.search(IP4_EXPANSION_PATTERN, value):",
            "            return list(expand_ipaddress_pattern(value, 4))",
            "        elif \":\" in value and re.search(IP6_EXPANSION_PATTERN, value):",
            "            return list(expand_ipaddress_pattern(value, 6))",
            "        return [value]",
            "",
            "",
            "class CommentField(forms.CharField):",
            "    \"\"\"",
            "    A textarea with support for Markdown rendering. Exists mostly just to add a standard help_text.",
            "    \"\"\"",
            "",
            "    widget = forms.Textarea",
            "    default_label = \"\"",
            "",
            "    @property",
            "    def default_helptext(self):",
            "        # TODO: Port Markdown cheat sheet to internal documentation",
            "        return format_html(",
            "            '<i class=\"mdi mdi-information-outline\"></i> '",
            "            '<a href=\"https://www.markdownguide.org/cheat-sheet/#basic-syntax\" rel=\"noopener noreferrer\">Markdown</a> '",
            "            'syntax is supported, as well as <a href=\"{}#render_markdown\">a limited subset of HTML</a>.',",
            "            static(\"docs/additional-features/template-filters.html\"),",
            "        )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        required = kwargs.pop(\"required\", False)",
            "        label = kwargs.pop(\"label\", self.default_label)",
            "        help_text = kwargs.pop(\"help_text\", self.default_helptext)",
            "        super().__init__(required=required, label=label, help_text=help_text, *args, **kwargs)",
            "",
            "",
            "class NullableDateField(forms.DateField):",
            "    def to_python(self, value):",
            "        if not value:",
            "            return None",
            "        elif value == \"null\":",
            "            return value",
            "        return super().to_python(value)",
            "",
            "",
            "class SlugField(forms.SlugField):",
            "    \"\"\"",
            "    Extend the built-in SlugField to automatically populate from a field called `name` unless otherwise specified.",
            "    \"\"\"",
            "",
            "    def __init__(self, slug_source=\"name\", *args, **kwargs):",
            "        \"\"\"",
            "        Instantiate a SlugField.",
            "",
            "        Args:",
            "            slug_source (str, tuple): Name of the field (or a list of field names) that will be used to suggest a slug.",
            "        \"\"\"",
            "        kwargs.setdefault(\"label\", \"Slug\")",
            "        kwargs.setdefault(\"help_text\", \"URL-friendly unique shorthand\")",
            "        kwargs.setdefault(\"widget\", widgets.SlugWidget)",
            "        super().__init__(*args, **kwargs)",
            "        if isinstance(slug_source, (tuple, list)):",
            "            slug_source = \" \".join(slug_source)",
            "        self.widget.attrs[\"slug-source\"] = slug_source",
            "",
            "",
            "class DynamicModelChoiceMixin:",
            "    \"\"\"",
            "    :param display_field: The name of the attribute of an API response object to display in the selection list",
            "    :param query_params: A dictionary of additional key/value pairs to attach to the API request",
            "    :param initial_params: A dictionary of child field references to use for selecting a parent field's initial value",
            "    :param null_option: The string used to represent a null selection (if any)",
            "    :param disabled_indicator: The name of the field which, if populated, will disable selection of the",
            "        choice (optional)",
            "    :param brief_mode: Use the \"brief\" format (?brief=true) when making API requests (default)",
            "    \"\"\"",
            "",
            "    filter = django_filters.ModelChoiceFilter  # 2.0 TODO(Glenn): can we rename this? pylint: disable=redefined-builtin",
            "    widget = widgets.APISelect",
            "",
            "    def __init__(",
            "        self,",
            "        display_field=\"display\",",
            "        query_params=None,",
            "        initial_params=None,",
            "        null_option=None,",
            "        disabled_indicator=None,",
            "        brief_mode=True,",
            "        *args,",
            "        **kwargs,",
            "    ):",
            "        self.display_field = display_field",
            "        self.query_params = query_params or {}",
            "        self.initial_params = initial_params or {}",
            "        self.null_option = null_option",
            "        self.disabled_indicator = disabled_indicator",
            "        self.brief_mode = brief_mode",
            "",
            "        # to_field_name is set by ModelChoiceField.__init__(), but we need to set it early for reference",
            "        # by widget_attrs()",
            "        self.to_field_name = kwargs.get(\"to_field_name\")",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def widget_attrs(self, widget):",
            "        attrs = {",
            "            \"display-field\": self.display_field,",
            "        }",
            "",
            "        # Set value-field attribute if the field specifies to_field_name",
            "        if self.to_field_name:",
            "            attrs[\"value-field\"] = self.to_field_name",
            "",
            "        # Set the string used to represent a null option",
            "        if self.null_option is not None:",
            "            attrs[\"data-null-option\"] = self.null_option",
            "",
            "        # Set the disabled indicator, if any",
            "        if self.disabled_indicator is not None:",
            "            attrs[\"disabled-indicator\"] = self.disabled_indicator",
            "",
            "        # Toggle brief mode",
            "        if not self.brief_mode:",
            "            attrs[\"data-full\"] = \"true\"",
            "",
            "        # Attach any static query parameters",
            "        for key, value in self.query_params.items():",
            "            widget.add_query_param(key, value)",
            "",
            "        return attrs",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"",
            "        Augment the behavior of forms.ModelChoiceField.prepare_value().",
            "",
            "        Specifically, if `value` is a PK, but we have `to_field_name` set, we need to look up the model instance",
            "        from the given PK, so that the base class will get the appropriate field value rather than just keeping the PK,",
            "        because the rendered form field needs this in order to correctly prepopulate a default selection.",
            "        \"\"\"",
            "        if self.to_field_name and is_uuid(value):",
            "            try:",
            "                value = self.queryset.get(pk=value)",
            "            except ObjectDoesNotExist:",
            "                pass",
            "        return super().prepare_value(value)",
            "",
            "    def get_bound_field(self, form, field_name):",
            "        bound_field = BoundField(form, self, field_name)",
            "",
            "        # Set initial value based on prescribed child fields (if not already set)",
            "        if not self.initial and self.initial_params:",
            "            filter_kwargs = {}",
            "            for kwarg, child_field in self.initial_params.items():",
            "                value = form.initial.get(child_field.lstrip(\"$\"))",
            "                if value:",
            "                    filter_kwargs[kwarg] = value",
            "            if filter_kwargs:",
            "                self.initial = self.queryset.filter(**filter_kwargs).first()",
            "",
            "        # Modify the QuerySet of the field before we return it. Limit choices to any data already bound: Options",
            "        # will be populated on-demand via the APISelect widget.",
            "        data = bound_field.value()",
            "        if data:",
            "            field_name = getattr(self, \"to_field_name\") or \"pk\"",
            "            filter_ = self.filter(field_name=field_name)",
            "            try:",
            "                self.queryset = filter_.filter(self.queryset, data)",
            "            except (TypeError, ValidationError):",
            "                # Catch any error caused by invalid initial data passed from the user",
            "                self.queryset = self.queryset.none()",
            "        else:",
            "            self.queryset = self.queryset.none()",
            "",
            "        # Set the data URL on the APISelect widget (if not already set)",
            "        widget = bound_field.field.widget",
            "        if not widget.attrs.get(\"data-url\"):",
            "            route = get_route_for_model(self.queryset.model, \"list\", api=True)",
            "            data_url = reverse(route)",
            "            widget.attrs[\"data-url\"] = data_url",
            "",
            "        return bound_field",
            "",
            "",
            "class DynamicModelChoiceField(DynamicModelChoiceMixin, forms.ModelChoiceField):",
            "    \"\"\"",
            "    Override get_bound_field() to avoid pre-populating field choices with a SQL query. The field will be",
            "    rendered only with choices set via bound data. Choices are populated on-demand via the APISelect widget.",
            "    \"\"\"",
            "",
            "    def clean(self, value):",
            "        \"\"\"",
            "        When null option is enabled and \"None\" is sent as part of a form to be submitted, it is sent as the",
            "        string 'null'.  This will check for that condition and gracefully handle the conversion to a NoneType.",
            "        \"\"\"",
            "        if self.null_option is not None and value == settings.FILTERS_NULL_CHOICE_VALUE:",
            "            return None",
            "        return super().clean(value)",
            "",
            "",
            "class DynamicModelMultipleChoiceField(DynamicModelChoiceMixin, forms.ModelMultipleChoiceField):",
            "    \"\"\"",
            "    A multiple-choice version of DynamicModelChoiceField.",
            "    \"\"\"",
            "",
            "    filter = django_filters.ModelMultipleChoiceFilter",
            "    widget = widgets.APISelectMultiple",
            "",
            "",
            "class LaxURLField(forms.URLField):",
            "    \"\"\"",
            "    Modifies Django's built-in URLField to remove the requirement for fully-qualified domain names",
            "    (e.g. http://myserver/ is valid)",
            "    \"\"\"",
            "",
            "    default_validators = [EnhancedURLValidator()]",
            "",
            "",
            "class JSONField(_JSONField):",
            "    \"\"\"",
            "    Custom wrapper around Django's built-in JSONField to avoid presenting \"null\" as the default text.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not self.help_text:",
            "            self.help_text = 'Enter context data in <a href=\"https://json.org/\">JSON</a> format.'",
            "            self.widget.attrs[\"placeholder\"] = \"\"",
            "",
            "    def prepare_value(self, value):",
            "        if isinstance(value, InvalidJSONInput):",
            "            return value",
            "        if value is None:",
            "            return \"\"",
            "        return json.dumps(value, sort_keys=True, indent=4, ensure_ascii=False)",
            "",
            "    # TODO: remove this when we upgrade to Django 4",
            "    def bound_data(self, data, initial):",
            "        if data is None:",
            "            return None",
            "        return super().bound_data(data, initial)",
            "",
            "",
            "class JSONArrayFormField(forms.JSONField):",
            "    \"\"\"",
            "    A FormField counterpart to JSONArrayField.",
            "    Replicates ArrayFormField's base field validation: Field values are validated as JSON Arrays,",
            "    and each Array element is validated by `base_field` validators.",
            "    \"\"\"",
            "",
            "    def __init__(self, base_field, *, delimiter=\",\", **kwargs):",
            "        self.base_field = base_field",
            "        self.delimiter = delimiter",
            "        super().__init__(**kwargs)",
            "",
            "    def clean(self, value):",
            "        \"\"\"",
            "        Validate `value` and return its \"cleaned\" value as an appropriate",
            "        Python object. Raise ValidationError for any errors.",
            "        \"\"\"",
            "        value = super().clean(value)",
            "        return [self.base_field.clean(val) for val in value]",
            "",
            "    def prepare_value(self, value):",
            "        \"\"\"",
            "        Return a string of this value.",
            "        \"\"\"",
            "        if isinstance(value, list):",
            "            return self.delimiter.join(str(self.base_field.prepare_value(v)) for v in value)",
            "        return value",
            "",
            "    def to_python(self, value):",
            "        \"\"\"",
            "        Convert `value` into JSON, raising django.core.exceptions.ValidationError",
            "        if the data can't be converted. Return the converted value.",
            "        \"\"\"",
            "        if isinstance(value, list):",
            "            items = value",
            "        elif value:",
            "            try:",
            "                items = value.split(self.delimiter)",
            "            except Exception as e:",
            "                raise ValidationError(e)",
            "        else:",
            "            items = []",
            "",
            "        errors = []",
            "        values = []",
            "        for item in items:",
            "            try:",
            "                values.append(self.base_field.to_python(item))",
            "            except ValidationError as error:",
            "                errors.append(error)",
            "        if errors:",
            "            raise ValidationError(errors)",
            "        return values",
            "",
            "    def validate(self, value):",
            "        \"\"\"",
            "        Validate `value` and raise ValidationError if necessary.",
            "        \"\"\"",
            "        super().validate(value)",
            "        errors = []",
            "        for item in value:",
            "            try:",
            "                self.base_field.validate(item)",
            "            except ValidationError as error:",
            "                errors.append(error)",
            "        if errors:",
            "            raise ValidationError(errors)",
            "",
            "    def run_validators(self, value):",
            "        \"\"\"",
            "        Runs all validators against `value` and raise ValidationError if necessary.",
            "        Some validators can't be created at field initialization time.",
            "        \"\"\"",
            "        super().run_validators(value)",
            "        errors = []",
            "        for item in value:",
            "            try:",
            "                self.base_field.run_validators(item)",
            "            except ValidationError as error:",
            "                errors.append(error)",
            "        if errors:",
            "            raise ValidationError(errors)",
            "",
            "    def has_changed(self, initial, data):",
            "        \"\"\"",
            "        Return True if `data` differs from `initial`.",
            "        \"\"\"",
            "        value = self.to_python(data)",
            "        if initial in self.empty_values and value in self.empty_values:",
            "            return False",
            "        return super().has_changed(initial, data)",
            "",
            "",
            "class NumericArrayField(SimpleArrayField):",
            "    \"\"\"Basic array field that takes comma-separated or hyphenated ranges.\"\"\"",
            "",
            "    def to_python(self, value):",
            "        try:",
            "            value = \",\".join([str(n) for n in parse_numeric_range(value)])",
            "        except ValueError as error:",
            "            raise ValidationError(error)",
            "        return super().to_python(value)",
            "",
            "",
            "class MultiMatchModelMultipleChoiceField(django_filters.fields.ModelMultipleChoiceField):",
            "    \"\"\"",
            "    Filter field to support matching on the PK *or* `to_field_name` fields (defaulting to `slug` if not specified).",
            "",
            "    Raises ValidationError if none of the fields match the requested value.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.natural_key = kwargs.setdefault(\"to_field_name\", \"slug\")",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def _check_values(self, values):",
            "        \"\"\"",
            "        This method overloads the grandparent method in `django.forms.models.ModelMultipleChoiceField`,",
            "        re-using some of that method's existing logic and adding support for coupling this field with",
            "        multiple model fields.",
            "        \"\"\"",
            "        null = self.null_label is not None and values and self.null_value in values",
            "        if null:",
            "            values = [v for v in values if v != self.null_value]",
            "        # deduplicate given values to avoid creating many querysets or",
            "        # requiring the database backend deduplicate efficiently.",
            "        try:",
            "            values = frozenset(values)",
            "        except TypeError:",
            "            # list of lists isn't hashable, for example",
            "            raise ValidationError(",
            "                self.error_messages[\"invalid_list\"],",
            "                code=\"invalid_list\",",
            "            )",
            "        pk_values = set()",
            "        natural_key_values = set()",
            "        for item in values:",
            "            query = Q()",
            "            if is_uuid(item):",
            "                pk_values.add(item)",
            "                query |= Q(pk=item)",
            "            else:",
            "                natural_key_values.add(item)",
            "                query |= Q(**{self.natural_key: item})",
            "            qs = self.queryset.filter(query)",
            "            if not qs.exists():",
            "                raise ValidationError(",
            "                    self.error_messages[\"invalid_choice\"],",
            "                    code=\"invalid_choice\",",
            "                    params={\"value\": item},",
            "                )",
            "        query = Q(pk__in=pk_values) | Q(**{f\"{self.natural_key}__in\": natural_key_values})",
            "        qs = self.queryset.filter(query)",
            "        result = list(qs)",
            "        if null:",
            "            result += [self.null_value]",
            "        return result",
            "",
            "",
            "class TagFilterField(DynamicModelMultipleChoiceField):",
            "    \"\"\"",
            "    A filter field for the tags of a model. Only the tags used by a model are displayed.",
            "",
            "    :param model: The model of the filter",
            "    \"\"\"",
            "",
            "    def __init__(self, model, *args, query_params=None, queryset=None, **kwargs):",
            "        if queryset is None:",
            "            queryset = model.tags.all()",
            "        query_params = query_params or {}",
            "        query_params.update({\"content_types\": model._meta.label_lower})",
            "        super().__init__(",
            "            label=\"Tags\",",
            "            query_params=query_params,",
            "            queryset=queryset,",
            "            required=False,",
            "            to_field_name=\"slug\",",
            "            *args,",
            "            **kwargs,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "394": [
                "CommentField"
            ],
            "395": [
                "CommentField"
            ],
            "396": [
                "CommentField"
            ],
            "397": [
                "CommentField"
            ],
            "398": [
                "CommentField"
            ],
            "399": [
                "CommentField"
            ]
        },
        "addLocation": []
    },
    "nautobot/utilities/logging.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import re"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.conf import settings"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+import nh3"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from nautobot.utilities import constants"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "9": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "             logger.error('Error in string sanitization using \"%s\"', sanitizer)"
            },
            "10": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     return string"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+def clean_html(html):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    \"\"\"Use nh3/ammonia to strip out all HTML tags and attributes except those explicitly permitted.\"\"\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    return nh3.clean("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        html,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        tags=constants.HTML_ALLOWED_TAGS,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        attributes=constants.HTML_ALLOWED_ATTRIBUTES,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        url_schemes=set(settings.ALLOWED_URL_SCHEMES),"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    )"
            }
        },
        "frontPatchFile": [
            "\"\"\"Utilities for working with log messages and similar features.\"\"\"",
            "",
            "import logging",
            "import re",
            "",
            "from django.conf import settings",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def sanitize(string, replacement=\"(redacted)\"):",
            "    \"\"\"",
            "    Make an attempt at stripping potentially-sensitive information from the given string.",
            "",
            "    Obviously this will never be 100% foolproof but we can at least try.",
            "",
            "    Uses settings.SANITIZER_PATTERNS as the list of (regexp, repl) tuples to apply.",
            "    \"\"\"",
            "    # Don't allow regex match groups to be referenced in the replacement string!",
            "    assert not re.search(r\"\\\\\\d|\\\\g<\\d+>\", replacement)",
            "",
            "    for sanitizer, repl in settings.SANITIZER_PATTERNS:",
            "        try:",
            "            string = sanitizer.sub(repl.format(replacement=replacement), string)",
            "        except re.error:",
            "            logger.error('Error in string sanitization using \"%s\"', sanitizer)",
            "",
            "    return string"
        ],
        "afterPatchFile": [
            "\"\"\"Utilities for working with log messages and similar features.\"\"\"",
            "",
            "import logging",
            "import re",
            "",
            "from django.conf import settings",
            "import nh3",
            "",
            "from nautobot.utilities import constants",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def sanitize(string, replacement=\"(redacted)\"):",
            "    \"\"\"",
            "    Make an attempt at stripping potentially-sensitive information from the given string.",
            "",
            "    Obviously this will never be 100% foolproof but we can at least try.",
            "",
            "    Uses settings.SANITIZER_PATTERNS as the list of (regexp, repl) tuples to apply.",
            "    \"\"\"",
            "    # Don't allow regex match groups to be referenced in the replacement string!",
            "    assert not re.search(r\"\\\\\\d|\\\\g<\\d+>\", replacement)",
            "",
            "    for sanitizer, repl in settings.SANITIZER_PATTERNS:",
            "        try:",
            "            string = sanitizer.sub(repl.format(replacement=replacement), string)",
            "        except re.error:",
            "            logger.error('Error in string sanitization using \"%s\"', sanitizer)",
            "",
            "    return string",
            "",
            "",
            "def clean_html(html):",
            "    \"\"\"Use nh3/ammonia to strip out all HTML tags and attributes except those explicitly permitted.\"\"\"",
            "    return nh3.clean(",
            "        html,",
            "        tags=constants.HTML_ALLOWED_TAGS,",
            "        attributes=constants.HTML_ALLOWED_ATTRIBUTES,",
            "        url_schemes=set(settings.ALLOWED_URL_SCHEMES),",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.urllib3.util.retry"
        ]
    },
    "nautobot/utilities/templatetags/helpers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.contrib.staticfiles.finders import find"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.templatetags.static import static, StaticNode"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.urls import NoReverseMatch, reverse"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import format_html, strip_tags"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from django.utils.safestring import mark_safe"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from markdown import markdown"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from django_jinja import library"
            },
            "8": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from nautobot.utilities.config import get_settings_or_config"
            },
            "10": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from nautobot.utilities.forms import TableConfigForm"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from nautobot.utilities.logging import clean_html"
            },
            "12": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from nautobot.utilities.utils import foreground_color, get_route_for_model, UtilizationData"
            },
            "13": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " HTML_TRUE = mark_safe('<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>')  # noqa: S308"
            },
            "15": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     Example:"
            },
            "16": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         {{ text | render_markdown }}"
            },
            "17": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     \"\"\""
            },
            "18": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Strip HTML tags"
            },
            "19": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    value = strip_tags(value)"
            },
            "20": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "21": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Sanitize Markdown links"
            },
            "22": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    schemes = \"|\".join(settings.ALLOWED_URL_SCHEMES)"
            },
            "23": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pattern = rf\"\\[(.+)\\]\\((?!({schemes})).*:(.+)\\)\""
            },
            "24": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    value = re.sub(pattern, \"[\\\\1](\\\\3)\", value, flags=re.IGNORECASE)"
            },
            "25": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     # Render Markdown"
            },
            "27": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     html = markdown(value, extensions=[\"fenced_code\", \"tables\"])"
            },
            "28": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return mark_safe(html)  # noqa: S308"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+    # Sanitize rendered HTML"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+    html = clean_html(html)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    return mark_safe(html)  # noqa: S308  # suspicious-mark-safe-usage, OK here since we sanitized the string earlier"
            },
            "34": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 174,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " @library.filter()"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import json",
            "import re",
            "",
            "import yaml",
            "from django import template",
            "from django.conf import settings",
            "from django.contrib.staticfiles.finders import find",
            "from django.templatetags.static import static, StaticNode",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import format_html, strip_tags",
            "from django.utils.safestring import mark_safe",
            "from markdown import markdown",
            "from django_jinja import library",
            "",
            "from nautobot.utilities.config import get_settings_or_config",
            "from nautobot.utilities.forms import TableConfigForm",
            "from nautobot.utilities.utils import foreground_color, get_route_for_model, UtilizationData",
            "",
            "HTML_TRUE = mark_safe('<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>')  # noqa: S308",
            "HTML_FALSE = mark_safe('<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>')  # noqa: S308",
            "HTML_NONE = mark_safe('<span class=\"text-muted\">&mdash;</span>')  # noqa: S308",
            "",
            "DEFAULT_SUPPORT_MESSAGE = (",
            "    \"If further assistance is required, please join the `#nautobot` channel \"",
            "    \"on [Network to Code's Slack community](https://slack.networktocode.com/) and post your question.\"",
            ")",
            "",
            "register = template.Library()",
            "",
            "",
            "#",
            "# Filters",
            "#",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def hyperlinked_object(value, field=\"display\"):",
            "    \"\"\"Render and link to a Django model instance, if any, or render a placeholder if not.",
            "",
            "    Uses the specified object field if available, otherwise uses the string representation of the object.",
            "    If the object defines `get_absolute_url()` this will be used to hyperlink the displayed object;",
            "    additionally if there is an `object.description` this will be used as the title of the hyperlink.",
            "",
            "    Args:",
            "        value (django.db.models.Model, None)",
            "",
            "    Returns:",
            "        str: String representation of the value (hyperlinked if it defines get_absolute_url()) or a placeholder.",
            "",
            "    Examples:",
            "        >>> hyperlinked_object(device)",
            "        '<a href=\"/dcim/devices/3faafe8c-bdd6-4317-88dc-f791e6988caa/\">Device 1</a>'",
            "        >>> hyperlinked_object(device_role)",
            "        '<a href=\"/dcim/device-roles/router/\" title=\"Devices that are routers, not switches\">Router</a>'",
            "        >>> hyperlinked_object(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> hyperlinked_object(\"Hello\")",
            "        'Hello'",
            "        >>> hyperlinked_object(location)",
            "        '<a href=\"/dcim/locations/leaf/\">Root \u2192 Intermediate \u2192 Leaf</a>'",
            "        >>> hyperlinked_object(location, \"name\")",
            "        '<a href=\"/dcim/locations/leaf/\">Leaf</a>'",
            "    \"\"\"",
            "    if value is None:",
            "        return placeholder(value)",
            "    display = getattr(value, field) if hasattr(value, field) else str(value)",
            "    if hasattr(value, \"get_absolute_url\"):",
            "        if hasattr(value, \"description\") and value.description:",
            "            return format_html('<a href=\"{}\" title=\"{}\">{}</a>', value.get_absolute_url(), value.description, display)",
            "        return format_html('<a href=\"{}\">{}</a>', value.get_absolute_url(), display)",
            "    return format_html(\"{}\", display)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def placeholder(value):",
            "    \"\"\"Render a muted placeholder if value is falsey, else render the value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "",
            "    Returns:",
            "        str: Placeholder in HTML, or the string representation of the value.",
            "",
            "    Example:",
            "        >>> placeholder(\"\")",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> placeholder(\"hello\")",
            "        \"hello\"",
            "    \"\"\"",
            "    if value:",
            "        return value",
            "    return HTML_NONE",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def add_html_id(element_str, id_str):",
            "    \"\"\"Add an HTML `id=\"...\"` attribute to the given HTML element string.",
            "",
            "    Args:",
            "        element_str (str): String describing an HTML element.",
            "        id_str (str): String to add as the `id` attribute of the element_str.",
            "",
            "    Returns:",
            "        str: HTML string with added `id`.",
            "",
            "    Example:",
            "        >>> add_html_id(\"<div></div>\", \"my-div\")",
            "        '<div id=\"my-div\"></div>'",
            "        >>> add_html_id('<a href=\"...\" title=\"...\">Hello!</a>', \"my-a\")",
            "        '<a id=\"my-a\" href=\"...\" title=\"...\">Hello!</a>'",
            "    \"\"\"",
            "    match = re.match(r\"^(.*?<\\w+) ?(.*)$\", element_str, flags=re.DOTALL)",
            "    if not match:",
            "        return element_str",
            "    return mark_safe(match.group(1) + format_html(' id=\"{}\" ', id_str) + match.group(2))  # noqa: S308",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_boolean(value):",
            "    \"\"\"Render HTML from a computed boolean value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "        A truthy value (for example non-empty string / True / non-zero number) is considered True.",
            "        A falsey value other than None (for example \"\" or 0 or False) is considered False.",
            "        A value of None is considered neither True nor False.",
            "",
            "    Returns:",
            "        str: HTML",
            "        '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>' if True value",
            "        - or -",
            "        '<span class=\"text-muted\">&mdash;</span>' if None value",
            "        - or -",
            "        '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>' if False value",
            "",
            "    Examples:",
            "        >>> render_boolean(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> render_boolean(True or \"arbitrary string\" or 1)",
            "        '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>'",
            "        >>> render_boolean(False or \"\" or 0)",
            "        '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>'",
            "    \"\"\"",
            "    if value is None:",
            "        return HTML_NONE",
            "    if bool(value):",
            "        return HTML_TRUE",
            "    return HTML_FALSE",
            "",
            "",
            "@library.filter()",
            "@register.filter(is_safe=True)",
            "def render_markdown(value):",
            "    \"\"\"",
            "    Render text as Markdown",
            "",
            "    Example:",
            "        {{ text | render_markdown }}",
            "    \"\"\"",
            "    # Strip HTML tags",
            "    value = strip_tags(value)",
            "",
            "    # Sanitize Markdown links",
            "    schemes = \"|\".join(settings.ALLOWED_URL_SCHEMES)",
            "    pattern = rf\"\\[(.+)\\]\\((?!({schemes})).*:(.+)\\)\"",
            "    value = re.sub(pattern, \"[\\\\1](\\\\3)\", value, flags=re.IGNORECASE)",
            "",
            "    # Render Markdown",
            "    html = markdown(value, extensions=[\"fenced_code\", \"tables\"])",
            "",
            "    return mark_safe(html)  # noqa: S308",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_json(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted JSON.",
            "    \"\"\"",
            "    return json.dumps(value, indent=4, sort_keys=True, ensure_ascii=False)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_yaml(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted YAML.",
            "    \"\"\"",
            "    return yaml.dump(json.loads(json.dumps(value, ensure_ascii=False)), allow_unicode=True)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meta(obj, attr):",
            "    \"\"\"",
            "    Return the specified Meta attribute of a model. This is needed because Django does not permit templates",
            "    to access attributes which begin with an underscore (e.g. _meta).",
            "",
            "    Args:",
            "        obj (models.Model): Class or Instance of a Django Model",
            "        attr (str): name of the attribute to access",
            "",
            "    Returns:",
            "        any: return the value of the attribute",
            "    \"\"\"",
            "    return getattr(obj._meta, attr, \"\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action. Does not perform any validation.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        str: return the name of the view for the model/action provided.",
            "    Examples:",
            "        >>> viewname(Device, \"list\")",
            "        \"dcim:device_list\"",
            "    \"\"\"",
            "    return get_route_for_model(model, action)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def validated_viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action if valid, or None if invalid.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        str or None: return the name of the view for the model/action provided if valid, or None if invalid.",
            "    \"\"\"",
            "    viewname_str = get_route_for_model(model, action)",
            "",
            "    try:",
            "        # Validate and return the view name. We don't return the actual URL yet because many of the templates",
            "        # are written to pass a name to {% url %}.",
            "        reverse(viewname_str)",
            "        return viewname_str",
            "    except NoReverseMatch:",
            "        return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def bettertitle(value):",
            "    \"\"\"",
            "    Alternative to the builtin title(); capitalizes words without replacing letters that are already uppercase.",
            "",
            "    Args:",
            "        value (str): string to convert to Title Case",
            "",
            "    Returns:",
            "        str: string in Title format",
            "",
            "    Example:",
            "        >>> bettertitle(\"IP address\")",
            "        \"IP Address\"",
            "    \"\"\"",
            "    return \" \".join([w[0].upper() + w[1:] for w in value.split()])",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def humanize_speed(speed):",
            "    \"\"\"",
            "    Humanize speeds given in Kbps. Examples:",
            "",
            "        1544 => \"1.544 Mbps\"",
            "        100000 => \"100 Mbps\"",
            "        10000000 => \"10 Gbps\"",
            "    \"\"\"",
            "    if not speed:",
            "        return \"\"",
            "    if speed >= 1000000000 and speed % 1000000000 == 0:",
            "        return f\"{int(speed / 1000000000)} Tbps\"",
            "    elif speed >= 1000000 and speed % 1000000 == 0:",
            "        return f\"{int(speed / 1000000)} Gbps\"",
            "    elif speed >= 1000 and speed % 1000 == 0:",
            "        return f\"{int(speed / 1000)} Mbps\"",
            "    elif speed >= 1000:",
            "        return f\"{float(speed) / 1000} Mbps\"",
            "    else:",
            "        return f\"{speed} Kbps\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def tzoffset(value):",
            "    \"\"\"",
            "    Returns the hour offset of a given time zone using the current time.",
            "    \"\"\"",
            "    return datetime.datetime.now(value).strftime(\"%z\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def fgcolor(value):",
            "    \"\"\"",
            "    Return the ideal foreground color (block or white) given an arbitrary background color in RRGGBB format.",
            "",
            "    Args:",
            "        value (str): Color in RRGGBB format, with or without #",
            "",
            "    Returns:",
            "        str: ideal foreground color, either black (#000000) or white (#ffffff)",
            "",
            "    Example:",
            "        >>> fgcolor(\"#999999\")",
            "        \"#ffffff\"",
            "    \"\"\"",
            "    value = value.lower().strip(\"#\")",
            "    if not re.match(\"^[0-9a-f]{6}$\", value):",
            "        return \"\"",
            "    return f\"#{foreground_color(value)}\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def divide(x, y):",
            "    \"\"\"Return x/y (rounded).",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        int: x/y (rounded)",
            "",
            "    Examples:",
            "        >>> divide(10, 3)",
            "        3",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def percentage(x, y):",
            "    \"\"\"Return x/y as a percentage.",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        int: x/y as a percentage",
            "",
            "    Examples:",
            "        >>> percentage(2, 10)",
            "        20",
            "",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y * 100)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_docs_url(model):",
            "    \"\"\"Return the documentation URL for the specified model.",
            "",
            "    Nautobot Core models have a path like docs/models/{app_label}/{model_name}",
            "    while plugins will have {app_label}/docs/models/{model_name}. If the html file",
            "    does not exist, this function will return None.",
            "",
            "    Args:",
            "        model (models.Model): Instance of a Django model",
            "",
            "    Returns:",
            "        str: static URL for the documentation of the object.",
            "        or",
            "        None",
            "",
            "    Example:",
            "        >>> get_docs_url(obj)",
            "        \"static/docs/models/dcim/site.html\"",
            "    \"\"\"",
            "    path = f\"docs/models/{model._meta.app_label}/{model._meta.model_name}.html\"",
            "    if model._meta.app_label in settings.PLUGINS:",
            "        path = f\"{model._meta.app_label}/docs/models/{model._meta.model_name}.html\"",
            "",
            "    # Check to see if documentation exists in any of the static paths.",
            "    if find(path):",
            "        return static(path)",
            "    return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *all* permissions in the list.",
            "    \"\"\"",
            "    return user.has_perms(permissions_list)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_one_or_more_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *at least one* permissions in the list.",
            "    \"\"\"",
            "",
            "    for permission in permissions_list:",
            "        if user.has_perm(permission):",
            "            return True",
            "    return False",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def split(string, sep=\",\"):",
            "    \"\"\"Split a string by the given value (default: comma)",
            "",
            "    Args:",
            "        string (str): string to split into a list",
            "        sep (str default=,): separator to look for in the string",
            "",
            "    Returns:",
            "        [list]: List of string, if the separator wasn't found, list of 1",
            "    \"\"\"",
            "    return string.split(sep)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def as_range(n):",
            "    \"\"\"Return a range of n items.",
            "",
            "    Args:",
            "        n (int, str): Number of element in the range",
            "",
            "    Returns:",
            "        [list, Range]: range function from o to the value provided. Returns an empty list if n is not valid.",
            "",
            "    Example:",
            "        {% for i in record.parents|as_range %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "        {% endfor %}",
            "    \"\"\"",
            "    try:",
            "        int(n)",
            "    except (TypeError, ValueError):",
            "        return []",
            "    return range(int(n))",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meters_to_feet(n):",
            "    \"\"\"Convert a length from meters to feet.",
            "",
            "    Args:",
            "        n (int, float, str): Number of meters to convert",
            "",
            "    Returns:",
            "        [float]: Value in feet",
            "    \"\"\"",
            "    return float(n) * 3.28084",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_item(d, key):",
            "    \"\"\"Access a specific item/key in a dictionary",
            "",
            "    Args:",
            "        d (dict): dictionary containing the data to access",
            "        key (str]): name of the item/key to access",
            "",
            "    Returns:",
            "        [any]: Value of the item in the dictionary provided",
            "",
            "    Example:",
            "        >>> get_items(data, key)",
            "        \"value\"",
            "    \"\"\"",
            "    return d.get(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def settings_or_config(key):",
            "    \"\"\"Get a value from Django settings (if specified there) or Constance configuration (otherwise).\"\"\"",
            "    return get_settings_or_config(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def quote_string(value):",
            "    \"\"\"Add literal quote characters around the provided value if it's a string.\"\"\"",
            "    if isinstance(value, str):",
            "        return f'\"{value}\"'",
            "    return value",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "@register.simple_tag()",
            "def get_attr(obj, attr, default=None):",
            "    return getattr(obj, attr, default)",
            "",
            "",
            "@register.simple_tag()",
            "def querystring(request, **kwargs):",
            "    \"\"\"",
            "    Append or update the page number in a querystring.",
            "    \"\"\"",
            "    querydict = request.GET.copy()",
            "    for k, v in kwargs.items():",
            "        if v is not None:",
            "            querydict[k] = str(v)",
            "        elif k in querydict:",
            "            querydict.pop(k)",
            "    query_string = querydict.urlencode(safe=\"/\")",
            "    if query_string:",
            "        return \"?\" + query_string",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph(utilization_data, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Wrapper for a horizontal bar graph indicating a percentage of utilization from a tuple of data.",
            "",
            "    Takes the utilization_data that is a namedtuple with numerator and denominator field names and passes them into",
            "    the utilization_graph_raw_data to handle the generation graph data.",
            "",
            "    Args:",
            "        utilization_data (UtilizationData): Namedtuple with numerator and denominator keys",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        dict: Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # See https://github.com/nautobot/nautobot/issues/1169",
            "    # If `get_utilization()` threw an exception, utilization_data will be an empty string",
            "    # rather than a UtilizationData instance. Avoid a potentially confusing exception in that case.",
            "    if not isinstance(utilization_data, UtilizationData):",
            "        return {}",
            "    return utilization_graph_raw_data(",
            "        numerator=utilization_data.numerator,",
            "        denominator=utilization_data.denominator,",
            "        warning_threshold=warning_threshold,",
            "        danger_threshold=danger_threshold,",
            "    )",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph_raw_data(numerator, denominator, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Display a horizontal bar graph indicating a percentage of utilization.",
            "",
            "    Args:",
            "        numerator (int): Numerator for creating a percentage",
            "        denominator (int): Denominator for creating a percentage",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        dict: Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # Check for possible division by zero error",
            "    if denominator == 0:",
            "        utilization = 0",
            "    else:",
            "        utilization = int(float(numerator) / denominator * 100)",
            "",
            "    return {",
            "        \"utilization\": utilization,",
            "        \"warning_threshold\": warning_threshold,",
            "        \"danger_threshold\": danger_threshold,",
            "        \"utilization_count\": numerator,",
            "        \"total_count\": denominator,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/tag.html\")",
            "def tag(tag, url_name=None):  # pylint: disable=redefined-outer-name",
            "    \"\"\"",
            "    Display a tag, optionally linked to a filtered list of objects.",
            "    \"\"\"",
            "    return {",
            "        \"tag\": tag,",
            "        \"url_name\": url_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/badge.html\")",
            "def badge(value, show_empty=False):",
            "    \"\"\"",
            "    Display the specified number as a badge.",
            "    \"\"\"",
            "    return {",
            "        \"value\": value,",
            "        \"show_empty\": show_empty,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/table_config_form.html\")",
            "def table_config_form(table, table_name=None):",
            "    return {",
            "        \"table_name\": table_name or table.__class__.__name__,",
            "        \"table_config_form\": TableConfigForm(table=table),",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/filter_form_modal.html\")",
            "def filter_form_modal(",
            "    filter_form,",
            "    dynamic_filter_form,",
            "    model_plural_name,",
            "    filter_form_name=\"FilterForm\",",
            "    dynamic_filter_form_name=\"DynamicFilterForm\",",
            "):",
            "    return {",
            "        \"model_plural_name\": model_plural_name,",
            "        \"filter_form\": filter_form,",
            "        \"filter_form_name\": filter_form_name,",
            "        \"dynamic_filter_form\": dynamic_filter_form,",
            "        \"dynamic_filter_form_name\": dynamic_filter_form_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/modal_form_as_dialog.html\")",
            "def modal_form_as_dialog(form, editing=False, form_name=None, obj=None, obj_type=None):",
            "    \"\"\"Generate a form in a modal view.",
            "",
            "    Create an overlaying modal view which holds a Django form.",
            "",
            "    Inside of the template the template tag needs to be used with the correct inputs. A button will",
            "    also need to be create to open and close the modal. See below for an example:",
            "",
            "    ```",
            "    {% modal_form_as_dialog form editing=False form_name=\"CreateDevice\" obj=obj obj_type=\"Device\" %}",
            "    <a class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#CreateDevice_form\" title=\"Query Form\">Create Device</a>",
            "    ```",
            "    Args:",
            "        form (django.form.Forms): Django form object.",
            "        editing (bool, optional): Is the form creating or editing an object? Defaults to False for create.",
            "        form_name ([type], optional): Name of form. Defaults to None. If None get name from class name.",
            "        obj (django.model.Object, optional): If editing an existing model object, the object needs to be passed in. Defaults to None.",
            "        obj_type (string, optional): Used in title of form to display object type. Defaults to None.",
            "",
            "    Returns:",
            "        dict: Passed in values used to render HTML.",
            "    \"\"\"",
            "    return {",
            "        \"editing\": editing,",
            "        \"form\": form,",
            "        \"form_action_url\": form.get_action_url(),",
            "        \"form_name\": form_name or form.__class__.__name__,",
            "        \"obj\": obj,",
            "        \"obj_type\": obj_type,",
            "    }",
            "",
            "",
            "@register.simple_tag",
            "def custom_branding_or_static(branding_asset, static_asset):",
            "    \"\"\"",
            "    This tag attempts to return custom branding assets relative to the MEDIA_ROOT and MEDIA_URL, if such",
            "    branding has been configured in settings, else it returns stock branding via static.",
            "    \"\"\"",
            "    if settings.BRANDING_FILEPATHS.get(branding_asset):",
            "        return f\"{ settings.MEDIA_URL }{ settings.BRANDING_FILEPATHS.get(branding_asset) }\"",
            "    return StaticNode.handle_simple(static_asset)",
            "",
            "",
            "@register.simple_tag",
            "def support_message():",
            "    \"\"\"",
            "    Return the configured support message (if any) or else the default.",
            "    \"\"\"",
            "    try:",
            "        message = get_settings_or_config(\"SUPPORT_MESSAGE\")",
            "    except AttributeError:",
            "        message = \"\"",
            "    if not message:",
            "        message = DEFAULT_SUPPORT_MESSAGE",
            "    return render_markdown(message)"
        ],
        "afterPatchFile": [
            "import datetime",
            "import json",
            "import re",
            "",
            "import yaml",
            "from django import template",
            "from django.conf import settings",
            "from django.contrib.staticfiles.finders import find",
            "from django.templatetags.static import static, StaticNode",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import format_html",
            "from django.utils.safestring import mark_safe",
            "from markdown import markdown",
            "from django_jinja import library",
            "",
            "from nautobot.utilities.config import get_settings_or_config",
            "from nautobot.utilities.forms import TableConfigForm",
            "from nautobot.utilities.logging import clean_html",
            "from nautobot.utilities.utils import foreground_color, get_route_for_model, UtilizationData",
            "",
            "HTML_TRUE = mark_safe('<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>')  # noqa: S308",
            "HTML_FALSE = mark_safe('<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>')  # noqa: S308",
            "HTML_NONE = mark_safe('<span class=\"text-muted\">&mdash;</span>')  # noqa: S308",
            "",
            "DEFAULT_SUPPORT_MESSAGE = (",
            "    \"If further assistance is required, please join the `#nautobot` channel \"",
            "    \"on [Network to Code's Slack community](https://slack.networktocode.com/) and post your question.\"",
            ")",
            "",
            "register = template.Library()",
            "",
            "",
            "#",
            "# Filters",
            "#",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def hyperlinked_object(value, field=\"display\"):",
            "    \"\"\"Render and link to a Django model instance, if any, or render a placeholder if not.",
            "",
            "    Uses the specified object field if available, otherwise uses the string representation of the object.",
            "    If the object defines `get_absolute_url()` this will be used to hyperlink the displayed object;",
            "    additionally if there is an `object.description` this will be used as the title of the hyperlink.",
            "",
            "    Args:",
            "        value (django.db.models.Model, None)",
            "",
            "    Returns:",
            "        str: String representation of the value (hyperlinked if it defines get_absolute_url()) or a placeholder.",
            "",
            "    Examples:",
            "        >>> hyperlinked_object(device)",
            "        '<a href=\"/dcim/devices/3faafe8c-bdd6-4317-88dc-f791e6988caa/\">Device 1</a>'",
            "        >>> hyperlinked_object(device_role)",
            "        '<a href=\"/dcim/device-roles/router/\" title=\"Devices that are routers, not switches\">Router</a>'",
            "        >>> hyperlinked_object(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> hyperlinked_object(\"Hello\")",
            "        'Hello'",
            "        >>> hyperlinked_object(location)",
            "        '<a href=\"/dcim/locations/leaf/\">Root \u2192 Intermediate \u2192 Leaf</a>'",
            "        >>> hyperlinked_object(location, \"name\")",
            "        '<a href=\"/dcim/locations/leaf/\">Leaf</a>'",
            "    \"\"\"",
            "    if value is None:",
            "        return placeholder(value)",
            "    display = getattr(value, field) if hasattr(value, field) else str(value)",
            "    if hasattr(value, \"get_absolute_url\"):",
            "        if hasattr(value, \"description\") and value.description:",
            "            return format_html('<a href=\"{}\" title=\"{}\">{}</a>', value.get_absolute_url(), value.description, display)",
            "        return format_html('<a href=\"{}\">{}</a>', value.get_absolute_url(), display)",
            "    return format_html(\"{}\", display)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def placeholder(value):",
            "    \"\"\"Render a muted placeholder if value is falsey, else render the value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "",
            "    Returns:",
            "        str: Placeholder in HTML, or the string representation of the value.",
            "",
            "    Example:",
            "        >>> placeholder(\"\")",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> placeholder(\"hello\")",
            "        \"hello\"",
            "    \"\"\"",
            "    if value:",
            "        return value",
            "    return HTML_NONE",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def add_html_id(element_str, id_str):",
            "    \"\"\"Add an HTML `id=\"...\"` attribute to the given HTML element string.",
            "",
            "    Args:",
            "        element_str (str): String describing an HTML element.",
            "        id_str (str): String to add as the `id` attribute of the element_str.",
            "",
            "    Returns:",
            "        str: HTML string with added `id`.",
            "",
            "    Example:",
            "        >>> add_html_id(\"<div></div>\", \"my-div\")",
            "        '<div id=\"my-div\"></div>'",
            "        >>> add_html_id('<a href=\"...\" title=\"...\">Hello!</a>', \"my-a\")",
            "        '<a id=\"my-a\" href=\"...\" title=\"...\">Hello!</a>'",
            "    \"\"\"",
            "    match = re.match(r\"^(.*?<\\w+) ?(.*)$\", element_str, flags=re.DOTALL)",
            "    if not match:",
            "        return element_str",
            "    return mark_safe(match.group(1) + format_html(' id=\"{}\" ', id_str) + match.group(2))  # noqa: S308",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_boolean(value):",
            "    \"\"\"Render HTML from a computed boolean value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "        A truthy value (for example non-empty string / True / non-zero number) is considered True.",
            "        A falsey value other than None (for example \"\" or 0 or False) is considered False.",
            "        A value of None is considered neither True nor False.",
            "",
            "    Returns:",
            "        str: HTML",
            "        '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>' if True value",
            "        - or -",
            "        '<span class=\"text-muted\">&mdash;</span>' if None value",
            "        - or -",
            "        '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>' if False value",
            "",
            "    Examples:",
            "        >>> render_boolean(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> render_boolean(True or \"arbitrary string\" or 1)",
            "        '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>'",
            "        >>> render_boolean(False or \"\" or 0)",
            "        '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>'",
            "    \"\"\"",
            "    if value is None:",
            "        return HTML_NONE",
            "    if bool(value):",
            "        return HTML_TRUE",
            "    return HTML_FALSE",
            "",
            "",
            "@library.filter()",
            "@register.filter(is_safe=True)",
            "def render_markdown(value):",
            "    \"\"\"",
            "    Render text as Markdown",
            "",
            "    Example:",
            "        {{ text | render_markdown }}",
            "    \"\"\"",
            "    # Render Markdown",
            "    html = markdown(value, extensions=[\"fenced_code\", \"tables\"])",
            "",
            "    # Sanitize rendered HTML",
            "    html = clean_html(html)",
            "",
            "    return mark_safe(html)  # noqa: S308  # suspicious-mark-safe-usage, OK here since we sanitized the string earlier",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_json(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted JSON.",
            "    \"\"\"",
            "    return json.dumps(value, indent=4, sort_keys=True, ensure_ascii=False)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_yaml(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted YAML.",
            "    \"\"\"",
            "    return yaml.dump(json.loads(json.dumps(value, ensure_ascii=False)), allow_unicode=True)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meta(obj, attr):",
            "    \"\"\"",
            "    Return the specified Meta attribute of a model. This is needed because Django does not permit templates",
            "    to access attributes which begin with an underscore (e.g. _meta).",
            "",
            "    Args:",
            "        obj (models.Model): Class or Instance of a Django Model",
            "        attr (str): name of the attribute to access",
            "",
            "    Returns:",
            "        any: return the value of the attribute",
            "    \"\"\"",
            "    return getattr(obj._meta, attr, \"\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action. Does not perform any validation.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        str: return the name of the view for the model/action provided.",
            "    Examples:",
            "        >>> viewname(Device, \"list\")",
            "        \"dcim:device_list\"",
            "    \"\"\"",
            "    return get_route_for_model(model, action)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def validated_viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action if valid, or None if invalid.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        str or None: return the name of the view for the model/action provided if valid, or None if invalid.",
            "    \"\"\"",
            "    viewname_str = get_route_for_model(model, action)",
            "",
            "    try:",
            "        # Validate and return the view name. We don't return the actual URL yet because many of the templates",
            "        # are written to pass a name to {% url %}.",
            "        reverse(viewname_str)",
            "        return viewname_str",
            "    except NoReverseMatch:",
            "        return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def bettertitle(value):",
            "    \"\"\"",
            "    Alternative to the builtin title(); capitalizes words without replacing letters that are already uppercase.",
            "",
            "    Args:",
            "        value (str): string to convert to Title Case",
            "",
            "    Returns:",
            "        str: string in Title format",
            "",
            "    Example:",
            "        >>> bettertitle(\"IP address\")",
            "        \"IP Address\"",
            "    \"\"\"",
            "    return \" \".join([w[0].upper() + w[1:] for w in value.split()])",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def humanize_speed(speed):",
            "    \"\"\"",
            "    Humanize speeds given in Kbps. Examples:",
            "",
            "        1544 => \"1.544 Mbps\"",
            "        100000 => \"100 Mbps\"",
            "        10000000 => \"10 Gbps\"",
            "    \"\"\"",
            "    if not speed:",
            "        return \"\"",
            "    if speed >= 1000000000 and speed % 1000000000 == 0:",
            "        return f\"{int(speed / 1000000000)} Tbps\"",
            "    elif speed >= 1000000 and speed % 1000000 == 0:",
            "        return f\"{int(speed / 1000000)} Gbps\"",
            "    elif speed >= 1000 and speed % 1000 == 0:",
            "        return f\"{int(speed / 1000)} Mbps\"",
            "    elif speed >= 1000:",
            "        return f\"{float(speed) / 1000} Mbps\"",
            "    else:",
            "        return f\"{speed} Kbps\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def tzoffset(value):",
            "    \"\"\"",
            "    Returns the hour offset of a given time zone using the current time.",
            "    \"\"\"",
            "    return datetime.datetime.now(value).strftime(\"%z\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def fgcolor(value):",
            "    \"\"\"",
            "    Return the ideal foreground color (block or white) given an arbitrary background color in RRGGBB format.",
            "",
            "    Args:",
            "        value (str): Color in RRGGBB format, with or without #",
            "",
            "    Returns:",
            "        str: ideal foreground color, either black (#000000) or white (#ffffff)",
            "",
            "    Example:",
            "        >>> fgcolor(\"#999999\")",
            "        \"#ffffff\"",
            "    \"\"\"",
            "    value = value.lower().strip(\"#\")",
            "    if not re.match(\"^[0-9a-f]{6}$\", value):",
            "        return \"\"",
            "    return f\"#{foreground_color(value)}\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def divide(x, y):",
            "    \"\"\"Return x/y (rounded).",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        int: x/y (rounded)",
            "",
            "    Examples:",
            "        >>> divide(10, 3)",
            "        3",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def percentage(x, y):",
            "    \"\"\"Return x/y as a percentage.",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        int: x/y as a percentage",
            "",
            "    Examples:",
            "        >>> percentage(2, 10)",
            "        20",
            "",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y * 100)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_docs_url(model):",
            "    \"\"\"Return the documentation URL for the specified model.",
            "",
            "    Nautobot Core models have a path like docs/models/{app_label}/{model_name}",
            "    while plugins will have {app_label}/docs/models/{model_name}. If the html file",
            "    does not exist, this function will return None.",
            "",
            "    Args:",
            "        model (models.Model): Instance of a Django model",
            "",
            "    Returns:",
            "        str: static URL for the documentation of the object.",
            "        or",
            "        None",
            "",
            "    Example:",
            "        >>> get_docs_url(obj)",
            "        \"static/docs/models/dcim/site.html\"",
            "    \"\"\"",
            "    path = f\"docs/models/{model._meta.app_label}/{model._meta.model_name}.html\"",
            "    if model._meta.app_label in settings.PLUGINS:",
            "        path = f\"{model._meta.app_label}/docs/models/{model._meta.model_name}.html\"",
            "",
            "    # Check to see if documentation exists in any of the static paths.",
            "    if find(path):",
            "        return static(path)",
            "    return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *all* permissions in the list.",
            "    \"\"\"",
            "    return user.has_perms(permissions_list)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_one_or_more_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *at least one* permissions in the list.",
            "    \"\"\"",
            "",
            "    for permission in permissions_list:",
            "        if user.has_perm(permission):",
            "            return True",
            "    return False",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def split(string, sep=\",\"):",
            "    \"\"\"Split a string by the given value (default: comma)",
            "",
            "    Args:",
            "        string (str): string to split into a list",
            "        sep (str default=,): separator to look for in the string",
            "",
            "    Returns:",
            "        [list]: List of string, if the separator wasn't found, list of 1",
            "    \"\"\"",
            "    return string.split(sep)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def as_range(n):",
            "    \"\"\"Return a range of n items.",
            "",
            "    Args:",
            "        n (int, str): Number of element in the range",
            "",
            "    Returns:",
            "        [list, Range]: range function from o to the value provided. Returns an empty list if n is not valid.",
            "",
            "    Example:",
            "        {% for i in record.parents|as_range %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "        {% endfor %}",
            "    \"\"\"",
            "    try:",
            "        int(n)",
            "    except (TypeError, ValueError):",
            "        return []",
            "    return range(int(n))",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meters_to_feet(n):",
            "    \"\"\"Convert a length from meters to feet.",
            "",
            "    Args:",
            "        n (int, float, str): Number of meters to convert",
            "",
            "    Returns:",
            "        [float]: Value in feet",
            "    \"\"\"",
            "    return float(n) * 3.28084",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_item(d, key):",
            "    \"\"\"Access a specific item/key in a dictionary",
            "",
            "    Args:",
            "        d (dict): dictionary containing the data to access",
            "        key (str]): name of the item/key to access",
            "",
            "    Returns:",
            "        [any]: Value of the item in the dictionary provided",
            "",
            "    Example:",
            "        >>> get_items(data, key)",
            "        \"value\"",
            "    \"\"\"",
            "    return d.get(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def settings_or_config(key):",
            "    \"\"\"Get a value from Django settings (if specified there) or Constance configuration (otherwise).\"\"\"",
            "    return get_settings_or_config(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def quote_string(value):",
            "    \"\"\"Add literal quote characters around the provided value if it's a string.\"\"\"",
            "    if isinstance(value, str):",
            "        return f'\"{value}\"'",
            "    return value",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "@register.simple_tag()",
            "def get_attr(obj, attr, default=None):",
            "    return getattr(obj, attr, default)",
            "",
            "",
            "@register.simple_tag()",
            "def querystring(request, **kwargs):",
            "    \"\"\"",
            "    Append or update the page number in a querystring.",
            "    \"\"\"",
            "    querydict = request.GET.copy()",
            "    for k, v in kwargs.items():",
            "        if v is not None:",
            "            querydict[k] = str(v)",
            "        elif k in querydict:",
            "            querydict.pop(k)",
            "    query_string = querydict.urlencode(safe=\"/\")",
            "    if query_string:",
            "        return \"?\" + query_string",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph(utilization_data, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Wrapper for a horizontal bar graph indicating a percentage of utilization from a tuple of data.",
            "",
            "    Takes the utilization_data that is a namedtuple with numerator and denominator field names and passes them into",
            "    the utilization_graph_raw_data to handle the generation graph data.",
            "",
            "    Args:",
            "        utilization_data (UtilizationData): Namedtuple with numerator and denominator keys",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        dict: Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # See https://github.com/nautobot/nautobot/issues/1169",
            "    # If `get_utilization()` threw an exception, utilization_data will be an empty string",
            "    # rather than a UtilizationData instance. Avoid a potentially confusing exception in that case.",
            "    if not isinstance(utilization_data, UtilizationData):",
            "        return {}",
            "    return utilization_graph_raw_data(",
            "        numerator=utilization_data.numerator,",
            "        denominator=utilization_data.denominator,",
            "        warning_threshold=warning_threshold,",
            "        danger_threshold=danger_threshold,",
            "    )",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph_raw_data(numerator, denominator, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Display a horizontal bar graph indicating a percentage of utilization.",
            "",
            "    Args:",
            "        numerator (int): Numerator for creating a percentage",
            "        denominator (int): Denominator for creating a percentage",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        dict: Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # Check for possible division by zero error",
            "    if denominator == 0:",
            "        utilization = 0",
            "    else:",
            "        utilization = int(float(numerator) / denominator * 100)",
            "",
            "    return {",
            "        \"utilization\": utilization,",
            "        \"warning_threshold\": warning_threshold,",
            "        \"danger_threshold\": danger_threshold,",
            "        \"utilization_count\": numerator,",
            "        \"total_count\": denominator,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/tag.html\")",
            "def tag(tag, url_name=None):  # pylint: disable=redefined-outer-name",
            "    \"\"\"",
            "    Display a tag, optionally linked to a filtered list of objects.",
            "    \"\"\"",
            "    return {",
            "        \"tag\": tag,",
            "        \"url_name\": url_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/badge.html\")",
            "def badge(value, show_empty=False):",
            "    \"\"\"",
            "    Display the specified number as a badge.",
            "    \"\"\"",
            "    return {",
            "        \"value\": value,",
            "        \"show_empty\": show_empty,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/table_config_form.html\")",
            "def table_config_form(table, table_name=None):",
            "    return {",
            "        \"table_name\": table_name or table.__class__.__name__,",
            "        \"table_config_form\": TableConfigForm(table=table),",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/filter_form_modal.html\")",
            "def filter_form_modal(",
            "    filter_form,",
            "    dynamic_filter_form,",
            "    model_plural_name,",
            "    filter_form_name=\"FilterForm\",",
            "    dynamic_filter_form_name=\"DynamicFilterForm\",",
            "):",
            "    return {",
            "        \"model_plural_name\": model_plural_name,",
            "        \"filter_form\": filter_form,",
            "        \"filter_form_name\": filter_form_name,",
            "        \"dynamic_filter_form\": dynamic_filter_form,",
            "        \"dynamic_filter_form_name\": dynamic_filter_form_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/modal_form_as_dialog.html\")",
            "def modal_form_as_dialog(form, editing=False, form_name=None, obj=None, obj_type=None):",
            "    \"\"\"Generate a form in a modal view.",
            "",
            "    Create an overlaying modal view which holds a Django form.",
            "",
            "    Inside of the template the template tag needs to be used with the correct inputs. A button will",
            "    also need to be create to open and close the modal. See below for an example:",
            "",
            "    ```",
            "    {% modal_form_as_dialog form editing=False form_name=\"CreateDevice\" obj=obj obj_type=\"Device\" %}",
            "    <a class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#CreateDevice_form\" title=\"Query Form\">Create Device</a>",
            "    ```",
            "    Args:",
            "        form (django.form.Forms): Django form object.",
            "        editing (bool, optional): Is the form creating or editing an object? Defaults to False for create.",
            "        form_name ([type], optional): Name of form. Defaults to None. If None get name from class name.",
            "        obj (django.model.Object, optional): If editing an existing model object, the object needs to be passed in. Defaults to None.",
            "        obj_type (string, optional): Used in title of form to display object type. Defaults to None.",
            "",
            "    Returns:",
            "        dict: Passed in values used to render HTML.",
            "    \"\"\"",
            "    return {",
            "        \"editing\": editing,",
            "        \"form\": form,",
            "        \"form_action_url\": form.get_action_url(),",
            "        \"form_name\": form_name or form.__class__.__name__,",
            "        \"obj\": obj,",
            "        \"obj_type\": obj_type,",
            "    }",
            "",
            "",
            "@register.simple_tag",
            "def custom_branding_or_static(branding_asset, static_asset):",
            "    \"\"\"",
            "    This tag attempts to return custom branding assets relative to the MEDIA_ROOT and MEDIA_URL, if such",
            "    branding has been configured in settings, else it returns stock branding via static.",
            "    \"\"\"",
            "    if settings.BRANDING_FILEPATHS.get(branding_asset):",
            "        return f\"{ settings.MEDIA_URL }{ settings.BRANDING_FILEPATHS.get(branding_asset) }\"",
            "    return StaticNode.handle_simple(static_asset)",
            "",
            "",
            "@register.simple_tag",
            "def support_message():",
            "    \"\"\"",
            "    Return the configured support message (if any) or else the default.",
            "    \"\"\"",
            "    try:",
            "        message = get_settings_or_config(\"SUPPORT_MESSAGE\")",
            "    except AttributeError:",
            "        message = \"\"",
            "    if not message:",
            "        message = DEFAULT_SUPPORT_MESSAGE",
            "    return render_markdown(message)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "165": [
                "render_markdown"
            ],
            "166": [
                "render_markdown"
            ],
            "167": [
                "render_markdown"
            ],
            "168": [
                "render_markdown"
            ],
            "169": [
                "render_markdown"
            ],
            "170": [
                "render_markdown"
            ],
            "171": [
                "render_markdown"
            ],
            "172": [
                "render_markdown"
            ],
            "176": [
                "render_markdown"
            ]
        },
        "addLocation": []
    }
}