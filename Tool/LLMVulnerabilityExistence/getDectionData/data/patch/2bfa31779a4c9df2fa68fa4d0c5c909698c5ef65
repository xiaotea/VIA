{
    "alerta/auth/basic_ldap.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     except KeyError:"
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         raise ApiError(\"must supply 'username' and 'password'\", 401)"
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    if not password:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        raise ApiError('password not allowed to be empty', 401)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     try:"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         if '\\\\' in login:"
            },
            "8": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "             domain, username = login.split('\\\\')"
            }
        },
        "frontPatchFile": [
            "import sys",
            "",
            "import ldap  # pylint: disable=import-error",
            "from flask import current_app, jsonify, request",
            "from flask_cors import cross_origin",
            "",
            "from alerta.auth.utils import create_token, get_customers",
            "from alerta.exceptions import ApiError",
            "from alerta.models.permission import Permission",
            "from alerta.models.user import User",
            "from alerta.utils.audit import auth_audit_trail",
            "",
            "from . import auth",
            "",
            "",
            "@auth.route('/auth/login', methods=['OPTIONS', 'POST'])",
            "@cross_origin(supports_credentials=True)",
            "def login():",
            "    # Allow LDAP server to use a self signed certificate",
            "    if current_app.config['LDAP_ALLOW_SELF_SIGNED_CERT']:",
            "        ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)",
            "",
            "    # Retrieve required fields from client request",
            "    try:",
            "        login = request.json.get('username', None) or request.json['email']",
            "        password = request.json['password']",
            "    except KeyError:",
            "        raise ApiError(\"must supply 'username' and 'password'\", 401)",
            "",
            "    try:",
            "        if '\\\\' in login:",
            "            domain, username = login.split('\\\\')",
            "            email = ''",
            "            email_verified = False",
            "        else:",
            "            username, domain = login.split('@')",
            "            email = login",
            "            email_verified = True",
            "    except ValueError:",
            "        raise ApiError('expected username with domain', 401)",
            "",
            "    # Validate LDAP domain",
            "    if domain not in current_app.config['LDAP_DOMAINS']:",
            "        raise ApiError('unauthorized domain', 403)",
            "",
            "    userdn = current_app.config['LDAP_DOMAINS'][domain] % username",
            "",
            "    # Attempt LDAP AUTH",
            "    try:",
            "        trace_level = 2 if current_app.debug else 0",
            "        ldap_connection = ldap.initialize(current_app.config['LDAP_URL'], trace_level=trace_level)",
            "        ldap_connection.simple_bind_s(userdn, password)",
            "    except ldap.INVALID_CREDENTIALS:",
            "        raise ApiError('invalid username or password', 401)",
            "    except Exception as e:",
            "        raise ApiError(str(e), 500)",
            "",
            "    # Get email address from LDAP",
            "    if not email_verified:",
            "        try:",
            "            ldap_result = ldap_connection.search_s(userdn, ldap.SCOPE_SUBTREE, '(objectClass=*)', ['mail'])",
            "            email = ldap_result[0][1]['mail'][0].decode(sys.stdout.encoding)",
            "            email_verified = True",
            "        except Exception:",
            "            email = '{}@{}'.format(username, domain)",
            "",
            "    # Create user if not yet there",
            "    user = User.find_by_username(username=login)",
            "    if not user:",
            "        user = User(name=username, login=login, password='', email=email,",
            "                    roles=[], text='LDAP user', email_verified=email_verified)",
            "        try:",
            "            user = user.create()",
            "        except Exception as e:",
            "            ApiError(str(e), 500)",
            "",
            "    # Assign customers & update last login time",
            "    groups = list()",
            "    try:",
            "        groups_filters = current_app.config.get('LDAP_DOMAINS_GROUP', {})",
            "        base_dns = current_app.config.get('LDAP_DOMAINS_BASEDN', {})",
            "        if domain in groups_filters and domain in base_dns:",
            "            resultID = ldap_connection.search(",
            "                base_dns[domain],",
            "                ldap.SCOPE_SUBTREE,",
            "                groups_filters[domain].format(username=username, email=email, userdn=userdn),",
            "                ['cn']",
            "            )",
            "            resultTypes, results = ldap_connection.result(resultID)",
            "            for _dn, attributes in results:",
            "                groups.append(attributes['cn'][0].decode('utf-8'))",
            "    except ldap.LDAPError as e:",
            "        raise ApiError(str(e), 500)",
            "",
            "    # Check user is active",
            "    if user.status != 'active':",
            "        raise ApiError('User {} not active'.format(login), 403)",
            "    user.update_last_login()",
            "",
            "    scopes = Permission.lookup(login=login, roles=user.roles + groups)",
            "    customers = get_customers(login=login, groups=[user.domain] + groups)",
            "",
            "    auth_audit_trail.send(current_app._get_current_object(), event='basic-ldap-login', message='user login via LDAP',",
            "                          user=login, customers=customers, scopes=scopes, roles=user.roles, groups=groups,",
            "                          resource_id=user.id, type='user', request=request)",
            "",
            "    # Generate token",
            "    token = create_token(user_id=user.id, name=user.name, login=user.email, provider='ldap',",
            "                         customers=customers, scopes=scopes, roles=user.roles, groups=groups,",
            "                         email=user.email, email_verified=user.email_verified)",
            "    return jsonify(token=token.tokenize)"
        ],
        "afterPatchFile": [
            "import sys",
            "",
            "import ldap  # pylint: disable=import-error",
            "from flask import current_app, jsonify, request",
            "from flask_cors import cross_origin",
            "",
            "from alerta.auth.utils import create_token, get_customers",
            "from alerta.exceptions import ApiError",
            "from alerta.models.permission import Permission",
            "from alerta.models.user import User",
            "from alerta.utils.audit import auth_audit_trail",
            "",
            "from . import auth",
            "",
            "",
            "@auth.route('/auth/login', methods=['OPTIONS', 'POST'])",
            "@cross_origin(supports_credentials=True)",
            "def login():",
            "    # Allow LDAP server to use a self signed certificate",
            "    if current_app.config['LDAP_ALLOW_SELF_SIGNED_CERT']:",
            "        ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)",
            "",
            "    # Retrieve required fields from client request",
            "    try:",
            "        login = request.json.get('username', None) or request.json['email']",
            "        password = request.json['password']",
            "    except KeyError:",
            "        raise ApiError(\"must supply 'username' and 'password'\", 401)",
            "",
            "    if not password:",
            "        raise ApiError('password not allowed to be empty', 401)",
            "",
            "    try:",
            "        if '\\\\' in login:",
            "            domain, username = login.split('\\\\')",
            "            email = ''",
            "            email_verified = False",
            "        else:",
            "            username, domain = login.split('@')",
            "            email = login",
            "            email_verified = True",
            "    except ValueError:",
            "        raise ApiError('expected username with domain', 401)",
            "",
            "    # Validate LDAP domain",
            "    if domain not in current_app.config['LDAP_DOMAINS']:",
            "        raise ApiError('unauthorized domain', 403)",
            "",
            "    userdn = current_app.config['LDAP_DOMAINS'][domain] % username",
            "",
            "    # Attempt LDAP AUTH",
            "    try:",
            "        trace_level = 2 if current_app.debug else 0",
            "        ldap_connection = ldap.initialize(current_app.config['LDAP_URL'], trace_level=trace_level)",
            "        ldap_connection.simple_bind_s(userdn, password)",
            "    except ldap.INVALID_CREDENTIALS:",
            "        raise ApiError('invalid username or password', 401)",
            "    except Exception as e:",
            "        raise ApiError(str(e), 500)",
            "",
            "    # Get email address from LDAP",
            "    if not email_verified:",
            "        try:",
            "            ldap_result = ldap_connection.search_s(userdn, ldap.SCOPE_SUBTREE, '(objectClass=*)', ['mail'])",
            "            email = ldap_result[0][1]['mail'][0].decode(sys.stdout.encoding)",
            "            email_verified = True",
            "        except Exception:",
            "            email = '{}@{}'.format(username, domain)",
            "",
            "    # Create user if not yet there",
            "    user = User.find_by_username(username=login)",
            "    if not user:",
            "        user = User(name=username, login=login, password='', email=email,",
            "                    roles=[], text='LDAP user', email_verified=email_verified)",
            "        try:",
            "            user = user.create()",
            "        except Exception as e:",
            "            ApiError(str(e), 500)",
            "",
            "    # Assign customers & update last login time",
            "    groups = list()",
            "    try:",
            "        groups_filters = current_app.config.get('LDAP_DOMAINS_GROUP', {})",
            "        base_dns = current_app.config.get('LDAP_DOMAINS_BASEDN', {})",
            "        if domain in groups_filters and domain in base_dns:",
            "            resultID = ldap_connection.search(",
            "                base_dns[domain],",
            "                ldap.SCOPE_SUBTREE,",
            "                groups_filters[domain].format(username=username, email=email, userdn=userdn),",
            "                ['cn']",
            "            )",
            "            resultTypes, results = ldap_connection.result(resultID)",
            "            for _dn, attributes in results:",
            "                groups.append(attributes['cn'][0].decode('utf-8'))",
            "    except ldap.LDAPError as e:",
            "        raise ApiError(str(e), 500)",
            "",
            "    # Check user is active",
            "    if user.status != 'active':",
            "        raise ApiError('User {} not active'.format(login), 403)",
            "    user.update_last_login()",
            "",
            "    scopes = Permission.lookup(login=login, roles=user.roles + groups)",
            "    customers = get_customers(login=login, groups=[user.domain] + groups)",
            "",
            "    auth_audit_trail.send(current_app._get_current_object(), event='basic-ldap-login', message='user login via LDAP',",
            "                          user=login, customers=customers, scopes=scopes, roles=user.roles, groups=groups,",
            "                          resource_id=user.id, type='user', request=request)",
            "",
            "    # Generate token",
            "    token = create_token(user_id=user.id, name=user.name, login=user.email, provider='ldap',",
            "                         customers=customers, scopes=scopes, roles=user.roles, groups=groups,",
            "                         email=user.email, email_verified=user.email_verified)",
            "    return jsonify(token=token.tokenize)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.ops.image_ops_test.RGBToHSVTest"
        ]
    },
    "alerta/models/note.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             'updateTime': self.update_time,"
            },
            "1": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "             '_links': dict(),"
            },
            "2": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             'customer': self.customer"
            },
            "3": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        }"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        }  # type: Dict[str, Any]"
            },
            "5": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         if self.alert:"
            },
            "6": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             note['_links'] = {"
            },
            "7": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "                 'alert': absolute_url('/alert/' + self.alert)"
            }
        },
        "frontPatchFile": [
            "from datetime import datetime",
            "from typing import Any, Dict, List, Optional, Tuple, Union",
            "from uuid import uuid4",
            "",
            "from flask import g",
            "",
            "from alerta.app import db",
            "from alerta.database.base import Query",
            "from alerta.models.enums import ChangeType, NoteType",
            "from alerta.models.history import History",
            "from alerta.utils.format import DateTime",
            "from alerta.utils.response import absolute_url",
            "",
            "JSON = Dict[str, Any]",
            "",
            "",
            "class Note:",
            "",
            "    def __init__(self, text: str, user: str, note_type: str, **kwargs) -> None:",
            "",
            "        self.id = kwargs.get('id') or str(uuid4())",
            "        self.text = text",
            "        self.user = user",
            "        self.note_type = note_type",
            "        self.attributes = kwargs.get('attributes', None) or dict()",
            "        self.create_time = kwargs['create_time'] if 'create_time' in kwargs else datetime.utcnow()",
            "        self.update_time = kwargs.get('update_time')",
            "        self.alert = kwargs.get('alert')",
            "        self.customer = kwargs.get('customer')",
            "",
            "    @classmethod",
            "    def parse(cls, json: JSON) -> 'Note':",
            "        return Note(",
            "            id=json.get('id', None),",
            "            text=json.get('status', None),",
            "            user=json.get('status', None),",
            "            attributes=json.get('attributes', dict()),",
            "            note_type=json.get('type', None),",
            "            create_time=DateTime.parse(json['createTime']) if 'createTime' in json else None,",
            "            update_time=DateTime.parse(json['updateTime']) if 'updateTime' in json else None,",
            "            alert=json.get('related', {}).get('alert'),",
            "            customer=json.get('customer', None)",
            "        )",
            "",
            "    @property",
            "    def serialize(self) -> Dict[str, Any]:",
            "        note = {",
            "            'id': self.id,",
            "            'href': absolute_url('/note/' + self.id),",
            "            'text': self.text,",
            "            'user': self.user,",
            "            'attributes': self.attributes,",
            "            'type': self.note_type,",
            "            'createTime': self.create_time,",
            "            'updateTime': self.update_time,",
            "            '_links': dict(),",
            "            'customer': self.customer",
            "        }",
            "        if self.alert:",
            "            note['_links'] = {",
            "                'alert': absolute_url('/alert/' + self.alert)",
            "            }",
            "        return note",
            "",
            "    def __repr__(self) -> str:",
            "        return 'Note(id={!r}, text={!r}, user={!r}, type={!r}, customer={!r})'.format(",
            "            self.id, self.text, self.user, self.note_type, self.customer",
            "        )",
            "",
            "    @classmethod",
            "    def from_document(cls, doc: Dict[str, Any]) -> 'Note':",
            "        return Note(",
            "            id=doc.get('id', None) or doc.get('_id'),",
            "            text=doc.get('text', None),",
            "            user=doc.get('user', None),",
            "            attributes=doc.get('attributes', dict()),",
            "            note_type=doc.get('type', None),",
            "            create_time=doc.get('createTime'),",
            "            update_time=doc.get('updateTime'),",
            "            alert=doc.get('alert'),",
            "            customer=doc.get('customer')",
            "        )",
            "",
            "    @classmethod",
            "    def from_record(cls, rec) -> 'Note':",
            "        return Note(",
            "            id=rec.id,",
            "            text=rec.text,",
            "            user=rec.user,",
            "            attributes=dict(rec.attributes),",
            "            note_type=rec.type,",
            "            create_time=rec.create_time,",
            "            update_time=rec.update_time,",
            "            alert=rec.alert,",
            "            customer=rec.customer",
            "        )",
            "",
            "    @classmethod",
            "    def from_db(cls, r: Union[Dict, Tuple]) -> 'Note':",
            "        if isinstance(r, dict):",
            "            return cls.from_document(r)",
            "        elif isinstance(r, tuple):",
            "            return cls.from_record(r)",
            "",
            "    def create(self) -> 'Note':",
            "        return Note.from_db(db.create_note(self))",
            "",
            "    @staticmethod",
            "    def from_alert(alert, text):",
            "        note = Note(",
            "            text=text,",
            "            user=g.login,",
            "            note_type=NoteType.alert,",
            "            attributes=dict(",
            "                resource=alert.resource,",
            "                event=alert.event,",
            "                environment=alert.environment,",
            "                severity=alert.severity,",
            "                status=alert.status",
            "            ),",
            "            alert=alert.id,",
            "            customer=alert.customer",
            "        )",
            "",
            "        history = History(",
            "            id=note.id,",
            "            event=alert.event,",
            "            severity=alert.severity,",
            "            status=alert.status,",
            "            value=alert.value,",
            "            text=text,",
            "            change_type=ChangeType.note,",
            "            update_time=datetime.utcnow(),",
            "            user=g.login",
            "        )",
            "        db.add_history(alert.id, history)",
            "        return note.create()",
            "",
            "    @staticmethod",
            "    def find_by_id(id: str) -> Optional['Note']:",
            "        return Note.from_db(db.get_note(id))",
            "",
            "    @staticmethod",
            "    def find_all(query: Query = None) -> List['Note']:",
            "        return [Note.from_db(note) for note in db.get_notes(query)]",
            "",
            "    def update(self, **kwargs) -> 'Note':",
            "        return Note.from_db(db.update_note(self.id, **kwargs))",
            "",
            "    def delete(self) -> bool:",
            "        return db.delete_note(self.id)"
        ],
        "afterPatchFile": [
            "from datetime import datetime",
            "from typing import Any, Dict, List, Optional, Tuple, Union",
            "from uuid import uuid4",
            "",
            "from flask import g",
            "",
            "from alerta.app import db",
            "from alerta.database.base import Query",
            "from alerta.models.enums import ChangeType, NoteType",
            "from alerta.models.history import History",
            "from alerta.utils.format import DateTime",
            "from alerta.utils.response import absolute_url",
            "",
            "JSON = Dict[str, Any]",
            "",
            "",
            "class Note:",
            "",
            "    def __init__(self, text: str, user: str, note_type: str, **kwargs) -> None:",
            "",
            "        self.id = kwargs.get('id') or str(uuid4())",
            "        self.text = text",
            "        self.user = user",
            "        self.note_type = note_type",
            "        self.attributes = kwargs.get('attributes', None) or dict()",
            "        self.create_time = kwargs['create_time'] if 'create_time' in kwargs else datetime.utcnow()",
            "        self.update_time = kwargs.get('update_time')",
            "        self.alert = kwargs.get('alert')",
            "        self.customer = kwargs.get('customer')",
            "",
            "    @classmethod",
            "    def parse(cls, json: JSON) -> 'Note':",
            "        return Note(",
            "            id=json.get('id', None),",
            "            text=json.get('status', None),",
            "            user=json.get('status', None),",
            "            attributes=json.get('attributes', dict()),",
            "            note_type=json.get('type', None),",
            "            create_time=DateTime.parse(json['createTime']) if 'createTime' in json else None,",
            "            update_time=DateTime.parse(json['updateTime']) if 'updateTime' in json else None,",
            "            alert=json.get('related', {}).get('alert'),",
            "            customer=json.get('customer', None)",
            "        )",
            "",
            "    @property",
            "    def serialize(self) -> Dict[str, Any]:",
            "        note = {",
            "            'id': self.id,",
            "            'href': absolute_url('/note/' + self.id),",
            "            'text': self.text,",
            "            'user': self.user,",
            "            'attributes': self.attributes,",
            "            'type': self.note_type,",
            "            'createTime': self.create_time,",
            "            'updateTime': self.update_time,",
            "            '_links': dict(),",
            "            'customer': self.customer",
            "        }  # type: Dict[str, Any]",
            "        if self.alert:",
            "            note['_links'] = {",
            "                'alert': absolute_url('/alert/' + self.alert)",
            "            }",
            "        return note",
            "",
            "    def __repr__(self) -> str:",
            "        return 'Note(id={!r}, text={!r}, user={!r}, type={!r}, customer={!r})'.format(",
            "            self.id, self.text, self.user, self.note_type, self.customer",
            "        )",
            "",
            "    @classmethod",
            "    def from_document(cls, doc: Dict[str, Any]) -> 'Note':",
            "        return Note(",
            "            id=doc.get('id', None) or doc.get('_id'),",
            "            text=doc.get('text', None),",
            "            user=doc.get('user', None),",
            "            attributes=doc.get('attributes', dict()),",
            "            note_type=doc.get('type', None),",
            "            create_time=doc.get('createTime'),",
            "            update_time=doc.get('updateTime'),",
            "            alert=doc.get('alert'),",
            "            customer=doc.get('customer')",
            "        )",
            "",
            "    @classmethod",
            "    def from_record(cls, rec) -> 'Note':",
            "        return Note(",
            "            id=rec.id,",
            "            text=rec.text,",
            "            user=rec.user,",
            "            attributes=dict(rec.attributes),",
            "            note_type=rec.type,",
            "            create_time=rec.create_time,",
            "            update_time=rec.update_time,",
            "            alert=rec.alert,",
            "            customer=rec.customer",
            "        )",
            "",
            "    @classmethod",
            "    def from_db(cls, r: Union[Dict, Tuple]) -> 'Note':",
            "        if isinstance(r, dict):",
            "            return cls.from_document(r)",
            "        elif isinstance(r, tuple):",
            "            return cls.from_record(r)",
            "",
            "    def create(self) -> 'Note':",
            "        return Note.from_db(db.create_note(self))",
            "",
            "    @staticmethod",
            "    def from_alert(alert, text):",
            "        note = Note(",
            "            text=text,",
            "            user=g.login,",
            "            note_type=NoteType.alert,",
            "            attributes=dict(",
            "                resource=alert.resource,",
            "                event=alert.event,",
            "                environment=alert.environment,",
            "                severity=alert.severity,",
            "                status=alert.status",
            "            ),",
            "            alert=alert.id,",
            "            customer=alert.customer",
            "        )",
            "",
            "        history = History(",
            "            id=note.id,",
            "            event=alert.event,",
            "            severity=alert.severity,",
            "            status=alert.status,",
            "            value=alert.value,",
            "            text=text,",
            "            change_type=ChangeType.note,",
            "            update_time=datetime.utcnow(),",
            "            user=g.login",
            "        )",
            "        db.add_history(alert.id, history)",
            "        return note.create()",
            "",
            "    @staticmethod",
            "    def find_by_id(id: str) -> Optional['Note']:",
            "        return Note.from_db(db.get_note(id))",
            "",
            "    @staticmethod",
            "    def find_all(query: Query = None) -> List['Note']:",
            "        return [Note.from_db(note) for note in db.get_notes(query)]",
            "",
            "    def update(self, **kwargs) -> 'Note':",
            "        return Note.from_db(db.update_note(self.id, **kwargs))",
            "",
            "    def delete(self) -> bool:",
            "        return db.delete_note(self.id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "58": [
                "Note",
                "serialize"
            ]
        },
        "addLocation": []
    }
}