{
    "airflow/providers/microsoft/mssql/hooks/mssql.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     @property"
            },
            "1": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def sqlalchemy_scheme(self) -> str:"
            },
            "2": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         \"\"\"Sqlalchemy scheme either from constructor, connection extras or default.\"\"\""
            },
            "3": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return ("
            },
            "4": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._sqlalchemy_scheme"
            },
            "5": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            or self.connection_extra_lower.get(\"sqlalchemy_scheme\")"
            },
            "6": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            or self.DEFAULT_SQLALCHEMY_SCHEME"
            },
            "7": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        extra_scheme = self.connection_extra_lower.get(\"sqlalchemy_scheme\")"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        if not self._sqlalchemy_scheme and extra_scheme and (\":\" in extra_scheme or \"/\" in extra_scheme):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            raise RuntimeError(\"sqlalchemy_scheme in connection extra should not contain : or / characters\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        return self._sqlalchemy_scheme or extra_scheme or self.DEFAULT_SQLALCHEMY_SCHEME"
            },
            "12": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     def get_uri(self) -> str:"
            },
            "14": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         from urllib.parse import parse_qs, urlencode, urlsplit, urlunsplit"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Microsoft SQLServer hook module.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "",
            "import pymssql",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "",
            "",
            "class MsSqlHook(DbApiHook):",
            "    \"\"\"Interact with Microsoft SQL Server.\"\"\"",
            "",
            "    conn_name_attr = \"mssql_conn_id\"",
            "    default_conn_name = \"mssql_default\"",
            "    conn_type = \"mssql\"",
            "    hook_name = \"Microsoft SQL Server\"",
            "    supports_autocommit = True",
            "    DEFAULT_SQLALCHEMY_SCHEME = \"mssql+pymssql\"",
            "",
            "    def __init__(",
            "        self,",
            "        *args,",
            "        sqlalchemy_scheme: str | None = None,",
            "        **kwargs,",
            "    ) -> None:",
            "        \"\"\"",
            "        :param args: passed to DBApiHook",
            "        :param sqlalchemy_scheme: Scheme sqlalchemy connection.  Default is ``mssql+pymssql`` Only used for",
            "          ``get_sqlalchemy_engine`` and ``get_sqlalchemy_connection`` methods.",
            "        :param kwargs: passed to DbApiHook",
            "        \"\"\"",
            "        super().__init__(*args, **kwargs)",
            "        self.schema = kwargs.pop(\"schema\", None)",
            "        self._sqlalchemy_scheme = sqlalchemy_scheme",
            "",
            "    @property",
            "    def connection_extra_lower(self) -> dict:",
            "        \"\"\"",
            "        ``connection.extra_dejson`` but where keys are converted to lower case.",
            "        This is used internally for case-insensitive access of mssql params.",
            "        \"\"\"",
            "        conn = self.get_connection(self.mssql_conn_id)  # type: ignore[attr-defined]",
            "        return {k.lower(): v for k, v in conn.extra_dejson.items()}",
            "",
            "    @property",
            "    def sqlalchemy_scheme(self) -> str:",
            "        \"\"\"Sqlalchemy scheme either from constructor, connection extras or default.\"\"\"",
            "        return (",
            "            self._sqlalchemy_scheme",
            "            or self.connection_extra_lower.get(\"sqlalchemy_scheme\")",
            "            or self.DEFAULT_SQLALCHEMY_SCHEME",
            "        )",
            "",
            "    def get_uri(self) -> str:",
            "        from urllib.parse import parse_qs, urlencode, urlsplit, urlunsplit",
            "",
            "        r = list(urlsplit(super().get_uri()))",
            "        # change pymssql driver:",
            "        r[0] = self.sqlalchemy_scheme",
            "        # remove query string 'sqlalchemy_scheme' like parameters:",
            "        qs = parse_qs(r[3], keep_blank_values=True)",
            "        for k in list(qs.keys()):",
            "            if k.lower() == \"sqlalchemy_scheme\":",
            "                qs.pop(k, None)",
            "        r[3] = urlencode(qs, doseq=True)",
            "        return urlunsplit(r)",
            "",
            "    def get_sqlalchemy_connection(",
            "        self, connect_kwargs: dict | None = None, engine_kwargs: dict | None = None",
            "    ) -> Any:",
            "        \"\"\"Sqlalchemy connection object.\"\"\"",
            "        engine = self.get_sqlalchemy_engine(engine_kwargs=engine_kwargs)",
            "        return engine.connect(**(connect_kwargs or {}))",
            "",
            "    def get_conn(self) -> pymssql.connect:",
            "        \"\"\"Returns a mssql connection object.\"\"\"",
            "        conn = self.get_connection(self.mssql_conn_id)  # type: ignore[attr-defined]",
            "",
            "        conn = pymssql.connect(",
            "            server=conn.host,",
            "            user=conn.login,",
            "            password=conn.password,",
            "            database=self.schema or conn.schema,",
            "            port=conn.port,",
            "        )",
            "        return conn",
            "",
            "    def set_autocommit(",
            "        self,",
            "        conn: pymssql.connect,",
            "        autocommit: bool,",
            "    ) -> None:",
            "        conn.autocommit(autocommit)",
            "",
            "    def get_autocommit(self, conn: pymssql.connect):",
            "        return conn.autocommit_state"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Microsoft SQLServer hook module.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "",
            "import pymssql",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "",
            "",
            "class MsSqlHook(DbApiHook):",
            "    \"\"\"Interact with Microsoft SQL Server.\"\"\"",
            "",
            "    conn_name_attr = \"mssql_conn_id\"",
            "    default_conn_name = \"mssql_default\"",
            "    conn_type = \"mssql\"",
            "    hook_name = \"Microsoft SQL Server\"",
            "    supports_autocommit = True",
            "    DEFAULT_SQLALCHEMY_SCHEME = \"mssql+pymssql\"",
            "",
            "    def __init__(",
            "        self,",
            "        *args,",
            "        sqlalchemy_scheme: str | None = None,",
            "        **kwargs,",
            "    ) -> None:",
            "        \"\"\"",
            "        :param args: passed to DBApiHook",
            "        :param sqlalchemy_scheme: Scheme sqlalchemy connection.  Default is ``mssql+pymssql`` Only used for",
            "          ``get_sqlalchemy_engine`` and ``get_sqlalchemy_connection`` methods.",
            "        :param kwargs: passed to DbApiHook",
            "        \"\"\"",
            "        super().__init__(*args, **kwargs)",
            "        self.schema = kwargs.pop(\"schema\", None)",
            "        self._sqlalchemy_scheme = sqlalchemy_scheme",
            "",
            "    @property",
            "    def connection_extra_lower(self) -> dict:",
            "        \"\"\"",
            "        ``connection.extra_dejson`` but where keys are converted to lower case.",
            "        This is used internally for case-insensitive access of mssql params.",
            "        \"\"\"",
            "        conn = self.get_connection(self.mssql_conn_id)  # type: ignore[attr-defined]",
            "        return {k.lower(): v for k, v in conn.extra_dejson.items()}",
            "",
            "    @property",
            "    def sqlalchemy_scheme(self) -> str:",
            "        \"\"\"Sqlalchemy scheme either from constructor, connection extras or default.\"\"\"",
            "        extra_scheme = self.connection_extra_lower.get(\"sqlalchemy_scheme\")",
            "        if not self._sqlalchemy_scheme and extra_scheme and (\":\" in extra_scheme or \"/\" in extra_scheme):",
            "            raise RuntimeError(\"sqlalchemy_scheme in connection extra should not contain : or / characters\")",
            "        return self._sqlalchemy_scheme or extra_scheme or self.DEFAULT_SQLALCHEMY_SCHEME",
            "",
            "    def get_uri(self) -> str:",
            "        from urllib.parse import parse_qs, urlencode, urlsplit, urlunsplit",
            "",
            "        r = list(urlsplit(super().get_uri()))",
            "        # change pymssql driver:",
            "        r[0] = self.sqlalchemy_scheme",
            "        # remove query string 'sqlalchemy_scheme' like parameters:",
            "        qs = parse_qs(r[3], keep_blank_values=True)",
            "        for k in list(qs.keys()):",
            "            if k.lower() == \"sqlalchemy_scheme\":",
            "                qs.pop(k, None)",
            "        r[3] = urlencode(qs, doseq=True)",
            "        return urlunsplit(r)",
            "",
            "    def get_sqlalchemy_connection(",
            "        self, connect_kwargs: dict | None = None, engine_kwargs: dict | None = None",
            "    ) -> Any:",
            "        \"\"\"Sqlalchemy connection object.\"\"\"",
            "        engine = self.get_sqlalchemy_engine(engine_kwargs=engine_kwargs)",
            "        return engine.connect(**(connect_kwargs or {}))",
            "",
            "    def get_conn(self) -> pymssql.connect:",
            "        \"\"\"Returns a mssql connection object.\"\"\"",
            "        conn = self.get_connection(self.mssql_conn_id)  # type: ignore[attr-defined]",
            "",
            "        conn = pymssql.connect(",
            "            server=conn.host,",
            "            user=conn.login,",
            "            password=conn.password,",
            "            database=self.schema or conn.schema,",
            "            port=conn.port,",
            "        )",
            "        return conn",
            "",
            "    def set_autocommit(",
            "        self,",
            "        conn: pymssql.connect,",
            "        autocommit: bool,",
            "    ) -> None:",
            "        conn.autocommit(autocommit)",
            "",
            "    def get_autocommit(self, conn: pymssql.connect):",
            "        return conn.autocommit_state"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "66": [
                "MsSqlHook",
                "sqlalchemy_scheme"
            ],
            "67": [
                "MsSqlHook",
                "sqlalchemy_scheme"
            ],
            "68": [
                "MsSqlHook",
                "sqlalchemy_scheme"
            ],
            "69": [
                "MsSqlHook",
                "sqlalchemy_scheme"
            ],
            "70": [
                "MsSqlHook",
                "sqlalchemy_scheme"
            ]
        },
        "addLocation": []
    },
    "airflow/providers/odbc/hooks/odbc.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     @property"
            },
            "1": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     def sqlalchemy_scheme(self) -> str:"
            },
            "2": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         \"\"\"SQLAlchemy scheme either from constructor, connection extras or default.\"\"\""
            },
            "3": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return ("
            },
            "4": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._sqlalchemy_scheme"
            },
            "5": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            or self.connection_extra_lower.get(\"sqlalchemy_scheme\")"
            },
            "6": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            or self.DEFAULT_SQLALCHEMY_SCHEME"
            },
            "7": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        extra_scheme = self.connection_extra_lower.get(\"sqlalchemy_scheme\")"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        if not self._sqlalchemy_scheme and extra_scheme and (\":\" in extra_scheme or \"/\" in extra_scheme):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            raise RuntimeError(\"sqlalchemy_scheme in connection extra should not contain : or / characters\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        return self._sqlalchemy_scheme or extra_scheme or self.DEFAULT_SQLALCHEMY_SCHEME"
            },
            "12": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     @property"
            },
            "14": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     def connection_extra_lower(self) -> dict:"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"This module contains ODBC hook.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "from urllib.parse import quote_plus",
            "",
            "import pyodbc",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "from airflow.utils.helpers import merge_dicts",
            "",
            "",
            "class OdbcHook(DbApiHook):",
            "    \"\"\"",
            "    Interact with odbc data sources using pyodbc.",
            "",
            "    To configure driver, in addition to supplying as constructor arg, the following are also supported:",
            "        * set ``driver`` parameter in ``hook_params`` dictionary when instantiating hook by SQL operators.",
            "        * set ``driver`` extra in the connection and set ``allow_driver_in_extra`` to True in",
            "          section ``providers.odbc`` section of airflow config.",
            "        * patch ``OdbcHook.default_driver`` in ``local_settings.py`` file.",
            "",
            "    See :doc:`/connections/odbc` for full documentation.",
            "",
            "    :param args: passed to DbApiHook",
            "    :param database: database to use -- overrides connection ``schema``",
            "    :param driver: name of driver or path to driver. see above for more info",
            "    :param dsn: name of DSN to use.  overrides DSN supplied in connection ``extra``",
            "    :param connect_kwargs: keyword arguments passed to ``pyodbc.connect``",
            "    :param sqlalchemy_scheme: Scheme sqlalchemy connection.  Default is ``mssql+pyodbc`` Only used for",
            "        ``get_sqlalchemy_engine`` and ``get_sqlalchemy_connection`` methods.",
            "    :param kwargs: passed to DbApiHook",
            "    \"\"\"",
            "",
            "    DEFAULT_SQLALCHEMY_SCHEME = \"mssql+pyodbc\"",
            "    conn_name_attr = \"odbc_conn_id\"",
            "    default_conn_name = \"odbc_default\"",
            "    conn_type = \"odbc\"",
            "    hook_name = \"ODBC\"",
            "    supports_autocommit = True",
            "",
            "    default_driver: str | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        *args,",
            "        database: str | None = None,",
            "        driver: str | None = None,",
            "        dsn: str | None = None,",
            "        connect_kwargs: dict | None = None,",
            "        sqlalchemy_scheme: str | None = None,",
            "        **kwargs,",
            "    ) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self._database = database",
            "        self._driver = driver",
            "        self._dsn = dsn",
            "        self._conn_str = None",
            "        self._sqlalchemy_scheme = sqlalchemy_scheme",
            "        self._connection = None",
            "        self._connect_kwargs = connect_kwargs",
            "",
            "    @property",
            "    def connection(self):",
            "        \"\"\"The Connection object with ID ``odbc_conn_id``.\"\"\"",
            "        if not self._connection:",
            "            self._connection = self.get_connection(getattr(self, self.conn_name_attr))",
            "        return self._connection",
            "",
            "    @property",
            "    def database(self) -> str | None:",
            "        \"\"\"Database provided in init if exists; otherwise, ``schema`` from ``Connection`` object.\"\"\"",
            "        return self._database or self.connection.schema",
            "",
            "    @property",
            "    def sqlalchemy_scheme(self) -> str:",
            "        \"\"\"SQLAlchemy scheme either from constructor, connection extras or default.\"\"\"",
            "        return (",
            "            self._sqlalchemy_scheme",
            "            or self.connection_extra_lower.get(\"sqlalchemy_scheme\")",
            "            or self.DEFAULT_SQLALCHEMY_SCHEME",
            "        )",
            "",
            "    @property",
            "    def connection_extra_lower(self) -> dict:",
            "        \"\"\"",
            "        ``connection.extra_dejson`` but where keys are converted to lower case.",
            "",
            "        This is used internally for case-insensitive access of odbc params.",
            "        \"\"\"",
            "        return {k.lower(): v for k, v in self.connection.extra_dejson.items()}",
            "",
            "    @property",
            "    def driver(self) -> str | None:",
            "        \"\"\"Driver from init param if given; else try to find one in connection extra.\"\"\"",
            "        extra_driver = self.connection_extra_lower.get(\"driver\")",
            "        from airflow.configuration import conf",
            "",
            "        if extra_driver and conf.getboolean(\"providers.odbc\", \"allow_driver_in_extra\", fallback=False):",
            "            self._driver = extra_driver",
            "        else:",
            "            self.log.warning(",
            "                \"You have supplied 'driver' via connection extra but it will not be used. In order to \"",
            "                \"use 'driver' from extra you must set airflow config setting `allow_driver_in_extra = True` \"",
            "                \"in section `providers.odbc`. Alternatively you may specify driver via 'driver' parameter of \"",
            "                \"the hook constructor or via 'hook_params' dictionary with key 'driver' if using SQL \"",
            "                \"operators.\"",
            "            )",
            "        if not self._driver:",
            "            self._driver = self.default_driver",
            "        return self._driver.strip().lstrip(\"{\").rstrip(\"}\").strip() if self._driver else None",
            "",
            "    @property",
            "    def dsn(self) -> str | None:",
            "        \"\"\"DSN from init param if given; else try to find one in connection extra.\"\"\"",
            "        if not self._dsn:",
            "            dsn = self.connection_extra_lower.get(\"dsn\")",
            "            if dsn:",
            "                self._dsn = dsn.strip()",
            "        return self._dsn",
            "",
            "    @property",
            "    def odbc_connection_string(self):",
            "        \"\"\"ODBC connection string.",
            "",
            "        We build connection string instead of using ``pyodbc.connect`` params",
            "        because, for example, there is no param representing",
            "        ``ApplicationIntent=ReadOnly``.  Any key-value pairs provided in",
            "        ``Connection.extra`` will be added to the connection string.",
            "        \"\"\"",
            "        if not self._conn_str:",
            "            conn_str = \"\"",
            "            if self.driver:",
            "                conn_str += f\"DRIVER={{{self.driver}}};\"",
            "            if self.dsn:",
            "                conn_str += f\"DSN={self.dsn};\"",
            "            if self.connection.host:",
            "                conn_str += f\"SERVER={self.connection.host};\"",
            "            database = self.database or self.connection.schema",
            "            if database:",
            "                conn_str += f\"DATABASE={database};\"",
            "            if self.connection.login:",
            "                conn_str += f\"UID={self.connection.login};\"",
            "            if self.connection.password:",
            "                conn_str += f\"PWD={self.connection.password};\"",
            "            if self.connection.port:",
            "                conn_str += f\"PORT={self.connection.port};\"",
            "",
            "            extra_exclude = {\"driver\", \"dsn\", \"connect_kwargs\", \"sqlalchemy_scheme\"}",
            "            extra_params = {",
            "                k: v for k, v in self.connection.extra_dejson.items() if k.lower() not in extra_exclude",
            "            }",
            "            for k, v in extra_params.items():",
            "                conn_str += f\"{k}={v};\"",
            "",
            "            self._conn_str = conn_str",
            "        return self._conn_str",
            "",
            "    @property",
            "    def connect_kwargs(self) -> dict:",
            "        \"\"\"Effective kwargs to be passed to ``pyodbc.connect``.",
            "",
            "        The kwargs are merged from connection extra, ``connect_kwargs``, and",
            "        the hook's init arguments. Values received to the hook precede those",
            "        from the connection.",
            "",
            "        If ``attrs_before`` is provided, keys and values are converted to int,",
            "        as required by pyodbc.",
            "        \"\"\"",
            "        conn_connect_kwargs = self.connection_extra_lower.get(\"connect_kwargs\", {})",
            "        hook_connect_kwargs = self._connect_kwargs or {}",
            "        merged_connect_kwargs = merge_dicts(conn_connect_kwargs, hook_connect_kwargs)",
            "",
            "        if \"attrs_before\" in merged_connect_kwargs:",
            "            merged_connect_kwargs[\"attrs_before\"] = {",
            "                int(k): int(v) for k, v in merged_connect_kwargs[\"attrs_before\"].items()",
            "            }",
            "",
            "        return merged_connect_kwargs",
            "",
            "    def get_conn(self) -> pyodbc.Connection:",
            "        \"\"\"Returns a pyodbc connection object.\"\"\"",
            "        conn = pyodbc.connect(self.odbc_connection_string, **self.connect_kwargs)",
            "        return conn",
            "",
            "    def get_uri(self) -> str:",
            "        \"\"\"URI invoked in :meth:`~airflow.providers.common.sql.hooks.sql.DbApiHook.get_sqlalchemy_engine`.\"\"\"",
            "        quoted_conn_str = quote_plus(self.odbc_connection_string)",
            "        uri = f\"{self.sqlalchemy_scheme}:///?odbc_connect={quoted_conn_str}\"",
            "        return uri",
            "",
            "    def get_sqlalchemy_connection(",
            "        self, connect_kwargs: dict | None = None, engine_kwargs: dict | None = None",
            "    ) -> Any:",
            "        \"\"\"SQLAlchemy connection object.\"\"\"",
            "        engine = self.get_sqlalchemy_engine(engine_kwargs=engine_kwargs)",
            "        cnx = engine.connect(**(connect_kwargs or {}))",
            "        return cnx"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"This module contains ODBC hook.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "from urllib.parse import quote_plus",
            "",
            "import pyodbc",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "from airflow.utils.helpers import merge_dicts",
            "",
            "",
            "class OdbcHook(DbApiHook):",
            "    \"\"\"",
            "    Interact with odbc data sources using pyodbc.",
            "",
            "    To configure driver, in addition to supplying as constructor arg, the following are also supported:",
            "        * set ``driver`` parameter in ``hook_params`` dictionary when instantiating hook by SQL operators.",
            "        * set ``driver`` extra in the connection and set ``allow_driver_in_extra`` to True in",
            "          section ``providers.odbc`` section of airflow config.",
            "        * patch ``OdbcHook.default_driver`` in ``local_settings.py`` file.",
            "",
            "    See :doc:`/connections/odbc` for full documentation.",
            "",
            "    :param args: passed to DbApiHook",
            "    :param database: database to use -- overrides connection ``schema``",
            "    :param driver: name of driver or path to driver. see above for more info",
            "    :param dsn: name of DSN to use.  overrides DSN supplied in connection ``extra``",
            "    :param connect_kwargs: keyword arguments passed to ``pyodbc.connect``",
            "    :param sqlalchemy_scheme: Scheme sqlalchemy connection.  Default is ``mssql+pyodbc`` Only used for",
            "        ``get_sqlalchemy_engine`` and ``get_sqlalchemy_connection`` methods.",
            "    :param kwargs: passed to DbApiHook",
            "    \"\"\"",
            "",
            "    DEFAULT_SQLALCHEMY_SCHEME = \"mssql+pyodbc\"",
            "    conn_name_attr = \"odbc_conn_id\"",
            "    default_conn_name = \"odbc_default\"",
            "    conn_type = \"odbc\"",
            "    hook_name = \"ODBC\"",
            "    supports_autocommit = True",
            "",
            "    default_driver: str | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        *args,",
            "        database: str | None = None,",
            "        driver: str | None = None,",
            "        dsn: str | None = None,",
            "        connect_kwargs: dict | None = None,",
            "        sqlalchemy_scheme: str | None = None,",
            "        **kwargs,",
            "    ) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self._database = database",
            "        self._driver = driver",
            "        self._dsn = dsn",
            "        self._conn_str = None",
            "        self._sqlalchemy_scheme = sqlalchemy_scheme",
            "        self._connection = None",
            "        self._connect_kwargs = connect_kwargs",
            "",
            "    @property",
            "    def connection(self):",
            "        \"\"\"The Connection object with ID ``odbc_conn_id``.\"\"\"",
            "        if not self._connection:",
            "            self._connection = self.get_connection(getattr(self, self.conn_name_attr))",
            "        return self._connection",
            "",
            "    @property",
            "    def database(self) -> str | None:",
            "        \"\"\"Database provided in init if exists; otherwise, ``schema`` from ``Connection`` object.\"\"\"",
            "        return self._database or self.connection.schema",
            "",
            "    @property",
            "    def sqlalchemy_scheme(self) -> str:",
            "        \"\"\"SQLAlchemy scheme either from constructor, connection extras or default.\"\"\"",
            "        extra_scheme = self.connection_extra_lower.get(\"sqlalchemy_scheme\")",
            "        if not self._sqlalchemy_scheme and extra_scheme and (\":\" in extra_scheme or \"/\" in extra_scheme):",
            "            raise RuntimeError(\"sqlalchemy_scheme in connection extra should not contain : or / characters\")",
            "        return self._sqlalchemy_scheme or extra_scheme or self.DEFAULT_SQLALCHEMY_SCHEME",
            "",
            "    @property",
            "    def connection_extra_lower(self) -> dict:",
            "        \"\"\"",
            "        ``connection.extra_dejson`` but where keys are converted to lower case.",
            "",
            "        This is used internally for case-insensitive access of odbc params.",
            "        \"\"\"",
            "        return {k.lower(): v for k, v in self.connection.extra_dejson.items()}",
            "",
            "    @property",
            "    def driver(self) -> str | None:",
            "        \"\"\"Driver from init param if given; else try to find one in connection extra.\"\"\"",
            "        extra_driver = self.connection_extra_lower.get(\"driver\")",
            "        from airflow.configuration import conf",
            "",
            "        if extra_driver and conf.getboolean(\"providers.odbc\", \"allow_driver_in_extra\", fallback=False):",
            "            self._driver = extra_driver",
            "        else:",
            "            self.log.warning(",
            "                \"You have supplied 'driver' via connection extra but it will not be used. In order to \"",
            "                \"use 'driver' from extra you must set airflow config setting `allow_driver_in_extra = True` \"",
            "                \"in section `providers.odbc`. Alternatively you may specify driver via 'driver' parameter of \"",
            "                \"the hook constructor or via 'hook_params' dictionary with key 'driver' if using SQL \"",
            "                \"operators.\"",
            "            )",
            "        if not self._driver:",
            "            self._driver = self.default_driver",
            "        return self._driver.strip().lstrip(\"{\").rstrip(\"}\").strip() if self._driver else None",
            "",
            "    @property",
            "    def dsn(self) -> str | None:",
            "        \"\"\"DSN from init param if given; else try to find one in connection extra.\"\"\"",
            "        if not self._dsn:",
            "            dsn = self.connection_extra_lower.get(\"dsn\")",
            "            if dsn:",
            "                self._dsn = dsn.strip()",
            "        return self._dsn",
            "",
            "    @property",
            "    def odbc_connection_string(self):",
            "        \"\"\"ODBC connection string.",
            "",
            "        We build connection string instead of using ``pyodbc.connect`` params",
            "        because, for example, there is no param representing",
            "        ``ApplicationIntent=ReadOnly``.  Any key-value pairs provided in",
            "        ``Connection.extra`` will be added to the connection string.",
            "        \"\"\"",
            "        if not self._conn_str:",
            "            conn_str = \"\"",
            "            if self.driver:",
            "                conn_str += f\"DRIVER={{{self.driver}}};\"",
            "            if self.dsn:",
            "                conn_str += f\"DSN={self.dsn};\"",
            "            if self.connection.host:",
            "                conn_str += f\"SERVER={self.connection.host};\"",
            "            database = self.database or self.connection.schema",
            "            if database:",
            "                conn_str += f\"DATABASE={database};\"",
            "            if self.connection.login:",
            "                conn_str += f\"UID={self.connection.login};\"",
            "            if self.connection.password:",
            "                conn_str += f\"PWD={self.connection.password};\"",
            "            if self.connection.port:",
            "                conn_str += f\"PORT={self.connection.port};\"",
            "",
            "            extra_exclude = {\"driver\", \"dsn\", \"connect_kwargs\", \"sqlalchemy_scheme\"}",
            "            extra_params = {",
            "                k: v for k, v in self.connection.extra_dejson.items() if k.lower() not in extra_exclude",
            "            }",
            "            for k, v in extra_params.items():",
            "                conn_str += f\"{k}={v};\"",
            "",
            "            self._conn_str = conn_str",
            "        return self._conn_str",
            "",
            "    @property",
            "    def connect_kwargs(self) -> dict:",
            "        \"\"\"Effective kwargs to be passed to ``pyodbc.connect``.",
            "",
            "        The kwargs are merged from connection extra, ``connect_kwargs``, and",
            "        the hook's init arguments. Values received to the hook precede those",
            "        from the connection.",
            "",
            "        If ``attrs_before`` is provided, keys and values are converted to int,",
            "        as required by pyodbc.",
            "        \"\"\"",
            "        conn_connect_kwargs = self.connection_extra_lower.get(\"connect_kwargs\", {})",
            "        hook_connect_kwargs = self._connect_kwargs or {}",
            "        merged_connect_kwargs = merge_dicts(conn_connect_kwargs, hook_connect_kwargs)",
            "",
            "        if \"attrs_before\" in merged_connect_kwargs:",
            "            merged_connect_kwargs[\"attrs_before\"] = {",
            "                int(k): int(v) for k, v in merged_connect_kwargs[\"attrs_before\"].items()",
            "            }",
            "",
            "        return merged_connect_kwargs",
            "",
            "    def get_conn(self) -> pyodbc.Connection:",
            "        \"\"\"Returns a pyodbc connection object.\"\"\"",
            "        conn = pyodbc.connect(self.odbc_connection_string, **self.connect_kwargs)",
            "        return conn",
            "",
            "    def get_uri(self) -> str:",
            "        \"\"\"URI invoked in :meth:`~airflow.providers.common.sql.hooks.sql.DbApiHook.get_sqlalchemy_engine`.\"\"\"",
            "        quoted_conn_str = quote_plus(self.odbc_connection_string)",
            "        uri = f\"{self.sqlalchemy_scheme}:///?odbc_connect={quoted_conn_str}\"",
            "        return uri",
            "",
            "    def get_sqlalchemy_connection(",
            "        self, connect_kwargs: dict | None = None, engine_kwargs: dict | None = None",
            "    ) -> Any:",
            "        \"\"\"SQLAlchemy connection object.\"\"\"",
            "        engine = self.get_sqlalchemy_engine(engine_kwargs=engine_kwargs)",
            "        cnx = engine.connect(**(connect_kwargs or {}))",
            "        return cnx"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "94": [
                "OdbcHook",
                "sqlalchemy_scheme"
            ],
            "95": [
                "OdbcHook",
                "sqlalchemy_scheme"
            ],
            "96": [
                "OdbcHook",
                "sqlalchemy_scheme"
            ],
            "97": [
                "OdbcHook",
                "sqlalchemy_scheme"
            ],
            "98": [
                "OdbcHook",
                "sqlalchemy_scheme"
            ]
        },
        "addLocation": []
    }
}