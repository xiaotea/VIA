{
    "src/pretix/base/forms/widgets.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " from django import forms"
            },
            "1": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " from django.utils.formats import get_format"
            },
            "2": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " from django.utils.functional import lazy"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " from django.utils.timezone import get_current_timezone, now"
            },
            "5": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " from django.utils.translation import gettext_lazy as _"
            },
            "6": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     placeholders = [(k, v.render_sample(event) if event else v) for k, v in placeholders.items()]"
            },
            "8": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     placeholders.sort(key=lambda x: x[0])"
            },
            "9": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     phs = ["
            },
            "10": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        '<button type=\"button\" class=\"content-placeholder\" title=\"%s\">{%s}</button>' % (_(\"Sample: %s\") % v if v else \"\", k)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        '<button type=\"button\" class=\"content-placeholder\" title=\"%s\">{%s}</button>' % (escape(_(\"Sample: %s\") % v) if v else \"\", escape(k))"
            },
            "12": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         for k, v in placeholders"
            },
            "13": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     ]"
            },
            "14": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     return _('Available placeholders: {list}').format("
            }
        },
        "frontPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Felix Sch\u00e4fer",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import os",
            "from datetime import datetime",
            "",
            "from django import forms",
            "from django.utils.formats import get_format",
            "from django.utils.functional import lazy",
            "from django.utils.timezone import get_current_timezone, now",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "",
            "def replace_arabic_numbers(inp):",
            "    if not isinstance(inp, str):",
            "        return inp",
            "    table = {",
            "        1632: 48,  # 0",
            "        1633: 49,  # 1",
            "        1634: 50,  # 2",
            "        1635: 51,  # 3",
            "        1636: 52,  # 4",
            "        1637: 53,  # 5",
            "        1638: 54,  # 6",
            "        1639: 55,  # 7",
            "        1640: 56,  # 8",
            "        1641: 57,  # 9",
            "    }",
            "    return inp.translate(table)",
            "",
            "",
            "def format_placeholders_help_text(placeholders, event=None):",
            "    placeholders = [(k, v.render_sample(event) if event else v) for k, v in placeholders.items()]",
            "    placeholders.sort(key=lambda x: x[0])",
            "    phs = [",
            "        '<button type=\"button\" class=\"content-placeholder\" title=\"%s\">{%s}</button>' % (_(\"Sample: %s\") % v if v else \"\", k)",
            "        for k, v in placeholders",
            "    ]",
            "    return _('Available placeholders: {list}').format(",
            "        list=' '.join(phs)",
            "    )",
            "",
            "",
            "class DatePickerWidget(forms.DateInput):",
            "    def __init__(self, attrs=None, date_format=None):",
            "        attrs = attrs or {}",
            "        if 'placeholder' in attrs:",
            "            del attrs['placeholder']",
            "        date_attrs = dict(attrs)",
            "        date_attrs.setdefault('class', 'form-control')",
            "        date_attrs['class'] += ' datepickerfield'",
            "        date_attrs['autocomplete'] = 'off'",
            "",
            "        def placeholder():",
            "            df = date_format or get_format('DATE_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=12, day=31, hour=18, minute=0, second=0, microsecond=0",
            "            ).strftime(df)",
            "",
            "        date_attrs['placeholder'] = lazy(placeholder, str)",
            "",
            "        forms.DateInput.__init__(self, date_attrs, date_format)",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        v = super().value_from_datadict(data, files, name)",
            "        return replace_arabic_numbers(v)",
            "",
            "",
            "class TimePickerWidget(forms.TimeInput):",
            "    def __init__(self, attrs=None, time_format=None):",
            "        attrs = attrs or {}",
            "        if 'placeholder' in attrs:",
            "            del attrs['placeholder']",
            "        time_attrs = dict(attrs)",
            "        time_attrs.setdefault('class', 'form-control')",
            "        time_attrs['class'] += ' timepickerfield'",
            "        time_attrs['autocomplete'] = 'off'",
            "",
            "        def placeholder():",
            "            tf = time_format or get_format('TIME_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=1, day=1, hour=0, minute=0, second=0, microsecond=0",
            "            ).strftime(tf)",
            "",
            "        time_attrs['placeholder'] = lazy(placeholder, str)",
            "",
            "        forms.TimeInput.__init__(self, time_attrs, time_format)",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        v = super().value_from_datadict(data, files, name)",
            "        return replace_arabic_numbers(v)",
            "",
            "",
            "class UploadedFileWidget(forms.ClearableFileInput):",
            "    def __init__(self, *args, **kwargs):",
            "        self.position = kwargs.pop('position')",
            "        self.event = kwargs.pop('event')",
            "        self.answer = kwargs.pop('answer')",
            "        super().__init__(*args, **kwargs)",
            "",
            "    class FakeFile:",
            "        def __init__(self, file, position, event, answer):",
            "            self.file = file",
            "            self.position = position",
            "            self.event = event",
            "            self.answer = answer",
            "",
            "        def __str__(self):",
            "            return os.path.basename(self.file.name).split('.', 1)[-1]",
            "",
            "        @property",
            "        def url(self):",
            "            from pretix.base.models import OrderPosition",
            "            from pretix.multidomain.urlreverse import eventreverse",
            "",
            "            if isinstance(self.position, OrderPosition):",
            "                return eventreverse(self.event, 'presale:event.order.download.answer', kwargs={",
            "                    'order': self.position.order.code,",
            "                    'secret': self.position.order.secret,",
            "                    'answer': self.answer.pk,",
            "                })",
            "            else:",
            "                return eventreverse(self.event, 'presale:event.cart.download.answer', kwargs={",
            "                    'answer': self.answer.pk,",
            "                })",
            "",
            "    def get_context(self, name, value, attrs):",
            "        # Browsers can't recognize that the server already has a file uploaded",
            "        # Don't mark this input as being required if we already have an answer",
            "        # (this needs to be done via the attrs, otherwise we wouldn't get the \"required\" star on the field label)",
            "        ctx = super().get_context(name, value, attrs)",
            "        if ctx['widget']['is_initial']:",
            "            ctx['widget']['attrs']['required'] = False",
            "        return ctx",
            "",
            "    def format_value(self, value):",
            "        if self.is_initial(value):",
            "            return self.FakeFile(value, self.position, self.event, self.answer)",
            "",
            "",
            "class SplitDateTimePickerWidget(forms.SplitDateTimeWidget):",
            "    template_name = 'pretixbase/forms/widgets/splitdatetime.html'",
            "",
            "    def __init__(self, attrs=None, date_format=None, time_format=None, min_date=None, max_date=None):",
            "        attrs = attrs or {}",
            "        if 'placeholder' in attrs:",
            "            del attrs['placeholder']",
            "        date_attrs = dict(attrs)",
            "        time_attrs = dict(attrs)",
            "        date_attrs.setdefault('class', 'form-control splitdatetimepart')",
            "        time_attrs.setdefault('class', 'form-control splitdatetimepart')",
            "        date_attrs.setdefault('autocomplete', 'off')",
            "        time_attrs.setdefault('autocomplete', 'off')",
            "        date_attrs['class'] += ' datepickerfield'",
            "        time_attrs['class'] += ' timepickerfield'",
            "        date_attrs['autocomplete'] = 'off'",
            "        time_attrs['autocomplete'] = 'off'",
            "        if min_date:",
            "            date_attrs['data-min'] = (",
            "                min_date if not isinstance(min_date, datetime) else min_date.astimezone(get_current_timezone()).date()",
            "            ).isoformat()",
            "        if max_date:",
            "            date_attrs['data-max'] = (",
            "                max_date if not isinstance(max_date, datetime) else max_date.astimezone(get_current_timezone()).date()",
            "            ).isoformat()",
            "",
            "        def date_placeholder():",
            "            df = date_format or get_format('DATE_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=12, day=31, hour=18, minute=0, second=0, microsecond=0",
            "            ).strftime(df)",
            "",
            "        def time_placeholder():",
            "            tf = time_format or get_format('TIME_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=1, day=1, hour=0, minute=0, second=0, microsecond=0",
            "            ).strftime(tf)",
            "",
            "        date_attrs['placeholder'] = lazy(date_placeholder, str)",
            "        time_attrs['placeholder'] = lazy(time_placeholder, str)",
            "        date_attrs['aria-label'] = _('Date')",
            "        time_attrs['aria-label'] = _('Time')",
            "        if 'aria-label' in attrs:",
            "            del attrs['aria-label']",
            "        widgets = (",
            "            forms.DateInput(attrs=date_attrs, format=date_format),",
            "            forms.TimeInput(attrs=time_attrs, format=time_format),",
            "        )",
            "        # Skip one hierarchy level",
            "        forms.MultiWidget.__init__(self, widgets, attrs)",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        v = super().value_from_datadict(data, files, name)",
            "        return [replace_arabic_numbers(i) for i in v]",
            "",
            "",
            "class BusinessBooleanRadio(forms.RadioSelect):",
            "    def __init__(self, require_business=False, attrs=None):",
            "        self.require_business = require_business",
            "        if self.require_business:",
            "            choices = (",
            "                ('business', _('Business or institutional customer')),",
            "            )",
            "        else:",
            "            choices = (",
            "                ('individual', _('Individual customer')),",
            "                ('business', _('Business or institutional customer')),",
            "            )",
            "        super().__init__(attrs, choices)",
            "",
            "    def format_value(self, value):",
            "        if self.require_business:",
            "            return 'business'",
            "        try:",
            "            return {True: 'business', False: 'individual'}[value]",
            "        except KeyError:",
            "            return 'individual'",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        value = data.get(name)",
            "        if self.require_business:",
            "            return True",
            "        return {",
            "            'business': True,",
            "            True: True,",
            "            'True': True,",
            "            'individual': False,",
            "            'False': False,",
            "            False: False,",
            "        }.get(value)"
        ],
        "afterPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Felix Sch\u00e4fer",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import os",
            "from datetime import datetime",
            "",
            "from django import forms",
            "from django.utils.formats import get_format",
            "from django.utils.functional import lazy",
            "from django.utils.html import escape",
            "from django.utils.timezone import get_current_timezone, now",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "",
            "def replace_arabic_numbers(inp):",
            "    if not isinstance(inp, str):",
            "        return inp",
            "    table = {",
            "        1632: 48,  # 0",
            "        1633: 49,  # 1",
            "        1634: 50,  # 2",
            "        1635: 51,  # 3",
            "        1636: 52,  # 4",
            "        1637: 53,  # 5",
            "        1638: 54,  # 6",
            "        1639: 55,  # 7",
            "        1640: 56,  # 8",
            "        1641: 57,  # 9",
            "    }",
            "    return inp.translate(table)",
            "",
            "",
            "def format_placeholders_help_text(placeholders, event=None):",
            "    placeholders = [(k, v.render_sample(event) if event else v) for k, v in placeholders.items()]",
            "    placeholders.sort(key=lambda x: x[0])",
            "    phs = [",
            "        '<button type=\"button\" class=\"content-placeholder\" title=\"%s\">{%s}</button>' % (escape(_(\"Sample: %s\") % v) if v else \"\", escape(k))",
            "        for k, v in placeholders",
            "    ]",
            "    return _('Available placeholders: {list}').format(",
            "        list=' '.join(phs)",
            "    )",
            "",
            "",
            "class DatePickerWidget(forms.DateInput):",
            "    def __init__(self, attrs=None, date_format=None):",
            "        attrs = attrs or {}",
            "        if 'placeholder' in attrs:",
            "            del attrs['placeholder']",
            "        date_attrs = dict(attrs)",
            "        date_attrs.setdefault('class', 'form-control')",
            "        date_attrs['class'] += ' datepickerfield'",
            "        date_attrs['autocomplete'] = 'off'",
            "",
            "        def placeholder():",
            "            df = date_format or get_format('DATE_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=12, day=31, hour=18, minute=0, second=0, microsecond=0",
            "            ).strftime(df)",
            "",
            "        date_attrs['placeholder'] = lazy(placeholder, str)",
            "",
            "        forms.DateInput.__init__(self, date_attrs, date_format)",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        v = super().value_from_datadict(data, files, name)",
            "        return replace_arabic_numbers(v)",
            "",
            "",
            "class TimePickerWidget(forms.TimeInput):",
            "    def __init__(self, attrs=None, time_format=None):",
            "        attrs = attrs or {}",
            "        if 'placeholder' in attrs:",
            "            del attrs['placeholder']",
            "        time_attrs = dict(attrs)",
            "        time_attrs.setdefault('class', 'form-control')",
            "        time_attrs['class'] += ' timepickerfield'",
            "        time_attrs['autocomplete'] = 'off'",
            "",
            "        def placeholder():",
            "            tf = time_format or get_format('TIME_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=1, day=1, hour=0, minute=0, second=0, microsecond=0",
            "            ).strftime(tf)",
            "",
            "        time_attrs['placeholder'] = lazy(placeholder, str)",
            "",
            "        forms.TimeInput.__init__(self, time_attrs, time_format)",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        v = super().value_from_datadict(data, files, name)",
            "        return replace_arabic_numbers(v)",
            "",
            "",
            "class UploadedFileWidget(forms.ClearableFileInput):",
            "    def __init__(self, *args, **kwargs):",
            "        self.position = kwargs.pop('position')",
            "        self.event = kwargs.pop('event')",
            "        self.answer = kwargs.pop('answer')",
            "        super().__init__(*args, **kwargs)",
            "",
            "    class FakeFile:",
            "        def __init__(self, file, position, event, answer):",
            "            self.file = file",
            "            self.position = position",
            "            self.event = event",
            "            self.answer = answer",
            "",
            "        def __str__(self):",
            "            return os.path.basename(self.file.name).split('.', 1)[-1]",
            "",
            "        @property",
            "        def url(self):",
            "            from pretix.base.models import OrderPosition",
            "            from pretix.multidomain.urlreverse import eventreverse",
            "",
            "            if isinstance(self.position, OrderPosition):",
            "                return eventreverse(self.event, 'presale:event.order.download.answer', kwargs={",
            "                    'order': self.position.order.code,",
            "                    'secret': self.position.order.secret,",
            "                    'answer': self.answer.pk,",
            "                })",
            "            else:",
            "                return eventreverse(self.event, 'presale:event.cart.download.answer', kwargs={",
            "                    'answer': self.answer.pk,",
            "                })",
            "",
            "    def get_context(self, name, value, attrs):",
            "        # Browsers can't recognize that the server already has a file uploaded",
            "        # Don't mark this input as being required if we already have an answer",
            "        # (this needs to be done via the attrs, otherwise we wouldn't get the \"required\" star on the field label)",
            "        ctx = super().get_context(name, value, attrs)",
            "        if ctx['widget']['is_initial']:",
            "            ctx['widget']['attrs']['required'] = False",
            "        return ctx",
            "",
            "    def format_value(self, value):",
            "        if self.is_initial(value):",
            "            return self.FakeFile(value, self.position, self.event, self.answer)",
            "",
            "",
            "class SplitDateTimePickerWidget(forms.SplitDateTimeWidget):",
            "    template_name = 'pretixbase/forms/widgets/splitdatetime.html'",
            "",
            "    def __init__(self, attrs=None, date_format=None, time_format=None, min_date=None, max_date=None):",
            "        attrs = attrs or {}",
            "        if 'placeholder' in attrs:",
            "            del attrs['placeholder']",
            "        date_attrs = dict(attrs)",
            "        time_attrs = dict(attrs)",
            "        date_attrs.setdefault('class', 'form-control splitdatetimepart')",
            "        time_attrs.setdefault('class', 'form-control splitdatetimepart')",
            "        date_attrs.setdefault('autocomplete', 'off')",
            "        time_attrs.setdefault('autocomplete', 'off')",
            "        date_attrs['class'] += ' datepickerfield'",
            "        time_attrs['class'] += ' timepickerfield'",
            "        date_attrs['autocomplete'] = 'off'",
            "        time_attrs['autocomplete'] = 'off'",
            "        if min_date:",
            "            date_attrs['data-min'] = (",
            "                min_date if not isinstance(min_date, datetime) else min_date.astimezone(get_current_timezone()).date()",
            "            ).isoformat()",
            "        if max_date:",
            "            date_attrs['data-max'] = (",
            "                max_date if not isinstance(max_date, datetime) else max_date.astimezone(get_current_timezone()).date()",
            "            ).isoformat()",
            "",
            "        def date_placeholder():",
            "            df = date_format or get_format('DATE_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=12, day=31, hour=18, minute=0, second=0, microsecond=0",
            "            ).strftime(df)",
            "",
            "        def time_placeholder():",
            "            tf = time_format or get_format('TIME_INPUT_FORMATS')[0]",
            "            return now().replace(",
            "                year=2000, month=1, day=1, hour=0, minute=0, second=0, microsecond=0",
            "            ).strftime(tf)",
            "",
            "        date_attrs['placeholder'] = lazy(date_placeholder, str)",
            "        time_attrs['placeholder'] = lazy(time_placeholder, str)",
            "        date_attrs['aria-label'] = _('Date')",
            "        time_attrs['aria-label'] = _('Time')",
            "        if 'aria-label' in attrs:",
            "            del attrs['aria-label']",
            "        widgets = (",
            "            forms.DateInput(attrs=date_attrs, format=date_format),",
            "            forms.TimeInput(attrs=time_attrs, format=time_format),",
            "        )",
            "        # Skip one hierarchy level",
            "        forms.MultiWidget.__init__(self, widgets, attrs)",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        v = super().value_from_datadict(data, files, name)",
            "        return [replace_arabic_numbers(i) for i in v]",
            "",
            "",
            "class BusinessBooleanRadio(forms.RadioSelect):",
            "    def __init__(self, require_business=False, attrs=None):",
            "        self.require_business = require_business",
            "        if self.require_business:",
            "            choices = (",
            "                ('business', _('Business or institutional customer')),",
            "            )",
            "        else:",
            "            choices = (",
            "                ('individual', _('Individual customer')),",
            "                ('business', _('Business or institutional customer')),",
            "            )",
            "        super().__init__(attrs, choices)",
            "",
            "    def format_value(self, value):",
            "        if self.require_business:",
            "            return 'business'",
            "        try:",
            "            return {True: 'business', False: 'individual'}[value]",
            "        except KeyError:",
            "            return 'individual'",
            "",
            "    def value_from_datadict(self, data, files, name):",
            "        value = data.get(name)",
            "        if self.require_business:",
            "            return True",
            "        return {",
            "            'business': True,",
            "            True: True,",
            "            'True': True,",
            "            'individual': False,",
            "            'False': False,",
            "            False: False,",
            "        }.get(value)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "67": [
                "format_placeholders_help_text"
            ]
        },
        "addLocation": []
    },
    "src/pretix/control/views/event.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " from django.shortcuts import get_object_or_404, redirect"
            },
            "1": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " from django.urls import reverse"
            },
            "2": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " from django.utils.functional import cached_property"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " from django.utils.http import url_has_allowed_host_and_scheme"
            },
            "5": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " from django.utils.timezone import now"
            },
            "6": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " from django.utils.translation import gettext, gettext_lazy as _, gettext_noop"
            },
            "7": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 727,
                "PatchRowcode": "             else:"
            },
            "8": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 728,
                "PatchRowcode": "                 ctx[p.identifier] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format("
            },
            "9": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 729,
                "PatchRowcode": "                     _('This value will be replaced based on dynamic parameters.'),"
            },
            "10": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    s"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 730,
                "PatchRowcode": "+                    escape(s)"
            },
            "12": {
                "beforePatchRowNumber": 730,
                "afterPatchRowNumber": 731,
                "PatchRowcode": "                 )"
            },
            "13": {
                "beforePatchRowNumber": 731,
                "afterPatchRowNumber": 732,
                "PatchRowcode": "         return ctx"
            },
            "14": {
                "beforePatchRowNumber": 732,
                "afterPatchRowNumber": 733,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 776,
                "afterPatchRowNumber": 777,
                "PatchRowcode": "     def placeholders(self, item):"
            },
            "16": {
                "beforePatchRowNumber": 777,
                "afterPatchRowNumber": 778,
                "PatchRowcode": "         ctx = {}"
            },
            "17": {
                "beforePatchRowNumber": 778,
                "afterPatchRowNumber": 779,
                "PatchRowcode": "         for p in get_available_placeholders(self.request.event, MailSettingsForm.base_context[item]).values():"
            },
            "18": {
                "beforePatchRowNumber": 779,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ctx[p.identifier] = str(p.render_sample(self.request.event))"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 780,
                "PatchRowcode": "+            ctx[p.identifier] = escape(str(p.render_sample(self.request.event)))"
            },
            "20": {
                "beforePatchRowNumber": 780,
                "afterPatchRowNumber": 781,
                "PatchRowcode": "         return ctx"
            },
            "21": {
                "beforePatchRowNumber": 781,
                "afterPatchRowNumber": 782,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 782,
                "afterPatchRowNumber": 783,
                "PatchRowcode": "     def get(self, request, *args, **kwargs):"
            }
        },
        "frontPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Christian Franke, Daniel, Heok Hong Low, Jakob",
            "# Schnell, Maico Timmerman, Sohalt, Tobias Kunze, Ture Gj\u00f8rup, jasonwaiting@live.hk",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import json",
            "import operator",
            "import re",
            "from collections import OrderedDict",
            "from decimal import Decimal",
            "from io import BytesIO",
            "from itertools import groupby",
            "from urllib.parse import urlparse, urlsplit",
            "from zoneinfo import ZoneInfo",
            "",
            "import bleach",
            "import qrcode",
            "import qrcode.image.svg",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import PermissionDenied",
            "from django.core.files import File",
            "from django.db import transaction",
            "from django.db.models import ProtectedError",
            "from django.forms import inlineformset_factory",
            "from django.http import (",
            "    Http404, HttpResponse, HttpResponseBadRequest, HttpResponseNotAllowed,",
            "    JsonResponse,",
            ")",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.urls import reverse",
            "from django.utils.functional import cached_property",
            "from django.utils.http import url_has_allowed_host_and_scheme",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext, gettext_lazy as _, gettext_noop",
            "from django.views.generic import FormView, ListView",
            "from django.views.generic.base import TemplateView, View",
            "from django.views.generic.detail import SingleObjectMixin",
            "from i18nfield.strings import LazyI18nString",
            "from i18nfield.utils import I18nJSONEncoder",
            "",
            "from pretix.base.email import get_available_placeholders",
            "from pretix.base.forms import PlaceholderValidator",
            "from pretix.base.models import Event, LogEntry, Order, TaxRule, Voucher",
            "from pretix.base.models.event import EventMetaValue",
            "from pretix.base.services import tickets",
            "from pretix.base.services.invoices import build_preview_invoice_pdf",
            "from pretix.base.signals import register_ticket_outputs",
            "from pretix.base.templatetags.rich_text import markdown_compile_email",
            "from pretix.control.forms.event import (",
            "    CancelSettingsForm, CommentForm, ConfirmTextFormset, EventDeleteForm,",
            "    EventFooterLinkFormset, EventMetaValueForm, EventSettingsForm,",
            "    EventUpdateForm, InvoiceSettingsForm, ItemMetaPropertyForm,",
            "    MailSettingsForm, PaymentSettingsForm, ProviderForm, QuickSetupForm,",
            "    QuickSetupProductFormSet, TaxRuleForm, TaxRuleLineFormSet,",
            "    TicketSettingsForm, WidgetCodeForm,",
            ")",
            "from pretix.control.permissions import EventPermissionRequiredMixin",
            "from pretix.control.views.mailsetup import MailSettingsSetupView",
            "from pretix.control.views.user import RecentAuthenticationRequiredMixin",
            "from pretix.helpers.database import rolledback_transaction",
            "from pretix.multidomain.urlreverse import build_absolute_uri, get_event_domain",
            "from pretix.plugins.stripe.payment import StripeSettingsHolder",
            "",
            "from ...base.i18n import language",
            "from ...base.models.items import (",
            "    Item, ItemCategory, ItemMetaProperty, Question, Quota,",
            ")",
            "from ...base.settings import LazyI18nStringList",
            "from ...helpers.compat import CompatDeleteView",
            "from ...helpers.format import format_map",
            "from ..logdisplay import OVERVIEW_BANLIST",
            "from . import CreateView, PaginationMixin, UpdateView",
            "",
            "",
            "class EventSettingsViewMixin:",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['is_event_settings'] = True",
            "        return ctx",
            "",
            "",
            "class MetaDataEditorMixin:",
            "    meta_form = EventMetaValueForm",
            "    meta_model = EventMetaValue",
            "",
            "    @cached_property",
            "    def meta_forms(self):",
            "        if hasattr(self, 'object') and self.object:",
            "            val_instances = {",
            "                v.property_id: v for v in self.object.meta_values.all()",
            "            }",
            "        else:",
            "            val_instances = {}",
            "",
            "        formlist = []",
            "",
            "        for p in self.request.organizer.meta_properties.all():",
            "            formlist.append(self._make_meta_form(p, val_instances))",
            "        return formlist",
            "",
            "    def _make_meta_form(self, p, val_instances):",
            "        return self.meta_form(",
            "            prefix='prop-{}'.format(p.pk),",
            "            property=p,",
            "            disabled=(",
            "                p.protected and",
            "                not self.request.user.has_organizer_permission(self.request.organizer, 'can_change_organizer_settings', request=self.request)",
            "            ),",
            "            instance=val_instances.get(p.pk, self.meta_model(property=p, event=self.object)),",
            "            data=(self.request.POST if self.request.method == \"POST\" else None)",
            "        )",
            "",
            "    def save_meta(self):",
            "        for f in self.meta_forms:",
            "            if f.cleaned_data.get('value'):",
            "                f.save()",
            "            elif f.instance and f.instance.pk:",
            "                f.instance.delete()",
            "",
            "",
            "class DecoupleMixin:",
            "",
            "    def _save_decoupled(self, form):",
            "        # Save fields that are currently only set via the organizer but should be decoupled",
            "        fields = set()",
            "        for f in self.request.POST.getlist(\"decouple\"):",
            "            fields |= set(f.split(\",\"))",
            "        for f in fields:",
            "            if f not in form.fields:",
            "                continue",
            "            if f not in self.request.event.settings._cache():",
            "                self.request.event.settings.set(f, self.request.event.settings.get(f))",
            "",
            "",
            "class EventUpdate(DecoupleMixin, EventSettingsViewMixin, EventPermissionRequiredMixin, MetaDataEditorMixin, UpdateView):",
            "    model = Event",
            "    form_class = EventUpdateForm",
            "    template_name = 'pretixcontrol/event/settings.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    @cached_property",
            "    def object(self) -> Event:",
            "        return self.request.event",
            "",
            "    def get_object(self, queryset=None) -> Event:",
            "        return self.object",
            "",
            "    @cached_property",
            "    def sform(self):",
            "        return EventSettingsForm(",
            "            obj=self.object,",
            "            prefix='settings',",
            "            data=self.request.POST if self.request.method == 'POST' else None,",
            "            files=self.request.FILES if self.request.method == 'POST' else None,",
            "        )",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['sform'] = self.sform",
            "        context['meta_forms'] = self.meta_forms",
            "        context['item_meta_property_formset'] = self.item_meta_property_formset",
            "        context['confirm_texts_formset'] = self.confirm_texts_formset",
            "        context['footer_links_formset'] = self.footer_links_formset",
            "        return context",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        self._save_decoupled(self.sform)",
            "        self.sform.save()",
            "        self.object.cache.clear()",
            "        self.save_meta()",
            "        self.save_item_meta_property_formset(self.object)",
            "        self.save_confirm_texts_formset(self.object)",
            "        self.save_footer_links_formset(self.object)",
            "",
            "        if self.sform.has_changed() or self.confirm_texts_formset.has_changed():",
            "            data = {k: self.request.event.settings.get(k) for k in self.sform.changed_data}",
            "            if self.confirm_texts_formset.has_changed():",
            "                data.update(confirm_texts=self.confirm_texts_formset.cleaned_data)",
            "            self.request.event.log_action('pretix.event.settings', user=self.request.user, data=data)",
            "        if self.footer_links_formset.has_changed():",
            "            self.request.event.log_action('pretix.event.footerlinks.changed', user=self.request.user, data={",
            "                'data': self.footer_links_formset.cleaned_data",
            "            })",
            "        if form.has_changed():",
            "            self.request.event.log_action('pretix.event.changed', user=self.request.user, data={",
            "                k: (form.cleaned_data.get(k).name",
            "                    if isinstance(form.cleaned_data.get(k), File)",
            "                    else form.cleaned_data.get(k))",
            "                for k in form.changed_data",
            "            })",
            "",
            "        tickets.invalidate_cache.apply_async(kwargs={'event': self.request.event.pk})",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        return super().form_valid(form)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings', kwargs={",
            "            'organizer': self.object.organizer.slug,",
            "            'event': self.object.slug,",
            "        })",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        if self.request.user.has_active_staff_session(self.request.session.session_key):",
            "            kwargs['change_slug'] = True",
            "            kwargs['domain'] = True",
            "        return kwargs",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid() and self.sform.is_valid() and all([f.is_valid() for f in self.meta_forms]) and \\",
            "                self.item_meta_property_formset.is_valid() and self.confirm_texts_formset.is_valid() and \\",
            "                self.footer_links_formset.is_valid():",
            "            # reset timezone",
            "            zone = ZoneInfo(self.sform.cleaned_data['timezone'])",
            "            event = form.instance",
            "            event.date_from = self.reset_timezone(zone, event.date_from)",
            "            event.date_to = self.reset_timezone(zone, event.date_to)",
            "            event.presale_start = self.reset_timezone(zone, event.presale_start)",
            "            event.presale_end = self.reset_timezone(zone, event.presale_end)",
            "            return self.form_valid(form)",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.form_invalid(form)",
            "",
            "    @staticmethod",
            "    def reset_timezone(tz, dt):",
            "        return dt.replace(tzinfo=tz) if dt is not None else None",
            "",
            "    @cached_property",
            "    def item_meta_property_formset(self):",
            "        formsetclass = inlineformset_factory(",
            "            Event, ItemMetaProperty,",
            "            form=ItemMetaPropertyForm, can_order=False, can_delete=True, extra=0",
            "        )",
            "        return formsetclass(self.request.POST if self.request.method == \"POST\" else None, prefix=\"item-meta-property\",",
            "                            instance=self.object, queryset=self.object.item_meta_properties.all())",
            "",
            "    def save_item_meta_property_formset(self, obj):",
            "        for form in self.item_meta_property_formset.initial_forms:",
            "            if form in self.item_meta_property_formset.deleted_forms:",
            "                if not form.instance.pk:",
            "                    continue",
            "                form.instance.log_action(",
            "                    'pretix.event.item_meta_property.deleted',",
            "                    user=self.request.user,",
            "                    data=form.cleaned_data",
            "                )",
            "                form.instance.delete()",
            "                form.instance.pk = None",
            "            elif form.has_changed():",
            "                form.instance.log_action(",
            "                    'pretix.event.item_meta_property.changed',",
            "                    user=self.request.user,",
            "                    data=form.cleaned_data",
            "                )",
            "                form.save()",
            "",
            "        for form in self.item_meta_property_formset.extra_forms:",
            "            if not form.has_changed():",
            "                continue",
            "            if self.item_meta_property_formset._should_delete_form(form):",
            "                continue",
            "            form.instance.event = obj",
            "            form.save()",
            "            form.instance.log_action(",
            "                'pretix.event.item_meta_property.added',",
            "                user=self.request.user,",
            "                data=form.cleaned_data",
            "            )",
            "",
            "    @cached_property",
            "    def confirm_texts_formset(self):",
            "        initial = [{\"text\": text, \"ORDER\": order} for order, text in",
            "                   enumerate(self.object.settings.get(\"confirm_texts\", as_type=LazyI18nStringList))]",
            "        return ConfirmTextFormset(self.request.POST if self.request.method == \"POST\" else None, event=self.object,",
            "                                  prefix=\"confirm-texts\", initial=initial)",
            "",
            "    def save_confirm_texts_formset(self, obj):",
            "        obj.settings.confirm_texts = LazyI18nStringList(",
            "            form_data['text'].data",
            "            for form_data in sorted((d for d in self.confirm_texts_formset.cleaned_data if d), key=operator.itemgetter(\"ORDER\"))",
            "            if form_data and not form_data.get(\"DELETE\", False)",
            "        )",
            "",
            "    @cached_property",
            "    def footer_links_formset(self):",
            "        return EventFooterLinkFormset(self.request.POST if self.request.method == \"POST\" else None, event=self.object,",
            "                                      prefix=\"footer-links\", instance=self.object)",
            "",
            "    def save_footer_links_formset(self, obj):",
            "        self.footer_links_formset.save()",
            "",
            "",
            "class EventPlugins(EventSettingsViewMixin, EventPermissionRequiredMixin, TemplateView, SingleObjectMixin):",
            "    model = Event",
            "    context_object_name = 'event'",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/plugins.html'",
            "",
            "    def get_object(self, queryset=None) -> Event:",
            "        return self.request.event",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        from pretix.base.plugins import get_all_plugins",
            "",
            "        context = super().get_context_data(*args, **kwargs)",
            "        plugins = [p for p in get_all_plugins(self.object) if not p.name.startswith('.')",
            "                   and getattr(p, 'visible', True)]",
            "        order = [",
            "            'FEATURE',",
            "            'PAYMENT',",
            "            'INTEGRATION',",
            "            'CUSTOMIZATION',",
            "            'FORMAT',",
            "            'API',",
            "        ]",
            "        labels = {",
            "            'FEATURE': _('Features'),",
            "            'PAYMENT': _('Payment providers'),",
            "            'INTEGRATION': _('Integrations'),",
            "            'CUSTOMIZATION': _('Customizations'),",
            "            'FORMAT': _('Output and export formats'),",
            "            'API': _('API features'),",
            "        }",
            "",
            "        plugins_grouped = groupby(",
            "            sorted(",
            "                plugins,",
            "                key=lambda p: (",
            "                    str(getattr(p, 'category', _('Other'))),",
            "                    (0 if getattr(p, 'featured', False) else 1),",
            "                    str(p.name).lower().replace('pretix ', '')",
            "                ),",
            "            ),",
            "            lambda p: str(getattr(p, 'category', _('Other')))",
            "        )",
            "        plugins_grouped = [(c, list(plist)) for c, plist in plugins_grouped]",
            "",
            "        context['plugins'] = sorted([",
            "            (c, labels.get(c, c), plist, any(getattr(p, 'picture', None) for p in plist))",
            "            for c, plist",
            "            in plugins_grouped",
            "        ], key=lambda c: (order.index(c[0]), c[1]) if c[0] in order else (999, str(c[1])))",
            "        context['plugins_active'] = self.object.get_plugins()",
            "        context['show_meta'] = settings.PRETIX_PLUGINS_SHOW_META",
            "        return context",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        context = self.get_context_data(object=self.object)",
            "        return self.render_to_response(context)",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        from pretix.base.plugins import get_all_plugins",
            "",
            "        self.object = self.get_object()",
            "",
            "        plugins_available = {",
            "            p.module: p for p in get_all_plugins(self.object)",
            "            if not p.name.startswith('.') and getattr(p, 'visible', True)",
            "        }",
            "",
            "        with transaction.atomic():",
            "            for key, value in request.POST.items():",
            "                if key.startswith(\"plugin:\"):",
            "                    module = key.split(\":\")[1]",
            "                    if value == \"enable\" and module in plugins_available:",
            "                        if getattr(plugins_available[module], 'restricted', False):",
            "                            if module not in request.event.settings.allowed_restricted_plugins:",
            "                                continue",
            "",
            "                        self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                                      data={'plugin': module})",
            "                        self.object.enable_plugin(module, allow_restricted=request.event.settings.allowed_restricted_plugins)",
            "                    else:",
            "                        self.request.event.log_action('pretix.event.plugins.disabled', user=self.request.user,",
            "                                                      data={'plugin': module})",
            "                        self.object.disable_plugin(module)",
            "            self.object.save()",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.plugins', kwargs={",
            "            'organizer': self.get_object().organizer.slug,",
            "            'event': self.get_object().slug,",
            "        })",
            "",
            "",
            "class PaymentProviderSettings(EventSettingsViewMixin, EventPermissionRequiredMixin, TemplateView, SingleObjectMixin):",
            "    model = Event",
            "    context_object_name = 'event'",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/payment_provider.html'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.payment', kwargs={",
            "            'organizer': self.get_object().organizer.slug,",
            "            'event': self.get_object().slug,",
            "        })",
            "",
            "    @cached_property",
            "    def object(self):",
            "        return self.request.event",
            "",
            "    def get_object(self, queryset=None):",
            "        return self.object",
            "",
            "    @cached_property",
            "    def provider(self):",
            "        provider = self.request.event.get_payment_providers().get(self.kwargs['provider'])",
            "        return provider",
            "",
            "    @cached_property",
            "    def form(self):",
            "        form = ProviderForm(",
            "            obj=self.request.event,",
            "            settingspref=self.provider.settings.get_prefix(),",
            "            data=(self.request.POST if self.request.method == 'POST' else None),",
            "            files=(self.request.FILES if self.request.method == 'POST' else None),",
            "            provider=self.provider",
            "        )",
            "        form.fields = OrderedDict(",
            "            [",
            "                ('%s%s' % (self.provider.settings.get_prefix(), k), v)",
            "                for k, v in self.provider.settings_form_fields.items()",
            "            ]",
            "        )",
            "        form.prepare_fields()",
            "        return form",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.provider:",
            "            messages.error(self.request, _('This payment provider does not exist or the respective plugin is '",
            "                                           'disabled.'))",
            "            return redirect(self.get_success_url())",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    @cached_property",
            "    def settings_content(self):",
            "        return self.provider.settings_content_render(self.request)",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['form'] = self.form",
            "        context['provider'] = self.provider",
            "        context['settings_content'] = self.settings_content",
            "        return context",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        if self.form.is_valid():",
            "            if self.form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.payment.provider.' + self.provider.identifier, user=self.request.user, data={",
            "                        k: self.form.cleaned_data.get(k) for k in self.form.changed_data",
            "                    }",
            "                )",
            "                self.form.save()",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.get(request)",
            "",
            "",
            "class EventSettingsFormView(EventPermissionRequiredMixin, DecoupleMixin, FormView):",
            "    model = Event",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        return context",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['obj'] = self.request.event",
            "        return kwargs",
            "",
            "    def form_success(self):",
            "        pass",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid():",
            "            form.save()",
            "            self._save_decoupled(form)",
            "            if form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.settings', user=self.request.user, data={",
            "                        k: (form.cleaned_data.get(k).name",
            "                            if isinstance(form.cleaned_data.get(k), File)",
            "                            else form.cleaned_data.get(k))",
            "                        for k in form.changed_data",
            "                    }",
            "                )",
            "            self.form_success()",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.render_to_response(self.get_context_data(form=form))",
            "",
            "",
            "class PaymentSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    template_name = 'pretixcontrol/event/payment.html'",
            "    form_class = PaymentSettingsForm",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.payment', kwargs={",
            "            'organizer': self.request.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['providers'] = sorted(",
            "            [p for p in self.request.event.get_payment_providers().values()",
            "             if not (p.is_implicit(self.request) if callable(p.is_implicit) else p.is_implicit) and",
            "             (p.settings_form_fields or p.settings_content_render(self.request))],",
            "            key=lambda s: s.verbose_name",
            "        )",
            "",
            "        sales_channels = {s.identifier: s for s in self.request.organizer.sales_channels.all()}",
            "        for p in context['providers']:",
            "            p.show_enabled = p.is_enabled",
            "            p.sales_channels = [sales_channels[channel] for channel in p.settings.get('_restrict_to_sales_channels', as_type=list, default=['web'])]",
            "            if p.is_meta:",
            "                p.show_enabled = p.settings._enabled in (True, 'True')",
            "        return context",
            "",
            "",
            "class InvoiceSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    model = Event",
            "    form_class = InvoiceSettingsForm",
            "    template_name = 'pretixcontrol/event/invoicing.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        if 'preview' in self.request.POST:",
            "            return reverse('control:event.settings.invoice.preview', kwargs={",
            "                'organizer': self.request.event.organizer.slug,",
            "                'event': self.request.event.slug",
            "            })",
            "        return reverse('control:event.settings.invoice', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class CancelSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    model = Event",
            "    form_class = CancelSettingsForm",
            "    template_name = 'pretixcontrol/event/cancel.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.cancel', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        ctx['gets_notification'] = self.request.user.notifications_send and (",
            "            (",
            "                self.request.user.notification_settings.filter(",
            "                    event=self.request.event,",
            "                    action_type='pretix.event.order.refund.requested',",
            "                    enabled=True",
            "                ).exists()",
            "            ) or (",
            "                self.request.user.notification_settings.filter(",
            "                    event__isnull=True,",
            "                    action_type='pretix.event.order.refund.requested',",
            "                    enabled=True",
            "                ).exists() and not",
            "                self.request.user.notification_settings.filter(",
            "                    event=self.request.event,",
            "                    action_type='pretix.event.order.refund.requested',",
            "                    enabled=False",
            "                ).exists()",
            "            )",
            "        )",
            "        return ctx",
            "",
            "",
            "class InvoicePreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        fname, ftype, fcontent = build_preview_invoice_pdf(request.event)",
            "        resp = HttpResponse(fcontent, content_type=ftype)",
            "        if settings.DEBUG:",
            "            # attachment is more secure as we're dealing with user-generated stuff here, but inline is much more convenient during debugging",
            "            resp['Content-Disposition'] = 'inline; filename=\"{}\"'.format(fname)",
            "            resp._csp_ignore = True",
            "        else:",
            "            resp['Content-Disposition'] = 'attachment; filename=\"{}\"'.format(fname)",
            "        return resp",
            "",
            "",
            "class DangerZone(EventPermissionRequiredMixin, TemplateView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/dangerzone.html'",
            "",
            "",
            "class DisplaySettings(View):",
            "    def get(self, request, *wargs, **kwargs):",
            "        return redirect(reverse('control:event.settings', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        }) + '#tab-0-3-open')",
            "",
            "",
            "class MailSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    model = Event",
            "    form_class = MailSettingsForm",
            "    template_name = 'pretixcontrol/event/mail.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.mail', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['renderers'] = self.request.event.get_html_mail_renderers()",
            "        return ctx",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid():",
            "            form.save()",
            "            if form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.settings', user=self.request.user, data={",
            "                        k: form.cleaned_data.get(k) for k in form.changed_data",
            "                    }",
            "                )",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.get(request)",
            "",
            "",
            "class MailSettingsSetup(EventPermissionRequiredMixin, MailSettingsSetupView):",
            "    permission = 'can_change_event_settings'",
            "    basetpl = 'pretixcontrol/event/base.html'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.mail', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def log_action(self, data):",
            "        self.request.event.log_action(",
            "            'pretix.event.settings', user=self.request.user, data=data",
            "        )",
            "",
            "",
            "class MailSettingsPreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    # create index-language mapping",
            "    @cached_property",
            "    def supported_locale(self):",
            "        locales = {}",
            "        for idx, val in enumerate(settings.LANGUAGES):",
            "            if val[0] in self.request.event.settings.locales:",
            "                locales[str(idx)] = val[0]",
            "        return locales",
            "",
            "    # get all supported placeholders with dummy values",
            "    def placeholders(self, item):",
            "        ctx = {}",
            "        for p in get_available_placeholders(self.request.event, MailSettingsForm.base_context[item]).values():",
            "            s = str(p.render_sample(self.request.event))",
            "            if s.strip().startswith('* '):",
            "                ctx[p.identifier] = '<div class=\"placeholder\" title=\"{}\">{}</div>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    markdown_compile_email(s)",
            "                )",
            "            else:",
            "                ctx[p.identifier] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    s",
            "                )",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        preview_item = request.POST.get('item', '')",
            "        if preview_item not in MailSettingsForm.base_context:",
            "            return HttpResponseBadRequest(_('invalid item'))",
            "",
            "        regex = r\"^\" + re.escape(preview_item) + r\"_(?P<idx>[\\d]+)$\"",
            "        msgs = {}",
            "        for k, v in request.POST.items():",
            "            # only accept allowed fields",
            "            matched = re.search(regex, k)",
            "            if matched is not None:",
            "                idx = matched.group('idx')",
            "                if idx in self.supported_locale:",
            "                    with language(self.supported_locale[idx], self.request.event.settings.region):",
            "                        try:",
            "                            if k.startswith('mail_subject_'):",
            "                                msgs[self.supported_locale[idx]] = format_map(",
            "                                    bleach.clean(v), self.placeholders(preview_item), raise_on_missing=True",
            "                                )",
            "                            else:",
            "                                msgs[self.supported_locale[idx]] = markdown_compile_email(",
            "                                    format_map(v, self.placeholders(preview_item), raise_on_missing=True)",
            "                                )",
            "                        except ValueError:",
            "                            msgs[self.supported_locale[idx]] = '<div class=\"alert alert-danger\">{}</div>'.format(",
            "                                PlaceholderValidator.error_message)",
            "                        except KeyError as e:",
            "                            msgs[self.supported_locale[idx]] = '<div class=\"alert alert-danger\">{}</div>'.format(",
            "                                _('Invalid placeholder: {%(value)s}') % {'value': e.args[0]})",
            "",
            "        return JsonResponse({",
            "            'item': preview_item,",
            "            'msgs': msgs",
            "        })",
            "",
            "",
            "class MailSettingsRendererPreview(MailSettingsPreview):",
            "    permission = 'can_change_event_settings'",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        return HttpResponse(status=405)",
            "",
            "    # get all supported placeholders with dummy values",
            "    def placeholders(self, item):",
            "        ctx = {}",
            "        for p in get_available_placeholders(self.request.event, MailSettingsForm.base_context[item]).values():",
            "            ctx[p.identifier] = str(p.render_sample(self.request.event))",
            "        return ctx",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        v = str(request.event.settings.mail_text_order_placed)",
            "        v = format_map(v, self.placeholders('mail_text_order_placed'))",
            "        renderers = request.event.get_html_mail_renderers()",
            "        if request.GET.get('renderer') in renderers:",
            "            with rolledback_transaction():",
            "                order = request.event.orders.create(",
            "                    status=Order.STATUS_PENDING, datetime=now(),",
            "                    expires=now(), code=\"PREVIEW\", total=119,",
            "                    sales_channel=request.organizer.sales_channels.get(identifier=\"web\")",
            "                )",
            "                item = request.event.items.create(name=gettext(\"Sample product\"), default_price=42.23,",
            "                                                  description=gettext(\"Sample product description\"))",
            "                order.positions.create(item=item, attendee_name_parts={'_legacy': gettext(\"John Doe\")},",
            "                                       price=item.default_price, subevent=request.event.subevents.last())",
            "                v = renderers[request.GET.get('renderer')].render(",
            "                    v,",
            "                    str(request.event.settings.mail_text_signature),",
            "                    gettext('Your order: %(code)s') % {'code': order.code},",
            "                    order,",
            "                    position=None",
            "                )",
            "                r = HttpResponse(v, content_type='text/html')",
            "                r._csp_ignore = True",
            "                return r",
            "        else:",
            "            raise Http404(_('Unknown e-mail renderer.'))",
            "",
            "",
            "class TicketSettingsPreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    @cached_property",
            "    def output(self):",
            "        responses = register_ticket_outputs.send(self.request.event)",
            "        for receiver, response in responses:",
            "            provider = response(self.request.event)",
            "            if provider.identifier == self.kwargs.get('output'):",
            "                return provider",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        if not self.output:",
            "            messages.error(request, _('You requested an invalid ticket output type.'))",
            "            return redirect(self.get_error_url())",
            "",
            "        fname, mimet, data = tickets.preview(self.request.event.pk, self.output.identifier)",
            "        resp = HttpResponse(data, content_type=mimet)",
            "        ftype = fname.split(\".\")[-1]",
            "        resp['Content-Disposition'] = 'attachment; filename=\"ticket-preview.{}\"'.format(ftype)",
            "        return resp",
            "",
            "    def get_error_url(self) -> str:",
            "        return reverse('control:event.settings.tickets', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class TicketSettings(EventSettingsViewMixin, EventPermissionRequiredMixin, FormView):",
            "    model = Event",
            "    form_class = TicketSettingsForm",
            "    template_name = 'pretixcontrol/event/tickets.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['providers'] = self.provider_forms",
            "",
            "        context['any_enabled'] = False",
            "        responses = register_ticket_outputs.send(self.request.event)",
            "        for receiver, response in responses:",
            "            provider = response(self.request.event)",
            "            if provider.is_enabled:",
            "                context['any_enabled'] = True",
            "                break",
            "",
            "        return context",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tickets', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['obj'] = self.request.event",
            "        return kwargs",
            "",
            "    def get_form(self, form_class=None):",
            "        form = super().get_form(form_class)",
            "        form.prepare_fields()",
            "        return form",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        success = True",
            "        for provider in self.provider_forms:",
            "            if provider.form.is_valid():",
            "                provider.form.save()",
            "                if provider.form.has_changed():",
            "                    self.request.event.log_action(",
            "                        'pretix.event.tickets.provider.' + provider.identifier, user=self.request.user, data={",
            "                            k: (provider.form.cleaned_data.get(k).name",
            "                                if isinstance(provider.form.cleaned_data.get(k), File)",
            "                                else provider.form.cleaned_data.get(k))",
            "                            for k in provider.form.changed_data",
            "                        }",
            "                    )",
            "                    tickets.invalidate_cache.apply_async(kwargs={'event': self.request.event.pk, 'provider': provider.identifier})",
            "            else:",
            "                success = False",
            "        form = self.get_form(self.get_form_class())",
            "        if success and form.is_valid():",
            "            form.save()",
            "            if form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.tickets.settings', user=self.request.user, data={",
            "                        k: form.cleaned_data.get(k) for k in form.changed_data",
            "                    }",
            "                )",
            "",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    @cached_property",
            "    def provider_forms(self) -> list:",
            "        providers = []",
            "        responses = register_ticket_outputs.send(self.request.event)",
            "        for receiver, response in responses:",
            "            provider = response(self.request.event)",
            "            provider.form = ProviderForm(",
            "                obj=self.request.event,",
            "                settingspref='ticketoutput_%s_' % provider.identifier,",
            "                data=(self.request.POST if self.request.method == 'POST' else None),",
            "                files=(self.request.FILES if self.request.method == 'POST' else None)",
            "            )",
            "            provider.form.fields = OrderedDict(",
            "                [",
            "                    ('ticketoutput_%s_%s' % (provider.identifier, k), v)",
            "                    for k, v in provider.settings_form_fields.items()",
            "                ]",
            "            )",
            "            provider.settings_content = provider.settings_content_render(self.request)",
            "            provider.form.prepare_fields()",
            "",
            "            provider.evaluated_preview_allowed = True",
            "            if not provider.preview_allowed:",
            "                provider.evaluated_preview_allowed = False",
            "            else:",
            "                for k, v in provider.settings_form_fields.items():",
            "                    if v.required and not self.request.event.settings.get('ticketoutput_%s_%s' % (provider.identifier, k)):",
            "                        provider.evaluated_preview_allowed = False",
            "                        break",
            "",
            "            providers.append(provider)",
            "        return providers",
            "",
            "",
            "class EventPermissions(EventSettingsViewMixin, EventPermissionRequiredMixin, TemplateView):",
            "    template_name = 'pretixcontrol/event/permissions.html'",
            "",
            "",
            "class EventLive(EventPermissionRequiredMixin, TemplateView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/live.html'",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['issues'] = self.request.event.live_issues",
            "        ctx['actual_orders'] = self.request.event.orders.filter(testmode=False).exists()",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        if request.POST.get(\"live\") == \"true\" and not self.request.event.live_issues:",
            "            with transaction.atomic():",
            "                request.event.live = True",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.live.activated', user=self.request.user, data={}",
            "                )",
            "            messages.success(self.request, _('Your shop is live now!'))",
            "        elif request.POST.get(\"live\") == \"false\":",
            "            with transaction.atomic():",
            "                request.event.live = False",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.live.deactivated', user=self.request.user, data={}",
            "                )",
            "            messages.success(self.request, _('We\\'ve taken your shop down. You can re-enable it whenever you want!'))",
            "        elif request.POST.get(\"testmode\") == \"true\":",
            "            with transaction.atomic():",
            "                request.event.testmode = True",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.testmode.activated', user=self.request.user, data={}",
            "                )",
            "            messages.success(self.request, _('Your shop is now in test mode!'))",
            "        elif request.POST.get(\"testmode\") == \"false\":",
            "            with transaction.atomic():",
            "                request.event.testmode = False",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.testmode.deactivated', user=self.request.user, data={",
            "                        'delete': (request.POST.get(\"delete\") == \"yes\")",
            "                    }",
            "                )",
            "            request.event.cache.delete('complain_testmode_orders')",
            "            if request.POST.get(\"delete\") == \"yes\":",
            "                try:",
            "                    with transaction.atomic():",
            "                        for order in request.event.orders.filter(testmode=True):",
            "                            order.gracefully_delete(user=self.request.user)",
            "                except ProtectedError:",
            "                    messages.error(self.request, _('An order could not be deleted as some constraints (e.g. data '",
            "                                                   'created by plug-ins) do not allow it.'))",
            "                else:",
            "                    request.event.cache.set('complain_testmode_orders', False, 30)",
            "            request.event.cartposition_set.filter(addon_to__isnull=False).delete()",
            "            request.event.cartposition_set.all().delete()",
            "            messages.success(self.request, _('We\\'ve disabled test mode for you. Let\\'s sell some real tickets!'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.live', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class EventTransferSession(EventPermissionRequiredMixin, TemplateView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/transfer_session.html'",
            "",
            "",
            "class EventDelete(RecentAuthenticationRequiredMixin, EventPermissionRequiredMixin, FormView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/delete.html'",
            "    form_class = EventDeleteForm",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        if not self.request.event.allow_delete():",
            "            messages.error(self.request, _('This event can not be deleted.'))",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "        return super().post(request, *args, **kwargs)",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        return kwargs",
            "",
            "    def form_valid(self, form):",
            "        try:",
            "            with transaction.atomic():",
            "                self.request.organizer.log_action(",
            "                    'pretix.event.deleted', user=self.request.user,",
            "                    data={",
            "                        'event_id': self.request.event.pk,",
            "                        'name': str(self.request.event.name),",
            "                        'slug': self.request.event.slug,",
            "                        'logentries': list(self.request.event.logentry_set.values_list('pk', flat=True))",
            "                    }",
            "                )",
            "                self.request.event.delete_sub_objects()",
            "                self.request.event.delete()",
            "            messages.success(self.request, _('The event has been deleted.'))",
            "            return redirect(self.get_success_url())",
            "        except ProtectedError as e:",
            "            err = gettext('The event could not be deleted as some constraints (e.g. data created by plug-ins) do not allow it.')",
            "",
            "            app_labels = set()",
            "            for e in e.protected_objects:",
            "                app_labels.add(type(e)._meta.app_label)",
            "",
            "            plugin_names = []",
            "            for app_label in app_labels:",
            "                app = apps.get_app_config(app_label)",
            "                if hasattr(app, 'PretixPluginMeta'):",
            "                    plugin_names.append(str(app.PretixPluginMeta.name))",
            "                else:",
            "                    plugin_names.append(str(app.verbose_name))",
            "",
            "            if plugin_names:",
            "                err += ' ' + gettext(",
            "                    'Specifically, the following plugins still contain data depends on this event: {plugin_names}'",
            "                ).format(plugin_names=', '.join(plugin_names))",
            "",
            "            messages.error(self.request, err)",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:index')",
            "",
            "",
            "class EventLog(EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    template_name = 'pretixcontrol/event/logs.html'",
            "    model = LogEntry",
            "    context_object_name = 'logs'",
            "",
            "    def get_queryset(self):",
            "        qs = self.request.event.logentry_set.all().select_related(",
            "            'user', 'content_type', 'api_token', 'oauth_application', 'device'",
            "        ).order_by('-datetime', '-pk')",
            "        qs = qs.exclude(action_type__in=OVERVIEW_BANLIST)",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event, 'can_view_orders',",
            "                                                      request=self.request):",
            "            qs = qs.exclude(content_type=ContentType.objects.get_for_model(Order))",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event, 'can_view_vouchers',",
            "                                                      request=self.request):",
            "            qs = qs.exclude(content_type=ContentType.objects.get_for_model(Voucher))",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event,",
            "                                                      'can_change_event_settings', request=self.request):",
            "            allowed_types = [",
            "                ContentType.objects.get_for_model(Voucher),",
            "                ContentType.objects.get_for_model(Order)",
            "            ]",
            "            if self.request.user.has_event_permission(self.request.organizer, self.request.event,",
            "                                                      'can_change_items', request=self.request):",
            "                allowed_types += [",
            "                    ContentType.objects.get_for_model(Item),",
            "                    ContentType.objects.get_for_model(ItemCategory),",
            "                    ContentType.objects.get_for_model(Quota),",
            "                    ContentType.objects.get_for_model(Question),",
            "                ]",
            "            qs = qs.filter(content_type__in=allowed_types)",
            "",
            "        if self.request.GET.get('user') == 'yes':",
            "            qs = qs.filter(user__isnull=False)",
            "        elif self.request.GET.get('user') == 'no':",
            "            qs = qs.filter(user__isnull=True)",
            "        elif self.request.GET.get('user', '').startswith('d-'):",
            "            qs = qs.filter(device_id=self.request.GET.get('user')[2:])",
            "        elif self.request.GET.get('user'):",
            "            qs = qs.filter(user_id=self.request.GET.get('user'))",
            "",
            "        if self.request.GET.get('action_type'):",
            "            qs = qs.filter(action_type=self.request.GET['action_type'])",
            "",
            "        if self.request.GET.get('content_type'):",
            "            qs = qs.filter(content_type=get_object_or_404(ContentType, pk=self.request.GET.get('content_type')))",
            "",
            "            if self.request.GET.get('object'):",
            "                qs = qs.filter(object_id=self.request.GET.get('object'))",
            "",
            "        return qs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        ctx['userlist'] = self.request.event.logentry_set.order_by().distinct().values('user__id', 'user__email')",
            "        ctx['devicelist'] = self.request.event.logentry_set.order_by('device__name').distinct().values('device__id', 'device__name')",
            "        return ctx",
            "",
            "",
            "class EventComment(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    def post(self, *args, **kwargs):",
            "        form = CommentForm(self.request.POST)",
            "        if form.is_valid():",
            "            self.request.event.comment = form.cleaned_data.get('comment')",
            "            self.request.event.save()",
            "            self.request.event.log_action('pretix.event.comment', user=self.request.user, data={",
            "                'new_comment': form.cleaned_data.get('comment')",
            "            })",
            "            messages.success(self.request, _('The comment has been updated.'))",
            "        else:",
            "            messages.error(self.request, _('Could not update the comment.'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get(self, *args, **kwargs):",
            "        return HttpResponseNotAllowed(['POST'])",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.index', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class TaxList(EventSettingsViewMixin, EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    model = TaxRule",
            "    context_object_name = 'taxrules'",
            "    template_name = 'pretixcontrol/event/tax_index.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_queryset(self):",
            "        return self.request.event.tax_rules.all()",
            "",
            "",
            "class TaxCreate(EventSettingsViewMixin, EventPermissionRequiredMixin, CreateView):",
            "    model = TaxRule",
            "    form_class = TaxRuleForm",
            "    template_name = 'pretixcontrol/event/tax_edit.html'",
            "    permission = 'can_change_event_settings'",
            "    context_object_name = 'taxrule'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tax', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_initial(self):",
            "        return {",
            "            'name': LazyI18nString.from_gettext(gettext('VAT'))",
            "        }",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        self.object = None",
            "        form = self.get_form()",
            "        if form.is_valid() and self.formset.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    @cached_property",
            "    def formset(self):",
            "        return TaxRuleLineFormSet(",
            "            data=self.request.POST if self.request.method == \"POST\" else None,",
            "            event=self.request.event,",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['formset'] = self.formset",
            "        return ctx",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        form.instance.event = self.request.event",
            "        form.instance.custom_rules = json.dumps([",
            "            f.cleaned_data for f in self.formset.ordered_forms if f not in self.formset.deleted_forms",
            "        ], cls=I18nJSONEncoder)",
            "        messages.success(self.request, _('The new tax rule has been created.'))",
            "        ret = super().form_valid(form)",
            "        form.instance.log_action('pretix.event.taxrule.added', user=self.request.user, data=dict(form.cleaned_data))",
            "        return ret",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "",
            "class TaxUpdate(EventSettingsViewMixin, EventPermissionRequiredMixin, UpdateView):",
            "    model = TaxRule",
            "    form_class = TaxRuleForm",
            "    template_name = 'pretixcontrol/event/tax_edit.html'",
            "    permission = 'can_change_event_settings'",
            "    context_object_name = 'rule'",
            "",
            "    def get_object(self, queryset=None) -> TaxRule:",
            "        try:",
            "            return self.request.event.tax_rules.get(",
            "                id=self.kwargs['rule']",
            "            )",
            "        except TaxRule.DoesNotExist:",
            "            raise Http404(_(\"The requested tax rule does not exist.\"))",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        self.object = self.get_object(self.get_queryset())",
            "        form = self.get_form()",
            "        if form.is_valid() and self.formset.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    @cached_property",
            "    def formset(self):",
            "        return TaxRuleLineFormSet(",
            "            data=self.request.POST if self.request.method == \"POST\" else None,",
            "            event=self.request.event,",
            "            initial=json.loads(self.object.custom_rules) if self.object.custom_rules else []",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['formset'] = self.formset",
            "        return ctx",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        form.instance.custom_rules = json.dumps([",
            "            f.cleaned_data for f in self.formset.ordered_forms if f not in self.formset.deleted_forms",
            "        ], cls=I18nJSONEncoder)",
            "        if form.has_changed():",
            "            self.object.log_action(",
            "                'pretix.event.taxrule.changed', user=self.request.user, data={",
            "                    k: form.cleaned_data.get(k) for k in form.changed_data",
            "                }",
            "            )",
            "        return super().form_valid(form)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tax', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "",
            "class TaxDelete(EventSettingsViewMixin, EventPermissionRequiredMixin, CompatDeleteView):",
            "    model = TaxRule",
            "    template_name = 'pretixcontrol/event/tax_delete.html'",
            "    permission = 'can_change_event_settings'",
            "    context_object_name = 'taxrule'",
            "",
            "    def get_object(self, queryset=None) -> TaxRule:",
            "        try:",
            "            return self.request.event.tax_rules.get(",
            "                id=self.kwargs['rule']",
            "            )",
            "        except TaxRule.DoesNotExist:",
            "            raise Http404(_(\"The requested tax rule does not exist.\"))",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "        if self.object.allow_delete():",
            "            self.object.log_action(action='pretix.event.taxrule.deleted', user=request.user)",
            "            self.object.delete()",
            "            messages.success(self.request, _('The selected tax rule has been deleted.'))",
            "        else:",
            "            messages.error(self.request, _('The selected tax rule can not be deleted.'))",
            "        return redirect(success_url)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tax', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['possible'] = self.object.allow_delete()",
            "        return context",
            "",
            "",
            "class WidgetSettings(EventSettingsViewMixin, EventPermissionRequiredMixin, FormView):",
            "    template_name = 'pretixcontrol/event/widget.html'",
            "    permission = 'can_change_event_settings'",
            "    form_class = WidgetCodeForm",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        return kwargs",
            "",
            "    def form_valid(self, form):",
            "        ctx = self.get_context_data()",
            "        ctx['form'] = form",
            "        ctx['valid'] = True",
            "        return self.render_to_response(ctx)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['urlprefix'] = settings.SITE_URL",
            "        domain = get_event_domain(self.request.event, fallback=True)",
            "        if domain:",
            "            siteurlsplit = urlsplit(settings.SITE_URL)",
            "            if siteurlsplit.port and siteurlsplit.port not in (80, 443):",
            "                domain = '%s:%d' % (domain, siteurlsplit.port)",
            "            ctx['urlprefix'] = '%s://%s' % (siteurlsplit.scheme, domain)",
            "        return ctx",
            "",
            "",
            "class QuickSetupView(FormView):",
            "    template_name = 'pretixcontrol/event/quick_setup.html'",
            "    permission = 'can_change_event_settings'",
            "    form_class = QuickSetupForm",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if request.event.items.exists() or request.event.quotas.exists():",
            "            messages.info(request, _('Your event is not empty, you need to set it up manually.'))",
            "            return redirect(reverse('control:event.index', kwargs={",
            "                'organizer': request.event.organizer.slug,",
            "                'event': request.event.slug",
            "            }))",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        return kwargs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        ctx['formset'] = self.formset",
            "        return ctx",
            "",
            "    def get_initial(self):",
            "        return {",
            "            'waiting_list_enabled': True,",
            "            'ticket_download': True,",
            "            'contact_mail': self.request.event.settings.contact_mail,",
            "            'imprint_url': self.request.event.settings.imprint_url,",
            "        }",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid() and self.formset.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.form_invalid(form)",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        plugins_active = self.request.event.get_plugins()",
            "        if form.cleaned_data['ticket_download']:",
            "            if 'pretix.plugins.ticketoutputpdf' not in plugins_active:",
            "                self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                              data={'plugin': 'pretix.plugins.ticketoutputpdf'})",
            "                plugins_active.append('pretix.plugins.ticketoutputpdf')",
            "",
            "            self.request.event.settings.ticket_download = True",
            "            self.request.event.settings.ticketoutput_pdf__enabled = True",
            "",
            "            try:",
            "                import pretix_passbook  # noqa",
            "            except ImportError:",
            "                pass",
            "            else:",
            "                if 'pretix_passbook' not in plugins_active:",
            "                    self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                                  data={'plugin': 'pretix_passbook'})",
            "                    plugins_active.append('pretix_passbook')",
            "                self.request.event.settings.ticketoutput_passbook__enabled = True",
            "",
            "        if form.cleaned_data['payment_banktransfer__enabled']:",
            "            if 'pretix.plugins.banktransfer' not in plugins_active:",
            "                self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                              data={'plugin': 'pretix.plugins.banktransfer'})",
            "                plugins_active.append('pretix.plugins.banktransfer')",
            "            self.request.event.settings.payment_banktransfer__enabled = True",
            "            for f in ('bank_details', 'bank_details_type', 'bank_details_sepa_name', 'bank_details_sepa_iban',",
            "                      'bank_details_sepa_bic', 'bank_details_sepa_bank'):",
            "                self.request.event.settings.set(",
            "                    'payment_banktransfer_%s' % f,",
            "                    form.cleaned_data['payment_banktransfer_%s' % f]",
            "                )",
            "",
            "        if form.cleaned_data.get('payment_stripe__enabled', None):",
            "            if 'pretix.plugins.stripe' not in plugins_active:",
            "                self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                              data={'plugin': 'pretix.plugins.stripe'})",
            "                plugins_active.append('pretix.plugins.stripe')",
            "",
            "        self.request.event.settings.show_quota_left = form.cleaned_data['show_quota_left']",
            "        self.request.event.settings.waiting_list_enabled = form.cleaned_data['waiting_list_enabled']",
            "        self.request.event.settings.attendee_names_required = form.cleaned_data['attendee_names_required']",
            "        self.request.event.settings.contact_mail = form.cleaned_data['contact_mail']",
            "        self.request.event.settings.imprint_url = form.cleaned_data['imprint_url']",
            "        self.request.event.log_action('pretix.event.settings', user=self.request.user, data={",
            "            k: self.request.event.settings.get(k) for k in form.changed_data",
            "        })",
            "",
            "        items = []",
            "        category = None",
            "        tax_rule = self.request.event.tax_rules.first()",
            "        if any(f not in self.formset.deleted_forms for f in self.formset):",
            "            category = self.request.event.categories.create(",
            "                name=LazyI18nString.from_gettext(gettext('Tickets'))",
            "            )",
            "            category.log_action('pretix.event.category.added', data={'name': gettext('Tickets')},",
            "                                user=self.request.user)",
            "",
            "        subevent = self.request.event.subevents.first()",
            "        for i, f in enumerate(self.formset):",
            "            if f in self.formset.deleted_forms or not f.has_changed():",
            "                continue",
            "",
            "            item = self.request.event.items.create(",
            "                name=f.cleaned_data['name'],",
            "                category=category,",
            "                active=True,",
            "                default_price=f.cleaned_data['default_price'] or 0,",
            "                tax_rule=tax_rule,",
            "                admission=True,",
            "                personalized=True,",
            "                position=i,",
            "                all_sales_channels=True,",
            "            )",
            "            item.log_action('pretix.event.item.added', user=self.request.user, data=dict(f.cleaned_data))",
            "            if f.cleaned_data['quota'] or not form.cleaned_data['total_quota']:",
            "                quota = self.request.event.quotas.create(",
            "                    name=str(f.cleaned_data['name']),",
            "                    subevent=subevent,",
            "                    size=f.cleaned_data['quota'],",
            "                )",
            "                quota.log_action('pretix.event.quota.added', user=self.request.user, data=dict(f.cleaned_data))",
            "                quota.items.add(item)",
            "            items.append(item)",
            "",
            "        if form.cleaned_data['total_quota']:",
            "            quota = self.request.event.quotas.create(",
            "                name=gettext('Tickets'),",
            "                size=form.cleaned_data['total_quota'],",
            "                subevent=subevent,",
            "            )",
            "            quota.log_action('pretix.event.quota.added', user=self.request.user, data={",
            "                'name': gettext('Tickets'),",
            "                'size': quota.size",
            "            })",
            "            quota.items.add(*items)",
            "",
            "        self.request.event.set_active_plugins(plugins_active, allow_restricted=plugins_active)",
            "        self.request.event.save()",
            "        messages.success(self.request, _('Your changes have been saved. You can now go on with looking at the details '",
            "                                         'or take your event live to start selling!'))",
            "",
            "        if form.cleaned_data.get('payment_stripe__enabled', False):",
            "            self.request.session['payment_stripe_oauth_enable'] = True",
            "            return redirect(StripeSettingsHolder(self.request.event).get_connect_url(self.request))",
            "",
            "        return redirect(reverse('control:event.index', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        }))",
            "",
            "    @cached_property",
            "    def formset(self):",
            "        return QuickSetupProductFormSet(",
            "            data=self.request.POST if self.request.method == \"POST\" else None,",
            "            event=self.request.event,",
            "            initial=[",
            "                {",
            "                    'name': LazyI18nString.from_gettext(gettext_noop('Regular ticket')),",
            "                    'default_price': Decimal('35.00'),",
            "                    'quota': 100,",
            "                },",
            "                {",
            "                    'name': LazyI18nString.from_gettext(gettext_noop('Reduced ticket')),",
            "                    'default_price': Decimal('29.00'),",
            "                    'quota': 50,",
            "                },",
            "            ] if self.request.method != \"POST\" else []",
            "        )",
            "",
            "",
            "class EventQRCode(EventPermissionRequiredMixin, View):",
            "    permission = None",
            "",
            "    def get(self, request, *args, filetype, **kwargs):",
            "        url = build_absolute_uri(request.event, 'presale:event.index')",
            "",
            "        if \"url\" in request.GET:",
            "            if url_has_allowed_host_and_scheme(request.GET[\"url\"], allowed_hosts=[urlparse(url).netloc]):",
            "                url = request.GET[\"url\"]",
            "            else:",
            "                raise PermissionDenied(\"Untrusted URL\")",
            "",
            "        qr = qrcode.QRCode(",
            "            version=1,",
            "            error_correction=qrcode.constants.ERROR_CORRECT_M,",
            "            box_size=10,",
            "            border=4,",
            "        )",
            "        qr.add_data(url)",
            "        qr.make(fit=True)",
            "",
            "        if filetype == 'svg':",
            "            factory = qrcode.image.svg.SvgPathImage",
            "            img = qr.make_image(image_factory=factory)",
            "            r = HttpResponse(img.to_string(), content_type='image/svg+xml')",
            "            r['Content-Disposition'] = f'inline; filename=\"qrcode-{request.event.slug}.{filetype}\"'",
            "            return r",
            "        elif filetype in ('jpeg', 'png', 'gif'):",
            "            img = qr.make_image(fill_color=\"black\", back_color=\"white\")",
            "",
            "            byte_io = BytesIO()",
            "            img.save(byte_io, filetype.upper())",
            "            byte_io.seek(0)",
            "            r = HttpResponse(byte_io.read(), content_type='image/' + filetype)",
            "            r['Content-Disposition'] = f'inline; filename=\"qrcode-{request.event.slug}.{filetype}\"'",
            "            return r"
        ],
        "afterPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Christian Franke, Daniel, Heok Hong Low, Jakob",
            "# Schnell, Maico Timmerman, Sohalt, Tobias Kunze, Ture Gj\u00f8rup, jasonwaiting@live.hk",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import json",
            "import operator",
            "import re",
            "from collections import OrderedDict",
            "from decimal import Decimal",
            "from io import BytesIO",
            "from itertools import groupby",
            "from urllib.parse import urlparse, urlsplit",
            "from zoneinfo import ZoneInfo",
            "",
            "import bleach",
            "import qrcode",
            "import qrcode.image.svg",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import PermissionDenied",
            "from django.core.files import File",
            "from django.db import transaction",
            "from django.db.models import ProtectedError",
            "from django.forms import inlineformset_factory",
            "from django.http import (",
            "    Http404, HttpResponse, HttpResponseBadRequest, HttpResponseNotAllowed,",
            "    JsonResponse,",
            ")",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.urls import reverse",
            "from django.utils.functional import cached_property",
            "from django.utils.html import escape",
            "from django.utils.http import url_has_allowed_host_and_scheme",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext, gettext_lazy as _, gettext_noop",
            "from django.views.generic import FormView, ListView",
            "from django.views.generic.base import TemplateView, View",
            "from django.views.generic.detail import SingleObjectMixin",
            "from i18nfield.strings import LazyI18nString",
            "from i18nfield.utils import I18nJSONEncoder",
            "",
            "from pretix.base.email import get_available_placeholders",
            "from pretix.base.forms import PlaceholderValidator",
            "from pretix.base.models import Event, LogEntry, Order, TaxRule, Voucher",
            "from pretix.base.models.event import EventMetaValue",
            "from pretix.base.services import tickets",
            "from pretix.base.services.invoices import build_preview_invoice_pdf",
            "from pretix.base.signals import register_ticket_outputs",
            "from pretix.base.templatetags.rich_text import markdown_compile_email",
            "from pretix.control.forms.event import (",
            "    CancelSettingsForm, CommentForm, ConfirmTextFormset, EventDeleteForm,",
            "    EventFooterLinkFormset, EventMetaValueForm, EventSettingsForm,",
            "    EventUpdateForm, InvoiceSettingsForm, ItemMetaPropertyForm,",
            "    MailSettingsForm, PaymentSettingsForm, ProviderForm, QuickSetupForm,",
            "    QuickSetupProductFormSet, TaxRuleForm, TaxRuleLineFormSet,",
            "    TicketSettingsForm, WidgetCodeForm,",
            ")",
            "from pretix.control.permissions import EventPermissionRequiredMixin",
            "from pretix.control.views.mailsetup import MailSettingsSetupView",
            "from pretix.control.views.user import RecentAuthenticationRequiredMixin",
            "from pretix.helpers.database import rolledback_transaction",
            "from pretix.multidomain.urlreverse import build_absolute_uri, get_event_domain",
            "from pretix.plugins.stripe.payment import StripeSettingsHolder",
            "",
            "from ...base.i18n import language",
            "from ...base.models.items import (",
            "    Item, ItemCategory, ItemMetaProperty, Question, Quota,",
            ")",
            "from ...base.settings import LazyI18nStringList",
            "from ...helpers.compat import CompatDeleteView",
            "from ...helpers.format import format_map",
            "from ..logdisplay import OVERVIEW_BANLIST",
            "from . import CreateView, PaginationMixin, UpdateView",
            "",
            "",
            "class EventSettingsViewMixin:",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['is_event_settings'] = True",
            "        return ctx",
            "",
            "",
            "class MetaDataEditorMixin:",
            "    meta_form = EventMetaValueForm",
            "    meta_model = EventMetaValue",
            "",
            "    @cached_property",
            "    def meta_forms(self):",
            "        if hasattr(self, 'object') and self.object:",
            "            val_instances = {",
            "                v.property_id: v for v in self.object.meta_values.all()",
            "            }",
            "        else:",
            "            val_instances = {}",
            "",
            "        formlist = []",
            "",
            "        for p in self.request.organizer.meta_properties.all():",
            "            formlist.append(self._make_meta_form(p, val_instances))",
            "        return formlist",
            "",
            "    def _make_meta_form(self, p, val_instances):",
            "        return self.meta_form(",
            "            prefix='prop-{}'.format(p.pk),",
            "            property=p,",
            "            disabled=(",
            "                p.protected and",
            "                not self.request.user.has_organizer_permission(self.request.organizer, 'can_change_organizer_settings', request=self.request)",
            "            ),",
            "            instance=val_instances.get(p.pk, self.meta_model(property=p, event=self.object)),",
            "            data=(self.request.POST if self.request.method == \"POST\" else None)",
            "        )",
            "",
            "    def save_meta(self):",
            "        for f in self.meta_forms:",
            "            if f.cleaned_data.get('value'):",
            "                f.save()",
            "            elif f.instance and f.instance.pk:",
            "                f.instance.delete()",
            "",
            "",
            "class DecoupleMixin:",
            "",
            "    def _save_decoupled(self, form):",
            "        # Save fields that are currently only set via the organizer but should be decoupled",
            "        fields = set()",
            "        for f in self.request.POST.getlist(\"decouple\"):",
            "            fields |= set(f.split(\",\"))",
            "        for f in fields:",
            "            if f not in form.fields:",
            "                continue",
            "            if f not in self.request.event.settings._cache():",
            "                self.request.event.settings.set(f, self.request.event.settings.get(f))",
            "",
            "",
            "class EventUpdate(DecoupleMixin, EventSettingsViewMixin, EventPermissionRequiredMixin, MetaDataEditorMixin, UpdateView):",
            "    model = Event",
            "    form_class = EventUpdateForm",
            "    template_name = 'pretixcontrol/event/settings.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    @cached_property",
            "    def object(self) -> Event:",
            "        return self.request.event",
            "",
            "    def get_object(self, queryset=None) -> Event:",
            "        return self.object",
            "",
            "    @cached_property",
            "    def sform(self):",
            "        return EventSettingsForm(",
            "            obj=self.object,",
            "            prefix='settings',",
            "            data=self.request.POST if self.request.method == 'POST' else None,",
            "            files=self.request.FILES if self.request.method == 'POST' else None,",
            "        )",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['sform'] = self.sform",
            "        context['meta_forms'] = self.meta_forms",
            "        context['item_meta_property_formset'] = self.item_meta_property_formset",
            "        context['confirm_texts_formset'] = self.confirm_texts_formset",
            "        context['footer_links_formset'] = self.footer_links_formset",
            "        return context",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        self._save_decoupled(self.sform)",
            "        self.sform.save()",
            "        self.object.cache.clear()",
            "        self.save_meta()",
            "        self.save_item_meta_property_formset(self.object)",
            "        self.save_confirm_texts_formset(self.object)",
            "        self.save_footer_links_formset(self.object)",
            "",
            "        if self.sform.has_changed() or self.confirm_texts_formset.has_changed():",
            "            data = {k: self.request.event.settings.get(k) for k in self.sform.changed_data}",
            "            if self.confirm_texts_formset.has_changed():",
            "                data.update(confirm_texts=self.confirm_texts_formset.cleaned_data)",
            "            self.request.event.log_action('pretix.event.settings', user=self.request.user, data=data)",
            "        if self.footer_links_formset.has_changed():",
            "            self.request.event.log_action('pretix.event.footerlinks.changed', user=self.request.user, data={",
            "                'data': self.footer_links_formset.cleaned_data",
            "            })",
            "        if form.has_changed():",
            "            self.request.event.log_action('pretix.event.changed', user=self.request.user, data={",
            "                k: (form.cleaned_data.get(k).name",
            "                    if isinstance(form.cleaned_data.get(k), File)",
            "                    else form.cleaned_data.get(k))",
            "                for k in form.changed_data",
            "            })",
            "",
            "        tickets.invalidate_cache.apply_async(kwargs={'event': self.request.event.pk})",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        return super().form_valid(form)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings', kwargs={",
            "            'organizer': self.object.organizer.slug,",
            "            'event': self.object.slug,",
            "        })",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        if self.request.user.has_active_staff_session(self.request.session.session_key):",
            "            kwargs['change_slug'] = True",
            "            kwargs['domain'] = True",
            "        return kwargs",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid() and self.sform.is_valid() and all([f.is_valid() for f in self.meta_forms]) and \\",
            "                self.item_meta_property_formset.is_valid() and self.confirm_texts_formset.is_valid() and \\",
            "                self.footer_links_formset.is_valid():",
            "            # reset timezone",
            "            zone = ZoneInfo(self.sform.cleaned_data['timezone'])",
            "            event = form.instance",
            "            event.date_from = self.reset_timezone(zone, event.date_from)",
            "            event.date_to = self.reset_timezone(zone, event.date_to)",
            "            event.presale_start = self.reset_timezone(zone, event.presale_start)",
            "            event.presale_end = self.reset_timezone(zone, event.presale_end)",
            "            return self.form_valid(form)",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.form_invalid(form)",
            "",
            "    @staticmethod",
            "    def reset_timezone(tz, dt):",
            "        return dt.replace(tzinfo=tz) if dt is not None else None",
            "",
            "    @cached_property",
            "    def item_meta_property_formset(self):",
            "        formsetclass = inlineformset_factory(",
            "            Event, ItemMetaProperty,",
            "            form=ItemMetaPropertyForm, can_order=False, can_delete=True, extra=0",
            "        )",
            "        return formsetclass(self.request.POST if self.request.method == \"POST\" else None, prefix=\"item-meta-property\",",
            "                            instance=self.object, queryset=self.object.item_meta_properties.all())",
            "",
            "    def save_item_meta_property_formset(self, obj):",
            "        for form in self.item_meta_property_formset.initial_forms:",
            "            if form in self.item_meta_property_formset.deleted_forms:",
            "                if not form.instance.pk:",
            "                    continue",
            "                form.instance.log_action(",
            "                    'pretix.event.item_meta_property.deleted',",
            "                    user=self.request.user,",
            "                    data=form.cleaned_data",
            "                )",
            "                form.instance.delete()",
            "                form.instance.pk = None",
            "            elif form.has_changed():",
            "                form.instance.log_action(",
            "                    'pretix.event.item_meta_property.changed',",
            "                    user=self.request.user,",
            "                    data=form.cleaned_data",
            "                )",
            "                form.save()",
            "",
            "        for form in self.item_meta_property_formset.extra_forms:",
            "            if not form.has_changed():",
            "                continue",
            "            if self.item_meta_property_formset._should_delete_form(form):",
            "                continue",
            "            form.instance.event = obj",
            "            form.save()",
            "            form.instance.log_action(",
            "                'pretix.event.item_meta_property.added',",
            "                user=self.request.user,",
            "                data=form.cleaned_data",
            "            )",
            "",
            "    @cached_property",
            "    def confirm_texts_formset(self):",
            "        initial = [{\"text\": text, \"ORDER\": order} for order, text in",
            "                   enumerate(self.object.settings.get(\"confirm_texts\", as_type=LazyI18nStringList))]",
            "        return ConfirmTextFormset(self.request.POST if self.request.method == \"POST\" else None, event=self.object,",
            "                                  prefix=\"confirm-texts\", initial=initial)",
            "",
            "    def save_confirm_texts_formset(self, obj):",
            "        obj.settings.confirm_texts = LazyI18nStringList(",
            "            form_data['text'].data",
            "            for form_data in sorted((d for d in self.confirm_texts_formset.cleaned_data if d), key=operator.itemgetter(\"ORDER\"))",
            "            if form_data and not form_data.get(\"DELETE\", False)",
            "        )",
            "",
            "    @cached_property",
            "    def footer_links_formset(self):",
            "        return EventFooterLinkFormset(self.request.POST if self.request.method == \"POST\" else None, event=self.object,",
            "                                      prefix=\"footer-links\", instance=self.object)",
            "",
            "    def save_footer_links_formset(self, obj):",
            "        self.footer_links_formset.save()",
            "",
            "",
            "class EventPlugins(EventSettingsViewMixin, EventPermissionRequiredMixin, TemplateView, SingleObjectMixin):",
            "    model = Event",
            "    context_object_name = 'event'",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/plugins.html'",
            "",
            "    def get_object(self, queryset=None) -> Event:",
            "        return self.request.event",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        from pretix.base.plugins import get_all_plugins",
            "",
            "        context = super().get_context_data(*args, **kwargs)",
            "        plugins = [p for p in get_all_plugins(self.object) if not p.name.startswith('.')",
            "                   and getattr(p, 'visible', True)]",
            "        order = [",
            "            'FEATURE',",
            "            'PAYMENT',",
            "            'INTEGRATION',",
            "            'CUSTOMIZATION',",
            "            'FORMAT',",
            "            'API',",
            "        ]",
            "        labels = {",
            "            'FEATURE': _('Features'),",
            "            'PAYMENT': _('Payment providers'),",
            "            'INTEGRATION': _('Integrations'),",
            "            'CUSTOMIZATION': _('Customizations'),",
            "            'FORMAT': _('Output and export formats'),",
            "            'API': _('API features'),",
            "        }",
            "",
            "        plugins_grouped = groupby(",
            "            sorted(",
            "                plugins,",
            "                key=lambda p: (",
            "                    str(getattr(p, 'category', _('Other'))),",
            "                    (0 if getattr(p, 'featured', False) else 1),",
            "                    str(p.name).lower().replace('pretix ', '')",
            "                ),",
            "            ),",
            "            lambda p: str(getattr(p, 'category', _('Other')))",
            "        )",
            "        plugins_grouped = [(c, list(plist)) for c, plist in plugins_grouped]",
            "",
            "        context['plugins'] = sorted([",
            "            (c, labels.get(c, c), plist, any(getattr(p, 'picture', None) for p in plist))",
            "            for c, plist",
            "            in plugins_grouped",
            "        ], key=lambda c: (order.index(c[0]), c[1]) if c[0] in order else (999, str(c[1])))",
            "        context['plugins_active'] = self.object.get_plugins()",
            "        context['show_meta'] = settings.PRETIX_PLUGINS_SHOW_META",
            "        return context",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        context = self.get_context_data(object=self.object)",
            "        return self.render_to_response(context)",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        from pretix.base.plugins import get_all_plugins",
            "",
            "        self.object = self.get_object()",
            "",
            "        plugins_available = {",
            "            p.module: p for p in get_all_plugins(self.object)",
            "            if not p.name.startswith('.') and getattr(p, 'visible', True)",
            "        }",
            "",
            "        with transaction.atomic():",
            "            for key, value in request.POST.items():",
            "                if key.startswith(\"plugin:\"):",
            "                    module = key.split(\":\")[1]",
            "                    if value == \"enable\" and module in plugins_available:",
            "                        if getattr(plugins_available[module], 'restricted', False):",
            "                            if module not in request.event.settings.allowed_restricted_plugins:",
            "                                continue",
            "",
            "                        self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                                      data={'plugin': module})",
            "                        self.object.enable_plugin(module, allow_restricted=request.event.settings.allowed_restricted_plugins)",
            "                    else:",
            "                        self.request.event.log_action('pretix.event.plugins.disabled', user=self.request.user,",
            "                                                      data={'plugin': module})",
            "                        self.object.disable_plugin(module)",
            "            self.object.save()",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.plugins', kwargs={",
            "            'organizer': self.get_object().organizer.slug,",
            "            'event': self.get_object().slug,",
            "        })",
            "",
            "",
            "class PaymentProviderSettings(EventSettingsViewMixin, EventPermissionRequiredMixin, TemplateView, SingleObjectMixin):",
            "    model = Event",
            "    context_object_name = 'event'",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/payment_provider.html'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.payment', kwargs={",
            "            'organizer': self.get_object().organizer.slug,",
            "            'event': self.get_object().slug,",
            "        })",
            "",
            "    @cached_property",
            "    def object(self):",
            "        return self.request.event",
            "",
            "    def get_object(self, queryset=None):",
            "        return self.object",
            "",
            "    @cached_property",
            "    def provider(self):",
            "        provider = self.request.event.get_payment_providers().get(self.kwargs['provider'])",
            "        return provider",
            "",
            "    @cached_property",
            "    def form(self):",
            "        form = ProviderForm(",
            "            obj=self.request.event,",
            "            settingspref=self.provider.settings.get_prefix(),",
            "            data=(self.request.POST if self.request.method == 'POST' else None),",
            "            files=(self.request.FILES if self.request.method == 'POST' else None),",
            "            provider=self.provider",
            "        )",
            "        form.fields = OrderedDict(",
            "            [",
            "                ('%s%s' % (self.provider.settings.get_prefix(), k), v)",
            "                for k, v in self.provider.settings_form_fields.items()",
            "            ]",
            "        )",
            "        form.prepare_fields()",
            "        return form",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.provider:",
            "            messages.error(self.request, _('This payment provider does not exist or the respective plugin is '",
            "                                           'disabled.'))",
            "            return redirect(self.get_success_url())",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    @cached_property",
            "    def settings_content(self):",
            "        return self.provider.settings_content_render(self.request)",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['form'] = self.form",
            "        context['provider'] = self.provider",
            "        context['settings_content'] = self.settings_content",
            "        return context",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        if self.form.is_valid():",
            "            if self.form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.payment.provider.' + self.provider.identifier, user=self.request.user, data={",
            "                        k: self.form.cleaned_data.get(k) for k in self.form.changed_data",
            "                    }",
            "                )",
            "                self.form.save()",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.get(request)",
            "",
            "",
            "class EventSettingsFormView(EventPermissionRequiredMixin, DecoupleMixin, FormView):",
            "    model = Event",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        return context",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['obj'] = self.request.event",
            "        return kwargs",
            "",
            "    def form_success(self):",
            "        pass",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid():",
            "            form.save()",
            "            self._save_decoupled(form)",
            "            if form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.settings', user=self.request.user, data={",
            "                        k: (form.cleaned_data.get(k).name",
            "                            if isinstance(form.cleaned_data.get(k), File)",
            "                            else form.cleaned_data.get(k))",
            "                        for k in form.changed_data",
            "                    }",
            "                )",
            "            self.form_success()",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.render_to_response(self.get_context_data(form=form))",
            "",
            "",
            "class PaymentSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    template_name = 'pretixcontrol/event/payment.html'",
            "    form_class = PaymentSettingsForm",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.payment', kwargs={",
            "            'organizer': self.request.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['providers'] = sorted(",
            "            [p for p in self.request.event.get_payment_providers().values()",
            "             if not (p.is_implicit(self.request) if callable(p.is_implicit) else p.is_implicit) and",
            "             (p.settings_form_fields or p.settings_content_render(self.request))],",
            "            key=lambda s: s.verbose_name",
            "        )",
            "",
            "        sales_channels = {s.identifier: s for s in self.request.organizer.sales_channels.all()}",
            "        for p in context['providers']:",
            "            p.show_enabled = p.is_enabled",
            "            p.sales_channels = [sales_channels[channel] for channel in p.settings.get('_restrict_to_sales_channels', as_type=list, default=['web'])]",
            "            if p.is_meta:",
            "                p.show_enabled = p.settings._enabled in (True, 'True')",
            "        return context",
            "",
            "",
            "class InvoiceSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    model = Event",
            "    form_class = InvoiceSettingsForm",
            "    template_name = 'pretixcontrol/event/invoicing.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        if 'preview' in self.request.POST:",
            "            return reverse('control:event.settings.invoice.preview', kwargs={",
            "                'organizer': self.request.event.organizer.slug,",
            "                'event': self.request.event.slug",
            "            })",
            "        return reverse('control:event.settings.invoice', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class CancelSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    model = Event",
            "    form_class = CancelSettingsForm",
            "    template_name = 'pretixcontrol/event/cancel.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.cancel', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        ctx['gets_notification'] = self.request.user.notifications_send and (",
            "            (",
            "                self.request.user.notification_settings.filter(",
            "                    event=self.request.event,",
            "                    action_type='pretix.event.order.refund.requested',",
            "                    enabled=True",
            "                ).exists()",
            "            ) or (",
            "                self.request.user.notification_settings.filter(",
            "                    event__isnull=True,",
            "                    action_type='pretix.event.order.refund.requested',",
            "                    enabled=True",
            "                ).exists() and not",
            "                self.request.user.notification_settings.filter(",
            "                    event=self.request.event,",
            "                    action_type='pretix.event.order.refund.requested',",
            "                    enabled=False",
            "                ).exists()",
            "            )",
            "        )",
            "        return ctx",
            "",
            "",
            "class InvoicePreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        fname, ftype, fcontent = build_preview_invoice_pdf(request.event)",
            "        resp = HttpResponse(fcontent, content_type=ftype)",
            "        if settings.DEBUG:",
            "            # attachment is more secure as we're dealing with user-generated stuff here, but inline is much more convenient during debugging",
            "            resp['Content-Disposition'] = 'inline; filename=\"{}\"'.format(fname)",
            "            resp._csp_ignore = True",
            "        else:",
            "            resp['Content-Disposition'] = 'attachment; filename=\"{}\"'.format(fname)",
            "        return resp",
            "",
            "",
            "class DangerZone(EventPermissionRequiredMixin, TemplateView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/dangerzone.html'",
            "",
            "",
            "class DisplaySettings(View):",
            "    def get(self, request, *wargs, **kwargs):",
            "        return redirect(reverse('control:event.settings', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        }) + '#tab-0-3-open')",
            "",
            "",
            "class MailSettings(EventSettingsViewMixin, EventSettingsFormView):",
            "    model = Event",
            "    form_class = MailSettingsForm",
            "    template_name = 'pretixcontrol/event/mail.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.mail', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['renderers'] = self.request.event.get_html_mail_renderers()",
            "        return ctx",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid():",
            "            form.save()",
            "            if form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.settings', user=self.request.user, data={",
            "                        k: form.cleaned_data.get(k) for k in form.changed_data",
            "                    }",
            "                )",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.get(request)",
            "",
            "",
            "class MailSettingsSetup(EventPermissionRequiredMixin, MailSettingsSetupView):",
            "    permission = 'can_change_event_settings'",
            "    basetpl = 'pretixcontrol/event/base.html'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.mail', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def log_action(self, data):",
            "        self.request.event.log_action(",
            "            'pretix.event.settings', user=self.request.user, data=data",
            "        )",
            "",
            "",
            "class MailSettingsPreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    # create index-language mapping",
            "    @cached_property",
            "    def supported_locale(self):",
            "        locales = {}",
            "        for idx, val in enumerate(settings.LANGUAGES):",
            "            if val[0] in self.request.event.settings.locales:",
            "                locales[str(idx)] = val[0]",
            "        return locales",
            "",
            "    # get all supported placeholders with dummy values",
            "    def placeholders(self, item):",
            "        ctx = {}",
            "        for p in get_available_placeholders(self.request.event, MailSettingsForm.base_context[item]).values():",
            "            s = str(p.render_sample(self.request.event))",
            "            if s.strip().startswith('* '):",
            "                ctx[p.identifier] = '<div class=\"placeholder\" title=\"{}\">{}</div>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    markdown_compile_email(s)",
            "                )",
            "            else:",
            "                ctx[p.identifier] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    escape(s)",
            "                )",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        preview_item = request.POST.get('item', '')",
            "        if preview_item not in MailSettingsForm.base_context:",
            "            return HttpResponseBadRequest(_('invalid item'))",
            "",
            "        regex = r\"^\" + re.escape(preview_item) + r\"_(?P<idx>[\\d]+)$\"",
            "        msgs = {}",
            "        for k, v in request.POST.items():",
            "            # only accept allowed fields",
            "            matched = re.search(regex, k)",
            "            if matched is not None:",
            "                idx = matched.group('idx')",
            "                if idx in self.supported_locale:",
            "                    with language(self.supported_locale[idx], self.request.event.settings.region):",
            "                        try:",
            "                            if k.startswith('mail_subject_'):",
            "                                msgs[self.supported_locale[idx]] = format_map(",
            "                                    bleach.clean(v), self.placeholders(preview_item), raise_on_missing=True",
            "                                )",
            "                            else:",
            "                                msgs[self.supported_locale[idx]] = markdown_compile_email(",
            "                                    format_map(v, self.placeholders(preview_item), raise_on_missing=True)",
            "                                )",
            "                        except ValueError:",
            "                            msgs[self.supported_locale[idx]] = '<div class=\"alert alert-danger\">{}</div>'.format(",
            "                                PlaceholderValidator.error_message)",
            "                        except KeyError as e:",
            "                            msgs[self.supported_locale[idx]] = '<div class=\"alert alert-danger\">{}</div>'.format(",
            "                                _('Invalid placeholder: {%(value)s}') % {'value': e.args[0]})",
            "",
            "        return JsonResponse({",
            "            'item': preview_item,",
            "            'msgs': msgs",
            "        })",
            "",
            "",
            "class MailSettingsRendererPreview(MailSettingsPreview):",
            "    permission = 'can_change_event_settings'",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        return HttpResponse(status=405)",
            "",
            "    # get all supported placeholders with dummy values",
            "    def placeholders(self, item):",
            "        ctx = {}",
            "        for p in get_available_placeholders(self.request.event, MailSettingsForm.base_context[item]).values():",
            "            ctx[p.identifier] = escape(str(p.render_sample(self.request.event)))",
            "        return ctx",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        v = str(request.event.settings.mail_text_order_placed)",
            "        v = format_map(v, self.placeholders('mail_text_order_placed'))",
            "        renderers = request.event.get_html_mail_renderers()",
            "        if request.GET.get('renderer') in renderers:",
            "            with rolledback_transaction():",
            "                order = request.event.orders.create(",
            "                    status=Order.STATUS_PENDING, datetime=now(),",
            "                    expires=now(), code=\"PREVIEW\", total=119,",
            "                    sales_channel=request.organizer.sales_channels.get(identifier=\"web\")",
            "                )",
            "                item = request.event.items.create(name=gettext(\"Sample product\"), default_price=42.23,",
            "                                                  description=gettext(\"Sample product description\"))",
            "                order.positions.create(item=item, attendee_name_parts={'_legacy': gettext(\"John Doe\")},",
            "                                       price=item.default_price, subevent=request.event.subevents.last())",
            "                v = renderers[request.GET.get('renderer')].render(",
            "                    v,",
            "                    str(request.event.settings.mail_text_signature),",
            "                    gettext('Your order: %(code)s') % {'code': order.code},",
            "                    order,",
            "                    position=None",
            "                )",
            "                r = HttpResponse(v, content_type='text/html')",
            "                r._csp_ignore = True",
            "                return r",
            "        else:",
            "            raise Http404(_('Unknown e-mail renderer.'))",
            "",
            "",
            "class TicketSettingsPreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    @cached_property",
            "    def output(self):",
            "        responses = register_ticket_outputs.send(self.request.event)",
            "        for receiver, response in responses:",
            "            provider = response(self.request.event)",
            "            if provider.identifier == self.kwargs.get('output'):",
            "                return provider",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        if not self.output:",
            "            messages.error(request, _('You requested an invalid ticket output type.'))",
            "            return redirect(self.get_error_url())",
            "",
            "        fname, mimet, data = tickets.preview(self.request.event.pk, self.output.identifier)",
            "        resp = HttpResponse(data, content_type=mimet)",
            "        ftype = fname.split(\".\")[-1]",
            "        resp['Content-Disposition'] = 'attachment; filename=\"ticket-preview.{}\"'.format(ftype)",
            "        return resp",
            "",
            "    def get_error_url(self) -> str:",
            "        return reverse('control:event.settings.tickets', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class TicketSettings(EventSettingsViewMixin, EventPermissionRequiredMixin, FormView):",
            "    model = Event",
            "    form_class = TicketSettingsForm",
            "    template_name = 'pretixcontrol/event/tickets.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['providers'] = self.provider_forms",
            "",
            "        context['any_enabled'] = False",
            "        responses = register_ticket_outputs.send(self.request.event)",
            "        for receiver, response in responses:",
            "            provider = response(self.request.event)",
            "            if provider.is_enabled:",
            "                context['any_enabled'] = True",
            "                break",
            "",
            "        return context",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tickets', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['obj'] = self.request.event",
            "        return kwargs",
            "",
            "    def get_form(self, form_class=None):",
            "        form = super().get_form(form_class)",
            "        form.prepare_fields()",
            "        return form",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        success = True",
            "        for provider in self.provider_forms:",
            "            if provider.form.is_valid():",
            "                provider.form.save()",
            "                if provider.form.has_changed():",
            "                    self.request.event.log_action(",
            "                        'pretix.event.tickets.provider.' + provider.identifier, user=self.request.user, data={",
            "                            k: (provider.form.cleaned_data.get(k).name",
            "                                if isinstance(provider.form.cleaned_data.get(k), File)",
            "                                else provider.form.cleaned_data.get(k))",
            "                            for k in provider.form.changed_data",
            "                        }",
            "                    )",
            "                    tickets.invalidate_cache.apply_async(kwargs={'event': self.request.event.pk, 'provider': provider.identifier})",
            "            else:",
            "                success = False",
            "        form = self.get_form(self.get_form_class())",
            "        if success and form.is_valid():",
            "            form.save()",
            "            if form.has_changed():",
            "                self.request.event.log_action(",
            "                    'pretix.event.tickets.settings', user=self.request.user, data={",
            "                        k: form.cleaned_data.get(k) for k in form.changed_data",
            "                    }",
            "                )",
            "",
            "            messages.success(self.request, _('Your changes have been saved.'))",
            "            return redirect(self.get_success_url())",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    @cached_property",
            "    def provider_forms(self) -> list:",
            "        providers = []",
            "        responses = register_ticket_outputs.send(self.request.event)",
            "        for receiver, response in responses:",
            "            provider = response(self.request.event)",
            "            provider.form = ProviderForm(",
            "                obj=self.request.event,",
            "                settingspref='ticketoutput_%s_' % provider.identifier,",
            "                data=(self.request.POST if self.request.method == 'POST' else None),",
            "                files=(self.request.FILES if self.request.method == 'POST' else None)",
            "            )",
            "            provider.form.fields = OrderedDict(",
            "                [",
            "                    ('ticketoutput_%s_%s' % (provider.identifier, k), v)",
            "                    for k, v in provider.settings_form_fields.items()",
            "                ]",
            "            )",
            "            provider.settings_content = provider.settings_content_render(self.request)",
            "            provider.form.prepare_fields()",
            "",
            "            provider.evaluated_preview_allowed = True",
            "            if not provider.preview_allowed:",
            "                provider.evaluated_preview_allowed = False",
            "            else:",
            "                for k, v in provider.settings_form_fields.items():",
            "                    if v.required and not self.request.event.settings.get('ticketoutput_%s_%s' % (provider.identifier, k)):",
            "                        provider.evaluated_preview_allowed = False",
            "                        break",
            "",
            "            providers.append(provider)",
            "        return providers",
            "",
            "",
            "class EventPermissions(EventSettingsViewMixin, EventPermissionRequiredMixin, TemplateView):",
            "    template_name = 'pretixcontrol/event/permissions.html'",
            "",
            "",
            "class EventLive(EventPermissionRequiredMixin, TemplateView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/live.html'",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['issues'] = self.request.event.live_issues",
            "        ctx['actual_orders'] = self.request.event.orders.filter(testmode=False).exists()",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        if request.POST.get(\"live\") == \"true\" and not self.request.event.live_issues:",
            "            with transaction.atomic():",
            "                request.event.live = True",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.live.activated', user=self.request.user, data={}",
            "                )",
            "            messages.success(self.request, _('Your shop is live now!'))",
            "        elif request.POST.get(\"live\") == \"false\":",
            "            with transaction.atomic():",
            "                request.event.live = False",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.live.deactivated', user=self.request.user, data={}",
            "                )",
            "            messages.success(self.request, _('We\\'ve taken your shop down. You can re-enable it whenever you want!'))",
            "        elif request.POST.get(\"testmode\") == \"true\":",
            "            with transaction.atomic():",
            "                request.event.testmode = True",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.testmode.activated', user=self.request.user, data={}",
            "                )",
            "            messages.success(self.request, _('Your shop is now in test mode!'))",
            "        elif request.POST.get(\"testmode\") == \"false\":",
            "            with transaction.atomic():",
            "                request.event.testmode = False",
            "                request.event.save()",
            "                self.request.event.log_action(",
            "                    'pretix.event.testmode.deactivated', user=self.request.user, data={",
            "                        'delete': (request.POST.get(\"delete\") == \"yes\")",
            "                    }",
            "                )",
            "            request.event.cache.delete('complain_testmode_orders')",
            "            if request.POST.get(\"delete\") == \"yes\":",
            "                try:",
            "                    with transaction.atomic():",
            "                        for order in request.event.orders.filter(testmode=True):",
            "                            order.gracefully_delete(user=self.request.user)",
            "                except ProtectedError:",
            "                    messages.error(self.request, _('An order could not be deleted as some constraints (e.g. data '",
            "                                                   'created by plug-ins) do not allow it.'))",
            "                else:",
            "                    request.event.cache.set('complain_testmode_orders', False, 30)",
            "            request.event.cartposition_set.filter(addon_to__isnull=False).delete()",
            "            request.event.cartposition_set.all().delete()",
            "            messages.success(self.request, _('We\\'ve disabled test mode for you. Let\\'s sell some real tickets!'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.live', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class EventTransferSession(EventPermissionRequiredMixin, TemplateView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/transfer_session.html'",
            "",
            "",
            "class EventDelete(RecentAuthenticationRequiredMixin, EventPermissionRequiredMixin, FormView):",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixcontrol/event/delete.html'",
            "    form_class = EventDeleteForm",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        if not self.request.event.allow_delete():",
            "            messages.error(self.request, _('This event can not be deleted.'))",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "        return super().post(request, *args, **kwargs)",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        return kwargs",
            "",
            "    def form_valid(self, form):",
            "        try:",
            "            with transaction.atomic():",
            "                self.request.organizer.log_action(",
            "                    'pretix.event.deleted', user=self.request.user,",
            "                    data={",
            "                        'event_id': self.request.event.pk,",
            "                        'name': str(self.request.event.name),",
            "                        'slug': self.request.event.slug,",
            "                        'logentries': list(self.request.event.logentry_set.values_list('pk', flat=True))",
            "                    }",
            "                )",
            "                self.request.event.delete_sub_objects()",
            "                self.request.event.delete()",
            "            messages.success(self.request, _('The event has been deleted.'))",
            "            return redirect(self.get_success_url())",
            "        except ProtectedError as e:",
            "            err = gettext('The event could not be deleted as some constraints (e.g. data created by plug-ins) do not allow it.')",
            "",
            "            app_labels = set()",
            "            for e in e.protected_objects:",
            "                app_labels.add(type(e)._meta.app_label)",
            "",
            "            plugin_names = []",
            "            for app_label in app_labels:",
            "                app = apps.get_app_config(app_label)",
            "                if hasattr(app, 'PretixPluginMeta'):",
            "                    plugin_names.append(str(app.PretixPluginMeta.name))",
            "                else:",
            "                    plugin_names.append(str(app.verbose_name))",
            "",
            "            if plugin_names:",
            "                err += ' ' + gettext(",
            "                    'Specifically, the following plugins still contain data depends on this event: {plugin_names}'",
            "                ).format(plugin_names=', '.join(plugin_names))",
            "",
            "            messages.error(self.request, err)",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:index')",
            "",
            "",
            "class EventLog(EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    template_name = 'pretixcontrol/event/logs.html'",
            "    model = LogEntry",
            "    context_object_name = 'logs'",
            "",
            "    def get_queryset(self):",
            "        qs = self.request.event.logentry_set.all().select_related(",
            "            'user', 'content_type', 'api_token', 'oauth_application', 'device'",
            "        ).order_by('-datetime', '-pk')",
            "        qs = qs.exclude(action_type__in=OVERVIEW_BANLIST)",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event, 'can_view_orders',",
            "                                                      request=self.request):",
            "            qs = qs.exclude(content_type=ContentType.objects.get_for_model(Order))",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event, 'can_view_vouchers',",
            "                                                      request=self.request):",
            "            qs = qs.exclude(content_type=ContentType.objects.get_for_model(Voucher))",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event,",
            "                                                      'can_change_event_settings', request=self.request):",
            "            allowed_types = [",
            "                ContentType.objects.get_for_model(Voucher),",
            "                ContentType.objects.get_for_model(Order)",
            "            ]",
            "            if self.request.user.has_event_permission(self.request.organizer, self.request.event,",
            "                                                      'can_change_items', request=self.request):",
            "                allowed_types += [",
            "                    ContentType.objects.get_for_model(Item),",
            "                    ContentType.objects.get_for_model(ItemCategory),",
            "                    ContentType.objects.get_for_model(Quota),",
            "                    ContentType.objects.get_for_model(Question),",
            "                ]",
            "            qs = qs.filter(content_type__in=allowed_types)",
            "",
            "        if self.request.GET.get('user') == 'yes':",
            "            qs = qs.filter(user__isnull=False)",
            "        elif self.request.GET.get('user') == 'no':",
            "            qs = qs.filter(user__isnull=True)",
            "        elif self.request.GET.get('user', '').startswith('d-'):",
            "            qs = qs.filter(device_id=self.request.GET.get('user')[2:])",
            "        elif self.request.GET.get('user'):",
            "            qs = qs.filter(user_id=self.request.GET.get('user'))",
            "",
            "        if self.request.GET.get('action_type'):",
            "            qs = qs.filter(action_type=self.request.GET['action_type'])",
            "",
            "        if self.request.GET.get('content_type'):",
            "            qs = qs.filter(content_type=get_object_or_404(ContentType, pk=self.request.GET.get('content_type')))",
            "",
            "            if self.request.GET.get('object'):",
            "                qs = qs.filter(object_id=self.request.GET.get('object'))",
            "",
            "        return qs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        ctx['userlist'] = self.request.event.logentry_set.order_by().distinct().values('user__id', 'user__email')",
            "        ctx['devicelist'] = self.request.event.logentry_set.order_by('device__name').distinct().values('device__id', 'device__name')",
            "        return ctx",
            "",
            "",
            "class EventComment(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_event_settings'",
            "",
            "    def post(self, *args, **kwargs):",
            "        form = CommentForm(self.request.POST)",
            "        if form.is_valid():",
            "            self.request.event.comment = form.cleaned_data.get('comment')",
            "            self.request.event.save()",
            "            self.request.event.log_action('pretix.event.comment', user=self.request.user, data={",
            "                'new_comment': form.cleaned_data.get('comment')",
            "            })",
            "            messages.success(self.request, _('The comment has been updated.'))",
            "        else:",
            "            messages.error(self.request, _('Could not update the comment.'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get(self, *args, **kwargs):",
            "        return HttpResponseNotAllowed(['POST'])",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.index', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug",
            "        })",
            "",
            "",
            "class TaxList(EventSettingsViewMixin, EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    model = TaxRule",
            "    context_object_name = 'taxrules'",
            "    template_name = 'pretixcontrol/event/tax_index.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_queryset(self):",
            "        return self.request.event.tax_rules.all()",
            "",
            "",
            "class TaxCreate(EventSettingsViewMixin, EventPermissionRequiredMixin, CreateView):",
            "    model = TaxRule",
            "    form_class = TaxRuleForm",
            "    template_name = 'pretixcontrol/event/tax_edit.html'",
            "    permission = 'can_change_event_settings'",
            "    context_object_name = 'taxrule'",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tax', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_initial(self):",
            "        return {",
            "            'name': LazyI18nString.from_gettext(gettext('VAT'))",
            "        }",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        self.object = None",
            "        form = self.get_form()",
            "        if form.is_valid() and self.formset.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    @cached_property",
            "    def formset(self):",
            "        return TaxRuleLineFormSet(",
            "            data=self.request.POST if self.request.method == \"POST\" else None,",
            "            event=self.request.event,",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['formset'] = self.formset",
            "        return ctx",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        form.instance.event = self.request.event",
            "        form.instance.custom_rules = json.dumps([",
            "            f.cleaned_data for f in self.formset.ordered_forms if f not in self.formset.deleted_forms",
            "        ], cls=I18nJSONEncoder)",
            "        messages.success(self.request, _('The new tax rule has been created.'))",
            "        ret = super().form_valid(form)",
            "        form.instance.log_action('pretix.event.taxrule.added', user=self.request.user, data=dict(form.cleaned_data))",
            "        return ret",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "",
            "class TaxUpdate(EventSettingsViewMixin, EventPermissionRequiredMixin, UpdateView):",
            "    model = TaxRule",
            "    form_class = TaxRuleForm",
            "    template_name = 'pretixcontrol/event/tax_edit.html'",
            "    permission = 'can_change_event_settings'",
            "    context_object_name = 'rule'",
            "",
            "    def get_object(self, queryset=None) -> TaxRule:",
            "        try:",
            "            return self.request.event.tax_rules.get(",
            "                id=self.kwargs['rule']",
            "            )",
            "        except TaxRule.DoesNotExist:",
            "            raise Http404(_(\"The requested tax rule does not exist.\"))",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        self.object = self.get_object(self.get_queryset())",
            "        form = self.get_form()",
            "        if form.is_valid() and self.formset.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    @cached_property",
            "    def formset(self):",
            "        return TaxRuleLineFormSet(",
            "            data=self.request.POST if self.request.method == \"POST\" else None,",
            "            event=self.request.event,",
            "            initial=json.loads(self.object.custom_rules) if self.object.custom_rules else []",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['formset'] = self.formset",
            "        return ctx",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        form.instance.custom_rules = json.dumps([",
            "            f.cleaned_data for f in self.formset.ordered_forms if f not in self.formset.deleted_forms",
            "        ], cls=I18nJSONEncoder)",
            "        if form.has_changed():",
            "            self.object.log_action(",
            "                'pretix.event.taxrule.changed', user=self.request.user, data={",
            "                    k: form.cleaned_data.get(k) for k in form.changed_data",
            "                }",
            "            )",
            "        return super().form_valid(form)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tax', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "",
            "class TaxDelete(EventSettingsViewMixin, EventPermissionRequiredMixin, CompatDeleteView):",
            "    model = TaxRule",
            "    template_name = 'pretixcontrol/event/tax_delete.html'",
            "    permission = 'can_change_event_settings'",
            "    context_object_name = 'taxrule'",
            "",
            "    def get_object(self, queryset=None) -> TaxRule:",
            "        try:",
            "            return self.request.event.tax_rules.get(",
            "                id=self.kwargs['rule']",
            "            )",
            "        except TaxRule.DoesNotExist:",
            "            raise Http404(_(\"The requested tax rule does not exist.\"))",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "        if self.object.allow_delete():",
            "            self.object.log_action(action='pretix.event.taxrule.deleted', user=request.user)",
            "            self.object.delete()",
            "            messages.success(self.request, _('The selected tax rule has been deleted.'))",
            "        else:",
            "            messages.error(self.request, _('The selected tax rule can not be deleted.'))",
            "        return redirect(success_url)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.settings.tax', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_context_data(self, *args, **kwargs) -> dict:",
            "        context = super().get_context_data(*args, **kwargs)",
            "        context['possible'] = self.object.allow_delete()",
            "        return context",
            "",
            "",
            "class WidgetSettings(EventSettingsViewMixin, EventPermissionRequiredMixin, FormView):",
            "    template_name = 'pretixcontrol/event/widget.html'",
            "    permission = 'can_change_event_settings'",
            "    form_class = WidgetCodeForm",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        return kwargs",
            "",
            "    def form_valid(self, form):",
            "        ctx = self.get_context_data()",
            "        ctx['form'] = form",
            "        ctx['valid'] = True",
            "        return self.render_to_response(ctx)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['urlprefix'] = settings.SITE_URL",
            "        domain = get_event_domain(self.request.event, fallback=True)",
            "        if domain:",
            "            siteurlsplit = urlsplit(settings.SITE_URL)",
            "            if siteurlsplit.port and siteurlsplit.port not in (80, 443):",
            "                domain = '%s:%d' % (domain, siteurlsplit.port)",
            "            ctx['urlprefix'] = '%s://%s' % (siteurlsplit.scheme, domain)",
            "        return ctx",
            "",
            "",
            "class QuickSetupView(FormView):",
            "    template_name = 'pretixcontrol/event/quick_setup.html'",
            "    permission = 'can_change_event_settings'",
            "    form_class = QuickSetupForm",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if request.event.items.exists() or request.event.quotas.exists():",
            "            messages.info(request, _('Your event is not empty, you need to set it up manually.'))",
            "            return redirect(reverse('control:event.index', kwargs={",
            "                'organizer': request.event.organizer.slug,",
            "                'event': request.event.slug",
            "            }))",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        return kwargs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        ctx['formset'] = self.formset",
            "        return ctx",
            "",
            "    def get_initial(self):",
            "        return {",
            "            'waiting_list_enabled': True,",
            "            'ticket_download': True,",
            "            'contact_mail': self.request.event.settings.contact_mail,",
            "            'imprint_url': self.request.event.settings.imprint_url,",
            "        }",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        form = self.get_form()",
            "        if form.is_valid() and self.formset.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "            return self.form_invalid(form)",
            "",
            "    @transaction.atomic",
            "    def form_valid(self, form):",
            "        plugins_active = self.request.event.get_plugins()",
            "        if form.cleaned_data['ticket_download']:",
            "            if 'pretix.plugins.ticketoutputpdf' not in plugins_active:",
            "                self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                              data={'plugin': 'pretix.plugins.ticketoutputpdf'})",
            "                plugins_active.append('pretix.plugins.ticketoutputpdf')",
            "",
            "            self.request.event.settings.ticket_download = True",
            "            self.request.event.settings.ticketoutput_pdf__enabled = True",
            "",
            "            try:",
            "                import pretix_passbook  # noqa",
            "            except ImportError:",
            "                pass",
            "            else:",
            "                if 'pretix_passbook' not in plugins_active:",
            "                    self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                                  data={'plugin': 'pretix_passbook'})",
            "                    plugins_active.append('pretix_passbook')",
            "                self.request.event.settings.ticketoutput_passbook__enabled = True",
            "",
            "        if form.cleaned_data['payment_banktransfer__enabled']:",
            "            if 'pretix.plugins.banktransfer' not in plugins_active:",
            "                self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                              data={'plugin': 'pretix.plugins.banktransfer'})",
            "                plugins_active.append('pretix.plugins.banktransfer')",
            "            self.request.event.settings.payment_banktransfer__enabled = True",
            "            for f in ('bank_details', 'bank_details_type', 'bank_details_sepa_name', 'bank_details_sepa_iban',",
            "                      'bank_details_sepa_bic', 'bank_details_sepa_bank'):",
            "                self.request.event.settings.set(",
            "                    'payment_banktransfer_%s' % f,",
            "                    form.cleaned_data['payment_banktransfer_%s' % f]",
            "                )",
            "",
            "        if form.cleaned_data.get('payment_stripe__enabled', None):",
            "            if 'pretix.plugins.stripe' not in plugins_active:",
            "                self.request.event.log_action('pretix.event.plugins.enabled', user=self.request.user,",
            "                                              data={'plugin': 'pretix.plugins.stripe'})",
            "                plugins_active.append('pretix.plugins.stripe')",
            "",
            "        self.request.event.settings.show_quota_left = form.cleaned_data['show_quota_left']",
            "        self.request.event.settings.waiting_list_enabled = form.cleaned_data['waiting_list_enabled']",
            "        self.request.event.settings.attendee_names_required = form.cleaned_data['attendee_names_required']",
            "        self.request.event.settings.contact_mail = form.cleaned_data['contact_mail']",
            "        self.request.event.settings.imprint_url = form.cleaned_data['imprint_url']",
            "        self.request.event.log_action('pretix.event.settings', user=self.request.user, data={",
            "            k: self.request.event.settings.get(k) for k in form.changed_data",
            "        })",
            "",
            "        items = []",
            "        category = None",
            "        tax_rule = self.request.event.tax_rules.first()",
            "        if any(f not in self.formset.deleted_forms for f in self.formset):",
            "            category = self.request.event.categories.create(",
            "                name=LazyI18nString.from_gettext(gettext('Tickets'))",
            "            )",
            "            category.log_action('pretix.event.category.added', data={'name': gettext('Tickets')},",
            "                                user=self.request.user)",
            "",
            "        subevent = self.request.event.subevents.first()",
            "        for i, f in enumerate(self.formset):",
            "            if f in self.formset.deleted_forms or not f.has_changed():",
            "                continue",
            "",
            "            item = self.request.event.items.create(",
            "                name=f.cleaned_data['name'],",
            "                category=category,",
            "                active=True,",
            "                default_price=f.cleaned_data['default_price'] or 0,",
            "                tax_rule=tax_rule,",
            "                admission=True,",
            "                personalized=True,",
            "                position=i,",
            "                all_sales_channels=True,",
            "            )",
            "            item.log_action('pretix.event.item.added', user=self.request.user, data=dict(f.cleaned_data))",
            "            if f.cleaned_data['quota'] or not form.cleaned_data['total_quota']:",
            "                quota = self.request.event.quotas.create(",
            "                    name=str(f.cleaned_data['name']),",
            "                    subevent=subevent,",
            "                    size=f.cleaned_data['quota'],",
            "                )",
            "                quota.log_action('pretix.event.quota.added', user=self.request.user, data=dict(f.cleaned_data))",
            "                quota.items.add(item)",
            "            items.append(item)",
            "",
            "        if form.cleaned_data['total_quota']:",
            "            quota = self.request.event.quotas.create(",
            "                name=gettext('Tickets'),",
            "                size=form.cleaned_data['total_quota'],",
            "                subevent=subevent,",
            "            )",
            "            quota.log_action('pretix.event.quota.added', user=self.request.user, data={",
            "                'name': gettext('Tickets'),",
            "                'size': quota.size",
            "            })",
            "            quota.items.add(*items)",
            "",
            "        self.request.event.set_active_plugins(plugins_active, allow_restricted=plugins_active)",
            "        self.request.event.save()",
            "        messages.success(self.request, _('Your changes have been saved. You can now go on with looking at the details '",
            "                                         'or take your event live to start selling!'))",
            "",
            "        if form.cleaned_data.get('payment_stripe__enabled', False):",
            "            self.request.session['payment_stripe_oauth_enable'] = True",
            "            return redirect(StripeSettingsHolder(self.request.event).get_connect_url(self.request))",
            "",
            "        return redirect(reverse('control:event.index', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        }))",
            "",
            "    @cached_property",
            "    def formset(self):",
            "        return QuickSetupProductFormSet(",
            "            data=self.request.POST if self.request.method == \"POST\" else None,",
            "            event=self.request.event,",
            "            initial=[",
            "                {",
            "                    'name': LazyI18nString.from_gettext(gettext_noop('Regular ticket')),",
            "                    'default_price': Decimal('35.00'),",
            "                    'quota': 100,",
            "                },",
            "                {",
            "                    'name': LazyI18nString.from_gettext(gettext_noop('Reduced ticket')),",
            "                    'default_price': Decimal('29.00'),",
            "                    'quota': 50,",
            "                },",
            "            ] if self.request.method != \"POST\" else []",
            "        )",
            "",
            "",
            "class EventQRCode(EventPermissionRequiredMixin, View):",
            "    permission = None",
            "",
            "    def get(self, request, *args, filetype, **kwargs):",
            "        url = build_absolute_uri(request.event, 'presale:event.index')",
            "",
            "        if \"url\" in request.GET:",
            "            if url_has_allowed_host_and_scheme(request.GET[\"url\"], allowed_hosts=[urlparse(url).netloc]):",
            "                url = request.GET[\"url\"]",
            "            else:",
            "                raise PermissionDenied(\"Untrusted URL\")",
            "",
            "        qr = qrcode.QRCode(",
            "            version=1,",
            "            error_correction=qrcode.constants.ERROR_CORRECT_M,",
            "            box_size=10,",
            "            border=4,",
            "        )",
            "        qr.add_data(url)",
            "        qr.make(fit=True)",
            "",
            "        if filetype == 'svg':",
            "            factory = qrcode.image.svg.SvgPathImage",
            "            img = qr.make_image(image_factory=factory)",
            "            r = HttpResponse(img.to_string(), content_type='image/svg+xml')",
            "            r['Content-Disposition'] = f'inline; filename=\"qrcode-{request.event.slug}.{filetype}\"'",
            "            return r",
            "        elif filetype in ('jpeg', 'png', 'gif'):",
            "            img = qr.make_image(fill_color=\"black\", back_color=\"white\")",
            "",
            "            byte_io = BytesIO()",
            "            img.save(byte_io, filetype.upper())",
            "            byte_io.seek(0)",
            "            r = HttpResponse(byte_io.read(), content_type='image/' + filetype)",
            "            r['Content-Disposition'] = f'inline; filename=\"qrcode-{request.event.slug}.{filetype}\"'",
            "            return r"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "729": [
                "MailSettingsPreview",
                "placeholders"
            ],
            "779": [
                "MailSettingsRendererPreview",
                "placeholders"
            ]
        },
        "addLocation": []
    },
    "src/pretix/control/views/vouchers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " from django.shortcuts import redirect, render"
            },
            "1": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " from django.urls import resolve, reverse"
            },
            "2": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " from django.utils.functional import cached_property"
            },
            "3": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import format_html"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+from django.utils.html import format_html, escape"
            },
            "5": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " from django.utils.safestring import mark_safe"
            },
            "6": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " from django.utils.timezone import now"
            },
            "7": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " from django.utils.translation import gettext_lazy as _"
            },
            "8": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 562,
                "PatchRowcode": "             else:"
            },
            "9": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": 563,
                "PatchRowcode": "                 ctx[p.identifier] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format("
            },
            "10": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 564,
                "PatchRowcode": "                     _('This value will be replaced based on dynamic parameters.'),"
            },
            "11": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    s"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 565,
                "PatchRowcode": "+                    escape(s)"
            },
            "13": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "                 )"
            },
            "14": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 567,
                "PatchRowcode": "         return self.SafeDict(ctx)"
            },
            "15": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 568,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Mason Mohkami, Sohalt, Tobias Kunze,",
            "# jasonwaiting@live.hk, koebi",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import io",
            "from urllib.parse import urlencode",
            "",
            "import bleach",
            "from defusedcsv import csv",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.core.exceptions import PermissionDenied, ValidationError",
            "from django.db import connection, transaction",
            "from django.db.models import Exists, OuterRef, Sum",
            "from django.http import (",
            "    Http404, HttpResponse, HttpResponseBadRequest, HttpResponseRedirect,",
            "    JsonResponse,",
            ")",
            "from django.shortcuts import redirect, render",
            "from django.urls import resolve, reverse",
            "from django.utils.functional import cached_property",
            "from django.utils.html import format_html",
            "from django.utils.safestring import mark_safe",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext_lazy as _",
            "from django.views.generic import (",
            "    CreateView, ListView, TemplateView, UpdateView, View,",
            ")",
            "from django_scopes import scopes_disabled",
            "",
            "from pretix.base.email import get_available_placeholders",
            "from pretix.base.models import (",
            "    CartPosition, LogEntry, Voucher, WaitingListEntry,",
            ")",
            "from pretix.base.models.vouchers import generate_codes",
            "from pretix.base.services.vouchers import vouchers_send",
            "from pretix.base.templatetags.rich_text import markdown_compile_email",
            "from pretix.base.views.tasks import AsyncFormView",
            "from pretix.control.forms.filter import VoucherFilterForm, VoucherTagFilterForm",
            "from pretix.control.forms.vouchers import VoucherBulkForm, VoucherForm",
            "from pretix.control.permissions import EventPermissionRequiredMixin",
            "from pretix.control.signals import voucher_form_class",
            "from pretix.control.views import PaginationMixin",
            "from pretix.helpers.compat import CompatDeleteView",
            "from pretix.helpers.format import format_map",
            "from pretix.helpers.models import modelcopy",
            "from pretix.multidomain.urlreverse import build_absolute_uri",
            "",
            "",
            "class VoucherList(PaginationMixin, EventPermissionRequiredMixin, ListView):",
            "    model = Voucher",
            "    context_object_name = 'vouchers'",
            "    template_name = 'pretixcontrol/vouchers/index.html'",
            "    permission = 'can_view_vouchers'",
            "",
            "    @scopes_disabled()  # we have an event check here, and we can save some performance on subqueries",
            "    def get_queryset(self):",
            "        qs = Voucher.annotate_budget_used_orders(self.request.event.vouchers.exclude(",
            "            Exists(WaitingListEntry.objects.filter(voucher_id=OuterRef('pk')))",
            "        ).select_related(",
            "            'item', 'variation', 'seat'",
            "        ))",
            "        if self.filter_form.is_valid():",
            "            qs = self.filter_form.filter_qs(qs)",
            "",
            "        return qs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['filter_form'] = self.filter_form",
            "        return ctx",
            "",
            "    @cached_property",
            "    def filter_form(self):",
            "        return VoucherFilterForm(data=self.request.GET, event=self.request.event)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        if request.GET.get(\"download\", \"\") == \"yes\":",
            "            return self._download_csv()",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def _download_csv(self):",
            "        output = io.StringIO()",
            "        writer = csv.writer(output, quoting=csv.QUOTE_NONNUMERIC, delimiter=\",\")",
            "",
            "        headers = [",
            "            _('Voucher code'), _('Valid until'), _('Product'), _('Reserve quota'), _('Bypass quota'),",
            "            _('Price effect'), _('Value'), _('Tag'), _('Redeemed'), _('Maximum usages'), _('Seat'),",
            "            _('Comment')",
            "        ]",
            "        writer.writerow(headers)",
            "",
            "        for v in self.get_queryset():",
            "            if v.item:",
            "                if v.variation:",
            "                    prod = '%s \u2013 %s' % (str(v.item), str(v.variation))",
            "                else:",
            "                    prod = '%s' % str(v.item)",
            "            elif v.quota:",
            "                prod = _('Any product in quota \"{quota}\"').format(quota=str(v.quota.name))",
            "            else:",
            "                prod = _('Any product')",
            "            row = [",
            "                v.code,",
            "                v.valid_until.isoformat() if v.valid_until else \"\",",
            "                prod,",
            "                _(\"Yes\") if v.block_quota else _(\"No\"),",
            "                _(\"Yes\") if v.allow_ignore_quota else _(\"No\"),",
            "                v.get_price_mode_display(),",
            "                str(v.value) if v.value is not None else \"\",",
            "                v.tag,",
            "                str(v.redeemed),",
            "                str(v.max_usages),",
            "                str(v.seat) if v.seat else \"\",",
            "                str(v.comment) if v.comment else \"\"",
            "            ]",
            "            writer.writerow(row)",
            "",
            "        r = HttpResponse(output.getvalue().encode(\"utf-8\"), content_type='text/csv')",
            "        r['Content-Disposition'] = 'attachment; filename=\"vouchers.csv\"'",
            "        return r",
            "",
            "",
            "class VoucherTags(EventPermissionRequiredMixin, TemplateView):",
            "    template_name = 'pretixcontrol/vouchers/tags.html'",
            "    permission = 'can_view_vouchers'",
            "",
            "    def get_queryset(self):",
            "        qs = self.request.event.vouchers.order_by('tag').filter(",
            "            tag__isnull=False,",
            "            waitinglistentries__isnull=True",
            "        )",
            "",
            "        if self.filter_form.is_valid():",
            "            qs = self.filter_form.filter_qs(qs)",
            "",
            "        qs = qs.values('tag').annotate(",
            "            total=Sum('max_usages'),",
            "            redeemed=Sum('redeemed')",
            "        )",
            "",
            "        return qs.distinct()",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "",
            "        tags = self.get_queryset()",
            "",
            "        for t in tags:",
            "            if t['total'] == 0:",
            "                t['percentage'] = 0",
            "            else:",
            "                t['percentage'] = int((t['redeemed'] / t['total']) * 100)",
            "",
            "        ctx['tags'] = tags",
            "        ctx['filter_form'] = self.filter_form",
            "        return ctx",
            "",
            "    @cached_property",
            "    def filter_form(self):",
            "        return VoucherTagFilterForm(data=self.request.GET, event=self.request.event)",
            "",
            "",
            "class VoucherDeleteCarts(EventPermissionRequiredMixin, CompatDeleteView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/delete_carts.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "",
            "    def get_object(self, queryset=None) -> Voucher:",
            "        try:",
            "            return self.request.event.vouchers.get(",
            "                id=self.kwargs['voucher']",
            "            )",
            "        except Voucher.DoesNotExist:",
            "            raise Http404(_(\"The requested voucher does not exist.\"))",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "",
            "        self.object.log_action('pretix.voucher.carts.deleted', user=self.request.user)",
            "        CartPosition.objects.filter(addon_to__voucher=self.object).delete()",
            "        self.object.cartposition_set.all().delete()",
            "        messages.success(request, _('The selected cart positions have been removed.'))",
            "        return HttpResponseRedirect(success_url)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "",
            "class VoucherDelete(EventPermissionRequiredMixin, CompatDeleteView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/delete.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "",
            "    def get_object(self, queryset=None) -> Voucher:",
            "        try:",
            "            return self.request.event.vouchers.get(",
            "                id=self.kwargs['voucher']",
            "            )",
            "        except Voucher.DoesNotExist:",
            "            raise Http404(_(\"The requested voucher does not exist.\"))",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        if not self.get_object().allow_delete():",
            "            messages.error(request, _('A voucher can not be deleted if it already has been redeemed.'))",
            "            return HttpResponseRedirect(self.get_success_url())",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "",
            "        if not self.object.allow_delete():",
            "            messages.error(request, _('A voucher can not be deleted if it already has been redeemed.'))",
            "        else:",
            "            self.object.log_action('pretix.voucher.deleted', user=self.request.user)",
            "            CartPosition.objects.filter(addon_to__voucher=self.object).delete()",
            "            self.object.cartposition_set.all().delete()",
            "            self.object.delete()",
            "            messages.success(request, _('The selected voucher has been deleted.'))",
            "        return HttpResponseRedirect(success_url)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "",
            "class VoucherUpdate(EventPermissionRequiredMixin, UpdateView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/detail.html'",
            "    permission = ('can_change_vouchers', 'can_view_vouchers')",
            "    context_object_name = 'voucher'",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def get_form_class(self):",
            "        form_class = VoucherForm",
            "        for receiver, response in voucher_form_class.send(self.request.event, cls=form_class):",
            "            if response:",
            "                form_class = response",
            "        return form_class",
            "",
            "    def get_form(self, form_class=None):",
            "        form = super().get_form(form_class)",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event, 'can_change_vouchers',",
            "                                                      request=self.request):",
            "            for f in form.fields.values():",
            "                f.disabled = True",
            "        return form",
            "",
            "    def get_object(self, queryset=None) -> VoucherForm:",
            "        url = resolve(self.request.path_info)",
            "        try:",
            "            return self.request.event.vouchers.get(",
            "                id=url.kwargs['voucher']",
            "            )",
            "        except Voucher.DoesNotExist:",
            "            raise Http404(_(\"The requested voucher does not exist.\"))",
            "",
            "    def form_valid(self, form):",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        if form.has_changed():",
            "            self.object.log_action(",
            "                'pretix.voucher.changed', user=self.request.user, data={",
            "                    k: form.cleaned_data.get(k) for k in form.changed_data",
            "                }",
            "            )",
            "        return super().form_valid(form)",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        if not request.user.has_event_permission(request.organizer, request.event, 'can_change_vouchers',",
            "                                                 request=request):",
            "            raise PermissionDenied()",
            "        return super().post(request, *args, **kwargs)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        redeemed_in_carts = CartPosition.objects.filter(",
            "            voucher=self.object, event=self.request.event,",
            "            expires__gte=now()",
            "        ).count()",
            "        ctx['redeemed_in_carts'] = redeemed_in_carts",
            "",
            "        url_params = {",
            "            'voucher': self.object.code",
            "        }",
            "        if self.object.subevent_id:",
            "            url_params['subevent'] = self.object.subevent_id",
            "        ctx['url'] = build_absolute_uri(self.request.event, \"presale:event.redeem\") + \"?\" + urlencode(url_params)",
            "        return ctx",
            "",
            "",
            "class VoucherCreate(EventPermissionRequiredMixin, CreateView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/detail.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def get_form_class(self):",
            "        form_class = VoucherForm",
            "        for receiver, response in voucher_form_class.send(self.request.event, cls=form_class):",
            "            if response:",
            "                form_class = response",
            "        return form_class",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['instance'] = Voucher(event=self.request.event)",
            "        return kwargs",
            "",
            "    def form_valid(self, form):",
            "        form.instance.event = self.request.event",
            "        ret = super().form_valid(form)",
            "        url = reverse('control:event.voucher', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "            'voucher': self.object.pk",
            "        })",
            "        messages.success(self.request, mark_safe(_('The new voucher has been created: {code}').format(",
            "            code=format_html('<a href=\"{url}\">{code}</a>', url=url, code=self.object.code)",
            "        )))",
            "        form.instance.log_action('pretix.voucher.added', data=dict(form.cleaned_data), user=self.request.user)",
            "        return ret",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        return super().post(request, *args, **kwargs)",
            "",
            "",
            "class VoucherGo(EventPermissionRequiredMixin, View):",
            "    permission = 'can_view_vouchers'",
            "",
            "    def get_voucher(self, code):",
            "        return Voucher.objects.get(code__iexact=code, event=self.request.event)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        code = request.GET.get(\"code\", \"\").strip()",
            "        try:",
            "            voucher = self.get_voucher(code)",
            "            return redirect('control:event.voucher', event=request.event.slug, organizer=request.event.organizer.slug,",
            "                            voucher=voucher.id)",
            "        except Voucher.DoesNotExist:",
            "            messages.error(request, _('There is no voucher with the given voucher code.'))",
            "            return redirect('control:event.vouchers', event=request.event.slug, organizer=request.event.organizer.slug)",
            "",
            "",
            "class VoucherBulkCreate(EventPermissionRequiredMixin, AsyncFormView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/bulk.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "    atomic_execute = True",
            "",
            "    def get_success_url(self, value) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_error_url(self):",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    @cached_property",
            "    def copy_from(self):",
            "        if self.request.GET.get(\"copy_from\") and not getattr(self, 'object', None):",
            "            try:",
            "                return self.request.event.vouchers.get(pk=self.request.GET.get(\"copy_from\"))",
            "            except Voucher.DoesNotExist:",
            "                pass",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "",
            "        if self.copy_from:",
            "            i = modelcopy(self.copy_from)",
            "            i.pk = None",
            "            i.redeemed = 0",
            "            kwargs['instance'] = i",
            "        else:",
            "            kwargs['instance'] = Voucher(event=self.request.event, code=None)",
            "        return kwargs",
            "",
            "    def get_async_form_kwargs(self, form_kwargs, organizer=None, event=None):",
            "        if not form_kwargs.get('instance'):",
            "            form_kwargs['instance'] = Voucher(event=self.request.event, code=None)",
            "        return form_kwargs",
            "",
            "    def async_form_valid(self, task, form):",
            "        batch_size = 500",
            "        total_num = 1  # will be set later",
            "",
            "        def set_progress(percent):",
            "            if not task.request.called_directly:",
            "                task.update_state(",
            "                    state='PROGRESS',",
            "                    meta={'value': percent}",
            "                )",
            "",
            "        def process_batch(batch_vouchers, voucherids):",
            "            Voucher.objects.bulk_create(batch_vouchers)",
            "            if not connection.features.can_return_rows_from_bulk_insert:",
            "                from_db = list(self.request.event.vouchers.filter(code__in=[v.code for v in batch_vouchers]))",
            "                batch_vouchers.clear()",
            "                batch_vouchers += from_db",
            "",
            "            log_entries = []",
            "            for v in batch_vouchers:",
            "                voucherids.append(v.pk)",
            "                data = dict(form.cleaned_data)",
            "                data['code'] = code",
            "                data['bulk'] = True",
            "                del data['codes']",
            "                log_entries.append(",
            "                    v.log_action('pretix.voucher.added', data=data, user=self.request.user, save=False)",
            "                )",
            "            LogEntry.objects.bulk_create(log_entries)",
            "            form.post_bulk_save(batch_vouchers)",
            "            batch_vouchers.clear()",
            "            set_progress(len(voucherids) / total_num * (50. if form.cleaned_data['send'] else 100.))",
            "",
            "        voucherids = []",
            "        if not form.is_valid():",
            "            raise ValidationError(form.errors)",
            "        total_num = len(form.cleaned_data['codes'])",
            "",
            "        batch_vouchers = []",
            "        for code in form.cleaned_data['codes']:",
            "            if len(batch_vouchers) >= batch_size:",
            "                process_batch(batch_vouchers, voucherids)",
            "",
            "            obj = modelcopy(form.instance, code=None)",
            "            obj.event = self.request.event",
            "            obj.code = code",
            "            try:",
            "                obj.seat = form.cleaned_data['seats'].pop()",
            "                obj.item = obj.seat.product",
            "            except IndexError:",
            "                pass",
            "            batch_vouchers.append(obj)",
            "",
            "        process_batch(batch_vouchers, voucherids)",
            "",
            "        if form.cleaned_data['send']:",
            "            vouchers_send(",
            "                event=self.request.event,",
            "                vouchers=voucherids,",
            "                subject=form.cleaned_data['send_subject'],",
            "                message=form.cleaned_data['send_message'],",
            "                recipients=[r._asdict() for r in form.cleaned_data['send_recipients']],",
            "                user=self.request.user.pk,",
            "                progress=lambda p: set_progress(50. + p * 50.)",
            "            )",
            "",
            "    def get_success_message(self, value):",
            "        return _('The new vouchers have been created.')",
            "",
            "    def get_form_class(self):",
            "        form_class = VoucherBulkForm",
            "        for receiver, response in voucher_form_class.send(self.request.event, cls=form_class):",
            "            if response:",
            "                form_class = response",
            "        return form_class",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['code_length'] = settings.ENTROPY['voucher_code']",
            "        return ctx",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    @transaction.atomic()",
            "    def post(self, request, *args, **kwargs):",
            "        return super().post(request, *args, **kwargs)",
            "",
            "",
            "class VoucherBulkMailPreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_vouchers'",
            "",
            "    # return the origin text if key is missing in dict",
            "    class SafeDict(dict):",
            "        def __missing__(self, key):",
            "            return '{' + key + '}'",
            "",
            "    # get all supported placeholders with dummy values",
            "    def placeholders(self, item):",
            "        ctx = {}",
            "        base_ctx = ['event', 'name']",
            "        if item == 'send_message':",
            "            base_ctx += ['voucher_list']",
            "        for p in get_available_placeholders(self.request.event, base_ctx).values():",
            "            s = str(p.render_sample(self.request.event))",
            "            if s.strip().startswith('* ') or s.startswith('  '):",
            "                ctx[p.identifier] = '<div class=\"placeholder\" title=\"{}\">{}</div>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    markdown_compile_email(s)",
            "                )",
            "            else:",
            "                ctx[p.identifier] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    s",
            "                )",
            "        return self.SafeDict(ctx)",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        preview_item = request.POST.get('item', '')",
            "        if preview_item not in ('send_message', 'send_subject'):",
            "            return HttpResponseBadRequest(_('invalid item'))",
            "        msgs = {}",
            "        if \"subject\" in preview_item:",
            "            msgs[\"all\"] = format_map(bleach.clean(request.POST.get(preview_item, \"\")), self.placeholders(preview_item))",
            "        else:",
            "            msgs[\"all\"] = markdown_compile_email(",
            "                format_map(request.POST.get(preview_item), self.placeholders(preview_item))",
            "            )",
            "",
            "        return JsonResponse({",
            "            'item': preview_item,",
            "            'msgs': msgs",
            "        })",
            "",
            "",
            "class VoucherRNG(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_vouchers'",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        try:",
            "            num = int(request.GET.get('num', '5'))",
            "            if num > 100_000:",
            "                return HttpResponseBadRequest()",
            "        except ValueError:  # NOQA",
            "            return HttpResponseBadRequest()",
            "",
            "        prefix = request.GET.get('prefix')",
            "        codes = generate_codes(request.organizer, num, prefix=prefix)",
            "        return JsonResponse({",
            "            'codes': codes",
            "        })",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "",
            "class VoucherBulkAction(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_vouchers'",
            "",
            "    @cached_property",
            "    def objects(self):",
            "        return self.request.event.vouchers.filter(",
            "            id__in=self.request.POST.getlist('voucher')",
            "        )",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        if request.POST.get('action') == 'delete':",
            "            return render(request, 'pretixcontrol/vouchers/delete_bulk.html', {",
            "                'allowed': self.objects.filter(redeemed=0),",
            "                'forbidden': self.objects.exclude(redeemed=0),",
            "            })",
            "        elif request.POST.get('action') == 'delete_confirm':",
            "            for obj in self.objects:",
            "                if obj.allow_delete():",
            "                    obj.log_action('pretix.voucher.deleted', user=self.request.user)",
            "                    CartPosition.objects.filter(addon_to__voucher=obj).delete()",
            "                    obj.cartposition_set.all().delete()",
            "                    obj.delete()",
            "                else:",
            "                    obj.log_action('pretix.voucher.changed', user=self.request.user, data={",
            "                        'max_usages': min(obj.redeemed, obj.max_usages),",
            "                        'bulk': True",
            "                    })",
            "                    obj.max_usages = min(obj.redeemed, obj.max_usages)",
            "                    obj.save(update_fields=['max_usages'])",
            "            messages.success(request, _('The selected vouchers have been deleted or disabled.'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })"
        ],
        "afterPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Mason Mohkami, Sohalt, Tobias Kunze,",
            "# jasonwaiting@live.hk, koebi",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import io",
            "from urllib.parse import urlencode",
            "",
            "import bleach",
            "from defusedcsv import csv",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.core.exceptions import PermissionDenied, ValidationError",
            "from django.db import connection, transaction",
            "from django.db.models import Exists, OuterRef, Sum",
            "from django.http import (",
            "    Http404, HttpResponse, HttpResponseBadRequest, HttpResponseRedirect,",
            "    JsonResponse,",
            ")",
            "from django.shortcuts import redirect, render",
            "from django.urls import resolve, reverse",
            "from django.utils.functional import cached_property",
            "from django.utils.html import format_html, escape",
            "from django.utils.safestring import mark_safe",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext_lazy as _",
            "from django.views.generic import (",
            "    CreateView, ListView, TemplateView, UpdateView, View,",
            ")",
            "from django_scopes import scopes_disabled",
            "",
            "from pretix.base.email import get_available_placeholders",
            "from pretix.base.models import (",
            "    CartPosition, LogEntry, Voucher, WaitingListEntry,",
            ")",
            "from pretix.base.models.vouchers import generate_codes",
            "from pretix.base.services.vouchers import vouchers_send",
            "from pretix.base.templatetags.rich_text import markdown_compile_email",
            "from pretix.base.views.tasks import AsyncFormView",
            "from pretix.control.forms.filter import VoucherFilterForm, VoucherTagFilterForm",
            "from pretix.control.forms.vouchers import VoucherBulkForm, VoucherForm",
            "from pretix.control.permissions import EventPermissionRequiredMixin",
            "from pretix.control.signals import voucher_form_class",
            "from pretix.control.views import PaginationMixin",
            "from pretix.helpers.compat import CompatDeleteView",
            "from pretix.helpers.format import format_map",
            "from pretix.helpers.models import modelcopy",
            "from pretix.multidomain.urlreverse import build_absolute_uri",
            "",
            "",
            "class VoucherList(PaginationMixin, EventPermissionRequiredMixin, ListView):",
            "    model = Voucher",
            "    context_object_name = 'vouchers'",
            "    template_name = 'pretixcontrol/vouchers/index.html'",
            "    permission = 'can_view_vouchers'",
            "",
            "    @scopes_disabled()  # we have an event check here, and we can save some performance on subqueries",
            "    def get_queryset(self):",
            "        qs = Voucher.annotate_budget_used_orders(self.request.event.vouchers.exclude(",
            "            Exists(WaitingListEntry.objects.filter(voucher_id=OuterRef('pk')))",
            "        ).select_related(",
            "            'item', 'variation', 'seat'",
            "        ))",
            "        if self.filter_form.is_valid():",
            "            qs = self.filter_form.filter_qs(qs)",
            "",
            "        return qs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['filter_form'] = self.filter_form",
            "        return ctx",
            "",
            "    @cached_property",
            "    def filter_form(self):",
            "        return VoucherFilterForm(data=self.request.GET, event=self.request.event)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        if request.GET.get(\"download\", \"\") == \"yes\":",
            "            return self._download_csv()",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def _download_csv(self):",
            "        output = io.StringIO()",
            "        writer = csv.writer(output, quoting=csv.QUOTE_NONNUMERIC, delimiter=\",\")",
            "",
            "        headers = [",
            "            _('Voucher code'), _('Valid until'), _('Product'), _('Reserve quota'), _('Bypass quota'),",
            "            _('Price effect'), _('Value'), _('Tag'), _('Redeemed'), _('Maximum usages'), _('Seat'),",
            "            _('Comment')",
            "        ]",
            "        writer.writerow(headers)",
            "",
            "        for v in self.get_queryset():",
            "            if v.item:",
            "                if v.variation:",
            "                    prod = '%s \u2013 %s' % (str(v.item), str(v.variation))",
            "                else:",
            "                    prod = '%s' % str(v.item)",
            "            elif v.quota:",
            "                prod = _('Any product in quota \"{quota}\"').format(quota=str(v.quota.name))",
            "            else:",
            "                prod = _('Any product')",
            "            row = [",
            "                v.code,",
            "                v.valid_until.isoformat() if v.valid_until else \"\",",
            "                prod,",
            "                _(\"Yes\") if v.block_quota else _(\"No\"),",
            "                _(\"Yes\") if v.allow_ignore_quota else _(\"No\"),",
            "                v.get_price_mode_display(),",
            "                str(v.value) if v.value is not None else \"\",",
            "                v.tag,",
            "                str(v.redeemed),",
            "                str(v.max_usages),",
            "                str(v.seat) if v.seat else \"\",",
            "                str(v.comment) if v.comment else \"\"",
            "            ]",
            "            writer.writerow(row)",
            "",
            "        r = HttpResponse(output.getvalue().encode(\"utf-8\"), content_type='text/csv')",
            "        r['Content-Disposition'] = 'attachment; filename=\"vouchers.csv\"'",
            "        return r",
            "",
            "",
            "class VoucherTags(EventPermissionRequiredMixin, TemplateView):",
            "    template_name = 'pretixcontrol/vouchers/tags.html'",
            "    permission = 'can_view_vouchers'",
            "",
            "    def get_queryset(self):",
            "        qs = self.request.event.vouchers.order_by('tag').filter(",
            "            tag__isnull=False,",
            "            waitinglistentries__isnull=True",
            "        )",
            "",
            "        if self.filter_form.is_valid():",
            "            qs = self.filter_form.filter_qs(qs)",
            "",
            "        qs = qs.values('tag').annotate(",
            "            total=Sum('max_usages'),",
            "            redeemed=Sum('redeemed')",
            "        )",
            "",
            "        return qs.distinct()",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "",
            "        tags = self.get_queryset()",
            "",
            "        for t in tags:",
            "            if t['total'] == 0:",
            "                t['percentage'] = 0",
            "            else:",
            "                t['percentage'] = int((t['redeemed'] / t['total']) * 100)",
            "",
            "        ctx['tags'] = tags",
            "        ctx['filter_form'] = self.filter_form",
            "        return ctx",
            "",
            "    @cached_property",
            "    def filter_form(self):",
            "        return VoucherTagFilterForm(data=self.request.GET, event=self.request.event)",
            "",
            "",
            "class VoucherDeleteCarts(EventPermissionRequiredMixin, CompatDeleteView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/delete_carts.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "",
            "    def get_object(self, queryset=None) -> Voucher:",
            "        try:",
            "            return self.request.event.vouchers.get(",
            "                id=self.kwargs['voucher']",
            "            )",
            "        except Voucher.DoesNotExist:",
            "            raise Http404(_(\"The requested voucher does not exist.\"))",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "",
            "        self.object.log_action('pretix.voucher.carts.deleted', user=self.request.user)",
            "        CartPosition.objects.filter(addon_to__voucher=self.object).delete()",
            "        self.object.cartposition_set.all().delete()",
            "        messages.success(request, _('The selected cart positions have been removed.'))",
            "        return HttpResponseRedirect(success_url)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "",
            "class VoucherDelete(EventPermissionRequiredMixin, CompatDeleteView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/delete.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "",
            "    def get_object(self, queryset=None) -> Voucher:",
            "        try:",
            "            return self.request.event.vouchers.get(",
            "                id=self.kwargs['voucher']",
            "            )",
            "        except Voucher.DoesNotExist:",
            "            raise Http404(_(\"The requested voucher does not exist.\"))",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        if not self.get_object().allow_delete():",
            "            messages.error(request, _('A voucher can not be deleted if it already has been redeemed.'))",
            "            return HttpResponseRedirect(self.get_success_url())",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "",
            "        if not self.object.allow_delete():",
            "            messages.error(request, _('A voucher can not be deleted if it already has been redeemed.'))",
            "        else:",
            "            self.object.log_action('pretix.voucher.deleted', user=self.request.user)",
            "            CartPosition.objects.filter(addon_to__voucher=self.object).delete()",
            "            self.object.cartposition_set.all().delete()",
            "            self.object.delete()",
            "            messages.success(request, _('The selected voucher has been deleted.'))",
            "        return HttpResponseRedirect(success_url)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "",
            "class VoucherUpdate(EventPermissionRequiredMixin, UpdateView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/detail.html'",
            "    permission = ('can_change_vouchers', 'can_view_vouchers')",
            "    context_object_name = 'voucher'",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def get_form_class(self):",
            "        form_class = VoucherForm",
            "        for receiver, response in voucher_form_class.send(self.request.event, cls=form_class):",
            "            if response:",
            "                form_class = response",
            "        return form_class",
            "",
            "    def get_form(self, form_class=None):",
            "        form = super().get_form(form_class)",
            "        if not self.request.user.has_event_permission(self.request.organizer, self.request.event, 'can_change_vouchers',",
            "                                                      request=self.request):",
            "            for f in form.fields.values():",
            "                f.disabled = True",
            "        return form",
            "",
            "    def get_object(self, queryset=None) -> VoucherForm:",
            "        url = resolve(self.request.path_info)",
            "        try:",
            "            return self.request.event.vouchers.get(",
            "                id=url.kwargs['voucher']",
            "            )",
            "        except Voucher.DoesNotExist:",
            "            raise Http404(_(\"The requested voucher does not exist.\"))",
            "",
            "    def form_valid(self, form):",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        if form.has_changed():",
            "            self.object.log_action(",
            "                'pretix.voucher.changed', user=self.request.user, data={",
            "                    k: form.cleaned_data.get(k) for k in form.changed_data",
            "                }",
            "            )",
            "        return super().form_valid(form)",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        if not request.user.has_event_permission(request.organizer, request.event, 'can_change_vouchers',",
            "                                                 request=request):",
            "            raise PermissionDenied()",
            "        return super().post(request, *args, **kwargs)",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        redeemed_in_carts = CartPosition.objects.filter(",
            "            voucher=self.object, event=self.request.event,",
            "            expires__gte=now()",
            "        ).count()",
            "        ctx['redeemed_in_carts'] = redeemed_in_carts",
            "",
            "        url_params = {",
            "            'voucher': self.object.code",
            "        }",
            "        if self.object.subevent_id:",
            "            url_params['subevent'] = self.object.subevent_id",
            "        ctx['url'] = build_absolute_uri(self.request.event, \"presale:event.redeem\") + \"?\" + urlencode(url_params)",
            "        return ctx",
            "",
            "",
            "class VoucherCreate(EventPermissionRequiredMixin, CreateView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/detail.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def get_form_class(self):",
            "        form_class = VoucherForm",
            "        for receiver, response in voucher_form_class.send(self.request.event, cls=form_class):",
            "            if response:",
            "                form_class = response",
            "        return form_class",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['instance'] = Voucher(event=self.request.event)",
            "        return kwargs",
            "",
            "    def form_valid(self, form):",
            "        form.instance.event = self.request.event",
            "        ret = super().form_valid(form)",
            "        url = reverse('control:event.voucher', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "            'voucher': self.object.pk",
            "        })",
            "        messages.success(self.request, mark_safe(_('The new voucher has been created: {code}').format(",
            "            code=format_html('<a href=\"{url}\">{code}</a>', url=url, code=self.object.code)",
            "        )))",
            "        form.instance.log_action('pretix.voucher.added', data=dict(form.cleaned_data), user=self.request.user)",
            "        return ret",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        return super().post(request, *args, **kwargs)",
            "",
            "",
            "class VoucherGo(EventPermissionRequiredMixin, View):",
            "    permission = 'can_view_vouchers'",
            "",
            "    def get_voucher(self, code):",
            "        return Voucher.objects.get(code__iexact=code, event=self.request.event)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        code = request.GET.get(\"code\", \"\").strip()",
            "        try:",
            "            voucher = self.get_voucher(code)",
            "            return redirect('control:event.voucher', event=request.event.slug, organizer=request.event.organizer.slug,",
            "                            voucher=voucher.id)",
            "        except Voucher.DoesNotExist:",
            "            messages.error(request, _('There is no voucher with the given voucher code.'))",
            "            return redirect('control:event.vouchers', event=request.event.slug, organizer=request.event.organizer.slug)",
            "",
            "",
            "class VoucherBulkCreate(EventPermissionRequiredMixin, AsyncFormView):",
            "    model = Voucher",
            "    template_name = 'pretixcontrol/vouchers/bulk.html'",
            "    permission = 'can_change_vouchers'",
            "    context_object_name = 'voucher'",
            "    atomic_execute = True",
            "",
            "    def get_success_url(self, value) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_error_url(self):",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    @cached_property",
            "    def copy_from(self):",
            "        if self.request.GET.get(\"copy_from\") and not getattr(self, 'object', None):",
            "            try:",
            "                return self.request.event.vouchers.get(pk=self.request.GET.get(\"copy_from\"))",
            "            except Voucher.DoesNotExist:",
            "                pass",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "",
            "        if self.copy_from:",
            "            i = modelcopy(self.copy_from)",
            "            i.pk = None",
            "            i.redeemed = 0",
            "            kwargs['instance'] = i",
            "        else:",
            "            kwargs['instance'] = Voucher(event=self.request.event, code=None)",
            "        return kwargs",
            "",
            "    def get_async_form_kwargs(self, form_kwargs, organizer=None, event=None):",
            "        if not form_kwargs.get('instance'):",
            "            form_kwargs['instance'] = Voucher(event=self.request.event, code=None)",
            "        return form_kwargs",
            "",
            "    def async_form_valid(self, task, form):",
            "        batch_size = 500",
            "        total_num = 1  # will be set later",
            "",
            "        def set_progress(percent):",
            "            if not task.request.called_directly:",
            "                task.update_state(",
            "                    state='PROGRESS',",
            "                    meta={'value': percent}",
            "                )",
            "",
            "        def process_batch(batch_vouchers, voucherids):",
            "            Voucher.objects.bulk_create(batch_vouchers)",
            "            if not connection.features.can_return_rows_from_bulk_insert:",
            "                from_db = list(self.request.event.vouchers.filter(code__in=[v.code for v in batch_vouchers]))",
            "                batch_vouchers.clear()",
            "                batch_vouchers += from_db",
            "",
            "            log_entries = []",
            "            for v in batch_vouchers:",
            "                voucherids.append(v.pk)",
            "                data = dict(form.cleaned_data)",
            "                data['code'] = code",
            "                data['bulk'] = True",
            "                del data['codes']",
            "                log_entries.append(",
            "                    v.log_action('pretix.voucher.added', data=data, user=self.request.user, save=False)",
            "                )",
            "            LogEntry.objects.bulk_create(log_entries)",
            "            form.post_bulk_save(batch_vouchers)",
            "            batch_vouchers.clear()",
            "            set_progress(len(voucherids) / total_num * (50. if form.cleaned_data['send'] else 100.))",
            "",
            "        voucherids = []",
            "        if not form.is_valid():",
            "            raise ValidationError(form.errors)",
            "        total_num = len(form.cleaned_data['codes'])",
            "",
            "        batch_vouchers = []",
            "        for code in form.cleaned_data['codes']:",
            "            if len(batch_vouchers) >= batch_size:",
            "                process_batch(batch_vouchers, voucherids)",
            "",
            "            obj = modelcopy(form.instance, code=None)",
            "            obj.event = self.request.event",
            "            obj.code = code",
            "            try:",
            "                obj.seat = form.cleaned_data['seats'].pop()",
            "                obj.item = obj.seat.product",
            "            except IndexError:",
            "                pass",
            "            batch_vouchers.append(obj)",
            "",
            "        process_batch(batch_vouchers, voucherids)",
            "",
            "        if form.cleaned_data['send']:",
            "            vouchers_send(",
            "                event=self.request.event,",
            "                vouchers=voucherids,",
            "                subject=form.cleaned_data['send_subject'],",
            "                message=form.cleaned_data['send_message'],",
            "                recipients=[r._asdict() for r in form.cleaned_data['send_recipients']],",
            "                user=self.request.user.pk,",
            "                progress=lambda p: set_progress(50. + p * 50.)",
            "            )",
            "",
            "    def get_success_message(self, value):",
            "        return _('The new vouchers have been created.')",
            "",
            "    def get_form_class(self):",
            "        form_class = VoucherBulkForm",
            "        for receiver, response in voucher_form_class.send(self.request.event, cls=form_class):",
            "            if response:",
            "                form_class = response",
            "        return form_class",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['code_length'] = settings.ENTROPY['voucher_code']",
            "        return ctx",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    @transaction.atomic()",
            "    def post(self, request, *args, **kwargs):",
            "        return super().post(request, *args, **kwargs)",
            "",
            "",
            "class VoucherBulkMailPreview(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_vouchers'",
            "",
            "    # return the origin text if key is missing in dict",
            "    class SafeDict(dict):",
            "        def __missing__(self, key):",
            "            return '{' + key + '}'",
            "",
            "    # get all supported placeholders with dummy values",
            "    def placeholders(self, item):",
            "        ctx = {}",
            "        base_ctx = ['event', 'name']",
            "        if item == 'send_message':",
            "            base_ctx += ['voucher_list']",
            "        for p in get_available_placeholders(self.request.event, base_ctx).values():",
            "            s = str(p.render_sample(self.request.event))",
            "            if s.strip().startswith('* ') or s.startswith('  '):",
            "                ctx[p.identifier] = '<div class=\"placeholder\" title=\"{}\">{}</div>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    markdown_compile_email(s)",
            "                )",
            "            else:",
            "                ctx[p.identifier] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                    _('This value will be replaced based on dynamic parameters.'),",
            "                    escape(s)",
            "                )",
            "        return self.SafeDict(ctx)",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        preview_item = request.POST.get('item', '')",
            "        if preview_item not in ('send_message', 'send_subject'):",
            "            return HttpResponseBadRequest(_('invalid item'))",
            "        msgs = {}",
            "        if \"subject\" in preview_item:",
            "            msgs[\"all\"] = format_map(bleach.clean(request.POST.get(preview_item, \"\")), self.placeholders(preview_item))",
            "        else:",
            "            msgs[\"all\"] = markdown_compile_email(",
            "                format_map(request.POST.get(preview_item), self.placeholders(preview_item))",
            "            )",
            "",
            "        return JsonResponse({",
            "            'item': preview_item,",
            "            'msgs': msgs",
            "        })",
            "",
            "",
            "class VoucherRNG(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_vouchers'",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        try:",
            "            num = int(request.GET.get('num', '5'))",
            "            if num > 100_000:",
            "                return HttpResponseBadRequest()",
            "        except ValueError:  # NOQA",
            "            return HttpResponseBadRequest()",
            "",
            "        prefix = request.GET.get('prefix')",
            "        codes = generate_codes(request.organizer, num, prefix=prefix)",
            "        return JsonResponse({",
            "            'codes': codes",
            "        })",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "",
            "class VoucherBulkAction(EventPermissionRequiredMixin, View):",
            "    permission = 'can_change_vouchers'",
            "",
            "    @cached_property",
            "    def objects(self):",
            "        return self.request.event.vouchers.filter(",
            "            id__in=self.request.POST.getlist('voucher')",
            "        )",
            "",
            "    @transaction.atomic",
            "    def post(self, request, *args, **kwargs):",
            "        if request.POST.get('action') == 'delete':",
            "            return render(request, 'pretixcontrol/vouchers/delete_bulk.html', {",
            "                'allowed': self.objects.filter(redeemed=0),",
            "                'forbidden': self.objects.exclude(redeemed=0),",
            "            })",
            "        elif request.POST.get('action') == 'delete_confirm':",
            "            for obj in self.objects:",
            "                if obj.allow_delete():",
            "                    obj.log_action('pretix.voucher.deleted', user=self.request.user)",
            "                    CartPosition.objects.filter(addon_to__voucher=obj).delete()",
            "                    obj.cartposition_set.all().delete()",
            "                    obj.delete()",
            "                else:",
            "                    obj.log_action('pretix.voucher.changed', user=self.request.user, data={",
            "                        'max_usages': min(obj.redeemed, obj.max_usages),",
            "                        'bulk': True",
            "                    })",
            "                    obj.max_usages = min(obj.redeemed, obj.max_usages)",
            "                    obj.save(update_fields=['max_usages'])",
            "            messages.success(request, _('The selected vouchers have been deleted or disabled.'))",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_success_url(self) -> str:",
            "        return reverse('control:event.vouchers', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "53": [],
            "565": [
                "VoucherBulkMailPreview",
                "placeholders"
            ]
        },
        "addLocation": []
    },
    "src/pretix/plugins/sendmail/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " from django.template.loader import get_template"
            },
            "1": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " from django.urls import reverse"
            },
            "2": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " from django.utils.functional import cached_property"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " from django.utils.timezone import now"
            },
            "5": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " from django.utils.translation import gettext_lazy as _, ngettext"
            },
            "6": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " from django.views.generic import DeleteView, FormView, ListView, TemplateView"
            },
            "7": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "                     for k, v in get_available_placeholders(self.request.event, self.context_parameters).items():"
            },
            "8": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "                         context_dict[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format("
            },
            "9": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "                             _('This value will be replaced based on dynamic parameters.'),"
            },
            "10": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            v.render_sample(self.request.event)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                            escape(v.render_sample(self.request.event))"
            },
            "12": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "                         )"
            },
            "13": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 199,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "                     subject = bleach.clean(form.cleaned_data['subject'].localize(l), tags=[])"
            },
            "15": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 609,
                "PatchRowcode": "                                                                                 'position_or_address']).items():"
            },
            "16": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 610,
                "PatchRowcode": "                         context_dict[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format("
            },
            "17": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": 611,
                "PatchRowcode": "                             _('This value will be replaced based on dynamic parameters.'),"
            },
            "18": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            v.render_sample(self.request.event)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 612,
                "PatchRowcode": "+                            escape(v.render_sample(self.request.event))"
            },
            "20": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": 613,
                "PatchRowcode": "                         )"
            },
            "21": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": 614,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": 615,
                "PatchRowcode": "                     subject = bleach.clean(form.cleaned_data['subject'].localize(l), tags=[])"
            },
            "23": {
                "beforePatchRowNumber": 684,
                "afterPatchRowNumber": 685,
                "PatchRowcode": "                 for k, v in get_available_placeholders(self.request.event, ['event', 'order', 'position_or_address']).items():"
            },
            "24": {
                "beforePatchRowNumber": 685,
                "afterPatchRowNumber": 686,
                "PatchRowcode": "                     placeholders[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format("
            },
            "25": {
                "beforePatchRowNumber": 686,
                "afterPatchRowNumber": 687,
                "PatchRowcode": "                         _('This value will be replaced based on dynamic parameters.'),"
            },
            "26": {
                "beforePatchRowNumber": 687,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        v.render_sample(self.request.event)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 688,
                "PatchRowcode": "+                        escape(v.render_sample(self.request.event))"
            },
            "28": {
                "beforePatchRowNumber": 688,
                "afterPatchRowNumber": 689,
                "PatchRowcode": "                     )"
            },
            "29": {
                "beforePatchRowNumber": 689,
                "afterPatchRowNumber": 690,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 690,
                "afterPatchRowNumber": 691,
                "PatchRowcode": "                 subject = bleach.clean(self.object.subject.localize(lang), tags=[])"
            }
        },
        "frontPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Daniel, Flavia Bastos, FlaviaBastos, Sanket Dasgupta,",
            "# Sohalt, Tobias Kunze, asv-hungvt, pajowu",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import logging",
            "",
            "import bleach",
            "import dateutil",
            "from django.contrib import messages",
            "from django.contrib.humanize.templatetags.humanize import intcomma",
            "from django.db import transaction",
            "from django.db.models import Count, Exists, Max, Min, OuterRef, Q",
            "from django.http import Http404, HttpResponseRedirect",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.loader import get_template",
            "from django.urls import reverse",
            "from django.utils.functional import cached_property",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext_lazy as _, ngettext",
            "from django.views.generic import DeleteView, FormView, ListView, TemplateView",
            "",
            "from pretix.base.email import get_available_placeholders",
            "from pretix.base.i18n import LazyI18nString, language",
            "from pretix.base.models import Checkin, LogEntry, Order, OrderPosition",
            "from pretix.base.models.event import SubEvent",
            "from pretix.base.templatetags.rich_text import markdown_compile_email",
            "from pretix.control.permissions import EventPermissionRequiredMixin",
            "from pretix.control.views import CreateView, PaginationMixin, UpdateView",
            "from pretix.plugins.sendmail.tasks import (",
            "    send_mails_to_orders, send_mails_to_waitinglist,",
            ")",
            "",
            "from ...helpers.format import format_map",
            "from ...helpers.models import modelcopy",
            "from . import forms",
            "from .models import Rule, ScheduledMail",
            "",
            "logger = logging.getLogger('pretix.plugins.sendmail')",
            "",
            "",
            "class IndexView(EventPermissionRequiredMixin, TemplateView):",
            "    template_name = 'pretixplugins/sendmail/index.html'",
            "    permission = 'can_change_orders'",
            "",
            "    def get_context_data(self, **kwargs):",
            "        from .signals import sendmail_view_classes",
            "        classes = []",
            "        for recv, resp in sendmail_view_classes.send(self.request.event):",
            "            if isinstance(resp, (list, tuple)):",
            "                classes += resp",
            "            else:",
            "                classes.append(resp)",
            "        return super().get_context_data(**kwargs, views=[",
            "            {",
            "                'title': cls.TITLE,",
            "                'description': cls.DESCRIPTION,",
            "                'url': cls.get_url(self.request.event)",
            "            } for cls in classes",
            "        ])",
            "",
            "",
            "class BaseSenderView(EventPermissionRequiredMixin, FormView):",
            "    # These parameters usually SHOULD NOT be overridden",
            "    template_name = 'pretixplugins/sendmail/send_form.html'",
            "    permission = 'can_change_orders'",
            "",
            "    # These parameters MUST be overridden by subclasses",
            "    form_fragment_name = None",
            "    context_parameters = ['event']",
            "    task = None",
            "",
            "    # These parameters MUST be overriden by subclasses in a way that allows static access",
            "",
            "    ACTION_TYPE = None",
            "    TITLE = \"\"",
            "    DESCRIPTION = \"\"",
            "",
            "    # The following methods MUST be overridden by subclasses",
            "",
            "    @staticmethod",
            "    def get_url(self, event):",
            "        \"\"\"Returns the URL for this view for a given event.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_object_queryset(self, form):",
            "        \"\"\"Returns a queryset of objects that will become recipients.\"\"\"",
            "        return Order.objects.none()",
            "",
            "    def describe_match_size(self, cnt):",
            "        \"\"\"Returns a short human-readable description of the recipient set, such as '3 attendees'.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @classmethod",
            "    def show_history_meta_data(cls, logentry, _cache_store):",
            "        \"\"\"Returns an HTML component for the history view.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    # The following methods MAY be overridden by subclasses",
            "",
            "    def initial_from_logentry(self, logentry):",
            "        return {",
            "            'message': LazyI18nString(logentry.parsed_data['message']),",
            "            'subject': LazyI18nString(logentry.parsed_data['subject']),",
            "        }",
            "",
            "    def get_success_url(self):",
            "        return self.request.get_full_path()",
            "",
            "    def get_task_kwargs(self, form, objects):",
            "        kwargs = {",
            "            'event': self.request.event.pk,",
            "            'user': self.request.user.pk,",
            "            'subject': form.cleaned_data['subject'].data,",
            "            'message': form.cleaned_data['message'].data,",
            "            'objects': [o.pk for o in objects],",
            "        }",
            "        attachment = form.cleaned_data.get('attachment')",
            "        if attachment is not None and attachment is not False:",
            "            kwargs['attachments'] = [form.cleaned_data['attachment'].id]",
            "        return kwargs",
            "",
            "    # The following methods SHOULD NOT Be overridden by subclasses, but in some cases it may be necessary",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        kwargs['context_parameters'] = self.context_parameters",
            "        if 'from_log' in self.request.GET:",
            "            try:",
            "                from_log_id = self.request.GET.get('from_log')",
            "                logentry = LogEntry.objects.get(",
            "                    id=from_log_id,",
            "                    event=self.request.event,",
            "                    action_type=self.ACTION_TYPE",
            "                )",
            "                kwargs['initial'] = {",
            "                    **self.initial_from_logentry(logentry),",
            "                }",
            "            except LogEntry.DoesNotExist:",
            "                raise Http404(_('You supplied an invalid log entry ID'))",
            "        return kwargs",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not send the email. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def form_valid(self, form):",
            "        objects = self.get_object_queryset(form)",
            "        ocnt = objects.count()",
            "",
            "        self.output = {}",
            "        if not ocnt:",
            "            messages.error(self.request, _('There are no matching recipients for your selection.'))",
            "            self.request.POST = self.request.POST.copy()",
            "            self.request.POST.pop(\"action\", \"\")",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "        if self.request.POST.get(\"action\") != \"send\":",
            "            for l in self.request.event.settings.locales:",
            "                with language(l, self.request.event.settings.region):",
            "                    context_dict = {}",
            "                    for k, v in get_available_placeholders(self.request.event, self.context_parameters).items():",
            "                        context_dict[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                            _('This value will be replaced based on dynamic parameters.'),",
            "                            v.render_sample(self.request.event)",
            "                        )",
            "",
            "                    subject = bleach.clean(form.cleaned_data['subject'].localize(l), tags=[])",
            "                    preview_subject = format_map(subject, context_dict)",
            "                    message = form.cleaned_data['message'].localize(l)",
            "                    preview_text = markdown_compile_email(format_map(message, context_dict))",
            "",
            "                    self.output[l] = {",
            "                        'subject': _('Subject: {subject}').format(subject=preview_subject),",
            "                        'html': preview_text,",
            "                        'attachment': form.cleaned_data.get('attachment')",
            "                    }",
            "",
            "            self.object_count = ocnt",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "        self.task.apply_async(",
            "            kwargs=self.get_task_kwargs(form, objects)",
            "        )",
            "        self.request.event.log_action(",
            "            self.ACTION_TYPE,",
            "            user=self.request.user,",
            "            data=dict(form.cleaned_data)",
            "        )",
            "        messages.success(self.request, _('Your message has been queued and will be sent to the contact addresses of %s '",
            "                                         'in the next few minutes.') % self.describe_match_size(len(objects)))",
            "",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_context_data(self, *args, **kwargs):",
            "        ctx = super().get_context_data(*args, **kwargs)",
            "        ctx['output'] = getattr(self, 'output', None)",
            "        ctx['match_size'] = self.describe_match_size(getattr(self, 'object_count', None))",
            "        ctx['form_fragment_name'] = self.form_fragment_name",
            "        ctx['is_preview'] = self.request.method == 'POST' and self.request.POST.get('action') == 'preview' and ctx['form'].is_valid()",
            "        ctx['view_title'] = self.TITLE",
            "        return ctx",
            "",
            "    def get_form(self, form_class=None):",
            "        f = super().get_form(form_class)",
            "        if self.request.method == 'POST' and self.request.POST.get('action') == 'preview':",
            "            if f.is_valid():",
            "                for fname, field in f.fields.items():",
            "                    field.widget.attrs['disabled'] = 'disabled'",
            "        return f",
            "",
            "",
            "class OrderSendView(BaseSenderView):",
            "    form_class = forms.OrderMailForm",
            "    form_fragment_name = \"pretixplugins/sendmail/send_form_fragment_orders.html\"",
            "    context_parameters = ['event', 'order', 'position_or_address']",
            "    task = send_mails_to_orders",
            "",
            "    ACTION_TYPE = 'pretix.plugins.sendmail.sent'",
            "    TITLE = _(\"Orders or attendees\")",
            "    DESCRIPTION = _(\"Send an email to every customer, or to every person a ticket has been \"",
            "                    \"purchased for, or a combination of both.\")",
            "",
            "    @classmethod",
            "    def show_history_meta_data(cls, logentry, _cache_store):",
            "        if 'itemcache' not in _cache_store:",
            "            _cache_store['itemcache'] = {",
            "                i.pk: str(i) for i in logentry.event.items.all()",
            "            }",
            "        if 'checkin_list_cache' not in _cache_store:",
            "            _cache_store['checkin_list_cache'] = {",
            "                i.pk: str(i) for i in logentry.event.checkin_lists.all()",
            "            }",
            "        if 'status' not in _cache_store:",
            "            status = dict(Order.STATUS_CHOICE)",
            "            status['overdue'] = _('pending with payment overdue')",
            "            status['valid_if_pending'] = _('payment pending but already confirmed')",
            "            status['na'] = _('payment pending (except unapproved or already confirmed)')",
            "            status['pa'] = _('approval pending')",
            "            status['r'] = status['c']",
            "            _cache_store['status'] = status",
            "",
            "        tpl = get_template('pretixplugins/sendmail/history_fragment_orders.html')",
            "        logentry.pdata['sendto'] = [",
            "            _cache_store['status'][s] for s in logentry.pdata['sendto']",
            "        ]",
            "        logentry.pdata['items'] = [",
            "            _cache_store['itemcache'].get(i['id'], '?') for i in logentry.pdata.get('items', [])",
            "        ]",
            "        logentry.pdata['checkin_lists'] = [",
            "            _cache_store['checkin_list_cache'].get(i['id'], '?')",
            "            for i in logentry.pdata.get('checkin_lists', []) if i['id'] in _cache_store['checkin_list_cache']",
            "        ]",
            "        if logentry.pdata.get('subevent'):",
            "            try:",
            "                logentry.pdata['subevent_obj'] = logentry.event.subevents.get(pk=logentry.pdata['subevent']['id'])",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return tpl.render({",
            "            'log': logentry,",
            "        })",
            "",
            "    @classmethod",
            "    def get_url(cls, event):",
            "        return reverse(",
            "            'plugins:sendmail:send.orders',",
            "            kwargs={",
            "                'event': event.slug,",
            "                'organizer': event.organizer.slug,",
            "            }",
            "        )",
            "",
            "    def initial_from_logentry(self, logentry: LogEntry):",
            "        initial = super().initial_from_logentry(logentry)",
            "        if 'recipients' in logentry.parsed_data:",
            "            initial['recipients'] = logentry.parsed_data.get('recipients', 'orders')",
            "        if 'sendto' in logentry.parsed_data:",
            "            initial['sendto'] = logentry.parsed_data.get('sendto')",
            "        if 'items' in logentry.parsed_data:",
            "            initial['items'] = self.request.event.items.filter(",
            "                id__in=[a['id'] for a in logentry.parsed_data['items']]",
            "            )",
            "        elif logentry.parsed_data.get('item'):",
            "            initial['items'] = self.request.event.items.filter(",
            "                id=logentry.parsed_data['item']['id']",
            "            )",
            "        if 'checkin_lists' in logentry.parsed_data:",
            "            initial['checkin_lists'] = self.request.event.checkin_lists.filter(",
            "                id__in=[c['id'] for c in logentry.parsed_data['checkin_lists']]",
            "            )",
            "        initial['filter_checkins'] = logentry.parsed_data.get('filter_checkins', False)",
            "        initial['not_checked_in'] = logentry.parsed_data.get('not_checked_in', False)",
            "        if logentry.parsed_data.get('subevents_from'):",
            "            initial['subevents_from'] = dateutil.parser.parse(logentry.parsed_data['subevents_from'])",
            "        if logentry.parsed_data.get('subevents_to'):",
            "            initial['subevents_to'] = dateutil.parser.parse(logentry.parsed_data['subevents_to'])",
            "        if logentry.parsed_data.get('created_from'):",
            "            initial['created_from'] = dateutil.parser.parse(logentry.parsed_data['created_from'])",
            "        if logentry.parsed_data.get('created_to'):",
            "            initial['created_to'] = dateutil.parser.parse(logentry.parsed_data['created_to'])",
            "        if logentry.parsed_data.get('attach_tickets'):",
            "            initial['attach_tickets'] = logentry.parsed_data['attach_tickets']",
            "        if logentry.parsed_data.get('attach_ical'):",
            "            initial['attach_ical'] = logentry.parsed_data['attach_ical']",
            "        if logentry.parsed_data.get('subevent'):",
            "            try:",
            "                initial['subevent'] = self.request.event.subevents.get(",
            "                    pk=logentry.parsed_data['subevent']['id']",
            "                )",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return initial",
            "",
            "    def get_object_queryset(self, form):",
            "        qs = Order.objects.filter(event=self.request.event)",
            "        statusq = Q(status__in=form.cleaned_data['sendto'])",
            "        if 'overdue' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=False, valid_if_pending=False, expires__lt=now())",
            "        if 'pa' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=True)",
            "        if 'na' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=False, valid_if_pending=False)",
            "        if 'valid_if_pending' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=False, valid_if_pending=True)",
            "        orders = qs.filter(statusq)",
            "",
            "        opq = OrderPosition.objects.filter(",
            "            Q(item_id__in=[i.pk for i in form.cleaned_data.get('items')]) | Q(Exists(",
            "                OrderPosition.objects.filter(",
            "                    addon_to_id=OuterRef('pk'),",
            "                    item_id__in=[i.pk for i in form.cleaned_data.get('items')]",
            "                )",
            "            )),",
            "            order__event=self.request.event,",
            "            canceled=False,",
            "        )",
            "",
            "        if form.cleaned_data.get('filter_checkins'):",
            "            ql = []",
            "",
            "            if form.cleaned_data.get('not_checked_in'):",
            "                opq = opq.alias(",
            "                    any_checkins=Exists(",
            "                        Checkin.all.filter(",
            "                            Q(position_id=OuterRef('pk')) | Q(position__addon_to_id=OuterRef('pk')),",
            "                            successful=True,",
            "                            list__consider_tickets_used=True,",
            "                        )",
            "                    )",
            "                )",
            "                ql.append(Q(any_checkins=False))",
            "            if form.cleaned_data.get('checkin_lists'):",
            "                opq = opq.alias(",
            "                    matching_checkins=Exists(",
            "                        Checkin.all.filter(",
            "                            Q(position_id=OuterRef('pk')) | Q(position__addon_to_id=OuterRef('pk')),",
            "                            list_id__in=[i.pk for i in form.cleaned_data.get('checkin_lists', [])],",
            "                            successful=True",
            "                        )",
            "                    )",
            "                )",
            "                ql.append(Q(matching_checkins=True))",
            "            if len(ql) == 2:",
            "                opq = opq.filter(ql[0] | ql[1])",
            "            elif ql:",
            "                opq = opq.filter(ql[0])",
            "            else:",
            "                opq = opq.none()",
            "",
            "        if form.cleaned_data.get('subevent'):",
            "            opq = opq.filter(subevent=form.cleaned_data.get('subevent'))",
            "        if form.cleaned_data.get('subevents_from'):",
            "            opq = opq.filter(subevent__date_from__gte=form.cleaned_data.get('subevents_from'))",
            "        if form.cleaned_data.get('subevents_to'):",
            "            opq = opq.filter(subevent__date_from__lt=form.cleaned_data.get('subevents_to'))",
            "        if form.cleaned_data.get('created_from'):",
            "            opq = opq.filter(order__datetime__gte=form.cleaned_data.get('created_from'))",
            "        if form.cleaned_data.get('created_to'):",
            "            opq = opq.filter(order__datetime__lt=form.cleaned_data.get('created_to'))",
            "",
            "        # pk__in turns out to be faster than Exists(subquery) in many cases since we often filter on a large subset",
            "        # of orderpositions",
            "        return orders.filter(pk__in=opq.values_list('order_id'))",
            "",
            "    def describe_match_size(self, cnt):",
            "        return ngettext(",
            "            '%(number)s matching order',",
            "            '%(number)s matching orders',",
            "            cnt or 0,",
            "        ) % {",
            "            'number': intcomma(cnt or 0),",
            "        }",
            "",
            "    def get_task_kwargs(self, form, objects):",
            "        kwargs = super().get_task_kwargs(form, objects)",
            "        kwargs.update({",
            "            'recipients': form.cleaned_data['recipients'],",
            "            'items': [i.pk for i in form.cleaned_data.get('items')],",
            "            'not_checked_in': form.cleaned_data.get('not_checked_in'),",
            "            'checkin_lists': [i.pk for i in form.cleaned_data.get('checkin_lists')],",
            "            'filter_checkins': form.cleaned_data.get('filter_checkins'),",
            "            'attach_tickets': form.cleaned_data.get('attach_tickets'),",
            "            'attach_ical': form.cleaned_data.get('attach_ical'),",
            "        })",
            "        return kwargs",
            "",
            "",
            "class WaitinglistSendView(BaseSenderView):",
            "    form_class = forms.WaitinglistMailForm",
            "    form_fragment_name = \"pretixplugins/sendmail/send_form_fragment_waitinglist.html\"",
            "    context_parameters = ['event', 'waiting_list_entry', 'event_or_subevent']",
            "    task = send_mails_to_waitinglist",
            "",
            "    ACTION_TYPE = 'pretix.plugins.sendmail.sent.waitinglist'",
            "    TITLE = _(\"Waiting list\")",
            "    DESCRIPTION = _(\"Send an email to every person currently waiting to receive a voucher through the waiting \"",
            "                    \"list feature.\")",
            "",
            "    @classmethod",
            "    def show_history_meta_data(cls, logentry, _cache_store):",
            "        if 'itemcache' not in _cache_store:",
            "            _cache_store['itemcache'] = {",
            "                i.pk: str(i) for i in logentry.event.items.all()",
            "            }",
            "",
            "        tpl = get_template('pretixplugins/sendmail/history_fragment_waitinglist.html')",
            "        logentry.pdata['items'] = [",
            "            _cache_store['itemcache'].get(i['id'], '?') for i in logentry.pdata.get('items', [])",
            "        ]",
            "        if logentry.pdata.get('subevent'):",
            "            try:",
            "                logentry.pdata['subevent_obj'] = logentry.event.subevents.get(pk=logentry.pdata['subevent']['id'])",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return tpl.render({",
            "            'log': logentry,",
            "        })",
            "",
            "    @classmethod",
            "    def get_url(cls, event):",
            "        return reverse(",
            "            'plugins:sendmail:send.waitinglist',",
            "            kwargs={",
            "                'event': event.slug,",
            "                'organizer': event.organizer.slug,",
            "            }",
            "        )",
            "",
            "    def initial_from_logentry(self, logentry: LogEntry):",
            "        initial = super().initial_from_logentry(logentry)",
            "        if 'items' in logentry.parsed_data:",
            "            initial['items'] = self.request.event.items.filter(",
            "                id__in=[a['id'] for a in logentry.parsed_data['items']]",
            "            )",
            "        if logentry.parsed_data.get('subevents_from'):",
            "            initial['subevents_from'] = dateutil.parser.parse(logentry.parsed_data['subevents_from'])",
            "        if logentry.parsed_data.get('subevents_to'):",
            "            initial['subevents_to'] = dateutil.parser.parse(logentry.parsed_data['subevents_to'])",
            "        if logentry.parsed_data.get('subevent'):",
            "            try:",
            "                initial['subevent'] = self.request.event.subevents.get(",
            "                    pk=logentry.parsed_data['subevent']['id']",
            "                )",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return initial",
            "",
            "    def get_object_queryset(self, form):",
            "        qs = self.request.event.waitinglistentries.filter(voucher__isnull=True)",
            "",
            "        qs = qs.filter(item__in=[i.pk for i in form.cleaned_data.get('items')])",
            "        if form.cleaned_data.get('subevent'):",
            "            qs = qs.filter(subevent=form.cleaned_data.get('subevent'))",
            "        if form.cleaned_data.get('subevents_from'):",
            "            qs = qs.filter(subevent__date_from__gte=form.cleaned_data.get('subevents_from'))",
            "        if form.cleaned_data.get('subevents_to'):",
            "            qs = qs.filter(subevent__date_from__lt=form.cleaned_data.get('subevents_to'))",
            "",
            "        return qs",
            "",
            "    def describe_match_size(self, cnt):",
            "        return ngettext(",
            "            '%(number)s waiting list entry',",
            "            '%(number)s waiting list entries',",
            "            cnt or 0,",
            "        ) % {",
            "            'number': intcomma(cnt or 0),",
            "        }",
            "",
            "",
            "class EmailHistoryView(EventPermissionRequiredMixin, ListView):",
            "    template_name = 'pretixplugins/sendmail/history.html'",
            "    permission = 'can_change_orders'",
            "    model = LogEntry",
            "    context_object_name = 'logs'",
            "    paginate_by = 5",
            "",
            "    @cached_property",
            "    def type_map(self):",
            "        from .signals import sendmail_view_classes",
            "        classes = []",
            "        for recv, resp in sendmail_view_classes.send(self.request.event):",
            "            if isinstance(resp, (list, tuple)):",
            "                classes += resp",
            "            else:",
            "                classes.append(resp)",
            "        return {",
            "            cls.ACTION_TYPE: cls",
            "            for cls in classes",
            "        }",
            "",
            "    def get_queryset(self):",
            "        qs = LogEntry.objects.filter(",
            "            event=self.request.event,",
            "            action_type__in=self.type_map.keys(),",
            "        ).select_related('event', 'user')",
            "        return qs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        _cache = {}",
            "        for log in ctx['logs']:",
            "            log.pdata = log.parsed_data",
            "            log.pdata['locales'] = {}",
            "            for locale, msg in log.pdata['message'].items():",
            "                log.pdata['locales'][locale] = {",
            "                    'message': msg,",
            "                    'subject': log.pdata['subject'][locale]",
            "                }",
            "            log.view = {",
            "                'url': self.type_map[log.action_type].get_url(self.request.event),",
            "                'title': self.type_map[log.action_type].TITLE,",
            "                'rendered_data': self.type_map[log.action_type].show_history_meta_data(log, _cache)",
            "            }",
            "",
            "        return ctx",
            "",
            "",
            "class CreateRule(EventPermissionRequiredMixin, CreateView):",
            "    template_name = 'pretixplugins/sendmail/rule_create.html'",
            "    permission = 'can_change_event_settings'",
            "    form_class = forms.RuleForm",
            "",
            "    model = Rule",
            "",
            "    @cached_property",
            "    def copy_from(self):",
            "        if self.request.GET.get(\"copy_from\") and not getattr(self, 'object', None):",
            "            try:",
            "                return Rule.objects.get(pk=self.request.GET.get(\"copy_from\"), event=self.request.event)",
            "            except Rule.DoesNotExist:",
            "                pass",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "",
            "        if self.copy_from:",
            "            i = modelcopy(self.copy_from)",
            "            i.pk = None",
            "            i.redeemed = 0",
            "            kwargs[\"instance\"] = i",
            "        return kwargs",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def form_valid(self, form):",
            "        self.output = {}",
            "",
            "        if self.request.POST.get(\"action\") == \"preview\":",
            "            for l in self.request.event.settings.locales:",
            "                with language(l, self.request.event.settings.region):",
            "                    context_dict = {}",
            "                    for k, v in get_available_placeholders(self.request.event, ['event', 'order',",
            "                                                                                'position_or_address']).items():",
            "                        context_dict[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                            _('This value will be replaced based on dynamic parameters.'),",
            "                            v.render_sample(self.request.event)",
            "                        )",
            "",
            "                    subject = bleach.clean(form.cleaned_data['subject'].localize(l), tags=[])",
            "                    preview_subject = format_map(subject, context_dict)",
            "                    template = form.cleaned_data['template'].localize(l)",
            "                    preview_text = markdown_compile_email(format_map(template, context_dict))",
            "",
            "                    self.output[l] = {",
            "                        'subject': _('Subject: {subject}').format(subject=preview_subject),",
            "                        'html': preview_text,",
            "                    }",
            "",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "        messages.success(self.request, _('Your rule has been created.'))",
            "",
            "        form.instance.event = self.request.event",
            "",
            "        with transaction.atomic():",
            "            self.object = form.save()",
            "            form.instance.log_action('pretix.plugins.sendmail.rule.added', user=self.request.user,",
            "                                     data=dict(form.cleaned_data))",
            "",
            "        return redirect(",
            "            'plugins:sendmail:rule.update',",
            "            event=self.request.event.slug,",
            "            organizer=self.request.event.organizer.slug,",
            "            rule=self.object.pk,",
            "        )",
            "",
            "",
            "class UpdateRule(EventPermissionRequiredMixin, UpdateView):",
            "    model = Rule",
            "    form_class = forms.RuleForm",
            "    template_name = 'pretixplugins/sendmail/rule_update.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_object(self, queryset=None) -> Rule:",
            "        return get_object_or_404(",
            "            Rule.objects.annotate(",
            "                total_mails=Count('scheduledmail'),",
            "                sent_mails=Count('scheduledmail', filter=Q(scheduledmail__state=ScheduledMail.STATE_COMPLETED)),",
            "            ),",
            "            event=self.request.event,",
            "            id=self.kwargs['rule']",
            "        )",
            "",
            "    def get_success_url(self):",
            "        return reverse('plugins:sendmail:rule.update', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "            'rule': self.object.pk,",
            "        })",
            "",
            "    @transaction.atomic()",
            "    def form_valid(self, form):",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        form.instance.log_action('pretix.plugins.sendmail.rule.changed', user=self.request.user,",
            "                                 data=dict(form.cleaned_data))",
            "        return super().form_valid(form)",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        o = {}",
            "",
            "        for lang in self.request.event.settings.locales:",
            "            with language(lang, self.request.event.settings.region):",
            "                placeholders = {}",
            "                for k, v in get_available_placeholders(self.request.event, ['event', 'order', 'position_or_address']).items():",
            "                    placeholders[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                        _('This value will be replaced based on dynamic parameters.'),",
            "                        v.render_sample(self.request.event)",
            "                    )",
            "",
            "                subject = bleach.clean(self.object.subject.localize(lang), tags=[])",
            "                preview_subject = format_map(subject, placeholders)",
            "                template = self.object.template.localize(lang)",
            "                preview_text = markdown_compile_email(format_map(template, placeholders))",
            "",
            "                o[lang] = {",
            "                    'subject': _('Subject: {subject}'.format(subject=preview_subject)),",
            "                    'html': preview_text,",
            "                }",
            "",
            "        ctx['output'] = o",
            "",
            "        return ctx",
            "",
            "",
            "class ListRules(EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    template_name = 'pretixplugins/sendmail/rule_list.html'",
            "    model = Rule",
            "    context_object_name = 'rules'",
            "",
            "    def get_queryset(self):",
            "        return self.request.event.sendmail_rules.annotate(",
            "            total_mails=Count('scheduledmail'),",
            "            sent_mails=Count('scheduledmail', filter=Q(scheduledmail__state=ScheduledMail.STATE_COMPLETED)),",
            "            last_execution=Max(",
            "                'scheduledmail__computed_datetime',",
            "                filter=Q(scheduledmail__state=ScheduledMail.STATE_COMPLETED)",
            "            ),",
            "            next_execution=Min(",
            "                'scheduledmail__computed_datetime',",
            "                filter=Q(scheduledmail__state=ScheduledMail.STATE_SCHEDULED)",
            "            ),",
            "        ).prefetch_related(",
            "            'limit_products'",
            "        ).order_by('-send_date', 'subject', 'pk')",
            "",
            "",
            "class DeleteRule(EventPermissionRequiredMixin, DeleteView):",
            "    model = Rule",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixplugins/sendmail/rule_delete.html'",
            "    context_object_name = 'rule'",
            "",
            "    def get_success_url(self):",
            "        return reverse(\"plugins:sendmail:rule.list\", kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_object(self, queryset=None) -> Rule:",
            "        return get_object_or_404(Rule, event=self.request.event, id=self.kwargs['rule'])",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "",
            "        self.request.event.log_action('pretix.plugins.sendmail.rule.deleted',",
            "                                      user=self.request.user,",
            "                                      data={",
            "                                          'subject': self.object.subject,",
            "                                          'text': self.object.template,",
            "                                      })",
            "",
            "        self.object.delete()",
            "        messages.success(self.request, _('The selected rule has been deleted.'))",
            "        return HttpResponseRedirect(success_url)",
            "",
            "",
            "class ScheduleView(EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    template_name = 'pretixplugins/sendmail/rule_inspect.html'",
            "    model = ScheduledMail",
            "    context_object_name = 'scheduled_mails'",
            "",
            "    @cached_property",
            "    def rule(self):",
            "        return get_object_or_404(Rule, event=self.request.event, id=self.kwargs['rule'])",
            "",
            "    def get_queryset(self):",
            "        return self.rule.scheduledmail_set.select_related('subevent').order_by(",
            "            '-computed_datetime', '-pk'",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['rule'] = self.rule",
            "        return ctx"
        ],
        "afterPatchFile": [
            "#",
            "# This file is part of pretix (Community Edition).",
            "#",
            "# Copyright (C) 2014-2020 Raphael Michel and contributors",
            "# Copyright (C) 2020-2021 rami.io GmbH and contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General",
            "# Public License as published by the Free Software Foundation in version 3 of the License.",
            "#",
            "# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are",
            "# applicable granting you additional permissions and placing additional restrictions on your usage of this software.",
            "# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive",
            "# this file, see <https://pretix.eu/about/en/license>.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied",
            "# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see",
            "# <https://www.gnu.org/licenses/>.",
            "#",
            "",
            "# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of",
            "# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.",
            "#",
            "# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A",
            "# full history of changes and contributors is available at <https://github.com/pretix/pretix>.",
            "#",
            "# This file contains Apache-licensed contributions copyrighted by: Daniel, Flavia Bastos, FlaviaBastos, Sanket Dasgupta,",
            "# Sohalt, Tobias Kunze, asv-hungvt, pajowu",
            "#",
            "# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is",
            "# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations under the License.",
            "",
            "import logging",
            "",
            "import bleach",
            "import dateutil",
            "from django.contrib import messages",
            "from django.contrib.humanize.templatetags.humanize import intcomma",
            "from django.db import transaction",
            "from django.db.models import Count, Exists, Max, Min, OuterRef, Q",
            "from django.http import Http404, HttpResponseRedirect",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.loader import get_template",
            "from django.urls import reverse",
            "from django.utils.functional import cached_property",
            "from django.utils.html import escape",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext_lazy as _, ngettext",
            "from django.views.generic import DeleteView, FormView, ListView, TemplateView",
            "",
            "from pretix.base.email import get_available_placeholders",
            "from pretix.base.i18n import LazyI18nString, language",
            "from pretix.base.models import Checkin, LogEntry, Order, OrderPosition",
            "from pretix.base.models.event import SubEvent",
            "from pretix.base.templatetags.rich_text import markdown_compile_email",
            "from pretix.control.permissions import EventPermissionRequiredMixin",
            "from pretix.control.views import CreateView, PaginationMixin, UpdateView",
            "from pretix.plugins.sendmail.tasks import (",
            "    send_mails_to_orders, send_mails_to_waitinglist,",
            ")",
            "",
            "from ...helpers.format import format_map",
            "from ...helpers.models import modelcopy",
            "from . import forms",
            "from .models import Rule, ScheduledMail",
            "",
            "logger = logging.getLogger('pretix.plugins.sendmail')",
            "",
            "",
            "class IndexView(EventPermissionRequiredMixin, TemplateView):",
            "    template_name = 'pretixplugins/sendmail/index.html'",
            "    permission = 'can_change_orders'",
            "",
            "    def get_context_data(self, **kwargs):",
            "        from .signals import sendmail_view_classes",
            "        classes = []",
            "        for recv, resp in sendmail_view_classes.send(self.request.event):",
            "            if isinstance(resp, (list, tuple)):",
            "                classes += resp",
            "            else:",
            "                classes.append(resp)",
            "        return super().get_context_data(**kwargs, views=[",
            "            {",
            "                'title': cls.TITLE,",
            "                'description': cls.DESCRIPTION,",
            "                'url': cls.get_url(self.request.event)",
            "            } for cls in classes",
            "        ])",
            "",
            "",
            "class BaseSenderView(EventPermissionRequiredMixin, FormView):",
            "    # These parameters usually SHOULD NOT be overridden",
            "    template_name = 'pretixplugins/sendmail/send_form.html'",
            "    permission = 'can_change_orders'",
            "",
            "    # These parameters MUST be overridden by subclasses",
            "    form_fragment_name = None",
            "    context_parameters = ['event']",
            "    task = None",
            "",
            "    # These parameters MUST be overriden by subclasses in a way that allows static access",
            "",
            "    ACTION_TYPE = None",
            "    TITLE = \"\"",
            "    DESCRIPTION = \"\"",
            "",
            "    # The following methods MUST be overridden by subclasses",
            "",
            "    @staticmethod",
            "    def get_url(self, event):",
            "        \"\"\"Returns the URL for this view for a given event.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_object_queryset(self, form):",
            "        \"\"\"Returns a queryset of objects that will become recipients.\"\"\"",
            "        return Order.objects.none()",
            "",
            "    def describe_match_size(self, cnt):",
            "        \"\"\"Returns a short human-readable description of the recipient set, such as '3 attendees'.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @classmethod",
            "    def show_history_meta_data(cls, logentry, _cache_store):",
            "        \"\"\"Returns an HTML component for the history view.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    # The following methods MAY be overridden by subclasses",
            "",
            "    def initial_from_logentry(self, logentry):",
            "        return {",
            "            'message': LazyI18nString(logentry.parsed_data['message']),",
            "            'subject': LazyI18nString(logentry.parsed_data['subject']),",
            "        }",
            "",
            "    def get_success_url(self):",
            "        return self.request.get_full_path()",
            "",
            "    def get_task_kwargs(self, form, objects):",
            "        kwargs = {",
            "            'event': self.request.event.pk,",
            "            'user': self.request.user.pk,",
            "            'subject': form.cleaned_data['subject'].data,",
            "            'message': form.cleaned_data['message'].data,",
            "            'objects': [o.pk for o in objects],",
            "        }",
            "        attachment = form.cleaned_data.get('attachment')",
            "        if attachment is not None and attachment is not False:",
            "            kwargs['attachments'] = [form.cleaned_data['attachment'].id]",
            "        return kwargs",
            "",
            "    # The following methods SHOULD NOT Be overridden by subclasses, but in some cases it may be necessary",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "        kwargs['context_parameters'] = self.context_parameters",
            "        if 'from_log' in self.request.GET:",
            "            try:",
            "                from_log_id = self.request.GET.get('from_log')",
            "                logentry = LogEntry.objects.get(",
            "                    id=from_log_id,",
            "                    event=self.request.event,",
            "                    action_type=self.ACTION_TYPE",
            "                )",
            "                kwargs['initial'] = {",
            "                    **self.initial_from_logentry(logentry),",
            "                }",
            "            except LogEntry.DoesNotExist:",
            "                raise Http404(_('You supplied an invalid log entry ID'))",
            "        return kwargs",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not send the email. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def form_valid(self, form):",
            "        objects = self.get_object_queryset(form)",
            "        ocnt = objects.count()",
            "",
            "        self.output = {}",
            "        if not ocnt:",
            "            messages.error(self.request, _('There are no matching recipients for your selection.'))",
            "            self.request.POST = self.request.POST.copy()",
            "            self.request.POST.pop(\"action\", \"\")",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "        if self.request.POST.get(\"action\") != \"send\":",
            "            for l in self.request.event.settings.locales:",
            "                with language(l, self.request.event.settings.region):",
            "                    context_dict = {}",
            "                    for k, v in get_available_placeholders(self.request.event, self.context_parameters).items():",
            "                        context_dict[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                            _('This value will be replaced based on dynamic parameters.'),",
            "                            escape(v.render_sample(self.request.event))",
            "                        )",
            "",
            "                    subject = bleach.clean(form.cleaned_data['subject'].localize(l), tags=[])",
            "                    preview_subject = format_map(subject, context_dict)",
            "                    message = form.cleaned_data['message'].localize(l)",
            "                    preview_text = markdown_compile_email(format_map(message, context_dict))",
            "",
            "                    self.output[l] = {",
            "                        'subject': _('Subject: {subject}').format(subject=preview_subject),",
            "                        'html': preview_text,",
            "                        'attachment': form.cleaned_data.get('attachment')",
            "                    }",
            "",
            "            self.object_count = ocnt",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "        self.task.apply_async(",
            "            kwargs=self.get_task_kwargs(form, objects)",
            "        )",
            "        self.request.event.log_action(",
            "            self.ACTION_TYPE,",
            "            user=self.request.user,",
            "            data=dict(form.cleaned_data)",
            "        )",
            "        messages.success(self.request, _('Your message has been queued and will be sent to the contact addresses of %s '",
            "                                         'in the next few minutes.') % self.describe_match_size(len(objects)))",
            "",
            "        return redirect(self.get_success_url())",
            "",
            "    def get_context_data(self, *args, **kwargs):",
            "        ctx = super().get_context_data(*args, **kwargs)",
            "        ctx['output'] = getattr(self, 'output', None)",
            "        ctx['match_size'] = self.describe_match_size(getattr(self, 'object_count', None))",
            "        ctx['form_fragment_name'] = self.form_fragment_name",
            "        ctx['is_preview'] = self.request.method == 'POST' and self.request.POST.get('action') == 'preview' and ctx['form'].is_valid()",
            "        ctx['view_title'] = self.TITLE",
            "        return ctx",
            "",
            "    def get_form(self, form_class=None):",
            "        f = super().get_form(form_class)",
            "        if self.request.method == 'POST' and self.request.POST.get('action') == 'preview':",
            "            if f.is_valid():",
            "                for fname, field in f.fields.items():",
            "                    field.widget.attrs['disabled'] = 'disabled'",
            "        return f",
            "",
            "",
            "class OrderSendView(BaseSenderView):",
            "    form_class = forms.OrderMailForm",
            "    form_fragment_name = \"pretixplugins/sendmail/send_form_fragment_orders.html\"",
            "    context_parameters = ['event', 'order', 'position_or_address']",
            "    task = send_mails_to_orders",
            "",
            "    ACTION_TYPE = 'pretix.plugins.sendmail.sent'",
            "    TITLE = _(\"Orders or attendees\")",
            "    DESCRIPTION = _(\"Send an email to every customer, or to every person a ticket has been \"",
            "                    \"purchased for, or a combination of both.\")",
            "",
            "    @classmethod",
            "    def show_history_meta_data(cls, logentry, _cache_store):",
            "        if 'itemcache' not in _cache_store:",
            "            _cache_store['itemcache'] = {",
            "                i.pk: str(i) for i in logentry.event.items.all()",
            "            }",
            "        if 'checkin_list_cache' not in _cache_store:",
            "            _cache_store['checkin_list_cache'] = {",
            "                i.pk: str(i) for i in logentry.event.checkin_lists.all()",
            "            }",
            "        if 'status' not in _cache_store:",
            "            status = dict(Order.STATUS_CHOICE)",
            "            status['overdue'] = _('pending with payment overdue')",
            "            status['valid_if_pending'] = _('payment pending but already confirmed')",
            "            status['na'] = _('payment pending (except unapproved or already confirmed)')",
            "            status['pa'] = _('approval pending')",
            "            status['r'] = status['c']",
            "            _cache_store['status'] = status",
            "",
            "        tpl = get_template('pretixplugins/sendmail/history_fragment_orders.html')",
            "        logentry.pdata['sendto'] = [",
            "            _cache_store['status'][s] for s in logentry.pdata['sendto']",
            "        ]",
            "        logentry.pdata['items'] = [",
            "            _cache_store['itemcache'].get(i['id'], '?') for i in logentry.pdata.get('items', [])",
            "        ]",
            "        logentry.pdata['checkin_lists'] = [",
            "            _cache_store['checkin_list_cache'].get(i['id'], '?')",
            "            for i in logentry.pdata.get('checkin_lists', []) if i['id'] in _cache_store['checkin_list_cache']",
            "        ]",
            "        if logentry.pdata.get('subevent'):",
            "            try:",
            "                logentry.pdata['subevent_obj'] = logentry.event.subevents.get(pk=logentry.pdata['subevent']['id'])",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return tpl.render({",
            "            'log': logentry,",
            "        })",
            "",
            "    @classmethod",
            "    def get_url(cls, event):",
            "        return reverse(",
            "            'plugins:sendmail:send.orders',",
            "            kwargs={",
            "                'event': event.slug,",
            "                'organizer': event.organizer.slug,",
            "            }",
            "        )",
            "",
            "    def initial_from_logentry(self, logentry: LogEntry):",
            "        initial = super().initial_from_logentry(logentry)",
            "        if 'recipients' in logentry.parsed_data:",
            "            initial['recipients'] = logentry.parsed_data.get('recipients', 'orders')",
            "        if 'sendto' in logentry.parsed_data:",
            "            initial['sendto'] = logentry.parsed_data.get('sendto')",
            "        if 'items' in logentry.parsed_data:",
            "            initial['items'] = self.request.event.items.filter(",
            "                id__in=[a['id'] for a in logentry.parsed_data['items']]",
            "            )",
            "        elif logentry.parsed_data.get('item'):",
            "            initial['items'] = self.request.event.items.filter(",
            "                id=logentry.parsed_data['item']['id']",
            "            )",
            "        if 'checkin_lists' in logentry.parsed_data:",
            "            initial['checkin_lists'] = self.request.event.checkin_lists.filter(",
            "                id__in=[c['id'] for c in logentry.parsed_data['checkin_lists']]",
            "            )",
            "        initial['filter_checkins'] = logentry.parsed_data.get('filter_checkins', False)",
            "        initial['not_checked_in'] = logentry.parsed_data.get('not_checked_in', False)",
            "        if logentry.parsed_data.get('subevents_from'):",
            "            initial['subevents_from'] = dateutil.parser.parse(logentry.parsed_data['subevents_from'])",
            "        if logentry.parsed_data.get('subevents_to'):",
            "            initial['subevents_to'] = dateutil.parser.parse(logentry.parsed_data['subevents_to'])",
            "        if logentry.parsed_data.get('created_from'):",
            "            initial['created_from'] = dateutil.parser.parse(logentry.parsed_data['created_from'])",
            "        if logentry.parsed_data.get('created_to'):",
            "            initial['created_to'] = dateutil.parser.parse(logentry.parsed_data['created_to'])",
            "        if logentry.parsed_data.get('attach_tickets'):",
            "            initial['attach_tickets'] = logentry.parsed_data['attach_tickets']",
            "        if logentry.parsed_data.get('attach_ical'):",
            "            initial['attach_ical'] = logentry.parsed_data['attach_ical']",
            "        if logentry.parsed_data.get('subevent'):",
            "            try:",
            "                initial['subevent'] = self.request.event.subevents.get(",
            "                    pk=logentry.parsed_data['subevent']['id']",
            "                )",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return initial",
            "",
            "    def get_object_queryset(self, form):",
            "        qs = Order.objects.filter(event=self.request.event)",
            "        statusq = Q(status__in=form.cleaned_data['sendto'])",
            "        if 'overdue' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=False, valid_if_pending=False, expires__lt=now())",
            "        if 'pa' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=True)",
            "        if 'na' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=False, valid_if_pending=False)",
            "        if 'valid_if_pending' in form.cleaned_data['sendto']:",
            "            statusq |= Q(status=Order.STATUS_PENDING, require_approval=False, valid_if_pending=True)",
            "        orders = qs.filter(statusq)",
            "",
            "        opq = OrderPosition.objects.filter(",
            "            Q(item_id__in=[i.pk for i in form.cleaned_data.get('items')]) | Q(Exists(",
            "                OrderPosition.objects.filter(",
            "                    addon_to_id=OuterRef('pk'),",
            "                    item_id__in=[i.pk for i in form.cleaned_data.get('items')]",
            "                )",
            "            )),",
            "            order__event=self.request.event,",
            "            canceled=False,",
            "        )",
            "",
            "        if form.cleaned_data.get('filter_checkins'):",
            "            ql = []",
            "",
            "            if form.cleaned_data.get('not_checked_in'):",
            "                opq = opq.alias(",
            "                    any_checkins=Exists(",
            "                        Checkin.all.filter(",
            "                            Q(position_id=OuterRef('pk')) | Q(position__addon_to_id=OuterRef('pk')),",
            "                            successful=True,",
            "                            list__consider_tickets_used=True,",
            "                        )",
            "                    )",
            "                )",
            "                ql.append(Q(any_checkins=False))",
            "            if form.cleaned_data.get('checkin_lists'):",
            "                opq = opq.alias(",
            "                    matching_checkins=Exists(",
            "                        Checkin.all.filter(",
            "                            Q(position_id=OuterRef('pk')) | Q(position__addon_to_id=OuterRef('pk')),",
            "                            list_id__in=[i.pk for i in form.cleaned_data.get('checkin_lists', [])],",
            "                            successful=True",
            "                        )",
            "                    )",
            "                )",
            "                ql.append(Q(matching_checkins=True))",
            "            if len(ql) == 2:",
            "                opq = opq.filter(ql[0] | ql[1])",
            "            elif ql:",
            "                opq = opq.filter(ql[0])",
            "            else:",
            "                opq = opq.none()",
            "",
            "        if form.cleaned_data.get('subevent'):",
            "            opq = opq.filter(subevent=form.cleaned_data.get('subevent'))",
            "        if form.cleaned_data.get('subevents_from'):",
            "            opq = opq.filter(subevent__date_from__gte=form.cleaned_data.get('subevents_from'))",
            "        if form.cleaned_data.get('subevents_to'):",
            "            opq = opq.filter(subevent__date_from__lt=form.cleaned_data.get('subevents_to'))",
            "        if form.cleaned_data.get('created_from'):",
            "            opq = opq.filter(order__datetime__gte=form.cleaned_data.get('created_from'))",
            "        if form.cleaned_data.get('created_to'):",
            "            opq = opq.filter(order__datetime__lt=form.cleaned_data.get('created_to'))",
            "",
            "        # pk__in turns out to be faster than Exists(subquery) in many cases since we often filter on a large subset",
            "        # of orderpositions",
            "        return orders.filter(pk__in=opq.values_list('order_id'))",
            "",
            "    def describe_match_size(self, cnt):",
            "        return ngettext(",
            "            '%(number)s matching order',",
            "            '%(number)s matching orders',",
            "            cnt or 0,",
            "        ) % {",
            "            'number': intcomma(cnt or 0),",
            "        }",
            "",
            "    def get_task_kwargs(self, form, objects):",
            "        kwargs = super().get_task_kwargs(form, objects)",
            "        kwargs.update({",
            "            'recipients': form.cleaned_data['recipients'],",
            "            'items': [i.pk for i in form.cleaned_data.get('items')],",
            "            'not_checked_in': form.cleaned_data.get('not_checked_in'),",
            "            'checkin_lists': [i.pk for i in form.cleaned_data.get('checkin_lists')],",
            "            'filter_checkins': form.cleaned_data.get('filter_checkins'),",
            "            'attach_tickets': form.cleaned_data.get('attach_tickets'),",
            "            'attach_ical': form.cleaned_data.get('attach_ical'),",
            "        })",
            "        return kwargs",
            "",
            "",
            "class WaitinglistSendView(BaseSenderView):",
            "    form_class = forms.WaitinglistMailForm",
            "    form_fragment_name = \"pretixplugins/sendmail/send_form_fragment_waitinglist.html\"",
            "    context_parameters = ['event', 'waiting_list_entry', 'event_or_subevent']",
            "    task = send_mails_to_waitinglist",
            "",
            "    ACTION_TYPE = 'pretix.plugins.sendmail.sent.waitinglist'",
            "    TITLE = _(\"Waiting list\")",
            "    DESCRIPTION = _(\"Send an email to every person currently waiting to receive a voucher through the waiting \"",
            "                    \"list feature.\")",
            "",
            "    @classmethod",
            "    def show_history_meta_data(cls, logentry, _cache_store):",
            "        if 'itemcache' not in _cache_store:",
            "            _cache_store['itemcache'] = {",
            "                i.pk: str(i) for i in logentry.event.items.all()",
            "            }",
            "",
            "        tpl = get_template('pretixplugins/sendmail/history_fragment_waitinglist.html')",
            "        logentry.pdata['items'] = [",
            "            _cache_store['itemcache'].get(i['id'], '?') for i in logentry.pdata.get('items', [])",
            "        ]",
            "        if logentry.pdata.get('subevent'):",
            "            try:",
            "                logentry.pdata['subevent_obj'] = logentry.event.subevents.get(pk=logentry.pdata['subevent']['id'])",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return tpl.render({",
            "            'log': logentry,",
            "        })",
            "",
            "    @classmethod",
            "    def get_url(cls, event):",
            "        return reverse(",
            "            'plugins:sendmail:send.waitinglist',",
            "            kwargs={",
            "                'event': event.slug,",
            "                'organizer': event.organizer.slug,",
            "            }",
            "        )",
            "",
            "    def initial_from_logentry(self, logentry: LogEntry):",
            "        initial = super().initial_from_logentry(logentry)",
            "        if 'items' in logentry.parsed_data:",
            "            initial['items'] = self.request.event.items.filter(",
            "                id__in=[a['id'] for a in logentry.parsed_data['items']]",
            "            )",
            "        if logentry.parsed_data.get('subevents_from'):",
            "            initial['subevents_from'] = dateutil.parser.parse(logentry.parsed_data['subevents_from'])",
            "        if logentry.parsed_data.get('subevents_to'):",
            "            initial['subevents_to'] = dateutil.parser.parse(logentry.parsed_data['subevents_to'])",
            "        if logentry.parsed_data.get('subevent'):",
            "            try:",
            "                initial['subevent'] = self.request.event.subevents.get(",
            "                    pk=logentry.parsed_data['subevent']['id']",
            "                )",
            "            except SubEvent.DoesNotExist:",
            "                pass",
            "        return initial",
            "",
            "    def get_object_queryset(self, form):",
            "        qs = self.request.event.waitinglistentries.filter(voucher__isnull=True)",
            "",
            "        qs = qs.filter(item__in=[i.pk for i in form.cleaned_data.get('items')])",
            "        if form.cleaned_data.get('subevent'):",
            "            qs = qs.filter(subevent=form.cleaned_data.get('subevent'))",
            "        if form.cleaned_data.get('subevents_from'):",
            "            qs = qs.filter(subevent__date_from__gte=form.cleaned_data.get('subevents_from'))",
            "        if form.cleaned_data.get('subevents_to'):",
            "            qs = qs.filter(subevent__date_from__lt=form.cleaned_data.get('subevents_to'))",
            "",
            "        return qs",
            "",
            "    def describe_match_size(self, cnt):",
            "        return ngettext(",
            "            '%(number)s waiting list entry',",
            "            '%(number)s waiting list entries',",
            "            cnt or 0,",
            "        ) % {",
            "            'number': intcomma(cnt or 0),",
            "        }",
            "",
            "",
            "class EmailHistoryView(EventPermissionRequiredMixin, ListView):",
            "    template_name = 'pretixplugins/sendmail/history.html'",
            "    permission = 'can_change_orders'",
            "    model = LogEntry",
            "    context_object_name = 'logs'",
            "    paginate_by = 5",
            "",
            "    @cached_property",
            "    def type_map(self):",
            "        from .signals import sendmail_view_classes",
            "        classes = []",
            "        for recv, resp in sendmail_view_classes.send(self.request.event):",
            "            if isinstance(resp, (list, tuple)):",
            "                classes += resp",
            "            else:",
            "                classes.append(resp)",
            "        return {",
            "            cls.ACTION_TYPE: cls",
            "            for cls in classes",
            "        }",
            "",
            "    def get_queryset(self):",
            "        qs = LogEntry.objects.filter(",
            "            event=self.request.event,",
            "            action_type__in=self.type_map.keys(),",
            "        ).select_related('event', 'user')",
            "        return qs",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data()",
            "        _cache = {}",
            "        for log in ctx['logs']:",
            "            log.pdata = log.parsed_data",
            "            log.pdata['locales'] = {}",
            "            for locale, msg in log.pdata['message'].items():",
            "                log.pdata['locales'][locale] = {",
            "                    'message': msg,",
            "                    'subject': log.pdata['subject'][locale]",
            "                }",
            "            log.view = {",
            "                'url': self.type_map[log.action_type].get_url(self.request.event),",
            "                'title': self.type_map[log.action_type].TITLE,",
            "                'rendered_data': self.type_map[log.action_type].show_history_meta_data(log, _cache)",
            "            }",
            "",
            "        return ctx",
            "",
            "",
            "class CreateRule(EventPermissionRequiredMixin, CreateView):",
            "    template_name = 'pretixplugins/sendmail/rule_create.html'",
            "    permission = 'can_change_event_settings'",
            "    form_class = forms.RuleForm",
            "",
            "    model = Rule",
            "",
            "    @cached_property",
            "    def copy_from(self):",
            "        if self.request.GET.get(\"copy_from\") and not getattr(self, 'object', None):",
            "            try:",
            "                return Rule.objects.get(pk=self.request.GET.get(\"copy_from\"), event=self.request.event)",
            "            except Rule.DoesNotExist:",
            "                pass",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs['event'] = self.request.event",
            "",
            "        if self.copy_from:",
            "            i = modelcopy(self.copy_from)",
            "            i.pk = None",
            "            i.redeemed = 0",
            "            kwargs[\"instance\"] = i",
            "        return kwargs",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def form_valid(self, form):",
            "        self.output = {}",
            "",
            "        if self.request.POST.get(\"action\") == \"preview\":",
            "            for l in self.request.event.settings.locales:",
            "                with language(l, self.request.event.settings.region):",
            "                    context_dict = {}",
            "                    for k, v in get_available_placeholders(self.request.event, ['event', 'order',",
            "                                                                                'position_or_address']).items():",
            "                        context_dict[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                            _('This value will be replaced based on dynamic parameters.'),",
            "                            escape(v.render_sample(self.request.event))",
            "                        )",
            "",
            "                    subject = bleach.clean(form.cleaned_data['subject'].localize(l), tags=[])",
            "                    preview_subject = format_map(subject, context_dict)",
            "                    template = form.cleaned_data['template'].localize(l)",
            "                    preview_text = markdown_compile_email(format_map(template, context_dict))",
            "",
            "                    self.output[l] = {",
            "                        'subject': _('Subject: {subject}').format(subject=preview_subject),",
            "                        'html': preview_text,",
            "                    }",
            "",
            "            return self.get(self.request, *self.args, **self.kwargs)",
            "",
            "        messages.success(self.request, _('Your rule has been created.'))",
            "",
            "        form.instance.event = self.request.event",
            "",
            "        with transaction.atomic():",
            "            self.object = form.save()",
            "            form.instance.log_action('pretix.plugins.sendmail.rule.added', user=self.request.user,",
            "                                     data=dict(form.cleaned_data))",
            "",
            "        return redirect(",
            "            'plugins:sendmail:rule.update',",
            "            event=self.request.event.slug,",
            "            organizer=self.request.event.organizer.slug,",
            "            rule=self.object.pk,",
            "        )",
            "",
            "",
            "class UpdateRule(EventPermissionRequiredMixin, UpdateView):",
            "    model = Rule",
            "    form_class = forms.RuleForm",
            "    template_name = 'pretixplugins/sendmail/rule_update.html'",
            "    permission = 'can_change_event_settings'",
            "",
            "    def get_object(self, queryset=None) -> Rule:",
            "        return get_object_or_404(",
            "            Rule.objects.annotate(",
            "                total_mails=Count('scheduledmail'),",
            "                sent_mails=Count('scheduledmail', filter=Q(scheduledmail__state=ScheduledMail.STATE_COMPLETED)),",
            "            ),",
            "            event=self.request.event,",
            "            id=self.kwargs['rule']",
            "        )",
            "",
            "    def get_success_url(self):",
            "        return reverse('plugins:sendmail:rule.update', kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "            'rule': self.object.pk,",
            "        })",
            "",
            "    @transaction.atomic()",
            "    def form_valid(self, form):",
            "        messages.success(self.request, _('Your changes have been saved.'))",
            "        form.instance.log_action('pretix.plugins.sendmail.rule.changed', user=self.request.user,",
            "                                 data=dict(form.cleaned_data))",
            "        return super().form_valid(form)",
            "",
            "    def form_invalid(self, form):",
            "        messages.error(self.request, _('We could not save your changes. See below for details.'))",
            "        return super().form_invalid(form)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        o = {}",
            "",
            "        for lang in self.request.event.settings.locales:",
            "            with language(lang, self.request.event.settings.region):",
            "                placeholders = {}",
            "                for k, v in get_available_placeholders(self.request.event, ['event', 'order', 'position_or_address']).items():",
            "                    placeholders[k] = '<span class=\"placeholder\" title=\"{}\">{}</span>'.format(",
            "                        _('This value will be replaced based on dynamic parameters.'),",
            "                        escape(v.render_sample(self.request.event))",
            "                    )",
            "",
            "                subject = bleach.clean(self.object.subject.localize(lang), tags=[])",
            "                preview_subject = format_map(subject, placeholders)",
            "                template = self.object.template.localize(lang)",
            "                preview_text = markdown_compile_email(format_map(template, placeholders))",
            "",
            "                o[lang] = {",
            "                    'subject': _('Subject: {subject}'.format(subject=preview_subject)),",
            "                    'html': preview_text,",
            "                }",
            "",
            "        ctx['output'] = o",
            "",
            "        return ctx",
            "",
            "",
            "class ListRules(EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    template_name = 'pretixplugins/sendmail/rule_list.html'",
            "    model = Rule",
            "    context_object_name = 'rules'",
            "",
            "    def get_queryset(self):",
            "        return self.request.event.sendmail_rules.annotate(",
            "            total_mails=Count('scheduledmail'),",
            "            sent_mails=Count('scheduledmail', filter=Q(scheduledmail__state=ScheduledMail.STATE_COMPLETED)),",
            "            last_execution=Max(",
            "                'scheduledmail__computed_datetime',",
            "                filter=Q(scheduledmail__state=ScheduledMail.STATE_COMPLETED)",
            "            ),",
            "            next_execution=Min(",
            "                'scheduledmail__computed_datetime',",
            "                filter=Q(scheduledmail__state=ScheduledMail.STATE_SCHEDULED)",
            "            ),",
            "        ).prefetch_related(",
            "            'limit_products'",
            "        ).order_by('-send_date', 'subject', 'pk')",
            "",
            "",
            "class DeleteRule(EventPermissionRequiredMixin, DeleteView):",
            "    model = Rule",
            "    permission = 'can_change_event_settings'",
            "    template_name = 'pretixplugins/sendmail/rule_delete.html'",
            "    context_object_name = 'rule'",
            "",
            "    def get_success_url(self):",
            "        return reverse(\"plugins:sendmail:rule.list\", kwargs={",
            "            'organizer': self.request.event.organizer.slug,",
            "            'event': self.request.event.slug,",
            "        })",
            "",
            "    def get_object(self, queryset=None) -> Rule:",
            "        return get_object_or_404(Rule, event=self.request.event, id=self.kwargs['rule'])",
            "",
            "    @transaction.atomic",
            "    def delete(self, request, *args, **kwargs):",
            "        self.object = self.get_object()",
            "        success_url = self.get_success_url()",
            "",
            "        self.request.event.log_action('pretix.plugins.sendmail.rule.deleted',",
            "                                      user=self.request.user,",
            "                                      data={",
            "                                          'subject': self.object.subject,",
            "                                          'text': self.object.template,",
            "                                      })",
            "",
            "        self.object.delete()",
            "        messages.success(self.request, _('The selected rule has been deleted.'))",
            "        return HttpResponseRedirect(success_url)",
            "",
            "",
            "class ScheduleView(EventPermissionRequiredMixin, PaginationMixin, ListView):",
            "    template_name = 'pretixplugins/sendmail/rule_inspect.html'",
            "    model = ScheduledMail",
            "    context_object_name = 'scheduled_mails'",
            "",
            "    @cached_property",
            "    def rule(self):",
            "        return get_object_or_404(Rule, event=self.request.event, id=self.kwargs['rule'])",
            "",
            "    def get_queryset(self):",
            "        return self.rule.scheduledmail_set.select_related('subevent').order_by(",
            "            '-computed_datetime', '-pk'",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        ctx = super().get_context_data(**kwargs)",
            "        ctx['rule'] = self.rule",
            "        return ctx"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "196": [
                "BaseSenderView",
                "form_valid"
            ],
            "611": [
                "CreateRule",
                "form_valid"
            ],
            "687": [
                "UpdateRule",
                "get_context_data"
            ]
        },
        "addLocation": []
    }
}