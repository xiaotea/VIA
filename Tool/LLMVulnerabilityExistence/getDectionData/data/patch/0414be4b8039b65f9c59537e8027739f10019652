{
    "libs/experimental/langchain_experimental/llm_symbolic_math/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         extra=\"forbid\","
            },
            "1": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     )"
            },
            "2": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    allow_dangerous_requests: bool  # Assign no default."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    \"\"\"Must be set by the user to allow dangerous requests or not."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    We recommend a default of False to allow only pre-defined symbolic operations."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    When set to True, the chain will allow any kind of input. This is "
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    STRONGLY DISCOURAGED unless you fully trust the input (and believe that "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    the LLM itself cannot behave in a malicious way)."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    You should absolutely NOT be deploying this in a production environment"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    with allow_dangerous_requests=True. As this would allow a malicious actor"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    to execute arbitrary code on your system."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    Use default=True at your own risk."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    When set to False, the chain will only allow pre-defined symbolic operations."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    If the some symbolic expressions are failing to evaluate, you can open a PR"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    to add them to extend the list of allowed operations."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    def __init__(self, **kwargs: Any) -> None:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        if \"allow_dangerous_requests\" not in kwargs:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            raise ValueError("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                \"LLMSymbolicMathChain requires allow_dangerous_requests to be set. \""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                \"We recommend that you set `allow_dangerous_requests=False` to allow \""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                \"only pre-defined symbolic operations. \""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                \"If the some symbolic expressions are failing to evaluate, you can \""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                \"open a PR to add them to extend the list of allowed operations. \""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                \"Alternatively, you can set `allow_dangerous_requests=True` to allow \""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                \"any kind of input but this is STRONGLY DISCOURAGED unless you \""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                \"fully trust the input (and believe that the LLM itself cannot behave \""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                \"in a malicious way).\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                \"You should absolutely NOT be deploying this in a production \""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                \"environment with allow_dangerous_requests=True. As \""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                \"this would allow a malicious actor to execute arbitrary code on \""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                \"your system.\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+            )"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        super().__init__(**kwargs)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     @property"
            },
            "42": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     def input_keys(self) -> List[str]:"
            },
            "43": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         \"\"\"Expect input key."
            },
            "44": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "             raise ImportError("
            },
            "45": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "                 \"Unable to import sympy, please install it with `pip install sympy`.\""
            },
            "46": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "             ) from e"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         try:"
            },
            "49": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            output = str(sympy.sympify(expression, evaluate=True))"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            if self.allow_dangerous_requests:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+                output = str(sympy.sympify(expression, evaluate=True))"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+            else:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+                allowed_symbols = {"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+                    # Basic arithmetic and trigonometry"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+                    \"sin\": sympy.sin,"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+                    \"cos\": sympy.cos,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                    \"tan\": sympy.tan,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+                    \"cot\": sympy.cot,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+                    \"sec\": sympy.sec,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+                    \"csc\": sympy.csc,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                    \"asin\": sympy.asin,"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                    \"acos\": sympy.acos,"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+                    \"atan\": sympy.atan,"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                    # Hyperbolic functions"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+                    \"sinh\": sympy.sinh,"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+                    \"cosh\": sympy.cosh,"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+                    \"tanh\": sympy.tanh,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+                    \"asinh\": sympy.asinh,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+                    \"acosh\": sympy.acosh,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+                    \"atanh\": sympy.atanh,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+                    # Exponentials and logarithms"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+                    \"exp\": sympy.exp,"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+                    \"log\": sympy.log,"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+                    \"ln\": sympy.log,  # natural log sympy defaults to natural log"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+                    \"log10\": lambda x: sympy.log(x, 10),  # log base 10 (use sympy.log)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+                    # Powers and roots"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+                    \"sqrt\": sympy.sqrt,"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+                    \"cbrt\": lambda x: sympy.Pow(x, sympy.Rational(1, 3)),"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+                    # Combinatorics and other math functions"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+                    \"factorial\": sympy.factorial,"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+                    \"binomial\": sympy.binomial,"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+                    \"gcd\": sympy.gcd,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+                    \"lcm\": sympy.lcm,"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+                    \"abs\": sympy.Abs,"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+                    \"sign\": sympy.sign,"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                    \"mod\": sympy.Mod,"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+                    # Constants"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+                    \"pi\": sympy.pi,"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+                    \"e\": sympy.E,"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                    \"I\": sympy.I,"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                    \"oo\": sympy.oo,"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                    \"NaN\": sympy.nan,"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+                }"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                # Use parse_expr with strict settings"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                output = str("
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                    sympy.parse_expr("
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+                        expression, local_dict=allowed_symbols, evaluate=True"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                    )"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                )"
            },
            "101": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         except Exception as e:"
            },
            "102": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "             raise ValueError("
            },
            "103": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "                 f'LLMSymbolicMathChain._evaluate(\"{expression}\") raised error: {e}.'"
            }
        },
        "frontPatchFile": [
            "\"\"\"Chain that interprets a prompt and executes python code to do symbolic math.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import re",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.base_language import BaseLanguageModel",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain_core.callbacks.manager import (",
            "    AsyncCallbackManagerForChainRun,",
            "    CallbackManagerForChainRun,",
            ")",
            "from langchain_core.prompts.base import BasePromptTemplate",
            "from pydantic import ConfigDict",
            "",
            "from langchain_experimental.llm_symbolic_math.prompt import PROMPT",
            "",
            "",
            "class LLMSymbolicMathChain(Chain):",
            "    \"\"\"Chain that interprets a prompt and executes python code to do symbolic math.",
            "",
            "    It is based on the sympy library and can be used to evaluate",
            "    mathematical expressions.",
            "    See https://www.sympy.org/ for more information.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            from langchain.chains import LLMSymbolicMathChain",
            "            from langchain_community.llms import OpenAI",
            "            llm_symbolic_math = LLMSymbolicMathChain.from_llm(OpenAI())",
            "    \"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    input_key: str = \"question\"  #: :meta private:",
            "    output_key: str = \"answer\"  #: :meta private:",
            "",
            "    model_config = ConfigDict(",
            "        arbitrary_types_allowed=True,",
            "        extra=\"forbid\",",
            "    )",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Expect input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.input_key]",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Expect output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.output_key]",
            "",
            "    def _evaluate_expression(self, expression: str) -> str:",
            "        try:",
            "            import sympy",
            "        except ImportError as e:",
            "            raise ImportError(",
            "                \"Unable to import sympy, please install it with `pip install sympy`.\"",
            "            ) from e",
            "        try:",
            "            output = str(sympy.sympify(expression, evaluate=True))",
            "        except Exception as e:",
            "            raise ValueError(",
            "                f'LLMSymbolicMathChain._evaluate(\"{expression}\") raised error: {e}.'",
            "                \" Please try again with a valid numerical expression\"",
            "            )",
            "",
            "        # Remove any leading and trailing brackets from the output",
            "        return re.sub(r\"^\\[|\\]$\", \"\", output)",
            "",
            "    def _process_llm_result(",
            "        self, llm_output: str, run_manager: CallbackManagerForChainRun",
            "    ) -> Dict[str, str]:",
            "        run_manager.on_text(llm_output, color=\"green\", verbose=self.verbose)",
            "        llm_output = llm_output.strip()",
            "        text_match = re.search(r\"^```text(.*?)```\", llm_output, re.DOTALL)",
            "        if text_match:",
            "            expression = text_match.group(1)",
            "            output = self._evaluate_expression(expression)",
            "            run_manager.on_text(\"\\nAnswer: \", verbose=self.verbose)",
            "            run_manager.on_text(output, color=\"yellow\", verbose=self.verbose)",
            "            answer = \"Answer: \" + output",
            "        elif llm_output.startswith(\"Answer:\"):",
            "            answer = llm_output",
            "        elif \"Answer:\" in llm_output:",
            "            answer = \"Answer: \" + llm_output.split(\"Answer:\")[-1]",
            "        else:",
            "            raise ValueError(f\"unknown format from LLM: {llm_output}\")",
            "        return {self.output_key: answer}",
            "",
            "    async def _aprocess_llm_result(",
            "        self,",
            "        llm_output: str,",
            "        run_manager: AsyncCallbackManagerForChainRun,",
            "    ) -> Dict[str, str]:",
            "        await run_manager.on_text(llm_output, color=\"green\", verbose=self.verbose)",
            "        llm_output = llm_output.strip()",
            "        text_match = re.search(r\"^```text(.*?)```\", llm_output, re.DOTALL)",
            "        if text_match:",
            "            expression = text_match.group(1)",
            "            output = self._evaluate_expression(expression)",
            "            await run_manager.on_text(\"\\nAnswer: \", verbose=self.verbose)",
            "            await run_manager.on_text(output, color=\"yellow\", verbose=self.verbose)",
            "            answer = \"Answer: \" + output",
            "        elif llm_output.startswith(\"Answer:\"):",
            "            answer = llm_output",
            "        elif \"Answer:\" in llm_output:",
            "            answer = \"Answer: \" + llm_output.split(\"Answer:\")[-1]",
            "        else:",
            "            raise ValueError(f\"unknown format from LLM: {llm_output}\")",
            "        return {self.output_key: answer}",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, str],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        _run_manager.on_text(inputs[self.input_key])",
            "        llm_output = self.llm_chain.predict(",
            "            question=inputs[self.input_key],",
            "            stop=[\"```output\"],",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return self._process_llm_result(llm_output, _run_manager)",
            "",
            "    async def _acall(",
            "        self,",
            "        inputs: Dict[str, str],",
            "        run_manager: Optional[AsyncCallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or AsyncCallbackManagerForChainRun.get_noop_manager()",
            "        await _run_manager.on_text(inputs[self.input_key])",
            "        llm_output = await self.llm_chain.apredict(",
            "            question=inputs[self.input_key],",
            "            stop=[\"```output\"],",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return await self._aprocess_llm_result(llm_output, _run_manager)",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"llm_symbolic_math_chain\"",
            "",
            "    @classmethod",
            "    def from_llm(",
            "        cls,",
            "        llm: BaseLanguageModel,",
            "        prompt: BasePromptTemplate = PROMPT,",
            "        **kwargs: Any,",
            "    ) -> LLMSymbolicMathChain:",
            "        llm_chain = LLMChain(llm=llm, prompt=prompt)",
            "        return cls(llm_chain=llm_chain, **kwargs)"
        ],
        "afterPatchFile": [
            "\"\"\"Chain that interprets a prompt and executes python code to do symbolic math.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import re",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.base_language import BaseLanguageModel",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain_core.callbacks.manager import (",
            "    AsyncCallbackManagerForChainRun,",
            "    CallbackManagerForChainRun,",
            ")",
            "from langchain_core.prompts.base import BasePromptTemplate",
            "from pydantic import ConfigDict",
            "",
            "from langchain_experimental.llm_symbolic_math.prompt import PROMPT",
            "",
            "",
            "class LLMSymbolicMathChain(Chain):",
            "    \"\"\"Chain that interprets a prompt and executes python code to do symbolic math.",
            "",
            "    It is based on the sympy library and can be used to evaluate",
            "    mathematical expressions.",
            "    See https://www.sympy.org/ for more information.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            from langchain.chains import LLMSymbolicMathChain",
            "            from langchain_community.llms import OpenAI",
            "            llm_symbolic_math = LLMSymbolicMathChain.from_llm(OpenAI())",
            "    \"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    input_key: str = \"question\"  #: :meta private:",
            "    output_key: str = \"answer\"  #: :meta private:",
            "",
            "    model_config = ConfigDict(",
            "        arbitrary_types_allowed=True,",
            "        extra=\"forbid\",",
            "    )",
            "",
            "    allow_dangerous_requests: bool  # Assign no default.",
            "    \"\"\"Must be set by the user to allow dangerous requests or not.",
            "",
            "    We recommend a default of False to allow only pre-defined symbolic operations.",
            "",
            "    When set to True, the chain will allow any kind of input. This is ",
            "    STRONGLY DISCOURAGED unless you fully trust the input (and believe that ",
            "    the LLM itself cannot behave in a malicious way).",
            "    You should absolutely NOT be deploying this in a production environment",
            "    with allow_dangerous_requests=True. As this would allow a malicious actor",
            "    to execute arbitrary code on your system.",
            "    Use default=True at your own risk.",
            "",
            "",
            "    When set to False, the chain will only allow pre-defined symbolic operations.",
            "    If the some symbolic expressions are failing to evaluate, you can open a PR",
            "    to add them to extend the list of allowed operations.",
            "    \"\"\"",
            "",
            "    def __init__(self, **kwargs: Any) -> None:",
            "        if \"allow_dangerous_requests\" not in kwargs:",
            "            raise ValueError(",
            "                \"LLMSymbolicMathChain requires allow_dangerous_requests to be set. \"",
            "                \"We recommend that you set `allow_dangerous_requests=False` to allow \"",
            "                \"only pre-defined symbolic operations. \"",
            "                \"If the some symbolic expressions are failing to evaluate, you can \"",
            "                \"open a PR to add them to extend the list of allowed operations. \"",
            "                \"Alternatively, you can set `allow_dangerous_requests=True` to allow \"",
            "                \"any kind of input but this is STRONGLY DISCOURAGED unless you \"",
            "                \"fully trust the input (and believe that the LLM itself cannot behave \"",
            "                \"in a malicious way).\"",
            "                \"You should absolutely NOT be deploying this in a production \"",
            "                \"environment with allow_dangerous_requests=True. As \"",
            "                \"this would allow a malicious actor to execute arbitrary code on \"",
            "                \"your system.\"",
            "            )",
            "        super().__init__(**kwargs)",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Expect input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.input_key]",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Expect output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.output_key]",
            "",
            "    def _evaluate_expression(self, expression: str) -> str:",
            "        try:",
            "            import sympy",
            "        except ImportError as e:",
            "            raise ImportError(",
            "                \"Unable to import sympy, please install it with `pip install sympy`.\"",
            "            ) from e",
            "",
            "        try:",
            "            if self.allow_dangerous_requests:",
            "                output = str(sympy.sympify(expression, evaluate=True))",
            "            else:",
            "                allowed_symbols = {",
            "                    # Basic arithmetic and trigonometry",
            "                    \"sin\": sympy.sin,",
            "                    \"cos\": sympy.cos,",
            "                    \"tan\": sympy.tan,",
            "                    \"cot\": sympy.cot,",
            "                    \"sec\": sympy.sec,",
            "                    \"csc\": sympy.csc,",
            "                    \"asin\": sympy.asin,",
            "                    \"acos\": sympy.acos,",
            "                    \"atan\": sympy.atan,",
            "                    # Hyperbolic functions",
            "                    \"sinh\": sympy.sinh,",
            "                    \"cosh\": sympy.cosh,",
            "                    \"tanh\": sympy.tanh,",
            "                    \"asinh\": sympy.asinh,",
            "                    \"acosh\": sympy.acosh,",
            "                    \"atanh\": sympy.atanh,",
            "                    # Exponentials and logarithms",
            "                    \"exp\": sympy.exp,",
            "                    \"log\": sympy.log,",
            "                    \"ln\": sympy.log,  # natural log sympy defaults to natural log",
            "                    \"log10\": lambda x: sympy.log(x, 10),  # log base 10 (use sympy.log)",
            "                    # Powers and roots",
            "                    \"sqrt\": sympy.sqrt,",
            "                    \"cbrt\": lambda x: sympy.Pow(x, sympy.Rational(1, 3)),",
            "                    # Combinatorics and other math functions",
            "                    \"factorial\": sympy.factorial,",
            "                    \"binomial\": sympy.binomial,",
            "                    \"gcd\": sympy.gcd,",
            "                    \"lcm\": sympy.lcm,",
            "                    \"abs\": sympy.Abs,",
            "                    \"sign\": sympy.sign,",
            "                    \"mod\": sympy.Mod,",
            "                    # Constants",
            "                    \"pi\": sympy.pi,",
            "                    \"e\": sympy.E,",
            "                    \"I\": sympy.I,",
            "                    \"oo\": sympy.oo,",
            "                    \"NaN\": sympy.nan,",
            "                }",
            "",
            "                # Use parse_expr with strict settings",
            "                output = str(",
            "                    sympy.parse_expr(",
            "                        expression, local_dict=allowed_symbols, evaluate=True",
            "                    )",
            "                )",
            "        except Exception as e:",
            "            raise ValueError(",
            "                f'LLMSymbolicMathChain._evaluate(\"{expression}\") raised error: {e}.'",
            "                \" Please try again with a valid numerical expression\"",
            "            )",
            "",
            "        # Remove any leading and trailing brackets from the output",
            "        return re.sub(r\"^\\[|\\]$\", \"\", output)",
            "",
            "    def _process_llm_result(",
            "        self, llm_output: str, run_manager: CallbackManagerForChainRun",
            "    ) -> Dict[str, str]:",
            "        run_manager.on_text(llm_output, color=\"green\", verbose=self.verbose)",
            "        llm_output = llm_output.strip()",
            "        text_match = re.search(r\"^```text(.*?)```\", llm_output, re.DOTALL)",
            "        if text_match:",
            "            expression = text_match.group(1)",
            "            output = self._evaluate_expression(expression)",
            "            run_manager.on_text(\"\\nAnswer: \", verbose=self.verbose)",
            "            run_manager.on_text(output, color=\"yellow\", verbose=self.verbose)",
            "            answer = \"Answer: \" + output",
            "        elif llm_output.startswith(\"Answer:\"):",
            "            answer = llm_output",
            "        elif \"Answer:\" in llm_output:",
            "            answer = \"Answer: \" + llm_output.split(\"Answer:\")[-1]",
            "        else:",
            "            raise ValueError(f\"unknown format from LLM: {llm_output}\")",
            "        return {self.output_key: answer}",
            "",
            "    async def _aprocess_llm_result(",
            "        self,",
            "        llm_output: str,",
            "        run_manager: AsyncCallbackManagerForChainRun,",
            "    ) -> Dict[str, str]:",
            "        await run_manager.on_text(llm_output, color=\"green\", verbose=self.verbose)",
            "        llm_output = llm_output.strip()",
            "        text_match = re.search(r\"^```text(.*?)```\", llm_output, re.DOTALL)",
            "        if text_match:",
            "            expression = text_match.group(1)",
            "            output = self._evaluate_expression(expression)",
            "            await run_manager.on_text(\"\\nAnswer: \", verbose=self.verbose)",
            "            await run_manager.on_text(output, color=\"yellow\", verbose=self.verbose)",
            "            answer = \"Answer: \" + output",
            "        elif llm_output.startswith(\"Answer:\"):",
            "            answer = llm_output",
            "        elif \"Answer:\" in llm_output:",
            "            answer = \"Answer: \" + llm_output.split(\"Answer:\")[-1]",
            "        else:",
            "            raise ValueError(f\"unknown format from LLM: {llm_output}\")",
            "        return {self.output_key: answer}",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, str],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        _run_manager.on_text(inputs[self.input_key])",
            "        llm_output = self.llm_chain.predict(",
            "            question=inputs[self.input_key],",
            "            stop=[\"```output\"],",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return self._process_llm_result(llm_output, _run_manager)",
            "",
            "    async def _acall(",
            "        self,",
            "        inputs: Dict[str, str],",
            "        run_manager: Optional[AsyncCallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or AsyncCallbackManagerForChainRun.get_noop_manager()",
            "        await _run_manager.on_text(inputs[self.input_key])",
            "        llm_output = await self.llm_chain.apredict(",
            "            question=inputs[self.input_key],",
            "            stop=[\"```output\"],",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return await self._aprocess_llm_result(llm_output, _run_manager)",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"llm_symbolic_math_chain\"",
            "",
            "    @classmethod",
            "    def from_llm(",
            "        cls,",
            "        llm: BaseLanguageModel,",
            "        prompt: BasePromptTemplate = PROMPT,",
            "        **kwargs: Any,",
            "    ) -> LLMSymbolicMathChain:",
            "        llm_chain = LLMChain(llm=llm, prompt=prompt)",
            "        return cls(llm_chain=llm_chain, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "LLMSymbolicMathChain",
                "_evaluate_expression"
            ]
        },
        "addLocation": [
            "nicegui.nicegui",
            "libs.experimental.langchain_experimental.llm_symbolic_math.base.LLMSymbolicMathChain._process_llm_result",
            "libs.experimental.langchain_experimental.llm_symbolic_math.base.LLMSymbolicMathChain",
            "libs.experimental.langchain_experimental.llm_symbolic_math.base.LLMSymbolicMathChain.from_llm",
            "libs.experimental.langchain_experimental.llm_symbolic_math.base.LLMSymbolicMathChain._aprocess_llm_result",
            "libs.experimental.langchain_experimental.llm_symbolic_math.base.LLMSymbolicMathChain.self"
        ]
    },
    "libs/experimental/tests/unit_tests/test_llm_symbolic_math.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "             question=\"What are the solutions to this equation x**2 - x?\""
            },
            "1": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         ): \"```text\\nsolveset(x**2 - x, x)\\n```\","
            },
            "2": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         _PROMPT_TEMPLATE.format(question=\"foo\"): \"foo\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        _PROMPT_TEMPLATE.format(question=\"__import__('os')\"): \"__import__('os')\","
            },
            "4": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     }"
            },
            "5": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     fake_llm = FakeLLM(queries=queries)"
            },
            "6": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return LLMSymbolicMathChain.from_llm(fake_llm, input_key=\"q\", output_key=\"a\")"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    return LLMSymbolicMathChain.from_llm("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        fake_llm, input_key=\"q\", output_key=\"a\", allow_dangerous_requests=False"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    )"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+def test_require_allow_dangerous_requests_to_be_set() -> None:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    \"\"\"Test that allow_dangerous_requests must be set.\"\"\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    fake_llm = FakeLLM(queries={})"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        LLMSymbolicMathChain.from_llm(fake_llm, input_key=\"q\", output_key=\"a\")"
            },
            "18": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " def test_simple_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:"
            },
            "21": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     \"\"\"Test question that raises error.\"\"\""
            },
            "22": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     with pytest.raises(ValueError):"
            },
            "23": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         fake_llm_symbolic_math_chain.run(\"foo\")"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+def test_security_vulnerability("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    fake_llm_symbolic_math_chain: LLMSymbolicMathChain,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+) -> None:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    \"\"\"Test for potential security vulnerability with malicious input.\"\"\""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    # Example of a code injection attempt"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    malicious_input = \"__import__('os')\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+    # Run the chain with the malicious input and ensure it raises an error"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        fake_llm_symbolic_math_chain.run(malicious_input)"
            }
        },
        "frontPatchFile": [
            "\"\"\"Test LLM Math functionality.\"\"\"",
            "",
            "import pytest",
            "",
            "from langchain_experimental.llm_symbolic_math.base import (",
            "    LLMSymbolicMathChain,",
            ")",
            "from langchain_experimental.llm_symbolic_math.prompt import (",
            "    _PROMPT_TEMPLATE,",
            ")",
            "from tests.unit_tests.fake_llm import FakeLLM",
            "",
            "try:",
            "    import sympy",
            "except ImportError:",
            "    pytest.skip(\"sympy not installed\", allow_module_level=True)",
            "",
            "",
            "@pytest.fixture",
            "def fake_llm_symbolic_math_chain() -> LLMSymbolicMathChain:",
            "    \"\"\"Fake LLM Math chain for testing.\"\"\"",
            "    queries = {",
            "        _PROMPT_TEMPLATE.format(question=\"What is 1 plus 1?\"): \"Answer: 2\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What is the square root of 2?\"",
            "        ): \"```text\\nsqrt(2)\\n```\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What is the limit of sin(x) / x as x goes to 0?\"",
            "        ): \"```text\\nlimit(sin(x)/x,x,0)\\n```\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What is the integral of e^-x from 0 to infinity?\"",
            "        ): \"```text\\nintegrate(exp(-x), (x, 0, oo))\\n```\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What are the solutions to this equation x**2 - x?\"",
            "        ): \"```text\\nsolveset(x**2 - x, x)\\n```\",",
            "        _PROMPT_TEMPLATE.format(question=\"foo\"): \"foo\",",
            "    }",
            "    fake_llm = FakeLLM(queries=queries)",
            "    return LLMSymbolicMathChain.from_llm(fake_llm, input_key=\"q\", output_key=\"a\")",
            "",
            "",
            "def test_simple_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test simple question that should not need python.\"\"\"",
            "    question = \"What is 1 plus 1?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: 2\"",
            "",
            "",
            "def test_root_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test irrational number that should need sympy.\"\"\"",
            "    question = \"What is the square root of 2?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == f\"Answer: {sympy.sqrt(2)}\"",
            "",
            "",
            "def test_limit_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test question about limits that needs sympy\"\"\"",
            "    question = \"What is the limit of sin(x) / x as x goes to 0?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: 1\"",
            "",
            "",
            "def test_integration_question(",
            "    fake_llm_symbolic_math_chain: LLMSymbolicMathChain,",
            ") -> None:",
            "    \"\"\"Test question about integration that needs sympy\"\"\"",
            "    question = \"What is the integral of e^-x from 0 to infinity?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: 1\"",
            "",
            "",
            "def test_solver_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test question about solving algebraic equations that needs sympy\"\"\"",
            "    question = \"What are the solutions to this equation x**2 - x?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: {0, 1}\"",
            "",
            "",
            "def test_error(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test question that raises error.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        fake_llm_symbolic_math_chain.run(\"foo\")"
        ],
        "afterPatchFile": [
            "\"\"\"Test LLM Math functionality.\"\"\"",
            "",
            "import pytest",
            "",
            "from langchain_experimental.llm_symbolic_math.base import (",
            "    LLMSymbolicMathChain,",
            ")",
            "from langchain_experimental.llm_symbolic_math.prompt import (",
            "    _PROMPT_TEMPLATE,",
            ")",
            "from tests.unit_tests.fake_llm import FakeLLM",
            "",
            "try:",
            "    import sympy",
            "except ImportError:",
            "    pytest.skip(\"sympy not installed\", allow_module_level=True)",
            "",
            "",
            "@pytest.fixture",
            "def fake_llm_symbolic_math_chain() -> LLMSymbolicMathChain:",
            "    \"\"\"Fake LLM Math chain for testing.\"\"\"",
            "    queries = {",
            "        _PROMPT_TEMPLATE.format(question=\"What is 1 plus 1?\"): \"Answer: 2\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What is the square root of 2?\"",
            "        ): \"```text\\nsqrt(2)\\n```\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What is the limit of sin(x) / x as x goes to 0?\"",
            "        ): \"```text\\nlimit(sin(x)/x,x,0)\\n```\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What is the integral of e^-x from 0 to infinity?\"",
            "        ): \"```text\\nintegrate(exp(-x), (x, 0, oo))\\n```\",",
            "        _PROMPT_TEMPLATE.format(",
            "            question=\"What are the solutions to this equation x**2 - x?\"",
            "        ): \"```text\\nsolveset(x**2 - x, x)\\n```\",",
            "        _PROMPT_TEMPLATE.format(question=\"foo\"): \"foo\",",
            "        _PROMPT_TEMPLATE.format(question=\"__import__('os')\"): \"__import__('os')\",",
            "    }",
            "    fake_llm = FakeLLM(queries=queries)",
            "    return LLMSymbolicMathChain.from_llm(",
            "        fake_llm, input_key=\"q\", output_key=\"a\", allow_dangerous_requests=False",
            "    )",
            "",
            "",
            "def test_require_allow_dangerous_requests_to_be_set() -> None:",
            "    \"\"\"Test that allow_dangerous_requests must be set.\"\"\"",
            "    fake_llm = FakeLLM(queries={})",
            "",
            "    with pytest.raises(ValueError):",
            "        LLMSymbolicMathChain.from_llm(fake_llm, input_key=\"q\", output_key=\"a\")",
            "",
            "",
            "def test_simple_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test simple question that should not need python.\"\"\"",
            "    question = \"What is 1 plus 1?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: 2\"",
            "",
            "",
            "def test_root_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test irrational number that should need sympy.\"\"\"",
            "    question = \"What is the square root of 2?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == f\"Answer: {sympy.sqrt(2)}\"",
            "",
            "",
            "def test_limit_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test question about limits that needs sympy\"\"\"",
            "    question = \"What is the limit of sin(x) / x as x goes to 0?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: 1\"",
            "",
            "",
            "def test_integration_question(",
            "    fake_llm_symbolic_math_chain: LLMSymbolicMathChain,",
            ") -> None:",
            "    \"\"\"Test question about integration that needs sympy\"\"\"",
            "    question = \"What is the integral of e^-x from 0 to infinity?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: 1\"",
            "",
            "",
            "def test_solver_question(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test question about solving algebraic equations that needs sympy\"\"\"",
            "    question = \"What are the solutions to this equation x**2 - x?\"",
            "    output = fake_llm_symbolic_math_chain.run(question)",
            "    assert output == \"Answer: {0, 1}\"",
            "",
            "",
            "def test_error(fake_llm_symbolic_math_chain: LLMSymbolicMathChain) -> None:",
            "    \"\"\"Test question that raises error.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        fake_llm_symbolic_math_chain.run(\"foo\")",
            "",
            "",
            "def test_security_vulnerability(",
            "    fake_llm_symbolic_math_chain: LLMSymbolicMathChain,",
            ") -> None:",
            "    \"\"\"Test for potential security vulnerability with malicious input.\"\"\"",
            "    # Example of a code injection attempt",
            "    malicious_input = \"__import__('os')\"",
            "",
            "    # Run the chain with the malicious input and ensure it raises an error",
            "    with pytest.raises(ValueError):",
            "        fake_llm_symbolic_math_chain.run(malicious_input)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "39": [
                "fake_llm_symbolic_math_chain"
            ]
        },
        "addLocation": [
            "libs.experimental.tests.unit_tests.test_llm_symbolic_math.fake_llm_symbolic_math_chain.queries",
            "nicegui.nicegui"
        ]
    }
}