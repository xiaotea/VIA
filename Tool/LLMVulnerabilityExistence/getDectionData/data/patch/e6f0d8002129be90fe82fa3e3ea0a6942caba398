{
    "rdiffweb/controller/tests/test_controller.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         Check if the theme is properly configure."
            },
            "2": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.getPage('/logout')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        self.getPage('/logout', method=\"POST\")"
            },
            "5": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         self.getPage(path)"
            },
            "6": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "7": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         # Test with invalid method."
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Mar 13, 2019",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "import datetime",
            "",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, SessionObject",
            "",
            "",
            "class ControllerTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    default_config = {'HeaderName': 'MyTest'}",
            "",
            "    def test_headername(self):",
            "        \"\"\"",
            "        Check if the headername is used in the page.",
            "        \"\"\"",
            "        self.getPage(\"/\")",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('MyTest')",
            "",
            "    def test_proxy(self):",
            "        \"\"\"",
            "        Check if the headername is used in the page.",
            "        \"\"\"",
            "        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com')])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('http://this.is.a.test.com/favicon.ico')",
            "",
            "    def test_proxy_https(self):",
            "        \"\"\"",
            "        Check if the headername is used in the page.",
            "        \"\"\"",
            "        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com'), ('X-Forwarded-Proto', 'https')])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('https://this.is.a.test.com/favicon.ico')",
            "",
            "    @parameterized.expand(",
            "        [",
            "            '/favicon.ico',",
            "            '/default.css',",
            "            '/logo',",
            "            '/header_logo',",
            "            '/static/css/bootstrap.min.css',",
            "            '/static/css/font-awesome.min.css',",
            "            '/static/css/jquery.dataTables.min.css',",
            "            '/static/js/bootstrap.bundle.min.js',",
            "            '/static/js/jquery.dataTables.min.js',",
            "            '/static/js/jquery.min.js',",
            "            '/static/js/rdiffweb.js',",
            "        ]",
            "    )",
            "    def test_static_files(self, path):",
            "        \"\"\"",
            "        Check if the theme is properly configure.",
            "        \"\"\"",
            "        self.getPage('/logout')",
            "        self.getPage(path)",
            "        self.assertStatus(200)",
            "        # Test with invalid method.",
            "        self.getPage(path, method=\"POST\")",
            "        self.assertStatus(400)",
            "",
            "    def test_static_invalid_file(self):",
            "        \"\"\"",
            "        Check if the theme is properly configure.",
            "        \"\"\"",
            "        self.getPage(\"/static/invalid.css\")",
            "        self.assertStatus(400)",
            "",
            "    def test_path_traversal(self):",
            "        self.getPage('/static//../../test.txt')",
            "        self.assertStatus(403)",
            "",
            "",
            "@parameterized_class(",
            "    [",
            "        {\"default_config\": {'DefaultTheme': 'default'}, \"expect_color\": '#35979c'},",
            "        {\"default_config\": {'DefaultTheme': 'orange'}, \"expect_color\": '#dd4814'},",
            "        {\"default_config\": {'DefaultTheme': 'blue'}, \"expect_color\": '#153a58'},",
            "        {\"default_config\": {'link-color': '111'}, \"expect_color\": '#111'},",
            "        {\"default_config\": {'navbar-color': '222'}, \"expect_color\": '#222'},",
            "        {\"default_config\": {'font-family': 'Sans'}, \"expect_color\": 'Sans'},",
            "    ]",
            ")",
            "class ControllerThemeTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {}",
            "",
            "    expect_color = ''",
            "",
            "    def test_static(self):",
            "        # Query css with uniq value to avoid caching.",
            "        self.getPage(\"/default.css\")",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody(self.expect_color)",
            "",
            "",
            "class ControllerSession(rdiffweb.test.WebCase):",
            "    def test_enrich_session_anonymous(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage('/', headers=[('User-Agent', 'test')])",
            "        # Then a session object is enriched",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNotNone(session.get('ip_address'))",
            "        self.assertIsNotNone(session.get('user_agent'))",
            "        self.assertIsNotNone(session.get('access_time'))",
            "",
            "    def test_enrich_session_authenticated(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage(",
            "            '/login/',",
            "            method='POST',",
            "            headers=[('User-Agent', 'test')],",
            "            body={'login': self.USERNAME, 'password': self.PASSWORD},",
            "        )",
            "        # Then a session object is enriched",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNotNone(session.get('ip_address'))",
            "        self.assertIsNotNone(session.get('user_agent'))",
            "        self.assertIsNotNone(session.get('access_time'))",
            "",
            "    def test_create_session(self):",
            "        # Given a server with no session.",
            "        self.assertEqual(0, len(SessionObject.query.all()))",
            "        # When querying a new page",
            "        self.getPage('/')",
            "        self.assertStatus(303)",
            "        # Then a new session get created",
            "        self.assertEqual(1, len(SessionObject.query.all()))",
            "        session = SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        self.assertIsNotNone(session)",
            "",
            "    def test_clean_up_session(self):",
            "        # Given a server with a session",
            "        self.getPage('/')",
            "        self.assertStatus(303)",
            "        self.assertEqual(1, len(SessionObject.query.all()))",
            "        # When this session get old",
            "        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        data.expiration_time = datetime.datetime.now() - datetime.timedelta(seconds=1)",
            "        data.commit()",
            "        session = DbSession(id=self.session_id)",
            "        # Then the session get deleted by clean_up process",
            "        session.clean_up()",
            "        # Then session is deleted",
            "        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        self.assertIsNone(data)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Mar 13, 2019",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "import datetime",
            "",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, SessionObject",
            "",
            "",
            "class ControllerTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    default_config = {'HeaderName': 'MyTest'}",
            "",
            "    def test_headername(self):",
            "        \"\"\"",
            "        Check if the headername is used in the page.",
            "        \"\"\"",
            "        self.getPage(\"/\")",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('MyTest')",
            "",
            "    def test_proxy(self):",
            "        \"\"\"",
            "        Check if the headername is used in the page.",
            "        \"\"\"",
            "        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com')])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('http://this.is.a.test.com/favicon.ico')",
            "",
            "    def test_proxy_https(self):",
            "        \"\"\"",
            "        Check if the headername is used in the page.",
            "        \"\"\"",
            "        self.getPage(\"/\", headers=[('Host', 'this.is.a.test.com'), ('X-Forwarded-Proto', 'https')])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('https://this.is.a.test.com/favicon.ico')",
            "",
            "    @parameterized.expand(",
            "        [",
            "            '/favicon.ico',",
            "            '/default.css',",
            "            '/logo',",
            "            '/header_logo',",
            "            '/static/css/bootstrap.min.css',",
            "            '/static/css/font-awesome.min.css',",
            "            '/static/css/jquery.dataTables.min.css',",
            "            '/static/js/bootstrap.bundle.min.js',",
            "            '/static/js/jquery.dataTables.min.js',",
            "            '/static/js/jquery.min.js',",
            "            '/static/js/rdiffweb.js',",
            "        ]",
            "    )",
            "    def test_static_files(self, path):",
            "        \"\"\"",
            "        Check if the theme is properly configure.",
            "        \"\"\"",
            "        self.getPage('/logout', method=\"POST\")",
            "        self.getPage(path)",
            "        self.assertStatus(200)",
            "        # Test with invalid method.",
            "        self.getPage(path, method=\"POST\")",
            "        self.assertStatus(400)",
            "",
            "    def test_static_invalid_file(self):",
            "        \"\"\"",
            "        Check if the theme is properly configure.",
            "        \"\"\"",
            "        self.getPage(\"/static/invalid.css\")",
            "        self.assertStatus(400)",
            "",
            "    def test_path_traversal(self):",
            "        self.getPage('/static//../../test.txt')",
            "        self.assertStatus(403)",
            "",
            "",
            "@parameterized_class(",
            "    [",
            "        {\"default_config\": {'DefaultTheme': 'default'}, \"expect_color\": '#35979c'},",
            "        {\"default_config\": {'DefaultTheme': 'orange'}, \"expect_color\": '#dd4814'},",
            "        {\"default_config\": {'DefaultTheme': 'blue'}, \"expect_color\": '#153a58'},",
            "        {\"default_config\": {'link-color': '111'}, \"expect_color\": '#111'},",
            "        {\"default_config\": {'navbar-color': '222'}, \"expect_color\": '#222'},",
            "        {\"default_config\": {'font-family': 'Sans'}, \"expect_color\": 'Sans'},",
            "    ]",
            ")",
            "class ControllerThemeTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {}",
            "",
            "    expect_color = ''",
            "",
            "    def test_static(self):",
            "        # Query css with uniq value to avoid caching.",
            "        self.getPage(\"/default.css\")",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody(self.expect_color)",
            "",
            "",
            "class ControllerSession(rdiffweb.test.WebCase):",
            "    def test_enrich_session_anonymous(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage('/', headers=[('User-Agent', 'test')])",
            "        # Then a session object is enriched",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNotNone(session.get('ip_address'))",
            "        self.assertIsNotNone(session.get('user_agent'))",
            "        self.assertIsNotNone(session.get('access_time'))",
            "",
            "    def test_enrich_session_authenticated(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage(",
            "            '/login/',",
            "            method='POST',",
            "            headers=[('User-Agent', 'test')],",
            "            body={'login': self.USERNAME, 'password': self.PASSWORD},",
            "        )",
            "        # Then a session object is enriched",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNotNone(session.get('ip_address'))",
            "        self.assertIsNotNone(session.get('user_agent'))",
            "        self.assertIsNotNone(session.get('access_time'))",
            "",
            "    def test_create_session(self):",
            "        # Given a server with no session.",
            "        self.assertEqual(0, len(SessionObject.query.all()))",
            "        # When querying a new page",
            "        self.getPage('/')",
            "        self.assertStatus(303)",
            "        # Then a new session get created",
            "        self.assertEqual(1, len(SessionObject.query.all()))",
            "        session = SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        self.assertIsNotNone(session)",
            "",
            "    def test_clean_up_session(self):",
            "        # Given a server with a session",
            "        self.getPage('/')",
            "        self.assertStatus(303)",
            "        self.assertEqual(1, len(SessionObject.query.all()))",
            "        # When this session get old",
            "        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        data.expiration_time = datetime.datetime.now() - datetime.timedelta(seconds=1)",
            "        data.commit()",
            "        session = DbSession(id=self.session_id)",
            "        # Then the session get deleted by clean_up process",
            "        session.clean_up()",
            "        # Then session is deleted",
            "        data = SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        self.assertIsNone(data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "80": [
                "ControllerTest",
                "test_static_files"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/controller/tests/test_page_admin_users.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "         # Create another admin user"
            },
            "2": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "         self._add_user('admin2', '', 'pr3j5Dwi', '', UserObject.ADMIN_ROLE)"
            },
            "3": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.getPage(\"/logout\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+        self.getPage(\"/logout\", method=\"POST\")"
            },
            "5": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "         self.assertStatus(303)"
            },
            "6": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "         self.assertHeaderItemValue('Location', self.baseurl + '/')"
            },
            "7": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "         self._login('admin2', 'pr3j5Dwi')"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from unittest.mock import ANY, MagicMock",
            "",
            "import cherrypy",
            "from parameterized import parameterized",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import UserObject",
            "",
            "",
            "class AbstractAdminTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self._quota = {}",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        self.listener.get_disk_quota.side_effect = self._load_quota",
            "        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)",
            "        self.listener.get_disk_usage.return_value = 0",
            "        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)",
            "        self.listener.set_disk_quota.side_effect = self._store_quota",
            "        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)",
            "        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)",
            "        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)",
            "        return super().tearDown()",
            "",
            "    def _store_quota(self, userobj, value):",
            "        self._quota[userobj.username] = value",
            "",
            "    def _load_quota(self, userobj):",
            "        return self._quota.get(userobj.username, 0)",
            "",
            "    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None, mfa=None, fullname=None):",
            "        b = {}",
            "        b['action'] = 'add'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        if mfa is not None:",
            "            b['mfa'] = str(mfa)",
            "        if fullname is not None:",
            "            b['fullname'] = str(fullname)",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _edit_user(",
            "        self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None, mfa=None",
            "    ):",
            "        b = {}",
            "        b['action'] = 'edit'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        if disk_quota is not None:",
            "            b['disk_quota'] = disk_quota",
            "        if mfa is not None:",
            "            b['mfa'] = str(mfa)",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _delete_user(self, username='test1'):",
            "        b = {'action': 'delete', 'username': username}",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def test_add_user_with_role_admin(self):",
            "        # When trying to create a new user with role admin",
            "        self._add_user(\"admin_role\", \"admin_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.ADMIN_ROLE)",
            "        # Then page return success",
            "        self.assertStatus(200)",
            "        # Then database is updated",
            "        userobj = UserObject.get_user('admin_role')",
            "        self.assertEqual(UserObject.ADMIN_ROLE, userobj.role)",
            "        # Then notification was raised",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_with_role_maintainer(self):",
            "        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.MAINTAINER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(UserObject.MAINTAINER_ROLE, UserObject.get_user('maintainer_role').role)",
            "",
            "    def test_add_user_with_role_user(self):",
            "        self._add_user(\"user_role\", \"user_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(UserObject.USER_ROLE, UserObject.get_user('user_role').role)",
            "",
            "    def test_add_user_with_invalid_role(self):",
            "        # When trying to create a new user with an invalid role (admin instead of 0)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", 'admin')",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('Role: Invalid Choice: could not coerce')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "        # When trying to create a new user with an invalid role (-1)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", -1)",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('User Role: Not a valid choice')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_edit_delete(self):",
            "        #  Add user to be listed",
            "        self.listener.user_password_changed.reset_mock()",
            "        self._add_user(",
            "            \"test2\", \"test2@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE, mfa=UserObject.DISABLED_MFA",
            "        )",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"test2@test.com\")",
            "        self.listener.user_added.assert_called_once()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.listener.user_password_changed.reset_mock()",
            "        #  Update user",
            "        self._edit_user(",
            "            \"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", UserObject.ADMIN_ROLE, mfa=UserObject.ENABLED_MFA",
            "        )",
            "        self.listener.user_attr_changed.assert_called()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"chaned@test.com\")",
            "        self.assertNotInBody(\"/home/\")",
            "        self.assertInBody(\"/tmp/\")",
            "",
            "        self._delete_user(\"test2\")",
            "        self.listener.user_deleted.assert_called()",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User account removed.\")",
            "        self.assertNotInBody(\"test2\")",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('evil.com', False),",
            "            ('http://test', False),",
            "            ('email@test.test', False),",
            "            ('/test/', False),",
            "            # Valid",
            "            ('My fullname', True),",
            "            ('Test Test', True),",
            "            ('\u00c9ric Terrien-Pascal', True),",
            "            (\"Tel'c\", True),",
            "        ]",
            "    )",
            "    def test_edit_fullname_with_special_character(self, new_fullname, expected_valid):",
            "        # Given an existing user",
            "        # When updating the user's fullname",
            "        self.getPage(",
            "            \"/admin/users/\",",
            "            method='POST',",
            "            body={'action': 'edit', 'username': self.USERNAME, 'fullname': new_fullname},",
            "        )",
            "        self.assertStatus(200)",
            "        if expected_valid:",
            "            self.assertInBody(\"User information modified successfully.\")",
            "            self.assertNotInBody(\"Fullname: Must not contain any special characters.\")",
            "        else:",
            "            self.assertNotInBody(\"User information modified successfully.\")",
            "            self.assertInBody(\"Fullname: Must not contain any special characters.\")",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('http://username', False),",
            "            ('username@test.test', False),",
            "            ('/username/', False),",
            "            # Valid",
            "            ('username.com', True),",
            "            ('admin_user', True),",
            "            ('test.test', True),",
            "            ('test-test', True),",
            "        ]",
            "    )",
            "    def test_add_user_with_special_character(self, new_username, expected_valid):",
            "        self._add_user(new_username, \"eric@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)",
            "        self.assertStatus(200)",
            "        if expected_valid:",
            "            self.assertInBody(\"User added successfully.\")",
            "            self.assertNotInBody(\"Username: Must not contain any special characters.\")",
            "        else:",
            "            self.assertNotInBody(\"User added successfully.\")",
            "            self.assertInBody(\"Username: Must not contain any special characters.\")",
            "",
            "    def test_add_user_with_empty_username(self):",
            "        \"\"\"",
            "        Verify failure trying to create user without username.",
            "        \"\"\"",
            "        self._add_user(\"\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Username: This field is required.\")",
            "",
            "    def test_add_user_with_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to add the same user.",
            "        \"\"\"",
            "        # Given a user named `test1`",
            "        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # When trying to create a new user with the same name",
            "        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # Then the user list is displayed with an error message.",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User test1 already exists.\")",
            "",
            "    def test_add_user_with_invalid_root_directory(self):",
            "        \"\"\"",
            "        Verify failure to add a user with invalid root directory.",
            "        \"\"\"",
            "        try:",
            "            self._delete_user(\"test5\")",
            "        except Exception:",
            "            pass",
            "        self._add_user(\"test5\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_add_without_email(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test2\", None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "    def test_add_without_user_root(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test6\", None, \"pr3j5Dwi\", None, UserObject.USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "        user = UserObject.get_user('test6')",
            "        self.assertEqual('', user.user_root)",
            "",
            "    def test_add_with_username_too_long(self):",
            "        # Given a too long username",
            "        username = \"test2\" * 52",
            "        # When trying to create the user",
            "        self._add_user(username, None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Username too long.\")",
            "",
            "    def test_add_with_email_too_long(self):",
            "        # Given a too long username",
            "        email = (\"test2\" * 50) + \"@test.com\"",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", email, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Email too long.\")",
            "",
            "    def test_add_with_user_root_too_long(self):",
            "        # Given a too long user root",
            "        user_root = \"/temp/\" * 50",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", user_root, UserObject.USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Root directory too long.\")",
            "",
            "    def test_add_with_fullname_too_long(self):",
            "        # Given a too long user root",
            "        fullname = \"fullname\" * 50",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE, fullname=fullname)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Fullname too long.\")",
            "",
            "    def test_delete_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure to delete invalid username.",
            "        \"\"\"",
            "        self._delete_user(\"test3\")",
            "        self.assertInBody(\"User doesn&#39;t exists!\")",
            "",
            "    def test_delete_our_self(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        self._delete_user(self.USERNAME)",
            "        self.assertInBody(\"You cannot remove your own account!\")",
            "",
            "    def test_delete_user_admin(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        # Create another admin user",
            "        self._add_user('admin2', '', 'pr3j5Dwi', '', UserObject.ADMIN_ROLE)",
            "        self.getPage(\"/logout\")",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        self._login('admin2', 'pr3j5Dwi')",
            "",
            "        # Try deleting admin user",
            "        self._delete_user(self.USERNAME)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"can&#39;t delete admin user\")",
            "",
            "    def test_delete_user_method_get(self):",
            "        # Given a user",
            "        user = UserObject.add_user('newuser')",
            "        user.commit()",
            "        # When trying to delete this user using method GET",
            "        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "        # Then user is not deleted",
            "        self.assertIsNotNone(UserObject.get_user('newuser'))",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._edit_user(self.USERNAME, password='short')",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._edit_user(self.USERNAME, password=new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_admin_password(self):",
            "        # Given rdiffweb is configured with admin-password option",
            "        self.app.cfg.admin_password = 'hardcoded'",
            "        try:",
            "            # When trying to update admin password",
            "            self._edit_user('admin', password='new-password')",
            "            # Then the form is refused with 200 OK with an error message.",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")",
            "        finally:",
            "            self.app.cfg.admin_password = None",
            "",
            "    def test_edit_user_with_invalid_path(self):",
            "        \"\"\"",
            "        Verify failure trying to update user with invalid path.",
            "        \"\"\"",
            "        userobj = UserObject.add_user('test1')",
            "        userobj.commit()",
            "        self._edit_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)",
            "        self.assertNotInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_list(self):",
            "        self.getPage(\"/admin/users/\")",
            "        self.assertInBody(\"Users\")",
            "        self.assertInBody(\"User management\")",
            "        self.assertInBody(\"Add user\")",
            "",
            "    def test_edit_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to update invalid user.",
            "        \"\"\"",
            "        # Given an invalid username",
            "        username = 'invalid'",
            "        # When trying to edit the user",
            "        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", UserObject.USER_ROLE)",
            "        # Then the user list is displayed with an error message",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")",
            "",
            "    def test_user_invalid_root(self):",
            "        # Change the user's root",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.user_root = \"/invalid\"",
            "        user.commit()",
            "        self.getPage(\"/admin/users\")",
            "        self.assertInBody(\"Root directory not accessible!\")",
            "",
            "        # Query the page by default",
            "        user = UserObject.get_user('admin')",
            "        user.user_root = \"/tmp/\"",
            "        user.commit()",
            "        self.getPage(\"/admin/users\")",
            "        self.assertNotInBody(\"Root directory not accessible!\")",
            "",
            "    def test_get_quota(self):",
            "        # Mock a quota.",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 654321",
            "        # When querying the user list",
            "        self.getPage(\"/admin/users/\")",
            "        self.assertStatus(200)",
            "        # Then get_disk_quota listenre is called",
            "        self.listener.get_disk_quota.assert_called()",
            "        # Then the quota value is displayed in human readable format",
            "        self.assertInBody(\"638.99 KiB\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota(self):",
            "        # When updating user quota.",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then listenr get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_gib(self):",
            "        # When updating user quota",
            "        self._edit_user(\"admin\", disk_quota='1GiB')",
            "        # Then listern get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_comma(self):",
            "        # When updating quota with comma value",
            "        self._edit_user(\"admin\", disk_quota='1,5 GiB')",
            "        # Then listner get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_leading_dot(self):",
            "        # When updating quota with leading dot",
            "        self._edit_user(\"admin\", disk_quota='.5 GiB')",
            "        # Then listener get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_empty(self):",
            "        # When quota is not defined",
            "        self._edit_user(\"admin\", disk_quota='')",
            "        # Then listener is not called.",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_same_value(self):",
            "        # Given an exiting quota",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 1234567890",
            "        # When setting the quota value to the same value",
            "        self._edit_user(\"admin\", disk_quota='1.15 GiB')",
            "        #  Then listener is not called",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_unsupported(self):",
            "        # Given setting quota is not supported",
            "        self.listener.set_disk_quota.side_effect = None",
            "        self.listener.set_disk_quota.return_value = None",
            "        # When updating the quota",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        self.assertInBody(\"Setting user&#39;s quota is not supported\")",
            "        self.assertStatus(200)",
            "",
            "    def test_edit_own_role(self):",
            "        # Given an administrator",
            "        # When trygin to update your own role",
            "        self._edit_user(username=self.USERNAME, role=UserObject.MAINTAINER_ROLE)",
            "        # Then an error is returned",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot edit your own role.\")",
            "",
            "    def test_edit_own_mfa(self):",
            "        # Given an administrator",
            "        # When trygin to update your own role",
            "        self._edit_user(username=self.USERNAME, mfa=UserObject.ENABLED_MFA)",
            "        # Then an error is returned",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot change your own two-factor authentication settings.\")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from unittest.mock import ANY, MagicMock",
            "",
            "import cherrypy",
            "from parameterized import parameterized",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import UserObject",
            "",
            "",
            "class AbstractAdminTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self._quota = {}",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        self.listener.get_disk_quota.side_effect = self._load_quota",
            "        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)",
            "        self.listener.get_disk_usage.return_value = 0",
            "        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)",
            "        self.listener.set_disk_quota.side_effect = self._store_quota",
            "        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)",
            "        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)",
            "        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)",
            "        return super().tearDown()",
            "",
            "    def _store_quota(self, userobj, value):",
            "        self._quota[userobj.username] = value",
            "",
            "    def _load_quota(self, userobj):",
            "        return self._quota.get(userobj.username, 0)",
            "",
            "    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None, mfa=None, fullname=None):",
            "        b = {}",
            "        b['action'] = 'add'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        if mfa is not None:",
            "            b['mfa'] = str(mfa)",
            "        if fullname is not None:",
            "            b['fullname'] = str(fullname)",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _edit_user(",
            "        self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None, mfa=None",
            "    ):",
            "        b = {}",
            "        b['action'] = 'edit'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        if disk_quota is not None:",
            "            b['disk_quota'] = disk_quota",
            "        if mfa is not None:",
            "            b['mfa'] = str(mfa)",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _delete_user(self, username='test1'):",
            "        b = {'action': 'delete', 'username': username}",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def test_add_user_with_role_admin(self):",
            "        # When trying to create a new user with role admin",
            "        self._add_user(\"admin_role\", \"admin_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.ADMIN_ROLE)",
            "        # Then page return success",
            "        self.assertStatus(200)",
            "        # Then database is updated",
            "        userobj = UserObject.get_user('admin_role')",
            "        self.assertEqual(UserObject.ADMIN_ROLE, userobj.role)",
            "        # Then notification was raised",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_with_role_maintainer(self):",
            "        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.MAINTAINER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(UserObject.MAINTAINER_ROLE, UserObject.get_user('maintainer_role').role)",
            "",
            "    def test_add_user_with_role_user(self):",
            "        self._add_user(\"user_role\", \"user_role@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(UserObject.USER_ROLE, UserObject.get_user('user_role').role)",
            "",
            "    def test_add_user_with_invalid_role(self):",
            "        # When trying to create a new user with an invalid role (admin instead of 0)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", 'admin')",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('Role: Invalid Choice: could not coerce')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "        # When trying to create a new user with an invalid role (-1)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", -1)",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('User Role: Not a valid choice')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_edit_delete(self):",
            "        #  Add user to be listed",
            "        self.listener.user_password_changed.reset_mock()",
            "        self._add_user(",
            "            \"test2\", \"test2@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE, mfa=UserObject.DISABLED_MFA",
            "        )",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"test2@test.com\")",
            "        self.listener.user_added.assert_called_once()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.listener.user_password_changed.reset_mock()",
            "        #  Update user",
            "        self._edit_user(",
            "            \"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", UserObject.ADMIN_ROLE, mfa=UserObject.ENABLED_MFA",
            "        )",
            "        self.listener.user_attr_changed.assert_called()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"chaned@test.com\")",
            "        self.assertNotInBody(\"/home/\")",
            "        self.assertInBody(\"/tmp/\")",
            "",
            "        self._delete_user(\"test2\")",
            "        self.listener.user_deleted.assert_called()",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User account removed.\")",
            "        self.assertNotInBody(\"test2\")",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('evil.com', False),",
            "            ('http://test', False),",
            "            ('email@test.test', False),",
            "            ('/test/', False),",
            "            # Valid",
            "            ('My fullname', True),",
            "            ('Test Test', True),",
            "            ('\u00c9ric Terrien-Pascal', True),",
            "            (\"Tel'c\", True),",
            "        ]",
            "    )",
            "    def test_edit_fullname_with_special_character(self, new_fullname, expected_valid):",
            "        # Given an existing user",
            "        # When updating the user's fullname",
            "        self.getPage(",
            "            \"/admin/users/\",",
            "            method='POST',",
            "            body={'action': 'edit', 'username': self.USERNAME, 'fullname': new_fullname},",
            "        )",
            "        self.assertStatus(200)",
            "        if expected_valid:",
            "            self.assertInBody(\"User information modified successfully.\")",
            "            self.assertNotInBody(\"Fullname: Must not contain any special characters.\")",
            "        else:",
            "            self.assertNotInBody(\"User information modified successfully.\")",
            "            self.assertInBody(\"Fullname: Must not contain any special characters.\")",
            "",
            "    @parameterized.expand(",
            "        [",
            "            # Invalid",
            "            ('http://username', False),",
            "            ('username@test.test', False),",
            "            ('/username/', False),",
            "            # Valid",
            "            ('username.com', True),",
            "            ('admin_user', True),",
            "            ('test.test', True),",
            "            ('test-test', True),",
            "        ]",
            "    )",
            "    def test_add_user_with_special_character(self, new_username, expected_valid):",
            "        self._add_user(new_username, \"eric@test.com\", \"pr3j5Dwi\", \"/home/\", UserObject.USER_ROLE)",
            "        self.assertStatus(200)",
            "        if expected_valid:",
            "            self.assertInBody(\"User added successfully.\")",
            "            self.assertNotInBody(\"Username: Must not contain any special characters.\")",
            "        else:",
            "            self.assertNotInBody(\"User added successfully.\")",
            "            self.assertInBody(\"Username: Must not contain any special characters.\")",
            "",
            "    def test_add_user_with_empty_username(self):",
            "        \"\"\"",
            "        Verify failure trying to create user without username.",
            "        \"\"\"",
            "        self._add_user(\"\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Username: This field is required.\")",
            "",
            "    def test_add_user_with_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to add the same user.",
            "        \"\"\"",
            "        # Given a user named `test1`",
            "        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # When trying to create a new user with the same name",
            "        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # Then the user list is displayed with an error message.",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User test1 already exists.\")",
            "",
            "    def test_add_user_with_invalid_root_directory(self):",
            "        \"\"\"",
            "        Verify failure to add a user with invalid root directory.",
            "        \"\"\"",
            "        try:",
            "            self._delete_user(\"test5\")",
            "        except Exception:",
            "            pass",
            "        self._add_user(\"test5\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_add_without_email(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test2\", None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "    def test_add_without_user_root(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test6\", None, \"pr3j5Dwi\", None, UserObject.USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "        user = UserObject.get_user('test6')",
            "        self.assertEqual('', user.user_root)",
            "",
            "    def test_add_with_username_too_long(self):",
            "        # Given a too long username",
            "        username = \"test2\" * 52",
            "        # When trying to create the user",
            "        self._add_user(username, None, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Username too long.\")",
            "",
            "    def test_add_with_email_too_long(self):",
            "        # Given a too long username",
            "        email = (\"test2\" * 50) + \"@test.com\"",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", email, \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Email too long.\")",
            "",
            "    def test_add_with_user_root_too_long(self):",
            "        # Given a too long user root",
            "        user_root = \"/temp/\" * 50",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", user_root, UserObject.USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Root directory too long.\")",
            "",
            "    def test_add_with_fullname_too_long(self):",
            "        # Given a too long user root",
            "        fullname = \"fullname\" * 50",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", \"/tmp/\", UserObject.USER_ROLE, fullname=fullname)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Fullname too long.\")",
            "",
            "    def test_delete_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure to delete invalid username.",
            "        \"\"\"",
            "        self._delete_user(\"test3\")",
            "        self.assertInBody(\"User doesn&#39;t exists!\")",
            "",
            "    def test_delete_our_self(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        self._delete_user(self.USERNAME)",
            "        self.assertInBody(\"You cannot remove your own account!\")",
            "",
            "    def test_delete_user_admin(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        # Create another admin user",
            "        self._add_user('admin2', '', 'pr3j5Dwi', '', UserObject.ADMIN_ROLE)",
            "        self.getPage(\"/logout\", method=\"POST\")",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        self._login('admin2', 'pr3j5Dwi')",
            "",
            "        # Try deleting admin user",
            "        self._delete_user(self.USERNAME)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"can&#39;t delete admin user\")",
            "",
            "    def test_delete_user_method_get(self):",
            "        # Given a user",
            "        user = UserObject.add_user('newuser')",
            "        user.commit()",
            "        # When trying to delete this user using method GET",
            "        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "        # Then user is not deleted",
            "        self.assertIsNotNone(UserObject.get_user('newuser'))",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._edit_user(self.USERNAME, password='short')",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._edit_user(self.USERNAME, password=new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_admin_password(self):",
            "        # Given rdiffweb is configured with admin-password option",
            "        self.app.cfg.admin_password = 'hardcoded'",
            "        try:",
            "            # When trying to update admin password",
            "            self._edit_user('admin', password='new-password')",
            "            # Then the form is refused with 200 OK with an error message.",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")",
            "        finally:",
            "            self.app.cfg.admin_password = None",
            "",
            "    def test_edit_user_with_invalid_path(self):",
            "        \"\"\"",
            "        Verify failure trying to update user with invalid path.",
            "        \"\"\"",
            "        userobj = UserObject.add_user('test1')",
            "        userobj.commit()",
            "        self._edit_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", UserObject.USER_ROLE)",
            "        self.assertNotInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_list(self):",
            "        self.getPage(\"/admin/users/\")",
            "        self.assertInBody(\"Users\")",
            "        self.assertInBody(\"User management\")",
            "        self.assertInBody(\"Add user\")",
            "",
            "    def test_edit_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to update invalid user.",
            "        \"\"\"",
            "        # Given an invalid username",
            "        username = 'invalid'",
            "        # When trying to edit the user",
            "        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", UserObject.USER_ROLE)",
            "        # Then the user list is displayed with an error message",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")",
            "",
            "    def test_user_invalid_root(self):",
            "        # Change the user's root",
            "        user = UserObject.get_user(self.USERNAME)",
            "        user.user_root = \"/invalid\"",
            "        user.commit()",
            "        self.getPage(\"/admin/users\")",
            "        self.assertInBody(\"Root directory not accessible!\")",
            "",
            "        # Query the page by default",
            "        user = UserObject.get_user('admin')",
            "        user.user_root = \"/tmp/\"",
            "        user.commit()",
            "        self.getPage(\"/admin/users\")",
            "        self.assertNotInBody(\"Root directory not accessible!\")",
            "",
            "    def test_get_quota(self):",
            "        # Mock a quota.",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 654321",
            "        # When querying the user list",
            "        self.getPage(\"/admin/users/\")",
            "        self.assertStatus(200)",
            "        # Then get_disk_quota listenre is called",
            "        self.listener.get_disk_quota.assert_called()",
            "        # Then the quota value is displayed in human readable format",
            "        self.assertInBody(\"638.99 KiB\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota(self):",
            "        # When updating user quota.",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then listenr get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_gib(self):",
            "        # When updating user quota",
            "        self._edit_user(\"admin\", disk_quota='1GiB')",
            "        # Then listern get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_comma(self):",
            "        # When updating quota with comma value",
            "        self._edit_user(\"admin\", disk_quota='1,5 GiB')",
            "        # Then listner get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_leading_dot(self):",
            "        # When updating quota with leading dot",
            "        self._edit_user(\"admin\", disk_quota='.5 GiB')",
            "        # Then listener get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_empty(self):",
            "        # When quota is not defined",
            "        self._edit_user(\"admin\", disk_quota='')",
            "        # Then listener is not called.",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_same_value(self):",
            "        # Given an exiting quota",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 1234567890",
            "        # When setting the quota value to the same value",
            "        self._edit_user(\"admin\", disk_quota='1.15 GiB')",
            "        #  Then listener is not called",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_unsupported(self):",
            "        # Given setting quota is not supported",
            "        self.listener.set_disk_quota.side_effect = None",
            "        self.listener.set_disk_quota.return_value = None",
            "        # When updating the quota",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        self.assertInBody(\"Setting user&#39;s quota is not supported\")",
            "        self.assertStatus(200)",
            "",
            "    def test_edit_own_role(self):",
            "        # Given an administrator",
            "        # When trygin to update your own role",
            "        self._edit_user(username=self.USERNAME, role=UserObject.MAINTAINER_ROLE)",
            "        # Then an error is returned",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot edit your own role.\")",
            "",
            "    def test_edit_own_mfa(self):",
            "        # Given an administrator",
            "        # When trygin to update your own role",
            "        self._edit_user(username=self.USERNAME, mfa=UserObject.ENABLED_MFA)",
            "        # Then an error is returned",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot change your own two-factor authentication settings.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "328": [
                "AbstractAdminTest",
                "test_delete_user_admin"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/controller/tests/test_page_login.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "     def test_login_persistent(self):"
            },
            "2": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         # Given a user authenticated with persistent"
            },
            "3": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.getPage('/logout/')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        self.getPage('/logout', method=\"POST\")"
            },
            "5": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "         self.assertStatus(303)"
            },
            "6": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         self.getPage("
            },
            "7": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}"
            },
            "8": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "     def test_getpage_without_login(self):"
            },
            "9": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "         # Given an unauthenticated user"
            },
            "10": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "         # When Accessing logout page directly"
            },
            "11": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.getPage('/logout')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+        self.getPage('/logout', method=\"POST\")"
            },
            "13": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "         # Then user is redirect to root '/'"
            },
            "14": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "         self.assertStatus('303 See Other')"
            },
            "15": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "         self.assertHeaderItemValue('Location', self.baseurl + '/')"
            },
            "16": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "         self.getPage(\"/prefs/general\")"
            },
            "17": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "         self.assertStatus('200 OK')"
            },
            "18": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         # When logout"
            },
            "19": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.getPage('/logout')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+        self.getPage('/logout', method=\"POST\")"
            },
            "21": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         # Then a new session id is generated"
            },
            "22": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         self.assertNotEqual(prev_session_id, self.session_id)"
            },
            "23": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "         # Then user is redirected to root page"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "import os",
            "",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, SessionObject, UserObject",
            "from rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY",
            "",
            "",
            "class LoginPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage('/')",
            "        # Then user is redirected to login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # Then a session object is created without a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNone(session.get(SESSION_KEY))",
            "",
            "    def test_login_success(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authenticating with valid credentials.",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then a new session_id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then a session object is created with a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertEqual('admin', session.get(SESSION_KEY))",
            "        self.assertIsNotNone(session.get(LOGIN_TIME))",
            "",
            "    def test_cookie_http_only(self):",
            "        # Given a request made to rdiffweb",
            "        # When receiving the response",
            "        self.getPage('/')",
            "        # Then the header contains Set-Cookie with HttpOnly",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('HttpOnly', cookie)",
            "",
            "    def test_login_with_plaintext(self):",
            "        \"\"\"",
            "        Requesting plain text without being authenticated should show the login form.",
            "        \"\"\"",
            "        # When querying root page without authentication",
            "        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "",
            "    @parameterized.expand(",
            "        [",
            "            ('with_root', '/'),",
            "            ('with_browse_url', '/browse/admin/testcases/Revisions/'),",
            "            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),",
            "            (",
            "                'with_broken_encoding',",
            "                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',",
            "            ),",
            "            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),",
            "            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),",
            "            ('with_admin', '/admin/'),",
            "        ]",
            "    )",
            "    def test_login(self, unused, original_url):",
            "        # Given an unauthenticated user",
            "        # Query the page without login-in",
            "        self.getPage(original_url)",
            "        # Then user is redirected to the login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authentication is successful",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then user is redirected to original URL",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + original_url)",
            "        # Then cookie is not persistent",
            "        self.assertNotIn('expires', self.cookies[0][1])",
            "        self.assertNotIn('Max-Age', self.cookies[0][1])",
            "        # When requesting the original page",
            "        self.getPage(original_url)",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "",
            "    def test_getpage_with_redirect_post(self):",
            "        \"\"\"",
            "        Check encoding of redirect url when send using POST method.",
            "        \"\"\"",
            "        # When posting invalid credentials",
            "        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        # Then page return without HTTP Error",
            "        self.assertStatus('200 OK')",
            "        # Then page display an error",
            "        self.assertInBody('Invalid username or password.')",
            "        self.assertInBody('id=\"form-login\"')",
            "        # Then redirect URL is ignored",
            "        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')",
            "",
            "    def test_getpage_without_username(self):",
            "        \"\"\"",
            "        Check if error is raised when requesting /login without a username.",
            "        \"\"\"",
            "        self.getPage('/login/', method='GET')",
            "        self.assertStatus('200 OK')",
            "",
            "    def test_getpage_with_username_too_long(self):",
            "        b = {'login': 'admin' * 52, 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('Username too long.')",
            "",
            "    def test_getpage_with_empty_password(self):",
            "        \"\"\"",
            "        Check if authentication is failing without a password.",
            "        \"\"\"",
            "        b = {'login': 'admin', 'password': ''}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('This field is required.')",
            "",
            "    def test_getpage_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='GET')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_post_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='POST')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_login_twice(self):",
            "        # Given an authenticated user",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "        # Given another user",
            "        userobj = UserObject.add_user('otheruser', password='password')",
            "        userobj.commit()",
            "        # When trying to re-authenticated with login page",
            "        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})",
            "        # Then user is still authenticated with previous user",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "",
            "    def test_login_persistent(self):",
            "        # Given a user authenticated with persistent",
            "        self.getPage('/logout/')",
            "        self.assertStatus(303)",
            "        self.getPage(",
            "            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}",
            "        )",
            "        self.assertStatus(303)",
            "        # Then a persistent cookie is return",
            "        self.assertIn('expires', self.cookies[0][1])",
            "        self.assertIn('Max-Age', self.cookies[0][1])",
            "        # Then a session is created with persistent flag",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # Then session timeout is 30 days in future",
            "        self.assertAlmostEqual(session.timeout, 43200, delta=2)",
            "",
            "",
            "class LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}",
            "",
            "    def test_getpage_default(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('default message')",
            "",
            "    def test_getpage_french(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('french message')",
            "",
            "",
            "class LoginPageWithHeaderName(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'header-name': 'HEADER-NAME'}",
            "",
            "    def test_getpage_default(self):",
            "        # Given a custom header-name",
            "        # When querying the loging page",
            "        self.getPage('/login/')",
            "        # Then the page display the header-name",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('HEADER-NAME')",
            "",
            "",
            "@parameterized_class(",
            "    [",
            "        {\"default_config\": {'rate-limit': 5}},",
            "        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},",
            "    ]",
            ")",
            "class LoginPageRateLimitTest(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1')",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1.-login')",
            "        return super().setUp()",
            "",
            "    def test_login_ratelimit(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page",
            "        for i in range(1, 5):",
            "            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "            self.assertStatus(200)",
            "        # Then a 429 error (too many request) is return",
            "        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest2(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_forwarded_for(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Forwarded-For`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then original IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest3(rdiffweb.test.WebCase):",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_real_ip(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Real-IP`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Real-IP', '127.0.0.128')],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then the X-Real-IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Real-IP', '127.0.0.128')],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LogoutPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage_without_login(self):",
            "        # Given an unauthenticated user",
            "        # When Accessing logout page directly",
            "        self.getPage('/logout')",
            "        # Then user is redirect to root '/'",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_getpage_with_login(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Login",
            "        b = {'login': 'admin', 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('303 See Other')",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        prev_session_id = self.session_id",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('200 OK')",
            "        # When logout",
            "        self.getPage('/logout')",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to root page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "import os",
            "",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, SessionObject, UserObject",
            "from rdiffweb.tools.auth_form import LOGIN_TIME, SESSION_KEY",
            "",
            "",
            "class LoginPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage(self):",
            "        # When making a query to a page while unauthenticated",
            "        self.getPage('/')",
            "        # Then user is redirected to login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # Then a session object is created without a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertIsNone(session.get(SESSION_KEY))",
            "",
            "    def test_login_success(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authenticating with valid credentials.",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then a new session_id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then a session object is created with a username",
            "        self.assertEqual(1, SessionObject.query.filter(SessionObject.id == self.session_id).count())",
            "        SessionObject.query.filter(SessionObject.id == self.session_id).first()",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertEqual('admin', session.get(SESSION_KEY))",
            "        self.assertIsNotNone(session.get(LOGIN_TIME))",
            "",
            "    def test_cookie_http_only(self):",
            "        # Given a request made to rdiffweb",
            "        # When receiving the response",
            "        self.getPage('/')",
            "        # Then the header contains Set-Cookie with HttpOnly",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('HttpOnly', cookie)",
            "",
            "    def test_login_with_plaintext(self):",
            "        \"\"\"",
            "        Requesting plain text without being authenticated should show the login form.",
            "        \"\"\"",
            "        # When querying root page without authentication",
            "        self.getPage('/', headers=[(\"Accept\", \"text/plain\")])",
            "        # Then user is redirected to /login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "",
            "    @parameterized.expand(",
            "        [",
            "            ('with_root', '/'),",
            "            ('with_browse_url', '/browse/admin/testcases/Revisions/'),",
            "            ('with_encoded_url', '/browse/admin/testcases/DIR%EF%BF%BD/'),",
            "            (",
            "                'with_broken_encoding',",
            "                '/restore/admin/testcases/Fichier%20avec%20non%20asci%20char%20%C9velyne%20M%E8re.txt/?date=1415221507',",
            "            ),",
            "            ('with_query_string', '/restore/admin/testcases/Revisions?date=1477434528'),",
            "            ('with_multiple_query_string', '/restore/admin/testcases/Revisions?date=1477434528&kind=tar.gz'),",
            "            ('with_admin', '/admin/'),",
            "        ]",
            "    )",
            "    def test_login(self, unused, original_url):",
            "        # Given an unauthenticated user",
            "        # Query the page without login-in",
            "        self.getPage(original_url)",
            "        # Then user is redirected to the login page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        # When authentication is successful",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        # Then user is redirected to original URL",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + original_url)",
            "        # Then cookie is not persistent",
            "        self.assertNotIn('expires', self.cookies[0][1])",
            "        self.assertNotIn('Max-Age', self.cookies[0][1])",
            "        # When requesting the original page",
            "        self.getPage(original_url)",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "",
            "    def test_getpage_with_redirect_post(self):",
            "        \"\"\"",
            "        Check encoding of redirect url when send using POST method.",
            "        \"\"\"",
            "        # When posting invalid credentials",
            "        b = {'login': 'admin', 'password': 'invalid', 'redirect': '/browse/' + self.REPO + '/DIR%EF%BF%BD/'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        # Then page return without HTTP Error",
            "        self.assertStatus('200 OK')",
            "        # Then page display an error",
            "        self.assertInBody('Invalid username or password.')",
            "        self.assertInBody('id=\"form-login\"')",
            "        # Then redirect URL is ignored",
            "        self.assertNotInBody('/browse/' + self.REPO + '/DIR%EF%BF%BD/\"')",
            "",
            "    def test_getpage_without_username(self):",
            "        \"\"\"",
            "        Check if error is raised when requesting /login without a username.",
            "        \"\"\"",
            "        self.getPage('/login/', method='GET')",
            "        self.assertStatus('200 OK')",
            "",
            "    def test_getpage_with_username_too_long(self):",
            "        b = {'login': 'admin' * 52, 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('Username too long.')",
            "",
            "    def test_getpage_with_empty_password(self):",
            "        \"\"\"",
            "        Check if authentication is failing without a password.",
            "        \"\"\"",
            "        b = {'login': 'admin', 'password': ''}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('This field is required.')",
            "",
            "    def test_getpage_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='GET')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_post_with_invalid_url(self):",
            "        self.getPage('/login/kefuxian.mvc', method='POST')",
            "        self.assertStatus('303 See Other')",
            "",
            "    def test_login_twice(self):",
            "        # Given an authenticated user",
            "        self.getPage('/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "        # Given another user",
            "        userobj = UserObject.add_user('otheruser', password='password')",
            "        userobj.commit()",
            "        # When trying to re-authenticated with login page",
            "        self.getPage('/login/', method='POST', body={'login': 'otheruser', 'password': 'password'})",
            "        # Then user is still authenticated with previous user",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + \"/\")",
            "        self.getPage('/')",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.USERNAME)",
            "",
            "    def test_login_persistent(self):",
            "        # Given a user authenticated with persistent",
            "        self.getPage('/logout', method=\"POST\")",
            "        self.assertStatus(303)",
            "        self.getPage(",
            "            '/login/', method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD, 'persistent': '1'}",
            "        )",
            "        self.assertStatus(303)",
            "        # Then a persistent cookie is return",
            "        self.assertIn('expires', self.cookies[0][1])",
            "        self.assertIn('Max-Age', self.cookies[0][1])",
            "        # Then a session is created with persistent flag",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # Then session timeout is 30 days in future",
            "        self.assertAlmostEqual(session.timeout, 43200, delta=2)",
            "",
            "",
            "class LoginPageWithWelcomeMsgTest(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}",
            "",
            "    def test_getpage_default(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"it\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('default message')",
            "",
            "    def test_getpage_french(self):",
            "        \"\"\"",
            "        Make sure the login page can be rendered without error.",
            "        \"\"\"",
            "        self.getPage('/login/', headers=[(\"Accept-Language\", \"fr\")])",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('french message')",
            "",
            "",
            "class LoginPageWithHeaderName(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'header-name': 'HEADER-NAME'}",
            "",
            "    def test_getpage_default(self):",
            "        # Given a custom header-name",
            "        # When querying the loging page",
            "        self.getPage('/login/')",
            "        # Then the page display the header-name",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('HEADER-NAME')",
            "",
            "",
            "@parameterized_class(",
            "    [",
            "        {\"default_config\": {'rate-limit': 5}},",
            "        {\"default_config\": {'rate-limit': 5, 'rate-limit-dir': '/tmp'}},",
            "    ]",
            ")",
            "class LoginPageRateLimitTest(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1')",
            "        if os.path.isfile('/tmp/ratelimit-127.0.0.1.-login'):",
            "            os.unlink('/tmp/ratelimit-127.0.0.1.-login')",
            "        return super().setUp()",
            "",
            "    def test_login_ratelimit(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page",
            "        for i in range(1, 5):",
            "            self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "            self.assertStatus(200)",
            "        # Then a 429 error (too many request) is return",
            "        self.getPage('/login/', method='POST', body={'login': 'invalid', 'password': 'invalid'})",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest2(rdiffweb.test.WebCase):",
            "",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_forwarded_for(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Forwarded-For`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then original IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Forwarded-For', '127.0.0.%s' % i)],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LoginPageRateLimitTest3(rdiffweb.test.WebCase):",
            "    default_config = {'rate-limit': 5}",
            "",
            "    def test_login_ratelimit_real_ip(self):",
            "        # Given an unauthenticate",
            "        # When requesting multiple time the login page with different `X-Real-IP`",
            "        for i in range(1, 5):",
            "            self.getPage(",
            "                '/login/',",
            "                headers=[('X-Real-IP', '127.0.0.128')],",
            "                method='POST',",
            "                body={'login': 'invalid', 'password': 'invalid'},",
            "            )",
            "            self.assertStatus(200)",
            "        # Then the X-Real-IP get blocked",
            "        self.getPage(",
            "            '/login/',",
            "            headers=[('X-Real-IP', '127.0.0.128')],",
            "            method='POST',",
            "            body={'login': 'invalid', 'password': 'invalid'},",
            "        )",
            "        self.assertStatus(429)",
            "",
            "",
            "class LogoutPageTest(rdiffweb.test.WebCase):",
            "    def test_getpage_without_login(self):",
            "        # Given an unauthenticated user",
            "        # When Accessing logout page directly",
            "        self.getPage('/logout', method=\"POST\")",
            "        # Then user is redirect to root '/'",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_getpage_with_login(self):",
            "        # Given an anonymous user",
            "        self.getPage('/')",
            "        prev_session_id = self.session_id",
            "        # Login",
            "        b = {'login': 'admin', 'password': 'admin123'}",
            "        self.getPage('/login/', method='POST', body=b)",
            "        self.assertStatus('303 See Other')",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        prev_session_id = self.session_id",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('200 OK')",
            "        # When logout",
            "        self.getPage('/logout', method=\"POST\")",
            "        # Then a new session id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to root page",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Get content of a page.",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus('303 See Other')",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "186": [
                "LoginPageTest",
                "test_login_persistent"
            ],
            "315": [
                "LogoutPageTest",
                "test_getpage_without_login"
            ],
            "335": [
                "LogoutPageTest",
                "test_getpage_with_login"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/controller/tests/test_page_mfa.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     def test_get_without_login(self):"
            },
            "2": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         # Given an unauthenticated user"
            },
            "3": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.getPage(\"/logout\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        self.getPage(\"/logout\", method=\"POST\")"
            },
            "5": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         self.assertStatus(303)"
            },
            "6": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         # When requesting /mfa/"
            },
            "7": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         self.getPage(\"/mfa/\")"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import datetime",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, UserObject",
            "",
            "",
            "class MfaPageTest(rdiffweb.test.WebCase):",
            "",
            "    # Authenticated by default.",
            "    login = True",
            "",
            "    def _get_code(self):",
            "        # Register an email listeer to capture email send",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)",
            "        # Query MFA page to generate a code",
            "        self.getPage(\"/mfa/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "        # Extract code from email between <strong> and </strong>",
            "        self.listener.queue_email.assert_called_once()",
            "        message = self.listener.queue_email.call_args[1]['message']",
            "        return message.split('<strong>', 1)[1].split('</strong>')[0]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # Enabled MFA for all test cases",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.mfa = UserObject.ENABLED_MFA",
            "        userobj.email = 'admin@example.com'",
            "        userobj.commit()",
            "",
            "    def test_get_without_login(self):",
            "        # Given an unauthenticated user",
            "        self.getPage(\"/logout\")",
            "        self.assertStatus(303)",
            "        # When requesting /mfa/",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to /login/",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "",
            "    def test_get_with_mfa_disabled(self):",
            "        # Given an authenticated user with MFA Disable",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.mfa = UserObject.DISABLED_MFA",
            "        userobj.commit()",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to root page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_get_with_user_without_email(self):",
            "        # Given an authenticated user without email.",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.email = ''",
            "        userobj.commit()",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to root page",
            "        self.assertStatus(200)",
            "        self.assertInBody(",
            "            \"Multi-factor authentication is enabled for your account, but your account does not have a valid email address to send the verification code to. Check your account settings with your administrator.\"",
            "        )",
            "",
            "    def test_get_with_trusted(self):",
            "        # Given an authenticated user with MFA enabled and already verified",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_username'] = self.USERNAME",
            "        session['_auth_mfa_time'] = session.now()",
            "        session['_auth_mfa_trusted_ip_list'] = ['127.0.0.1']",
            "        session.save()",
            "        # When requesting /mfa/ page when we are already trusted",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to root page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_get_with_trusted_expired(self):",
            "        # Given an authenticated user with MFA enabled and already verified",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_username'] = self.USERNAME",
            "        session['_auth_mfa_time'] = session.now() - datetime.timedelta(minutes=session.timeout)",
            "        session.save()",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then an email get send with a new code",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_get_with_trusted_different_ip(self):",
            "        # Given an authenticated user with MFA enabled and already verified",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_username'] = self.USERNAME",
            "        session['_auth_mfa_time'] = session.now()",
            "        session.save()",
            "        # When requesting /mfa/ page from a different ip",
            "        self.getPage(\"/mfa/\", headers=[('X-Forwarded-For', '10.255.14.23')])",
            "        # Then an email get send with a new code",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_get_without_verified(self):",
            "        # Given an authenticated user With MFA enabled",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then an email get send with a new code",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_verify_code_valid(self):",
            "        prev_session_id = self.session_id",
            "        # Given an authenticated user With MFA enabled",
            "        code = self._get_code()",
            "        # When sending a valid verification code",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})",
            "        # Then a new session_id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to root page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then user has access",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "",
            "    def test_verify_code_invalid(self):",
            "        # Given an authenticated user With MFA enabled",
            "        # When sending an invalid verification code",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        # Then an error get displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Invalid verification code.\")",
            "",
            "    def test_verify_code_expired(self):",
            "        # Given an authenticated user With MFA enabled",
            "        code = self._get_code()",
            "        # When sending a valid verification code that expired",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_code_time'] = session.now() - datetime.timedelta(minutes=session.timeout + 1)",
            "        session.save()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})",
            "        # Then a new code get generated.",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Invalid verification code.\")",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_verify_code_invalid_after_3_tentative(self):",
            "        # Given an authenticated user With MFA",
            "        self._get_code()",
            "        # When user enter an invalid verification code 3 times",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        self.assertStatus(200)",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        self.assertStatus(200)",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        # Then an error get displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Invalid verification code.\")",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_resend_code(self):",
            "        # Given an authenticated user With MFA enabled with an existing code",
            "        self._get_code()",
            "        # When user request a new code",
            "        self.getPage(\"/mfa/\", method='POST', body={'resend_code': '1'})",
            "        # Then a new code is sent to the user by email",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_redirect_to_original_url(self):",
            "        # When querying a page that required mfa",
            "        self.getPage('/prefs/general')",
            "        # Then user is redirected to mfa page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')",
            "        # When providing verification code",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})",
            "        # Then user is redirected to original url",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "",
            "    def test_login_persistent_when_login_timout(self):",
            "        prev_session_id = self.session_id",
            "        # Given a user authenticated with MFA with \"login_persistent\"",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})",
            "        self.assertStatus(303)",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # When the login_time expired (after 15 min)",
            "        session['login_time'] = session.now() - datetime.timedelta(minutes=15, seconds=1)",
            "        session.save()",
            "        # Then next query redirect user to same page (by mfa)",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "        self.getPage(\"/prefs/general\")",
            "        # Then user is redirected to /login/ page (by auth_form)",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        prev_session_id = self.session_id",
            "        # When user enter valid username password",
            "        self.getPage(\"/login/\", method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to original url",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody('Repositories')",
            "",
            "    def test_login_persistent_when_mfa_timeout(self):",
            "        prev_session_id = self.session_id",
            "        # Given a user authenticated with MFA with \"login_persistent\"",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})",
            "        self.assertStatus(303)",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # When the mfa verification timeout (after 30 days)",
            "        session['_auth_mfa_time'] = session.now() - datetime.timedelta(days=30, seconds=1)",
            "        session.save()",
            "        # Then next query redirect user to mfa page",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')",
            "        # When user enter valid code",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})",
            "        # Then user is redirected to original page.",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody('Repositories')",
            "",
            "",
            "class MfaPageWithWelcomeMsgTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # Enabled MFA for all test cases",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.mfa = UserObject.ENABLED_MFA",
            "        userobj.email = 'admin@example.com'",
            "        userobj.commit()",
            "",
            "    def test_getpage_default(self):",
            "        # Given a user with MFA enabled",
            "        # When querying the mfa page",
            "        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"it\")])",
            "        # Then page is return without error with the custom welcome message",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('default message')",
            "",
            "    def test_getpage_french(self):",
            "        # Given a user with MFA enabled",
            "        # When querying the mfa page in french",
            "        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"fr\")])",
            "        # Then page is return without error with the custom welcome message in french",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('french message')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import datetime",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.model import DbSession, UserObject",
            "",
            "",
            "class MfaPageTest(rdiffweb.test.WebCase):",
            "",
            "    # Authenticated by default.",
            "    login = True",
            "",
            "    def _get_code(self):",
            "        # Register an email listeer to capture email send",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_email, priority=50)",
            "        # Query MFA page to generate a code",
            "        self.getPage(\"/mfa/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "        # Extract code from email between <strong> and </strong>",
            "        self.listener.queue_email.assert_called_once()",
            "        message = self.listener.queue_email.call_args[1]['message']",
            "        return message.split('<strong>', 1)[1].split('</strong>')[0]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # Enabled MFA for all test cases",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.mfa = UserObject.ENABLED_MFA",
            "        userobj.email = 'admin@example.com'",
            "        userobj.commit()",
            "",
            "    def test_get_without_login(self):",
            "        # Given an unauthenticated user",
            "        self.getPage(\"/logout\", method=\"POST\")",
            "        self.assertStatus(303)",
            "        # When requesting /mfa/",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to /login/",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "",
            "    def test_get_with_mfa_disabled(self):",
            "        # Given an authenticated user with MFA Disable",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.mfa = UserObject.DISABLED_MFA",
            "        userobj.commit()",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to root page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_get_with_user_without_email(self):",
            "        # Given an authenticated user without email.",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.email = ''",
            "        userobj.commit()",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to root page",
            "        self.assertStatus(200)",
            "        self.assertInBody(",
            "            \"Multi-factor authentication is enabled for your account, but your account does not have a valid email address to send the verification code to. Check your account settings with your administrator.\"",
            "        )",
            "",
            "    def test_get_with_trusted(self):",
            "        # Given an authenticated user with MFA enabled and already verified",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_username'] = self.USERNAME",
            "        session['_auth_mfa_time'] = session.now()",
            "        session['_auth_mfa_trusted_ip_list'] = ['127.0.0.1']",
            "        session.save()",
            "        # When requesting /mfa/ page when we are already trusted",
            "        self.getPage(\"/mfa/\")",
            "        # Then user is redirected to root page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "",
            "    def test_get_with_trusted_expired(self):",
            "        # Given an authenticated user with MFA enabled and already verified",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_username'] = self.USERNAME",
            "        session['_auth_mfa_time'] = session.now() - datetime.timedelta(minutes=session.timeout)",
            "        session.save()",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then an email get send with a new code",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_get_with_trusted_different_ip(self):",
            "        # Given an authenticated user with MFA enabled and already verified",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_username'] = self.USERNAME",
            "        session['_auth_mfa_time'] = session.now()",
            "        session.save()",
            "        # When requesting /mfa/ page from a different ip",
            "        self.getPage(\"/mfa/\", headers=[('X-Forwarded-For', '10.255.14.23')])",
            "        # Then an email get send with a new code",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_get_without_verified(self):",
            "        # Given an authenticated user With MFA enabled",
            "        # When requesting /mfa/ page",
            "        self.getPage(\"/mfa/\")",
            "        # Then an email get send with a new code",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_verify_code_valid(self):",
            "        prev_session_id = self.session_id",
            "        # Given an authenticated user With MFA enabled",
            "        code = self._get_code()",
            "        # When sending a valid verification code",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})",
            "        # Then a new session_id is generated",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to root page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/')",
            "        # Then user has access",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "",
            "    def test_verify_code_invalid(self):",
            "        # Given an authenticated user With MFA enabled",
            "        # When sending an invalid verification code",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        # Then an error get displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Invalid verification code.\")",
            "",
            "    def test_verify_code_expired(self):",
            "        # Given an authenticated user With MFA enabled",
            "        code = self._get_code()",
            "        # When sending a valid verification code that expired",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        session['_auth_mfa_code_time'] = session.now() - datetime.timedelta(minutes=session.timeout + 1)",
            "        session.save()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})",
            "        # Then a new code get generated.",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Invalid verification code.\")",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_verify_code_invalid_after_3_tentative(self):",
            "        # Given an authenticated user With MFA",
            "        self._get_code()",
            "        # When user enter an invalid verification code 3 times",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        self.assertStatus(200)",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        self.assertStatus(200)",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': '1234567', 'submit': '1'})",
            "        # Then an error get displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Invalid verification code.\")",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_resend_code(self):",
            "        # Given an authenticated user With MFA enabled with an existing code",
            "        self._get_code()",
            "        # When user request a new code",
            "        self.getPage(\"/mfa/\", method='POST', body={'resend_code': '1'})",
            "        # Then a new code is sent to the user by email",
            "        self.assertInBody(\"A new verification code has been sent to your email.\")",
            "",
            "    def test_redirect_to_original_url(self):",
            "        # When querying a page that required mfa",
            "        self.getPage('/prefs/general')",
            "        # Then user is redirected to mfa page",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')",
            "        # When providing verification code",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1'})",
            "        # Then user is redirected to original url",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "",
            "    def test_login_persistent_when_login_timout(self):",
            "        prev_session_id = self.session_id",
            "        # Given a user authenticated with MFA with \"login_persistent\"",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})",
            "        self.assertStatus(303)",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # When the login_time expired (after 15 min)",
            "        session['login_time'] = session.now() - datetime.timedelta(minutes=15, seconds=1)",
            "        session.save()",
            "        # Then next query redirect user to same page (by mfa)",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "        self.getPage(\"/prefs/general\")",
            "        # Then user is redirected to /login/ page (by auth_form)",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/login/')",
            "        prev_session_id = self.session_id",
            "        # When user enter valid username password",
            "        self.getPage(\"/login/\", method='POST', body={'login': self.USERNAME, 'password': self.PASSWORD})",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        # Then user is redirected to original url",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody('Repositories')",
            "",
            "    def test_login_persistent_when_mfa_timeout(self):",
            "        prev_session_id = self.session_id",
            "        # Given a user authenticated with MFA with \"login_persistent\"",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})",
            "        self.assertStatus(303)",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertNotEqual(prev_session_id, self.session_id)",
            "        session = DbSession(id=self.session_id)",
            "        session.load()",
            "        self.assertTrue(session['login_persistent'])",
            "        # When the mfa verification timeout (after 30 days)",
            "        session['_auth_mfa_time'] = session.now() - datetime.timedelta(days=30, seconds=1)",
            "        session.save()",
            "        # Then next query redirect user to mfa page",
            "        self.getPage(\"/prefs/general\")",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/mfa/')",
            "        # When user enter valid code",
            "        code = self._get_code()",
            "        self.getPage(\"/mfa/\", method='POST', body={'code': code, 'submit': '1', 'persistent': '1'})",
            "        # Then user is redirected to original page.",
            "        self.assertStatus(303)",
            "        self.assertHeaderItemValue('Location', self.baseurl + '/prefs/general')",
            "        self.getPage(\"/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody('Repositories')",
            "",
            "",
            "class MfaPageWithWelcomeMsgTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    default_config = {'welcomemsg': 'default message', 'welcomemsg[fr]': 'french message'}",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # Enabled MFA for all test cases",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.mfa = UserObject.ENABLED_MFA",
            "        userobj.email = 'admin@example.com'",
            "        userobj.commit()",
            "",
            "    def test_getpage_default(self):",
            "        # Given a user with MFA enabled",
            "        # When querying the mfa page",
            "        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"it\")])",
            "        # Then page is return without error with the custom welcome message",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('default message')",
            "",
            "    def test_getpage_french(self):",
            "        # Given a user with MFA enabled",
            "        # When querying the mfa page in french",
            "        self.getPage('/mfa/', headers=[(\"Accept-Language\", \"fr\")])",
            "        # Then page is return without error with the custom welcome message in french",
            "        self.assertStatus('200 OK')",
            "        self.assertInBody('french message')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "55": [
                "MfaPageTest",
                "test_get_without_login"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/controller/tests/test_secure_headers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             ('/invalid', 404),"
            },
            "1": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             ('/browse/invalid', 404),"
            },
            "2": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             ('/login', 301),"
            },
            "3": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ('/logout', 303),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            ('/logout', 405),"
            },
            "5": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         ]"
            },
            "6": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     )"
            },
            "7": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def test_cookie_with_https_http_error(self, url, expected_error_code):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Oct 20, 2021",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "from parameterized import parameterized",
            "",
            "import rdiffweb.test",
            "",
            "",
            "class SecureHeadersTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_cookie_samesite_lax(self):",
            "        # Given a request made to rdiffweb",
            "        # When receiving the response",
            "        self.getPage('/')",
            "        # Then the header contains Set-Cookie with SameSite=Lax",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('SameSite=Lax', cookie)",
            "",
            "    def test_cookie_samesite_lax_without_session(self):",
            "        # Given not a client sending no cookie",
            "        self.cookies = None",
            "        # When a query is made to a static path (without session)",
            "        self.getPage('/static/blue.css')",
            "        # Then Set-Cookie is not defined.",
            "        self.assertNoHeader('Set-Cookie')",
            "",
            "    def test_cookie_with_https(self):",
            "        # Given an https request made to rdiffweb",
            "        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])",
            "        # When receiving the response",
            "        self.assertStatus(200)",
            "        # Then the header contains Set-Cookie with Secure",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('Secure', cookie)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            ('/invalid', 404),",
            "            ('/browse/invalid', 404),",
            "            ('/login', 301),",
            "            ('/logout', 303),",
            "        ]",
            "    )",
            "    def test_cookie_with_https_http_error(self, url, expected_error_code):",
            "        # Given an https request made to rdiffweb",
            "        self.getPage(url, headers=[('X-Forwarded-Proto', 'https')])",
            "        # When receiving the response",
            "        self.assertStatus(expected_error_code)",
            "        # Then the header contains Set-Cookie with Secure",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('Secure', cookie)",
            "",
            "    def test_cookie_with_http(self):",
            "        # Given an https request made to rdiffweb",
            "        self.getPage('/')",
            "        # When receiving the response",
            "        # Then the header contains Set-Cookie with Secure",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertNotIn('Secure', cookie)",
            "",
            "    def test_get_with_wrong_origin(self):",
            "        # Given a GET request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        self.getPage('/', headers=[('Origin', 'http://www.examples.com')])",
            "        # Then the response status it 200 OK.",
            "        self.assertStatus(200)",
            "",
            "    def test_post_with_wrong_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        self.getPage('/', headers=[('Origin', 'http://www.examples.com')], method='POST')",
            "        # Then the request is refused with 403 Forbiden",
            "        self.assertStatus(403)",
            "        self.assertInBody('Unexpected Origin header')",
            "",
            "    def test_post_with_prefixed_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        base = 'http://%s:%s' % (self.HOST + 'anything.com', self.PORT)",
            "        self.getPage('/dashboard/', headers=[('Origin', base)], method='POST')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(403)",
            "        self.assertInBody('Unexpected Origin header')",
            "",
            "    def test_post_with_valid_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        base = 'http://%s:%s' % (self.HOST, self.PORT)",
            "        self.getPage('/', headers=[('Origin', base)], method='POST')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "",
            "    def test_post_without_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/', method='POST')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "",
            "    def test_clickjacking_defense(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('X-Frame-Options', 'DENY')",
            "",
            "    def test_no_cache(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('Cache-control', 'no-cache')",
            "        self.assertHeaderItemValue('Cache-control', 'no-store')",
            "        self.assertHeaderItemValue('Cache-control', 'must-revalidate')",
            "        self.assertHeaderItemValue('Cache-control', 'max-age=0')",
            "        self.assertHeaderItemValue('Pragma', 'no-cache')",
            "        self.assertHeaderItemValue('Expires', '0')",
            "",
            "    def test_no_cache_with_static(self):",
            "        self.getPage('/static/js/rdiffweb.js')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertNoHeader('Cache-control')",
            "        self.assertNoHeader('Pragma')",
            "        self.assertNoHeader('Expires')",
            "",
            "    def test_referrer_policy(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('Referrer-Policy', 'same-origin')",
            "",
            "    def test_nosniff(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('X-Content-Type-Options', 'nosniff')",
            "",
            "    def test_xss_protection(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('X-XSS-Protection', '1; mode=block')",
            "",
            "    def test_content_security_policy(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue(",
            "            'Content-Security-Policy',",
            "            \"default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'\",",
            "        )",
            "",
            "    def test_strict_transport_security(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Oct 20, 2021",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "from parameterized import parameterized",
            "",
            "import rdiffweb.test",
            "",
            "",
            "class SecureHeadersTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_cookie_samesite_lax(self):",
            "        # Given a request made to rdiffweb",
            "        # When receiving the response",
            "        self.getPage('/')",
            "        # Then the header contains Set-Cookie with SameSite=Lax",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('SameSite=Lax', cookie)",
            "",
            "    def test_cookie_samesite_lax_without_session(self):",
            "        # Given not a client sending no cookie",
            "        self.cookies = None",
            "        # When a query is made to a static path (without session)",
            "        self.getPage('/static/blue.css')",
            "        # Then Set-Cookie is not defined.",
            "        self.assertNoHeader('Set-Cookie')",
            "",
            "    def test_cookie_with_https(self):",
            "        # Given an https request made to rdiffweb",
            "        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])",
            "        # When receiving the response",
            "        self.assertStatus(200)",
            "        # Then the header contains Set-Cookie with Secure",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('Secure', cookie)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            ('/invalid', 404),",
            "            ('/browse/invalid', 404),",
            "            ('/login', 301),",
            "            ('/logout', 405),",
            "        ]",
            "    )",
            "    def test_cookie_with_https_http_error(self, url, expected_error_code):",
            "        # Given an https request made to rdiffweb",
            "        self.getPage(url, headers=[('X-Forwarded-Proto', 'https')])",
            "        # When receiving the response",
            "        self.assertStatus(expected_error_code)",
            "        # Then the header contains Set-Cookie with Secure",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertIn('Secure', cookie)",
            "",
            "    def test_cookie_with_http(self):",
            "        # Given an https request made to rdiffweb",
            "        self.getPage('/')",
            "        # When receiving the response",
            "        # Then the header contains Set-Cookie with Secure",
            "        cookie = self.assertHeader('Set-Cookie')",
            "        self.assertNotIn('Secure', cookie)",
            "",
            "    def test_get_with_wrong_origin(self):",
            "        # Given a GET request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        self.getPage('/', headers=[('Origin', 'http://www.examples.com')])",
            "        # Then the response status it 200 OK.",
            "        self.assertStatus(200)",
            "",
            "    def test_post_with_wrong_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        self.getPage('/', headers=[('Origin', 'http://www.examples.com')], method='POST')",
            "        # Then the request is refused with 403 Forbiden",
            "        self.assertStatus(403)",
            "        self.assertInBody('Unexpected Origin header')",
            "",
            "    def test_post_with_prefixed_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        base = 'http://%s:%s' % (self.HOST + 'anything.com', self.PORT)",
            "        self.getPage('/dashboard/', headers=[('Origin', base)], method='POST')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(403)",
            "        self.assertInBody('Unexpected Origin header')",
            "",
            "    def test_post_with_valid_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made using a different origin",
            "        base = 'http://%s:%s' % (self.HOST, self.PORT)",
            "        self.getPage('/', headers=[('Origin', base)], method='POST')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "",
            "    def test_post_without_origin(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/', method='POST')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "",
            "    def test_clickjacking_defense(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('X-Frame-Options', 'DENY')",
            "",
            "    def test_no_cache(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('Cache-control', 'no-cache')",
            "        self.assertHeaderItemValue('Cache-control', 'no-store')",
            "        self.assertHeaderItemValue('Cache-control', 'must-revalidate')",
            "        self.assertHeaderItemValue('Cache-control', 'max-age=0')",
            "        self.assertHeaderItemValue('Pragma', 'no-cache')",
            "        self.assertHeaderItemValue('Expires', '0')",
            "",
            "    def test_no_cache_with_static(self):",
            "        self.getPage('/static/js/rdiffweb.js')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertNoHeader('Cache-control')",
            "        self.assertNoHeader('Pragma')",
            "        self.assertNoHeader('Expires')",
            "",
            "    def test_referrer_policy(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('Referrer-Policy', 'same-origin')",
            "",
            "    def test_nosniff(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('X-Content-Type-Options', 'nosniff')",
            "",
            "    def test_xss_protection(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('X-XSS-Protection', '1; mode=block')",
            "",
            "    def test_content_security_policy(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/')",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue(",
            "            'Content-Security-Policy',",
            "            \"default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'\",",
            "        )",
            "",
            "    def test_strict_transport_security(self):",
            "        # Given a POST request made to rdiffweb",
            "        # When the request is made without an origin",
            "        self.getPage('/', headers=[('X-Forwarded-Proto', 'https')])",
            "        # Then the request is accepted with 200 OK",
            "        self.assertStatus(200)",
            "        self.assertHeaderItemValue('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "61": [
                "SecureHeadersTest"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         return json.loads(self.body.decode('utf8'))"
            },
            "1": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     def _login(self, username=USERNAME, password=PASSWORD):"
            },
            "3": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.getPage(\"/logout\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        self.getPage(\"/logout\", method=\"POST\")"
            },
            "5": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         self.getPage(\"/login/\", method='POST', body={'login': username, 'password': password})"
            },
            "6": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         self.assertStatus('303 See Other')"
            },
            "7": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Oct 14, 2015",
            "",
            "Mock class for testing.",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "import json",
            "import os",
            "import shutil",
            "import subprocess",
            "import tempfile",
            "import time",
            "import unittest",
            "import unittest.mock",
            "from threading import Thread",
            "from urllib.parse import urlencode",
            "",
            "import cherrypy",
            "import pkg_resources",
            "from cherrypy.test import helper",
            "",
            "from rdiffweb.core.model import UserObject",
            "from rdiffweb.rdw_app import RdiffwebApp",
            "",
            "# For cherrypy8, we need to monkey patch Thread.isAlive",
            "Thread.isAlive = Thread.is_alive",
            "",
            "",
            "def create_testcases_repo(app):",
            "    \"\"\"Extract testcases.\"\"\"",
            "    # Extract 'testcases.tar.gz'",
            "    testcases = pkg_resources.resource_filename('rdiffweb.tests', 'testcases.tar.gz')  # @UndefinedVariable",
            "    new = str(tempfile.mkdtemp(prefix='rdiffweb_tests_'))",
            "    subprocess.check_call(['tar', '-zxf', testcases], cwd=new)",
            "    return new",
            "",
            "",
            "class WebCase(helper.CPWebCase):",
            "    \"\"\"",
            "    Helper class for the rdiffweb test suite.",
            "    \"\"\"",
            "",
            "    REPO = 'testcases'",
            "",
            "    USERNAME = 'admin'",
            "",
            "    PASSWORD = 'admin123'",
            "",
            "    interactive = False",
            "",
            "    login = False",
            "",
            "    default_config = {}",
            "",
            "    app_class = RdiffwebApp",
            "",
            "    @classmethod",
            "    def setup_class(cls):",
            "        if cls is WebCase:",
            "            raise unittest.SkipTest(\"%s is an abstract base class\" % cls.__name__)",
            "        super().setup_class()",
            "        cls.do_gc_test = False",
            "",
            "    @classmethod",
            "    def teardown_class(cls):",
            "        super().teardown_class()",
            "        cherrypy.tools.db.drop_all()",
            "        if hasattr(cherrypy, '_cache'):",
            "            cherrypy._cache.clear()",
            "",
            "    @classmethod",
            "    def setup_server(cls):",
            "        # Allow defining a custom database uri for testing.",
            "        uri = os.environ.get(",
            "            'RDIFFWEB_TEST_DATABASE_URI', 'sqlite:///' + tempfile.gettempdir() + '/test_rdiffweb_data.db'",
            "        )",
            "        cls.default_config['database-uri'] = uri",
            "        # Disable rate-limit for testing.",
            "        if 'rate-limit' not in cls.default_config:",
            "            cls.default_config['rate-limit'] = -1",
            "        cfg = cls.app_class.parse_args(",
            "            args=[], config_file_contents='\\n'.join('%s=%s' % (k, v) for k, v in cls.default_config.items())",
            "        )",
            "        # Create Application",
            "        app = cls.app_class(cfg)",
            "        cherrypy.tree.mount(app)",
            "",
            "    def setUp(self):",
            "        helper.CPWebCase.setUp(self)",
            "        if hasattr(cherrypy, '_cache'):",
            "            cherrypy._cache.clear()",
            "        cherrypy.tools.db.drop_all()",
            "        cherrypy.tools.db.create_all()",
            "        # Create default admin",
            "        admin_user = UserObject.create_admin_user(self.USERNAME, self.PASSWORD)",
            "        admin_user.commit()",
            "        # Create testcases repo",
            "        self.testcases = create_testcases_repo(self.app)",
            "        if admin_user:",
            "            admin_user.user_root = self.testcases",
            "            admin_user.refresh_repos()",
            "            admin_user.commit()",
            "        # Login to web application.",
            "        if self.login:",
            "            self._login()",
            "",
            "    def tearDown(self):",
            "        if hasattr(self, 'testcases'):",
            "            shutil.rmtree(self.testcases)",
            "            delattr(self, 'testcases')",
            "        cherrypy.tools.db.drop_all()",
            "        if hasattr(cherrypy, '_cache'):",
            "            cherrypy._cache.clear()",
            "",
            "    @property",
            "    def app(self):",
            "        \"\"\"",
            "        Return reference to Rdiffweb application.",
            "        \"\"\"",
            "        return cherrypy.tree.apps['']",
            "",
            "    @property",
            "    def session(self):",
            "        return cherrypy.tools.db.get_session()",
            "",
            "    @property",
            "    def session_id(self):",
            "        if hasattr(self, 'cookies') and self.cookies:",
            "            for unused, value in self.cookies:",
            "                for part in value.split(';'):",
            "                    key, unused, value = part.partition('=')",
            "                    if key == 'session_id':",
            "                        return value",
            "",
            "    @property",
            "    def baseurl(self):",
            "        return 'http://%s:%s' % (self.HOST, self.PORT)",
            "",
            "    def getPage(self, url, headers=None, method=\"GET\", body=None, protocol=None):",
            "        if headers is None:",
            "            headers = []",
            "        # When body is a dict, send the data as form data.",
            "        if isinstance(body, dict) and method in ['POST', 'PUT']:",
            "            data = [(k.encode(encoding='latin1'), v.encode(encoding='utf-8')) for k, v in body.items()]",
            "            body = urlencode(data)",
            "        # Send back cookies if any",
            "        if hasattr(self, 'cookies') and self.cookies:",
            "            headers.extend(self.cookies)",
            "        # CherryPy ~8.9.1 is not handling absolute URL properly and web browser",
            "        # are usually not sending absolute URL either. So trim the base.",
            "        base = 'http://%s:%s' % (self.HOST, self.PORT)",
            "        if url.startswith(base):",
            "            url = url[len(base) :]",
            "        helper.CPWebCase.getPage(self, url, headers, method, body, protocol)",
            "",
            "    def getJson(self, *args, **kwargs):",
            "        self.getPage(*args, **kwargs)",
            "        self.assertStatus(200)",
            "        return json.loads(self.body.decode('utf8'))",
            "",
            "    def _login(self, username=USERNAME, password=PASSWORD):",
            "        self.getPage(\"/logout\")",
            "        self.getPage(\"/login/\", method='POST', body={'login': username, 'password': password})",
            "        self.assertStatus('303 See Other')",
            "",
            "    def wait_for_tasks(self):",
            "        time.sleep(1)",
            "        while len(cherrypy.scheduler.list_tasks()) or cherrypy.scheduler.is_job_running():",
            "            time.sleep(1)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Oct 14, 2015",
            "",
            "Mock class for testing.",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "import json",
            "import os",
            "import shutil",
            "import subprocess",
            "import tempfile",
            "import time",
            "import unittest",
            "import unittest.mock",
            "from threading import Thread",
            "from urllib.parse import urlencode",
            "",
            "import cherrypy",
            "import pkg_resources",
            "from cherrypy.test import helper",
            "",
            "from rdiffweb.core.model import UserObject",
            "from rdiffweb.rdw_app import RdiffwebApp",
            "",
            "# For cherrypy8, we need to monkey patch Thread.isAlive",
            "Thread.isAlive = Thread.is_alive",
            "",
            "",
            "def create_testcases_repo(app):",
            "    \"\"\"Extract testcases.\"\"\"",
            "    # Extract 'testcases.tar.gz'",
            "    testcases = pkg_resources.resource_filename('rdiffweb.tests', 'testcases.tar.gz')  # @UndefinedVariable",
            "    new = str(tempfile.mkdtemp(prefix='rdiffweb_tests_'))",
            "    subprocess.check_call(['tar', '-zxf', testcases], cwd=new)",
            "    return new",
            "",
            "",
            "class WebCase(helper.CPWebCase):",
            "    \"\"\"",
            "    Helper class for the rdiffweb test suite.",
            "    \"\"\"",
            "",
            "    REPO = 'testcases'",
            "",
            "    USERNAME = 'admin'",
            "",
            "    PASSWORD = 'admin123'",
            "",
            "    interactive = False",
            "",
            "    login = False",
            "",
            "    default_config = {}",
            "",
            "    app_class = RdiffwebApp",
            "",
            "    @classmethod",
            "    def setup_class(cls):",
            "        if cls is WebCase:",
            "            raise unittest.SkipTest(\"%s is an abstract base class\" % cls.__name__)",
            "        super().setup_class()",
            "        cls.do_gc_test = False",
            "",
            "    @classmethod",
            "    def teardown_class(cls):",
            "        super().teardown_class()",
            "        cherrypy.tools.db.drop_all()",
            "        if hasattr(cherrypy, '_cache'):",
            "            cherrypy._cache.clear()",
            "",
            "    @classmethod",
            "    def setup_server(cls):",
            "        # Allow defining a custom database uri for testing.",
            "        uri = os.environ.get(",
            "            'RDIFFWEB_TEST_DATABASE_URI', 'sqlite:///' + tempfile.gettempdir() + '/test_rdiffweb_data.db'",
            "        )",
            "        cls.default_config['database-uri'] = uri",
            "        # Disable rate-limit for testing.",
            "        if 'rate-limit' not in cls.default_config:",
            "            cls.default_config['rate-limit'] = -1",
            "        cfg = cls.app_class.parse_args(",
            "            args=[], config_file_contents='\\n'.join('%s=%s' % (k, v) for k, v in cls.default_config.items())",
            "        )",
            "        # Create Application",
            "        app = cls.app_class(cfg)",
            "        cherrypy.tree.mount(app)",
            "",
            "    def setUp(self):",
            "        helper.CPWebCase.setUp(self)",
            "        if hasattr(cherrypy, '_cache'):",
            "            cherrypy._cache.clear()",
            "        cherrypy.tools.db.drop_all()",
            "        cherrypy.tools.db.create_all()",
            "        # Create default admin",
            "        admin_user = UserObject.create_admin_user(self.USERNAME, self.PASSWORD)",
            "        admin_user.commit()",
            "        # Create testcases repo",
            "        self.testcases = create_testcases_repo(self.app)",
            "        if admin_user:",
            "            admin_user.user_root = self.testcases",
            "            admin_user.refresh_repos()",
            "            admin_user.commit()",
            "        # Login to web application.",
            "        if self.login:",
            "            self._login()",
            "",
            "    def tearDown(self):",
            "        if hasattr(self, 'testcases'):",
            "            shutil.rmtree(self.testcases)",
            "            delattr(self, 'testcases')",
            "        cherrypy.tools.db.drop_all()",
            "        if hasattr(cherrypy, '_cache'):",
            "            cherrypy._cache.clear()",
            "",
            "    @property",
            "    def app(self):",
            "        \"\"\"",
            "        Return reference to Rdiffweb application.",
            "        \"\"\"",
            "        return cherrypy.tree.apps['']",
            "",
            "    @property",
            "    def session(self):",
            "        return cherrypy.tools.db.get_session()",
            "",
            "    @property",
            "    def session_id(self):",
            "        if hasattr(self, 'cookies') and self.cookies:",
            "            for unused, value in self.cookies:",
            "                for part in value.split(';'):",
            "                    key, unused, value = part.partition('=')",
            "                    if key == 'session_id':",
            "                        return value",
            "",
            "    @property",
            "    def baseurl(self):",
            "        return 'http://%s:%s' % (self.HOST, self.PORT)",
            "",
            "    def getPage(self, url, headers=None, method=\"GET\", body=None, protocol=None):",
            "        if headers is None:",
            "            headers = []",
            "        # When body is a dict, send the data as form data.",
            "        if isinstance(body, dict) and method in ['POST', 'PUT']:",
            "            data = [(k.encode(encoding='latin1'), v.encode(encoding='utf-8')) for k, v in body.items()]",
            "            body = urlencode(data)",
            "        # Send back cookies if any",
            "        if hasattr(self, 'cookies') and self.cookies:",
            "            headers.extend(self.cookies)",
            "        # CherryPy ~8.9.1 is not handling absolute URL properly and web browser",
            "        # are usually not sending absolute URL either. So trim the base.",
            "        base = 'http://%s:%s' % (self.HOST, self.PORT)",
            "        if url.startswith(base):",
            "            url = url[len(base) :]",
            "        helper.CPWebCase.getPage(self, url, headers, method, body, protocol)",
            "",
            "    def getJson(self, *args, **kwargs):",
            "        self.getPage(*args, **kwargs)",
            "        self.assertStatus(200)",
            "        return json.loads(self.body.decode('utf8'))",
            "",
            "    def _login(self, username=USERNAME, password=PASSWORD):",
            "        self.getPage(\"/logout\", method=\"POST\")",
            "        self.getPage(\"/login/\", method='POST', body={'login': username, 'password': password})",
            "        self.assertStatus('303 See Other')",
            "",
            "    def wait_for_tasks(self):",
            "        time.sleep(1)",
            "        while len(cherrypy.scheduler.list_tasks()) or cherrypy.scheduler.is_job_running():",
            "            time.sleep(1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "179": [
                "WebCase",
                "_login"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/tools/auth_form.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         # Clear session when browsing /logout"
            },
            "2": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         if request.path_info == logout_url or request.path_info.startswith(logout_url):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            if request.method != 'POST':"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+                raise cherrypy.HTTPError(405)"
            },
            "5": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             self.logout()"
            },
            "6": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             raise cherrypy.HTTPRedirect('/')"
            },
            "7": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import datetime",
            "import time",
            "import urllib.parse",
            "",
            "import cherrypy",
            "from cherrypy.lib import httputil",
            "",
            "SESSION_KEY = '_cp_username'",
            "LOGIN_TIME = 'login_time'",
            "LOGIN_REDIRECT_URL = '_auth_form_redirect_url'",
            "LOGIN_PERSISTENT = 'login_persistent'",
            "",
            "",
            "class CheckAuthForm(cherrypy.Tool):",
            "    def __init__(self, priority=73):",
            "        super().__init__(point='before_handler', callable=self.run, priority=priority)",
            "",
            "    def _is_login(self):",
            "        \"\"\"",
            "        Verify if the login expired and we need to prompt the user to authenticated again using either credentials and/or MFA.",
            "        \"\"\"",
            "        # Verify if current user exists",
            "        request = cherrypy.serving.request",
            "        if not getattr(request, 'currentuser', None):",
            "            return False",
            "",
            "        # Verify if session is enabled",
            "        sessions_on = request.config.get('tools.sessions.on', False)",
            "        if not sessions_on:",
            "            return False",
            "",
            "        # Verify session",
            "        # We don't need to verify the timeout value since expired session get deleted automatically.",
            "        session = cherrypy.session",
            "        return session.get(SESSION_KEY) is not None and session.get(LOGIN_TIME) is not None",
            "",
            "    def _get_redirect_url(self):",
            "        \"\"\"",
            "        Return the original URL the user browser before getting redirect to login.",
            "        \"\"\"",
            "        return cherrypy.session.get(LOGIN_REDIRECT_URL) or '/'",
            "",
            "    def _set_redirect_url(self):",
            "        # Keep reference to the current URL",
            "        request = cherrypy.serving.request",
            "        uri_encoding = getattr(request, 'uri_encoding', 'utf-8')",
            "        original_url = urllib.parse.quote(request.path_info, encoding=uri_encoding)",
            "        qs = request.query_string",
            "        new_url = cherrypy.url(original_url, qs=qs, base='')",
            "        cherrypy.session[LOGIN_REDIRECT_URL] = new_url",
            "",
            "    def _update_session_timeout(self, persistent_timeout=43200, absolute_timeout=30):",
            "        \"\"\"",
            "        Since we have multiple timeout value (idle, absolute and persistent) We need to update the session timeout and possibly the cookie timeout.",
            "        \"\"\"",
            "        persistent_timeout = cherrypy.request.config.get('tools.auth_form.persistent_timeout', 43200)",
            "        absolute_timeout = cherrypy.request.config.get('tools.auth_form.absolute_timeout', 30)",
            "        # If login is persistent, update the cookie max-age/expires",
            "        session = cherrypy.session",
            "        if session.get(LOGIN_PERSISTENT, False):",
            "            expiration = session[LOGIN_TIME] + datetime.timedelta(minutes=persistent_timeout)",
            "            session.timeout = int((expiration - session.now()).total_seconds() / 60)",
            "            cookie = cherrypy.serving.response.cookie",
            "            cookie['session_id']['max-age'] = session.timeout * 60",
            "            cookie['session_id']['expires'] = httputil.HTTPDate(time.time() + session.timeout * 60)",
            "        else:",
            "            session_idle_timeout = cherrypy.request.config.get('tools.sessions.timeout', 60)",
            "            expiration1 = session.now() + datetime.timedelta(minutes=session_idle_timeout)",
            "            expiration2 = session[LOGIN_TIME] + datetime.timedelta(minutes=absolute_timeout)",
            "            expiration = min(expiration1, expiration2)",
            "            session.timeout = int((expiration - session.now()).total_seconds() / 60)",
            "",
            "    def redirect_to_original_url(self):",
            "        # Redirect user to original URL",
            "        raise cherrypy.HTTPRedirect(self._get_redirect_url())",
            "",
            "    def run(self, login_url='/login/', logout_url='/logout', persistent_timeout=43200, absolute_timeout=30):",
            "        \"\"\"",
            "        A tool that verify if the session is associated to a user by tracking",
            "        a session key. If session is not authenticated, redirect user to login page.",
            "        \"\"\"",
            "        request = cherrypy.serving.request",
            "        # Skip execution of this tools when browsing the login page.",
            "        if request.path_info == login_url:",
            "            if self._is_login():",
            "                raise cherrypy.HTTPRedirect('/')",
            "            return",
            "",
            "        # Clear session when browsing /logout",
            "        if request.path_info == logout_url or request.path_info.startswith(logout_url):",
            "            self.logout()",
            "            raise cherrypy.HTTPRedirect('/')",
            "",
            "        # Check if login",
            "        if not self._is_login():",
            "            # Store original URL",
            "            self._set_redirect_url()",
            "            # And redirect to login page",
            "            raise cherrypy.HTTPRedirect(login_url)",
            "",
            "        self._update_session_timeout()",
            "",
            "    def login(self, username, persistent=False):",
            "        \"\"\"",
            "        Must be called by the page hanlder when the authentication is successful.",
            "        \"\"\"",
            "        # Store session data",
            "        cherrypy.session[LOGIN_PERSISTENT] = persistent",
            "        cherrypy.session[SESSION_KEY] = username",
            "        cherrypy.session[LOGIN_TIME] = cherrypy.session.now()",
            "        # Generate a new session id",
            "        cherrypy.session.regenerate()",
            "        # Update the session timeout",
            "        self._update_session_timeout()",
            "",
            "    def logout(self):",
            "        # Clear session date and generate a new session id",
            "        cherrypy.session.clear()",
            "        cherrypy.session.regenerate()",
            "",
            "",
            "cherrypy.tools.auth_form = CheckAuthForm()"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import datetime",
            "import time",
            "import urllib.parse",
            "",
            "import cherrypy",
            "from cherrypy.lib import httputil",
            "",
            "SESSION_KEY = '_cp_username'",
            "LOGIN_TIME = 'login_time'",
            "LOGIN_REDIRECT_URL = '_auth_form_redirect_url'",
            "LOGIN_PERSISTENT = 'login_persistent'",
            "",
            "",
            "class CheckAuthForm(cherrypy.Tool):",
            "    def __init__(self, priority=73):",
            "        super().__init__(point='before_handler', callable=self.run, priority=priority)",
            "",
            "    def _is_login(self):",
            "        \"\"\"",
            "        Verify if the login expired and we need to prompt the user to authenticated again using either credentials and/or MFA.",
            "        \"\"\"",
            "        # Verify if current user exists",
            "        request = cherrypy.serving.request",
            "        if not getattr(request, 'currentuser', None):",
            "            return False",
            "",
            "        # Verify if session is enabled",
            "        sessions_on = request.config.get('tools.sessions.on', False)",
            "        if not sessions_on:",
            "            return False",
            "",
            "        # Verify session",
            "        # We don't need to verify the timeout value since expired session get deleted automatically.",
            "        session = cherrypy.session",
            "        return session.get(SESSION_KEY) is not None and session.get(LOGIN_TIME) is not None",
            "",
            "    def _get_redirect_url(self):",
            "        \"\"\"",
            "        Return the original URL the user browser before getting redirect to login.",
            "        \"\"\"",
            "        return cherrypy.session.get(LOGIN_REDIRECT_URL) or '/'",
            "",
            "    def _set_redirect_url(self):",
            "        # Keep reference to the current URL",
            "        request = cherrypy.serving.request",
            "        uri_encoding = getattr(request, 'uri_encoding', 'utf-8')",
            "        original_url = urllib.parse.quote(request.path_info, encoding=uri_encoding)",
            "        qs = request.query_string",
            "        new_url = cherrypy.url(original_url, qs=qs, base='')",
            "        cherrypy.session[LOGIN_REDIRECT_URL] = new_url",
            "",
            "    def _update_session_timeout(self, persistent_timeout=43200, absolute_timeout=30):",
            "        \"\"\"",
            "        Since we have multiple timeout value (idle, absolute and persistent) We need to update the session timeout and possibly the cookie timeout.",
            "        \"\"\"",
            "        persistent_timeout = cherrypy.request.config.get('tools.auth_form.persistent_timeout', 43200)",
            "        absolute_timeout = cherrypy.request.config.get('tools.auth_form.absolute_timeout', 30)",
            "        # If login is persistent, update the cookie max-age/expires",
            "        session = cherrypy.session",
            "        if session.get(LOGIN_PERSISTENT, False):",
            "            expiration = session[LOGIN_TIME] + datetime.timedelta(minutes=persistent_timeout)",
            "            session.timeout = int((expiration - session.now()).total_seconds() / 60)",
            "            cookie = cherrypy.serving.response.cookie",
            "            cookie['session_id']['max-age'] = session.timeout * 60",
            "            cookie['session_id']['expires'] = httputil.HTTPDate(time.time() + session.timeout * 60)",
            "        else:",
            "            session_idle_timeout = cherrypy.request.config.get('tools.sessions.timeout', 60)",
            "            expiration1 = session.now() + datetime.timedelta(minutes=session_idle_timeout)",
            "            expiration2 = session[LOGIN_TIME] + datetime.timedelta(minutes=absolute_timeout)",
            "            expiration = min(expiration1, expiration2)",
            "            session.timeout = int((expiration - session.now()).total_seconds() / 60)",
            "",
            "    def redirect_to_original_url(self):",
            "        # Redirect user to original URL",
            "        raise cherrypy.HTTPRedirect(self._get_redirect_url())",
            "",
            "    def run(self, login_url='/login/', logout_url='/logout', persistent_timeout=43200, absolute_timeout=30):",
            "        \"\"\"",
            "        A tool that verify if the session is associated to a user by tracking",
            "        a session key. If session is not authenticated, redirect user to login page.",
            "        \"\"\"",
            "        request = cherrypy.serving.request",
            "        # Skip execution of this tools when browsing the login page.",
            "        if request.path_info == login_url:",
            "            if self._is_login():",
            "                raise cherrypy.HTTPRedirect('/')",
            "            return",
            "",
            "        # Clear session when browsing /logout",
            "        if request.path_info == logout_url or request.path_info.startswith(logout_url):",
            "            if request.method != 'POST':",
            "                raise cherrypy.HTTPError(405)",
            "            self.logout()",
            "            raise cherrypy.HTTPRedirect('/')",
            "",
            "        # Check if login",
            "        if not self._is_login():",
            "            # Store original URL",
            "            self._set_redirect_url()",
            "            # And redirect to login page",
            "            raise cherrypy.HTTPRedirect(login_url)",
            "",
            "        self._update_session_timeout()",
            "",
            "    def login(self, username, persistent=False):",
            "        \"\"\"",
            "        Must be called by the page hanlder when the authentication is successful.",
            "        \"\"\"",
            "        # Store session data",
            "        cherrypy.session[LOGIN_PERSISTENT] = persistent",
            "        cherrypy.session[SESSION_KEY] = username",
            "        cherrypy.session[LOGIN_TIME] = cherrypy.session.now()",
            "        # Generate a new session id",
            "        cherrypy.session.regenerate()",
            "        # Update the session timeout",
            "        self._update_session_timeout()",
            "",
            "    def logout(self):",
            "        # Clear session date and generate a new session id",
            "        cherrypy.session.clear()",
            "        cherrypy.session.regenerate()",
            "",
            "",
            "cherrypy.tools.auth_form = CheckAuthForm()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "airflow.www.views.LogModelView"
        ]
    }
}