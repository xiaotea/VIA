{
    "gradio/processing_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import base64"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import hashlib"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+import ipaddress"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import json"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import logging"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import os"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import shutil"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+import socket"
            },
            "9": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import subprocess"
            },
            "10": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import tempfile"
            },
            "11": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import warnings"
            },
            "12": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from io import BytesIO"
            },
            "13": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from pathlib import Path"
            },
            "14": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from typing import TYPE_CHECKING, Any"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from urllib.parse import urlparse"
            },
            "16": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import aiofiles"
            },
            "18": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import httpx"
            },
            "19": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from gradio import utils, wasm_utils"
            },
            "20": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from gradio.data_classes import FileData, GradioModel, GradioRootModel, JsonData"
            },
            "21": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from gradio.exceptions import Error"
            },
            "22": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from gradio.utils import abspath, get_upload_folder, is_in_or_equal"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from gradio.utils import abspath, get_hash_seed, get_upload_folder, is_in_or_equal"
            },
            "24": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " with warnings.catch_warnings():"
            },
            "26": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     warnings.simplefilter(\"ignore\")  # Ignore pydub warning if ffmpeg is not installed"
            },
            "27": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         return output_bytes.getvalue()"
            },
            "28": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+hash_seed = get_hash_seed().encode(\"utf-8\")"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " def hash_file(file_path: str | Path, chunk_num_blocks: int = 128) -> str:"
            },
            "34": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "     sha1 = hashlib.sha1()"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+    sha1.update(hash_seed)"
            },
            "36": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     with open(file_path, \"rb\") as f:"
            },
            "37": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         for chunk in iter(lambda: f.read(chunk_num_blocks * sha1.block_size), b\"\"):"
            },
            "38": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "             sha1.update(chunk)"
            },
            "39": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 194,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " def hash_url(url: str) -> str:"
            },
            "41": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "     sha1 = hashlib.sha1()"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+    sha1.update(hash_seed)"
            },
            "43": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "     sha1.update(url.encode(\"utf-8\"))"
            },
            "44": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     return sha1.hexdigest()"
            },
            "45": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 200,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 201,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 202,
                "PatchRowcode": " def hash_bytes(bytes: bytes):"
            },
            "48": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "     sha1 = hashlib.sha1()"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+    sha1.update(hash_seed)"
            },
            "50": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "     sha1.update(bytes)"
            },
            "51": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "     return sha1.hexdigest()"
            },
            "52": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 208,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 209,
                "PatchRowcode": " def hash_base64(base64_encoding: str, chunk_num_blocks: int = 128) -> str:"
            },
            "55": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "     sha1 = hashlib.sha1()"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+    sha1.update(hash_seed)"
            },
            "57": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "     for i in range(0, len(base64_encoding), chunk_num_blocks * sha1.block_size):"
            },
            "58": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         data = base64_encoding[i : i + chunk_num_blocks * sha1.block_size]"
            },
            "59": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         sha1.update(data.encode(\"utf-8\"))"
            },
            "60": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "     return full_temp_file_path"
            },
            "61": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 271,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 272,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+def check_public_url(url: str):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+    parsed_url = urlparse(url)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    if parsed_url.scheme not in [\"http\", \"https\"]:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+        raise httpx.RequestError(f\"Invalid URL: {url}\")"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    hostname = parsed_url.hostname"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+    if not hostname:"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+        raise httpx.RequestError(f\"Invalid URL: {url}\")"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+    try:"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+        addrinfo = socket.getaddrinfo(hostname, None)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+    except socket.gaierror:"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        raise httpx.RequestError(f\"Cannot resolve hostname: {hostname}\") from None"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+    for family, _, _, _, sockaddr in addrinfo:"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+        ip = sockaddr[0]"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        if family == socket.AF_INET6:"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+            ip = ip.split(\"%\")[0]  # Remove scope ID if present"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+        if not ipaddress.ip_address(ip).is_global:"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+            raise httpx.RequestError("
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+                f\"Non-public IP address found: {ip} for URL: {url}\""
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+            )"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+    return True"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 299,
                "PatchRowcode": " def save_url_to_cache(url: str, cache_dir: str) -> str:"
            },
            "90": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "     \"\"\"Downloads a file and makes a temporary file path for a copy if does not already"
            },
            "91": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "     exist. Otherwise returns the path to the existing temp file.\"\"\""
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+    check_public_url(url)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "     temp_dir = hash_url(url)"
            },
            "95": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "     temp_dir = Path(cache_dir) / temp_dir"
            },
            "96": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "     temp_dir.mkdir(exist_ok=True, parents=True)"
            },
            "97": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     name = client_utils.strip_invalid_filename_characters(Path(url).name)"
            },
            "98": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "     full_temp_file_path = str(abspath(temp_dir / name))"
            },
            "99": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 309,
                "PatchRowcode": " "
            },
            "100": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "     if not Path(full_temp_file_path).exists():"
            },
            "101": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with sync_client.stream(\"GET\", url, follow_redirects=True) as r, open("
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+        with sync_client.stream(\"GET\", url, follow_redirects=True) as response, open("
            },
            "103": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             full_temp_file_path, \"wb\""
            },
            "104": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "         ) as f:"
            },
            "105": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for chunk in r.iter_raw():"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+            for redirect in response.history:"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+                check_public_url(str(redirect.url))"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+            for chunk in response.iter_raw():"
            },
            "110": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "                 f.write(chunk)"
            },
            "111": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 319,
                "PatchRowcode": " "
            },
            "112": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "     return full_temp_file_path"
            },
            "113": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 323,
                "PatchRowcode": " async def async_save_url_to_cache(url: str, cache_dir: str) -> str:"
            },
            "114": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "     \"\"\"Downloads a file and makes a temporary file path for a copy if does not already"
            },
            "115": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "     exist. Otherwise returns the path to the existing temp file. Uses async httpx.\"\"\""
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+    check_public_url(url)"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+"
            },
            "118": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "     temp_dir = hash_url(url)"
            },
            "119": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "     temp_dir = Path(cache_dir) / temp_dir"
            },
            "120": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "     temp_dir.mkdir(exist_ok=True, parents=True)"
            },
            "121": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 333,
                "PatchRowcode": " "
            },
            "122": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "     if not Path(full_temp_file_path).exists():"
            },
            "123": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         async with async_client.stream(\"GET\", url, follow_redirects=True) as response:"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+            for redirect in response.history:"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+                check_public_url(str(redirect.url))"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+"
            },
            "127": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "             async with aiofiles.open(full_temp_file_path, \"wb\") as f:"
            },
            "128": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "                 async for chunk in response.aiter_raw():"
            },
            "129": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "                     await f.write(chunk)"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import base64",
            "import hashlib",
            "import json",
            "import logging",
            "import os",
            "import shutil",
            "import subprocess",
            "import tempfile",
            "import warnings",
            "from io import BytesIO",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any",
            "",
            "import aiofiles",
            "import httpx",
            "import numpy as np",
            "from gradio_client import utils as client_utils",
            "from PIL import Image, ImageOps, ImageSequence, PngImagePlugin",
            "",
            "from gradio import utils, wasm_utils",
            "from gradio.data_classes import FileData, GradioModel, GradioRootModel, JsonData",
            "from gradio.exceptions import Error",
            "from gradio.utils import abspath, get_upload_folder, is_in_or_equal",
            "",
            "with warnings.catch_warnings():",
            "    warnings.simplefilter(\"ignore\")  # Ignore pydub warning if ffmpeg is not installed",
            "    from pydub import AudioSegment",
            "",
            "if wasm_utils.IS_WASM:",
            "    import pyodide.http  # type: ignore",
            "    import urllib3",
            "",
            "    # NOTE: In the Wasm env, we use urllib3 to make HTTP requests. See https://github.com/gradio-app/gradio/issues/6837.",
            "    class Urllib3ResponseSyncByteStream(httpx.SyncByteStream):",
            "        def __init__(self, response) -> None:",
            "            self.response = response",
            "",
            "        def __iter__(self):",
            "            yield from self.response.stream()",
            "",
            "    class Urllib3Transport(httpx.BaseTransport):",
            "        def __init__(self):",
            "            self.pool = urllib3.PoolManager()",
            "",
            "        def handle_request(self, request: httpx.Request) -> httpx.Response:",
            "            url = str(request.url)",
            "            method = str(request.method)",
            "            headers = dict(request.headers)",
            "            body = None if method in [\"GET\", \"HEAD\"] else request.read()",
            "",
            "            response = self.pool.request(",
            "                headers=headers,",
            "                method=method,",
            "                url=url,",
            "                body=body,",
            "                preload_content=False,  # Stream the content",
            "            )",
            "",
            "            return httpx.Response(",
            "                status_code=response.status,",
            "                headers=response.headers,",
            "                stream=Urllib3ResponseSyncByteStream(response),",
            "            )",
            "",
            "    sync_transport = Urllib3Transport()",
            "",
            "    class PyodideHttpResponseAsyncByteStream(httpx.AsyncByteStream):",
            "        def __init__(self, response) -> None:",
            "            self.response = response",
            "",
            "        async def __aiter__(self):",
            "            yield await self.response.bytes()",
            "",
            "    class PyodideHttpTransport(httpx.AsyncBaseTransport):",
            "        async def handle_async_request(",
            "            self,",
            "            request: httpx.Request,",
            "        ) -> httpx.Response:",
            "            url = str(request.url)",
            "            method = request.method",
            "            headers = dict(request.headers)",
            "            body = None if method in [\"GET\", \"HEAD\"] else await request.aread()",
            "            response = await pyodide.http.pyfetch(",
            "                url, method=method, headers=headers, body=body",
            "            )",
            "            return httpx.Response(",
            "                status_code=response.status,",
            "                headers=response.headers,",
            "                stream=PyodideHttpResponseAsyncByteStream(response),",
            "            )",
            "",
            "    async_transport = PyodideHttpTransport()",
            "else:",
            "    sync_transport = None",
            "    async_transport = None",
            "",
            "sync_client = httpx.Client(transport=sync_transport)",
            "async_client = httpx.AsyncClient(transport=async_transport)",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Block",
            "",
            "",
            "#########################",
            "# GENERAL",
            "#########################",
            "",
            "",
            "def to_binary(x: str | dict) -> bytes:",
            "    \"\"\"Converts a base64 string or dictionary to a binary string that can be sent in a POST.\"\"\"",
            "    if isinstance(x, dict):",
            "        if x.get(\"data\"):",
            "            base64str = x[\"data\"]",
            "        else:",
            "            base64str = client_utils.encode_url_or_file_to_base64(x[\"path\"])",
            "    else:",
            "        base64str = x",
            "    return base64.b64decode(extract_base64_data(base64str))",
            "",
            "",
            "def extract_base64_data(x: str) -> str:",
            "    \"\"\"Just extracts the base64 data from a general base64 string.\"\"\"",
            "    return x.rsplit(\",\", 1)[-1]",
            "",
            "",
            "#########################",
            "# IMAGE PRE-PROCESSING",
            "#########################",
            "",
            "",
            "def encode_plot_to_base64(plt, format: str = \"png\"):",
            "    fmt = format or \"png\"",
            "    with BytesIO() as output_bytes:",
            "        plt.savefig(output_bytes, format=fmt)",
            "        bytes_data = output_bytes.getvalue()",
            "    base64_str = str(base64.b64encode(bytes_data), \"utf-8\")",
            "    return f\"data:image/{format or 'png'};base64,{base64_str}\"",
            "",
            "",
            "def get_pil_exif_bytes(pil_image):",
            "    if \"exif\" in pil_image.info:",
            "        return pil_image.info[\"exif\"]",
            "",
            "",
            "def get_pil_metadata(pil_image):",
            "    # Copy any text-only metadata",
            "    metadata = PngImagePlugin.PngInfo()",
            "    for key, value in pil_image.info.items():",
            "        if isinstance(key, str) and isinstance(value, str):",
            "            metadata.add_text(key, value)",
            "",
            "    return metadata",
            "",
            "",
            "def encode_pil_to_bytes(pil_image, format=\"png\"):",
            "    with BytesIO() as output_bytes:",
            "        if format.lower() == \"gif\":",
            "            frames = [frame.copy() for frame in ImageSequence.Iterator(pil_image)]",
            "            frames[0].save(",
            "                output_bytes,",
            "                format=format,",
            "                save_all=True,",
            "                append_images=frames[1:],",
            "                loop=0,",
            "            )",
            "        else:",
            "            if format.lower() == \"png\":",
            "                params = {\"pnginfo\": get_pil_metadata(pil_image)}",
            "            else:",
            "                exif = get_pil_exif_bytes(pil_image)",
            "                params = {\"exif\": exif} if exif else {}",
            "            pil_image.save(output_bytes, format, **params)",
            "        return output_bytes.getvalue()",
            "",
            "",
            "def hash_file(file_path: str | Path, chunk_num_blocks: int = 128) -> str:",
            "    sha1 = hashlib.sha1()",
            "    with open(file_path, \"rb\") as f:",
            "        for chunk in iter(lambda: f.read(chunk_num_blocks * sha1.block_size), b\"\"):",
            "            sha1.update(chunk)",
            "    return sha1.hexdigest()",
            "",
            "",
            "def hash_url(url: str) -> str:",
            "    sha1 = hashlib.sha1()",
            "    sha1.update(url.encode(\"utf-8\"))",
            "    return sha1.hexdigest()",
            "",
            "",
            "def hash_bytes(bytes: bytes):",
            "    sha1 = hashlib.sha1()",
            "    sha1.update(bytes)",
            "    return sha1.hexdigest()",
            "",
            "",
            "def hash_base64(base64_encoding: str, chunk_num_blocks: int = 128) -> str:",
            "    sha1 = hashlib.sha1()",
            "    for i in range(0, len(base64_encoding), chunk_num_blocks * sha1.block_size):",
            "        data = base64_encoding[i : i + chunk_num_blocks * sha1.block_size]",
            "        sha1.update(data.encode(\"utf-8\"))",
            "    return sha1.hexdigest()",
            "",
            "",
            "def save_pil_to_cache(",
            "    img: Image.Image,",
            "    cache_dir: str,",
            "    name: str = \"image\",",
            "    format: str = \"webp\",",
            ") -> str:",
            "    bytes_data = encode_pil_to_bytes(img, format)",
            "    temp_dir = Path(cache_dir) / hash_bytes(bytes_data)",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    filename = str((temp_dir / f\"{name}.{format}\").resolve())",
            "    (temp_dir / f\"{name}.{format}\").resolve().write_bytes(bytes_data)",
            "    return filename",
            "",
            "",
            "def save_img_array_to_cache(",
            "    arr: np.ndarray, cache_dir: str, format: str = \"webp\"",
            ") -> str:",
            "    pil_image = Image.fromarray(_convert(arr, np.uint8, force_copy=False))",
            "    return save_pil_to_cache(pil_image, cache_dir, format=format)",
            "",
            "",
            "def save_audio_to_cache(",
            "    data: np.ndarray, sample_rate: int, format: str, cache_dir: str",
            ") -> str:",
            "    temp_dir = Path(cache_dir) / hash_bytes(data.tobytes())",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    filename = str((temp_dir / f\"audio.{format}\").resolve())",
            "    audio_to_file(sample_rate, data, filename, format=format)",
            "    return filename",
            "",
            "",
            "def save_bytes_to_cache(data: bytes, file_name: str, cache_dir: str) -> str:",
            "    path = Path(cache_dir) / hash_bytes(data)",
            "    path.mkdir(exist_ok=True, parents=True)",
            "    path = path / Path(file_name).name",
            "    path.write_bytes(data)",
            "    return str(path.resolve())",
            "",
            "",
            "def save_file_to_cache(file_path: str | Path, cache_dir: str) -> str:",
            "    \"\"\"Returns a temporary file path for a copy of the given file path if it does",
            "    not already exist. Otherwise returns the path to the existing temp file.\"\"\"",
            "    temp_dir = hash_file(file_path)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "",
            "    name = client_utils.strip_invalid_filename_characters(Path(file_path).name)",
            "    full_temp_file_path = str(abspath(temp_dir / name))",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        shutil.copy2(file_path, full_temp_file_path)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "def save_url_to_cache(url: str, cache_dir: str) -> str:",
            "    \"\"\"Downloads a file and makes a temporary file path for a copy if does not already",
            "    exist. Otherwise returns the path to the existing temp file.\"\"\"",
            "    temp_dir = hash_url(url)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    name = client_utils.strip_invalid_filename_characters(Path(url).name)",
            "    full_temp_file_path = str(abspath(temp_dir / name))",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        with sync_client.stream(\"GET\", url, follow_redirects=True) as r, open(",
            "            full_temp_file_path, \"wb\"",
            "        ) as f:",
            "            for chunk in r.iter_raw():",
            "                f.write(chunk)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "async def async_save_url_to_cache(url: str, cache_dir: str) -> str:",
            "    \"\"\"Downloads a file and makes a temporary file path for a copy if does not already",
            "    exist. Otherwise returns the path to the existing temp file. Uses async httpx.\"\"\"",
            "    temp_dir = hash_url(url)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    name = client_utils.strip_invalid_filename_characters(Path(url).name)",
            "    full_temp_file_path = str(abspath(temp_dir / name))",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        async with async_client.stream(\"GET\", url, follow_redirects=True) as response:",
            "            async with aiofiles.open(full_temp_file_path, \"wb\") as f:",
            "                async for chunk in response.aiter_raw():",
            "                    await f.write(chunk)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "def save_base64_to_cache(",
            "    base64_encoding: str, cache_dir: str, file_name: str | None = None",
            ") -> str:",
            "    \"\"\"Converts a base64 encoding to a file and returns the path to the file if",
            "    the file doesn't already exist. Otherwise returns the path to the existing file.",
            "    \"\"\"",
            "    temp_dir = hash_base64(base64_encoding)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "",
            "    guess_extension = client_utils.get_extension(base64_encoding)",
            "    if file_name:",
            "        file_name = client_utils.strip_invalid_filename_characters(file_name)",
            "    elif guess_extension:",
            "        file_name = f\"file.{guess_extension}\"",
            "    else:",
            "        file_name = \"file\"",
            "",
            "    full_temp_file_path = str(abspath(temp_dir / file_name))  # type: ignore",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        data, _ = client_utils.decode_base64_to_binary(base64_encoding)",
            "        with open(full_temp_file_path, \"wb\") as fb:",
            "            fb.write(data)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "def move_resource_to_block_cache(",
            "    url_or_file_path: str | Path | None, block: Block",
            ") -> str | None:",
            "    \"\"\"This method has been replaced by Block.move_resource_to_block_cache(), but is",
            "    left here for backwards compatibility for any custom components created in Gradio 4.2.0 or earlier.",
            "    \"\"\"",
            "    return block.move_resource_to_block_cache(url_or_file_path)",
            "",
            "",
            "def check_all_files_in_cache(data: JsonData):",
            "    def _in_cache(d: dict):",
            "        if (",
            "            (path := d.get(\"path\", \"\"))",
            "            and not client_utils.is_http_url_like(path)",
            "            and not is_in_or_equal(path, get_upload_folder())",
            "        ):",
            "            raise Error(",
            "                f\"File {path} is not in the cache folder and cannot be accessed.\"",
            "            )",
            "",
            "    client_utils.traverse(data, _in_cache, client_utils.is_file_obj)",
            "",
            "",
            "def move_files_to_cache(",
            "    data: Any,",
            "    block: Block,",
            "    postprocess: bool = False,",
            "    check_in_upload_folder=False,",
            "    keep_in_cache=False,",
            "):",
            "    \"\"\"Move any files in `data` to cache and (optionally), adds URL prefixes (/file=...) needed to access the cached file.",
            "    Also handles the case where the file is on an external Gradio app (/proxy=...).",
            "",
            "    Runs after .postprocess() and before .preprocess().",
            "",
            "    Args:",
            "        data: The input or output data for a component. Can be a dictionary or a dataclass",
            "        block: The component whose data is being processed",
            "        postprocess: Whether its running from postprocessing",
            "        check_in_upload_folder: If True, instead of moving the file to cache, checks if the file is in already in cache (exception if not).",
            "        keep_in_cache: If True, the file will not be deleted from cache when the server is shut down.",
            "    \"\"\"",
            "",
            "    def _move_to_cache(d: dict):",
            "        payload = FileData(**d)",
            "        # If the gradio app developer is returning a URL from",
            "        # postprocess, it means the component can display a URL",
            "        # without it being served from the gradio server",
            "        # This makes it so that the URL is not downloaded and speeds up event processing",
            "        if payload.url and postprocess and client_utils.is_http_url_like(payload.url):",
            "            payload.path = payload.url",
            "        elif utils.is_static_file(payload):",
            "            pass",
            "        elif not block.proxy_url:",
            "            # If the file is on a remote server, do not move it to cache.",
            "            if check_in_upload_folder and not client_utils.is_http_url_like(",
            "                payload.path",
            "            ):",
            "                path = os.path.abspath(payload.path)",
            "                if not is_in_or_equal(path, get_upload_folder()):",
            "                    raise ValueError(",
            "                        f\"File {path} is not in the upload folder and cannot be accessed.\"",
            "                    )",
            "            if not payload.is_stream:",
            "                temp_file_path = block.move_resource_to_block_cache(payload.path)",
            "                if temp_file_path is None:",
            "                    raise ValueError(\"Did not determine a file path for the resource.\")",
            "                payload.path = temp_file_path",
            "                if keep_in_cache:",
            "                    block.keep_in_cache.add(payload.path)",
            "",
            "        url_prefix = \"/stream/\" if payload.is_stream else \"/file=\"",
            "        if block.proxy_url:",
            "            proxy_url = block.proxy_url.rstrip(\"/\")",
            "            url = f\"/proxy={proxy_url}{url_prefix}{payload.path}\"",
            "        elif client_utils.is_http_url_like(payload.path) or payload.path.startswith(",
            "            f\"{url_prefix}\"",
            "        ):",
            "            url = payload.path",
            "        else:",
            "            url = f\"{url_prefix}{payload.path}\"",
            "        payload.url = url",
            "",
            "        return payload.model_dump()",
            "",
            "    if isinstance(data, (GradioRootModel, GradioModel)):",
            "        data = data.model_dump()",
            "",
            "    return client_utils.traverse(data, _move_to_cache, client_utils.is_file_obj)",
            "",
            "",
            "async def async_move_files_to_cache(",
            "    data: Any,",
            "    block: Block,",
            "    postprocess: bool = False,",
            "    check_in_upload_folder=False,",
            "    keep_in_cache=False,",
            ") -> dict:",
            "    \"\"\"Move any files in `data` to cache and (optionally), adds URL prefixes (/file=...) needed to access the cached file.",
            "    Also handles the case where the file is on an external Gradio app (/proxy=...).",
            "",
            "    Runs after .postprocess() and before .preprocess().",
            "",
            "    Args:",
            "        data: The input or output data for a component. Can be a dictionary or a dataclass",
            "        block: The component whose data is being processed",
            "        postprocess: Whether its running from postprocessing",
            "        check_in_upload_folder: If True, instead of moving the file to cache, checks if the file is in already in cache (exception if not).",
            "        keep_in_cache: If True, the file will not be deleted from cache when the server is shut down.",
            "    \"\"\"",
            "",
            "    async def _move_to_cache(d: dict):",
            "        payload = FileData(**d)",
            "        # If the gradio app developer is returning a URL from",
            "        # postprocess, it means the component can display a URL",
            "        # without it being served from the gradio server",
            "        # This makes it so that the URL is not downloaded and speeds up event processing",
            "        if payload.url and postprocess and client_utils.is_http_url_like(payload.url):",
            "            payload.path = payload.url",
            "        elif utils.is_static_file(payload):",
            "            pass",
            "        elif not block.proxy_url:",
            "            # If the file is on a remote server, do not move it to cache.",
            "            if check_in_upload_folder and not client_utils.is_http_url_like(",
            "                payload.path",
            "            ):",
            "                path = os.path.abspath(payload.path)",
            "                if not is_in_or_equal(path, get_upload_folder()):",
            "                    raise ValueError(",
            "                        f\"File {path} is not in the upload folder and cannot be accessed.\"",
            "                    )",
            "            if not payload.is_stream:",
            "                temp_file_path = await block.async_move_resource_to_block_cache(",
            "                    payload.path",
            "                )",
            "                if temp_file_path is None:",
            "                    raise ValueError(\"Did not determine a file path for the resource.\")",
            "                payload.path = temp_file_path",
            "                if keep_in_cache:",
            "                    block.keep_in_cache.add(payload.path)",
            "",
            "        url_prefix = \"/stream/\" if payload.is_stream else \"/file=\"",
            "        if block.proxy_url:",
            "            proxy_url = block.proxy_url.rstrip(\"/\")",
            "            url = f\"/proxy={proxy_url}{url_prefix}{payload.path}\"",
            "        elif client_utils.is_http_url_like(payload.path) or payload.path.startswith(",
            "            f\"{url_prefix}\"",
            "        ):",
            "            url = payload.path",
            "        else:",
            "            url = f\"{url_prefix}{payload.path}\"",
            "        payload.url = url",
            "",
            "        return payload.model_dump()",
            "",
            "    if isinstance(data, (GradioRootModel, GradioModel)):",
            "        data = data.model_dump()",
            "    return await client_utils.async_traverse(",
            "        data, _move_to_cache, client_utils.is_file_obj",
            "    )",
            "",
            "",
            "def add_root_url(data: dict | list, root_url: str, previous_root_url: str | None):",
            "    def _add_root_url(file_dict: dict):",
            "        if previous_root_url and file_dict[\"url\"].startswith(previous_root_url):",
            "            file_dict[\"url\"] = file_dict[\"url\"][len(previous_root_url) :]",
            "        elif client_utils.is_http_url_like(file_dict[\"url\"]):",
            "            return file_dict",
            "        file_dict[\"url\"] = f'{root_url}{file_dict[\"url\"]}'",
            "        return file_dict",
            "",
            "    return client_utils.traverse(data, _add_root_url, client_utils.is_file_obj_with_url)",
            "",
            "",
            "def resize_and_crop(img, size, crop_type=\"center\"):",
            "    \"\"\"",
            "    Resize and crop an image to fit the specified size.",
            "    args:",
            "        size: `(width, height)` tuple. Pass `None` for either width or height",
            "        to only crop and resize the other.",
            "        crop_type: can be 'top', 'middle' or 'bottom', depending on this",
            "            value, the image will cropped getting the 'top/left', 'middle' or",
            "            'bottom/right' of the image to fit the size.",
            "    raises:",
            "        ValueError: if an invalid `crop_type` is provided.",
            "    \"\"\"",
            "    if crop_type == \"top\":",
            "        center = (0, 0)",
            "    elif crop_type == \"center\":",
            "        center = (0.5, 0.5)",
            "    else:",
            "        raise ValueError",
            "",
            "    resize = list(size)",
            "    if size[0] is None:",
            "        resize[0] = img.size[0]",
            "    if size[1] is None:",
            "        resize[1] = img.size[1]",
            "    return ImageOps.fit(img, resize, centering=center)  # type: ignore",
            "",
            "",
            "##################",
            "# Audio",
            "##################",
            "",
            "",
            "def audio_from_file(filename, crop_min=0, crop_max=100):",
            "    try:",
            "        audio = AudioSegment.from_file(filename)",
            "    except FileNotFoundError as e:",
            "        isfile = Path(filename).is_file()",
            "        msg = (",
            "            f\"Cannot load audio from file: `{'ffprobe' if isfile else filename}` not found.\"",
            "            + \" Please install `ffmpeg` in your system to use non-WAV audio file formats\"",
            "            \" and make sure `ffprobe` is in your PATH.\"",
            "            if isfile",
            "            else \"\"",
            "        )",
            "        raise RuntimeError(msg) from e",
            "    if crop_min != 0 or crop_max != 100:",
            "        audio_start = len(audio) * crop_min / 100",
            "        audio_end = len(audio) * crop_max / 100",
            "        audio = audio[audio_start:audio_end]",
            "    data = np.array(audio.get_array_of_samples())",
            "    if audio.channels > 1:",
            "        data = data.reshape(-1, audio.channels)",
            "    return audio.frame_rate, data",
            "",
            "",
            "def audio_to_file(sample_rate, data, filename, format=\"wav\"):",
            "    if format == \"wav\":",
            "        data = convert_to_16_bit_wav(data)",
            "    audio = AudioSegment(",
            "        data.tobytes(),",
            "        frame_rate=sample_rate,",
            "        sample_width=data.dtype.itemsize,",
            "        channels=(1 if len(data.shape) == 1 else data.shape[1]),",
            "    )",
            "    file = audio.export(filename, format=format)",
            "    file.close()  # type: ignore",
            "",
            "",
            "def convert_to_16_bit_wav(data):",
            "    # Based on: https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.wavfile.write.html",
            "    warning = \"Trying to convert audio automatically from {} to 16-bit int format.\"",
            "    if data.dtype in [np.float64, np.float32, np.float16]:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data / np.abs(data).max()",
            "        data = data * 32767",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.int32:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data / 65536",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.int16:",
            "        pass",
            "    elif data.dtype == np.uint16:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data - 32768",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.uint8:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data * 257 - 32768",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.int8:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data * 256",
            "        data = data.astype(np.int16)",
            "    else:",
            "        raise ValueError(",
            "            \"Audio data cannot be converted automatically from \"",
            "            f\"{data.dtype} to 16-bit int format.\"",
            "        )",
            "    return data",
            "",
            "",
            "##################",
            "# OUTPUT",
            "##################",
            "",
            "",
            "def _convert(image, dtype, force_copy=False, uniform=False):",
            "    \"\"\"",
            "    Adapted from: https://github.com/scikit-image/scikit-image/blob/main/skimage/util/dtype.py#L510-L531",
            "",
            "    Convert an image to the requested data-type.",
            "    Warnings are issued in case of precision loss, or when negative values",
            "    are clipped during conversion to unsigned integer types (sign loss).",
            "    Floating point values are expected to be normalized and will be clipped",
            "    to the range [0.0, 1.0] or [-1.0, 1.0] when converting to unsigned or",
            "    signed integers respectively.",
            "    Numbers are not shifted to the negative side when converting from",
            "    unsigned to signed integer types. Negative values will be clipped when",
            "    converting to unsigned integers.",
            "    Parameters",
            "    ----------",
            "    image : ndarray",
            "        Input image.",
            "    dtype : dtype",
            "        Target data-type.",
            "    force_copy : bool, optional",
            "        Force a copy of the data, irrespective of its current dtype.",
            "    uniform : bool, optional",
            "        Uniformly quantize the floating point range to the integer range.",
            "        By default (uniform=False) floating point values are scaled and",
            "        rounded to the nearest integers, which minimizes back and forth",
            "        conversion errors.",
            "    .. versionchanged :: 0.15",
            "        ``_convert`` no longer warns about possible precision or sign",
            "        information loss. See discussions on these warnings at:",
            "        https://github.com/scikit-image/scikit-image/issues/2602",
            "        https://github.com/scikit-image/scikit-image/issues/543#issuecomment-208202228",
            "        https://github.com/scikit-image/scikit-image/pull/3575",
            "    References",
            "    ----------",
            "    .. [1] DirectX data conversion rules.",
            "           https://msdn.microsoft.com/en-us/library/windows/desktop/dd607323%28v=vs.85%29.aspx",
            "    .. [2] Data Conversions. In \"OpenGL ES 2.0 Specification v2.0.25\",",
            "           pp 7-8. Khronos Group, 2010.",
            "    .. [3] Proper treatment of pixels as integers. A.W. Paeth.",
            "           In \"Graphics Gems I\", pp 249-256. Morgan Kaufmann, 1990.",
            "    .. [4] Dirty Pixels. J. Blinn. In \"Jim Blinn's corner: Dirty Pixels\",",
            "           pp 47-57. Morgan Kaufmann, 1998.",
            "    \"\"\"",
            "    dtype_range = {",
            "        bool: (False, True),",
            "        np.bool_: (False, True),",
            "        float: (-1, 1),",
            "        np.float16: (-1, 1),",
            "        np.float32: (-1, 1),",
            "        np.float64: (-1, 1),",
            "    }",
            "",
            "    if hasattr(np, \"float_\"):",
            "        dtype_range[np.float_] = dtype_range[float]  # type: ignore",
            "    if hasattr(np, \"bool8\"):",
            "        dtype_range[np.bool8] = dtype_range[np.bool_]  # type: ignore",
            "",
            "    def _dtype_itemsize(itemsize, *dtypes):",
            "        \"\"\"Return first of `dtypes` with itemsize greater than `itemsize`",
            "        Parameters",
            "        ----------",
            "        itemsize: int",
            "            The data type object element size.",
            "        Other Parameters",
            "        ----------------",
            "        *dtypes:",
            "            Any Object accepted by `np.dtype` to be converted to a data",
            "            type object",
            "        Returns",
            "        -------",
            "        dtype: data type object",
            "            First of `dtypes` with itemsize greater than `itemsize`.",
            "        \"\"\"",
            "        return next(dt for dt in dtypes if np.dtype(dt).itemsize >= itemsize)",
            "",
            "    def _dtype_bits(kind, bits, itemsize=1):",
            "        \"\"\"Return dtype of `kind` that can store a `bits` wide unsigned int",
            "        Parameters:",
            "        kind: str",
            "            Data type kind.",
            "        bits: int",
            "            Desired number of bits.",
            "        itemsize: int",
            "            The data type object element size.",
            "        Returns",
            "        -------",
            "        dtype: data type object",
            "            Data type of `kind` that can store a `bits` wide unsigned int",
            "        \"\"\"",
            "",
            "        s = next(",
            "            i",
            "            for i in (itemsize,) + (2, 4, 8)",
            "            if bits < (i * 8) or (bits == (i * 8) and kind == \"u\")",
            "        )",
            "",
            "        return np.dtype(kind + str(s))",
            "",
            "    def _scale(a, n, m, copy=True):",
            "        \"\"\"Scale an array of unsigned/positive integers from `n` to `m` bits.",
            "        Numbers can be represented exactly only if `m` is a multiple of `n`.",
            "        Parameters",
            "        ----------",
            "        a : ndarray",
            "            Input image array.",
            "        n : int",
            "            Number of bits currently used to encode the values in `a`.",
            "        m : int",
            "            Desired number of bits to encode the values in `out`.",
            "        copy : bool, optional",
            "            If True, allocates and returns new array. Otherwise, modifies",
            "            `a` in place.",
            "        Returns",
            "        -------",
            "        out : array",
            "            Output image array. Has the same kind as `a`.",
            "        \"\"\"",
            "        kind = a.dtype.kind",
            "        if n > m and a.max() < 2**m:",
            "            return a.astype(_dtype_bits(kind, m))",
            "        elif n == m:",
            "            return a.copy() if copy else a",
            "        elif n > m:",
            "            # downscale with precision loss",
            "            if copy:",
            "                b = np.empty(a.shape, _dtype_bits(kind, m))",
            "                np.floor_divide(a, 2 ** (n - m), out=b, dtype=a.dtype, casting=\"unsafe\")",
            "                return b",
            "            else:",
            "                a //= 2 ** (n - m)",
            "                return a",
            "        elif m % n == 0:",
            "            # exact upscale to a multiple of `n` bits",
            "            if copy:",
            "                b = np.empty(a.shape, _dtype_bits(kind, m))",
            "                np.multiply(a, (2**m - 1) // (2**n - 1), out=b, dtype=b.dtype)",
            "                return b",
            "            else:",
            "                a = a.astype(_dtype_bits(kind, m, a.dtype.itemsize), copy=False)",
            "                a *= (2**m - 1) // (2**n - 1)",
            "                return a",
            "        else:",
            "            # upscale to a multiple of `n` bits,",
            "            # then downscale with precision loss",
            "            o = (m // n + 1) * n",
            "            if copy:",
            "                b = np.empty(a.shape, _dtype_bits(kind, o))",
            "                np.multiply(a, (2**o - 1) // (2**n - 1), out=b, dtype=b.dtype)",
            "                b //= 2 ** (o - m)",
            "                return b",
            "            else:",
            "                a = a.astype(_dtype_bits(kind, o, a.dtype.itemsize), copy=False)",
            "                a *= (2**o - 1) // (2**n - 1)",
            "                a //= 2 ** (o - m)",
            "                return a",
            "",
            "    image = np.asarray(image)",
            "    dtypeobj_in = image.dtype",
            "    dtypeobj_out = np.dtype(\"float64\") if dtype is np.floating else np.dtype(dtype)",
            "    dtype_in = dtypeobj_in.type",
            "    dtype_out = dtypeobj_out.type",
            "    kind_in = dtypeobj_in.kind",
            "    kind_out = dtypeobj_out.kind",
            "    itemsize_in = dtypeobj_in.itemsize",
            "    itemsize_out = dtypeobj_out.itemsize",
            "",
            "    # Below, we do an `issubdtype` check.  Its purpose is to find out",
            "    # whether we can get away without doing any image conversion.  This happens",
            "    # when:",
            "    #",
            "    # - the output and input dtypes are the same or",
            "    # - when the output is specified as a type, and the input dtype",
            "    #   is a subclass of that type (e.g. `np.floating` will allow",
            "    #   `float32` and `float64` arrays through)",
            "",
            "    if hasattr(np, \"obj2sctype\"):",
            "        is_subdtype = np.issubdtype(dtype_in, np.obj2sctype(dtype))",
            "    else:",
            "        is_subdtype = np.issubdtype(dtype_in, dtypeobj_out.type)",
            "",
            "    if is_subdtype:",
            "        if force_copy:",
            "            image = image.copy()",
            "        return image",
            "",
            "    if kind_in in \"ui\":",
            "        imin_in = np.iinfo(dtype_in).min",
            "        imax_in = np.iinfo(dtype_in).max",
            "    if kind_out in \"ui\":",
            "        imin_out = np.iinfo(dtype_out).min  # type: ignore",
            "        imax_out = np.iinfo(dtype_out).max  # type: ignore",
            "",
            "    # any -> binary",
            "    if kind_out == \"b\":",
            "        return image > dtype_in(dtype_range[dtype_in][1] / 2)",
            "",
            "    # binary -> any",
            "    if kind_in == \"b\":",
            "        result = image.astype(dtype_out)",
            "        if kind_out != \"f\":",
            "            result *= dtype_out(dtype_range[dtype_out][1])",
            "        return result",
            "",
            "    # float -> any",
            "    if kind_in == \"f\":",
            "        if kind_out == \"f\":",
            "            # float -> float",
            "            return image.astype(dtype_out)",
            "",
            "        if np.min(image) < -1.0 or np.max(image) > 1.0:",
            "            raise ValueError(\"Images of type float must be between -1 and 1.\")",
            "        # floating point -> integer",
            "        # use float type that can represent output integer type",
            "        computation_type = _dtype_itemsize(",
            "            itemsize_out, dtype_in, np.float32, np.float64",
            "        )",
            "",
            "        if not uniform:",
            "            if kind_out == \"u\":",
            "                image_out = np.multiply(image, imax_out, dtype=computation_type)  # type: ignore",
            "            else:",
            "                image_out = np.multiply(",
            "                    image,",
            "                    (imax_out - imin_out) / 2,  # type: ignore",
            "                    dtype=computation_type,",
            "                )",
            "                image_out -= 1.0 / 2.0",
            "            np.rint(image_out, out=image_out)",
            "            np.clip(image_out, imin_out, imax_out, out=image_out)  # type: ignore",
            "        elif kind_out == \"u\":",
            "            image_out = np.multiply(image, imax_out + 1, dtype=computation_type)  # type: ignore",
            "            np.clip(image_out, 0, imax_out, out=image_out)  # type: ignore",
            "        else:",
            "            image_out = np.multiply(",
            "                image,",
            "                (imax_out - imin_out + 1.0) / 2.0,  # type: ignore",
            "                dtype=computation_type,",
            "            )",
            "            np.floor(image_out, out=image_out)",
            "            np.clip(image_out, imin_out, imax_out, out=image_out)  # type: ignore",
            "        return image_out.astype(dtype_out)",
            "",
            "    # signed/unsigned int -> float",
            "    if kind_out == \"f\":",
            "        # use float type that can exactly represent input integers",
            "        computation_type = _dtype_itemsize(",
            "            itemsize_in, dtype_out, np.float32, np.float64",
            "        )",
            "",
            "        if kind_in == \"u\":",
            "            # using np.divide or np.multiply doesn't copy the data",
            "            # until the computation time",
            "            image = np.multiply(image, 1.0 / imax_in, dtype=computation_type)  # type: ignore",
            "            # DirectX uses this conversion also for signed ints",
            "            # if imin_in:",
            "            #     np.maximum(image, -1.0, out=image)",
            "        else:",
            "            image = np.add(image, 0.5, dtype=computation_type)",
            "            image *= 2 / (imax_in - imin_in)  # type: ignore",
            "",
            "        return np.asarray(image, dtype_out)",
            "",
            "    # unsigned int -> signed/unsigned int",
            "    if kind_in == \"u\":",
            "        if kind_out == \"i\":",
            "            # unsigned int -> signed int",
            "            image = _scale(image, 8 * itemsize_in, 8 * itemsize_out - 1)",
            "            return image.view(dtype_out)",
            "        else:",
            "            # unsigned int -> unsigned int",
            "            return _scale(image, 8 * itemsize_in, 8 * itemsize_out)",
            "",
            "    # signed int -> unsigned int",
            "    if kind_out == \"u\":",
            "        image = _scale(image, 8 * itemsize_in - 1, 8 * itemsize_out)",
            "        result = np.empty(image.shape, dtype_out)",
            "        np.maximum(image, 0, out=result, dtype=image.dtype, casting=\"unsafe\")",
            "        return result",
            "",
            "    # signed int -> signed int",
            "    if itemsize_in > itemsize_out:",
            "        return _scale(image, 8 * itemsize_in - 1, 8 * itemsize_out - 1)",
            "",
            "    image = image.astype(_dtype_bits(\"i\", itemsize_out * 8))",
            "    image -= imin_in  # type: ignore",
            "    image = _scale(image, 8 * itemsize_in, 8 * itemsize_out, copy=False)",
            "    image += imin_out  # type: ignore",
            "    return image.astype(dtype_out)",
            "",
            "",
            "def ffmpeg_installed() -> bool:",
            "    if wasm_utils.IS_WASM:",
            "        # TODO: Support ffmpeg in WASM",
            "        return False",
            "",
            "    return shutil.which(\"ffmpeg\") is not None",
            "",
            "",
            "def video_is_playable(video_filepath: str) -> bool:",
            "    \"\"\"Determines if a video is playable in the browser.",
            "",
            "    A video is playable if it has a playable container and codec.",
            "        .mp4 -> h264",
            "        .webm -> vp9",
            "        .ogg -> theora",
            "    \"\"\"",
            "    from ffmpy import FFprobe, FFRuntimeError",
            "",
            "    try:",
            "        container = Path(video_filepath).suffix.lower()",
            "        probe = FFprobe(",
            "            global_options=\"-show_format -show_streams -select_streams v -print_format json\",",
            "            inputs={video_filepath: None},",
            "        )",
            "        output = probe.run(stderr=subprocess.PIPE, stdout=subprocess.PIPE)",
            "        output = json.loads(output[0])",
            "        video_codec = output[\"streams\"][0][\"codec_name\"]",
            "        return (container, video_codec) in [",
            "            (\".mp4\", \"h264\"),",
            "            (\".ogg\", \"theora\"),",
            "            (\".webm\", \"vp9\"),",
            "        ]",
            "    # If anything goes wrong, assume the video can be played to not convert downstream",
            "    except (FFRuntimeError, IndexError, KeyError):",
            "        return True",
            "",
            "",
            "def convert_video_to_playable_mp4(video_path: str) -> str:",
            "    \"\"\"Convert the video to mp4. If something goes wrong return the original video.\"\"\"",
            "    from ffmpy import FFmpeg, FFRuntimeError",
            "",
            "    try:",
            "        with tempfile.NamedTemporaryFile(delete=False) as tmp_file:",
            "            output_path = Path(video_path).with_suffix(\".mp4\")",
            "            shutil.copy2(video_path, tmp_file.name)",
            "            # ffmpeg will automatically use h264 codec (playable in browser) when converting to mp4",
            "            ff = FFmpeg(",
            "                inputs={str(tmp_file.name): None},",
            "                outputs={str(output_path): None},",
            "                global_options=\"-y -loglevel quiet\",",
            "            )",
            "            ff.run()",
            "    except FFRuntimeError as e:",
            "        print(f\"Error converting video to browser-playable format {str(e)}\")",
            "        output_path = video_path",
            "    finally:",
            "        # Remove temp file",
            "        os.remove(tmp_file.name)  # type: ignore",
            "    return str(output_path)",
            "",
            "",
            "def get_video_length(video_path: str | Path):",
            "    if wasm_utils.IS_WASM:",
            "        raise wasm_utils.WasmUnsupportedError(",
            "            \"Video duration is not supported in the Wasm mode.\"",
            "        )",
            "    duration = subprocess.check_output(",
            "        [",
            "            \"ffprobe\",",
            "            \"-i\",",
            "            str(video_path),",
            "            \"-show_entries\",",
            "            \"format=duration\",",
            "            \"-v\",",
            "            \"quiet\",",
            "            \"-of\",",
            "            \"csv={}\".format(\"p=0\"),",
            "        ]",
            "    )",
            "    duration_str = duration.decode(\"utf-8\").strip()",
            "    duration_float = float(duration_str)",
            "",
            "    return duration_float"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import base64",
            "import hashlib",
            "import ipaddress",
            "import json",
            "import logging",
            "import os",
            "import shutil",
            "import socket",
            "import subprocess",
            "import tempfile",
            "import warnings",
            "from io import BytesIO",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any",
            "from urllib.parse import urlparse",
            "",
            "import aiofiles",
            "import httpx",
            "import numpy as np",
            "from gradio_client import utils as client_utils",
            "from PIL import Image, ImageOps, ImageSequence, PngImagePlugin",
            "",
            "from gradio import utils, wasm_utils",
            "from gradio.data_classes import FileData, GradioModel, GradioRootModel, JsonData",
            "from gradio.exceptions import Error",
            "from gradio.utils import abspath, get_hash_seed, get_upload_folder, is_in_or_equal",
            "",
            "with warnings.catch_warnings():",
            "    warnings.simplefilter(\"ignore\")  # Ignore pydub warning if ffmpeg is not installed",
            "    from pydub import AudioSegment",
            "",
            "if wasm_utils.IS_WASM:",
            "    import pyodide.http  # type: ignore",
            "    import urllib3",
            "",
            "    # NOTE: In the Wasm env, we use urllib3 to make HTTP requests. See https://github.com/gradio-app/gradio/issues/6837.",
            "    class Urllib3ResponseSyncByteStream(httpx.SyncByteStream):",
            "        def __init__(self, response) -> None:",
            "            self.response = response",
            "",
            "        def __iter__(self):",
            "            yield from self.response.stream()",
            "",
            "    class Urllib3Transport(httpx.BaseTransport):",
            "        def __init__(self):",
            "            self.pool = urllib3.PoolManager()",
            "",
            "        def handle_request(self, request: httpx.Request) -> httpx.Response:",
            "            url = str(request.url)",
            "            method = str(request.method)",
            "            headers = dict(request.headers)",
            "            body = None if method in [\"GET\", \"HEAD\"] else request.read()",
            "",
            "            response = self.pool.request(",
            "                headers=headers,",
            "                method=method,",
            "                url=url,",
            "                body=body,",
            "                preload_content=False,  # Stream the content",
            "            )",
            "",
            "            return httpx.Response(",
            "                status_code=response.status,",
            "                headers=response.headers,",
            "                stream=Urllib3ResponseSyncByteStream(response),",
            "            )",
            "",
            "    sync_transport = Urllib3Transport()",
            "",
            "    class PyodideHttpResponseAsyncByteStream(httpx.AsyncByteStream):",
            "        def __init__(self, response) -> None:",
            "            self.response = response",
            "",
            "        async def __aiter__(self):",
            "            yield await self.response.bytes()",
            "",
            "    class PyodideHttpTransport(httpx.AsyncBaseTransport):",
            "        async def handle_async_request(",
            "            self,",
            "            request: httpx.Request,",
            "        ) -> httpx.Response:",
            "            url = str(request.url)",
            "            method = request.method",
            "            headers = dict(request.headers)",
            "            body = None if method in [\"GET\", \"HEAD\"] else await request.aread()",
            "            response = await pyodide.http.pyfetch(",
            "                url, method=method, headers=headers, body=body",
            "            )",
            "            return httpx.Response(",
            "                status_code=response.status,",
            "                headers=response.headers,",
            "                stream=PyodideHttpResponseAsyncByteStream(response),",
            "            )",
            "",
            "    async_transport = PyodideHttpTransport()",
            "else:",
            "    sync_transport = None",
            "    async_transport = None",
            "",
            "sync_client = httpx.Client(transport=sync_transport)",
            "async_client = httpx.AsyncClient(transport=async_transport)",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Block",
            "",
            "",
            "#########################",
            "# GENERAL",
            "#########################",
            "",
            "",
            "def to_binary(x: str | dict) -> bytes:",
            "    \"\"\"Converts a base64 string or dictionary to a binary string that can be sent in a POST.\"\"\"",
            "    if isinstance(x, dict):",
            "        if x.get(\"data\"):",
            "            base64str = x[\"data\"]",
            "        else:",
            "            base64str = client_utils.encode_url_or_file_to_base64(x[\"path\"])",
            "    else:",
            "        base64str = x",
            "    return base64.b64decode(extract_base64_data(base64str))",
            "",
            "",
            "def extract_base64_data(x: str) -> str:",
            "    \"\"\"Just extracts the base64 data from a general base64 string.\"\"\"",
            "    return x.rsplit(\",\", 1)[-1]",
            "",
            "",
            "#########################",
            "# IMAGE PRE-PROCESSING",
            "#########################",
            "",
            "",
            "def encode_plot_to_base64(plt, format: str = \"png\"):",
            "    fmt = format or \"png\"",
            "    with BytesIO() as output_bytes:",
            "        plt.savefig(output_bytes, format=fmt)",
            "        bytes_data = output_bytes.getvalue()",
            "    base64_str = str(base64.b64encode(bytes_data), \"utf-8\")",
            "    return f\"data:image/{format or 'png'};base64,{base64_str}\"",
            "",
            "",
            "def get_pil_exif_bytes(pil_image):",
            "    if \"exif\" in pil_image.info:",
            "        return pil_image.info[\"exif\"]",
            "",
            "",
            "def get_pil_metadata(pil_image):",
            "    # Copy any text-only metadata",
            "    metadata = PngImagePlugin.PngInfo()",
            "    for key, value in pil_image.info.items():",
            "        if isinstance(key, str) and isinstance(value, str):",
            "            metadata.add_text(key, value)",
            "",
            "    return metadata",
            "",
            "",
            "def encode_pil_to_bytes(pil_image, format=\"png\"):",
            "    with BytesIO() as output_bytes:",
            "        if format.lower() == \"gif\":",
            "            frames = [frame.copy() for frame in ImageSequence.Iterator(pil_image)]",
            "            frames[0].save(",
            "                output_bytes,",
            "                format=format,",
            "                save_all=True,",
            "                append_images=frames[1:],",
            "                loop=0,",
            "            )",
            "        else:",
            "            if format.lower() == \"png\":",
            "                params = {\"pnginfo\": get_pil_metadata(pil_image)}",
            "            else:",
            "                exif = get_pil_exif_bytes(pil_image)",
            "                params = {\"exif\": exif} if exif else {}",
            "            pil_image.save(output_bytes, format, **params)",
            "        return output_bytes.getvalue()",
            "",
            "",
            "hash_seed = get_hash_seed().encode(\"utf-8\")",
            "",
            "",
            "def hash_file(file_path: str | Path, chunk_num_blocks: int = 128) -> str:",
            "    sha1 = hashlib.sha1()",
            "    sha1.update(hash_seed)",
            "    with open(file_path, \"rb\") as f:",
            "        for chunk in iter(lambda: f.read(chunk_num_blocks * sha1.block_size), b\"\"):",
            "            sha1.update(chunk)",
            "    return sha1.hexdigest()",
            "",
            "",
            "def hash_url(url: str) -> str:",
            "    sha1 = hashlib.sha1()",
            "    sha1.update(hash_seed)",
            "    sha1.update(url.encode(\"utf-8\"))",
            "    return sha1.hexdigest()",
            "",
            "",
            "def hash_bytes(bytes: bytes):",
            "    sha1 = hashlib.sha1()",
            "    sha1.update(hash_seed)",
            "    sha1.update(bytes)",
            "    return sha1.hexdigest()",
            "",
            "",
            "def hash_base64(base64_encoding: str, chunk_num_blocks: int = 128) -> str:",
            "    sha1 = hashlib.sha1()",
            "    sha1.update(hash_seed)",
            "    for i in range(0, len(base64_encoding), chunk_num_blocks * sha1.block_size):",
            "        data = base64_encoding[i : i + chunk_num_blocks * sha1.block_size]",
            "        sha1.update(data.encode(\"utf-8\"))",
            "    return sha1.hexdigest()",
            "",
            "",
            "def save_pil_to_cache(",
            "    img: Image.Image,",
            "    cache_dir: str,",
            "    name: str = \"image\",",
            "    format: str = \"webp\",",
            ") -> str:",
            "    bytes_data = encode_pil_to_bytes(img, format)",
            "    temp_dir = Path(cache_dir) / hash_bytes(bytes_data)",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    filename = str((temp_dir / f\"{name}.{format}\").resolve())",
            "    (temp_dir / f\"{name}.{format}\").resolve().write_bytes(bytes_data)",
            "    return filename",
            "",
            "",
            "def save_img_array_to_cache(",
            "    arr: np.ndarray, cache_dir: str, format: str = \"webp\"",
            ") -> str:",
            "    pil_image = Image.fromarray(_convert(arr, np.uint8, force_copy=False))",
            "    return save_pil_to_cache(pil_image, cache_dir, format=format)",
            "",
            "",
            "def save_audio_to_cache(",
            "    data: np.ndarray, sample_rate: int, format: str, cache_dir: str",
            ") -> str:",
            "    temp_dir = Path(cache_dir) / hash_bytes(data.tobytes())",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    filename = str((temp_dir / f\"audio.{format}\").resolve())",
            "    audio_to_file(sample_rate, data, filename, format=format)",
            "    return filename",
            "",
            "",
            "def save_bytes_to_cache(data: bytes, file_name: str, cache_dir: str) -> str:",
            "    path = Path(cache_dir) / hash_bytes(data)",
            "    path.mkdir(exist_ok=True, parents=True)",
            "    path = path / Path(file_name).name",
            "    path.write_bytes(data)",
            "    return str(path.resolve())",
            "",
            "",
            "def save_file_to_cache(file_path: str | Path, cache_dir: str) -> str:",
            "    \"\"\"Returns a temporary file path for a copy of the given file path if it does",
            "    not already exist. Otherwise returns the path to the existing temp file.\"\"\"",
            "    temp_dir = hash_file(file_path)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "",
            "    name = client_utils.strip_invalid_filename_characters(Path(file_path).name)",
            "    full_temp_file_path = str(abspath(temp_dir / name))",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        shutil.copy2(file_path, full_temp_file_path)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "def check_public_url(url: str):",
            "    parsed_url = urlparse(url)",
            "    if parsed_url.scheme not in [\"http\", \"https\"]:",
            "        raise httpx.RequestError(f\"Invalid URL: {url}\")",
            "    hostname = parsed_url.hostname",
            "    if not hostname:",
            "        raise httpx.RequestError(f\"Invalid URL: {url}\")",
            "",
            "    try:",
            "        addrinfo = socket.getaddrinfo(hostname, None)",
            "    except socket.gaierror:",
            "        raise httpx.RequestError(f\"Cannot resolve hostname: {hostname}\") from None",
            "",
            "    for family, _, _, _, sockaddr in addrinfo:",
            "        ip = sockaddr[0]",
            "        if family == socket.AF_INET6:",
            "            ip = ip.split(\"%\")[0]  # Remove scope ID if present",
            "",
            "        if not ipaddress.ip_address(ip).is_global:",
            "            raise httpx.RequestError(",
            "                f\"Non-public IP address found: {ip} for URL: {url}\"",
            "            )",
            "",
            "    return True",
            "",
            "",
            "def save_url_to_cache(url: str, cache_dir: str) -> str:",
            "    \"\"\"Downloads a file and makes a temporary file path for a copy if does not already",
            "    exist. Otherwise returns the path to the existing temp file.\"\"\"",
            "    check_public_url(url)",
            "",
            "    temp_dir = hash_url(url)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    name = client_utils.strip_invalid_filename_characters(Path(url).name)",
            "    full_temp_file_path = str(abspath(temp_dir / name))",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        with sync_client.stream(\"GET\", url, follow_redirects=True) as response, open(",
            "            full_temp_file_path, \"wb\"",
            "        ) as f:",
            "            for redirect in response.history:",
            "                check_public_url(str(redirect.url))",
            "",
            "            for chunk in response.iter_raw():",
            "                f.write(chunk)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "async def async_save_url_to_cache(url: str, cache_dir: str) -> str:",
            "    \"\"\"Downloads a file and makes a temporary file path for a copy if does not already",
            "    exist. Otherwise returns the path to the existing temp file. Uses async httpx.\"\"\"",
            "    check_public_url(url)",
            "",
            "    temp_dir = hash_url(url)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "    name = client_utils.strip_invalid_filename_characters(Path(url).name)",
            "    full_temp_file_path = str(abspath(temp_dir / name))",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        async with async_client.stream(\"GET\", url, follow_redirects=True) as response:",
            "            for redirect in response.history:",
            "                check_public_url(str(redirect.url))",
            "",
            "            async with aiofiles.open(full_temp_file_path, \"wb\") as f:",
            "                async for chunk in response.aiter_raw():",
            "                    await f.write(chunk)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "def save_base64_to_cache(",
            "    base64_encoding: str, cache_dir: str, file_name: str | None = None",
            ") -> str:",
            "    \"\"\"Converts a base64 encoding to a file and returns the path to the file if",
            "    the file doesn't already exist. Otherwise returns the path to the existing file.",
            "    \"\"\"",
            "    temp_dir = hash_base64(base64_encoding)",
            "    temp_dir = Path(cache_dir) / temp_dir",
            "    temp_dir.mkdir(exist_ok=True, parents=True)",
            "",
            "    guess_extension = client_utils.get_extension(base64_encoding)",
            "    if file_name:",
            "        file_name = client_utils.strip_invalid_filename_characters(file_name)",
            "    elif guess_extension:",
            "        file_name = f\"file.{guess_extension}\"",
            "    else:",
            "        file_name = \"file\"",
            "",
            "    full_temp_file_path = str(abspath(temp_dir / file_name))  # type: ignore",
            "",
            "    if not Path(full_temp_file_path).exists():",
            "        data, _ = client_utils.decode_base64_to_binary(base64_encoding)",
            "        with open(full_temp_file_path, \"wb\") as fb:",
            "            fb.write(data)",
            "",
            "    return full_temp_file_path",
            "",
            "",
            "def move_resource_to_block_cache(",
            "    url_or_file_path: str | Path | None, block: Block",
            ") -> str | None:",
            "    \"\"\"This method has been replaced by Block.move_resource_to_block_cache(), but is",
            "    left here for backwards compatibility for any custom components created in Gradio 4.2.0 or earlier.",
            "    \"\"\"",
            "    return block.move_resource_to_block_cache(url_or_file_path)",
            "",
            "",
            "def check_all_files_in_cache(data: JsonData):",
            "    def _in_cache(d: dict):",
            "        if (",
            "            (path := d.get(\"path\", \"\"))",
            "            and not client_utils.is_http_url_like(path)",
            "            and not is_in_or_equal(path, get_upload_folder())",
            "        ):",
            "            raise Error(",
            "                f\"File {path} is not in the cache folder and cannot be accessed.\"",
            "            )",
            "",
            "    client_utils.traverse(data, _in_cache, client_utils.is_file_obj)",
            "",
            "",
            "def move_files_to_cache(",
            "    data: Any,",
            "    block: Block,",
            "    postprocess: bool = False,",
            "    check_in_upload_folder=False,",
            "    keep_in_cache=False,",
            "):",
            "    \"\"\"Move any files in `data` to cache and (optionally), adds URL prefixes (/file=...) needed to access the cached file.",
            "    Also handles the case where the file is on an external Gradio app (/proxy=...).",
            "",
            "    Runs after .postprocess() and before .preprocess().",
            "",
            "    Args:",
            "        data: The input or output data for a component. Can be a dictionary or a dataclass",
            "        block: The component whose data is being processed",
            "        postprocess: Whether its running from postprocessing",
            "        check_in_upload_folder: If True, instead of moving the file to cache, checks if the file is in already in cache (exception if not).",
            "        keep_in_cache: If True, the file will not be deleted from cache when the server is shut down.",
            "    \"\"\"",
            "",
            "    def _move_to_cache(d: dict):",
            "        payload = FileData(**d)",
            "        # If the gradio app developer is returning a URL from",
            "        # postprocess, it means the component can display a URL",
            "        # without it being served from the gradio server",
            "        # This makes it so that the URL is not downloaded and speeds up event processing",
            "        if payload.url and postprocess and client_utils.is_http_url_like(payload.url):",
            "            payload.path = payload.url",
            "        elif utils.is_static_file(payload):",
            "            pass",
            "        elif not block.proxy_url:",
            "            # If the file is on a remote server, do not move it to cache.",
            "            if check_in_upload_folder and not client_utils.is_http_url_like(",
            "                payload.path",
            "            ):",
            "                path = os.path.abspath(payload.path)",
            "                if not is_in_or_equal(path, get_upload_folder()):",
            "                    raise ValueError(",
            "                        f\"File {path} is not in the upload folder and cannot be accessed.\"",
            "                    )",
            "            if not payload.is_stream:",
            "                temp_file_path = block.move_resource_to_block_cache(payload.path)",
            "                if temp_file_path is None:",
            "                    raise ValueError(\"Did not determine a file path for the resource.\")",
            "                payload.path = temp_file_path",
            "                if keep_in_cache:",
            "                    block.keep_in_cache.add(payload.path)",
            "",
            "        url_prefix = \"/stream/\" if payload.is_stream else \"/file=\"",
            "        if block.proxy_url:",
            "            proxy_url = block.proxy_url.rstrip(\"/\")",
            "            url = f\"/proxy={proxy_url}{url_prefix}{payload.path}\"",
            "        elif client_utils.is_http_url_like(payload.path) or payload.path.startswith(",
            "            f\"{url_prefix}\"",
            "        ):",
            "            url = payload.path",
            "        else:",
            "            url = f\"{url_prefix}{payload.path}\"",
            "        payload.url = url",
            "",
            "        return payload.model_dump()",
            "",
            "    if isinstance(data, (GradioRootModel, GradioModel)):",
            "        data = data.model_dump()",
            "",
            "    return client_utils.traverse(data, _move_to_cache, client_utils.is_file_obj)",
            "",
            "",
            "async def async_move_files_to_cache(",
            "    data: Any,",
            "    block: Block,",
            "    postprocess: bool = False,",
            "    check_in_upload_folder=False,",
            "    keep_in_cache=False,",
            ") -> dict:",
            "    \"\"\"Move any files in `data` to cache and (optionally), adds URL prefixes (/file=...) needed to access the cached file.",
            "    Also handles the case where the file is on an external Gradio app (/proxy=...).",
            "",
            "    Runs after .postprocess() and before .preprocess().",
            "",
            "    Args:",
            "        data: The input or output data for a component. Can be a dictionary or a dataclass",
            "        block: The component whose data is being processed",
            "        postprocess: Whether its running from postprocessing",
            "        check_in_upload_folder: If True, instead of moving the file to cache, checks if the file is in already in cache (exception if not).",
            "        keep_in_cache: If True, the file will not be deleted from cache when the server is shut down.",
            "    \"\"\"",
            "",
            "    async def _move_to_cache(d: dict):",
            "        payload = FileData(**d)",
            "        # If the gradio app developer is returning a URL from",
            "        # postprocess, it means the component can display a URL",
            "        # without it being served from the gradio server",
            "        # This makes it so that the URL is not downloaded and speeds up event processing",
            "        if payload.url and postprocess and client_utils.is_http_url_like(payload.url):",
            "            payload.path = payload.url",
            "        elif utils.is_static_file(payload):",
            "            pass",
            "        elif not block.proxy_url:",
            "            # If the file is on a remote server, do not move it to cache.",
            "            if check_in_upload_folder and not client_utils.is_http_url_like(",
            "                payload.path",
            "            ):",
            "                path = os.path.abspath(payload.path)",
            "                if not is_in_or_equal(path, get_upload_folder()):",
            "                    raise ValueError(",
            "                        f\"File {path} is not in the upload folder and cannot be accessed.\"",
            "                    )",
            "            if not payload.is_stream:",
            "                temp_file_path = await block.async_move_resource_to_block_cache(",
            "                    payload.path",
            "                )",
            "                if temp_file_path is None:",
            "                    raise ValueError(\"Did not determine a file path for the resource.\")",
            "                payload.path = temp_file_path",
            "                if keep_in_cache:",
            "                    block.keep_in_cache.add(payload.path)",
            "",
            "        url_prefix = \"/stream/\" if payload.is_stream else \"/file=\"",
            "        if block.proxy_url:",
            "            proxy_url = block.proxy_url.rstrip(\"/\")",
            "            url = f\"/proxy={proxy_url}{url_prefix}{payload.path}\"",
            "        elif client_utils.is_http_url_like(payload.path) or payload.path.startswith(",
            "            f\"{url_prefix}\"",
            "        ):",
            "            url = payload.path",
            "        else:",
            "            url = f\"{url_prefix}{payload.path}\"",
            "        payload.url = url",
            "",
            "        return payload.model_dump()",
            "",
            "    if isinstance(data, (GradioRootModel, GradioModel)):",
            "        data = data.model_dump()",
            "    return await client_utils.async_traverse(",
            "        data, _move_to_cache, client_utils.is_file_obj",
            "    )",
            "",
            "",
            "def add_root_url(data: dict | list, root_url: str, previous_root_url: str | None):",
            "    def _add_root_url(file_dict: dict):",
            "        if previous_root_url and file_dict[\"url\"].startswith(previous_root_url):",
            "            file_dict[\"url\"] = file_dict[\"url\"][len(previous_root_url) :]",
            "        elif client_utils.is_http_url_like(file_dict[\"url\"]):",
            "            return file_dict",
            "        file_dict[\"url\"] = f'{root_url}{file_dict[\"url\"]}'",
            "        return file_dict",
            "",
            "    return client_utils.traverse(data, _add_root_url, client_utils.is_file_obj_with_url)",
            "",
            "",
            "def resize_and_crop(img, size, crop_type=\"center\"):",
            "    \"\"\"",
            "    Resize and crop an image to fit the specified size.",
            "    args:",
            "        size: `(width, height)` tuple. Pass `None` for either width or height",
            "        to only crop and resize the other.",
            "        crop_type: can be 'top', 'middle' or 'bottom', depending on this",
            "            value, the image will cropped getting the 'top/left', 'middle' or",
            "            'bottom/right' of the image to fit the size.",
            "    raises:",
            "        ValueError: if an invalid `crop_type` is provided.",
            "    \"\"\"",
            "    if crop_type == \"top\":",
            "        center = (0, 0)",
            "    elif crop_type == \"center\":",
            "        center = (0.5, 0.5)",
            "    else:",
            "        raise ValueError",
            "",
            "    resize = list(size)",
            "    if size[0] is None:",
            "        resize[0] = img.size[0]",
            "    if size[1] is None:",
            "        resize[1] = img.size[1]",
            "    return ImageOps.fit(img, resize, centering=center)  # type: ignore",
            "",
            "",
            "##################",
            "# Audio",
            "##################",
            "",
            "",
            "def audio_from_file(filename, crop_min=0, crop_max=100):",
            "    try:",
            "        audio = AudioSegment.from_file(filename)",
            "    except FileNotFoundError as e:",
            "        isfile = Path(filename).is_file()",
            "        msg = (",
            "            f\"Cannot load audio from file: `{'ffprobe' if isfile else filename}` not found.\"",
            "            + \" Please install `ffmpeg` in your system to use non-WAV audio file formats\"",
            "            \" and make sure `ffprobe` is in your PATH.\"",
            "            if isfile",
            "            else \"\"",
            "        )",
            "        raise RuntimeError(msg) from e",
            "    if crop_min != 0 or crop_max != 100:",
            "        audio_start = len(audio) * crop_min / 100",
            "        audio_end = len(audio) * crop_max / 100",
            "        audio = audio[audio_start:audio_end]",
            "    data = np.array(audio.get_array_of_samples())",
            "    if audio.channels > 1:",
            "        data = data.reshape(-1, audio.channels)",
            "    return audio.frame_rate, data",
            "",
            "",
            "def audio_to_file(sample_rate, data, filename, format=\"wav\"):",
            "    if format == \"wav\":",
            "        data = convert_to_16_bit_wav(data)",
            "    audio = AudioSegment(",
            "        data.tobytes(),",
            "        frame_rate=sample_rate,",
            "        sample_width=data.dtype.itemsize,",
            "        channels=(1 if len(data.shape) == 1 else data.shape[1]),",
            "    )",
            "    file = audio.export(filename, format=format)",
            "    file.close()  # type: ignore",
            "",
            "",
            "def convert_to_16_bit_wav(data):",
            "    # Based on: https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.wavfile.write.html",
            "    warning = \"Trying to convert audio automatically from {} to 16-bit int format.\"",
            "    if data.dtype in [np.float64, np.float32, np.float16]:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data / np.abs(data).max()",
            "        data = data * 32767",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.int32:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data / 65536",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.int16:",
            "        pass",
            "    elif data.dtype == np.uint16:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data - 32768",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.uint8:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data * 257 - 32768",
            "        data = data.astype(np.int16)",
            "    elif data.dtype == np.int8:",
            "        warnings.warn(warning.format(data.dtype))",
            "        data = data * 256",
            "        data = data.astype(np.int16)",
            "    else:",
            "        raise ValueError(",
            "            \"Audio data cannot be converted automatically from \"",
            "            f\"{data.dtype} to 16-bit int format.\"",
            "        )",
            "    return data",
            "",
            "",
            "##################",
            "# OUTPUT",
            "##################",
            "",
            "",
            "def _convert(image, dtype, force_copy=False, uniform=False):",
            "    \"\"\"",
            "    Adapted from: https://github.com/scikit-image/scikit-image/blob/main/skimage/util/dtype.py#L510-L531",
            "",
            "    Convert an image to the requested data-type.",
            "    Warnings are issued in case of precision loss, or when negative values",
            "    are clipped during conversion to unsigned integer types (sign loss).",
            "    Floating point values are expected to be normalized and will be clipped",
            "    to the range [0.0, 1.0] or [-1.0, 1.0] when converting to unsigned or",
            "    signed integers respectively.",
            "    Numbers are not shifted to the negative side when converting from",
            "    unsigned to signed integer types. Negative values will be clipped when",
            "    converting to unsigned integers.",
            "    Parameters",
            "    ----------",
            "    image : ndarray",
            "        Input image.",
            "    dtype : dtype",
            "        Target data-type.",
            "    force_copy : bool, optional",
            "        Force a copy of the data, irrespective of its current dtype.",
            "    uniform : bool, optional",
            "        Uniformly quantize the floating point range to the integer range.",
            "        By default (uniform=False) floating point values are scaled and",
            "        rounded to the nearest integers, which minimizes back and forth",
            "        conversion errors.",
            "    .. versionchanged :: 0.15",
            "        ``_convert`` no longer warns about possible precision or sign",
            "        information loss. See discussions on these warnings at:",
            "        https://github.com/scikit-image/scikit-image/issues/2602",
            "        https://github.com/scikit-image/scikit-image/issues/543#issuecomment-208202228",
            "        https://github.com/scikit-image/scikit-image/pull/3575",
            "    References",
            "    ----------",
            "    .. [1] DirectX data conversion rules.",
            "           https://msdn.microsoft.com/en-us/library/windows/desktop/dd607323%28v=vs.85%29.aspx",
            "    .. [2] Data Conversions. In \"OpenGL ES 2.0 Specification v2.0.25\",",
            "           pp 7-8. Khronos Group, 2010.",
            "    .. [3] Proper treatment of pixels as integers. A.W. Paeth.",
            "           In \"Graphics Gems I\", pp 249-256. Morgan Kaufmann, 1990.",
            "    .. [4] Dirty Pixels. J. Blinn. In \"Jim Blinn's corner: Dirty Pixels\",",
            "           pp 47-57. Morgan Kaufmann, 1998.",
            "    \"\"\"",
            "    dtype_range = {",
            "        bool: (False, True),",
            "        np.bool_: (False, True),",
            "        float: (-1, 1),",
            "        np.float16: (-1, 1),",
            "        np.float32: (-1, 1),",
            "        np.float64: (-1, 1),",
            "    }",
            "",
            "    if hasattr(np, \"float_\"):",
            "        dtype_range[np.float_] = dtype_range[float]  # type: ignore",
            "    if hasattr(np, \"bool8\"):",
            "        dtype_range[np.bool8] = dtype_range[np.bool_]  # type: ignore",
            "",
            "    def _dtype_itemsize(itemsize, *dtypes):",
            "        \"\"\"Return first of `dtypes` with itemsize greater than `itemsize`",
            "        Parameters",
            "        ----------",
            "        itemsize: int",
            "            The data type object element size.",
            "        Other Parameters",
            "        ----------------",
            "        *dtypes:",
            "            Any Object accepted by `np.dtype` to be converted to a data",
            "            type object",
            "        Returns",
            "        -------",
            "        dtype: data type object",
            "            First of `dtypes` with itemsize greater than `itemsize`.",
            "        \"\"\"",
            "        return next(dt for dt in dtypes if np.dtype(dt).itemsize >= itemsize)",
            "",
            "    def _dtype_bits(kind, bits, itemsize=1):",
            "        \"\"\"Return dtype of `kind` that can store a `bits` wide unsigned int",
            "        Parameters:",
            "        kind: str",
            "            Data type kind.",
            "        bits: int",
            "            Desired number of bits.",
            "        itemsize: int",
            "            The data type object element size.",
            "        Returns",
            "        -------",
            "        dtype: data type object",
            "            Data type of `kind` that can store a `bits` wide unsigned int",
            "        \"\"\"",
            "",
            "        s = next(",
            "            i",
            "            for i in (itemsize,) + (2, 4, 8)",
            "            if bits < (i * 8) or (bits == (i * 8) and kind == \"u\")",
            "        )",
            "",
            "        return np.dtype(kind + str(s))",
            "",
            "    def _scale(a, n, m, copy=True):",
            "        \"\"\"Scale an array of unsigned/positive integers from `n` to `m` bits.",
            "        Numbers can be represented exactly only if `m` is a multiple of `n`.",
            "        Parameters",
            "        ----------",
            "        a : ndarray",
            "            Input image array.",
            "        n : int",
            "            Number of bits currently used to encode the values in `a`.",
            "        m : int",
            "            Desired number of bits to encode the values in `out`.",
            "        copy : bool, optional",
            "            If True, allocates and returns new array. Otherwise, modifies",
            "            `a` in place.",
            "        Returns",
            "        -------",
            "        out : array",
            "            Output image array. Has the same kind as `a`.",
            "        \"\"\"",
            "        kind = a.dtype.kind",
            "        if n > m and a.max() < 2**m:",
            "            return a.astype(_dtype_bits(kind, m))",
            "        elif n == m:",
            "            return a.copy() if copy else a",
            "        elif n > m:",
            "            # downscale with precision loss",
            "            if copy:",
            "                b = np.empty(a.shape, _dtype_bits(kind, m))",
            "                np.floor_divide(a, 2 ** (n - m), out=b, dtype=a.dtype, casting=\"unsafe\")",
            "                return b",
            "            else:",
            "                a //= 2 ** (n - m)",
            "                return a",
            "        elif m % n == 0:",
            "            # exact upscale to a multiple of `n` bits",
            "            if copy:",
            "                b = np.empty(a.shape, _dtype_bits(kind, m))",
            "                np.multiply(a, (2**m - 1) // (2**n - 1), out=b, dtype=b.dtype)",
            "                return b",
            "            else:",
            "                a = a.astype(_dtype_bits(kind, m, a.dtype.itemsize), copy=False)",
            "                a *= (2**m - 1) // (2**n - 1)",
            "                return a",
            "        else:",
            "            # upscale to a multiple of `n` bits,",
            "            # then downscale with precision loss",
            "            o = (m // n + 1) * n",
            "            if copy:",
            "                b = np.empty(a.shape, _dtype_bits(kind, o))",
            "                np.multiply(a, (2**o - 1) // (2**n - 1), out=b, dtype=b.dtype)",
            "                b //= 2 ** (o - m)",
            "                return b",
            "            else:",
            "                a = a.astype(_dtype_bits(kind, o, a.dtype.itemsize), copy=False)",
            "                a *= (2**o - 1) // (2**n - 1)",
            "                a //= 2 ** (o - m)",
            "                return a",
            "",
            "    image = np.asarray(image)",
            "    dtypeobj_in = image.dtype",
            "    dtypeobj_out = np.dtype(\"float64\") if dtype is np.floating else np.dtype(dtype)",
            "    dtype_in = dtypeobj_in.type",
            "    dtype_out = dtypeobj_out.type",
            "    kind_in = dtypeobj_in.kind",
            "    kind_out = dtypeobj_out.kind",
            "    itemsize_in = dtypeobj_in.itemsize",
            "    itemsize_out = dtypeobj_out.itemsize",
            "",
            "    # Below, we do an `issubdtype` check.  Its purpose is to find out",
            "    # whether we can get away without doing any image conversion.  This happens",
            "    # when:",
            "    #",
            "    # - the output and input dtypes are the same or",
            "    # - when the output is specified as a type, and the input dtype",
            "    #   is a subclass of that type (e.g. `np.floating` will allow",
            "    #   `float32` and `float64` arrays through)",
            "",
            "    if hasattr(np, \"obj2sctype\"):",
            "        is_subdtype = np.issubdtype(dtype_in, np.obj2sctype(dtype))",
            "    else:",
            "        is_subdtype = np.issubdtype(dtype_in, dtypeobj_out.type)",
            "",
            "    if is_subdtype:",
            "        if force_copy:",
            "            image = image.copy()",
            "        return image",
            "",
            "    if kind_in in \"ui\":",
            "        imin_in = np.iinfo(dtype_in).min",
            "        imax_in = np.iinfo(dtype_in).max",
            "    if kind_out in \"ui\":",
            "        imin_out = np.iinfo(dtype_out).min  # type: ignore",
            "        imax_out = np.iinfo(dtype_out).max  # type: ignore",
            "",
            "    # any -> binary",
            "    if kind_out == \"b\":",
            "        return image > dtype_in(dtype_range[dtype_in][1] / 2)",
            "",
            "    # binary -> any",
            "    if kind_in == \"b\":",
            "        result = image.astype(dtype_out)",
            "        if kind_out != \"f\":",
            "            result *= dtype_out(dtype_range[dtype_out][1])",
            "        return result",
            "",
            "    # float -> any",
            "    if kind_in == \"f\":",
            "        if kind_out == \"f\":",
            "            # float -> float",
            "            return image.astype(dtype_out)",
            "",
            "        if np.min(image) < -1.0 or np.max(image) > 1.0:",
            "            raise ValueError(\"Images of type float must be between -1 and 1.\")",
            "        # floating point -> integer",
            "        # use float type that can represent output integer type",
            "        computation_type = _dtype_itemsize(",
            "            itemsize_out, dtype_in, np.float32, np.float64",
            "        )",
            "",
            "        if not uniform:",
            "            if kind_out == \"u\":",
            "                image_out = np.multiply(image, imax_out, dtype=computation_type)  # type: ignore",
            "            else:",
            "                image_out = np.multiply(",
            "                    image,",
            "                    (imax_out - imin_out) / 2,  # type: ignore",
            "                    dtype=computation_type,",
            "                )",
            "                image_out -= 1.0 / 2.0",
            "            np.rint(image_out, out=image_out)",
            "            np.clip(image_out, imin_out, imax_out, out=image_out)  # type: ignore",
            "        elif kind_out == \"u\":",
            "            image_out = np.multiply(image, imax_out + 1, dtype=computation_type)  # type: ignore",
            "            np.clip(image_out, 0, imax_out, out=image_out)  # type: ignore",
            "        else:",
            "            image_out = np.multiply(",
            "                image,",
            "                (imax_out - imin_out + 1.0) / 2.0,  # type: ignore",
            "                dtype=computation_type,",
            "            )",
            "            np.floor(image_out, out=image_out)",
            "            np.clip(image_out, imin_out, imax_out, out=image_out)  # type: ignore",
            "        return image_out.astype(dtype_out)",
            "",
            "    # signed/unsigned int -> float",
            "    if kind_out == \"f\":",
            "        # use float type that can exactly represent input integers",
            "        computation_type = _dtype_itemsize(",
            "            itemsize_in, dtype_out, np.float32, np.float64",
            "        )",
            "",
            "        if kind_in == \"u\":",
            "            # using np.divide or np.multiply doesn't copy the data",
            "            # until the computation time",
            "            image = np.multiply(image, 1.0 / imax_in, dtype=computation_type)  # type: ignore",
            "            # DirectX uses this conversion also for signed ints",
            "            # if imin_in:",
            "            #     np.maximum(image, -1.0, out=image)",
            "        else:",
            "            image = np.add(image, 0.5, dtype=computation_type)",
            "            image *= 2 / (imax_in - imin_in)  # type: ignore",
            "",
            "        return np.asarray(image, dtype_out)",
            "",
            "    # unsigned int -> signed/unsigned int",
            "    if kind_in == \"u\":",
            "        if kind_out == \"i\":",
            "            # unsigned int -> signed int",
            "            image = _scale(image, 8 * itemsize_in, 8 * itemsize_out - 1)",
            "            return image.view(dtype_out)",
            "        else:",
            "            # unsigned int -> unsigned int",
            "            return _scale(image, 8 * itemsize_in, 8 * itemsize_out)",
            "",
            "    # signed int -> unsigned int",
            "    if kind_out == \"u\":",
            "        image = _scale(image, 8 * itemsize_in - 1, 8 * itemsize_out)",
            "        result = np.empty(image.shape, dtype_out)",
            "        np.maximum(image, 0, out=result, dtype=image.dtype, casting=\"unsafe\")",
            "        return result",
            "",
            "    # signed int -> signed int",
            "    if itemsize_in > itemsize_out:",
            "        return _scale(image, 8 * itemsize_in - 1, 8 * itemsize_out - 1)",
            "",
            "    image = image.astype(_dtype_bits(\"i\", itemsize_out * 8))",
            "    image -= imin_in  # type: ignore",
            "    image = _scale(image, 8 * itemsize_in, 8 * itemsize_out, copy=False)",
            "    image += imin_out  # type: ignore",
            "    return image.astype(dtype_out)",
            "",
            "",
            "def ffmpeg_installed() -> bool:",
            "    if wasm_utils.IS_WASM:",
            "        # TODO: Support ffmpeg in WASM",
            "        return False",
            "",
            "    return shutil.which(\"ffmpeg\") is not None",
            "",
            "",
            "def video_is_playable(video_filepath: str) -> bool:",
            "    \"\"\"Determines if a video is playable in the browser.",
            "",
            "    A video is playable if it has a playable container and codec.",
            "        .mp4 -> h264",
            "        .webm -> vp9",
            "        .ogg -> theora",
            "    \"\"\"",
            "    from ffmpy import FFprobe, FFRuntimeError",
            "",
            "    try:",
            "        container = Path(video_filepath).suffix.lower()",
            "        probe = FFprobe(",
            "            global_options=\"-show_format -show_streams -select_streams v -print_format json\",",
            "            inputs={video_filepath: None},",
            "        )",
            "        output = probe.run(stderr=subprocess.PIPE, stdout=subprocess.PIPE)",
            "        output = json.loads(output[0])",
            "        video_codec = output[\"streams\"][0][\"codec_name\"]",
            "        return (container, video_codec) in [",
            "            (\".mp4\", \"h264\"),",
            "            (\".ogg\", \"theora\"),",
            "            (\".webm\", \"vp9\"),",
            "        ]",
            "    # If anything goes wrong, assume the video can be played to not convert downstream",
            "    except (FFRuntimeError, IndexError, KeyError):",
            "        return True",
            "",
            "",
            "def convert_video_to_playable_mp4(video_path: str) -> str:",
            "    \"\"\"Convert the video to mp4. If something goes wrong return the original video.\"\"\"",
            "    from ffmpy import FFmpeg, FFRuntimeError",
            "",
            "    try:",
            "        with tempfile.NamedTemporaryFile(delete=False) as tmp_file:",
            "            output_path = Path(video_path).with_suffix(\".mp4\")",
            "            shutil.copy2(video_path, tmp_file.name)",
            "            # ffmpeg will automatically use h264 codec (playable in browser) when converting to mp4",
            "            ff = FFmpeg(",
            "                inputs={str(tmp_file.name): None},",
            "                outputs={str(output_path): None},",
            "                global_options=\"-y -loglevel quiet\",",
            "            )",
            "            ff.run()",
            "    except FFRuntimeError as e:",
            "        print(f\"Error converting video to browser-playable format {str(e)}\")",
            "        output_path = video_path",
            "    finally:",
            "        # Remove temp file",
            "        os.remove(tmp_file.name)  # type: ignore",
            "    return str(output_path)",
            "",
            "",
            "def get_video_length(video_path: str | Path):",
            "    if wasm_utils.IS_WASM:",
            "        raise wasm_utils.WasmUnsupportedError(",
            "            \"Video duration is not supported in the Wasm mode.\"",
            "        )",
            "    duration = subprocess.check_output(",
            "        [",
            "            \"ffprobe\",",
            "            \"-i\",",
            "            str(video_path),",
            "            \"-show_entries\",",
            "            \"format=duration\",",
            "            \"-v\",",
            "            \"quiet\",",
            "            \"-of\",",
            "            \"csv={}\".format(\"p=0\"),",
            "        ]",
            "    )",
            "    duration_str = duration.decode(\"utf-8\").strip()",
            "    duration_float = float(duration_str)",
            "",
            "    return duration_float"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "25": [],
            "273": [
                "save_url_to_cache"
            ],
            "276": [
                "save_url_to_cache"
            ]
        },
        "addLocation": []
    },
    "gradio/route_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "     ) -> None:"
            },
            "1": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "         super().__init__(file, size=size, filename=filename, headers=headers)"
            },
            "2": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "         self.sha = hashlib.sha1()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+        self.sha.update(processing_utils.hash_seed)"
            },
            "4": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 388,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 389,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 390,
                "PatchRowcode": " @python_dataclass(frozen=True)"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import functools",
            "import hashlib",
            "import hmac",
            "import json",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import threading",
            "import uuid",
            "from collections import deque",
            "from contextlib import AsyncExitStack, asynccontextmanager",
            "from dataclasses import dataclass as python_dataclass",
            "from datetime import datetime",
            "from pathlib import Path",
            "from tempfile import NamedTemporaryFile, _TemporaryFileWrapper",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    AsyncContextManager,",
            "    AsyncGenerator,",
            "    BinaryIO,",
            "    Callable,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "from urllib.parse import urlparse",
            "",
            "import anyio",
            "import fastapi",
            "import gradio_client.utils as client_utils",
            "import httpx",
            "import multipart",
            "from gradio_client.documentation import document",
            "from multipart.multipart import parse_options_header",
            "from starlette.datastructures import FormData, Headers, MutableHeaders, UploadFile",
            "from starlette.formparsers import MultiPartException, MultipartPart",
            "from starlette.responses import PlainTextResponse, Response",
            "from starlette.types import ASGIApp, Message, Receive, Scope, Send",
            "",
            "from gradio import processing_utils, utils",
            "from gradio.data_classes import BlocksConfigDict, MediaStreamChunk, PredictBody",
            "from gradio.exceptions import Error",
            "from gradio.helpers import EventData",
            "from gradio.state_holder import SessionState",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import BlockFunction, Blocks",
            "    from gradio.routes import App",
            "",
            "",
            "config_lock = threading.Lock()",
            "",
            "",
            "class Obj:",
            "    \"\"\"",
            "    Using a class to convert dictionaries into objects. Used by the `Request` class.",
            "    Credit: https://www.geeksforgeeks.org/convert-nested-python-dictionary-to-object/",
            "    \"\"\"",
            "",
            "    def __init__(self, dict_):",
            "        self.__dict__.update(dict_)",
            "        for key, value in dict_.items():",
            "            if isinstance(value, (dict, list)):",
            "                value = Obj(value)",
            "            setattr(self, key, value)",
            "",
            "    def __getitem__(self, item):",
            "        return self.__dict__[item]",
            "",
            "    def __setitem__(self, item, value):",
            "        self.__dict__[item] = value",
            "",
            "    def __iter__(self):",
            "        for key, value in self.__dict__.items():",
            "            if isinstance(value, Obj):",
            "                yield (key, dict(value))",
            "            else:",
            "                yield (key, value)",
            "",
            "    def __contains__(self, item) -> bool:",
            "        if item in self.__dict__:",
            "            return True",
            "        for value in self.__dict__.values():",
            "            if isinstance(value, Obj) and item in value:",
            "                return True",
            "        return False",
            "",
            "    def get(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__[item]",
            "        return default",
            "",
            "    def keys(self):",
            "        return self.__dict__.keys()",
            "",
            "    def values(self):",
            "        return self.__dict__.values()",
            "",
            "    def items(self):",
            "        return self.__dict__.items()",
            "",
            "    def __str__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def pop(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__.pop(item)",
            "        return default",
            "",
            "",
            "@document()",
            "class Request:",
            "    \"\"\"",
            "    A Gradio request object that can be used to access the request headers, cookies,",
            "    query parameters and other information about the request from within the prediction",
            "    function. The class is a thin wrapper around the fastapi.Request class. Attributes",
            "    of this class include: `headers`, `client`, `query_params`, `session_hash`, and `path_params`. If",
            "    auth is enabled, the `username` attribute can be used to get the logged in user.",
            "    Example:",
            "        import gradio as gr",
            "        def echo(text, request: gr.Request):",
            "            if request:",
            "                print(\"Request headers dictionary:\", request.headers)",
            "                print(\"IP address:\", request.client.host)",
            "                print(\"Query parameters:\", dict(request.query_params))",
            "                print(\"Session hash:\", request.session_hash)",
            "            return text",
            "        io = gr.Interface(echo, \"textbox\", \"textbox\").launch()",
            "    Demos: request_ip_headers",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        request: fastapi.Request | None = None,",
            "        username: str | None = None,",
            "        session_hash: str | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Can be instantiated with either a fastapi.Request or by manually passing in",
            "        attributes (needed for queueing).",
            "        Parameters:",
            "            request: A fastapi.Request",
            "            username: The username of the logged in user (if auth is enabled)",
            "            session_hash: The session hash of the current session. It is unique for each page load.",
            "        \"\"\"",
            "        self.request = request",
            "        self.username = username",
            "        self.session_hash = session_hash",
            "        self.kwargs: dict = kwargs",
            "",
            "    def dict_to_obj(self, d):",
            "        if isinstance(d, dict):",
            "            return json.loads(json.dumps(d), object_hook=Obj)",
            "        else:",
            "            return d",
            "",
            "    def __getattr__(self, name):",
            "        if self.request:",
            "            return self.dict_to_obj(getattr(self.request, name))",
            "        else:",
            "            try:",
            "                obj = self.kwargs[name]",
            "            except KeyError as ke:",
            "                raise AttributeError(",
            "                    f\"'Request' object has no attribute '{name}'\"",
            "                ) from ke",
            "            return self.dict_to_obj(obj)",
            "",
            "",
            "class FnIndexInferError(Exception):",
            "    pass",
            "",
            "",
            "def get_fn(blocks: Blocks, api_name: str | None, body: PredictBody) -> BlockFunction:",
            "    if body.session_hash:",
            "        session_state = blocks.state_holder[body.session_hash]",
            "        fns = session_state.blocks_config.fns",
            "    else:",
            "        fns = blocks.fns",
            "",
            "    if body.fn_index is None:",
            "        if api_name is not None:",
            "            for fn in fns.values():",
            "                if fn.api_name == api_name:",
            "                    return fn",
            "        raise FnIndexInferError(",
            "            f\"Could not infer function index for API name: {api_name}\"",
            "        )",
            "    else:",
            "        return fns[body.fn_index]",
            "",
            "",
            "def compile_gr_request(",
            "    body: PredictBody,",
            "    fn: BlockFunction,",
            "    username: Optional[str],",
            "    request: Optional[fastapi.Request],",
            "):",
            "    # If this fn_index cancels jobs, then the only input we need is the",
            "    # current session hash",
            "    if fn.cancels:",
            "        body.data = [body.session_hash]",
            "    if body.request:",
            "        if body.batched:",
            "            gr_request = [Request(username=username, request=request)]",
            "        else:",
            "            gr_request = Request(",
            "                username=username, request=body.request, session_hash=body.session_hash",
            "            )",
            "    else:",
            "        if request is None:",
            "            raise ValueError(\"request must be provided if body.request is None\")",
            "        gr_request = Request(",
            "            username=username, request=request, session_hash=body.session_hash",
            "        )",
            "",
            "    return gr_request",
            "",
            "",
            "def restore_session_state(app: App, body: PredictBody):",
            "    event_id = body.event_id",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    if session_hash is not None:",
            "        session_state = app.state_holder[session_hash]",
            "        # The should_reset set keeps track of the fn_indices",
            "        # that have been cancelled. When a job is cancelled,",
            "        # the /reset route will mark the jobs as having been reset.",
            "        # That way if the cancel job finishes BEFORE the job being cancelled",
            "        # the job being cancelled will not overwrite the state of the iterator.",
            "        if event_id is None:",
            "            iterator = None",
            "        elif event_id in app.iterators_to_reset:",
            "            iterator = None",
            "            app.iterators_to_reset.remove(event_id)",
            "        else:",
            "            iterator = app.iterators.get(event_id)",
            "    else:",
            "        session_state = SessionState(app.get_blocks())",
            "        iterator = None",
            "",
            "    return session_state, iterator",
            "",
            "",
            "def prepare_event_data(",
            "    blocks: Blocks,",
            "    body: PredictBody,",
            ") -> EventData:",
            "    target = body.trigger_id",
            "    event_data = EventData(",
            "        blocks.blocks.get(target) if target else None,",
            "        body.event_data,",
            "    )",
            "    return event_data",
            "",
            "",
            "async def call_process_api(",
            "    app: App,",
            "    body: PredictBody,",
            "    gr_request: Union[Request, list[Request]],",
            "    fn: BlockFunction,",
            "    root_path: str,",
            "):",
            "    session_state, iterator = restore_session_state(app=app, body=body)",
            "",
            "    event_data = prepare_event_data(app.get_blocks(), body)",
            "    event_id = body.event_id",
            "",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    inputs = body.data",
            "",
            "    batch_in_single_out = not body.batched and fn.batch",
            "    if batch_in_single_out:",
            "        inputs = [inputs]",
            "",
            "    try:",
            "        with utils.MatplotlibBackendMananger():",
            "            output = await app.get_blocks().process_api(",
            "                block_fn=fn,",
            "                inputs=inputs,",
            "                request=gr_request,",
            "                state=session_state,",
            "                iterator=iterator,",
            "                session_hash=session_hash,",
            "                event_id=event_id,",
            "                event_data=event_data,",
            "                in_event_listener=True,",
            "                simple_format=body.simple_format,",
            "                root_path=root_path,",
            "            )",
            "        iterator = output.pop(\"iterator\", None)",
            "        if event_id is not None:",
            "            app.iterators[event_id] = iterator  # type: ignore",
            "        if isinstance(output, Error):",
            "            raise output",
            "    except BaseException:",
            "        iterator = app.iterators.get(event_id) if event_id is not None else None",
            "        if iterator is not None:  # close off any streams that are still open",
            "            run_id = id(iterator)",
            "            pending_streams: dict[int, MediaStream] = (",
            "                app.get_blocks().pending_streams[session_hash].get(run_id, {})",
            "            )",
            "            for stream in pending_streams.values():",
            "                stream.end_stream()",
            "        raise",
            "",
            "    if batch_in_single_out:",
            "        output[\"data\"] = output[\"data\"][0]",
            "",
            "    return output",
            "",
            "",
            "def get_root_url(",
            "    request: fastapi.Request, route_path: str, root_path: str | None",
            ") -> str:",
            "    \"\"\"",
            "    Gets the root url of the Gradio app (i.e. the public url of the app) without a trailing slash.",
            "",
            "    This is how the root_url is resolved:",
            "    1. If a user provides a `root_path` manually that is a full URL, it is returned directly.",
            "    2. If the request has an x-forwarded-host header (e.g. because it is behind a proxy), the root url is",
            "    constructed from the x-forwarded-host header. In this case, `route_path` is not used to construct the root url.",
            "    3. Otherwise, the root url is constructed from the request url. The query parameters and `route_path` are stripped off.",
            "    And if a relative `root_path` is provided, and it is not already the subpath of the URL, it is appended to the root url.",
            "",
            "    In cases (2) and (3), We also check to see if the x-forwarded-proto header is present, and if so, convert the root url to https.",
            "    And if there are multiple hosts in the x-forwarded-host or multiple protocols in the x-forwarded-proto, the first one is used.",
            "    \"\"\"",
            "",
            "    def get_first_header_value(header_name: str):",
            "        header_value = request.headers.get(header_name)",
            "        if header_value:",
            "            return header_value.split(\",\")[0].strip()",
            "        return None",
            "",
            "    if root_path and client_utils.is_http_url_like(root_path):",
            "        return root_path.rstrip(\"/\")",
            "",
            "    x_forwarded_host = get_first_header_value(\"x-forwarded-host\")",
            "    root_url = f\"http://{x_forwarded_host}\" if x_forwarded_host else str(request.url)",
            "    root_url = httpx.URL(root_url)",
            "    root_url = root_url.copy_with(query=None)",
            "    root_url = str(root_url).rstrip(\"/\")",
            "    if get_first_header_value(\"x-forwarded-proto\") == \"https\":",
            "        root_url = root_url.replace(\"http://\", \"https://\")",
            "",
            "    route_path = route_path.rstrip(\"/\")",
            "    if len(route_path) > 0 and not x_forwarded_host:",
            "        root_url = root_url[: -len(route_path)]",
            "    root_url = root_url.rstrip(\"/\")",
            "",
            "    root_url = httpx.URL(root_url)",
            "    if root_path and root_url.path != root_path:",
            "        root_url = root_url.copy_with(path=root_path)",
            "",
            "    return str(root_url).rstrip(\"/\")",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class GradioUploadFile(UploadFile):",
            "    \"\"\"UploadFile with a sha attribute.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        file: BinaryIO,",
            "        *,",
            "        size: int | None = None,",
            "        filename: str | None = None,",
            "        headers: Headers | None = None,",
            "    ) -> None:",
            "        super().__init__(file, size=size, filename=filename, headers=headers)",
            "        self.sha = hashlib.sha1()",
            "",
            "",
            "@python_dataclass(frozen=True)",
            "class FileUploadProgressUnit:",
            "    filename: str",
            "    chunk_size: int",
            "",
            "",
            "@python_dataclass",
            "class FileUploadProgressTracker:",
            "    deque: deque[FileUploadProgressUnit]",
            "    is_done: bool",
            "",
            "",
            "class FileUploadProgressNotTrackedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgressNotQueuedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgress:",
            "    def __init__(self) -> None:",
            "        self._statuses: dict[str, FileUploadProgressTracker] = {}",
            "",
            "    def track(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self._statuses[upload_id] = FileUploadProgressTracker(deque(), False)",
            "",
            "    def append(self, upload_id: str, filename: str, message_bytes: bytes):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        queue = self._statuses[upload_id].deque",
            "",
            "        if len(queue) == 0:",
            "            queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "        else:",
            "            last_unit = queue.popleft()",
            "            if last_unit.filename != filename:",
            "                queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "            else:",
            "                queue.append(",
            "                    FileUploadProgressUnit(",
            "                        filename,",
            "                        last_unit.chunk_size + len(message_bytes),",
            "                    )",
            "                )",
            "",
            "    def set_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        self._statuses[upload_id].is_done = True",
            "",
            "    def is_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        return self._statuses[upload_id].is_done",
            "",
            "    def stop_tracking(self, upload_id: str):",
            "        if upload_id in self._statuses:",
            "            del self._statuses[upload_id]",
            "",
            "    def pop(self, upload_id: str) -> FileUploadProgressUnit:",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        try:",
            "            return self._statuses[upload_id].deque.pop()",
            "        except IndexError as e:",
            "            raise FileUploadProgressNotQueuedError() from e",
            "",
            "",
            "class GradioMultiPartParser:",
            "    \"\"\"Vendored from starlette.MultipartParser.",
            "",
            "    Thanks starlette!",
            "",
            "    Made the following modifications",
            "        - Use GradioUploadFile instead of UploadFile",
            "        - Use NamedTemporaryFile instead of SpooledTemporaryFile",
            "        - Compute hash of data as the request is streamed",
            "",
            "    \"\"\"",
            "",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self,",
            "        headers: Headers,",
            "        stream: AsyncGenerator[bytes, None],",
            "        *,",
            "        max_files: Union[int, float] = 1000,",
            "        max_fields: Union[int, float] = 1000,",
            "        upload_id: str | None = None,",
            "        upload_progress: FileUploadProgress | None = None,",
            "        max_file_size: int | float,",
            "    ) -> None:",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.max_files = max_files",
            "        self.max_fields = max_fields",
            "        self.items: List[Tuple[str, Union[str, UploadFile]]] = []",
            "        self.upload_id = upload_id",
            "        self.upload_progress = upload_progress",
            "        self._current_files = 0",
            "        self._current_fields = 0",
            "        self.max_file_size = max_file_size",
            "        self._current_partial_header_name: bytes = b\"\"",
            "        self._current_partial_header_value: bytes = b\"\"",
            "        self._current_part = MultipartPart()",
            "        self._charset = \"\"",
            "        self._file_parts_to_write: List[Tuple[MultipartPart, bytes]] = []",
            "        self._file_parts_to_finish: List[MultipartPart] = []",
            "        self._files_to_close_on_error: List[_TemporaryFileWrapper] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        self._current_part = MultipartPart()",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message_bytes = data[start:end]",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.append(",
            "                self.upload_id,  # type: ignore",
            "                self._current_part.file.filename,  # type: ignore",
            "                message_bytes,",
            "            )",
            "        if self._current_part.file is None:",
            "            self._current_part.data += message_bytes",
            "        else:",
            "            self._file_parts_to_write.append((self._current_part, message_bytes))",
            "",
            "    def on_part_end(self) -> None:",
            "        if self._current_part.file is None:",
            "            self.items.append(",
            "                (",
            "                    self._current_part.field_name,",
            "                    _user_safe_decode(self._current_part.data, str(self._charset)),",
            "                )",
            "            )",
            "        else:",
            "            self._file_parts_to_finish.append(self._current_part)",
            "            # The file can be added to the items right now even though it's not",
            "            # finished yet, because it will be finished in the `parse()` method, before",
            "            # self.items is used in the return value.",
            "            self.items.append((self._current_part.field_name, self._current_part.file))",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_name += data[start:end]",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_value += data[start:end]",
            "",
            "    def on_header_end(self) -> None:",
            "        field = self._current_partial_header_name.lower()",
            "        if field == b\"content-disposition\":",
            "            self._current_part.content_disposition = self._current_partial_header_value",
            "        self._current_part.item_headers.append(",
            "            (field, self._current_partial_header_value)",
            "        )",
            "        self._current_partial_header_name = b\"\"",
            "        self._current_partial_header_value = b\"\"",
            "",
            "    def on_headers_finished(self) -> None:",
            "        _, options = parse_options_header(self._current_part.content_disposition or b\"\")",
            "        try:",
            "            self._current_part.field_name = _user_safe_decode(",
            "                options[b\"name\"], str(self._charset)",
            "            )",
            "        except KeyError as e:",
            "            raise MultiPartException(",
            "                'The Content-Disposition header field \"name\" must be ' \"provided.\"",
            "            ) from e",
            "        if b\"filename\" in options:",
            "            self._current_files += 1",
            "            if self._current_files > self.max_files:",
            "                raise MultiPartException(",
            "                    f\"Too many files. Maximum number of files is {self.max_files}.\"",
            "                )",
            "            filename = _user_safe_decode(options[b\"filename\"], str(self._charset))",
            "            tempfile = NamedTemporaryFile(delete=False)",
            "            self._files_to_close_on_error.append(tempfile)",
            "            self._current_part.file = GradioUploadFile(",
            "                file=tempfile,  # type: ignore[arg-type]",
            "                size=0,",
            "                filename=filename,",
            "                headers=Headers(raw=self._current_part.item_headers),",
            "            )",
            "        else:",
            "            self._current_fields += 1",
            "            if self._current_fields > self.max_fields:",
            "                raise MultiPartException(",
            "                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"",
            "                )",
            "            self._current_part.file = None",
            "",
            "    def on_end(self) -> None:",
            "        pass",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if isinstance(charset, bytes):",
            "            charset = charset.decode(\"latin-1\")",
            "        self._charset = charset",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError as e:",
            "            raise MultiPartException(\"Missing boundary in multipart.\") from e",
            "",
            "        # Callbacks dictionary.",
            "        callbacks: multipart.multipart.MultipartCallbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        try:",
            "            # Feed the parser with data from the request.",
            "            async for chunk in self.stream:",
            "                parser.write(chunk)",
            "                # Write file data, it needs to use await with the UploadFile methods",
            "                # that call the corresponding file methods *in a threadpool*,",
            "                # otherwise, if they were called directly in the callback methods above",
            "                # (regular, non-async functions), that would block the event loop in",
            "                # the main thread.",
            "                for part, data in self._file_parts_to_write:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.write(data)",
            "                    part.file.sha.update(data)  # type: ignore",
            "                    if os.stat(part.file.file.name).st_size > self.max_file_size:",
            "                        if self.upload_progress is not None:",
            "                            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "                        raise MultiPartException(",
            "                            f\"File size exceeded maximum allowed size of {self.max_file_size} bytes.\"",
            "                        )",
            "                for part in self._file_parts_to_finish:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.seek(0)",
            "                self._file_parts_to_write.clear()",
            "                self._file_parts_to_finish.clear()",
            "        except MultiPartException as exc:",
            "            # Close all the files if there was an error.",
            "            for file in self._files_to_close_on_error:",
            "                file.close()",
            "                Path(file.name).unlink()",
            "            raise exc",
            "",
            "        parser.finalize()",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "        return FormData(self.items)",
            "",
            "",
            "def move_uploaded_files_to_cache(files: list[str], destinations: list[str]) -> None:",
            "    for file, dest in zip(files, destinations):",
            "        shutil.move(file, dest)",
            "",
            "",
            "def update_root_in_config(config: BlocksConfigDict, root: str) -> BlocksConfigDict:",
            "    \"\"\"",
            "    Updates the root \"key\" in the config dictionary to the new root url. If the",
            "    root url has changed, all of the urls in the config that correspond to component",
            "    file urls are updated to use the new root url.",
            "    \"\"\"",
            "    with config_lock:",
            "        previous_root = config.get(\"root\")",
            "        if previous_root is None or previous_root != root:",
            "            config[\"root\"] = root",
            "            config = processing_utils.add_root_url(config, root, previous_root)  # type: ignore",
            "    return config",
            "",
            "",
            "def compare_passwords_securely(input_password: str, correct_password: str) -> bool:",
            "    return hmac.compare_digest(input_password.encode(), correct_password.encode())",
            "",
            "",
            "def starts_with_protocol(string: str) -> bool:",
            "    \"\"\"This regex matches strings that start with a scheme (one or more characters not including colon, slash, or space)",
            "    followed by ://, or start with just //, \\\\/, /\\\\, or \\\\ as they are interpreted as SMB paths on Windows.",
            "    \"\"\"",
            "    pattern = r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-.]*://|//|\\\\\\\\|\\\\/|/\\\\)\"",
            "    return re.match(pattern, string) is not None",
            "",
            "",
            "def get_hostname(url: str) -> str:",
            "    \"\"\"",
            "    Returns the hostname of a given url, or an empty string if the url cannot be parsed.",
            "    Examples:",
            "        get_hostname(\"https://www.gradio.app\") -> \"www.gradio.app\"",
            "        get_hostname(\"localhost:7860\") -> \"localhost\"",
            "        get_hostname(\"127.0.0.1\") -> \"127.0.0.1\"",
            "    \"\"\"",
            "    if not url:",
            "        return \"\"",
            "    if \"://\" not in url:",
            "        url = \"http://\" + url",
            "    try:",
            "        return urlparse(url).hostname or \"\"",
            "    except Exception:",
            "        return \"\"",
            "",
            "",
            "class CustomCORSMiddleware:",
            "    # This is a modified version of the Starlette CORSMiddleware that restricts the allowed origins when the host is localhost.",
            "    # Adapted from: https://github.com/encode/starlette/blob/89fae174a1ea10f59ae248fe030d9b7e83d0b8a0/starlette/middleware/cors.py",
            "",
            "    def __init__(",
            "        self,",
            "        app: ASGIApp,",
            "        strict_cors: bool = True,",
            "    ) -> None:",
            "        self.app = app",
            "        self.all_methods = (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\")",
            "        self.preflight_headers = {",
            "            \"Access-Control-Allow-Methods\": \", \".join(self.all_methods),",
            "            \"Access-Control-Max-Age\": str(600),",
            "            \"Access-Control-Allow-Credentials\": \"true\",",
            "        }",
            "        self.simple_headers = {\"Access-Control-Allow-Credentials\": \"true\"}",
            "        # Any of these hosts suggests that the Gradio app is running locally.",
            "        self.localhost_aliases = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"]",
            "        if not strict_cors:  # type: ignore",
            "            # Note: \"null\" is a special case that happens if a Gradio app is running",
            "            # as an embedded web component in a local static webpage. However, it can",
            "            # also be used maliciously for CSRF attacks, so it is not allowed by default.",
            "            self.localhost_aliases.append(\"null\")",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        if scope[\"type\"] != \"http\":",
            "            await self.app(scope, receive, send)",
            "            return",
            "        headers = Headers(scope=scope)",
            "        origin = headers.get(\"origin\")",
            "        if origin is None:",
            "            await self.app(scope, receive, send)",
            "            return",
            "        if scope[\"method\"] == \"OPTIONS\" and \"access-control-request-method\" in headers:",
            "            response = self.preflight_response(request_headers=headers)",
            "            await response(scope, receive, send)",
            "            return",
            "        await self.simple_response(scope, receive, send, request_headers=headers)",
            "",
            "    def preflight_response(self, request_headers: Headers) -> Response:",
            "        headers = dict(self.preflight_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            headers[\"Access-Control-Allow-Origin\"] = origin",
            "        requested_headers = request_headers.get(\"access-control-request-headers\")",
            "        if requested_headers is not None:",
            "            headers[\"Access-Control-Allow-Headers\"] = requested_headers",
            "        return PlainTextResponse(\"OK\", status_code=200, headers=headers)",
            "",
            "    async def simple_response(",
            "        self, scope: Scope, receive: Receive, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        send = functools.partial(self._send, send=send, request_headers=request_headers)",
            "        await self.app(scope, receive, send)",
            "",
            "    async def _send(",
            "        self, message: Message, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        if message[\"type\"] != \"http.response.start\":",
            "            await send(message)",
            "            return",
            "        message.setdefault(\"headers\", [])",
            "        headers = MutableHeaders(scope=message)",
            "        headers.update(self.simple_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            self.allow_explicit_origin(headers, origin)",
            "        await send(message)",
            "",
            "    def is_valid_origin(self, request_headers: Headers) -> bool:",
            "        origin = request_headers[\"Origin\"]",
            "        host = request_headers[\"Host\"]",
            "        host_name = get_hostname(host)",
            "        origin_name = get_hostname(origin)",
            "        return (",
            "            host_name not in self.localhost_aliases",
            "            or origin_name in self.localhost_aliases",
            "        )",
            "",
            "    @staticmethod",
            "    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None:",
            "        headers[\"Access-Control-Allow-Origin\"] = origin",
            "        headers.add_vary_header(\"Origin\")",
            "",
            "",
            "def delete_files_created_by_app(blocks: Blocks, age: int | None) -> None:",
            "    \"\"\"Delete files that are older than age. If age is None, delete all files.\"\"\"",
            "    dont_delete = set()",
            "    for component in blocks.blocks.values():",
            "        dont_delete.update(getattr(component, \"keep_in_cache\", set()))",
            "    for temp_set in blocks.temp_file_sets:",
            "        # We use a copy of the set to avoid modifying the set while iterating over it",
            "        # otherwise we would get an exception: Set changed size during iteration",
            "        to_remove = set()",
            "        for file in temp_set:",
            "            if file in dont_delete:",
            "                continue",
            "            try:",
            "                file_path = Path(file)",
            "                modified_time = datetime.fromtimestamp(file_path.lstat().st_ctime)",
            "                if age is None or (datetime.now() - modified_time).seconds > age:",
            "                    os.remove(file)",
            "                    to_remove.add(file)",
            "            except FileNotFoundError:",
            "                continue",
            "        temp_set -= to_remove",
            "",
            "",
            "async def delete_files_on_schedule(app: App, frequency: int, age: int) -> None:",
            "    \"\"\"Startup task to delete files created by the app based on time since last modification.\"\"\"",
            "    while True:",
            "        await asyncio.sleep(frequency)",
            "        await anyio.to_thread.run_sync(",
            "            delete_files_created_by_app, app.get_blocks(), age",
            "        )",
            "",
            "",
            "@asynccontextmanager",
            "async def _lifespan_handler(",
            "    app: App, frequency: int = 1, age: int = 1",
            ") -> AsyncGenerator:",
            "    \"\"\"A context manager that triggers the startup and shutdown events of the app.\"\"\"",
            "    asyncio.create_task(delete_files_on_schedule(app, frequency, age))",
            "    yield",
            "    delete_files_created_by_app(app.get_blocks(), age=None)",
            "",
            "",
            "async def _delete_state(app: App):",
            "    \"\"\"Delete all expired state every second.\"\"\"",
            "    while True:",
            "        app.state_holder.delete_all_expired_state()",
            "        await asyncio.sleep(1)",
            "",
            "",
            "@asynccontextmanager",
            "async def _delete_state_handler(app: App):",
            "    \"\"\"When the server launches, regularly delete expired state.\"\"\"",
            "    # The stop event needs to get the current event loop for python 3.8",
            "    # but the loop parameter is deprecated for 3.8+",
            "    if sys.version_info < (3, 10):",
            "        loop = asyncio.get_running_loop()",
            "        app.stop_event = asyncio.Event(loop=loop)",
            "    asyncio.create_task(_delete_state(app))",
            "    yield",
            "",
            "",
            "def create_lifespan_handler(",
            "    user_lifespan: Callable[[App], AsyncContextManager] | None,",
            "    frequency: int | None = 1,",
            "    age: int | None = 1,",
            ") -> Callable[[App], AsyncContextManager]:",
            "    \"\"\"Return a context manager that applies _lifespan_handler and user_lifespan if it exists.\"\"\"",
            "",
            "    @asynccontextmanager",
            "    async def _handler(app: App):",
            "        async with AsyncExitStack() as stack:",
            "            await stack.enter_async_context(_delete_state_handler(app))",
            "            if frequency and age:",
            "                await stack.enter_async_context(_lifespan_handler(app, frequency, age))",
            "            if user_lifespan is not None:",
            "                await stack.enter_async_context(user_lifespan(app))",
            "            yield",
            "",
            "    return _handler",
            "",
            "",
            "class MediaStream:",
            "    def __init__(self):",
            "        self.segments: list[MediaStreamChunk] = []",
            "        self.ended = False",
            "        self.segment_index = 0",
            "        self.playlist = \"#EXTM3U\\n#EXT-X-PLAYLIST-TYPE:EVENT\\n#EXT-X-TARGETDURATION:10\\n#EXT-X-VERSION:4\\n#EXT-X-MEDIA-SEQUENCE:0\\n\"",
            "        self.max_length = 5",
            "",
            "    async def add_segment(self, data: MediaStreamChunk | None):",
            "        if not data:",
            "            return",
            "",
            "        segment_id = str(uuid.uuid4())",
            "        self.segments.append({\"id\": segment_id, **data})",
            "        self.max_duration = max(self.max_length, data[\"duration\"]) + 1",
            "",
            "    def end_stream(self):",
            "        self.ended = True"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import functools",
            "import hashlib",
            "import hmac",
            "import json",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import threading",
            "import uuid",
            "from collections import deque",
            "from contextlib import AsyncExitStack, asynccontextmanager",
            "from dataclasses import dataclass as python_dataclass",
            "from datetime import datetime",
            "from pathlib import Path",
            "from tempfile import NamedTemporaryFile, _TemporaryFileWrapper",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    AsyncContextManager,",
            "    AsyncGenerator,",
            "    BinaryIO,",
            "    Callable,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "from urllib.parse import urlparse",
            "",
            "import anyio",
            "import fastapi",
            "import gradio_client.utils as client_utils",
            "import httpx",
            "import multipart",
            "from gradio_client.documentation import document",
            "from multipart.multipart import parse_options_header",
            "from starlette.datastructures import FormData, Headers, MutableHeaders, UploadFile",
            "from starlette.formparsers import MultiPartException, MultipartPart",
            "from starlette.responses import PlainTextResponse, Response",
            "from starlette.types import ASGIApp, Message, Receive, Scope, Send",
            "",
            "from gradio import processing_utils, utils",
            "from gradio.data_classes import BlocksConfigDict, MediaStreamChunk, PredictBody",
            "from gradio.exceptions import Error",
            "from gradio.helpers import EventData",
            "from gradio.state_holder import SessionState",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import BlockFunction, Blocks",
            "    from gradio.routes import App",
            "",
            "",
            "config_lock = threading.Lock()",
            "",
            "",
            "class Obj:",
            "    \"\"\"",
            "    Using a class to convert dictionaries into objects. Used by the `Request` class.",
            "    Credit: https://www.geeksforgeeks.org/convert-nested-python-dictionary-to-object/",
            "    \"\"\"",
            "",
            "    def __init__(self, dict_):",
            "        self.__dict__.update(dict_)",
            "        for key, value in dict_.items():",
            "            if isinstance(value, (dict, list)):",
            "                value = Obj(value)",
            "            setattr(self, key, value)",
            "",
            "    def __getitem__(self, item):",
            "        return self.__dict__[item]",
            "",
            "    def __setitem__(self, item, value):",
            "        self.__dict__[item] = value",
            "",
            "    def __iter__(self):",
            "        for key, value in self.__dict__.items():",
            "            if isinstance(value, Obj):",
            "                yield (key, dict(value))",
            "            else:",
            "                yield (key, value)",
            "",
            "    def __contains__(self, item) -> bool:",
            "        if item in self.__dict__:",
            "            return True",
            "        for value in self.__dict__.values():",
            "            if isinstance(value, Obj) and item in value:",
            "                return True",
            "        return False",
            "",
            "    def get(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__[item]",
            "        return default",
            "",
            "    def keys(self):",
            "        return self.__dict__.keys()",
            "",
            "    def values(self):",
            "        return self.__dict__.values()",
            "",
            "    def items(self):",
            "        return self.__dict__.items()",
            "",
            "    def __str__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def pop(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__.pop(item)",
            "        return default",
            "",
            "",
            "@document()",
            "class Request:",
            "    \"\"\"",
            "    A Gradio request object that can be used to access the request headers, cookies,",
            "    query parameters and other information about the request from within the prediction",
            "    function. The class is a thin wrapper around the fastapi.Request class. Attributes",
            "    of this class include: `headers`, `client`, `query_params`, `session_hash`, and `path_params`. If",
            "    auth is enabled, the `username` attribute can be used to get the logged in user.",
            "    Example:",
            "        import gradio as gr",
            "        def echo(text, request: gr.Request):",
            "            if request:",
            "                print(\"Request headers dictionary:\", request.headers)",
            "                print(\"IP address:\", request.client.host)",
            "                print(\"Query parameters:\", dict(request.query_params))",
            "                print(\"Session hash:\", request.session_hash)",
            "            return text",
            "        io = gr.Interface(echo, \"textbox\", \"textbox\").launch()",
            "    Demos: request_ip_headers",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        request: fastapi.Request | None = None,",
            "        username: str | None = None,",
            "        session_hash: str | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Can be instantiated with either a fastapi.Request or by manually passing in",
            "        attributes (needed for queueing).",
            "        Parameters:",
            "            request: A fastapi.Request",
            "            username: The username of the logged in user (if auth is enabled)",
            "            session_hash: The session hash of the current session. It is unique for each page load.",
            "        \"\"\"",
            "        self.request = request",
            "        self.username = username",
            "        self.session_hash = session_hash",
            "        self.kwargs: dict = kwargs",
            "",
            "    def dict_to_obj(self, d):",
            "        if isinstance(d, dict):",
            "            return json.loads(json.dumps(d), object_hook=Obj)",
            "        else:",
            "            return d",
            "",
            "    def __getattr__(self, name):",
            "        if self.request:",
            "            return self.dict_to_obj(getattr(self.request, name))",
            "        else:",
            "            try:",
            "                obj = self.kwargs[name]",
            "            except KeyError as ke:",
            "                raise AttributeError(",
            "                    f\"'Request' object has no attribute '{name}'\"",
            "                ) from ke",
            "            return self.dict_to_obj(obj)",
            "",
            "",
            "class FnIndexInferError(Exception):",
            "    pass",
            "",
            "",
            "def get_fn(blocks: Blocks, api_name: str | None, body: PredictBody) -> BlockFunction:",
            "    if body.session_hash:",
            "        session_state = blocks.state_holder[body.session_hash]",
            "        fns = session_state.blocks_config.fns",
            "    else:",
            "        fns = blocks.fns",
            "",
            "    if body.fn_index is None:",
            "        if api_name is not None:",
            "            for fn in fns.values():",
            "                if fn.api_name == api_name:",
            "                    return fn",
            "        raise FnIndexInferError(",
            "            f\"Could not infer function index for API name: {api_name}\"",
            "        )",
            "    else:",
            "        return fns[body.fn_index]",
            "",
            "",
            "def compile_gr_request(",
            "    body: PredictBody,",
            "    fn: BlockFunction,",
            "    username: Optional[str],",
            "    request: Optional[fastapi.Request],",
            "):",
            "    # If this fn_index cancels jobs, then the only input we need is the",
            "    # current session hash",
            "    if fn.cancels:",
            "        body.data = [body.session_hash]",
            "    if body.request:",
            "        if body.batched:",
            "            gr_request = [Request(username=username, request=request)]",
            "        else:",
            "            gr_request = Request(",
            "                username=username, request=body.request, session_hash=body.session_hash",
            "            )",
            "    else:",
            "        if request is None:",
            "            raise ValueError(\"request must be provided if body.request is None\")",
            "        gr_request = Request(",
            "            username=username, request=request, session_hash=body.session_hash",
            "        )",
            "",
            "    return gr_request",
            "",
            "",
            "def restore_session_state(app: App, body: PredictBody):",
            "    event_id = body.event_id",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    if session_hash is not None:",
            "        session_state = app.state_holder[session_hash]",
            "        # The should_reset set keeps track of the fn_indices",
            "        # that have been cancelled. When a job is cancelled,",
            "        # the /reset route will mark the jobs as having been reset.",
            "        # That way if the cancel job finishes BEFORE the job being cancelled",
            "        # the job being cancelled will not overwrite the state of the iterator.",
            "        if event_id is None:",
            "            iterator = None",
            "        elif event_id in app.iterators_to_reset:",
            "            iterator = None",
            "            app.iterators_to_reset.remove(event_id)",
            "        else:",
            "            iterator = app.iterators.get(event_id)",
            "    else:",
            "        session_state = SessionState(app.get_blocks())",
            "        iterator = None",
            "",
            "    return session_state, iterator",
            "",
            "",
            "def prepare_event_data(",
            "    blocks: Blocks,",
            "    body: PredictBody,",
            ") -> EventData:",
            "    target = body.trigger_id",
            "    event_data = EventData(",
            "        blocks.blocks.get(target) if target else None,",
            "        body.event_data,",
            "    )",
            "    return event_data",
            "",
            "",
            "async def call_process_api(",
            "    app: App,",
            "    body: PredictBody,",
            "    gr_request: Union[Request, list[Request]],",
            "    fn: BlockFunction,",
            "    root_path: str,",
            "):",
            "    session_state, iterator = restore_session_state(app=app, body=body)",
            "",
            "    event_data = prepare_event_data(app.get_blocks(), body)",
            "    event_id = body.event_id",
            "",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    inputs = body.data",
            "",
            "    batch_in_single_out = not body.batched and fn.batch",
            "    if batch_in_single_out:",
            "        inputs = [inputs]",
            "",
            "    try:",
            "        with utils.MatplotlibBackendMananger():",
            "            output = await app.get_blocks().process_api(",
            "                block_fn=fn,",
            "                inputs=inputs,",
            "                request=gr_request,",
            "                state=session_state,",
            "                iterator=iterator,",
            "                session_hash=session_hash,",
            "                event_id=event_id,",
            "                event_data=event_data,",
            "                in_event_listener=True,",
            "                simple_format=body.simple_format,",
            "                root_path=root_path,",
            "            )",
            "        iterator = output.pop(\"iterator\", None)",
            "        if event_id is not None:",
            "            app.iterators[event_id] = iterator  # type: ignore",
            "        if isinstance(output, Error):",
            "            raise output",
            "    except BaseException:",
            "        iterator = app.iterators.get(event_id) if event_id is not None else None",
            "        if iterator is not None:  # close off any streams that are still open",
            "            run_id = id(iterator)",
            "            pending_streams: dict[int, MediaStream] = (",
            "                app.get_blocks().pending_streams[session_hash].get(run_id, {})",
            "            )",
            "            for stream in pending_streams.values():",
            "                stream.end_stream()",
            "        raise",
            "",
            "    if batch_in_single_out:",
            "        output[\"data\"] = output[\"data\"][0]",
            "",
            "    return output",
            "",
            "",
            "def get_root_url(",
            "    request: fastapi.Request, route_path: str, root_path: str | None",
            ") -> str:",
            "    \"\"\"",
            "    Gets the root url of the Gradio app (i.e. the public url of the app) without a trailing slash.",
            "",
            "    This is how the root_url is resolved:",
            "    1. If a user provides a `root_path` manually that is a full URL, it is returned directly.",
            "    2. If the request has an x-forwarded-host header (e.g. because it is behind a proxy), the root url is",
            "    constructed from the x-forwarded-host header. In this case, `route_path` is not used to construct the root url.",
            "    3. Otherwise, the root url is constructed from the request url. The query parameters and `route_path` are stripped off.",
            "    And if a relative `root_path` is provided, and it is not already the subpath of the URL, it is appended to the root url.",
            "",
            "    In cases (2) and (3), We also check to see if the x-forwarded-proto header is present, and if so, convert the root url to https.",
            "    And if there are multiple hosts in the x-forwarded-host or multiple protocols in the x-forwarded-proto, the first one is used.",
            "    \"\"\"",
            "",
            "    def get_first_header_value(header_name: str):",
            "        header_value = request.headers.get(header_name)",
            "        if header_value:",
            "            return header_value.split(\",\")[0].strip()",
            "        return None",
            "",
            "    if root_path and client_utils.is_http_url_like(root_path):",
            "        return root_path.rstrip(\"/\")",
            "",
            "    x_forwarded_host = get_first_header_value(\"x-forwarded-host\")",
            "    root_url = f\"http://{x_forwarded_host}\" if x_forwarded_host else str(request.url)",
            "    root_url = httpx.URL(root_url)",
            "    root_url = root_url.copy_with(query=None)",
            "    root_url = str(root_url).rstrip(\"/\")",
            "    if get_first_header_value(\"x-forwarded-proto\") == \"https\":",
            "        root_url = root_url.replace(\"http://\", \"https://\")",
            "",
            "    route_path = route_path.rstrip(\"/\")",
            "    if len(route_path) > 0 and not x_forwarded_host:",
            "        root_url = root_url[: -len(route_path)]",
            "    root_url = root_url.rstrip(\"/\")",
            "",
            "    root_url = httpx.URL(root_url)",
            "    if root_path and root_url.path != root_path:",
            "        root_url = root_url.copy_with(path=root_path)",
            "",
            "    return str(root_url).rstrip(\"/\")",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class GradioUploadFile(UploadFile):",
            "    \"\"\"UploadFile with a sha attribute.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        file: BinaryIO,",
            "        *,",
            "        size: int | None = None,",
            "        filename: str | None = None,",
            "        headers: Headers | None = None,",
            "    ) -> None:",
            "        super().__init__(file, size=size, filename=filename, headers=headers)",
            "        self.sha = hashlib.sha1()",
            "        self.sha.update(processing_utils.hash_seed)",
            "",
            "",
            "@python_dataclass(frozen=True)",
            "class FileUploadProgressUnit:",
            "    filename: str",
            "    chunk_size: int",
            "",
            "",
            "@python_dataclass",
            "class FileUploadProgressTracker:",
            "    deque: deque[FileUploadProgressUnit]",
            "    is_done: bool",
            "",
            "",
            "class FileUploadProgressNotTrackedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgressNotQueuedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgress:",
            "    def __init__(self) -> None:",
            "        self._statuses: dict[str, FileUploadProgressTracker] = {}",
            "",
            "    def track(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self._statuses[upload_id] = FileUploadProgressTracker(deque(), False)",
            "",
            "    def append(self, upload_id: str, filename: str, message_bytes: bytes):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        queue = self._statuses[upload_id].deque",
            "",
            "        if len(queue) == 0:",
            "            queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "        else:",
            "            last_unit = queue.popleft()",
            "            if last_unit.filename != filename:",
            "                queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "            else:",
            "                queue.append(",
            "                    FileUploadProgressUnit(",
            "                        filename,",
            "                        last_unit.chunk_size + len(message_bytes),",
            "                    )",
            "                )",
            "",
            "    def set_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        self._statuses[upload_id].is_done = True",
            "",
            "    def is_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        return self._statuses[upload_id].is_done",
            "",
            "    def stop_tracking(self, upload_id: str):",
            "        if upload_id in self._statuses:",
            "            del self._statuses[upload_id]",
            "",
            "    def pop(self, upload_id: str) -> FileUploadProgressUnit:",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        try:",
            "            return self._statuses[upload_id].deque.pop()",
            "        except IndexError as e:",
            "            raise FileUploadProgressNotQueuedError() from e",
            "",
            "",
            "class GradioMultiPartParser:",
            "    \"\"\"Vendored from starlette.MultipartParser.",
            "",
            "    Thanks starlette!",
            "",
            "    Made the following modifications",
            "        - Use GradioUploadFile instead of UploadFile",
            "        - Use NamedTemporaryFile instead of SpooledTemporaryFile",
            "        - Compute hash of data as the request is streamed",
            "",
            "    \"\"\"",
            "",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self,",
            "        headers: Headers,",
            "        stream: AsyncGenerator[bytes, None],",
            "        *,",
            "        max_files: Union[int, float] = 1000,",
            "        max_fields: Union[int, float] = 1000,",
            "        upload_id: str | None = None,",
            "        upload_progress: FileUploadProgress | None = None,",
            "        max_file_size: int | float,",
            "    ) -> None:",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.max_files = max_files",
            "        self.max_fields = max_fields",
            "        self.items: List[Tuple[str, Union[str, UploadFile]]] = []",
            "        self.upload_id = upload_id",
            "        self.upload_progress = upload_progress",
            "        self._current_files = 0",
            "        self._current_fields = 0",
            "        self.max_file_size = max_file_size",
            "        self._current_partial_header_name: bytes = b\"\"",
            "        self._current_partial_header_value: bytes = b\"\"",
            "        self._current_part = MultipartPart()",
            "        self._charset = \"\"",
            "        self._file_parts_to_write: List[Tuple[MultipartPart, bytes]] = []",
            "        self._file_parts_to_finish: List[MultipartPart] = []",
            "        self._files_to_close_on_error: List[_TemporaryFileWrapper] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        self._current_part = MultipartPart()",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message_bytes = data[start:end]",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.append(",
            "                self.upload_id,  # type: ignore",
            "                self._current_part.file.filename,  # type: ignore",
            "                message_bytes,",
            "            )",
            "        if self._current_part.file is None:",
            "            self._current_part.data += message_bytes",
            "        else:",
            "            self._file_parts_to_write.append((self._current_part, message_bytes))",
            "",
            "    def on_part_end(self) -> None:",
            "        if self._current_part.file is None:",
            "            self.items.append(",
            "                (",
            "                    self._current_part.field_name,",
            "                    _user_safe_decode(self._current_part.data, str(self._charset)),",
            "                )",
            "            )",
            "        else:",
            "            self._file_parts_to_finish.append(self._current_part)",
            "            # The file can be added to the items right now even though it's not",
            "            # finished yet, because it will be finished in the `parse()` method, before",
            "            # self.items is used in the return value.",
            "            self.items.append((self._current_part.field_name, self._current_part.file))",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_name += data[start:end]",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_value += data[start:end]",
            "",
            "    def on_header_end(self) -> None:",
            "        field = self._current_partial_header_name.lower()",
            "        if field == b\"content-disposition\":",
            "            self._current_part.content_disposition = self._current_partial_header_value",
            "        self._current_part.item_headers.append(",
            "            (field, self._current_partial_header_value)",
            "        )",
            "        self._current_partial_header_name = b\"\"",
            "        self._current_partial_header_value = b\"\"",
            "",
            "    def on_headers_finished(self) -> None:",
            "        _, options = parse_options_header(self._current_part.content_disposition or b\"\")",
            "        try:",
            "            self._current_part.field_name = _user_safe_decode(",
            "                options[b\"name\"], str(self._charset)",
            "            )",
            "        except KeyError as e:",
            "            raise MultiPartException(",
            "                'The Content-Disposition header field \"name\" must be ' \"provided.\"",
            "            ) from e",
            "        if b\"filename\" in options:",
            "            self._current_files += 1",
            "            if self._current_files > self.max_files:",
            "                raise MultiPartException(",
            "                    f\"Too many files. Maximum number of files is {self.max_files}.\"",
            "                )",
            "            filename = _user_safe_decode(options[b\"filename\"], str(self._charset))",
            "            tempfile = NamedTemporaryFile(delete=False)",
            "            self._files_to_close_on_error.append(tempfile)",
            "            self._current_part.file = GradioUploadFile(",
            "                file=tempfile,  # type: ignore[arg-type]",
            "                size=0,",
            "                filename=filename,",
            "                headers=Headers(raw=self._current_part.item_headers),",
            "            )",
            "        else:",
            "            self._current_fields += 1",
            "            if self._current_fields > self.max_fields:",
            "                raise MultiPartException(",
            "                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"",
            "                )",
            "            self._current_part.file = None",
            "",
            "    def on_end(self) -> None:",
            "        pass",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if isinstance(charset, bytes):",
            "            charset = charset.decode(\"latin-1\")",
            "        self._charset = charset",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError as e:",
            "            raise MultiPartException(\"Missing boundary in multipart.\") from e",
            "",
            "        # Callbacks dictionary.",
            "        callbacks: multipart.multipart.MultipartCallbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        try:",
            "            # Feed the parser with data from the request.",
            "            async for chunk in self.stream:",
            "                parser.write(chunk)",
            "                # Write file data, it needs to use await with the UploadFile methods",
            "                # that call the corresponding file methods *in a threadpool*,",
            "                # otherwise, if they were called directly in the callback methods above",
            "                # (regular, non-async functions), that would block the event loop in",
            "                # the main thread.",
            "                for part, data in self._file_parts_to_write:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.write(data)",
            "                    part.file.sha.update(data)  # type: ignore",
            "                    if os.stat(part.file.file.name).st_size > self.max_file_size:",
            "                        if self.upload_progress is not None:",
            "                            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "                        raise MultiPartException(",
            "                            f\"File size exceeded maximum allowed size of {self.max_file_size} bytes.\"",
            "                        )",
            "                for part in self._file_parts_to_finish:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.seek(0)",
            "                self._file_parts_to_write.clear()",
            "                self._file_parts_to_finish.clear()",
            "        except MultiPartException as exc:",
            "            # Close all the files if there was an error.",
            "            for file in self._files_to_close_on_error:",
            "                file.close()",
            "                Path(file.name).unlink()",
            "            raise exc",
            "",
            "        parser.finalize()",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "        return FormData(self.items)",
            "",
            "",
            "def move_uploaded_files_to_cache(files: list[str], destinations: list[str]) -> None:",
            "    for file, dest in zip(files, destinations):",
            "        shutil.move(file, dest)",
            "",
            "",
            "def update_root_in_config(config: BlocksConfigDict, root: str) -> BlocksConfigDict:",
            "    \"\"\"",
            "    Updates the root \"key\" in the config dictionary to the new root url. If the",
            "    root url has changed, all of the urls in the config that correspond to component",
            "    file urls are updated to use the new root url.",
            "    \"\"\"",
            "    with config_lock:",
            "        previous_root = config.get(\"root\")",
            "        if previous_root is None or previous_root != root:",
            "            config[\"root\"] = root",
            "            config = processing_utils.add_root_url(config, root, previous_root)  # type: ignore",
            "    return config",
            "",
            "",
            "def compare_passwords_securely(input_password: str, correct_password: str) -> bool:",
            "    return hmac.compare_digest(input_password.encode(), correct_password.encode())",
            "",
            "",
            "def starts_with_protocol(string: str) -> bool:",
            "    \"\"\"This regex matches strings that start with a scheme (one or more characters not including colon, slash, or space)",
            "    followed by ://, or start with just //, \\\\/, /\\\\, or \\\\ as they are interpreted as SMB paths on Windows.",
            "    \"\"\"",
            "    pattern = r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-.]*://|//|\\\\\\\\|\\\\/|/\\\\)\"",
            "    return re.match(pattern, string) is not None",
            "",
            "",
            "def get_hostname(url: str) -> str:",
            "    \"\"\"",
            "    Returns the hostname of a given url, or an empty string if the url cannot be parsed.",
            "    Examples:",
            "        get_hostname(\"https://www.gradio.app\") -> \"www.gradio.app\"",
            "        get_hostname(\"localhost:7860\") -> \"localhost\"",
            "        get_hostname(\"127.0.0.1\") -> \"127.0.0.1\"",
            "    \"\"\"",
            "    if not url:",
            "        return \"\"",
            "    if \"://\" not in url:",
            "        url = \"http://\" + url",
            "    try:",
            "        return urlparse(url).hostname or \"\"",
            "    except Exception:",
            "        return \"\"",
            "",
            "",
            "class CustomCORSMiddleware:",
            "    # This is a modified version of the Starlette CORSMiddleware that restricts the allowed origins when the host is localhost.",
            "    # Adapted from: https://github.com/encode/starlette/blob/89fae174a1ea10f59ae248fe030d9b7e83d0b8a0/starlette/middleware/cors.py",
            "",
            "    def __init__(",
            "        self,",
            "        app: ASGIApp,",
            "        strict_cors: bool = True,",
            "    ) -> None:",
            "        self.app = app",
            "        self.all_methods = (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\")",
            "        self.preflight_headers = {",
            "            \"Access-Control-Allow-Methods\": \", \".join(self.all_methods),",
            "            \"Access-Control-Max-Age\": str(600),",
            "            \"Access-Control-Allow-Credentials\": \"true\",",
            "        }",
            "        self.simple_headers = {\"Access-Control-Allow-Credentials\": \"true\"}",
            "        # Any of these hosts suggests that the Gradio app is running locally.",
            "        self.localhost_aliases = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"]",
            "        if not strict_cors:  # type: ignore",
            "            # Note: \"null\" is a special case that happens if a Gradio app is running",
            "            # as an embedded web component in a local static webpage. However, it can",
            "            # also be used maliciously for CSRF attacks, so it is not allowed by default.",
            "            self.localhost_aliases.append(\"null\")",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        if scope[\"type\"] != \"http\":",
            "            await self.app(scope, receive, send)",
            "            return",
            "        headers = Headers(scope=scope)",
            "        origin = headers.get(\"origin\")",
            "        if origin is None:",
            "            await self.app(scope, receive, send)",
            "            return",
            "        if scope[\"method\"] == \"OPTIONS\" and \"access-control-request-method\" in headers:",
            "            response = self.preflight_response(request_headers=headers)",
            "            await response(scope, receive, send)",
            "            return",
            "        await self.simple_response(scope, receive, send, request_headers=headers)",
            "",
            "    def preflight_response(self, request_headers: Headers) -> Response:",
            "        headers = dict(self.preflight_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            headers[\"Access-Control-Allow-Origin\"] = origin",
            "        requested_headers = request_headers.get(\"access-control-request-headers\")",
            "        if requested_headers is not None:",
            "            headers[\"Access-Control-Allow-Headers\"] = requested_headers",
            "        return PlainTextResponse(\"OK\", status_code=200, headers=headers)",
            "",
            "    async def simple_response(",
            "        self, scope: Scope, receive: Receive, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        send = functools.partial(self._send, send=send, request_headers=request_headers)",
            "        await self.app(scope, receive, send)",
            "",
            "    async def _send(",
            "        self, message: Message, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        if message[\"type\"] != \"http.response.start\":",
            "            await send(message)",
            "            return",
            "        message.setdefault(\"headers\", [])",
            "        headers = MutableHeaders(scope=message)",
            "        headers.update(self.simple_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            self.allow_explicit_origin(headers, origin)",
            "        await send(message)",
            "",
            "    def is_valid_origin(self, request_headers: Headers) -> bool:",
            "        origin = request_headers[\"Origin\"]",
            "        host = request_headers[\"Host\"]",
            "        host_name = get_hostname(host)",
            "        origin_name = get_hostname(origin)",
            "        return (",
            "            host_name not in self.localhost_aliases",
            "            or origin_name in self.localhost_aliases",
            "        )",
            "",
            "    @staticmethod",
            "    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None:",
            "        headers[\"Access-Control-Allow-Origin\"] = origin",
            "        headers.add_vary_header(\"Origin\")",
            "",
            "",
            "def delete_files_created_by_app(blocks: Blocks, age: int | None) -> None:",
            "    \"\"\"Delete files that are older than age. If age is None, delete all files.\"\"\"",
            "    dont_delete = set()",
            "    for component in blocks.blocks.values():",
            "        dont_delete.update(getattr(component, \"keep_in_cache\", set()))",
            "    for temp_set in blocks.temp_file_sets:",
            "        # We use a copy of the set to avoid modifying the set while iterating over it",
            "        # otherwise we would get an exception: Set changed size during iteration",
            "        to_remove = set()",
            "        for file in temp_set:",
            "            if file in dont_delete:",
            "                continue",
            "            try:",
            "                file_path = Path(file)",
            "                modified_time = datetime.fromtimestamp(file_path.lstat().st_ctime)",
            "                if age is None or (datetime.now() - modified_time).seconds > age:",
            "                    os.remove(file)",
            "                    to_remove.add(file)",
            "            except FileNotFoundError:",
            "                continue",
            "        temp_set -= to_remove",
            "",
            "",
            "async def delete_files_on_schedule(app: App, frequency: int, age: int) -> None:",
            "    \"\"\"Startup task to delete files created by the app based on time since last modification.\"\"\"",
            "    while True:",
            "        await asyncio.sleep(frequency)",
            "        await anyio.to_thread.run_sync(",
            "            delete_files_created_by_app, app.get_blocks(), age",
            "        )",
            "",
            "",
            "@asynccontextmanager",
            "async def _lifespan_handler(",
            "    app: App, frequency: int = 1, age: int = 1",
            ") -> AsyncGenerator:",
            "    \"\"\"A context manager that triggers the startup and shutdown events of the app.\"\"\"",
            "    asyncio.create_task(delete_files_on_schedule(app, frequency, age))",
            "    yield",
            "    delete_files_created_by_app(app.get_blocks(), age=None)",
            "",
            "",
            "async def _delete_state(app: App):",
            "    \"\"\"Delete all expired state every second.\"\"\"",
            "    while True:",
            "        app.state_holder.delete_all_expired_state()",
            "        await asyncio.sleep(1)",
            "",
            "",
            "@asynccontextmanager",
            "async def _delete_state_handler(app: App):",
            "    \"\"\"When the server launches, regularly delete expired state.\"\"\"",
            "    # The stop event needs to get the current event loop for python 3.8",
            "    # but the loop parameter is deprecated for 3.8+",
            "    if sys.version_info < (3, 10):",
            "        loop = asyncio.get_running_loop()",
            "        app.stop_event = asyncio.Event(loop=loop)",
            "    asyncio.create_task(_delete_state(app))",
            "    yield",
            "",
            "",
            "def create_lifespan_handler(",
            "    user_lifespan: Callable[[App], AsyncContextManager] | None,",
            "    frequency: int | None = 1,",
            "    age: int | None = 1,",
            ") -> Callable[[App], AsyncContextManager]:",
            "    \"\"\"Return a context manager that applies _lifespan_handler and user_lifespan if it exists.\"\"\"",
            "",
            "    @asynccontextmanager",
            "    async def _handler(app: App):",
            "        async with AsyncExitStack() as stack:",
            "            await stack.enter_async_context(_delete_state_handler(app))",
            "            if frequency and age:",
            "                await stack.enter_async_context(_lifespan_handler(app, frequency, age))",
            "            if user_lifespan is not None:",
            "                await stack.enter_async_context(user_lifespan(app))",
            "            yield",
            "",
            "    return _handler",
            "",
            "",
            "class MediaStream:",
            "    def __init__(self):",
            "        self.segments: list[MediaStreamChunk] = []",
            "        self.ended = False",
            "        self.segment_index = 0",
            "        self.playlist = \"#EXTM3U\\n#EXT-X-PLAYLIST-TYPE:EVENT\\n#EXT-X-TARGETDURATION:10\\n#EXT-X-VERSION:4\\n#EXT-X-MEDIA-SEQUENCE:0\\n\"",
            "        self.max_length = 5",
            "",
            "    async def add_segment(self, data: MediaStreamChunk | None):",
            "        if not data:",
            "            return",
            "",
            "        segment_id = str(uuid.uuid4())",
            "        self.segments.append({\"id\": segment_id, **data})",
            "        self.max_duration = max(self.max_length, data[\"duration\"]) + 1",
            "",
            "    def end_stream(self):",
            "        self.ended = True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.twisted.web.client.URI.fromBytes",
            "gradio.route_utils.GradioUploadFile",
            "gradio.route_utils.GradioMultiPartParser.on_headers_finished"
        ]
    },
    "gradio/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import traceback"
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import typing"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import urllib.parse"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+import uuid"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import warnings"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from abc import ABC, abstractmethod"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from collections import OrderedDict"
            },
            "7": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " from gradio_client.documentation import document"
            },
            "8": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " from typing_extensions import ParamSpec"
            },
            "9": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+import gradio"
            },
            "11": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " from gradio.context import get_blocks_context"
            },
            "12": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " from gradio.data_classes import BlocksConfigDict, FileData"
            },
            "13": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " from gradio.exceptions import Error"
            },
            "14": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "     return article"
            },
            "15": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 438,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 439,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+HASH_SEED_PATH = os.path.join(os.path.dirname(gradio.__file__), \"hash_seed.txt\")"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+def get_hash_seed() -> str:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+    try:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+        if os.path.exists(HASH_SEED_PATH):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+            with open(HASH_SEED_PATH) as j:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 447,
                "PatchRowcode": "+                return j.read().strip()"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 448,
                "PatchRowcode": "+        else:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+            with open(HASH_SEED_PATH, \"w\") as j:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+                seed = uuid.uuid4().hex"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+                j.write(seed)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+                return seed"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+    except Exception:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        return uuid.uuid4().hex"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 457,
                "PatchRowcode": " def get_default_args(func: Callable) -> list[Any]:"
            },
            "35": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 458,
                "PatchRowcode": "     signature = inspect.signature(func)"
            },
            "36": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 459,
                "PatchRowcode": "     return ["
            }
        },
        "frontPatchFile": [
            "\"\"\"Handy utility functions.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import ast",
            "import asyncio",
            "import copy",
            "import functools",
            "import hashlib",
            "import importlib",
            "import importlib.util",
            "import inspect",
            "import json",
            "import json.decoder",
            "import os",
            "import pkgutil",
            "import re",
            "import sys",
            "import tempfile",
            "import threading",
            "import time",
            "import traceback",
            "import typing",
            "import urllib.parse",
            "import warnings",
            "from abc import ABC, abstractmethod",
            "from collections import OrderedDict",
            "from collections.abc import MutableMapping",
            "from contextlib import contextmanager",
            "from functools import wraps",
            "from io import BytesIO",
            "from pathlib import Path",
            "from types import ModuleType",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Generic,",
            "    Iterable,",
            "    Iterator,",
            "    Literal,",
            "    Optional,",
            "    Sequence,",
            "    TypeVar,",
            ")",
            "",
            "import anyio",
            "import gradio_client.utils as client_utils",
            "import httpx",
            "import orjson",
            "from gradio_client.documentation import document",
            "from typing_extensions import ParamSpec",
            "",
            "from gradio.context import get_blocks_context",
            "from gradio.data_classes import BlocksConfigDict, FileData",
            "from gradio.exceptions import Error",
            "",
            "if TYPE_CHECKING:  # Only import for type checking (is False at runtime).",
            "    from gradio.blocks import BlockContext, Blocks",
            "    from gradio.components import Component",
            "    from gradio.routes import App, Request",
            "    from gradio.state_holder import SessionState",
            "",
            "P = ParamSpec(\"P\")",
            "T = TypeVar(\"T\")",
            "",
            "",
            "def get_package_version() -> str:",
            "    try:",
            "        package_json_data = (",
            "            pkgutil.get_data(__name__, \"package.json\").decode(\"utf-8\").strip()  # type: ignore",
            "        )",
            "        package_data = json.loads(package_json_data)",
            "        version = package_data.get(\"version\", \"\")",
            "        return version",
            "    except Exception:",
            "        return \"\"",
            "",
            "",
            "def safe_get_lock() -> asyncio.Lock:",
            "    \"\"\"Get asyncio.Lock() without fear of getting an Exception.",
            "",
            "    Needed because in reload mode we import the Blocks object outside",
            "    the main thread.",
            "    \"\"\"",
            "    try:",
            "        asyncio.get_event_loop()",
            "        return asyncio.Lock()",
            "    except RuntimeError:",
            "        return None  # type: ignore",
            "",
            "",
            "def safe_get_stop_event() -> asyncio.Event:",
            "    try:",
            "        asyncio.get_event_loop()",
            "        return asyncio.Event()",
            "    except RuntimeError:",
            "        return None  # type: ignore",
            "",
            "",
            "class BaseReloader(ABC):",
            "    @property",
            "    @abstractmethod",
            "    def running_app(self) -> App:",
            "        pass",
            "",
            "    def swap_blocks(self, demo: Blocks):",
            "        assert self.running_app.blocks  # noqa: S101",
            "        # Copy over the blocks to get new components and events but",
            "        # not a new queue",
            "        demo._queue = self.running_app.blocks._queue",
            "        demo.max_file_size = self.running_app.blocks.max_file_size",
            "        self.running_app.state_holder.reset(demo)",
            "        self.running_app.blocks = demo",
            "",
            "",
            "class SourceFileReloader(BaseReloader):",
            "    def __init__(",
            "        self,",
            "        app: App,",
            "        watch_dirs: list[str],",
            "        watch_module_name: str,",
            "        demo_file: str,",
            "        stop_event: threading.Event,",
            "        demo_name: str = \"demo\",",
            "    ) -> None:",
            "        super().__init__()",
            "        self.app = app",
            "        self.watch_dirs = watch_dirs",
            "        self.watch_module_name = watch_module_name",
            "        self.stop_event = stop_event",
            "        self.demo_name = demo_name",
            "        self.demo_file = Path(demo_file)",
            "",
            "    @property",
            "    def running_app(self) -> App:",
            "        return self.app",
            "",
            "    def should_watch(self) -> bool:",
            "        return not self.stop_event.is_set()",
            "",
            "    def stop(self) -> None:",
            "        self.stop_event.set()",
            "",
            "    def alert_change(self, change_type: Literal[\"reload\", \"error\"] = \"reload\"):",
            "        self.app.change_type = change_type",
            "        self.app.change_count += 1",
            "",
            "    def swap_blocks(self, demo: Blocks):",
            "        old_blocks = self.running_app.blocks",
            "        super().swap_blocks(demo)",
            "        if old_blocks:",
            "            reassign_keys(old_blocks, demo)",
            "        demo.config = demo.get_config_file()",
            "        self.alert_change(\"reload\")",
            "",
            "",
            "NO_RELOAD = True",
            "",
            "",
            "def _remove_no_reload_codeblocks(file_path: str):",
            "    \"\"\"Parse the file, remove the gr.no_reload code blocks, and write the file back to disk.",
            "",
            "    Parameters:",
            "        file_path (str): The path to the file to remove the no_reload code blocks from.",
            "    \"\"\"",
            "",
            "    with open(file_path, encoding=\"utf-8\") as file:",
            "        code = file.read()",
            "",
            "    tree = ast.parse(code)",
            "",
            "    def _is_gr_no_reload(expr: ast.AST) -> bool:",
            "        \"\"\"Find with gr.no_reload context managers.\"\"\"",
            "        return (",
            "            isinstance(expr, ast.If)",
            "            and isinstance(expr.test, ast.Attribute)",
            "            and isinstance(expr.test.value, ast.Name)",
            "            and expr.test.value.id == \"gr\"",
            "            and expr.test.attr == \"NO_RELOAD\"",
            "        )",
            "",
            "    # Find the positions of the code blocks to load",
            "    for node in ast.walk(tree):",
            "        if _is_gr_no_reload(node):",
            "            assert isinstance(node, ast.If)  # noqa: S101",
            "            node.body = [ast.Pass(lineno=node.lineno, col_offset=node.col_offset)]",
            "",
            "    # convert tree to string",
            "    code_removed = compile(tree, filename=file_path, mode=\"exec\")",
            "    return code_removed",
            "",
            "",
            "def _find_module(source_file: Path) -> ModuleType | None:",
            "    for s, v in sys.modules.items():",
            "        if s not in {\"__main__\", \"__mp_main__\"} and getattr(v, \"__file__\", None) == str(",
            "            source_file",
            "        ):",
            "            return v",
            "    return None",
            "",
            "",
            "def watchfn(reloader: SourceFileReloader):",
            "    \"\"\"Watch python files in a given module.",
            "",
            "    get_changes is taken from uvicorn's default file watcher.",
            "    \"\"\"",
            "",
            "    # The thread running watchfn will be the thread reloading",
            "    # the app. So we need to modify this thread_data attr here",
            "    # so that subsequent calls to reload don't launch the app",
            "    from gradio.cli.commands.reload import reload_thread",
            "",
            "    reload_thread.running_reload = True",
            "",
            "    def get_changes() -> Path | None:",
            "        for file in iter_py_files():",
            "            try:",
            "                mtime = file.stat().st_mtime",
            "            except OSError:  # pragma: nocover",
            "                continue",
            "",
            "            old_time = mtimes.get(file)",
            "            if old_time is None:",
            "                mtimes[file] = mtime",
            "                continue",
            "            elif mtime > old_time:",
            "                return file",
            "        return None",
            "",
            "    def iter_py_files() -> Iterator[Path]:",
            "        for reload_dir in reload_dirs:",
            "            for path in list(reload_dir.rglob(\"*.py\")):",
            "                yield path.resolve()",
            "            for path in list(reload_dir.rglob(\"*.css\")):",
            "                yield path.resolve()",
            "",
            "    reload_dirs = [Path(dir_) for dir_ in reloader.watch_dirs]",
            "    import sys",
            "",
            "    for dir_ in reload_dirs:",
            "        sys.path.insert(0, str(dir_))",
            "",
            "    mtimes = {}",
            "    # Need to import the module in this thread so that the",
            "    # module is available in the namespace of this thread",
            "    module = importlib.import_module(reloader.watch_module_name)",
            "    while reloader.should_watch():",
            "        changed = get_changes()",
            "        if changed:",
            "            print(f\"Changes detected in: {changed}\")",
            "            try:",
            "                # How source file reloading works",
            "                # 1. Remove the gr.no_reload code blocks from the temp file",
            "                # 2. Execute the changed source code in the original module's namespac",
            "                # 3. Delete the package the module is in from sys.modules.",
            "                # This is so that the updated module is available in the entire package",
            "                # 4. Do 1-2 for the main demo file even if it did not change.",
            "                # This is because the main demo file may import the changed file and we need the",
            "                # changes to be reflected in the main demo file.",
            "",
            "                if changed.suffix == \".py\":",
            "                    changed_in_copy = _remove_no_reload_codeblocks(str(changed))",
            "                    if changed != reloader.demo_file:",
            "                        changed_module = _find_module(changed)",
            "                        if changed_module:",
            "                            exec(changed_in_copy, changed_module.__dict__)",
            "                            top_level_parent = sys.modules[",
            "                                changed_module.__name__.split(\".\")[0]",
            "                            ]",
            "                            if top_level_parent != changed_module:",
            "                                importlib.reload(top_level_parent)",
            "",
            "                changed_demo_file = _remove_no_reload_codeblocks(",
            "                    str(reloader.demo_file)",
            "                )",
            "                exec(changed_demo_file, module.__dict__)",
            "            except Exception:",
            "                print(",
            "                    f\"Reloading {reloader.watch_module_name} failed with the following exception: \"",
            "                )",
            "                traceback.print_exc()",
            "                mtimes = {}",
            "                reloader.alert_change(\"error\")",
            "                reloader.app.reload_error_message = traceback.format_exc()",
            "                continue",
            "            demo = getattr(module, reloader.demo_name)",
            "            reloader.swap_blocks(demo)",
            "            mtimes = {}",
            "        time.sleep(0.05)",
            "",
            "",
            "def deep_equal(a: Any, b: Any) -> bool:",
            "    \"\"\"",
            "    Deep equality check for component values.",
            "",
            "    Prefer orjson for performance and compatibility with numpy arrays/dataframes/torch tensors.",
            "    If objects are not serializable by orjson, fall back to regular equality check.",
            "    \"\"\"",
            "",
            "    def _serialize(a: Any) -> bytes:",
            "        return orjson.dumps(",
            "            a,",
            "            option=orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_PASSTHROUGH_DATETIME,",
            "        )",
            "",
            "    try:",
            "        return _serialize(a) == _serialize(b)",
            "    except TypeError:",
            "        try:",
            "            return a == b",
            "        except Exception:",
            "            return False",
            "",
            "",
            "def reassign_keys(old_blocks: Blocks, new_blocks: Blocks):",
            "    from gradio.blocks import BlockContext",
            "",
            "    assigned_keys = [",
            "        block.key for block in new_blocks.children if block.key is not None",
            "    ]",
            "",
            "    def reassign_context_keys(",
            "        old_context: BlockContext | None, new_context: BlockContext",
            "    ):",
            "        for i, new_block in enumerate(new_context.children):",
            "            if old_context and i < len(old_context.children):",
            "                old_block = old_context.children[i]",
            "            else:",
            "                old_block = None",
            "            if new_block.key is None:",
            "                if (",
            "                    old_block.__class__ == new_block.__class__",
            "                    and old_block is not None",
            "                    and old_block.key not in assigned_keys",
            "                    and deep_equal(",
            "                        getattr(old_block, \"value\", None),",
            "                        getattr(new_block, \"value\", None),",
            "                    )",
            "                ):",
            "                    new_block.key = old_block.key",
            "                else:",
            "                    new_block.key = f\"__{new_block._id}__\"",
            "",
            "            if isinstance(new_block, BlockContext):",
            "                if (",
            "                    isinstance(old_block, BlockContext)",
            "                    and old_block.__class__ == new_block.__class__",
            "                ):",
            "                    reassign_context_keys(old_block, new_block)",
            "                else:",
            "                    reassign_context_keys(None, new_block)",
            "",
            "    reassign_context_keys(old_blocks, new_blocks)",
            "",
            "",
            "def colab_check() -> bool:",
            "    \"\"\"",
            "    Check if interface is launching from Google Colab",
            "    :return is_colab (bool): True or False",
            "    \"\"\"",
            "    is_colab = False",
            "    try:  # Check if running interactively using ipython.",
            "        from IPython.core.getipython import get_ipython",
            "",
            "        from_ipynb = get_ipython()",
            "        if \"google.colab\" in str(from_ipynb):",
            "            is_colab = True",
            "    except (ImportError, NameError):",
            "        pass",
            "    return is_colab",
            "",
            "",
            "def kaggle_check() -> bool:",
            "    return bool(",
            "        os.environ.get(\"KAGGLE_KERNEL_RUN_TYPE\") or os.environ.get(\"GFOOTBALL_DATA_DIR\")",
            "    )",
            "",
            "",
            "def sagemaker_check() -> bool:",
            "    try:",
            "        import boto3  # type: ignore",
            "",
            "        client = boto3.client(\"sts\")",
            "        response = client.get_caller_identity()",
            "        return \"sagemaker\" in response[\"Arn\"].lower()",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def ipython_check() -> bool:",
            "    \"\"\"",
            "    Check if interface is launching from iPython (not colab)",
            "    :return is_ipython (bool): True or False",
            "    \"\"\"",
            "    is_ipython = False",
            "    try:  # Check if running interactively using ipython.",
            "        from IPython.core.getipython import get_ipython",
            "",
            "        if get_ipython() is not None:",
            "            is_ipython = True",
            "    except (ImportError, NameError):",
            "        pass",
            "    return is_ipython",
            "",
            "",
            "def get_space() -> str | None:",
            "    if os.getenv(\"SYSTEM\") == \"spaces\":",
            "        return os.getenv(\"SPACE_ID\")",
            "    return None",
            "",
            "",
            "def is_zero_gpu_space() -> bool:",
            "    return os.getenv(\"SPACES_ZERO_GPU\") == \"true\"",
            "",
            "",
            "def download_if_url(article: str) -> str:",
            "    try:",
            "        result = urllib.parse.urlparse(article)",
            "        is_url = all([result.scheme, result.netloc, result.path])",
            "        is_url = is_url and result.scheme in [\"http\", \"https\"]",
            "    except ValueError:",
            "        is_url = False",
            "",
            "    if not is_url:",
            "        return article",
            "",
            "    try:",
            "        response = httpx.get(article, timeout=3)",
            "        if response.status_code == httpx.codes.OK:  # pylint: disable=no-member",
            "            article = response.text",
            "    except (httpx.InvalidURL, httpx.RequestError, httpx.TimeoutException):",
            "        pass",
            "",
            "    return article",
            "",
            "",
            "def get_default_args(func: Callable) -> list[Any]:",
            "    signature = inspect.signature(func)",
            "    return [",
            "        v.default if v.default is not inspect.Parameter.empty else None",
            "        for v in signature.parameters.values()",
            "    ]",
            "",
            "",
            "def assert_configs_are_equivalent_besides_ids(",
            "    config1: dict, config2: dict, root_keys: tuple = (\"mode\",)",
            "):",
            "    \"\"\"Allows you to test if two different Blocks configs produce the same demo.",
            "",
            "    Parameters:",
            "    config1 (dict): nested dict with config from the first Blocks instance",
            "    config2 (dict): nested dict with config from the second Blocks instance",
            "    root_keys (Tuple): an interable consisting of which keys to test for equivalence at",
            "        the root level of the config. By default, only \"mode\" is tested,",
            "        so keys like \"version\" are ignored.",
            "    \"\"\"",
            "    config1 = copy.deepcopy(config1)",
            "    config2 = copy.deepcopy(config2)",
            "    config1 = json.loads(json.dumps(config1))  # convert tuples to lists",
            "    config2 = json.loads(json.dumps(config2))",
            "",
            "    for key in root_keys:",
            "        if config1[key] != config2[key]:",
            "            raise ValueError(f\"Configs have different: {key}\")",
            "",
            "    if len(config1[\"components\"]) != len(config2[\"components\"]):",
            "        raise ValueError(\"# of components are different\")",
            "",
            "    def assert_same_components(config1_id, config2_id):",
            "        c1 = list(filter(lambda c: c[\"id\"] == config1_id, config1[\"components\"]))",
            "        if len(c1) == 0:",
            "            raise ValueError(f\"Could not find component with id {config1_id}\")",
            "        c1 = c1[0]",
            "        c2 = list(filter(lambda c: c[\"id\"] == config2_id, config2[\"components\"]))",
            "        if len(c2) == 0:",
            "            raise ValueError(f\"Could not find component with id {config2_id}\")",
            "        c2 = c2[0]",
            "        c1 = copy.deepcopy(c1)",
            "        c1.pop(\"id\")",
            "        c2 = copy.deepcopy(c2)",
            "        c2.pop(\"id\")",
            "        if c1 != c2:",
            "            raise ValueError(f\"{c1} does not match {c2}\")",
            "",
            "    def same_children_recursive(children1, chidren2):",
            "        for child1, child2 in zip(children1, chidren2):",
            "            assert_same_components(child1[\"id\"], child2[\"id\"])",
            "            if \"children\" in child1 or \"children\" in child2:",
            "                same_children_recursive(child1[\"children\"], child2[\"children\"])",
            "",
            "    children1 = config1[\"layout\"][\"children\"]",
            "    children2 = config2[\"layout\"][\"children\"]",
            "    same_children_recursive(children1, children2)",
            "",
            "    for d1, d2 in zip(config1[\"dependencies\"], config2[\"dependencies\"]):",
            "        for t1, t2 in zip(d1.pop(\"targets\"), d2.pop(\"targets\")):",
            "            assert_same_components(t1[0], t2[0])",
            "        for i1, i2 in zip(d1.pop(\"inputs\"), d2.pop(\"inputs\")):",
            "            assert_same_components(i1, i2)",
            "        for o1, o2 in zip(d1.pop(\"outputs\"), d2.pop(\"outputs\")):",
            "            assert_same_components(o1, o2)",
            "",
            "        if d1 != d2:",
            "            raise ValueError(f\"{d1} does not match {d2}\")",
            "",
            "    return True",
            "",
            "",
            "def delete_none(_dict: dict, skip_value: bool = False) -> dict:",
            "    \"\"\"",
            "    Delete keys whose values are None from a dictionary",
            "    \"\"\"",
            "    for key, value in list(_dict.items()):",
            "        if skip_value and key == \"value\":",
            "            continue",
            "        elif value is None:",
            "            del _dict[key]",
            "    return _dict",
            "",
            "",
            "def resolve_singleton(_list: list[Any] | Any) -> Any:",
            "    if len(_list) == 1:",
            "        return _list[0]",
            "    else:",
            "        return _list",
            "",
            "",
            "def get_all_components() -> list[type[Component] | type[BlockContext]]:",
            "    import gradio as gr",
            "",
            "    classes_to_check = (",
            "        gr.components.Component.__subclasses__()",
            "        + gr.blocks.BlockContext.__subclasses__()  # type: ignore",
            "    )",
            "    subclasses = []",
            "",
            "    while classes_to_check:",
            "        subclass = classes_to_check.pop()",
            "        classes_to_check.extend(subclass.__subclasses__())",
            "        subclasses.append(subclass)",
            "    return [",
            "        c",
            "        for c in subclasses",
            "        if c.__name__",
            "        not in [\"ChatInterface\", \"Interface\", \"Blocks\", \"TabbedInterface\", \"NativePlot\"]",
            "    ]",
            "",
            "",
            "def core_gradio_components():",
            "    return [",
            "        class_",
            "        for class_ in get_all_components()",
            "        if class_.__module__.startswith(\"gradio.\")",
            "    ]",
            "",
            "",
            "def component_or_layout_class(cls_name: str) -> type[Component] | type[BlockContext]:",
            "    \"\"\"",
            "    Returns the component, template, or layout class with the given class name, or",
            "    raises a ValueError if not found.",
            "",
            "    Parameters:",
            "    cls_name (str): lower-case string class name of a component",
            "    Returns:",
            "    cls: the component class",
            "    \"\"\"",
            "    import gradio.components as components_module",
            "    from gradio.components import Component",
            "",
            "    components = {c.__name__.lower(): c for c in get_all_components()}",
            "    # add aliases such as 'text'",
            "    for name, cls in components_module.__dict__.items():",
            "        if isinstance(cls, type) and issubclass(cls, Component):",
            "            components[name.lower()] = cls",
            "",
            "    if cls_name.replace(\"_\", \"\") in components:",
            "        return components[cls_name.replace(\"_\", \"\")]",
            "",
            "    raise ValueError(",
            "        f\"No such component or layout: {cls_name}. \"",
            "        \"It is possible it is a custom component, \"",
            "        \"in which case make sure it is installed and imported in your python session.\"",
            "    )",
            "",
            "",
            "def run_coro_in_background(func: Callable, *args, **kwargs):",
            "    \"\"\"",
            "    Runs coroutines in background.",
            "",
            "    Warning, be careful to not use this function in other than FastAPI scope, because the event_loop has not started yet.",
            "    You can use it in any scope reached by FastAPI app.",
            "",
            "    correct scope examples: endpoints in routes, Blocks.process_api",
            "    incorrect scope examples: Blocks.launch",
            "",
            "    Use startup_events in routes.py if you need to run a coro in background in Blocks.launch().",
            "",
            "",
            "    Example:",
            "        utils.run_coro_in_background(fn, *args, **kwargs)",
            "",
            "    Args:",
            "        func:",
            "        *args:",
            "        **kwargs:",
            "",
            "    Returns:",
            "",
            "    \"\"\"",
            "    event_loop = asyncio.get_event_loop()",
            "    return event_loop.create_task(func(*args, **kwargs))",
            "",
            "",
            "def run_sync_iterator_async(iterator):",
            "    \"\"\"Helper for yielding StopAsyncIteration from sync iterators.\"\"\"",
            "    try:",
            "        return next(iterator)",
            "    except StopIteration:",
            "        # raise a ValueError here because co-routines can't raise StopIteration themselves",
            "        raise StopAsyncIteration() from None",
            "",
            "",
            "class SyncToAsyncIterator:",
            "    \"\"\"Treat a synchronous iterator as async one.\"\"\"",
            "",
            "    def __init__(self, iterator, limiter) -> None:",
            "        self.iterator = iterator",
            "        self.limiter = limiter",
            "",
            "    def __aiter__(self):",
            "        return self",
            "",
            "    async def __anext__(self):",
            "        return await anyio.to_thread.run_sync(",
            "            run_sync_iterator_async, self.iterator, limiter=self.limiter",
            "        )",
            "",
            "",
            "async def async_iteration(iterator):",
            "    # anext not introduced until 3.10 :(",
            "    return await iterator.__anext__()",
            "",
            "",
            "@contextmanager",
            "def set_directory(path: Path | str):",
            "    \"\"\"Context manager that sets the working directory to the given path.\"\"\"",
            "    origin = Path().absolute()",
            "    try:",
            "        os.chdir(path)",
            "        yield",
            "    finally:",
            "        os.chdir(origin)",
            "",
            "",
            "@contextmanager",
            "def no_raise_exception():",
            "    \"\"\"Context manager that suppresses exceptions.\"\"\"",
            "    try:",
            "        yield",
            "    except Exception:",
            "        pass",
            "",
            "",
            "def sanitize_value_for_csv(value: str | float) -> str | float:",
            "    \"\"\"",
            "    Sanitizes a value that is being written to a CSV file to prevent CSV injection attacks.",
            "    Reference: https://owasp.org/www-community/attacks/CSV_Injection",
            "    \"\"\"",
            "    if isinstance(value, (float, int)):",
            "        return value",
            "    unsafe_prefixes = [\"=\", \"+\", \"-\", \"@\", \"\\t\", \"\\n\"]",
            "    unsafe_sequences = [\",=\", \",+\", \",-\", \",@\", \",\\t\", \",\\n\"]",
            "    if any(value.startswith(prefix) for prefix in unsafe_prefixes) or any(",
            "        sequence in value for sequence in unsafe_sequences",
            "    ):",
            "        value = f\"'{value}\"",
            "    return value",
            "",
            "",
            "def sanitize_list_for_csv(values: list[Any]) -> list[Any]:",
            "    \"\"\"",
            "    Sanitizes a list of values (or a list of list of values) that is being written to a",
            "    CSV file to prevent CSV injection attacks.",
            "    \"\"\"",
            "    sanitized_values = []",
            "    for value in values:",
            "        if isinstance(value, list):",
            "            sanitized_value = [sanitize_value_for_csv(v) for v in value]",
            "            sanitized_values.append(sanitized_value)",
            "        else:",
            "            sanitized_value = sanitize_value_for_csv(value)",
            "            sanitized_values.append(sanitized_value)",
            "    return sanitized_values",
            "",
            "",
            "def append_unique_suffix(name: str, list_of_names: list[str]):",
            "    \"\"\"Appends a numerical suffix to `name` so that it does not appear in `list_of_names`.\"\"\"",
            "    set_of_names: set[str] = set(list_of_names)  # for O(1) lookup",
            "    if name not in set_of_names:",
            "        return name",
            "    else:",
            "        suffix_counter = 1",
            "        new_name = f\"{name}_{suffix_counter}\"",
            "        while new_name in set_of_names:",
            "            suffix_counter += 1",
            "            new_name = f\"{name}_{suffix_counter}\"",
            "        return new_name",
            "",
            "",
            "def validate_url(possible_url: str) -> bool:",
            "    headers = {\"User-Agent\": \"gradio (https://gradio.app/; gradio-team@huggingface.co)\"}",
            "    try:",
            "        head_request = httpx.head(possible_url, headers=headers, follow_redirects=True)",
            "        # some URLs, such as AWS S3 presigned URLs, return a 405 or a 403 for HEAD requests",
            "        if head_request.status_code in (403, 405):",
            "            return httpx.get(",
            "                possible_url, headers=headers, follow_redirects=True",
            "            ).is_success",
            "        return head_request.is_success",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def is_prop_update(val):",
            "    return isinstance(val, dict) and \"update\" in val.get(\"__type__\", \"\")",
            "",
            "",
            "def function_wrapper(",
            "    f: Callable,",
            "    before_fn: Callable | None = None,",
            "    before_args: Iterable | None = None,",
            "    after_fn: Callable | None = None,",
            "    after_args: Iterable | None = None,",
            "):",
            "    before_args = [] if before_args is None else before_args",
            "    after_args = [] if after_args is None else after_args",
            "    if inspect.isasyncgenfunction(f):",
            "",
            "        @functools.wraps(f)",
            "        async def asyncgen_wrapper(*args, **kwargs):",
            "            iterator = f(*args, **kwargs)",
            "            while True:",
            "                if before_fn:",
            "                    before_fn(*before_args)",
            "                try:",
            "                    response = await iterator.__anext__()",
            "                except StopAsyncIteration:",
            "                    if after_fn:",
            "                        after_fn(*after_args)",
            "                    break",
            "                if after_fn:",
            "                    after_fn(*after_args)",
            "                yield response",
            "",
            "        return asyncgen_wrapper",
            "",
            "    elif asyncio.iscoroutinefunction(f):",
            "",
            "        @functools.wraps(f)",
            "        async def async_wrapper(*args, **kwargs):",
            "            if before_fn:",
            "                before_fn(*before_args)",
            "            response = await f(*args, **kwargs)",
            "            if after_fn:",
            "                after_fn(*after_args)",
            "            return response",
            "",
            "        return async_wrapper",
            "",
            "    elif inspect.isgeneratorfunction(f):",
            "",
            "        @functools.wraps(f)",
            "        def gen_wrapper(*args, **kwargs):",
            "            iterator = f(*args, **kwargs)",
            "            while True:",
            "                if before_fn:",
            "                    before_fn(*before_args)",
            "                try:",
            "                    response = next(iterator)",
            "                except StopIteration:",
            "                    if after_fn:",
            "                        after_fn(*after_args)",
            "                    break",
            "                if after_fn:",
            "                    after_fn(*after_args)",
            "                yield response",
            "",
            "        return gen_wrapper",
            "",
            "    else:",
            "",
            "        @functools.wraps(f)",
            "        def wrapper(*args, **kwargs):",
            "            if before_fn:",
            "                before_fn(*before_args)",
            "            response = f(*args, **kwargs)",
            "            if after_fn:",
            "                after_fn(*after_args)",
            "            return response",
            "",
            "        return wrapper",
            "",
            "",
            "def get_function_with_locals(",
            "    fn: Callable,",
            "    blocks: Blocks,",
            "    event_id: str | None,",
            "    in_event_listener: bool,",
            "    request: Request | None,",
            "    state: SessionState | None,",
            "):",
            "    def before_fn(blocks, event_id):",
            "        from gradio.context import LocalContext",
            "",
            "        LocalContext.blocks.set(blocks)",
            "        LocalContext.in_event_listener.set(in_event_listener)",
            "        LocalContext.event_id.set(event_id)",
            "        LocalContext.request.set(request)",
            "        if state:",
            "            LocalContext.blocks_config.set(state.blocks_config)",
            "",
            "    def after_fn():",
            "        from gradio.context import LocalContext",
            "",
            "        LocalContext.in_event_listener.set(False)",
            "        LocalContext.request.set(None)",
            "        LocalContext.blocks_config.set(None)",
            "",
            "    return function_wrapper(",
            "        fn,",
            "        before_fn=before_fn,",
            "        before_args=(blocks, event_id),",
            "        after_fn=after_fn,",
            "    )",
            "",
            "",
            "async def cancel_tasks(task_ids: set[str]) -> list[str]:",
            "    tasks = [(task, task.get_name()) for task in asyncio.all_tasks()]",
            "    event_ids: list[str] = []",
            "    matching_tasks = []",
            "    for task, name in tasks:",
            "        if \"<gradio-sep>\" not in name:",
            "            continue",
            "        task_id, event_id = name.split(\"<gradio-sep>\")",
            "        if task_id in task_ids:",
            "            matching_tasks.append(task)",
            "            event_ids.append(event_id)",
            "            task.cancel()",
            "    await asyncio.gather(*matching_tasks, return_exceptions=True)",
            "    return event_ids",
            "",
            "",
            "def set_task_name(task, session_hash: str, fn_index: int, event_id: str, batch: bool):",
            "    if not batch:",
            "        task.set_name(f\"{session_hash}_{fn_index}<gradio-sep>{event_id}\")",
            "",
            "",
            "def get_cancelled_fn_indices(",
            "    dependencies: list[dict[str, Any]],",
            ") -> list[int]:",
            "    fn_indices = []",
            "    for dep in dependencies:",
            "        root_block = get_blocks_context()",
            "        if root_block:",
            "            fn_index = next(",
            "                i for i, d in root_block.fns.items() if d.get_config() == dep",
            "            )",
            "            fn_indices.append(fn_index)",
            "",
            "    return fn_indices",
            "",
            "",
            "def get_type_hints(fn):",
            "    # Importing gradio with the canonical abbreviation. Used in typing._eval_type.",
            "    import gradio as gr  # noqa: F401",
            "    from gradio import OAuthProfile, OAuthToken, Request  # noqa: F401",
            "",
            "    if inspect.isfunction(fn) or inspect.ismethod(fn):",
            "        pass",
            "    elif callable(fn):",
            "        fn = fn.__call__",
            "    else:",
            "        return {}",
            "",
            "    try:",
            "        return typing.get_type_hints(fn)",
            "    except TypeError:",
            "        # On Python 3.9 or earlier, get_type_hints throws a TypeError if the function",
            "        # has a type annotation that include \"|\". We resort to parsing the signature",
            "        # manually using inspect.signature.",
            "        type_hints = {}",
            "        sig = inspect.signature(fn)",
            "        for name, param in sig.parameters.items():",
            "            if param.annotation is inspect.Parameter.empty:",
            "                continue",
            "            if param.annotation == \"gr.OAuthProfile | None\":",
            "                # Special case: we want to inject the OAuthProfile value even on Python 3.9",
            "                type_hints[name] = Optional[OAuthProfile]",
            "            if param.annotation == \"gr.OAuthToken | None\":",
            "                # Special case: we want to inject the OAuthToken value even on Python 3.9",
            "                type_hints[name] = Optional[OAuthToken]",
            "            if \"|\" in str(param.annotation):",
            "                continue",
            "            # To convert the string annotation to a class, we use the",
            "            # internal typing._eval_type function. This is not ideal, but",
            "            # it's the only way to do it without eval-ing the string.",
            "            # Since the API is internal, it may change in the future.",
            "            try:",
            "                type_hints[name] = typing._eval_type(  # type: ignore",
            "                    typing.ForwardRef(param.annotation), globals(), locals()",
            "                )",
            "            except (NameError, TypeError):",
            "                pass",
            "        return type_hints",
            "",
            "",
            "def is_special_typed_parameter(name, parameter_types):",
            "    from gradio.helpers import EventData",
            "    from gradio.oauth import OAuthProfile, OAuthToken",
            "    from gradio.routes import Request",
            "",
            "    \"\"\"Checks if parameter has a type hint designating it as a gr.Request, gr.EventData, gr.OAuthProfile or gr.OAuthToken.\"\"\"",
            "    hint = parameter_types.get(name)",
            "    if not hint:",
            "        return False",
            "    is_request = hint == Request",
            "    is_oauth_arg = hint in (",
            "        OAuthProfile,",
            "        Optional[OAuthProfile],",
            "        OAuthToken,",
            "        Optional[OAuthToken],",
            "    )",
            "    is_event_data = inspect.isclass(hint) and issubclass(hint, EventData)",
            "    return is_request or is_event_data or is_oauth_arg",
            "",
            "",
            "def check_function_inputs_match(fn: Callable, inputs: Sequence, inputs_as_dict: bool):",
            "    \"\"\"",
            "    Checks if the input component set matches the function",
            "    Returns: None if valid or if the function does not have a signature (e.g. is a built in),",
            "    or a string error message if mismatch",
            "    \"\"\"",
            "    try:",
            "        signature = inspect.signature(fn)",
            "    except ValueError:",
            "        return None",
            "    parameter_types = get_type_hints(fn)",
            "    min_args = 0",
            "    max_args = 0",
            "    infinity = -1",
            "    for name, param in signature.parameters.items():",
            "        has_default = param.default != param.empty",
            "        if param.kind in [param.POSITIONAL_ONLY, param.POSITIONAL_OR_KEYWORD]:",
            "            if not is_special_typed_parameter(name, parameter_types):",
            "                if not has_default:",
            "                    min_args += 1",
            "                max_args += 1",
            "        elif param.kind == param.VAR_POSITIONAL:",
            "            max_args = infinity",
            "        elif param.kind == param.KEYWORD_ONLY and not has_default:",
            "            return f\"Keyword-only args must have default values for function {fn}\"",
            "    arg_count = 1 if inputs_as_dict else len(inputs)",
            "    if min_args == max_args and max_args != arg_count:",
            "        warnings.warn(",
            "            f\"Expected {max_args} arguments for function {fn}, received {arg_count}.\"",
            "        )",
            "    if arg_count < min_args:",
            "        warnings.warn(",
            "            f\"Expected at least {min_args} arguments for function {fn}, received {arg_count}.\"",
            "        )",
            "    if max_args != infinity and arg_count > max_args:",
            "        warnings.warn(",
            "            f\"Expected maximum {max_args} arguments for function {fn}, received {arg_count}.\"",
            "        )",
            "",
            "",
            "class TupleNoPrint(tuple):",
            "    # To remove printing function return in notebook",
            "    def __repr__(self):",
            "        return \"\"",
            "",
            "    def __str__(self):",
            "        return \"\"",
            "",
            "",
            "class MatplotlibBackendMananger:",
            "    def __enter__(self):",
            "        import matplotlib",
            "",
            "        self._original_backend = matplotlib.get_backend()",
            "        matplotlib.use(\"agg\")",
            "",
            "    def __exit__(self, exc_type, exc_val, exc_tb):",
            "        import matplotlib",
            "",
            "        matplotlib.use(self._original_backend)",
            "",
            "",
            "def tex2svg(formula, *_args):",
            "    with MatplotlibBackendMananger():",
            "        import matplotlib.pyplot as plt",
            "",
            "        fontsize = 20",
            "        dpi = 300",
            "        plt.rc(\"mathtext\", fontset=\"cm\")",
            "        fig = plt.figure(figsize=(0.01, 0.01))",
            "        fig.text(0, 0, rf\"${formula}$\", fontsize=fontsize)",
            "        output = BytesIO()",
            "        fig.savefig(  # type: ignore",
            "            output,",
            "            dpi=dpi,",
            "            transparent=True,",
            "            format=\"svg\",",
            "            bbox_inches=\"tight\",",
            "            pad_inches=0.0,",
            "        )",
            "        plt.close(fig)",
            "        output.seek(0)",
            "        xml_code = output.read().decode(\"utf-8\")",
            "        svg_start = xml_code.index(\"<svg \")",
            "        svg_code = xml_code[svg_start:]",
            "        svg_code = re.sub(r\"<metadata>.*<\\/metadata>\", \"\", svg_code, flags=re.DOTALL)",
            "        svg_code = re.sub(r' width=\"[^\"]+\"', \"\", svg_code)",
            "        height_match = re.search(r'height=\"([\\d.]+)pt\"', svg_code)",
            "        if height_match:",
            "            height = float(height_match.group(1))",
            "            new_height = height / fontsize  # conversion from pt to em",
            "            svg_code = re.sub(",
            "                r'height=\"[\\d.]+pt\"', f'height=\"{new_height}em\"', svg_code",
            "            )",
            "        copy_code = f\"<span style='font-size: 0px'>{formula}</span>\"",
            "    return f\"{copy_code}{svg_code}\"",
            "",
            "",
            "def abspath(path: str | Path) -> Path:",
            "    \"\"\"Returns absolute path of a str or Path path, but does not resolve symlinks.\"\"\"",
            "    path = Path(path)",
            "",
            "    if path.is_absolute():",
            "        return path",
            "",
            "    # recursively check if there is a symlink within the path",
            "    is_symlink = path.is_symlink() or any(",
            "        parent.is_symlink() for parent in path.parents",
            "    )",
            "",
            "    if is_symlink or path == path.resolve():  # in case path couldn't be resolved",
            "        return Path.cwd() / path",
            "    else:",
            "        return path.resolve()",
            "",
            "",
            "def is_in_or_equal(path_1: str | Path, path_2: str | Path):",
            "    \"\"\"",
            "    True if path_1 is a descendant (i.e. located within) path_2 or if the paths are the",
            "    same, returns False otherwise.",
            "    Parameters:",
            "        path_1: str or Path (to file or directory)",
            "        path_2: str or Path (to file or directory)",
            "    \"\"\"",
            "    path_1, path_2 = abspath(path_1), abspath(path_2)",
            "    try:",
            "        relative_path = path_1.relative_to(path_2)",
            "        if str(relative_path) == \".\":",
            "            return True",
            "        relative_path = path_1.parent.relative_to(path_2)",
            "        return \"..\" not in str(relative_path)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "@document()",
            "def set_static_paths(paths: list[str | Path]) -> None:",
            "    \"\"\"",
            "    Set the static paths to be served by the gradio app.",
            "",
            "    Static files are not moved to the gradio cache and are served directly from the file system.",
            "    This function is useful when you want to serve files that you know will not be modified during the lifetime of the gradio app (like files used in gr.Examples).",
            "    By setting static paths, your app will launch faster and it will consume less disk space.",
            "    Calling this function will set the static paths for all gradio applications defined in the same interpreter session until it is called again or the session ends.",
            "    To clear out the static paths, call this function with an empty list.",
            "",
            "    Parameters:",
            "        paths: List of filepaths or directory names to be served by the gradio app. If it is a directory name, ALL files located within that directory will be considered static and not moved to the gradio cache. This also means that ALL files in that directory will be accessible over the network.",
            "    Example:",
            "        import gradio as gr",
            "",
            "        # Paths can be a list of strings or pathlib.Path objects",
            "        # corresponding to filenames or directories.",
            "        gr.set_static_paths(paths=[\"test/test_files/\"])",
            "",
            "        # The example files and the default value of the input",
            "        # will not be copied to the gradio cache and will be served directly.",
            "        demo = gr.Interface(",
            "            lambda s: s.rotate(45),",
            "            gr.Image(value=\"test/test_files/cheetah1.jpg\", type=\"pil\"),",
            "            gr.Image(),",
            "            examples=[\"test/test_files/bus.png\"],",
            "        )",
            "",
            "        demo.launch()",
            "    \"\"\"",
            "    from gradio.data_classes import _StaticFiles",
            "",
            "    _StaticFiles.all_paths.extend([Path(p).resolve() for p in paths])",
            "",
            "",
            "def is_static_file(file_path: Any):",
            "    \"\"\"Returns True if the file is a static file (and not moved to cache)\"\"\"",
            "    from gradio.data_classes import _StaticFiles",
            "",
            "    return _is_static_file(file_path, _StaticFiles.all_paths)",
            "",
            "",
            "def _is_static_file(file_path: Any, static_files: list[Path]) -> bool:",
            "    \"\"\"",
            "    Returns True if the file is a static file (i.e. is is in the static files list).",
            "    \"\"\"",
            "    if not isinstance(file_path, (str, Path, FileData)):",
            "        return False",
            "    if isinstance(file_path, FileData):",
            "        file_path = file_path.path",
            "    if isinstance(file_path, str):",
            "        file_path = Path(file_path)",
            "        if not file_path.exists():",
            "            return False",
            "    return any(is_in_or_equal(file_path, static_file) for static_file in static_files)",
            "",
            "",
            "HTML_TAG_RE = re.compile(\"<.*?>\")",
            "",
            "",
            "def remove_html_tags(raw_html: str | None) -> str:",
            "    return re.sub(HTML_TAG_RE, \"\", raw_html or \"\")",
            "",
            "",
            "def find_user_stack_level() -> int:",
            "    \"\"\"",
            "    Find the first stack frame not inside Gradio.",
            "    \"\"\"",
            "    frame = inspect.currentframe()",
            "    n = 0",
            "    while frame:",
            "        fname = inspect.getfile(frame)",
            "        if \"/gradio/\" not in fname.replace(os.sep, \"/\"):",
            "            break",
            "        frame = frame.f_back",
            "        n += 1",
            "    return n",
            "",
            "",
            "class NamedString(str):",
            "    \"\"\"",
            "    Subclass of str that includes a .name attribute equal to the value of the string itself. This class is used when returning",
            "    a value from the `.preprocess()` methods of the File and UploadButton components. Before Gradio 4.0, these methods returned a file",
            "    object which was then converted to a string filepath using the `.name` attribute. In Gradio 4.0, these methods now return a str",
            "    filepath directly, but to maintain backwards compatibility, we use this class instead of a regular str.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args):",
            "        super().__init__()",
            "        self.name = str(self) if args else \"\"",
            "",
            "",
            "def default_input_labels():",
            "    \"\"\"",
            "    A generator that provides default input labels for components when the user's function",
            "    does not have named parameters. The labels are of the form \"input 0\", \"input 1\", etc.",
            "    \"\"\"",
            "    n = 0",
            "    while True:",
            "        yield f\"input {n}\"",
            "        n += 1",
            "",
            "",
            "def get_extension_from_file_path_or_url(file_path_or_url: str) -> str:",
            "    \"\"\"",
            "    Returns the file extension (without the dot) from a file path or URL. If the file path or URL does not have a file extension, returns an empty string.",
            "    For example, \"https://example.com/avatar/xxxx.mp4?se=2023-11-16T06:51:23Z&sp=r\" would return \"mp4\".",
            "    \"\"\"",
            "    parsed_url = urllib.parse.urlparse(file_path_or_url)",
            "    file_extension = os.path.splitext(os.path.basename(parsed_url.path))[1]",
            "    return file_extension[1:] if file_extension else \"\"",
            "",
            "",
            "K = TypeVar(\"K\")",
            "V = TypeVar(\"V\")",
            "",
            "",
            "class LRUCache(OrderedDict, Generic[K, V]):",
            "    def __init__(self, max_size: int = 100):",
            "        super().__init__()",
            "        self.max_size: int = max_size",
            "",
            "    def __setitem__(self, key: K, value: V) -> None:",
            "        if key in self:",
            "            self.move_to_end(key)",
            "        elif len(self) >= self.max_size:",
            "            self.popitem(last=False)",
            "        super().__setitem__(key, value)",
            "",
            "    def __getitem__(self, key: K) -> V:",
            "        return super().__getitem__(key)",
            "",
            "",
            "def get_cache_folder() -> Path:",
            "    return Path(os.environ.get(\"GRADIO_EXAMPLES_CACHE\", \"gradio_cached_examples\"))",
            "",
            "",
            "def diff(old, new):",
            "    def compare_objects(obj1, obj2, path=None):",
            "        if path is None:",
            "            path = []",
            "        edits = []",
            "",
            "        if obj1 == obj2:",
            "            return edits",
            "",
            "        if type(obj1) != type(obj2):",
            "            edits.append((\"replace\", path, obj2))",
            "            return edits",
            "",
            "        if isinstance(obj1, str) and obj2.startswith(obj1):",
            "            edits.append((\"append\", path, obj2[len(obj1) :]))",
            "            return edits",
            "",
            "        if isinstance(obj1, list):",
            "            common_length = min(len(obj1), len(obj2))",
            "            for i in range(common_length):",
            "                edits.extend(compare_objects(obj1[i], obj2[i], path + [i]))",
            "            for i in range(common_length, len(obj1)):",
            "                edits.append((\"delete\", path + [i], None))",
            "            for i in range(common_length, len(obj2)):",
            "                edits.append((\"add\", path + [i], obj2[i]))",
            "            return edits",
            "",
            "        if isinstance(obj1, dict):",
            "            for key in obj1:",
            "                if key in obj2:",
            "                    edits.extend(compare_objects(obj1[key], obj2[key], path + [key]))",
            "                else:",
            "                    edits.append((\"delete\", path + [key], None))",
            "            for key in obj2:",
            "                if key not in obj1:",
            "                    edits.append((\"add\", path + [key], obj2[key]))",
            "            return edits",
            "",
            "        edits.append((\"replace\", path, obj2))",
            "        return edits",
            "",
            "    return compare_objects(old, new)",
            "",
            "",
            "def get_upload_folder() -> str:",
            "    return os.environ.get(\"GRADIO_TEMP_DIR\") or str(",
            "        (Path(tempfile.gettempdir()) / \"gradio\").resolve()",
            "    )",
            "",
            "",
            "def get_function_params(func: Callable) -> list[tuple[str, bool, Any]]:",
            "    \"\"\"",
            "    Gets the parameters of a function as a list of tuples of the form (name, has_default, default_value).",
            "    Excludes *args and **kwargs, as well as args that are Gradio-specific, such as gr.Request, gr.EventData, gr.OAuthProfile, and gr.OAuthToken.",
            "    \"\"\"",
            "    params_info = []",
            "    signature = inspect.signature(func)",
            "    type_hints = get_type_hints(func)",
            "    for name, parameter in signature.parameters.items():",
            "        if parameter.kind in (",
            "            inspect.Parameter.VAR_POSITIONAL,",
            "            inspect.Parameter.VAR_KEYWORD,",
            "        ):",
            "            break",
            "        if is_special_typed_parameter(name, type_hints):",
            "            continue",
            "        if parameter.default is inspect.Parameter.empty:",
            "            params_info.append((name, False, None))",
            "        else:",
            "            params_info.append((name, True, parameter.default))",
            "    return params_info",
            "",
            "",
            "def simplify_file_data_in_str(s):",
            "    \"\"\"",
            "    If a FileData dictionary has been dumped as part of a string, this function will replace the dict with just the str filepath",
            "    \"\"\"",
            "    try:",
            "        payload = json.loads(s)",
            "    except json.JSONDecodeError:",
            "        return s",
            "    payload = client_utils.traverse(",
            "        payload, lambda x: x[\"path\"], client_utils.is_file_obj_with_meta",
            "    )",
            "    if isinstance(payload, str):",
            "        return payload",
            "    return json.dumps(payload)",
            "",
            "",
            "def sync_fn_to_generator(fn):",
            "    def wrapped(*args, **kwargs):",
            "        yield fn(*args, **kwargs)",
            "",
            "    return wrapped",
            "",
            "",
            "def async_fn_to_generator(fn):",
            "    async def wrapped(*args, **kwargs):",
            "        yield await fn(*args, **kwargs)",
            "",
            "    return wrapped",
            "",
            "",
            "def async_lambda(f: Callable) -> Callable:",
            "    \"\"\"Turn a function into an async function.",
            "    Useful for internal event handlers defined as lambda functions used in the codebase",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    async def function_wrapper(*args, **kwargs):",
            "        return f(*args, **kwargs)",
            "",
            "    return function_wrapper",
            "",
            "",
            "class FileSize:",
            "    B = 1",
            "    KB = 1024 * B",
            "    MB = 1024 * KB",
            "    GB = 1024 * MB",
            "    TB = 1024 * GB",
            "",
            "",
            "def _parse_file_size(size: str | int | None) -> int | None:",
            "    if isinstance(size, int) or size is None:",
            "        return size",
            "",
            "    size = size.replace(\" \", \"\")",
            "",
            "    last_digit_index = next(",
            "        (i for i, c in enumerate(size) if not c.isdigit()), len(size)",
            "    )",
            "    size_int, unit = int(size[:last_digit_index]), size[last_digit_index:].upper()",
            "    multiple = getattr(FileSize, unit, None)",
            "    if not multiple:",
            "        raise ValueError(f\"Invalid file size unit: {unit}\")",
            "    return multiple * size_int",
            "",
            "",
            "def connect_heartbeat(config: BlocksConfigDict, blocks) -> bool:",
            "    \"\"\"",
            "    Determines whether a heartbeat is required for a given config.",
            "    \"\"\"",
            "    from gradio.components import State",
            "",
            "    any_state = any(isinstance(block, State) for block in blocks)",
            "    any_unload = False",
            "",
            "    if \"dependencies\" not in config:",
            "        raise ValueError(",
            "            \"Dependencies not found in config. Cannot determine whether\"",
            "            \"heartbeat is required.\"",
            "        )",
            "",
            "    for dep in config[\"dependencies\"]:",
            "        for target in dep[\"targets\"]:",
            "            if isinstance(target, (list, tuple)) and len(target) == 2:",
            "                any_unload = target[1] == \"unload\"",
            "                if any_unload:",
            "                    break",
            "    return any_state or any_unload",
            "",
            "",
            "def deep_hash(obj):",
            "    \"\"\"Compute a hash for a deeply nested data structure.\"\"\"",
            "    hasher = hashlib.sha256()",
            "    if isinstance(obj, (int, float, str, bytes)):",
            "        items = obj",
            "    elif isinstance(obj, dict):",
            "        items = tuple(",
            "            [",
            "                (k, deep_hash(v))",
            "                for k, v in sorted(obj.items(), key=lambda x: hash(x[0]))",
            "            ]",
            "        )",
            "    elif isinstance(obj, (list, tuple)):",
            "        items = tuple(deep_hash(x) for x in obj)",
            "    elif isinstance(obj, set):",
            "        items = tuple(deep_hash(x) for x in sorted(obj, key=hash))",
            "    else:",
            "        items = str(id(obj)).encode(\"utf-8\")",
            "    hasher.update(repr(items).encode(\"utf-8\"))",
            "    return hasher.hexdigest()",
            "",
            "",
            "def error_payload(",
            "    error: BaseException | None, show_error: bool",
            ") -> dict[str, bool | str | float | None]:",
            "    content: dict[str, bool | str | float | None] = {\"error\": None}",
            "    show_error = show_error or isinstance(error, Error)",
            "    if show_error:",
            "        content[\"error\"] = str(error)",
            "    if isinstance(error, Error):",
            "        content[\"duration\"] = error.duration",
            "        content[\"visible\"] = error.visible",
            "    return content",
            "",
            "",
            "class UnhashableKeyDict(MutableMapping):",
            "    \"\"\"",
            "    Essentially a list of key-value tuples that allows for keys that are not hashable,",
            "    but acts like a dictionary for convenience.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.data = []",
            "",
            "    def __getitem__(self, key):",
            "        for k, v in self.data:",
            "            if deep_equal(k, key):",
            "                return v",
            "        raise KeyError(key)",
            "",
            "    def __setitem__(self, key, value):",
            "        for i, (k, _) in enumerate(self.data):",
            "            if deep_equal(k, key):",
            "                self.data[i] = (key, value)",
            "                return",
            "        self.data.append((key, value))",
            "",
            "    def __delitem__(self, key):",
            "        for i, (k, _) in enumerate(self.data):",
            "            if deep_equal(k, key):",
            "                del self.data[i]",
            "                return",
            "        raise KeyError(key)",
            "",
            "    def __iter__(self):",
            "        return (k for k, _ in self.data)",
            "",
            "    def __len__(self):",
            "        return len(self.data)",
            "",
            "    def as_list(self):",
            "        return [v for _, v in self.data]"
        ],
        "afterPatchFile": [
            "\"\"\"Handy utility functions.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import ast",
            "import asyncio",
            "import copy",
            "import functools",
            "import hashlib",
            "import importlib",
            "import importlib.util",
            "import inspect",
            "import json",
            "import json.decoder",
            "import os",
            "import pkgutil",
            "import re",
            "import sys",
            "import tempfile",
            "import threading",
            "import time",
            "import traceback",
            "import typing",
            "import urllib.parse",
            "import uuid",
            "import warnings",
            "from abc import ABC, abstractmethod",
            "from collections import OrderedDict",
            "from collections.abc import MutableMapping",
            "from contextlib import contextmanager",
            "from functools import wraps",
            "from io import BytesIO",
            "from pathlib import Path",
            "from types import ModuleType",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Generic,",
            "    Iterable,",
            "    Iterator,",
            "    Literal,",
            "    Optional,",
            "    Sequence,",
            "    TypeVar,",
            ")",
            "",
            "import anyio",
            "import gradio_client.utils as client_utils",
            "import httpx",
            "import orjson",
            "from gradio_client.documentation import document",
            "from typing_extensions import ParamSpec",
            "",
            "import gradio",
            "from gradio.context import get_blocks_context",
            "from gradio.data_classes import BlocksConfigDict, FileData",
            "from gradio.exceptions import Error",
            "",
            "if TYPE_CHECKING:  # Only import for type checking (is False at runtime).",
            "    from gradio.blocks import BlockContext, Blocks",
            "    from gradio.components import Component",
            "    from gradio.routes import App, Request",
            "    from gradio.state_holder import SessionState",
            "",
            "P = ParamSpec(\"P\")",
            "T = TypeVar(\"T\")",
            "",
            "",
            "def get_package_version() -> str:",
            "    try:",
            "        package_json_data = (",
            "            pkgutil.get_data(__name__, \"package.json\").decode(\"utf-8\").strip()  # type: ignore",
            "        )",
            "        package_data = json.loads(package_json_data)",
            "        version = package_data.get(\"version\", \"\")",
            "        return version",
            "    except Exception:",
            "        return \"\"",
            "",
            "",
            "def safe_get_lock() -> asyncio.Lock:",
            "    \"\"\"Get asyncio.Lock() without fear of getting an Exception.",
            "",
            "    Needed because in reload mode we import the Blocks object outside",
            "    the main thread.",
            "    \"\"\"",
            "    try:",
            "        asyncio.get_event_loop()",
            "        return asyncio.Lock()",
            "    except RuntimeError:",
            "        return None  # type: ignore",
            "",
            "",
            "def safe_get_stop_event() -> asyncio.Event:",
            "    try:",
            "        asyncio.get_event_loop()",
            "        return asyncio.Event()",
            "    except RuntimeError:",
            "        return None  # type: ignore",
            "",
            "",
            "class BaseReloader(ABC):",
            "    @property",
            "    @abstractmethod",
            "    def running_app(self) -> App:",
            "        pass",
            "",
            "    def swap_blocks(self, demo: Blocks):",
            "        assert self.running_app.blocks  # noqa: S101",
            "        # Copy over the blocks to get new components and events but",
            "        # not a new queue",
            "        demo._queue = self.running_app.blocks._queue",
            "        demo.max_file_size = self.running_app.blocks.max_file_size",
            "        self.running_app.state_holder.reset(demo)",
            "        self.running_app.blocks = demo",
            "",
            "",
            "class SourceFileReloader(BaseReloader):",
            "    def __init__(",
            "        self,",
            "        app: App,",
            "        watch_dirs: list[str],",
            "        watch_module_name: str,",
            "        demo_file: str,",
            "        stop_event: threading.Event,",
            "        demo_name: str = \"demo\",",
            "    ) -> None:",
            "        super().__init__()",
            "        self.app = app",
            "        self.watch_dirs = watch_dirs",
            "        self.watch_module_name = watch_module_name",
            "        self.stop_event = stop_event",
            "        self.demo_name = demo_name",
            "        self.demo_file = Path(demo_file)",
            "",
            "    @property",
            "    def running_app(self) -> App:",
            "        return self.app",
            "",
            "    def should_watch(self) -> bool:",
            "        return not self.stop_event.is_set()",
            "",
            "    def stop(self) -> None:",
            "        self.stop_event.set()",
            "",
            "    def alert_change(self, change_type: Literal[\"reload\", \"error\"] = \"reload\"):",
            "        self.app.change_type = change_type",
            "        self.app.change_count += 1",
            "",
            "    def swap_blocks(self, demo: Blocks):",
            "        old_blocks = self.running_app.blocks",
            "        super().swap_blocks(demo)",
            "        if old_blocks:",
            "            reassign_keys(old_blocks, demo)",
            "        demo.config = demo.get_config_file()",
            "        self.alert_change(\"reload\")",
            "",
            "",
            "NO_RELOAD = True",
            "",
            "",
            "def _remove_no_reload_codeblocks(file_path: str):",
            "    \"\"\"Parse the file, remove the gr.no_reload code blocks, and write the file back to disk.",
            "",
            "    Parameters:",
            "        file_path (str): The path to the file to remove the no_reload code blocks from.",
            "    \"\"\"",
            "",
            "    with open(file_path, encoding=\"utf-8\") as file:",
            "        code = file.read()",
            "",
            "    tree = ast.parse(code)",
            "",
            "    def _is_gr_no_reload(expr: ast.AST) -> bool:",
            "        \"\"\"Find with gr.no_reload context managers.\"\"\"",
            "        return (",
            "            isinstance(expr, ast.If)",
            "            and isinstance(expr.test, ast.Attribute)",
            "            and isinstance(expr.test.value, ast.Name)",
            "            and expr.test.value.id == \"gr\"",
            "            and expr.test.attr == \"NO_RELOAD\"",
            "        )",
            "",
            "    # Find the positions of the code blocks to load",
            "    for node in ast.walk(tree):",
            "        if _is_gr_no_reload(node):",
            "            assert isinstance(node, ast.If)  # noqa: S101",
            "            node.body = [ast.Pass(lineno=node.lineno, col_offset=node.col_offset)]",
            "",
            "    # convert tree to string",
            "    code_removed = compile(tree, filename=file_path, mode=\"exec\")",
            "    return code_removed",
            "",
            "",
            "def _find_module(source_file: Path) -> ModuleType | None:",
            "    for s, v in sys.modules.items():",
            "        if s not in {\"__main__\", \"__mp_main__\"} and getattr(v, \"__file__\", None) == str(",
            "            source_file",
            "        ):",
            "            return v",
            "    return None",
            "",
            "",
            "def watchfn(reloader: SourceFileReloader):",
            "    \"\"\"Watch python files in a given module.",
            "",
            "    get_changes is taken from uvicorn's default file watcher.",
            "    \"\"\"",
            "",
            "    # The thread running watchfn will be the thread reloading",
            "    # the app. So we need to modify this thread_data attr here",
            "    # so that subsequent calls to reload don't launch the app",
            "    from gradio.cli.commands.reload import reload_thread",
            "",
            "    reload_thread.running_reload = True",
            "",
            "    def get_changes() -> Path | None:",
            "        for file in iter_py_files():",
            "            try:",
            "                mtime = file.stat().st_mtime",
            "            except OSError:  # pragma: nocover",
            "                continue",
            "",
            "            old_time = mtimes.get(file)",
            "            if old_time is None:",
            "                mtimes[file] = mtime",
            "                continue",
            "            elif mtime > old_time:",
            "                return file",
            "        return None",
            "",
            "    def iter_py_files() -> Iterator[Path]:",
            "        for reload_dir in reload_dirs:",
            "            for path in list(reload_dir.rglob(\"*.py\")):",
            "                yield path.resolve()",
            "            for path in list(reload_dir.rglob(\"*.css\")):",
            "                yield path.resolve()",
            "",
            "    reload_dirs = [Path(dir_) for dir_ in reloader.watch_dirs]",
            "    import sys",
            "",
            "    for dir_ in reload_dirs:",
            "        sys.path.insert(0, str(dir_))",
            "",
            "    mtimes = {}",
            "    # Need to import the module in this thread so that the",
            "    # module is available in the namespace of this thread",
            "    module = importlib.import_module(reloader.watch_module_name)",
            "    while reloader.should_watch():",
            "        changed = get_changes()",
            "        if changed:",
            "            print(f\"Changes detected in: {changed}\")",
            "            try:",
            "                # How source file reloading works",
            "                # 1. Remove the gr.no_reload code blocks from the temp file",
            "                # 2. Execute the changed source code in the original module's namespac",
            "                # 3. Delete the package the module is in from sys.modules.",
            "                # This is so that the updated module is available in the entire package",
            "                # 4. Do 1-2 for the main demo file even if it did not change.",
            "                # This is because the main demo file may import the changed file and we need the",
            "                # changes to be reflected in the main demo file.",
            "",
            "                if changed.suffix == \".py\":",
            "                    changed_in_copy = _remove_no_reload_codeblocks(str(changed))",
            "                    if changed != reloader.demo_file:",
            "                        changed_module = _find_module(changed)",
            "                        if changed_module:",
            "                            exec(changed_in_copy, changed_module.__dict__)",
            "                            top_level_parent = sys.modules[",
            "                                changed_module.__name__.split(\".\")[0]",
            "                            ]",
            "                            if top_level_parent != changed_module:",
            "                                importlib.reload(top_level_parent)",
            "",
            "                changed_demo_file = _remove_no_reload_codeblocks(",
            "                    str(reloader.demo_file)",
            "                )",
            "                exec(changed_demo_file, module.__dict__)",
            "            except Exception:",
            "                print(",
            "                    f\"Reloading {reloader.watch_module_name} failed with the following exception: \"",
            "                )",
            "                traceback.print_exc()",
            "                mtimes = {}",
            "                reloader.alert_change(\"error\")",
            "                reloader.app.reload_error_message = traceback.format_exc()",
            "                continue",
            "            demo = getattr(module, reloader.demo_name)",
            "            reloader.swap_blocks(demo)",
            "            mtimes = {}",
            "        time.sleep(0.05)",
            "",
            "",
            "def deep_equal(a: Any, b: Any) -> bool:",
            "    \"\"\"",
            "    Deep equality check for component values.",
            "",
            "    Prefer orjson for performance and compatibility with numpy arrays/dataframes/torch tensors.",
            "    If objects are not serializable by orjson, fall back to regular equality check.",
            "    \"\"\"",
            "",
            "    def _serialize(a: Any) -> bytes:",
            "        return orjson.dumps(",
            "            a,",
            "            option=orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_PASSTHROUGH_DATETIME,",
            "        )",
            "",
            "    try:",
            "        return _serialize(a) == _serialize(b)",
            "    except TypeError:",
            "        try:",
            "            return a == b",
            "        except Exception:",
            "            return False",
            "",
            "",
            "def reassign_keys(old_blocks: Blocks, new_blocks: Blocks):",
            "    from gradio.blocks import BlockContext",
            "",
            "    assigned_keys = [",
            "        block.key for block in new_blocks.children if block.key is not None",
            "    ]",
            "",
            "    def reassign_context_keys(",
            "        old_context: BlockContext | None, new_context: BlockContext",
            "    ):",
            "        for i, new_block in enumerate(new_context.children):",
            "            if old_context and i < len(old_context.children):",
            "                old_block = old_context.children[i]",
            "            else:",
            "                old_block = None",
            "            if new_block.key is None:",
            "                if (",
            "                    old_block.__class__ == new_block.__class__",
            "                    and old_block is not None",
            "                    and old_block.key not in assigned_keys",
            "                    and deep_equal(",
            "                        getattr(old_block, \"value\", None),",
            "                        getattr(new_block, \"value\", None),",
            "                    )",
            "                ):",
            "                    new_block.key = old_block.key",
            "                else:",
            "                    new_block.key = f\"__{new_block._id}__\"",
            "",
            "            if isinstance(new_block, BlockContext):",
            "                if (",
            "                    isinstance(old_block, BlockContext)",
            "                    and old_block.__class__ == new_block.__class__",
            "                ):",
            "                    reassign_context_keys(old_block, new_block)",
            "                else:",
            "                    reassign_context_keys(None, new_block)",
            "",
            "    reassign_context_keys(old_blocks, new_blocks)",
            "",
            "",
            "def colab_check() -> bool:",
            "    \"\"\"",
            "    Check if interface is launching from Google Colab",
            "    :return is_colab (bool): True or False",
            "    \"\"\"",
            "    is_colab = False",
            "    try:  # Check if running interactively using ipython.",
            "        from IPython.core.getipython import get_ipython",
            "",
            "        from_ipynb = get_ipython()",
            "        if \"google.colab\" in str(from_ipynb):",
            "            is_colab = True",
            "    except (ImportError, NameError):",
            "        pass",
            "    return is_colab",
            "",
            "",
            "def kaggle_check() -> bool:",
            "    return bool(",
            "        os.environ.get(\"KAGGLE_KERNEL_RUN_TYPE\") or os.environ.get(\"GFOOTBALL_DATA_DIR\")",
            "    )",
            "",
            "",
            "def sagemaker_check() -> bool:",
            "    try:",
            "        import boto3  # type: ignore",
            "",
            "        client = boto3.client(\"sts\")",
            "        response = client.get_caller_identity()",
            "        return \"sagemaker\" in response[\"Arn\"].lower()",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def ipython_check() -> bool:",
            "    \"\"\"",
            "    Check if interface is launching from iPython (not colab)",
            "    :return is_ipython (bool): True or False",
            "    \"\"\"",
            "    is_ipython = False",
            "    try:  # Check if running interactively using ipython.",
            "        from IPython.core.getipython import get_ipython",
            "",
            "        if get_ipython() is not None:",
            "            is_ipython = True",
            "    except (ImportError, NameError):",
            "        pass",
            "    return is_ipython",
            "",
            "",
            "def get_space() -> str | None:",
            "    if os.getenv(\"SYSTEM\") == \"spaces\":",
            "        return os.getenv(\"SPACE_ID\")",
            "    return None",
            "",
            "",
            "def is_zero_gpu_space() -> bool:",
            "    return os.getenv(\"SPACES_ZERO_GPU\") == \"true\"",
            "",
            "",
            "def download_if_url(article: str) -> str:",
            "    try:",
            "        result = urllib.parse.urlparse(article)",
            "        is_url = all([result.scheme, result.netloc, result.path])",
            "        is_url = is_url and result.scheme in [\"http\", \"https\"]",
            "    except ValueError:",
            "        is_url = False",
            "",
            "    if not is_url:",
            "        return article",
            "",
            "    try:",
            "        response = httpx.get(article, timeout=3)",
            "        if response.status_code == httpx.codes.OK:  # pylint: disable=no-member",
            "            article = response.text",
            "    except (httpx.InvalidURL, httpx.RequestError, httpx.TimeoutException):",
            "        pass",
            "",
            "    return article",
            "",
            "",
            "HASH_SEED_PATH = os.path.join(os.path.dirname(gradio.__file__), \"hash_seed.txt\")",
            "",
            "",
            "def get_hash_seed() -> str:",
            "    try:",
            "        if os.path.exists(HASH_SEED_PATH):",
            "            with open(HASH_SEED_PATH) as j:",
            "                return j.read().strip()",
            "        else:",
            "            with open(HASH_SEED_PATH, \"w\") as j:",
            "                seed = uuid.uuid4().hex",
            "                j.write(seed)",
            "                return seed",
            "    except Exception:",
            "        return uuid.uuid4().hex",
            "",
            "",
            "def get_default_args(func: Callable) -> list[Any]:",
            "    signature = inspect.signature(func)",
            "    return [",
            "        v.default if v.default is not inspect.Parameter.empty else None",
            "        for v in signature.parameters.values()",
            "    ]",
            "",
            "",
            "def assert_configs_are_equivalent_besides_ids(",
            "    config1: dict, config2: dict, root_keys: tuple = (\"mode\",)",
            "):",
            "    \"\"\"Allows you to test if two different Blocks configs produce the same demo.",
            "",
            "    Parameters:",
            "    config1 (dict): nested dict with config from the first Blocks instance",
            "    config2 (dict): nested dict with config from the second Blocks instance",
            "    root_keys (Tuple): an interable consisting of which keys to test for equivalence at",
            "        the root level of the config. By default, only \"mode\" is tested,",
            "        so keys like \"version\" are ignored.",
            "    \"\"\"",
            "    config1 = copy.deepcopy(config1)",
            "    config2 = copy.deepcopy(config2)",
            "    config1 = json.loads(json.dumps(config1))  # convert tuples to lists",
            "    config2 = json.loads(json.dumps(config2))",
            "",
            "    for key in root_keys:",
            "        if config1[key] != config2[key]:",
            "            raise ValueError(f\"Configs have different: {key}\")",
            "",
            "    if len(config1[\"components\"]) != len(config2[\"components\"]):",
            "        raise ValueError(\"# of components are different\")",
            "",
            "    def assert_same_components(config1_id, config2_id):",
            "        c1 = list(filter(lambda c: c[\"id\"] == config1_id, config1[\"components\"]))",
            "        if len(c1) == 0:",
            "            raise ValueError(f\"Could not find component with id {config1_id}\")",
            "        c1 = c1[0]",
            "        c2 = list(filter(lambda c: c[\"id\"] == config2_id, config2[\"components\"]))",
            "        if len(c2) == 0:",
            "            raise ValueError(f\"Could not find component with id {config2_id}\")",
            "        c2 = c2[0]",
            "        c1 = copy.deepcopy(c1)",
            "        c1.pop(\"id\")",
            "        c2 = copy.deepcopy(c2)",
            "        c2.pop(\"id\")",
            "        if c1 != c2:",
            "            raise ValueError(f\"{c1} does not match {c2}\")",
            "",
            "    def same_children_recursive(children1, chidren2):",
            "        for child1, child2 in zip(children1, chidren2):",
            "            assert_same_components(child1[\"id\"], child2[\"id\"])",
            "            if \"children\" in child1 or \"children\" in child2:",
            "                same_children_recursive(child1[\"children\"], child2[\"children\"])",
            "",
            "    children1 = config1[\"layout\"][\"children\"]",
            "    children2 = config2[\"layout\"][\"children\"]",
            "    same_children_recursive(children1, children2)",
            "",
            "    for d1, d2 in zip(config1[\"dependencies\"], config2[\"dependencies\"]):",
            "        for t1, t2 in zip(d1.pop(\"targets\"), d2.pop(\"targets\")):",
            "            assert_same_components(t1[0], t2[0])",
            "        for i1, i2 in zip(d1.pop(\"inputs\"), d2.pop(\"inputs\")):",
            "            assert_same_components(i1, i2)",
            "        for o1, o2 in zip(d1.pop(\"outputs\"), d2.pop(\"outputs\")):",
            "            assert_same_components(o1, o2)",
            "",
            "        if d1 != d2:",
            "            raise ValueError(f\"{d1} does not match {d2}\")",
            "",
            "    return True",
            "",
            "",
            "def delete_none(_dict: dict, skip_value: bool = False) -> dict:",
            "    \"\"\"",
            "    Delete keys whose values are None from a dictionary",
            "    \"\"\"",
            "    for key, value in list(_dict.items()):",
            "        if skip_value and key == \"value\":",
            "            continue",
            "        elif value is None:",
            "            del _dict[key]",
            "    return _dict",
            "",
            "",
            "def resolve_singleton(_list: list[Any] | Any) -> Any:",
            "    if len(_list) == 1:",
            "        return _list[0]",
            "    else:",
            "        return _list",
            "",
            "",
            "def get_all_components() -> list[type[Component] | type[BlockContext]]:",
            "    import gradio as gr",
            "",
            "    classes_to_check = (",
            "        gr.components.Component.__subclasses__()",
            "        + gr.blocks.BlockContext.__subclasses__()  # type: ignore",
            "    )",
            "    subclasses = []",
            "",
            "    while classes_to_check:",
            "        subclass = classes_to_check.pop()",
            "        classes_to_check.extend(subclass.__subclasses__())",
            "        subclasses.append(subclass)",
            "    return [",
            "        c",
            "        for c in subclasses",
            "        if c.__name__",
            "        not in [\"ChatInterface\", \"Interface\", \"Blocks\", \"TabbedInterface\", \"NativePlot\"]",
            "    ]",
            "",
            "",
            "def core_gradio_components():",
            "    return [",
            "        class_",
            "        for class_ in get_all_components()",
            "        if class_.__module__.startswith(\"gradio.\")",
            "    ]",
            "",
            "",
            "def component_or_layout_class(cls_name: str) -> type[Component] | type[BlockContext]:",
            "    \"\"\"",
            "    Returns the component, template, or layout class with the given class name, or",
            "    raises a ValueError if not found.",
            "",
            "    Parameters:",
            "    cls_name (str): lower-case string class name of a component",
            "    Returns:",
            "    cls: the component class",
            "    \"\"\"",
            "    import gradio.components as components_module",
            "    from gradio.components import Component",
            "",
            "    components = {c.__name__.lower(): c for c in get_all_components()}",
            "    # add aliases such as 'text'",
            "    for name, cls in components_module.__dict__.items():",
            "        if isinstance(cls, type) and issubclass(cls, Component):",
            "            components[name.lower()] = cls",
            "",
            "    if cls_name.replace(\"_\", \"\") in components:",
            "        return components[cls_name.replace(\"_\", \"\")]",
            "",
            "    raise ValueError(",
            "        f\"No such component or layout: {cls_name}. \"",
            "        \"It is possible it is a custom component, \"",
            "        \"in which case make sure it is installed and imported in your python session.\"",
            "    )",
            "",
            "",
            "def run_coro_in_background(func: Callable, *args, **kwargs):",
            "    \"\"\"",
            "    Runs coroutines in background.",
            "",
            "    Warning, be careful to not use this function in other than FastAPI scope, because the event_loop has not started yet.",
            "    You can use it in any scope reached by FastAPI app.",
            "",
            "    correct scope examples: endpoints in routes, Blocks.process_api",
            "    incorrect scope examples: Blocks.launch",
            "",
            "    Use startup_events in routes.py if you need to run a coro in background in Blocks.launch().",
            "",
            "",
            "    Example:",
            "        utils.run_coro_in_background(fn, *args, **kwargs)",
            "",
            "    Args:",
            "        func:",
            "        *args:",
            "        **kwargs:",
            "",
            "    Returns:",
            "",
            "    \"\"\"",
            "    event_loop = asyncio.get_event_loop()",
            "    return event_loop.create_task(func(*args, **kwargs))",
            "",
            "",
            "def run_sync_iterator_async(iterator):",
            "    \"\"\"Helper for yielding StopAsyncIteration from sync iterators.\"\"\"",
            "    try:",
            "        return next(iterator)",
            "    except StopIteration:",
            "        # raise a ValueError here because co-routines can't raise StopIteration themselves",
            "        raise StopAsyncIteration() from None",
            "",
            "",
            "class SyncToAsyncIterator:",
            "    \"\"\"Treat a synchronous iterator as async one.\"\"\"",
            "",
            "    def __init__(self, iterator, limiter) -> None:",
            "        self.iterator = iterator",
            "        self.limiter = limiter",
            "",
            "    def __aiter__(self):",
            "        return self",
            "",
            "    async def __anext__(self):",
            "        return await anyio.to_thread.run_sync(",
            "            run_sync_iterator_async, self.iterator, limiter=self.limiter",
            "        )",
            "",
            "",
            "async def async_iteration(iterator):",
            "    # anext not introduced until 3.10 :(",
            "    return await iterator.__anext__()",
            "",
            "",
            "@contextmanager",
            "def set_directory(path: Path | str):",
            "    \"\"\"Context manager that sets the working directory to the given path.\"\"\"",
            "    origin = Path().absolute()",
            "    try:",
            "        os.chdir(path)",
            "        yield",
            "    finally:",
            "        os.chdir(origin)",
            "",
            "",
            "@contextmanager",
            "def no_raise_exception():",
            "    \"\"\"Context manager that suppresses exceptions.\"\"\"",
            "    try:",
            "        yield",
            "    except Exception:",
            "        pass",
            "",
            "",
            "def sanitize_value_for_csv(value: str | float) -> str | float:",
            "    \"\"\"",
            "    Sanitizes a value that is being written to a CSV file to prevent CSV injection attacks.",
            "    Reference: https://owasp.org/www-community/attacks/CSV_Injection",
            "    \"\"\"",
            "    if isinstance(value, (float, int)):",
            "        return value",
            "    unsafe_prefixes = [\"=\", \"+\", \"-\", \"@\", \"\\t\", \"\\n\"]",
            "    unsafe_sequences = [\",=\", \",+\", \",-\", \",@\", \",\\t\", \",\\n\"]",
            "    if any(value.startswith(prefix) for prefix in unsafe_prefixes) or any(",
            "        sequence in value for sequence in unsafe_sequences",
            "    ):",
            "        value = f\"'{value}\"",
            "    return value",
            "",
            "",
            "def sanitize_list_for_csv(values: list[Any]) -> list[Any]:",
            "    \"\"\"",
            "    Sanitizes a list of values (or a list of list of values) that is being written to a",
            "    CSV file to prevent CSV injection attacks.",
            "    \"\"\"",
            "    sanitized_values = []",
            "    for value in values:",
            "        if isinstance(value, list):",
            "            sanitized_value = [sanitize_value_for_csv(v) for v in value]",
            "            sanitized_values.append(sanitized_value)",
            "        else:",
            "            sanitized_value = sanitize_value_for_csv(value)",
            "            sanitized_values.append(sanitized_value)",
            "    return sanitized_values",
            "",
            "",
            "def append_unique_suffix(name: str, list_of_names: list[str]):",
            "    \"\"\"Appends a numerical suffix to `name` so that it does not appear in `list_of_names`.\"\"\"",
            "    set_of_names: set[str] = set(list_of_names)  # for O(1) lookup",
            "    if name not in set_of_names:",
            "        return name",
            "    else:",
            "        suffix_counter = 1",
            "        new_name = f\"{name}_{suffix_counter}\"",
            "        while new_name in set_of_names:",
            "            suffix_counter += 1",
            "            new_name = f\"{name}_{suffix_counter}\"",
            "        return new_name",
            "",
            "",
            "def validate_url(possible_url: str) -> bool:",
            "    headers = {\"User-Agent\": \"gradio (https://gradio.app/; gradio-team@huggingface.co)\"}",
            "    try:",
            "        head_request = httpx.head(possible_url, headers=headers, follow_redirects=True)",
            "        # some URLs, such as AWS S3 presigned URLs, return a 405 or a 403 for HEAD requests",
            "        if head_request.status_code in (403, 405):",
            "            return httpx.get(",
            "                possible_url, headers=headers, follow_redirects=True",
            "            ).is_success",
            "        return head_request.is_success",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def is_prop_update(val):",
            "    return isinstance(val, dict) and \"update\" in val.get(\"__type__\", \"\")",
            "",
            "",
            "def function_wrapper(",
            "    f: Callable,",
            "    before_fn: Callable | None = None,",
            "    before_args: Iterable | None = None,",
            "    after_fn: Callable | None = None,",
            "    after_args: Iterable | None = None,",
            "):",
            "    before_args = [] if before_args is None else before_args",
            "    after_args = [] if after_args is None else after_args",
            "    if inspect.isasyncgenfunction(f):",
            "",
            "        @functools.wraps(f)",
            "        async def asyncgen_wrapper(*args, **kwargs):",
            "            iterator = f(*args, **kwargs)",
            "            while True:",
            "                if before_fn:",
            "                    before_fn(*before_args)",
            "                try:",
            "                    response = await iterator.__anext__()",
            "                except StopAsyncIteration:",
            "                    if after_fn:",
            "                        after_fn(*after_args)",
            "                    break",
            "                if after_fn:",
            "                    after_fn(*after_args)",
            "                yield response",
            "",
            "        return asyncgen_wrapper",
            "",
            "    elif asyncio.iscoroutinefunction(f):",
            "",
            "        @functools.wraps(f)",
            "        async def async_wrapper(*args, **kwargs):",
            "            if before_fn:",
            "                before_fn(*before_args)",
            "            response = await f(*args, **kwargs)",
            "            if after_fn:",
            "                after_fn(*after_args)",
            "            return response",
            "",
            "        return async_wrapper",
            "",
            "    elif inspect.isgeneratorfunction(f):",
            "",
            "        @functools.wraps(f)",
            "        def gen_wrapper(*args, **kwargs):",
            "            iterator = f(*args, **kwargs)",
            "            while True:",
            "                if before_fn:",
            "                    before_fn(*before_args)",
            "                try:",
            "                    response = next(iterator)",
            "                except StopIteration:",
            "                    if after_fn:",
            "                        after_fn(*after_args)",
            "                    break",
            "                if after_fn:",
            "                    after_fn(*after_args)",
            "                yield response",
            "",
            "        return gen_wrapper",
            "",
            "    else:",
            "",
            "        @functools.wraps(f)",
            "        def wrapper(*args, **kwargs):",
            "            if before_fn:",
            "                before_fn(*before_args)",
            "            response = f(*args, **kwargs)",
            "            if after_fn:",
            "                after_fn(*after_args)",
            "            return response",
            "",
            "        return wrapper",
            "",
            "",
            "def get_function_with_locals(",
            "    fn: Callable,",
            "    blocks: Blocks,",
            "    event_id: str | None,",
            "    in_event_listener: bool,",
            "    request: Request | None,",
            "    state: SessionState | None,",
            "):",
            "    def before_fn(blocks, event_id):",
            "        from gradio.context import LocalContext",
            "",
            "        LocalContext.blocks.set(blocks)",
            "        LocalContext.in_event_listener.set(in_event_listener)",
            "        LocalContext.event_id.set(event_id)",
            "        LocalContext.request.set(request)",
            "        if state:",
            "            LocalContext.blocks_config.set(state.blocks_config)",
            "",
            "    def after_fn():",
            "        from gradio.context import LocalContext",
            "",
            "        LocalContext.in_event_listener.set(False)",
            "        LocalContext.request.set(None)",
            "        LocalContext.blocks_config.set(None)",
            "",
            "    return function_wrapper(",
            "        fn,",
            "        before_fn=before_fn,",
            "        before_args=(blocks, event_id),",
            "        after_fn=after_fn,",
            "    )",
            "",
            "",
            "async def cancel_tasks(task_ids: set[str]) -> list[str]:",
            "    tasks = [(task, task.get_name()) for task in asyncio.all_tasks()]",
            "    event_ids: list[str] = []",
            "    matching_tasks = []",
            "    for task, name in tasks:",
            "        if \"<gradio-sep>\" not in name:",
            "            continue",
            "        task_id, event_id = name.split(\"<gradio-sep>\")",
            "        if task_id in task_ids:",
            "            matching_tasks.append(task)",
            "            event_ids.append(event_id)",
            "            task.cancel()",
            "    await asyncio.gather(*matching_tasks, return_exceptions=True)",
            "    return event_ids",
            "",
            "",
            "def set_task_name(task, session_hash: str, fn_index: int, event_id: str, batch: bool):",
            "    if not batch:",
            "        task.set_name(f\"{session_hash}_{fn_index}<gradio-sep>{event_id}\")",
            "",
            "",
            "def get_cancelled_fn_indices(",
            "    dependencies: list[dict[str, Any]],",
            ") -> list[int]:",
            "    fn_indices = []",
            "    for dep in dependencies:",
            "        root_block = get_blocks_context()",
            "        if root_block:",
            "            fn_index = next(",
            "                i for i, d in root_block.fns.items() if d.get_config() == dep",
            "            )",
            "            fn_indices.append(fn_index)",
            "",
            "    return fn_indices",
            "",
            "",
            "def get_type_hints(fn):",
            "    # Importing gradio with the canonical abbreviation. Used in typing._eval_type.",
            "    import gradio as gr  # noqa: F401",
            "    from gradio import OAuthProfile, OAuthToken, Request  # noqa: F401",
            "",
            "    if inspect.isfunction(fn) or inspect.ismethod(fn):",
            "        pass",
            "    elif callable(fn):",
            "        fn = fn.__call__",
            "    else:",
            "        return {}",
            "",
            "    try:",
            "        return typing.get_type_hints(fn)",
            "    except TypeError:",
            "        # On Python 3.9 or earlier, get_type_hints throws a TypeError if the function",
            "        # has a type annotation that include \"|\". We resort to parsing the signature",
            "        # manually using inspect.signature.",
            "        type_hints = {}",
            "        sig = inspect.signature(fn)",
            "        for name, param in sig.parameters.items():",
            "            if param.annotation is inspect.Parameter.empty:",
            "                continue",
            "            if param.annotation == \"gr.OAuthProfile | None\":",
            "                # Special case: we want to inject the OAuthProfile value even on Python 3.9",
            "                type_hints[name] = Optional[OAuthProfile]",
            "            if param.annotation == \"gr.OAuthToken | None\":",
            "                # Special case: we want to inject the OAuthToken value even on Python 3.9",
            "                type_hints[name] = Optional[OAuthToken]",
            "            if \"|\" in str(param.annotation):",
            "                continue",
            "            # To convert the string annotation to a class, we use the",
            "            # internal typing._eval_type function. This is not ideal, but",
            "            # it's the only way to do it without eval-ing the string.",
            "            # Since the API is internal, it may change in the future.",
            "            try:",
            "                type_hints[name] = typing._eval_type(  # type: ignore",
            "                    typing.ForwardRef(param.annotation), globals(), locals()",
            "                )",
            "            except (NameError, TypeError):",
            "                pass",
            "        return type_hints",
            "",
            "",
            "def is_special_typed_parameter(name, parameter_types):",
            "    from gradio.helpers import EventData",
            "    from gradio.oauth import OAuthProfile, OAuthToken",
            "    from gradio.routes import Request",
            "",
            "    \"\"\"Checks if parameter has a type hint designating it as a gr.Request, gr.EventData, gr.OAuthProfile or gr.OAuthToken.\"\"\"",
            "    hint = parameter_types.get(name)",
            "    if not hint:",
            "        return False",
            "    is_request = hint == Request",
            "    is_oauth_arg = hint in (",
            "        OAuthProfile,",
            "        Optional[OAuthProfile],",
            "        OAuthToken,",
            "        Optional[OAuthToken],",
            "    )",
            "    is_event_data = inspect.isclass(hint) and issubclass(hint, EventData)",
            "    return is_request or is_event_data or is_oauth_arg",
            "",
            "",
            "def check_function_inputs_match(fn: Callable, inputs: Sequence, inputs_as_dict: bool):",
            "    \"\"\"",
            "    Checks if the input component set matches the function",
            "    Returns: None if valid or if the function does not have a signature (e.g. is a built in),",
            "    or a string error message if mismatch",
            "    \"\"\"",
            "    try:",
            "        signature = inspect.signature(fn)",
            "    except ValueError:",
            "        return None",
            "    parameter_types = get_type_hints(fn)",
            "    min_args = 0",
            "    max_args = 0",
            "    infinity = -1",
            "    for name, param in signature.parameters.items():",
            "        has_default = param.default != param.empty",
            "        if param.kind in [param.POSITIONAL_ONLY, param.POSITIONAL_OR_KEYWORD]:",
            "            if not is_special_typed_parameter(name, parameter_types):",
            "                if not has_default:",
            "                    min_args += 1",
            "                max_args += 1",
            "        elif param.kind == param.VAR_POSITIONAL:",
            "            max_args = infinity",
            "        elif param.kind == param.KEYWORD_ONLY and not has_default:",
            "            return f\"Keyword-only args must have default values for function {fn}\"",
            "    arg_count = 1 if inputs_as_dict else len(inputs)",
            "    if min_args == max_args and max_args != arg_count:",
            "        warnings.warn(",
            "            f\"Expected {max_args} arguments for function {fn}, received {arg_count}.\"",
            "        )",
            "    if arg_count < min_args:",
            "        warnings.warn(",
            "            f\"Expected at least {min_args} arguments for function {fn}, received {arg_count}.\"",
            "        )",
            "    if max_args != infinity and arg_count > max_args:",
            "        warnings.warn(",
            "            f\"Expected maximum {max_args} arguments for function {fn}, received {arg_count}.\"",
            "        )",
            "",
            "",
            "class TupleNoPrint(tuple):",
            "    # To remove printing function return in notebook",
            "    def __repr__(self):",
            "        return \"\"",
            "",
            "    def __str__(self):",
            "        return \"\"",
            "",
            "",
            "class MatplotlibBackendMananger:",
            "    def __enter__(self):",
            "        import matplotlib",
            "",
            "        self._original_backend = matplotlib.get_backend()",
            "        matplotlib.use(\"agg\")",
            "",
            "    def __exit__(self, exc_type, exc_val, exc_tb):",
            "        import matplotlib",
            "",
            "        matplotlib.use(self._original_backend)",
            "",
            "",
            "def tex2svg(formula, *_args):",
            "    with MatplotlibBackendMananger():",
            "        import matplotlib.pyplot as plt",
            "",
            "        fontsize = 20",
            "        dpi = 300",
            "        plt.rc(\"mathtext\", fontset=\"cm\")",
            "        fig = plt.figure(figsize=(0.01, 0.01))",
            "        fig.text(0, 0, rf\"${formula}$\", fontsize=fontsize)",
            "        output = BytesIO()",
            "        fig.savefig(  # type: ignore",
            "            output,",
            "            dpi=dpi,",
            "            transparent=True,",
            "            format=\"svg\",",
            "            bbox_inches=\"tight\",",
            "            pad_inches=0.0,",
            "        )",
            "        plt.close(fig)",
            "        output.seek(0)",
            "        xml_code = output.read().decode(\"utf-8\")",
            "        svg_start = xml_code.index(\"<svg \")",
            "        svg_code = xml_code[svg_start:]",
            "        svg_code = re.sub(r\"<metadata>.*<\\/metadata>\", \"\", svg_code, flags=re.DOTALL)",
            "        svg_code = re.sub(r' width=\"[^\"]+\"', \"\", svg_code)",
            "        height_match = re.search(r'height=\"([\\d.]+)pt\"', svg_code)",
            "        if height_match:",
            "            height = float(height_match.group(1))",
            "            new_height = height / fontsize  # conversion from pt to em",
            "            svg_code = re.sub(",
            "                r'height=\"[\\d.]+pt\"', f'height=\"{new_height}em\"', svg_code",
            "            )",
            "        copy_code = f\"<span style='font-size: 0px'>{formula}</span>\"",
            "    return f\"{copy_code}{svg_code}\"",
            "",
            "",
            "def abspath(path: str | Path) -> Path:",
            "    \"\"\"Returns absolute path of a str or Path path, but does not resolve symlinks.\"\"\"",
            "    path = Path(path)",
            "",
            "    if path.is_absolute():",
            "        return path",
            "",
            "    # recursively check if there is a symlink within the path",
            "    is_symlink = path.is_symlink() or any(",
            "        parent.is_symlink() for parent in path.parents",
            "    )",
            "",
            "    if is_symlink or path == path.resolve():  # in case path couldn't be resolved",
            "        return Path.cwd() / path",
            "    else:",
            "        return path.resolve()",
            "",
            "",
            "def is_in_or_equal(path_1: str | Path, path_2: str | Path):",
            "    \"\"\"",
            "    True if path_1 is a descendant (i.e. located within) path_2 or if the paths are the",
            "    same, returns False otherwise.",
            "    Parameters:",
            "        path_1: str or Path (to file or directory)",
            "        path_2: str or Path (to file or directory)",
            "    \"\"\"",
            "    path_1, path_2 = abspath(path_1), abspath(path_2)",
            "    try:",
            "        relative_path = path_1.relative_to(path_2)",
            "        if str(relative_path) == \".\":",
            "            return True",
            "        relative_path = path_1.parent.relative_to(path_2)",
            "        return \"..\" not in str(relative_path)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "@document()",
            "def set_static_paths(paths: list[str | Path]) -> None:",
            "    \"\"\"",
            "    Set the static paths to be served by the gradio app.",
            "",
            "    Static files are not moved to the gradio cache and are served directly from the file system.",
            "    This function is useful when you want to serve files that you know will not be modified during the lifetime of the gradio app (like files used in gr.Examples).",
            "    By setting static paths, your app will launch faster and it will consume less disk space.",
            "    Calling this function will set the static paths for all gradio applications defined in the same interpreter session until it is called again or the session ends.",
            "    To clear out the static paths, call this function with an empty list.",
            "",
            "    Parameters:",
            "        paths: List of filepaths or directory names to be served by the gradio app. If it is a directory name, ALL files located within that directory will be considered static and not moved to the gradio cache. This also means that ALL files in that directory will be accessible over the network.",
            "    Example:",
            "        import gradio as gr",
            "",
            "        # Paths can be a list of strings or pathlib.Path objects",
            "        # corresponding to filenames or directories.",
            "        gr.set_static_paths(paths=[\"test/test_files/\"])",
            "",
            "        # The example files and the default value of the input",
            "        # will not be copied to the gradio cache and will be served directly.",
            "        demo = gr.Interface(",
            "            lambda s: s.rotate(45),",
            "            gr.Image(value=\"test/test_files/cheetah1.jpg\", type=\"pil\"),",
            "            gr.Image(),",
            "            examples=[\"test/test_files/bus.png\"],",
            "        )",
            "",
            "        demo.launch()",
            "    \"\"\"",
            "    from gradio.data_classes import _StaticFiles",
            "",
            "    _StaticFiles.all_paths.extend([Path(p).resolve() for p in paths])",
            "",
            "",
            "def is_static_file(file_path: Any):",
            "    \"\"\"Returns True if the file is a static file (and not moved to cache)\"\"\"",
            "    from gradio.data_classes import _StaticFiles",
            "",
            "    return _is_static_file(file_path, _StaticFiles.all_paths)",
            "",
            "",
            "def _is_static_file(file_path: Any, static_files: list[Path]) -> bool:",
            "    \"\"\"",
            "    Returns True if the file is a static file (i.e. is is in the static files list).",
            "    \"\"\"",
            "    if not isinstance(file_path, (str, Path, FileData)):",
            "        return False",
            "    if isinstance(file_path, FileData):",
            "        file_path = file_path.path",
            "    if isinstance(file_path, str):",
            "        file_path = Path(file_path)",
            "        if not file_path.exists():",
            "            return False",
            "    return any(is_in_or_equal(file_path, static_file) for static_file in static_files)",
            "",
            "",
            "HTML_TAG_RE = re.compile(\"<.*?>\")",
            "",
            "",
            "def remove_html_tags(raw_html: str | None) -> str:",
            "    return re.sub(HTML_TAG_RE, \"\", raw_html or \"\")",
            "",
            "",
            "def find_user_stack_level() -> int:",
            "    \"\"\"",
            "    Find the first stack frame not inside Gradio.",
            "    \"\"\"",
            "    frame = inspect.currentframe()",
            "    n = 0",
            "    while frame:",
            "        fname = inspect.getfile(frame)",
            "        if \"/gradio/\" not in fname.replace(os.sep, \"/\"):",
            "            break",
            "        frame = frame.f_back",
            "        n += 1",
            "    return n",
            "",
            "",
            "class NamedString(str):",
            "    \"\"\"",
            "    Subclass of str that includes a .name attribute equal to the value of the string itself. This class is used when returning",
            "    a value from the `.preprocess()` methods of the File and UploadButton components. Before Gradio 4.0, these methods returned a file",
            "    object which was then converted to a string filepath using the `.name` attribute. In Gradio 4.0, these methods now return a str",
            "    filepath directly, but to maintain backwards compatibility, we use this class instead of a regular str.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args):",
            "        super().__init__()",
            "        self.name = str(self) if args else \"\"",
            "",
            "",
            "def default_input_labels():",
            "    \"\"\"",
            "    A generator that provides default input labels for components when the user's function",
            "    does not have named parameters. The labels are of the form \"input 0\", \"input 1\", etc.",
            "    \"\"\"",
            "    n = 0",
            "    while True:",
            "        yield f\"input {n}\"",
            "        n += 1",
            "",
            "",
            "def get_extension_from_file_path_or_url(file_path_or_url: str) -> str:",
            "    \"\"\"",
            "    Returns the file extension (without the dot) from a file path or URL. If the file path or URL does not have a file extension, returns an empty string.",
            "    For example, \"https://example.com/avatar/xxxx.mp4?se=2023-11-16T06:51:23Z&sp=r\" would return \"mp4\".",
            "    \"\"\"",
            "    parsed_url = urllib.parse.urlparse(file_path_or_url)",
            "    file_extension = os.path.splitext(os.path.basename(parsed_url.path))[1]",
            "    return file_extension[1:] if file_extension else \"\"",
            "",
            "",
            "K = TypeVar(\"K\")",
            "V = TypeVar(\"V\")",
            "",
            "",
            "class LRUCache(OrderedDict, Generic[K, V]):",
            "    def __init__(self, max_size: int = 100):",
            "        super().__init__()",
            "        self.max_size: int = max_size",
            "",
            "    def __setitem__(self, key: K, value: V) -> None:",
            "        if key in self:",
            "            self.move_to_end(key)",
            "        elif len(self) >= self.max_size:",
            "            self.popitem(last=False)",
            "        super().__setitem__(key, value)",
            "",
            "    def __getitem__(self, key: K) -> V:",
            "        return super().__getitem__(key)",
            "",
            "",
            "def get_cache_folder() -> Path:",
            "    return Path(os.environ.get(\"GRADIO_EXAMPLES_CACHE\", \"gradio_cached_examples\"))",
            "",
            "",
            "def diff(old, new):",
            "    def compare_objects(obj1, obj2, path=None):",
            "        if path is None:",
            "            path = []",
            "        edits = []",
            "",
            "        if obj1 == obj2:",
            "            return edits",
            "",
            "        if type(obj1) != type(obj2):",
            "            edits.append((\"replace\", path, obj2))",
            "            return edits",
            "",
            "        if isinstance(obj1, str) and obj2.startswith(obj1):",
            "            edits.append((\"append\", path, obj2[len(obj1) :]))",
            "            return edits",
            "",
            "        if isinstance(obj1, list):",
            "            common_length = min(len(obj1), len(obj2))",
            "            for i in range(common_length):",
            "                edits.extend(compare_objects(obj1[i], obj2[i], path + [i]))",
            "            for i in range(common_length, len(obj1)):",
            "                edits.append((\"delete\", path + [i], None))",
            "            for i in range(common_length, len(obj2)):",
            "                edits.append((\"add\", path + [i], obj2[i]))",
            "            return edits",
            "",
            "        if isinstance(obj1, dict):",
            "            for key in obj1:",
            "                if key in obj2:",
            "                    edits.extend(compare_objects(obj1[key], obj2[key], path + [key]))",
            "                else:",
            "                    edits.append((\"delete\", path + [key], None))",
            "            for key in obj2:",
            "                if key not in obj1:",
            "                    edits.append((\"add\", path + [key], obj2[key]))",
            "            return edits",
            "",
            "        edits.append((\"replace\", path, obj2))",
            "        return edits",
            "",
            "    return compare_objects(old, new)",
            "",
            "",
            "def get_upload_folder() -> str:",
            "    return os.environ.get(\"GRADIO_TEMP_DIR\") or str(",
            "        (Path(tempfile.gettempdir()) / \"gradio\").resolve()",
            "    )",
            "",
            "",
            "def get_function_params(func: Callable) -> list[tuple[str, bool, Any]]:",
            "    \"\"\"",
            "    Gets the parameters of a function as a list of tuples of the form (name, has_default, default_value).",
            "    Excludes *args and **kwargs, as well as args that are Gradio-specific, such as gr.Request, gr.EventData, gr.OAuthProfile, and gr.OAuthToken.",
            "    \"\"\"",
            "    params_info = []",
            "    signature = inspect.signature(func)",
            "    type_hints = get_type_hints(func)",
            "    for name, parameter in signature.parameters.items():",
            "        if parameter.kind in (",
            "            inspect.Parameter.VAR_POSITIONAL,",
            "            inspect.Parameter.VAR_KEYWORD,",
            "        ):",
            "            break",
            "        if is_special_typed_parameter(name, type_hints):",
            "            continue",
            "        if parameter.default is inspect.Parameter.empty:",
            "            params_info.append((name, False, None))",
            "        else:",
            "            params_info.append((name, True, parameter.default))",
            "    return params_info",
            "",
            "",
            "def simplify_file_data_in_str(s):",
            "    \"\"\"",
            "    If a FileData dictionary has been dumped as part of a string, this function will replace the dict with just the str filepath",
            "    \"\"\"",
            "    try:",
            "        payload = json.loads(s)",
            "    except json.JSONDecodeError:",
            "        return s",
            "    payload = client_utils.traverse(",
            "        payload, lambda x: x[\"path\"], client_utils.is_file_obj_with_meta",
            "    )",
            "    if isinstance(payload, str):",
            "        return payload",
            "    return json.dumps(payload)",
            "",
            "",
            "def sync_fn_to_generator(fn):",
            "    def wrapped(*args, **kwargs):",
            "        yield fn(*args, **kwargs)",
            "",
            "    return wrapped",
            "",
            "",
            "def async_fn_to_generator(fn):",
            "    async def wrapped(*args, **kwargs):",
            "        yield await fn(*args, **kwargs)",
            "",
            "    return wrapped",
            "",
            "",
            "def async_lambda(f: Callable) -> Callable:",
            "    \"\"\"Turn a function into an async function.",
            "    Useful for internal event handlers defined as lambda functions used in the codebase",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    async def function_wrapper(*args, **kwargs):",
            "        return f(*args, **kwargs)",
            "",
            "    return function_wrapper",
            "",
            "",
            "class FileSize:",
            "    B = 1",
            "    KB = 1024 * B",
            "    MB = 1024 * KB",
            "    GB = 1024 * MB",
            "    TB = 1024 * GB",
            "",
            "",
            "def _parse_file_size(size: str | int | None) -> int | None:",
            "    if isinstance(size, int) or size is None:",
            "        return size",
            "",
            "    size = size.replace(\" \", \"\")",
            "",
            "    last_digit_index = next(",
            "        (i for i, c in enumerate(size) if not c.isdigit()), len(size)",
            "    )",
            "    size_int, unit = int(size[:last_digit_index]), size[last_digit_index:].upper()",
            "    multiple = getattr(FileSize, unit, None)",
            "    if not multiple:",
            "        raise ValueError(f\"Invalid file size unit: {unit}\")",
            "    return multiple * size_int",
            "",
            "",
            "def connect_heartbeat(config: BlocksConfigDict, blocks) -> bool:",
            "    \"\"\"",
            "    Determines whether a heartbeat is required for a given config.",
            "    \"\"\"",
            "    from gradio.components import State",
            "",
            "    any_state = any(isinstance(block, State) for block in blocks)",
            "    any_unload = False",
            "",
            "    if \"dependencies\" not in config:",
            "        raise ValueError(",
            "            \"Dependencies not found in config. Cannot determine whether\"",
            "            \"heartbeat is required.\"",
            "        )",
            "",
            "    for dep in config[\"dependencies\"]:",
            "        for target in dep[\"targets\"]:",
            "            if isinstance(target, (list, tuple)) and len(target) == 2:",
            "                any_unload = target[1] == \"unload\"",
            "                if any_unload:",
            "                    break",
            "    return any_state or any_unload",
            "",
            "",
            "def deep_hash(obj):",
            "    \"\"\"Compute a hash for a deeply nested data structure.\"\"\"",
            "    hasher = hashlib.sha256()",
            "    if isinstance(obj, (int, float, str, bytes)):",
            "        items = obj",
            "    elif isinstance(obj, dict):",
            "        items = tuple(",
            "            [",
            "                (k, deep_hash(v))",
            "                for k, v in sorted(obj.items(), key=lambda x: hash(x[0]))",
            "            ]",
            "        )",
            "    elif isinstance(obj, (list, tuple)):",
            "        items = tuple(deep_hash(x) for x in obj)",
            "    elif isinstance(obj, set):",
            "        items = tuple(deep_hash(x) for x in sorted(obj, key=hash))",
            "    else:",
            "        items = str(id(obj)).encode(\"utf-8\")",
            "    hasher.update(repr(items).encode(\"utf-8\"))",
            "    return hasher.hexdigest()",
            "",
            "",
            "def error_payload(",
            "    error: BaseException | None, show_error: bool",
            ") -> dict[str, bool | str | float | None]:",
            "    content: dict[str, bool | str | float | None] = {\"error\": None}",
            "    show_error = show_error or isinstance(error, Error)",
            "    if show_error:",
            "        content[\"error\"] = str(error)",
            "    if isinstance(error, Error):",
            "        content[\"duration\"] = error.duration",
            "        content[\"visible\"] = error.visible",
            "    return content",
            "",
            "",
            "class UnhashableKeyDict(MutableMapping):",
            "    \"\"\"",
            "    Essentially a list of key-value tuples that allows for keys that are not hashable,",
            "    but acts like a dictionary for convenience.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.data = []",
            "",
            "    def __getitem__(self, key):",
            "        for k, v in self.data:",
            "            if deep_equal(k, key):",
            "                return v",
            "        raise KeyError(key)",
            "",
            "    def __setitem__(self, key, value):",
            "        for i, (k, _) in enumerate(self.data):",
            "            if deep_equal(k, key):",
            "                self.data[i] = (key, value)",
            "                return",
            "        self.data.append((key, value))",
            "",
            "    def __delitem__(self, key):",
            "        for i, (k, _) in enumerate(self.data):",
            "            if deep_equal(k, key):",
            "                del self.data[i]",
            "                return",
            "        raise KeyError(key)",
            "",
            "    def __iter__(self):",
            "        return (k for k, _ in self.data)",
            "",
            "    def __len__(self):",
            "        return len(self.data)",
            "",
            "    def as_list(self):",
            "        return [v for _, v in self.data]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.twisted.web.client.URI.fromBytes"
        ]
    }
}