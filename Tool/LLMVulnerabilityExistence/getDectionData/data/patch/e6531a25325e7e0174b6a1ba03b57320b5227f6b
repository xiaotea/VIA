{
    "PyPDF2/_cmap.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from ._codecs import adobe_glyphs, charset_encoding"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from ._utils import logger_warning"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from .errors import PdfReadWarning"
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .generic import DecodedStreamObject, DictionaryObject"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from .generic import DecodedStreamObject, DictionaryObject, NameObject"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " # code freely inspired from @twiggy ; see #711"
            },
            "8": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "     enc: Union(str, DictionaryObject) = ft[\"/Encoding\"].get_object()  # type: ignore"
            },
            "9": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     if isinstance(enc, str):"
            },
            "10": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         try:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+            enc = NameObject.unnumber(enc)  # for #xx decoding"
            },
            "12": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "             if enc in charset_encoding:"
            },
            "13": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "                 encoding = charset_encoding[enc].copy()"
            },
            "14": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "             elif enc in _predefined_cmap:"
            }
        },
        "frontPatchFile": [
            "import warnings",
            "from binascii import unhexlify",
            "from typing import Any, Dict, List, Tuple, Union, cast",
            "",
            "from ._codecs import adobe_glyphs, charset_encoding",
            "from ._utils import logger_warning",
            "from .errors import PdfReadWarning",
            "from .generic import DecodedStreamObject, DictionaryObject",
            "",
            "",
            "# code freely inspired from @twiggy ; see #711",
            "def build_char_map(",
            "    font_name: str, space_width: float, obj: DictionaryObject",
            ") -> Tuple[",
            "    str, float, Union[str, Dict[int, str]], Dict",
            "]:  # font_type,space_width /2, encoding, cmap",
            "    ft: DictionaryObject = obj[\"/Resources\"][\"/Font\"][font_name]  # type: ignore",
            "    font_type: str = cast(str, ft[\"/Subtype\"])",
            "",
            "    space_code = 32",
            "    encoding, space_code = parse_encoding(ft, space_code)",
            "    map_dict, space_code, int_entry = parse_to_unicode(ft, space_code)",
            "",
            "    # encoding can be either a string for decode (on 1,2 or a variable number of bytes) of a char table (for 1 byte only for me)",
            "    # if empty string, it means it is than encoding field is not present and we have to select the good encoding from cmap input data",
            "    if encoding == \"\":",
            "        if -1 not in map_dict or map_dict[-1] == 1:",
            "            # I have not been able to find any rule for no /Encoding nor /ToUnicode",
            "            # One example shows /Symbol,bold I consider 8 bits encoding default",
            "            encoding = \"charmap\"",
            "        else:",
            "            encoding = \"utf-16-be\"",
            "    # apply rule from PDF ref 1.7 \u00a75.9.1, 1st bullet : if cmap not empty encoding should be discarded (here transformed into identity for those characters)",
            "    # if encoding is an str it is expected to be a identity translation",
            "    elif isinstance(encoding, dict):",
            "        for x in int_entry:",
            "            if x <= 255:",
            "                encoding[x] = chr(x)",
            "    try:",
            "        # override space_width with new params",
            "        space_width = _default_fonts_space_width[cast(str, ft[\"/BaseFont\"])]",
            "    except Exception:",
            "        pass",
            "    # I conside the space_code is available on one byte",
            "    if isinstance(space_code, str):",
            "        try:  # one byte",
            "            sp = space_code.encode(\"charmap\")[0]",
            "        except Exception:",
            "            sp = space_code.encode(\"utf-16-be\")",
            "            sp = sp[0] + 256 * sp[1]",
            "    else:",
            "        sp = space_code",
            "    sp_width = compute_space_width(ft, sp, space_width)",
            "",
            "    return (",
            "        font_type,",
            "        float(sp_width / 2),",
            "        encoding,",
            "        # https://github.com/python/mypy/issues/4374",
            "        map_dict,",
            "    )",
            "",
            "",
            "# used when missing data, e.g. font def missing",
            "unknown_char_map: Tuple[str, float, Union[str, Dict[int, str]], Dict[Any, Any]] = (",
            "    \"Unknown\",",
            "    9999,",
            "    dict(zip(range(256), [\"\ufffd\"] * 256)),",
            "    {},",
            ")",
            "",
            "",
            "_predefined_cmap: Dict[str, str] = {",
            "    \"/Identity-H\": \"utf-16-be\",",
            "    \"/Identity-V\": \"utf-16-be\",",
            "    \"/GB-EUC-H\": \"gbk\",  # TBC",
            "    \"/GB-EUC-V\": \"gbk\",  # TBC",
            "    \"/GBpc-EUC-H\": \"gb2312\",  # TBC",
            "    \"/GBpc-EUC-V\": \"gb2312\",  # TBC",
            "}",
            "",
            "",
            "# manually extracted from http://mirrors.ctan.org/fonts/adobe/afm/Adobe-Core35_AFMs-229.tar.gz",
            "_default_fonts_space_width: Dict[str, int] = {",
            "    \"/Courrier\": 600,",
            "    \"/Courier-Bold\": 600,",
            "    \"/Courier-BoldOblique\": 600,",
            "    \"/Courier-Oblique\": 600,",
            "    \"/Helvetica\": 278,",
            "    \"/Helvetica-Bold\": 278,",
            "    \"/Helvetica-BoldOblique\": 278,",
            "    \"/Helvetica-Oblique\": 278,",
            "    \"/Helvetica-Narrow\": 228,",
            "    \"/Helvetica-NarrowBold\": 228,",
            "    \"/Helvetica-NarrowBoldOblique\": 228,",
            "    \"/Helvetica-NarrowOblique\": 228,",
            "    \"/Times-Roman\": 250,",
            "    \"/Times-Bold\": 250,",
            "    \"/Times-BoldItalic\": 250,",
            "    \"/Times-Italic\": 250,",
            "    \"/Symbol\": 250,",
            "    \"/ZapfDingbats\": 278,",
            "}",
            "",
            "",
            "def parse_encoding(",
            "    ft: DictionaryObject, space_code: int",
            ") -> Tuple[Union[str, Dict[int, str]], int]:",
            "    encoding: Union[str, List[str], Dict[int, str]] = []",
            "    if \"/Encoding\" not in ft:",
            "        try:",
            "            if \"/BaseFont\" in ft and cast(str, ft[\"/BaseFont\"]) in charset_encoding:",
            "                encoding = dict(",
            "                    zip(range(256), charset_encoding[cast(str, ft[\"/BaseFont\"])])",
            "                )",
            "            else:",
            "                encoding = \"charmap\"",
            "            return encoding, _default_fonts_space_width[cast(str, ft[\"/BaseFont\"])]",
            "        except Exception:",
            "            if cast(str, ft[\"/Subtype\"]) == \"/Type1\":",
            "                return \"charmap\", space_code",
            "            else:",
            "                return \"\", space_code",
            "    enc: Union(str, DictionaryObject) = ft[\"/Encoding\"].get_object()  # type: ignore",
            "    if isinstance(enc, str):",
            "        try:",
            "            if enc in charset_encoding:",
            "                encoding = charset_encoding[enc].copy()",
            "            elif enc in _predefined_cmap:",
            "                encoding = _predefined_cmap[enc]",
            "            else:",
            "                raise Exception(\"not found\")",
            "        except Exception:",
            "            warnings.warn(",
            "                f\"Advanced encoding {enc} not implemented yet\",",
            "                PdfReadWarning,",
            "            )",
            "            encoding = enc",
            "    elif isinstance(enc, DictionaryObject) and \"/BaseEncoding\" in enc:",
            "        try:",
            "            encoding = charset_encoding[cast(str, enc[\"/BaseEncoding\"])].copy()",
            "        except Exception:",
            "            warnings.warn(",
            "                f\"Advanced encoding {encoding} not implemented yet\",",
            "                PdfReadWarning,",
            "            )",
            "            encoding = charset_encoding[\"/StandardCoding\"].copy()",
            "    else:",
            "        encoding = charset_encoding[\"/StandardCoding\"].copy()",
            "    if \"/Differences\" in enc:",
            "        x: int = 0",
            "        o: Union[int, str]",
            "        for o in cast(DictionaryObject, cast(DictionaryObject, enc)[\"/Differences\"]):",
            "            if isinstance(o, int):",
            "                x = o",
            "            else:  # isinstance(o,str):",
            "                try:",
            "                    encoding[x] = adobe_glyphs[o]  # type: ignore",
            "                except Exception:",
            "                    encoding[x] = o  # type: ignore",
            "                    if o == \" \":",
            "                        space_code = x",
            "                x += 1",
            "    if isinstance(encoding, list):",
            "        encoding = dict(zip(range(256), encoding))",
            "    return encoding, space_code",
            "",
            "",
            "def parse_to_unicode(",
            "    ft: DictionaryObject, space_code: int",
            ") -> Tuple[Dict[Any, Any], int, List[int]]:",
            "    # will store all translation code",
            "    # and map_dict[-1] we will have the number of bytes to convert",
            "    map_dict: Dict[Any, Any] = {}",
            "",
            "    # will provide the list of cmap keys as int to correct encoding",
            "    int_entry: List[int] = []",
            "",
            "    if \"/ToUnicode\" not in ft:",
            "        return {}, space_code, []",
            "    process_rg: bool = False",
            "    process_char: bool = False",
            "    multiline_rg: Union[",
            "        None, Tuple[int, int]",
            "    ] = None  # tuple = (current_char, remaining size) ; cf #1285 for example of file",
            "    cm = prepare_cm(ft)",
            "    for l in cm.split(b\"\\n\"):",
            "        process_rg, process_char, multiline_rg = process_cm_line(",
            "            l.strip(b\" \"), process_rg, process_char, multiline_rg, map_dict, int_entry",
            "        )",
            "",
            "    for a, value in map_dict.items():",
            "        if value == \" \":",
            "            space_code = a",
            "    return map_dict, space_code, int_entry",
            "",
            "",
            "def prepare_cm(ft: DictionaryObject) -> bytes:",
            "    cm: bytes = cast(DecodedStreamObject, ft[\"/ToUnicode\"]).get_data()",
            "    # we need to prepare cm before due to missing return line in pdf printed to pdf from word",
            "    cm = (",
            "        cm.strip()",
            "        .replace(b\"beginbfchar\", b\"\\nbeginbfchar\\n\")",
            "        .replace(b\"endbfchar\", b\"\\nendbfchar\\n\")",
            "        .replace(b\"beginbfrange\", b\"\\nbeginbfrange\\n\")",
            "        .replace(b\"endbfrange\", b\"\\nendbfrange\\n\")",
            "        .replace(b\"<<\", b\"\\n{\\n\")  # text between << and >> not used but",
            "        .replace(b\">>\", b\"\\n}\\n\")  # some solution to find it back",
            "    )",
            "    ll = cm.split(b\"<\")",
            "    for i in range(len(ll)):",
            "        j = ll[i].find(b\">\")",
            "        if j >= 0:",
            "            if j == 0:",
            "                # string is empty: stash a placeholder here (see below)",
            "                # see https://github.com/py-pdf/PyPDF2/issues/1111",
            "                content = b\".\"",
            "            else:",
            "                content = ll[i][:j].replace(b\" \", b\"\")",
            "            ll[i] = content + b\" \" + ll[i][j + 1 :]",
            "    cm = (",
            "        (b\" \".join(ll))",
            "        .replace(b\"[\", b\" [ \")",
            "        .replace(b\"]\", b\" ]\\n \")",
            "        .replace(b\"\\r\", b\"\\n\")",
            "    )",
            "    return cm",
            "",
            "",
            "def process_cm_line(",
            "    l: bytes,",
            "    process_rg: bool,",
            "    process_char: bool,",
            "    multiline_rg: Union[None, Tuple[int, int]],",
            "    map_dict: Dict[Any, Any],",
            "    int_entry: List[int],",
            ") -> Tuple[bool, bool, Union[None, Tuple[int, int]]]:",
            "    if l in (b\"\", b\" \") or l[0] == 37:  # 37 = %",
            "        return process_rg, process_char, multiline_rg",
            "    if b\"beginbfrange\" in l:",
            "        process_rg = True",
            "    elif b\"endbfrange\" in l:",
            "        process_rg = False",
            "    elif b\"beginbfchar\" in l:",
            "        process_char = True",
            "    elif b\"endbfchar\" in l:",
            "        process_char = False",
            "    elif process_rg:",
            "        multiline_rg = parse_bfrange(l, map_dict, int_entry, multiline_rg)",
            "    elif process_char:",
            "        parse_bfchar(l, map_dict, int_entry)",
            "    return process_rg, process_char, multiline_rg",
            "",
            "",
            "def parse_bfrange(",
            "    l: bytes,",
            "    map_dict: Dict[Any, Any],",
            "    int_entry: List[int],",
            "    multiline_rg: Union[None, Tuple[int, int]],",
            ") -> Union[None, Tuple[int, int]]:",
            "    lst = [x for x in l.split(b\" \") if x]",
            "    closure_found = False",
            "    nbi = len(lst[0])",
            "    map_dict[-1] = nbi // 2",
            "    fmt = b\"%%0%dX\" % nbi",
            "    if multiline_rg is not None:",
            "        a = multiline_rg[0]  # a, b not in the current line",
            "        b = multiline_rg[1]",
            "        for sq in lst[1:]:",
            "            if sq == b\"]\":",
            "                closure_found = True",
            "                break",
            "            map_dict[",
            "                unhexlify(fmt % a).decode(",
            "                    \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\",",
            "                    \"surrogatepass\",",
            "                )",
            "            ] = unhexlify(sq).decode(\"utf-16-be\", \"surrogatepass\")",
            "            int_entry.append(a)",
            "            a += 1",
            "    else:",
            "        a = int(lst[0], 16)",
            "        b = int(lst[1], 16)",
            "        if lst[2] == b\"[\":",
            "            for sq in lst[3:]:",
            "                if sq == b\"]\":",
            "                    closure_found = True",
            "                    break",
            "                map_dict[",
            "                    unhexlify(fmt % a).decode(",
            "                        \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\",",
            "                        \"surrogatepass\",",
            "                    )",
            "                ] = unhexlify(sq).decode(\"utf-16-be\", \"surrogatepass\")",
            "                int_entry.append(a)",
            "                a += 1",
            "        else:  # case without list",
            "            c = int(lst[2], 16)",
            "            fmt2 = b\"%%0%dX\" % max(4, len(lst[2]))",
            "            closure_found = True",
            "            while a <= b:",
            "                map_dict[",
            "                    unhexlify(fmt % a).decode(",
            "                        \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\",",
            "                        \"surrogatepass\",",
            "                    )",
            "                ] = unhexlify(fmt2 % c).decode(\"utf-16-be\", \"surrogatepass\")",
            "                int_entry.append(a)",
            "                a += 1",
            "                c += 1",
            "    return None if closure_found else (a, b)",
            "",
            "",
            "def parse_bfchar(l: bytes, map_dict: Dict[Any, Any], int_entry: List[int]) -> None:",
            "    lst = [x for x in l.split(b\" \") if x]",
            "    map_dict[-1] = len(lst[0]) // 2",
            "    while len(lst) > 1:",
            "        map_to = \"\"",
            "        # placeholder (see above) means empty string",
            "        if lst[1] != b\".\":",
            "            map_to = unhexlify(lst[1]).decode(",
            "                \"charmap\" if len(lst[1]) < 4 else \"utf-16-be\", \"surrogatepass\"",
            "            )  # join is here as some cases where the code was split",
            "        map_dict[",
            "            unhexlify(lst[0]).decode(",
            "                \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\", \"surrogatepass\"",
            "            )",
            "        ] = map_to",
            "        int_entry.append(int(lst[0], 16))",
            "        lst = lst[2:]",
            "",
            "",
            "def compute_space_width(",
            "    ft: DictionaryObject, space_code: int, space_width: float",
            ") -> float:",
            "    sp_width: float = space_width * 2  # default value",
            "    w = []",
            "    w1 = {}",
            "    st: int = 0",
            "    if \"/DescendantFonts\" in ft:  # ft[\"/Subtype\"].startswith(\"/CIDFontType\"):",
            "        ft1 = ft[\"/DescendantFonts\"][0].get_object()  # type: ignore",
            "        try:",
            "            w1[-1] = cast(float, ft1[\"/DW\"])",
            "        except Exception:",
            "            w1[-1] = 1000.0",
            "        if \"/W\" in ft1:",
            "            w = list(ft1[\"/W\"])",
            "        else:",
            "            w = []",
            "        while len(w) > 0:",
            "            st = w[0]",
            "            second = w[1]",
            "            if isinstance(second, int):",
            "                for x in range(st, second):",
            "                    w1[x] = w[2]",
            "                w = w[3:]",
            "            elif isinstance(second, list):",
            "                for y in second:",
            "                    w1[st] = y",
            "                    st += 1",
            "                w = w[2:]",
            "            else:",
            "                logger_warning(",
            "                    \"unknown widths : \\n\" + (ft1[\"/W\"]).__repr__(),",
            "                    __name__,",
            "                )",
            "                break",
            "        try:",
            "            sp_width = w1[space_code]",
            "        except Exception:",
            "            sp_width = (",
            "                w1[-1] / 2.0",
            "            )  # if using default we consider space will be only half size",
            "    elif \"/Widths\" in ft:",
            "        w = list(ft[\"/Widths\"])  # type: ignore",
            "        try:",
            "            st = cast(int, ft[\"/FirstChar\"])",
            "            en: int = cast(int, ft[\"/LastChar\"])",
            "            if st > space_code or en < space_code:",
            "                raise Exception(\"Not in range\")",
            "            if w[space_code - st] == 0:",
            "                raise Exception(\"null width\")",
            "            sp_width = w[space_code - st]",
            "        except Exception:",
            "            if \"/FontDescriptor\" in ft and \"/MissingWidth\" in cast(",
            "                DictionaryObject, ft[\"/FontDescriptor\"]",
            "            ):",
            "                sp_width = ft[\"/FontDescriptor\"][\"/MissingWidth\"]  # type: ignore",
            "            else:",
            "                # will consider width of char as avg(width)/2",
            "                m = 0",
            "                cpt = 0",
            "                for x in w:",
            "                    if x > 0:",
            "                        m += x",
            "                        cpt += 1",
            "                sp_width = m / max(1, cpt) / 2",
            "    return sp_width"
        ],
        "afterPatchFile": [
            "import warnings",
            "from binascii import unhexlify",
            "from typing import Any, Dict, List, Tuple, Union, cast",
            "",
            "from ._codecs import adobe_glyphs, charset_encoding",
            "from ._utils import logger_warning",
            "from .errors import PdfReadWarning",
            "from .generic import DecodedStreamObject, DictionaryObject, NameObject",
            "",
            "",
            "# code freely inspired from @twiggy ; see #711",
            "def build_char_map(",
            "    font_name: str, space_width: float, obj: DictionaryObject",
            ") -> Tuple[",
            "    str, float, Union[str, Dict[int, str]], Dict",
            "]:  # font_type,space_width /2, encoding, cmap",
            "    ft: DictionaryObject = obj[\"/Resources\"][\"/Font\"][font_name]  # type: ignore",
            "    font_type: str = cast(str, ft[\"/Subtype\"])",
            "",
            "    space_code = 32",
            "    encoding, space_code = parse_encoding(ft, space_code)",
            "    map_dict, space_code, int_entry = parse_to_unicode(ft, space_code)",
            "",
            "    # encoding can be either a string for decode (on 1,2 or a variable number of bytes) of a char table (for 1 byte only for me)",
            "    # if empty string, it means it is than encoding field is not present and we have to select the good encoding from cmap input data",
            "    if encoding == \"\":",
            "        if -1 not in map_dict or map_dict[-1] == 1:",
            "            # I have not been able to find any rule for no /Encoding nor /ToUnicode",
            "            # One example shows /Symbol,bold I consider 8 bits encoding default",
            "            encoding = \"charmap\"",
            "        else:",
            "            encoding = \"utf-16-be\"",
            "    # apply rule from PDF ref 1.7 \u00a75.9.1, 1st bullet : if cmap not empty encoding should be discarded (here transformed into identity for those characters)",
            "    # if encoding is an str it is expected to be a identity translation",
            "    elif isinstance(encoding, dict):",
            "        for x in int_entry:",
            "            if x <= 255:",
            "                encoding[x] = chr(x)",
            "    try:",
            "        # override space_width with new params",
            "        space_width = _default_fonts_space_width[cast(str, ft[\"/BaseFont\"])]",
            "    except Exception:",
            "        pass",
            "    # I conside the space_code is available on one byte",
            "    if isinstance(space_code, str):",
            "        try:  # one byte",
            "            sp = space_code.encode(\"charmap\")[0]",
            "        except Exception:",
            "            sp = space_code.encode(\"utf-16-be\")",
            "            sp = sp[0] + 256 * sp[1]",
            "    else:",
            "        sp = space_code",
            "    sp_width = compute_space_width(ft, sp, space_width)",
            "",
            "    return (",
            "        font_type,",
            "        float(sp_width / 2),",
            "        encoding,",
            "        # https://github.com/python/mypy/issues/4374",
            "        map_dict,",
            "    )",
            "",
            "",
            "# used when missing data, e.g. font def missing",
            "unknown_char_map: Tuple[str, float, Union[str, Dict[int, str]], Dict[Any, Any]] = (",
            "    \"Unknown\",",
            "    9999,",
            "    dict(zip(range(256), [\"\ufffd\"] * 256)),",
            "    {},",
            ")",
            "",
            "",
            "_predefined_cmap: Dict[str, str] = {",
            "    \"/Identity-H\": \"utf-16-be\",",
            "    \"/Identity-V\": \"utf-16-be\",",
            "    \"/GB-EUC-H\": \"gbk\",  # TBC",
            "    \"/GB-EUC-V\": \"gbk\",  # TBC",
            "    \"/GBpc-EUC-H\": \"gb2312\",  # TBC",
            "    \"/GBpc-EUC-V\": \"gb2312\",  # TBC",
            "}",
            "",
            "",
            "# manually extracted from http://mirrors.ctan.org/fonts/adobe/afm/Adobe-Core35_AFMs-229.tar.gz",
            "_default_fonts_space_width: Dict[str, int] = {",
            "    \"/Courrier\": 600,",
            "    \"/Courier-Bold\": 600,",
            "    \"/Courier-BoldOblique\": 600,",
            "    \"/Courier-Oblique\": 600,",
            "    \"/Helvetica\": 278,",
            "    \"/Helvetica-Bold\": 278,",
            "    \"/Helvetica-BoldOblique\": 278,",
            "    \"/Helvetica-Oblique\": 278,",
            "    \"/Helvetica-Narrow\": 228,",
            "    \"/Helvetica-NarrowBold\": 228,",
            "    \"/Helvetica-NarrowBoldOblique\": 228,",
            "    \"/Helvetica-NarrowOblique\": 228,",
            "    \"/Times-Roman\": 250,",
            "    \"/Times-Bold\": 250,",
            "    \"/Times-BoldItalic\": 250,",
            "    \"/Times-Italic\": 250,",
            "    \"/Symbol\": 250,",
            "    \"/ZapfDingbats\": 278,",
            "}",
            "",
            "",
            "def parse_encoding(",
            "    ft: DictionaryObject, space_code: int",
            ") -> Tuple[Union[str, Dict[int, str]], int]:",
            "    encoding: Union[str, List[str], Dict[int, str]] = []",
            "    if \"/Encoding\" not in ft:",
            "        try:",
            "            if \"/BaseFont\" in ft and cast(str, ft[\"/BaseFont\"]) in charset_encoding:",
            "                encoding = dict(",
            "                    zip(range(256), charset_encoding[cast(str, ft[\"/BaseFont\"])])",
            "                )",
            "            else:",
            "                encoding = \"charmap\"",
            "            return encoding, _default_fonts_space_width[cast(str, ft[\"/BaseFont\"])]",
            "        except Exception:",
            "            if cast(str, ft[\"/Subtype\"]) == \"/Type1\":",
            "                return \"charmap\", space_code",
            "            else:",
            "                return \"\", space_code",
            "    enc: Union(str, DictionaryObject) = ft[\"/Encoding\"].get_object()  # type: ignore",
            "    if isinstance(enc, str):",
            "        try:",
            "            enc = NameObject.unnumber(enc)  # for #xx decoding",
            "            if enc in charset_encoding:",
            "                encoding = charset_encoding[enc].copy()",
            "            elif enc in _predefined_cmap:",
            "                encoding = _predefined_cmap[enc]",
            "            else:",
            "                raise Exception(\"not found\")",
            "        except Exception:",
            "            warnings.warn(",
            "                f\"Advanced encoding {enc} not implemented yet\",",
            "                PdfReadWarning,",
            "            )",
            "            encoding = enc",
            "    elif isinstance(enc, DictionaryObject) and \"/BaseEncoding\" in enc:",
            "        try:",
            "            encoding = charset_encoding[cast(str, enc[\"/BaseEncoding\"])].copy()",
            "        except Exception:",
            "            warnings.warn(",
            "                f\"Advanced encoding {encoding} not implemented yet\",",
            "                PdfReadWarning,",
            "            )",
            "            encoding = charset_encoding[\"/StandardCoding\"].copy()",
            "    else:",
            "        encoding = charset_encoding[\"/StandardCoding\"].copy()",
            "    if \"/Differences\" in enc:",
            "        x: int = 0",
            "        o: Union[int, str]",
            "        for o in cast(DictionaryObject, cast(DictionaryObject, enc)[\"/Differences\"]):",
            "            if isinstance(o, int):",
            "                x = o",
            "            else:  # isinstance(o,str):",
            "                try:",
            "                    encoding[x] = adobe_glyphs[o]  # type: ignore",
            "                except Exception:",
            "                    encoding[x] = o  # type: ignore",
            "                    if o == \" \":",
            "                        space_code = x",
            "                x += 1",
            "    if isinstance(encoding, list):",
            "        encoding = dict(zip(range(256), encoding))",
            "    return encoding, space_code",
            "",
            "",
            "def parse_to_unicode(",
            "    ft: DictionaryObject, space_code: int",
            ") -> Tuple[Dict[Any, Any], int, List[int]]:",
            "    # will store all translation code",
            "    # and map_dict[-1] we will have the number of bytes to convert",
            "    map_dict: Dict[Any, Any] = {}",
            "",
            "    # will provide the list of cmap keys as int to correct encoding",
            "    int_entry: List[int] = []",
            "",
            "    if \"/ToUnicode\" not in ft:",
            "        return {}, space_code, []",
            "    process_rg: bool = False",
            "    process_char: bool = False",
            "    multiline_rg: Union[",
            "        None, Tuple[int, int]",
            "    ] = None  # tuple = (current_char, remaining size) ; cf #1285 for example of file",
            "    cm = prepare_cm(ft)",
            "    for l in cm.split(b\"\\n\"):",
            "        process_rg, process_char, multiline_rg = process_cm_line(",
            "            l.strip(b\" \"), process_rg, process_char, multiline_rg, map_dict, int_entry",
            "        )",
            "",
            "    for a, value in map_dict.items():",
            "        if value == \" \":",
            "            space_code = a",
            "    return map_dict, space_code, int_entry",
            "",
            "",
            "def prepare_cm(ft: DictionaryObject) -> bytes:",
            "    cm: bytes = cast(DecodedStreamObject, ft[\"/ToUnicode\"]).get_data()",
            "    # we need to prepare cm before due to missing return line in pdf printed to pdf from word",
            "    cm = (",
            "        cm.strip()",
            "        .replace(b\"beginbfchar\", b\"\\nbeginbfchar\\n\")",
            "        .replace(b\"endbfchar\", b\"\\nendbfchar\\n\")",
            "        .replace(b\"beginbfrange\", b\"\\nbeginbfrange\\n\")",
            "        .replace(b\"endbfrange\", b\"\\nendbfrange\\n\")",
            "        .replace(b\"<<\", b\"\\n{\\n\")  # text between << and >> not used but",
            "        .replace(b\">>\", b\"\\n}\\n\")  # some solution to find it back",
            "    )",
            "    ll = cm.split(b\"<\")",
            "    for i in range(len(ll)):",
            "        j = ll[i].find(b\">\")",
            "        if j >= 0:",
            "            if j == 0:",
            "                # string is empty: stash a placeholder here (see below)",
            "                # see https://github.com/py-pdf/PyPDF2/issues/1111",
            "                content = b\".\"",
            "            else:",
            "                content = ll[i][:j].replace(b\" \", b\"\")",
            "            ll[i] = content + b\" \" + ll[i][j + 1 :]",
            "    cm = (",
            "        (b\" \".join(ll))",
            "        .replace(b\"[\", b\" [ \")",
            "        .replace(b\"]\", b\" ]\\n \")",
            "        .replace(b\"\\r\", b\"\\n\")",
            "    )",
            "    return cm",
            "",
            "",
            "def process_cm_line(",
            "    l: bytes,",
            "    process_rg: bool,",
            "    process_char: bool,",
            "    multiline_rg: Union[None, Tuple[int, int]],",
            "    map_dict: Dict[Any, Any],",
            "    int_entry: List[int],",
            ") -> Tuple[bool, bool, Union[None, Tuple[int, int]]]:",
            "    if l in (b\"\", b\" \") or l[0] == 37:  # 37 = %",
            "        return process_rg, process_char, multiline_rg",
            "    if b\"beginbfrange\" in l:",
            "        process_rg = True",
            "    elif b\"endbfrange\" in l:",
            "        process_rg = False",
            "    elif b\"beginbfchar\" in l:",
            "        process_char = True",
            "    elif b\"endbfchar\" in l:",
            "        process_char = False",
            "    elif process_rg:",
            "        multiline_rg = parse_bfrange(l, map_dict, int_entry, multiline_rg)",
            "    elif process_char:",
            "        parse_bfchar(l, map_dict, int_entry)",
            "    return process_rg, process_char, multiline_rg",
            "",
            "",
            "def parse_bfrange(",
            "    l: bytes,",
            "    map_dict: Dict[Any, Any],",
            "    int_entry: List[int],",
            "    multiline_rg: Union[None, Tuple[int, int]],",
            ") -> Union[None, Tuple[int, int]]:",
            "    lst = [x for x in l.split(b\" \") if x]",
            "    closure_found = False",
            "    nbi = len(lst[0])",
            "    map_dict[-1] = nbi // 2",
            "    fmt = b\"%%0%dX\" % nbi",
            "    if multiline_rg is not None:",
            "        a = multiline_rg[0]  # a, b not in the current line",
            "        b = multiline_rg[1]",
            "        for sq in lst[1:]:",
            "            if sq == b\"]\":",
            "                closure_found = True",
            "                break",
            "            map_dict[",
            "                unhexlify(fmt % a).decode(",
            "                    \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\",",
            "                    \"surrogatepass\",",
            "                )",
            "            ] = unhexlify(sq).decode(\"utf-16-be\", \"surrogatepass\")",
            "            int_entry.append(a)",
            "            a += 1",
            "    else:",
            "        a = int(lst[0], 16)",
            "        b = int(lst[1], 16)",
            "        if lst[2] == b\"[\":",
            "            for sq in lst[3:]:",
            "                if sq == b\"]\":",
            "                    closure_found = True",
            "                    break",
            "                map_dict[",
            "                    unhexlify(fmt % a).decode(",
            "                        \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\",",
            "                        \"surrogatepass\",",
            "                    )",
            "                ] = unhexlify(sq).decode(\"utf-16-be\", \"surrogatepass\")",
            "                int_entry.append(a)",
            "                a += 1",
            "        else:  # case without list",
            "            c = int(lst[2], 16)",
            "            fmt2 = b\"%%0%dX\" % max(4, len(lst[2]))",
            "            closure_found = True",
            "            while a <= b:",
            "                map_dict[",
            "                    unhexlify(fmt % a).decode(",
            "                        \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\",",
            "                        \"surrogatepass\",",
            "                    )",
            "                ] = unhexlify(fmt2 % c).decode(\"utf-16-be\", \"surrogatepass\")",
            "                int_entry.append(a)",
            "                a += 1",
            "                c += 1",
            "    return None if closure_found else (a, b)",
            "",
            "",
            "def parse_bfchar(l: bytes, map_dict: Dict[Any, Any], int_entry: List[int]) -> None:",
            "    lst = [x for x in l.split(b\" \") if x]",
            "    map_dict[-1] = len(lst[0]) // 2",
            "    while len(lst) > 1:",
            "        map_to = \"\"",
            "        # placeholder (see above) means empty string",
            "        if lst[1] != b\".\":",
            "            map_to = unhexlify(lst[1]).decode(",
            "                \"charmap\" if len(lst[1]) < 4 else \"utf-16-be\", \"surrogatepass\"",
            "            )  # join is here as some cases where the code was split",
            "        map_dict[",
            "            unhexlify(lst[0]).decode(",
            "                \"charmap\" if map_dict[-1] == 1 else \"utf-16-be\", \"surrogatepass\"",
            "            )",
            "        ] = map_to",
            "        int_entry.append(int(lst[0], 16))",
            "        lst = lst[2:]",
            "",
            "",
            "def compute_space_width(",
            "    ft: DictionaryObject, space_code: int, space_width: float",
            ") -> float:",
            "    sp_width: float = space_width * 2  # default value",
            "    w = []",
            "    w1 = {}",
            "    st: int = 0",
            "    if \"/DescendantFonts\" in ft:  # ft[\"/Subtype\"].startswith(\"/CIDFontType\"):",
            "        ft1 = ft[\"/DescendantFonts\"][0].get_object()  # type: ignore",
            "        try:",
            "            w1[-1] = cast(float, ft1[\"/DW\"])",
            "        except Exception:",
            "            w1[-1] = 1000.0",
            "        if \"/W\" in ft1:",
            "            w = list(ft1[\"/W\"])",
            "        else:",
            "            w = []",
            "        while len(w) > 0:",
            "            st = w[0]",
            "            second = w[1]",
            "            if isinstance(second, int):",
            "                for x in range(st, second):",
            "                    w1[x] = w[2]",
            "                w = w[3:]",
            "            elif isinstance(second, list):",
            "                for y in second:",
            "                    w1[st] = y",
            "                    st += 1",
            "                w = w[2:]",
            "            else:",
            "                logger_warning(",
            "                    \"unknown widths : \\n\" + (ft1[\"/W\"]).__repr__(),",
            "                    __name__,",
            "                )",
            "                break",
            "        try:",
            "            sp_width = w1[space_code]",
            "        except Exception:",
            "            sp_width = (",
            "                w1[-1] / 2.0",
            "            )  # if using default we consider space will be only half size",
            "    elif \"/Widths\" in ft:",
            "        w = list(ft[\"/Widths\"])  # type: ignore",
            "        try:",
            "            st = cast(int, ft[\"/FirstChar\"])",
            "            en: int = cast(int, ft[\"/LastChar\"])",
            "            if st > space_code or en < space_code:",
            "                raise Exception(\"Not in range\")",
            "            if w[space_code - st] == 0:",
            "                raise Exception(\"null width\")",
            "            sp_width = w[space_code - st]",
            "        except Exception:",
            "            if \"/FontDescriptor\" in ft and \"/MissingWidth\" in cast(",
            "                DictionaryObject, ft[\"/FontDescriptor\"]",
            "            ):",
            "                sp_width = ft[\"/FontDescriptor\"][\"/MissingWidth\"]  # type: ignore",
            "            else:",
            "                # will consider width of char as avg(width)/2",
            "                m = 0",
            "                cpt = 0",
            "                for x in w:",
            "                    if x > 0:",
            "                        m += x",
            "                        cpt += 1",
            "                sp_width = m / max(1, cpt) / 2",
            "    return sp_width"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": []
        },
        "addLocation": []
    },
    "PyPDF2/_reader.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1139,
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "                     buf = bytes(self.stream.getbuffer())  # type: ignore"
            },
            "1": {
                "beforePatchRowNumber": 1140,
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "                 else:"
            },
            "2": {
                "beforePatchRowNumber": 1141,
                "afterPatchRowNumber": 1141,
                "PatchRowcode": "                     p = self.stream.tell()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1142,
                "PatchRowcode": "+                    self.stream.seek(0, 0)"
            },
            "4": {
                "beforePatchRowNumber": 1142,
                "afterPatchRowNumber": 1143,
                "PatchRowcode": "                     buf = self.stream.read(-1)"
            },
            "5": {
                "beforePatchRowNumber": 1143,
                "afterPatchRowNumber": 1144,
                "PatchRowcode": "                     self.stream.seek(p, 0)"
            },
            "6": {
                "beforePatchRowNumber": 1144,
                "afterPatchRowNumber": 1145,
                "PatchRowcode": "                 m = re.search("
            },
            "7": {
                "beforePatchRowNumber": 1192,
                "afterPatchRowNumber": 1193,
                "PatchRowcode": "                 buf = bytes(self.stream.getbuffer())  # type: ignore"
            },
            "8": {
                "beforePatchRowNumber": 1193,
                "afterPatchRowNumber": 1194,
                "PatchRowcode": "             else:"
            },
            "9": {
                "beforePatchRowNumber": 1194,
                "afterPatchRowNumber": 1195,
                "PatchRowcode": "                 p = self.stream.tell()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1196,
                "PatchRowcode": "+                self.stream.seek(0, 0)"
            },
            "11": {
                "beforePatchRowNumber": 1195,
                "afterPatchRowNumber": 1197,
                "PatchRowcode": "                 buf = self.stream.read(-1)"
            },
            "12": {
                "beforePatchRowNumber": 1196,
                "afterPatchRowNumber": 1198,
                "PatchRowcode": "                 self.stream.seek(p, 0)"
            },
            "13": {
                "beforePatchRowNumber": 1197,
                "afterPatchRowNumber": 1199,
                "PatchRowcode": "             m = re.search("
            },
            "14": {
                "beforePatchRowNumber": 1883,
                "afterPatchRowNumber": 1885,
                "PatchRowcode": "                         retval[tag] = es"
            },
            "15": {
                "beforePatchRowNumber": 1884,
                "afterPatchRowNumber": 1886,
                "PatchRowcode": "         return retval"
            },
            "16": {
                "beforePatchRowNumber": 1885,
                "afterPatchRowNumber": 1887,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1888,
                "PatchRowcode": "+    def _get_indirect_object(self, num: int, gen: int) -> Optional[PdfObject]:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1889,
                "PatchRowcode": "+        \"\"\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1890,
                "PatchRowcode": "+        used to ease development"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1891,
                "PatchRowcode": "+        equivalent to generic.IndirectObject(num,gen,self).get_object()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1892,
                "PatchRowcode": "+        \"\"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1893,
                "PatchRowcode": "+        return IndirectObject(num, gen, self).get_object()"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1894,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 1886,
                "afterPatchRowNumber": 1895,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 1887,
                "afterPatchRowNumber": 1896,
                "PatchRowcode": " class PdfFileReader(PdfReader):  # pragma: no cover"
            },
            "26": {
                "beforePatchRowNumber": 1888,
                "afterPatchRowNumber": 1897,
                "PatchRowcode": "     def __init__(self, *args: Any, **kwargs: Any) -> None:"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2006, Mathieu Fenniak",
            "# Copyright (c) 2007, Ashish Kulkarni <kulkarni.ashish@gmail.com>",
            "#",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without",
            "# modification, are permitted provided that the following conditions are",
            "# met:",
            "#",
            "# * Redistributions of source code must retain the above copyright notice,",
            "# this list of conditions and the following disclaimer.",
            "# * Redistributions in binary form must reproduce the above copyright notice,",
            "# this list of conditions and the following disclaimer in the documentation",
            "# and/or other materials provided with the distribution.",
            "# * The name of the author may not be used to endorse or promote products",
            "# derived from this software without specific prior written permission.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
            "# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
            "# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
            "# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
            "# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
            "# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
            "# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
            "# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
            "# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
            "# POSSIBILITY OF SUCH DAMAGE.",
            "",
            "import os",
            "import re",
            "import struct",
            "import zlib",
            "from io import BytesIO",
            "from pathlib import Path",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from ._encryption import Encryption, PasswordType",
            "from ._page import PageObject, _VirtualList",
            "from ._utils import (",
            "    StrByteType,",
            "    StreamType,",
            "    b_,",
            "    deprecate_no_replacement,",
            "    deprecate_with_replacement,",
            "    logger_warning,",
            "    read_non_whitespace,",
            "    read_previous_line,",
            "    read_until_whitespace,",
            "    skip_over_comment,",
            "    skip_over_whitespace,",
            ")",
            "from .constants import CatalogAttributes as CA",
            "from .constants import CatalogDictionary as CD",
            "from .constants import CheckboxRadioButtonAttributes",
            "from .constants import Core as CO",
            "from .constants import DocumentInformationAttributes as DI",
            "from .constants import FieldDictionaryAttributes, GoToActionArguments",
            "from .constants import PageAttributes as PG",
            "from .constants import PagesAttributes as PA",
            "from .constants import TrailerKeys as TK",
            "from .errors import (",
            "    EmptyFileError,",
            "    FileNotDecryptedError,",
            "    PdfReadError,",
            "    PdfStreamError,",
            "    WrongPasswordError,",
            ")",
            "from .generic import (",
            "    ArrayObject,",
            "    ContentStream,",
            "    DecodedStreamObject,",
            "    Destination,",
            "    DictionaryObject,",
            "    EncodedStreamObject,",
            "    Field,",
            "    FloatObject,",
            "    IndirectObject,",
            "    NameObject,",
            "    NullObject,",
            "    NumberObject,",
            "    PdfObject,",
            "    TextStringObject,",
            "    TreeObject,",
            "    read_object,",
            ")",
            "from .types import OutlineType, PagemodeType",
            "from .xmp import XmpInformation",
            "",
            "",
            "def convert_to_int(d: bytes, size: int) -> Union[int, Tuple[Any, ...]]:",
            "    if size > 8:",
            "        raise PdfReadError(\"invalid size in convert_to_int\")",
            "    d = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + d",
            "    d = d[-8:]",
            "    return struct.unpack(\">q\", d)[0]",
            "",
            "",
            "def convertToInt(",
            "    d: bytes, size: int",
            ") -> Union[int, Tuple[Any, ...]]:  # pragma: no cover",
            "    deprecate_with_replacement(\"convertToInt\", \"convert_to_int\")",
            "    return convert_to_int(d, size)",
            "",
            "",
            "class DocumentInformation(DictionaryObject):",
            "    \"\"\"",
            "    A class representing the basic document metadata provided in a PDF File.",
            "    This class is accessible through :py:class:`PdfReader.metadata<PyPDF2.PdfReader.metadata>`.",
            "",
            "    All text properties of the document metadata have",
            "    *two* properties, eg. author and author_raw. The non-raw property will",
            "    always return a ``TextStringObject``, making it ideal for a case where",
            "    the metadata is being displayed. The raw property can sometimes return",
            "    a ``ByteStringObject``, if PyPDF2 was unable to decode the string's",
            "    text encoding; this requires additional safety in the caller and",
            "    therefore is not as commonly accessed.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        DictionaryObject.__init__(self)",
            "",
            "    def _get_text(self, key: str) -> Optional[str]:",
            "        retval = self.get(key, None)",
            "        if isinstance(retval, TextStringObject):",
            "            return retval",
            "        return None",
            "",
            "    def getText(self, key: str) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        The text value of the specified key or None.",
            "",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attributes (e.g. :py:attr:`title` / :py:attr:`author`).",
            "        \"\"\"",
            "        deprecate_no_replacement(\"getText\")",
            "        return self._get_text(key)",
            "",
            "    @property",
            "    def title(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **title**.",
            "",
            "        Returns a unicode string (``TextStringObject``) or ``None``",
            "        if the title is not specified.",
            "        \"\"\"",
            "        return (",
            "            self._get_text(DI.TITLE) or self.get(DI.TITLE).get_object()  # type: ignore",
            "            if self.get(DI.TITLE)",
            "            else None",
            "        )",
            "",
            "    @property",
            "    def title_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of title; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.TITLE)",
            "",
            "    @property",
            "    def author(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **author**.",
            "",
            "        Returns a unicode string (``TextStringObject``) or ``None``",
            "        if the author is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.AUTHOR)",
            "",
            "    @property",
            "    def author_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of author; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.AUTHOR)",
            "",
            "    @property",
            "    def subject(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **subject**.",
            "",
            "        Returns a unicode string (``TextStringObject``) or ``None``",
            "        if the subject is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.SUBJECT)",
            "",
            "    @property",
            "    def subject_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of subject; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.SUBJECT)",
            "",
            "    @property",
            "    def creator(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **creator**.",
            "",
            "        If the document was converted to PDF from another format, this is the",
            "        name of the application (e.g. OpenOffice) that created the original",
            "        document from which it was converted. Returns a unicode string",
            "        (``TextStringObject``) or ``None`` if the creator is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.CREATOR)",
            "",
            "    @property",
            "    def creator_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of creator; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.CREATOR)",
            "",
            "    @property",
            "    def producer(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **producer**.",
            "",
            "        If the document was converted to PDF from another format, this is",
            "        the name of the application (for example, OSX Quartz) that converted",
            "        it to PDF. Returns a unicode string (``TextStringObject``)",
            "        or ``None`` if the producer is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.PRODUCER)",
            "",
            "    @property",
            "    def producer_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of producer; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.PRODUCER)",
            "",
            "",
            "class PdfReader:",
            "    \"\"\"",
            "    Initialize a PdfReader object.",
            "",
            "    This operation can take some time, as the PDF stream's cross-reference",
            "    tables are read into memory.",
            "",
            "    :param stream: A File object or an object that supports the standard read",
            "        and seek methods similar to a File object. Could also be a",
            "        string representing a path to a PDF file.",
            "    :param bool strict: Determines whether user should be warned of all",
            "        problems and also causes some correctable problems to be fatal.",
            "        Defaults to ``False``.",
            "    :param None/str/bytes password: Decrypt PDF file at initialization. If the",
            "        password is None, the file will not be decrypted.",
            "        Defaults to ``None``",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        stream: Union[StrByteType, Path],",
            "        strict: bool = False,",
            "        password: Union[None, str, bytes] = None,",
            "    ) -> None:",
            "        self.strict = strict",
            "        self.flattened_pages: Optional[List[PageObject]] = None",
            "        self.resolved_objects: Dict[Tuple[Any, Any], Optional[PdfObject]] = {}",
            "        self.xref_index = 0",
            "        self._page_id2num: Optional[",
            "            Dict[Any, Any]",
            "        ] = None  # map page indirect_ref number to Page Number",
            "        if hasattr(stream, \"mode\") and \"b\" not in stream.mode:  # type: ignore",
            "            logger_warning(",
            "                \"PdfReader stream/file object is not in binary mode. \"",
            "                \"It may not be read correctly.\",",
            "                __name__,",
            "            )",
            "        if isinstance(stream, (str, Path)):",
            "            with open(stream, \"rb\") as fh:",
            "                stream = BytesIO(fh.read())",
            "        self.read(stream)",
            "        self.stream = stream",
            "",
            "        self._override_encryption = False",
            "        self._encryption: Optional[Encryption] = None",
            "        if self.is_encrypted:",
            "            self._override_encryption = True",
            "            # Some documents may not have a /ID, use two empty",
            "            # byte strings instead. Solves",
            "            # https://github.com/mstamy2/PyPDF2/issues/608",
            "            id_entry = self.trailer.get(TK.ID)",
            "            id1_entry = id_entry[0].get_object().original_bytes if id_entry else b\"\"",
            "            encrypt_entry = cast(",
            "                DictionaryObject, self.trailer[TK.ENCRYPT].get_object()",
            "            )",
            "            self._encryption = Encryption.read(encrypt_entry, id1_entry)",
            "",
            "            # try empty password if no password provided",
            "            pwd = password if password is not None else b\"\"",
            "            if (",
            "                self._encryption.verify(pwd) == PasswordType.NOT_DECRYPTED",
            "                and password is not None",
            "            ):",
            "                # raise if password provided",
            "                raise WrongPasswordError(\"Wrong password\")",
            "            self._override_encryption = False",
            "        else:",
            "            if password is not None:",
            "                raise PdfReadError(\"Not encrypted file\")",
            "",
            "    @property",
            "    def pdf_header(self) -> str:",
            "        # TODO: Make this return a bytes object for consistency",
            "        #       but that needs a deprecation",
            "        loc = self.stream.tell()",
            "        self.stream.seek(0, 0)",
            "        pdf_file_version = self.stream.read(8).decode(\"utf-8\")",
            "        self.stream.seek(loc, 0)  # return to where it was",
            "        return pdf_file_version",
            "",
            "    @property",
            "    def metadata(self) -> Optional[DocumentInformation]:",
            "        \"\"\"",
            "        Retrieve the PDF file's document information dictionary, if it exists.",
            "        Note that some PDF files use metadata streams instead of docinfo",
            "        dictionaries, and these metadata streams will not be accessed by this",
            "        function.",
            "",
            "        :return: the document information of this PDF file",
            "        \"\"\"",
            "        if TK.INFO not in self.trailer:",
            "            return None",
            "        obj = self.trailer[TK.INFO]",
            "        retval = DocumentInformation()",
            "        if isinstance(obj, type(None)):",
            "            raise PdfReadError(",
            "                \"trailer not found or does not point to document information directory\"",
            "            )",
            "        retval.update(obj)  # type: ignore",
            "        return retval",
            "",
            "    def getDocumentInfo(self) -> Optional[DocumentInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getDocumentInfo\", \"metadata\")",
            "        return self.metadata",
            "",
            "    @property",
            "    def documentInfo(self) -> Optional[DocumentInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"documentInfo\", \"metadata\")",
            "        return self.metadata",
            "",
            "    @property",
            "    def xmp_metadata(self) -> Optional[XmpInformation]:",
            "        \"\"\"",
            "        XMP (Extensible Metadata Platform) data",
            "",
            "        :return: a :class:`XmpInformation<xmp.XmpInformation>`",
            "            instance that can be used to access XMP metadata from the document.",
            "            or ``None`` if no metadata was found on the document root.",
            "        \"\"\"",
            "        try:",
            "            self._override_encryption = True",
            "            return self.trailer[TK.ROOT].xmp_metadata  # type: ignore",
            "        finally:",
            "            self._override_encryption = False",
            "",
            "    def getXmpMetadata(self) -> Optional[XmpInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getXmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    @property",
            "    def xmpMetadata(self) -> Optional[XmpInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"xmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    def _get_num_pages(self) -> int:",
            "        \"\"\"",
            "        Calculate the number of pages in this PDF file.",
            "",
            "        :return: number of pages",
            "        :raises PdfReadError: if file is encrypted and restrictions prevent",
            "            this action.",
            "        \"\"\"",
            "        # Flattened pages will not work on an Encrypted PDF;",
            "        # the PDF file's page count is used in this case. Otherwise,",
            "        # the original method (flattened page count) is used.",
            "        if self.is_encrypted:",
            "            return self.trailer[TK.ROOT][\"/Pages\"][\"/Count\"]  # type: ignore",
            "        else:",
            "            if self.flattened_pages is None:",
            "                self._flatten()",
            "            return len(self.flattened_pages)  # type: ignore",
            "",
            "    def getNumPages(self) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :code:`len(reader.pages)` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"reader.getNumPages\", \"len(reader.pages)\")",
            "        return self._get_num_pages()",
            "",
            "    @property",
            "    def numPages(self) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :code:`len(reader.pages)` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"reader.numPages\", \"len(reader.pages)\")",
            "        return self._get_num_pages()",
            "",
            "    def getPage(self, pageNumber: int) -> PageObject:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :code:`reader.pages[pageNumber]` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(",
            "            \"reader.getPage(pageNumber)\", \"reader.pages[pageNumber]\"",
            "        )",
            "        return self._get_page(pageNumber)",
            "",
            "    def _get_page(self, page_number: int) -> PageObject:",
            "        \"\"\"",
            "        Retrieve a page by number from this PDF file.",
            "",
            "        :param int page_number: The page number to retrieve",
            "            (pages begin at zero)",
            "        :return: a :class:`PageObject<PyPDF2._page.PageObject>` instance.",
            "        \"\"\"",
            "        # ensure that we're not trying to access an encrypted PDF",
            "        # assert not self.trailer.has_key(TK.ENCRYPT)",
            "        if self.flattened_pages is None:",
            "            self._flatten()",
            "        assert self.flattened_pages is not None, \"hint for mypy\"",
            "        return self.flattened_pages[page_number]",
            "",
            "    @property",
            "    def namedDestinations(self) -> Dict[str, Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`named_destinations` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"namedDestinations\", \"named_destinations\")",
            "        return self.named_destinations",
            "",
            "    @property",
            "    def named_destinations(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        A read-only dictionary which maps names to",
            "        :class:`Destinations<PyPDF2.generic.Destination>`",
            "        \"\"\"",
            "        return self._get_named_destinations()",
            "",
            "    # A select group of relevant field attributes. For the complete list,",
            "    # see section 8.6.2 of the PDF 1.7 reference.",
            "",
            "    def get_fields(",
            "        self,",
            "        tree: Optional[TreeObject] = None,",
            "        retval: Optional[Dict[Any, Any]] = None,",
            "        fileobj: Optional[Any] = None,",
            "    ) -> Optional[Dict[str, Any]]:",
            "        \"\"\"",
            "        Extract field data if this PDF contains interactive form fields.",
            "",
            "        The *tree* and *retval* parameters are for recursive use.",
            "",
            "        :param fileobj: A file object (usually a text file) to write",
            "            a report to on all interactive form fields found.",
            "        :return: A dictionary where each key is a field name, and each",
            "            value is a :class:`Field<PyPDF2.generic.Field>` object. By",
            "            default, the mapping name is used for keys.",
            "            ``None`` if form data could not be located.",
            "        \"\"\"",
            "        field_attributes = FieldDictionaryAttributes.attributes_dict()",
            "        field_attributes.update(CheckboxRadioButtonAttributes.attributes_dict())",
            "        if retval is None:",
            "            retval = {}",
            "            catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "            # get the AcroForm tree",
            "            if CD.ACRO_FORM in catalog:",
            "                tree = cast(Optional[TreeObject], catalog[CD.ACRO_FORM])",
            "            else:",
            "                return None",
            "        if tree is None:",
            "            return retval",
            "        self._check_kids(tree, retval, fileobj)",
            "        for attr in field_attributes:",
            "            if attr in tree:",
            "                # Tree is a field",
            "                self._build_field(tree, retval, fileobj, field_attributes)",
            "                break",
            "",
            "        if \"/Fields\" in tree:",
            "            fields = cast(ArrayObject, tree[\"/Fields\"])",
            "            for f in fields:",
            "                field = f.get_object()",
            "                self._build_field(field, retval, fileobj, field_attributes)",
            "",
            "        return retval",
            "",
            "    def getFields(",
            "        self,",
            "        tree: Optional[TreeObject] = None,",
            "        retval: Optional[Dict[Any, Any]] = None,",
            "        fileobj: Optional[Any] = None,",
            "    ) -> Optional[Dict[str, Any]]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_fields` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getFields\", \"get_fields\")",
            "        return self.get_fields(tree, retval, fileobj)",
            "",
            "    def _build_field(",
            "        self,",
            "        field: Union[TreeObject, DictionaryObject],",
            "        retval: Dict[Any, Any],",
            "        fileobj: Any,",
            "        field_attributes: Any,",
            "    ) -> None:",
            "        self._check_kids(field, retval, fileobj)",
            "        try:",
            "            key = field[\"/TM\"]",
            "        except KeyError:",
            "            try:",
            "                key = field[\"/T\"]",
            "            except KeyError:",
            "                # Ignore no-name field for now",
            "                return",
            "        if fileobj:",
            "            self._write_field(fileobj, field, field_attributes)",
            "            fileobj.write(\"\\n\")",
            "        retval[key] = Field(field)",
            "",
            "    def _check_kids(",
            "        self, tree: Union[TreeObject, DictionaryObject], retval: Any, fileobj: Any",
            "    ) -> None:",
            "        if PA.KIDS in tree:",
            "            # recurse down the tree",
            "            for kid in tree[PA.KIDS]:  # type: ignore",
            "                self.get_fields(kid.get_object(), retval, fileobj)",
            "",
            "    def _write_field(self, fileobj: Any, field: Any, field_attributes: Any) -> None:",
            "        field_attributes_tuple = FieldDictionaryAttributes.attributes()",
            "        field_attributes_tuple = (",
            "            field_attributes_tuple + CheckboxRadioButtonAttributes.attributes()",
            "        )",
            "",
            "        for attr in field_attributes_tuple:",
            "            if attr in (",
            "                FieldDictionaryAttributes.Kids,",
            "                FieldDictionaryAttributes.AA,",
            "            ):",
            "                continue",
            "            attr_name = field_attributes[attr]",
            "            try:",
            "                if attr == FieldDictionaryAttributes.FT:",
            "                    # Make the field type value more clear",
            "                    types = {",
            "                        \"/Btn\": \"Button\",",
            "                        \"/Tx\": \"Text\",",
            "                        \"/Ch\": \"Choice\",",
            "                        \"/Sig\": \"Signature\",",
            "                    }",
            "                    if field[attr] in types:",
            "                        fileobj.write(attr_name + \": \" + types[field[attr]] + \"\\n\")",
            "                elif attr == FieldDictionaryAttributes.Parent:",
            "                    # Let's just write the name of the parent",
            "                    try:",
            "                        name = field[attr][FieldDictionaryAttributes.TM]",
            "                    except KeyError:",
            "                        name = field[attr][FieldDictionaryAttributes.T]",
            "                    fileobj.write(attr_name + \": \" + name + \"\\n\")",
            "                else:",
            "                    fileobj.write(attr_name + \": \" + str(field[attr]) + \"\\n\")",
            "            except KeyError:",
            "                # Field attribute is N/A or unknown, so don't write anything",
            "                pass",
            "",
            "    def get_form_text_fields(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Retrieve form fields from the document with textual data.",
            "",
            "        The key is the name of the form field, the value is the content of the",
            "        field.",
            "",
            "        If the document contains multiple form fields with the same name, the",
            "        second and following will get the suffix _2, _3, ...",
            "        \"\"\"",
            "        # Retrieve document form fields",
            "        formfields = self.get_fields()",
            "        if formfields is None:",
            "            return {}",
            "        return {",
            "            formfields[field][\"/T\"]: formfields[field].get(\"/V\")",
            "            for field in formfields",
            "            if formfields[field].get(\"/FT\") == \"/Tx\"",
            "        }",
            "",
            "    def getFormTextFields(self) -> Dict[str, Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_form_text_fields` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getFormTextFields\", \"get_form_text_fields\")",
            "        return self.get_form_text_fields()",
            "",
            "    def _get_named_destinations(",
            "        self,",
            "        tree: Union[TreeObject, None] = None,",
            "        retval: Optional[Any] = None,",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Retrieve the named destinations present in the document.",
            "",
            "        :return: a dictionary which maps names to",
            "            :class:`Destinations<PyPDF2.generic.Destination>`.",
            "        \"\"\"",
            "        if retval is None:",
            "            retval = {}",
            "            catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "",
            "            # get the name tree",
            "            if CA.DESTS in catalog:",
            "                tree = cast(TreeObject, catalog[CA.DESTS])",
            "            elif CA.NAMES in catalog:",
            "                names = cast(DictionaryObject, catalog[CA.NAMES])",
            "                if CA.DESTS in names:",
            "                    tree = cast(TreeObject, names[CA.DESTS])",
            "",
            "        if tree is None:",
            "            return retval",
            "",
            "        if PA.KIDS in tree:",
            "            # recurse down the tree",
            "            for kid in cast(ArrayObject, tree[PA.KIDS]):",
            "                self._get_named_destinations(kid.get_object(), retval)",
            "        # TABLE 3.33 Entries in a name tree node dictionary (PDF 1.7 specs)",
            "        elif CA.NAMES in tree:  # KIDS and NAMES are exclusives (PDF 1.7 specs p 162)",
            "            names = cast(DictionaryObject, tree[CA.NAMES])",
            "            for i in range(0, len(names), 2):",
            "                key = cast(str, names[i].get_object())",
            "                value = names[i + 1].get_object()",
            "                if isinstance(value, DictionaryObject) and \"/D\" in value:",
            "                    value = value[\"/D\"]",
            "                dest = self._build_destination(key, value)  # type: ignore",
            "                if dest is not None:",
            "                    retval[key] = dest",
            "        else:  # case where Dests is in root catalog (PDF 1.7 specs, \u00a72 about PDF1.1",
            "            for k__, v__ in tree.items():",
            "                val = v__.get_object()",
            "                dest = self._build_destination(k__, val)",
            "                if dest is not None:",
            "                    retval[k__] = dest",
            "        return retval",
            "",
            "    def getNamedDestinations(",
            "        self,",
            "        tree: Union[TreeObject, None] = None,",
            "        retval: Optional[Any] = None,",
            "    ) -> Dict[str, Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`named_destinations` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getNamedDestinations\", \"named_destinations\")",
            "        return self._get_named_destinations(tree, retval)",
            "",
            "    @property",
            "    def outline(self) -> OutlineType:",
            "        \"\"\"",
            "        Read-only property for the outline (i.e., a collection of 'outline items'",
            "        which are also known as 'bookmarks') present in the document.",
            "",
            "        :return: a nested list of :class:`Destinations<PyPDF2.generic.Destination>`.",
            "        \"\"\"",
            "        return self._get_outline()",
            "",
            "    @property",
            "    def outlines(self) -> OutlineType:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 2.9.0",
            "",
            "            Use :py:attr:`outline` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"outlines\", \"outline\")",
            "        return self.outline",
            "",
            "    def _get_outline(",
            "        self, node: Optional[DictionaryObject] = None, outline: Optional[Any] = None",
            "    ) -> OutlineType:",
            "        if outline is None:",
            "            outline = []",
            "            catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "",
            "            # get the outline dictionary and named destinations",
            "            if CO.OUTLINES in catalog:",
            "                lines = cast(DictionaryObject, catalog[CO.OUTLINES])",
            "",
            "                if isinstance(lines, NullObject):",
            "                    return outline",
            "",
            "                # TABLE 8.3 Entries in the outline dictionary",
            "                if lines is not None and \"/First\" in lines:",
            "                    node = cast(DictionaryObject, lines[\"/First\"])",
            "            self._namedDests = self._get_named_destinations()",
            "",
            "        if node is None:",
            "            return outline",
            "",
            "        # see if there are any more outline items",
            "        while True:",
            "            outline_obj = self._build_outline_item(node)",
            "            if outline_obj:",
            "                outline.append(outline_obj)",
            "",
            "            # check for sub-outline",
            "            if \"/First\" in node:",
            "                sub_outline: List[Any] = []",
            "                self._get_outline(cast(DictionaryObject, node[\"/First\"]), sub_outline)",
            "                if sub_outline:",
            "                    outline.append(sub_outline)",
            "",
            "            if \"/Next\" not in node:",
            "                break",
            "            node = cast(DictionaryObject, node[\"/Next\"])",
            "",
            "        return outline",
            "",
            "    def getOutlines(",
            "        self, node: Optional[DictionaryObject] = None, outline: Optional[Any] = None",
            "    ) -> OutlineType:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`outline` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getOutlines\", \"outline\")",
            "        return self._get_outline(node, outline)",
            "",
            "    def _get_page_number_by_indirect(",
            "        self, indirect_ref: Union[None, int, NullObject, IndirectObject]",
            "    ) -> int:",
            "        \"\"\"Generate _page_id2num\"\"\"",
            "        if self._page_id2num is None:",
            "            self._page_id2num = {",
            "                x.indirect_ref.idnum: i for i, x in enumerate(self.pages)  # type: ignore",
            "            }",
            "",
            "        if indirect_ref is None or isinstance(indirect_ref, NullObject):",
            "            return -1",
            "        if isinstance(indirect_ref, int):",
            "            idnum = indirect_ref",
            "        else:",
            "            idnum = indirect_ref.idnum",
            "        assert self._page_id2num is not None, \"hint for mypy\"",
            "        ret = self._page_id2num.get(idnum, -1)",
            "        return ret",
            "",
            "    def get_page_number(self, page: PageObject) -> int:",
            "        \"\"\"",
            "        Retrieve page number of a given PageObject",
            "",
            "        :param PageObject page: The page to get page number. Should be",
            "            an instance of :class:`PageObject<PyPDF2._page.PageObject>`",
            "        :return: the page number or -1 if page not found",
            "        \"\"\"",
            "        return self._get_page_number_by_indirect(page.indirect_ref)",
            "",
            "    def getPageNumber(self, page: PageObject) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_page_number` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getPageNumber\", \"get_page_number\")",
            "        return self.get_page_number(page)",
            "",
            "    def get_destination_page_number(self, destination: Destination) -> int:",
            "        \"\"\"",
            "        Retrieve page number of a given Destination object.",
            "",
            "        :param Destination destination: The destination to get page number.",
            "        :return: the page number or -1 if page not found",
            "        \"\"\"",
            "        return self._get_page_number_by_indirect(destination.page)",
            "",
            "    def getDestinationPageNumber(",
            "        self, destination: Destination",
            "    ) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_destination_page_number` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(",
            "            \"getDestinationPageNumber\", \"get_destination_page_number\"",
            "        )",
            "        return self.get_destination_page_number(destination)",
            "",
            "    def _build_destination(",
            "        self,",
            "        title: str,",
            "        array: List[Union[NumberObject, IndirectObject, NullObject, DictionaryObject]],",
            "    ) -> Destination:",
            "        page, typ = None, None",
            "        # handle outline items with missing or invalid destination",
            "        if (",
            "            isinstance(array, (type(None), NullObject))",
            "            or (isinstance(array, ArrayObject) and len(array) == 0)",
            "            or (isinstance(array, str))",
            "        ):",
            "",
            "            page = NullObject()",
            "            typ = TextStringObject(\"/Fit\")",
            "            return Destination(title, page, typ)",
            "        else:",
            "            page, typ = array[0:2]  # type: ignore",
            "            array = array[2:]",
            "            try:",
            "                return Destination(title, page, typ, *array)  # type: ignore",
            "            except PdfReadError:",
            "                logger_warning(f\"Unknown destination: {title} {array}\", __name__)",
            "                if self.strict:",
            "                    raise",
            "                # create a link to first Page",
            "                tmp = self.pages[0].indirect_ref",
            "                indirect_ref = NullObject() if tmp is None else tmp",
            "                return Destination(",
            "                    title, indirect_ref, TextStringObject(\"/Fit\")  # type: ignore",
            "                )",
            "",
            "    def _build_outline_item(self, node: DictionaryObject) -> Optional[Destination]:",
            "        dest, title, outline_item = None, None, None",
            "",
            "        # title required for valid outline",
            "        # PDF Reference 1.7: TABLE 8.4 Entries in an outline item dictionary",
            "        try:",
            "            title = node[\"/Title\"]",
            "        except KeyError:",
            "            if self.strict:",
            "                raise PdfReadError(f\"Outline Entry Missing /Title attribute: {node!r}\")",
            "            title = \"\"  # type: ignore",
            "",
            "        if \"/A\" in node:",
            "            # Action, PDFv1.7 Section 12.6 (only type GoTo supported)",
            "            action = cast(DictionaryObject, node[\"/A\"])",
            "            action_type = cast(NameObject, action[GoToActionArguments.S])",
            "            if action_type == \"/GoTo\":",
            "                dest = action[GoToActionArguments.D]",
            "        elif \"/Dest\" in node:",
            "            # Destination, PDFv1.7 Section 12.3.2",
            "            dest = node[\"/Dest\"]",
            "            # if array was referenced in another object, will be a dict w/ key \"/D\"",
            "            if isinstance(dest, DictionaryObject) and \"/D\" in dest:",
            "                dest = dest[\"/D\"]",
            "",
            "        if isinstance(dest, ArrayObject):",
            "            outline_item = self._build_destination(title, dest)  # type: ignore",
            "        elif isinstance(dest, str):",
            "            # named destination, addresses NameObject Issue #193",
            "            try:",
            "                outline_item = self._build_destination(",
            "                    title, self._namedDests[dest].dest_array",
            "                )",
            "            except KeyError:",
            "                # named destination not found in Name Dict",
            "                outline_item = self._build_destination(title, None)",
            "        elif isinstance(dest, type(None)):",
            "            # outline item not required to have destination or action",
            "            # PDFv1.7 Table 153",
            "            outline_item = self._build_destination(title, dest)  # type: ignore",
            "        else:",
            "            if self.strict:",
            "                raise PdfReadError(f\"Unexpected destination {dest!r}\")",
            "            outline_item = self._build_destination(title, None)  # type: ignore",
            "",
            "        # if outline item created, add color, format, and child count if present",
            "        if outline_item:",
            "            if \"/C\" in node:",
            "                # Color of outline item font in (R, G, B) with values ranging 0.0-1.0",
            "                outline_item[NameObject(\"/C\")] = ArrayObject(FloatObject(c) for c in node[\"/C\"])  # type: ignore",
            "            if \"/F\" in node:",
            "                # specifies style characteristics bold and/or italic",
            "                # 1=italic, 2=bold, 3=both",
            "                outline_item[NameObject(\"/F\")] = node[\"/F\"]",
            "            if \"/Count\" in node:",
            "                # absolute value = num. visible children",
            "                # positive = open/unfolded, negative = closed/folded",
            "                outline_item[NameObject(\"/Count\")] = node[\"/Count\"]",
            "",
            "        return outline_item",
            "",
            "    @property",
            "    def pages(self) -> List[PageObject]:",
            "        \"\"\"Read-only property that emulates a list of :py:class:`Page<PyPDF2._page.Page>` objects.\"\"\"",
            "        return _VirtualList(self._get_num_pages, self._get_page)  # type: ignore",
            "",
            "    @property",
            "    def page_layout(self) -> Optional[str]:",
            "        \"\"\"",
            "        Get the page layout.",
            "",
            "        :return: Page layout currently being used.",
            "",
            "        .. list-table:: Valid ``layout`` values",
            "           :widths: 50 200",
            "",
            "           * - /NoLayout",
            "             - Layout explicitly not specified",
            "           * - /SinglePage",
            "             - Show one page at a time",
            "           * - /OneColumn",
            "             - Show one column at a time",
            "           * - /TwoColumnLeft",
            "             - Show pages in two columns, odd-numbered pages on the left",
            "           * - /TwoColumnRight",
            "             - Show pages in two columns, odd-numbered pages on the right",
            "           * - /TwoPageLeft",
            "             - Show two pages at a time, odd-numbered pages on the left",
            "           * - /TwoPageRight",
            "             - Show two pages at a time, odd-numbered pages on the right",
            "        \"\"\"",
            "        trailer = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "        if CD.PAGE_LAYOUT in trailer:",
            "            return cast(NameObject, trailer[CD.PAGE_LAYOUT])",
            "        return None",
            "",
            "    def getPageLayout(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_layout` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getPageLayout\", \"page_layout\")",
            "        return self.page_layout",
            "",
            "    @property",
            "    def pageLayout(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_layout` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"pageLayout\", \"page_layout\")",
            "        return self.page_layout",
            "",
            "    @property",
            "    def page_mode(self) -> Optional[PagemodeType]:",
            "        \"\"\"",
            "        Get the page mode.",
            "",
            "        :return: Page mode currently being used.",
            "",
            "        .. list-table:: Valid ``mode`` values",
            "           :widths: 50 200",
            "",
            "           * - /UseNone",
            "             - Do not show outline or thumbnails panels",
            "           * - /UseOutlines",
            "             - Show outline (aka bookmarks) panel",
            "           * - /UseThumbs",
            "             - Show page thumbnails panel",
            "           * - /FullScreen",
            "             - Fullscreen view",
            "           * - /UseOC",
            "             - Show Optional Content Group (OCG) panel",
            "           * - /UseAttachments",
            "             - Show attachments panel",
            "        \"\"\"",
            "        try:",
            "            return self.trailer[TK.ROOT][\"/PageMode\"]  # type: ignore",
            "        except KeyError:",
            "            return None",
            "",
            "    def getPageMode(self) -> Optional[PagemodeType]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_mode` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getPageMode\", \"page_mode\")",
            "        return self.page_mode",
            "",
            "    @property",
            "    def pageMode(self) -> Optional[PagemodeType]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_mode` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"pageMode\", \"page_mode\")",
            "        return self.page_mode",
            "",
            "    def _flatten(",
            "        self,",
            "        pages: Union[None, DictionaryObject, PageObject] = None,",
            "        inherit: Optional[Dict[str, Any]] = None,",
            "        indirect_ref: Optional[IndirectObject] = None,",
            "    ) -> None:",
            "        inheritable_page_attributes = (",
            "            NameObject(PG.RESOURCES),",
            "            NameObject(PG.MEDIABOX),",
            "            NameObject(PG.CROPBOX),",
            "            NameObject(PG.ROTATE),",
            "        )",
            "        if inherit is None:",
            "            inherit = {}",
            "        if pages is None:",
            "            # Fix issue 327: set flattened_pages attribute only for",
            "            # decrypted file",
            "            catalog = self.trailer[TK.ROOT].get_object()",
            "            pages = catalog[\"/Pages\"].get_object()  # type: ignore",
            "            self.flattened_pages = []",
            "",
            "        t = \"/Pages\"",
            "        if PA.TYPE in pages:",
            "            t = pages[PA.TYPE]  # type: ignore",
            "",
            "        if t == \"/Pages\":",
            "            for attr in inheritable_page_attributes:",
            "                if attr in pages:",
            "                    inherit[attr] = pages[attr]",
            "            for page in pages[PA.KIDS]:  # type: ignore",
            "                addt = {}",
            "                if isinstance(page, IndirectObject):",
            "                    addt[\"indirect_ref\"] = page",
            "                self._flatten(page.get_object(), inherit, **addt)",
            "        elif t == \"/Page\":",
            "            for attr_in, value in list(inherit.items()):",
            "                # if the page has it's own value, it does not inherit the",
            "                # parent's value:",
            "                if attr_in not in pages:",
            "                    pages[attr_in] = value",
            "            page_obj = PageObject(self, indirect_ref)",
            "            page_obj.update(pages)",
            "",
            "            # TODO: Could flattened_pages be None at this point?",
            "            self.flattened_pages.append(page_obj)  # type: ignore",
            "",
            "    def _get_object_from_stream(",
            "        self, indirect_reference: IndirectObject",
            "    ) -> Union[int, PdfObject, str]:",
            "        # indirect reference to object in object stream",
            "        # read the entire object stream into memory",
            "        stmnum, idx = self.xref_objStm[indirect_reference.idnum]",
            "        obj_stm: EncodedStreamObject = IndirectObject(stmnum, 0, self).get_object()  # type: ignore",
            "        # This is an xref to a stream, so its type better be a stream",
            "        assert cast(str, obj_stm[\"/Type\"]) == \"/ObjStm\"",
            "        # /N is the number of indirect objects in the stream",
            "        assert idx < obj_stm[\"/N\"]",
            "        stream_data = BytesIO(b_(obj_stm.get_data()))  # type: ignore",
            "        for i in range(obj_stm[\"/N\"]):  # type: ignore",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "            objnum = NumberObject.read_from_stream(stream_data)",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "            offset = NumberObject.read_from_stream(stream_data)",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "            if objnum != indirect_reference.idnum:",
            "                # We're only interested in one object",
            "                continue",
            "            if self.strict and idx != i:",
            "                raise PdfReadError(\"Object is in wrong index.\")",
            "            stream_data.seek(int(obj_stm[\"/First\"] + offset), 0)  # type: ignore",
            "",
            "            # to cope with some case where the 'pointer' is on a white space",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "",
            "            try:",
            "                obj = read_object(stream_data, self)",
            "            except PdfStreamError as exc:",
            "                # Stream object cannot be read. Normally, a critical error, but",
            "                # Adobe Reader doesn't complain, so continue (in strict mode?)",
            "                logger_warning(",
            "                    f\"Invalid stream (index {i}) within object \"",
            "                    f\"{indirect_reference.idnum} {indirect_reference.generation}: \"",
            "                    f\"{exc}\",",
            "                    __name__,",
            "                )",
            "",
            "                if self.strict:",
            "                    raise PdfReadError(f\"Can't read object stream: {exc}\")",
            "                # Replace with null. Hopefully it's nothing important.",
            "                obj = NullObject()",
            "            return obj",
            "",
            "        if self.strict:",
            "            raise PdfReadError(\"This is a fatal error in strict mode.\")",
            "        return NullObject()",
            "",
            "    def get_object(self, indirect_reference: IndirectObject) -> Optional[PdfObject]:",
            "        retval = self.cache_get_indirect_object(",
            "            indirect_reference.generation, indirect_reference.idnum",
            "        )",
            "        if retval is not None:",
            "            return retval",
            "        if (",
            "            indirect_reference.generation == 0",
            "            and indirect_reference.idnum in self.xref_objStm",
            "        ):",
            "            retval = self._get_object_from_stream(indirect_reference)  # type: ignore",
            "        elif (",
            "            indirect_reference.generation in self.xref",
            "            and indirect_reference.idnum in self.xref[indirect_reference.generation]",
            "        ):",
            "            if self.xref_free_entry.get(indirect_reference.generation, {}).get(",
            "                indirect_reference.idnum, False",
            "            ):",
            "                return NullObject()",
            "            start = self.xref[indirect_reference.generation][indirect_reference.idnum]",
            "            self.stream.seek(start, 0)",
            "            try:",
            "                idnum, generation = self.read_object_header(self.stream)",
            "            except Exception:",
            "                if hasattr(self.stream, \"getbuffer\"):",
            "                    buf = bytes(self.stream.getbuffer())  # type: ignore",
            "                else:",
            "                    p = self.stream.tell()",
            "                    buf = self.stream.read(-1)",
            "                    self.stream.seek(p, 0)",
            "                m = re.search(",
            "                    rf\"\\s{indirect_reference.idnum}\\s+{indirect_reference.generation}\\s+obj\".encode(),",
            "                    buf,",
            "                )",
            "                if m is not None:",
            "                    logger_warning(",
            "                        f\"Object ID {indirect_reference.idnum},{indirect_reference.generation} ref repaired\",",
            "                        __name__,",
            "                    )",
            "                    self.xref[indirect_reference.generation][",
            "                        indirect_reference.idnum",
            "                    ] = (m.start(0) + 1)",
            "                    self.stream.seek(m.start(0) + 1)",
            "                    idnum, generation = self.read_object_header(self.stream)",
            "                else:",
            "                    idnum = -1  # exception will be raised below",
            "            if idnum != indirect_reference.idnum and self.xref_index:",
            "                # Xref table probably had bad indexes due to not being zero-indexed",
            "                if self.strict:",
            "                    raise PdfReadError(",
            "                        f\"Expected object ID ({indirect_reference.idnum} {indirect_reference.generation}) \"",
            "                        f\"does not match actual ({idnum} {generation}); \"",
            "                        \"xref table not zero-indexed.\"",
            "                    )",
            "                # xref table is corrected in non-strict mode",
            "            elif idnum != indirect_reference.idnum and self.strict:",
            "                # some other problem",
            "                raise PdfReadError(",
            "                    f\"Expected object ID ({indirect_reference.idnum} \"",
            "                    f\"{indirect_reference.generation}) does not match actual \"",
            "                    f\"({idnum} {generation}).\"",
            "                )",
            "            if self.strict:",
            "                assert generation == indirect_reference.generation",
            "            retval = read_object(self.stream, self)  # type: ignore",
            "",
            "            # override encryption is used for the /Encrypt dictionary",
            "            if not self._override_encryption and self._encryption is not None:",
            "                # if we don't have the encryption key:",
            "                if not self._encryption.is_decrypted():",
            "                    raise FileNotDecryptedError(\"File has not been decrypted\")",
            "                # otherwise, decrypt here...",
            "                retval = cast(PdfObject, retval)",
            "                retval = self._encryption.decrypt_object(",
            "                    retval, indirect_reference.idnum, indirect_reference.generation",
            "                )",
            "        else:",
            "            if hasattr(self.stream, \"getbuffer\"):",
            "                buf = bytes(self.stream.getbuffer())  # type: ignore",
            "            else:",
            "                p = self.stream.tell()",
            "                buf = self.stream.read(-1)",
            "                self.stream.seek(p, 0)",
            "            m = re.search(",
            "                rf\"\\s{indirect_reference.idnum}\\s+{indirect_reference.generation}\\s+obj\".encode(),",
            "                buf,",
            "            )",
            "            if m is not None:",
            "                logger_warning(",
            "                    f\"Object {indirect_reference.idnum} {indirect_reference.generation} found\",",
            "                    __name__,",
            "                )",
            "                if indirect_reference.generation not in self.xref:",
            "                    self.xref[indirect_reference.generation] = {}",
            "                self.xref[indirect_reference.generation][indirect_reference.idnum] = (",
            "                    m.start(0) + 1",
            "                )",
            "                self.stream.seek(m.end(0) + 1)",
            "                skip_over_whitespace(self.stream)",
            "                self.stream.seek(-1, 1)",
            "                retval = read_object(self.stream, self)  # type: ignore",
            "",
            "                # override encryption is used for the /Encrypt dictionary",
            "                if not self._override_encryption and self._encryption is not None:",
            "                    # if we don't have the encryption key:",
            "                    if not self._encryption.is_decrypted():",
            "                        raise FileNotDecryptedError(\"File has not been decrypted\")",
            "                    # otherwise, decrypt here...",
            "                    retval = cast(PdfObject, retval)",
            "                    retval = self._encryption.decrypt_object(",
            "                        retval, indirect_reference.idnum, indirect_reference.generation",
            "                    )",
            "            else:",
            "                logger_warning(",
            "                    f\"Object {indirect_reference.idnum} {indirect_reference.generation} not defined.\",",
            "                    __name__,",
            "                )",
            "                if self.strict:",
            "                    raise PdfReadError(\"Could not find object.\")",
            "        self.cache_indirect_object(",
            "            indirect_reference.generation, indirect_reference.idnum, retval",
            "        )",
            "        return retval",
            "",
            "    def getObject(",
            "        self, indirectReference: IndirectObject",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_object` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getObject\", \"get_object\")",
            "        return self.get_object(indirectReference)",
            "",
            "    def read_object_header(self, stream: StreamType) -> Tuple[int, int]:",
            "        # Should never be necessary to read out whitespace, since the",
            "        # cross-reference table should put us in the right spot to read the",
            "        # object header.  In reality... some files have stupid cross reference",
            "        # tables that are off by whitespace bytes.",
            "        extra = False",
            "        skip_over_comment(stream)",
            "        extra |= skip_over_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        idnum = read_until_whitespace(stream)",
            "        extra |= skip_over_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        generation = read_until_whitespace(stream)",
            "        extra |= skip_over_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "",
            "        # although it's not used, it might still be necessary to read",
            "        _obj = stream.read(3)  # noqa: F841",
            "",
            "        read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        if extra and self.strict:",
            "            logger_warning(",
            "                f\"Superfluous whitespace found in object header {idnum} {generation}\",  # type: ignore",
            "                __name__,",
            "            )",
            "        return int(idnum), int(generation)",
            "",
            "    def readObjectHeader(",
            "        self, stream: StreamType",
            "    ) -> Tuple[int, int]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`read_object_header` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"readObjectHeader\", \"read_object_header\")",
            "        return self.read_object_header(stream)",
            "",
            "    def cache_get_indirect_object(",
            "        self, generation: int, idnum: int",
            "    ) -> Optional[PdfObject]:",
            "        return self.resolved_objects.get((generation, idnum))",
            "",
            "    def cacheGetIndirectObject(",
            "        self, generation: int, idnum: int",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`cache_get_indirect_object` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(",
            "            \"cacheGetIndirectObject\", \"cache_get_indirect_object\"",
            "        )",
            "        return self.cache_get_indirect_object(generation, idnum)",
            "",
            "    def cache_indirect_object(",
            "        self, generation: int, idnum: int, obj: Optional[PdfObject]",
            "    ) -> Optional[PdfObject]:",
            "        if (generation, idnum) in self.resolved_objects:",
            "            msg = f\"Overwriting cache for {generation} {idnum}\"",
            "            if self.strict:",
            "                raise PdfReadError(msg)",
            "            logger_warning(msg, __name__)",
            "        self.resolved_objects[(generation, idnum)] = obj",
            "        return obj",
            "",
            "    def cacheIndirectObject(",
            "        self, generation: int, idnum: int, obj: Optional[PdfObject]",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`cache_indirect_object` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"cacheIndirectObject\", \"cache_indirect_object\")",
            "        return self.cache_indirect_object(generation, idnum, obj)",
            "",
            "    def read(self, stream: StreamType) -> None:",
            "        self._basic_validation(stream)",
            "        self._find_eof_marker(stream)",
            "        startxref = self._find_startxref_pos(stream)",
            "",
            "        # check and eventually correct the startxref only in not strict",
            "        xref_issue_nr = self._get_xref_issues(stream, startxref)",
            "        if xref_issue_nr != 0:",
            "            if self.strict and xref_issue_nr:",
            "                raise PdfReadError(\"Broken xref table\")",
            "            logger_warning(f\"incorrect startxref pointer({xref_issue_nr})\", __name__)",
            "",
            "        # read all cross reference tables and their trailers",
            "        self._read_xref_tables_and_trailers(stream, startxref, xref_issue_nr)",
            "",
            "        # if not zero-indexed, verify that the table is correct; change it if necessary",
            "        if self.xref_index and not self.strict:",
            "            loc = stream.tell()",
            "            for gen, xref_entry in self.xref.items():",
            "                if gen == 65535:",
            "                    continue",
            "                xref_k = sorted(",
            "                    xref_entry.keys()",
            "                )  # must ensure ascendant to prevent damange",
            "                for id in xref_k:",
            "                    stream.seek(xref_entry[id], 0)",
            "                    try:",
            "                        pid, _pgen = self.read_object_header(stream)",
            "                    except ValueError:",
            "                        break",
            "                    if pid == id - self.xref_index:",
            "                        # fixing index item per item is required for revised PDF.",
            "                        self.xref[gen][pid] = self.xref[gen][id]",
            "                        del self.xref[gen][id]",
            "                    # if not, then either it's just plain wrong, or the",
            "                    # non-zero-index is actually correct",
            "            stream.seek(loc, 0)  # return to where it was",
            "",
            "    def _basic_validation(self, stream: StreamType) -> None:",
            "        # start at the end:",
            "        stream.seek(0, os.SEEK_END)",
            "        if not stream.tell():",
            "            raise EmptyFileError(\"Cannot read an empty file\")",
            "        if self.strict:",
            "            stream.seek(0, os.SEEK_SET)",
            "            header_byte = stream.read(5)",
            "            if header_byte != b\"%PDF-\":",
            "                raise PdfReadError(",
            "                    f\"PDF starts with '{header_byte.decode('utf8')}', \"",
            "                    \"but '%PDF-' expected\"",
            "                )",
            "            stream.seek(0, os.SEEK_END)",
            "",
            "    def _find_eof_marker(self, stream: StreamType) -> None:",
            "        last_mb = 8  # to parse whole file",
            "        line = b\"\"",
            "        while line[:5] != b\"%%EOF\":",
            "            if stream.tell() < last_mb:",
            "                raise PdfReadError(\"EOF marker not found\")",
            "            line = read_previous_line(stream)",
            "",
            "    def _find_startxref_pos(self, stream: StreamType) -> int:",
            "        \"\"\"Find startxref entry - the location of the xref table\"\"\"",
            "        line = read_previous_line(stream)",
            "        try:",
            "            startxref = int(line)",
            "        except ValueError:",
            "            # 'startxref' may be on the same line as the location",
            "            if not line.startswith(b\"startxref\"):",
            "                raise PdfReadError(\"startxref not found\")",
            "            startxref = int(line[9:].strip())",
            "            logger_warning(\"startxref on same line as offset\", __name__)",
            "        else:",
            "            line = read_previous_line(stream)",
            "            if line[:9] != b\"startxref\":",
            "                raise PdfReadError(\"startxref not found\")",
            "        return startxref",
            "",
            "    def _read_standard_xref_table(self, stream: StreamType) -> None:",
            "        # standard cross-reference table",
            "        ref = stream.read(4)",
            "        if ref[:3] != b\"ref\":",
            "            raise PdfReadError(\"xref table read error\")",
            "        read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        firsttime = True  # check if the first time looking at the xref table",
            "        while True:",
            "            num = cast(int, read_object(stream, self))",
            "            if firsttime and num != 0:",
            "                self.xref_index = num",
            "                if self.strict:",
            "                    logger_warning(",
            "                        \"Xref table not zero-indexed. ID numbers for objects will be corrected.\",",
            "                        __name__,",
            "                    )",
            "                    # if table not zero indexed, could be due to error from when PDF was created",
            "                    # which will lead to mismatched indices later on, only warned and corrected if self.strict==True",
            "            firsttime = False",
            "            read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            size = cast(int, read_object(stream, self))",
            "            read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            cnt = 0",
            "            while cnt < size:",
            "                line = stream.read(20)",
            "",
            "                # It's very clear in section 3.4.3 of the PDF spec",
            "                # that all cross-reference table lines are a fixed",
            "                # 20 bytes (as of PDF 1.7). However, some files have",
            "                # 21-byte entries (or more) due to the use of \\r\\n",
            "                # (CRLF) EOL's. Detect that case, and adjust the line",
            "                # until it does not begin with a \\r (CR) or \\n (LF).",
            "                while line[0] in b\"\\x0D\\x0A\":",
            "                    stream.seek(-20 + 1, 1)",
            "                    line = stream.read(20)",
            "",
            "                # On the other hand, some malformed PDF files",
            "                # use a single character EOL without a preceding",
            "                # space.  Detect that case, and seek the stream",
            "                # back one character.  (0-9 means we've bled into",
            "                # the next xref entry, t means we've bled into the",
            "                # text \"trailer\"):",
            "                if line[-1] in b\"0123456789t\":",
            "                    stream.seek(-1, 1)",
            "",
            "                try:",
            "                    offset_b, generation_b = line[:16].split(b\" \")",
            "                    entry_type_b = line[17:18]",
            "",
            "                    offset, generation = int(offset_b), int(generation_b)",
            "                except Exception:",
            "                    # if something wrong occured",
            "                    if hasattr(stream, \"getbuffer\"):",
            "                        buf = bytes(stream.getbuffer())  # type: ignore",
            "                    else:",
            "                        p = stream.tell()",
            "                        stream.seek(0, 0)",
            "                        buf = stream.read(-1)",
            "                        stream.seek(p)",
            "",
            "                    f = re.search(f\"{num}\\\\s+(\\\\d+)\\\\s+obj\".encode(), buf)",
            "                    if f is None:",
            "                        logger_warning(",
            "                            f\"entry {num} in Xref table invalid; object not found\",",
            "                            __name__,",
            "                        )",
            "                        generation = 65535",
            "                        offset = -1",
            "                    else:",
            "                        logger_warning(",
            "                            f\"entry {num} in Xref table invalid but object found\",",
            "                            __name__,",
            "                        )",
            "                        generation = int(f.group(1))",
            "                        offset = f.start()",
            "",
            "                if generation not in self.xref:",
            "                    self.xref[generation] = {}",
            "                    self.xref_free_entry[generation] = {}",
            "                if num in self.xref[generation]:",
            "                    # It really seems like we should allow the last",
            "                    # xref table in the file to override previous",
            "                    # ones. Since we read the file backwards, assume",
            "                    # any existing key is already set correctly.",
            "                    pass",
            "                else:",
            "                    self.xref[generation][num] = offset",
            "                    try:",
            "                        self.xref_free_entry[generation][num] = entry_type_b == b\"f\"",
            "                    except Exception:",
            "                        pass",
            "                    try:",
            "                        self.xref_free_entry[65535][num] = entry_type_b == b\"f\"",
            "                    except Exception:",
            "                        pass",
            "                cnt += 1",
            "                num += 1",
            "            read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            trailertag = stream.read(7)",
            "            if trailertag != b\"trailer\":",
            "                # more xrefs!",
            "                stream.seek(-7, 1)",
            "            else:",
            "                break",
            "",
            "    def _read_xref_tables_and_trailers(",
            "        self, stream: StreamType, startxref: Optional[int], xref_issue_nr: int",
            "    ) -> None:",
            "        self.xref: Dict[int, Dict[Any, Any]] = {}",
            "        self.xref_free_entry: Dict[int, Dict[Any, Any]] = {}",
            "        self.xref_objStm: Dict[int, Tuple[Any, Any]] = {}",
            "        self.trailer = DictionaryObject()",
            "        while startxref is not None:",
            "            # load the xref table",
            "            stream.seek(startxref, 0)",
            "            x = stream.read(1)",
            "            if x in b\"\\r\\n\":",
            "                x = stream.read(1)",
            "            if x == b\"x\":",
            "                startxref = self._read_xref(stream)",
            "            elif xref_issue_nr:",
            "                try:",
            "                    self._rebuild_xref_table(stream)",
            "                    break",
            "                except Exception:",
            "                    xref_issue_nr = 0",
            "            elif x.isdigit():",
            "                try:",
            "                    xrefstream = self._read_pdf15_xref_stream(stream)",
            "                except Exception as e:",
            "                    if TK.ROOT in self.trailer:",
            "                        logger_warning(",
            "                            f\"Previous trailer can not be read {e.args}\",",
            "                            __name__,",
            "                        )",
            "                        break",
            "                    else:",
            "                        raise PdfReadError(f\"trailer can not be read {e.args}\")",
            "                trailer_keys = TK.ROOT, TK.ENCRYPT, TK.INFO, TK.ID",
            "                for key in trailer_keys:",
            "                    if key in xrefstream and key not in self.trailer:",
            "                        self.trailer[NameObject(key)] = xrefstream.raw_get(key)",
            "                if \"/XRefStm\" in xrefstream:",
            "                    p = stream.tell()",
            "                    stream.seek(cast(int, xrefstream[\"/XRefStm\"]) + 1, 0)",
            "                    self._read_pdf15_xref_stream(stream)",
            "                    stream.seek(p, 0)",
            "                if \"/Prev\" in xrefstream:",
            "                    startxref = cast(int, xrefstream[\"/Prev\"])",
            "                else:",
            "                    break",
            "            else:",
            "                startxref = self._read_xref_other_error(stream, startxref)",
            "",
            "    def _read_xref(self, stream: StreamType) -> Optional[int]:",
            "        self._read_standard_xref_table(stream)",
            "        read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        new_trailer = cast(Dict[str, Any], read_object(stream, self))",
            "        for key, value in new_trailer.items():",
            "            if key not in self.trailer:",
            "                self.trailer[key] = value",
            "        if \"/XRefStm\" in new_trailer:",
            "            p = stream.tell()",
            "            stream.seek(cast(int, new_trailer[\"/XRefStm\"]) + 1, 0)",
            "            try:",
            "                self._read_pdf15_xref_stream(stream)",
            "            except Exception:",
            "                logger_warning(",
            "                    f\"XRef object at {new_trailer['/XRefStm']} can not be read, some object may be missing\",",
            "                    __name__,",
            "                )",
            "            stream.seek(p, 0)",
            "        if \"/Prev\" in new_trailer:",
            "            startxref = new_trailer[\"/Prev\"]",
            "            return startxref",
            "        else:",
            "            return None",
            "",
            "    def _read_xref_other_error(",
            "        self, stream: StreamType, startxref: int",
            "    ) -> Optional[int]:",
            "        # some PDFs have /Prev=0 in the trailer, instead of no /Prev",
            "        if startxref == 0:",
            "            if self.strict:",
            "                raise PdfReadError(",
            "                    \"/Prev=0 in the trailer (try opening with strict=False)\"",
            "                )",
            "            logger_warning(",
            "                \"/Prev=0 in the trailer - assuming there is no previous xref table\",",
            "                __name__,",
            "            )",
            "            return None",
            "        # bad xref character at startxref.  Let's see if we can find",
            "        # the xref table nearby, as we've observed this error with an",
            "        # off-by-one before.",
            "        stream.seek(-11, 1)",
            "        tmp = stream.read(20)",
            "        xref_loc = tmp.find(b\"xref\")",
            "        if xref_loc != -1:",
            "            startxref -= 10 - xref_loc",
            "            return startxref",
            "        # No explicit xref table, try finding a cross-reference stream.",
            "        stream.seek(startxref, 0)",
            "        for look in range(5):",
            "            if stream.read(1).isdigit():",
            "                # This is not a standard PDF, consider adding a warning",
            "                startxref += look",
            "                return startxref",
            "        # no xref table found at specified location",
            "        if \"/Root\" in self.trailer and not self.strict:",
            "            # if Root has been already found, just raise warning",
            "            logger_warning(\"Invalid parent xref., rebuild xref\", __name__)",
            "            try:",
            "                self._rebuild_xref_table(stream)",
            "                return None",
            "            except Exception:",
            "                raise PdfReadError(\"can not rebuild xref\")",
            "        raise PdfReadError(\"Could not find xref table at specified location\")",
            "",
            "    def _read_pdf15_xref_stream(",
            "        self, stream: StreamType",
            "    ) -> Union[ContentStream, EncodedStreamObject, DecodedStreamObject]:",
            "        # PDF 1.5+ Cross-Reference Stream",
            "        stream.seek(-1, 1)",
            "        idnum, generation = self.read_object_header(stream)",
            "        xrefstream = cast(ContentStream, read_object(stream, self))",
            "        assert cast(str, xrefstream[\"/Type\"]) == \"/XRef\"",
            "        self.cache_indirect_object(generation, idnum, xrefstream)",
            "        stream_data = BytesIO(b_(xrefstream.get_data()))",
            "        # Index pairs specify the subsections in the dictionary. If",
            "        # none create one subsection that spans everything.",
            "        idx_pairs = xrefstream.get(\"/Index\", [0, xrefstream.get(\"/Size\")])",
            "        entry_sizes = cast(Dict[Any, Any], xrefstream.get(\"/W\"))",
            "        assert len(entry_sizes) >= 3",
            "        if self.strict and len(entry_sizes) > 3:",
            "            raise PdfReadError(f\"Too many entry sizes: {entry_sizes}\")",
            "",
            "        def get_entry(i: int) -> Union[int, Tuple[int, ...]]:",
            "            # Reads the correct number of bytes for each entry. See the",
            "            # discussion of the W parameter in PDF spec table 17.",
            "            if entry_sizes[i] > 0:",
            "                d = stream_data.read(entry_sizes[i])",
            "                return convert_to_int(d, entry_sizes[i])",
            "",
            "            # PDF Spec Table 17: A value of zero for an element in the",
            "            # W array indicates...the default value shall be used",
            "            if i == 0:",
            "                return 1  # First value defaults to 1",
            "            else:",
            "                return 0",
            "",
            "        def used_before(num: int, generation: Union[int, Tuple[int, ...]]) -> bool:",
            "            # We move backwards through the xrefs, don't replace any.",
            "            return num in self.xref.get(generation, []) or num in self.xref_objStm  # type: ignore",
            "",
            "        # Iterate through each subsection",
            "        self._read_xref_subsections(idx_pairs, get_entry, used_before)",
            "        return xrefstream",
            "",
            "    @staticmethod",
            "    def _get_xref_issues(stream: StreamType, startxref: int) -> int:",
            "        \"\"\"Return an int which indicates an issue. 0 means there is no issue.\"\"\"",
            "        stream.seek(startxref - 1, 0)  # -1 to check character before",
            "        line = stream.read(1)",
            "        if line not in b\"\\r\\n \\t\":",
            "            return 1",
            "        line = stream.read(4)",
            "        if line != b\"xref\":",
            "            # not an xref so check if it is an XREF object",
            "            line = b\"\"",
            "            while line in b\"0123456789 \\t\":",
            "                line = stream.read(1)",
            "                if line == b\"\":",
            "                    return 2",
            "            line += stream.read(2)  # 1 char already read, +2 to check \"obj\"",
            "            if line.lower() != b\"obj\":",
            "                return 3",
            "            # while stream.read(1) in b\" \\t\\r\\n\":",
            "            #     pass",
            "            # line = stream.read(256)  # check that it is xref obj",
            "            # if b\"/xref\" not in line.lower():",
            "            #     return 4",
            "        return 0",
            "",
            "    def _rebuild_xref_table(self, stream: StreamType) -> None:",
            "        self.xref = {}",
            "        stream.seek(0, 0)",
            "        f_ = stream.read(-1)",
            "",
            "        for m in re.finditer(rb\"[\\r\\n \\t][ \\t]*(\\d+)[ \\t]+(\\d+)[ \\t]+obj\", f_):",
            "            idnum = int(m.group(1))",
            "            generation = int(m.group(2))",
            "            if generation not in self.xref:",
            "                self.xref[generation] = {}",
            "            self.xref[generation][idnum] = m.start(1)",
            "        stream.seek(0, 0)",
            "        for m in re.finditer(rb\"[\\r\\n \\t][ \\t]*trailer[\\r\\n \\t]*(<<)\", f_):",
            "            stream.seek(m.start(1), 0)",
            "            new_trailer = cast(Dict[Any, Any], read_object(stream, self))",
            "            # Here, we are parsing the file from start to end, the new data have to erase the existing.",
            "            for key, value in list(new_trailer.items()):",
            "                self.trailer[key] = value",
            "",
            "    def _read_xref_subsections(",
            "        self,",
            "        idx_pairs: List[int],",
            "        get_entry: Callable[[int], Union[int, Tuple[int, ...]]],",
            "        used_before: Callable[[int, Union[int, Tuple[int, ...]]], bool],",
            "    ) -> None:",
            "        last_end = 0",
            "        for start, size in self._pairs(idx_pairs):",
            "            # The subsections must increase",
            "            assert start >= last_end",
            "            last_end = start + size",
            "            for num in range(start, start + size):",
            "                # The first entry is the type",
            "                xref_type = get_entry(0)",
            "                # The rest of the elements depend on the xref_type",
            "                if xref_type == 0:",
            "                    # linked list of free objects",
            "                    next_free_object = get_entry(1)  # noqa: F841",
            "                    next_generation = get_entry(2)  # noqa: F841",
            "                elif xref_type == 1:",
            "                    # objects that are in use but are not compressed",
            "                    byte_offset = get_entry(1)",
            "                    generation = get_entry(2)",
            "                    if generation not in self.xref:",
            "                        self.xref[generation] = {}  # type: ignore",
            "                    if not used_before(num, generation):",
            "                        self.xref[generation][num] = byte_offset  # type: ignore",
            "                elif xref_type == 2:",
            "                    # compressed objects",
            "                    objstr_num = get_entry(1)",
            "                    obstr_idx = get_entry(2)",
            "                    generation = 0  # PDF spec table 18, generation is 0",
            "                    if not used_before(num, generation):",
            "                        self.xref_objStm[num] = (objstr_num, obstr_idx)",
            "                elif self.strict:",
            "                    raise PdfReadError(f\"Unknown xref type: {xref_type}\")",
            "",
            "    def _pairs(self, array: List[int]) -> Iterable[Tuple[int, int]]:",
            "        i = 0",
            "        while True:",
            "            yield array[i], array[i + 1]",
            "            i += 2",
            "            if (i + 1) >= len(array):",
            "                break",
            "",
            "    def read_next_end_line(",
            "        self, stream: StreamType, limit_offset: int = 0",
            "    ) -> bytes:  # pragma: no cover",
            "        \"\"\".. deprecated:: 2.1.0\"\"\"",
            "        deprecate_no_replacement(\"read_next_end_line\", removed_in=\"4.0.0\")",
            "        line_parts = []",
            "        while True:",
            "            # Prevent infinite loops in malformed PDFs",
            "            if stream.tell() == 0 or stream.tell() == limit_offset:",
            "                raise PdfReadError(\"Could not read malformed PDF file\")",
            "            x = stream.read(1)",
            "            if stream.tell() < 2:",
            "                raise PdfReadError(\"EOL marker not found\")",
            "            stream.seek(-2, 1)",
            "            if x in (b\"\\n\", b\"\\r\"):  # \\n = LF; \\r = CR",
            "                crlf = False",
            "                while x in (b\"\\n\", b\"\\r\"):",
            "                    x = stream.read(1)",
            "                    if x in (b\"\\n\", b\"\\r\"):  # account for CR+LF",
            "                        stream.seek(-1, 1)",
            "                        crlf = True",
            "                    if stream.tell() < 2:",
            "                        raise PdfReadError(\"EOL marker not found\")",
            "                    stream.seek(-2, 1)",
            "                stream.seek(",
            "                    2 if crlf else 1, 1",
            "                )  # if using CR+LF, go back 2 bytes, else 1",
            "                break",
            "            else:",
            "                line_parts.append(x)",
            "        line_parts.reverse()",
            "        return b\"\".join(line_parts)",
            "",
            "    def readNextEndLine(",
            "        self, stream: StreamType, limit_offset: int = 0",
            "    ) -> bytes:  # pragma: no cover",
            "        \"\"\".. deprecated:: 1.28.0\"\"\"",
            "        deprecate_no_replacement(\"readNextEndLine\")",
            "        return self.read_next_end_line(stream, limit_offset)",
            "",
            "    def decrypt(self, password: Union[str, bytes]) -> PasswordType:",
            "        \"\"\"",
            "        When using an encrypted / secured PDF file with the PDF Standard",
            "        encryption handler, this function will allow the file to be decrypted.",
            "        It checks the given password against the document's user password and",
            "        owner password, and then stores the resulting decryption key if either",
            "        password is correct.",
            "",
            "        It does not matter which password was matched.  Both passwords provide",
            "        the correct decryption key that will allow the document to be used with",
            "        this library.",
            "",
            "        :param str password: The password to match.",
            "        :return: `PasswordType`.",
            "        \"\"\"",
            "        if not self._encryption:",
            "            raise PdfReadError(\"Not encrypted file\")",
            "        # TODO: raise Exception for wrong password",
            "        return self._encryption.verify(password)",
            "",
            "    def decode_permissions(self, permissions_code: int) -> Dict[str, bool]:",
            "        # Takes the permissions as an integer, returns the allowed access",
            "        permissions = {}",
            "        permissions[\"print\"] = permissions_code & (1 << 3 - 1) != 0  # bit 3",
            "        permissions[\"modify\"] = permissions_code & (1 << 4 - 1) != 0  # bit 4",
            "        permissions[\"copy\"] = permissions_code & (1 << 5 - 1) != 0  # bit 5",
            "        permissions[\"annotations\"] = permissions_code & (1 << 6 - 1) != 0  # bit 6",
            "        permissions[\"forms\"] = permissions_code & (1 << 9 - 1) != 0  # bit 9",
            "        permissions[\"accessability\"] = permissions_code & (1 << 10 - 1) != 0  # bit 10",
            "        permissions[\"assemble\"] = permissions_code & (1 << 11 - 1) != 0  # bit 11",
            "        permissions[\"print_high_quality\"] = (",
            "            permissions_code & (1 << 12 - 1) != 0",
            "        )  # bit 12",
            "        return permissions",
            "",
            "    @property",
            "    def is_encrypted(self) -> bool:",
            "        \"\"\"",
            "        Read-only boolean property showing whether this PDF file is encrypted.",
            "        Note that this property, if true, will remain true even after the",
            "        :meth:`decrypt()<PyPDF2.PdfReader.decrypt>` method is called.",
            "        \"\"\"",
            "        return TK.ENCRYPT in self.trailer",
            "",
            "    def getIsEncrypted(self) -> bool:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`is_encrypted` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getIsEncrypted\", \"is_encrypted\")",
            "        return self.is_encrypted",
            "",
            "    @property",
            "    def isEncrypted(self) -> bool:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`is_encrypted` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"isEncrypted\", \"is_encrypted\")",
            "        return self.is_encrypted",
            "",
            "    @property",
            "    def xfa(self) -> Optional[Dict[str, Any]]:",
            "        tree: Optional[TreeObject] = None",
            "        retval: Dict[str, Any] = {}",
            "        catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "",
            "        if \"/AcroForm\" not in catalog or not catalog[\"/AcroForm\"]:",
            "            return None",
            "",
            "        tree = cast(TreeObject, catalog[\"/AcroForm\"])",
            "",
            "        if \"/XFA\" in tree:",
            "            fields = cast(ArrayObject, tree[\"/XFA\"])",
            "            i = iter(fields)",
            "            for f in i:",
            "                tag = f",
            "                f = next(i)",
            "                if isinstance(f, IndirectObject):",
            "                    field = cast(Optional[EncodedStreamObject], f.get_object())",
            "                    if field:",
            "                        es = zlib.decompress(field._data)",
            "                        retval[tag] = es",
            "        return retval",
            "",
            "",
            "class PdfFileReader(PdfReader):  # pragma: no cover",
            "    def __init__(self, *args: Any, **kwargs: Any) -> None:",
            "        deprecate_with_replacement(\"PdfFileReader\", \"PdfReader\")",
            "        if \"strict\" not in kwargs and len(args) < 2:",
            "            kwargs[\"strict\"] = True  # maintain the default",
            "        super().__init__(*args, **kwargs)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2006, Mathieu Fenniak",
            "# Copyright (c) 2007, Ashish Kulkarni <kulkarni.ashish@gmail.com>",
            "#",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without",
            "# modification, are permitted provided that the following conditions are",
            "# met:",
            "#",
            "# * Redistributions of source code must retain the above copyright notice,",
            "# this list of conditions and the following disclaimer.",
            "# * Redistributions in binary form must reproduce the above copyright notice,",
            "# this list of conditions and the following disclaimer in the documentation",
            "# and/or other materials provided with the distribution.",
            "# * The name of the author may not be used to endorse or promote products",
            "# derived from this software without specific prior written permission.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
            "# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
            "# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
            "# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
            "# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
            "# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
            "# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
            "# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
            "# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
            "# POSSIBILITY OF SUCH DAMAGE.",
            "",
            "import os",
            "import re",
            "import struct",
            "import zlib",
            "from io import BytesIO",
            "from pathlib import Path",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from ._encryption import Encryption, PasswordType",
            "from ._page import PageObject, _VirtualList",
            "from ._utils import (",
            "    StrByteType,",
            "    StreamType,",
            "    b_,",
            "    deprecate_no_replacement,",
            "    deprecate_with_replacement,",
            "    logger_warning,",
            "    read_non_whitespace,",
            "    read_previous_line,",
            "    read_until_whitespace,",
            "    skip_over_comment,",
            "    skip_over_whitespace,",
            ")",
            "from .constants import CatalogAttributes as CA",
            "from .constants import CatalogDictionary as CD",
            "from .constants import CheckboxRadioButtonAttributes",
            "from .constants import Core as CO",
            "from .constants import DocumentInformationAttributes as DI",
            "from .constants import FieldDictionaryAttributes, GoToActionArguments",
            "from .constants import PageAttributes as PG",
            "from .constants import PagesAttributes as PA",
            "from .constants import TrailerKeys as TK",
            "from .errors import (",
            "    EmptyFileError,",
            "    FileNotDecryptedError,",
            "    PdfReadError,",
            "    PdfStreamError,",
            "    WrongPasswordError,",
            ")",
            "from .generic import (",
            "    ArrayObject,",
            "    ContentStream,",
            "    DecodedStreamObject,",
            "    Destination,",
            "    DictionaryObject,",
            "    EncodedStreamObject,",
            "    Field,",
            "    FloatObject,",
            "    IndirectObject,",
            "    NameObject,",
            "    NullObject,",
            "    NumberObject,",
            "    PdfObject,",
            "    TextStringObject,",
            "    TreeObject,",
            "    read_object,",
            ")",
            "from .types import OutlineType, PagemodeType",
            "from .xmp import XmpInformation",
            "",
            "",
            "def convert_to_int(d: bytes, size: int) -> Union[int, Tuple[Any, ...]]:",
            "    if size > 8:",
            "        raise PdfReadError(\"invalid size in convert_to_int\")",
            "    d = b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + d",
            "    d = d[-8:]",
            "    return struct.unpack(\">q\", d)[0]",
            "",
            "",
            "def convertToInt(",
            "    d: bytes, size: int",
            ") -> Union[int, Tuple[Any, ...]]:  # pragma: no cover",
            "    deprecate_with_replacement(\"convertToInt\", \"convert_to_int\")",
            "    return convert_to_int(d, size)",
            "",
            "",
            "class DocumentInformation(DictionaryObject):",
            "    \"\"\"",
            "    A class representing the basic document metadata provided in a PDF File.",
            "    This class is accessible through :py:class:`PdfReader.metadata<PyPDF2.PdfReader.metadata>`.",
            "",
            "    All text properties of the document metadata have",
            "    *two* properties, eg. author and author_raw. The non-raw property will",
            "    always return a ``TextStringObject``, making it ideal for a case where",
            "    the metadata is being displayed. The raw property can sometimes return",
            "    a ``ByteStringObject``, if PyPDF2 was unable to decode the string's",
            "    text encoding; this requires additional safety in the caller and",
            "    therefore is not as commonly accessed.",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        DictionaryObject.__init__(self)",
            "",
            "    def _get_text(self, key: str) -> Optional[str]:",
            "        retval = self.get(key, None)",
            "        if isinstance(retval, TextStringObject):",
            "            return retval",
            "        return None",
            "",
            "    def getText(self, key: str) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        The text value of the specified key or None.",
            "",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attributes (e.g. :py:attr:`title` / :py:attr:`author`).",
            "        \"\"\"",
            "        deprecate_no_replacement(\"getText\")",
            "        return self._get_text(key)",
            "",
            "    @property",
            "    def title(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **title**.",
            "",
            "        Returns a unicode string (``TextStringObject``) or ``None``",
            "        if the title is not specified.",
            "        \"\"\"",
            "        return (",
            "            self._get_text(DI.TITLE) or self.get(DI.TITLE).get_object()  # type: ignore",
            "            if self.get(DI.TITLE)",
            "            else None",
            "        )",
            "",
            "    @property",
            "    def title_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of title; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.TITLE)",
            "",
            "    @property",
            "    def author(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **author**.",
            "",
            "        Returns a unicode string (``TextStringObject``) or ``None``",
            "        if the author is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.AUTHOR)",
            "",
            "    @property",
            "    def author_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of author; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.AUTHOR)",
            "",
            "    @property",
            "    def subject(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **subject**.",
            "",
            "        Returns a unicode string (``TextStringObject``) or ``None``",
            "        if the subject is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.SUBJECT)",
            "",
            "    @property",
            "    def subject_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of subject; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.SUBJECT)",
            "",
            "    @property",
            "    def creator(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **creator**.",
            "",
            "        If the document was converted to PDF from another format, this is the",
            "        name of the application (e.g. OpenOffice) that created the original",
            "        document from which it was converted. Returns a unicode string",
            "        (``TextStringObject``) or ``None`` if the creator is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.CREATOR)",
            "",
            "    @property",
            "    def creator_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of creator; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.CREATOR)",
            "",
            "    @property",
            "    def producer(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the document's **producer**.",
            "",
            "        If the document was converted to PDF from another format, this is",
            "        the name of the application (for example, OSX Quartz) that converted",
            "        it to PDF. Returns a unicode string (``TextStringObject``)",
            "        or ``None`` if the producer is not specified.",
            "        \"\"\"",
            "        return self._get_text(DI.PRODUCER)",
            "",
            "    @property",
            "    def producer_raw(self) -> Optional[str]:",
            "        \"\"\"The \"raw\" version of producer; can return a ``ByteStringObject``.\"\"\"",
            "        return self.get(DI.PRODUCER)",
            "",
            "",
            "class PdfReader:",
            "    \"\"\"",
            "    Initialize a PdfReader object.",
            "",
            "    This operation can take some time, as the PDF stream's cross-reference",
            "    tables are read into memory.",
            "",
            "    :param stream: A File object or an object that supports the standard read",
            "        and seek methods similar to a File object. Could also be a",
            "        string representing a path to a PDF file.",
            "    :param bool strict: Determines whether user should be warned of all",
            "        problems and also causes some correctable problems to be fatal.",
            "        Defaults to ``False``.",
            "    :param None/str/bytes password: Decrypt PDF file at initialization. If the",
            "        password is None, the file will not be decrypted.",
            "        Defaults to ``None``",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        stream: Union[StrByteType, Path],",
            "        strict: bool = False,",
            "        password: Union[None, str, bytes] = None,",
            "    ) -> None:",
            "        self.strict = strict",
            "        self.flattened_pages: Optional[List[PageObject]] = None",
            "        self.resolved_objects: Dict[Tuple[Any, Any], Optional[PdfObject]] = {}",
            "        self.xref_index = 0",
            "        self._page_id2num: Optional[",
            "            Dict[Any, Any]",
            "        ] = None  # map page indirect_ref number to Page Number",
            "        if hasattr(stream, \"mode\") and \"b\" not in stream.mode:  # type: ignore",
            "            logger_warning(",
            "                \"PdfReader stream/file object is not in binary mode. \"",
            "                \"It may not be read correctly.\",",
            "                __name__,",
            "            )",
            "        if isinstance(stream, (str, Path)):",
            "            with open(stream, \"rb\") as fh:",
            "                stream = BytesIO(fh.read())",
            "        self.read(stream)",
            "        self.stream = stream",
            "",
            "        self._override_encryption = False",
            "        self._encryption: Optional[Encryption] = None",
            "        if self.is_encrypted:",
            "            self._override_encryption = True",
            "            # Some documents may not have a /ID, use two empty",
            "            # byte strings instead. Solves",
            "            # https://github.com/mstamy2/PyPDF2/issues/608",
            "            id_entry = self.trailer.get(TK.ID)",
            "            id1_entry = id_entry[0].get_object().original_bytes if id_entry else b\"\"",
            "            encrypt_entry = cast(",
            "                DictionaryObject, self.trailer[TK.ENCRYPT].get_object()",
            "            )",
            "            self._encryption = Encryption.read(encrypt_entry, id1_entry)",
            "",
            "            # try empty password if no password provided",
            "            pwd = password if password is not None else b\"\"",
            "            if (",
            "                self._encryption.verify(pwd) == PasswordType.NOT_DECRYPTED",
            "                and password is not None",
            "            ):",
            "                # raise if password provided",
            "                raise WrongPasswordError(\"Wrong password\")",
            "            self._override_encryption = False",
            "        else:",
            "            if password is not None:",
            "                raise PdfReadError(\"Not encrypted file\")",
            "",
            "    @property",
            "    def pdf_header(self) -> str:",
            "        # TODO: Make this return a bytes object for consistency",
            "        #       but that needs a deprecation",
            "        loc = self.stream.tell()",
            "        self.stream.seek(0, 0)",
            "        pdf_file_version = self.stream.read(8).decode(\"utf-8\")",
            "        self.stream.seek(loc, 0)  # return to where it was",
            "        return pdf_file_version",
            "",
            "    @property",
            "    def metadata(self) -> Optional[DocumentInformation]:",
            "        \"\"\"",
            "        Retrieve the PDF file's document information dictionary, if it exists.",
            "        Note that some PDF files use metadata streams instead of docinfo",
            "        dictionaries, and these metadata streams will not be accessed by this",
            "        function.",
            "",
            "        :return: the document information of this PDF file",
            "        \"\"\"",
            "        if TK.INFO not in self.trailer:",
            "            return None",
            "        obj = self.trailer[TK.INFO]",
            "        retval = DocumentInformation()",
            "        if isinstance(obj, type(None)):",
            "            raise PdfReadError(",
            "                \"trailer not found or does not point to document information directory\"",
            "            )",
            "        retval.update(obj)  # type: ignore",
            "        return retval",
            "",
            "    def getDocumentInfo(self) -> Optional[DocumentInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getDocumentInfo\", \"metadata\")",
            "        return self.metadata",
            "",
            "    @property",
            "    def documentInfo(self) -> Optional[DocumentInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"documentInfo\", \"metadata\")",
            "        return self.metadata",
            "",
            "    @property",
            "    def xmp_metadata(self) -> Optional[XmpInformation]:",
            "        \"\"\"",
            "        XMP (Extensible Metadata Platform) data",
            "",
            "        :return: a :class:`XmpInformation<xmp.XmpInformation>`",
            "            instance that can be used to access XMP metadata from the document.",
            "            or ``None`` if no metadata was found on the document root.",
            "        \"\"\"",
            "        try:",
            "            self._override_encryption = True",
            "            return self.trailer[TK.ROOT].xmp_metadata  # type: ignore",
            "        finally:",
            "            self._override_encryption = False",
            "",
            "    def getXmpMetadata(self) -> Optional[XmpInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getXmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    @property",
            "    def xmpMetadata(self) -> Optional[XmpInformation]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use the attribute :py:attr:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"xmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    def _get_num_pages(self) -> int:",
            "        \"\"\"",
            "        Calculate the number of pages in this PDF file.",
            "",
            "        :return: number of pages",
            "        :raises PdfReadError: if file is encrypted and restrictions prevent",
            "            this action.",
            "        \"\"\"",
            "        # Flattened pages will not work on an Encrypted PDF;",
            "        # the PDF file's page count is used in this case. Otherwise,",
            "        # the original method (flattened page count) is used.",
            "        if self.is_encrypted:",
            "            return self.trailer[TK.ROOT][\"/Pages\"][\"/Count\"]  # type: ignore",
            "        else:",
            "            if self.flattened_pages is None:",
            "                self._flatten()",
            "            return len(self.flattened_pages)  # type: ignore",
            "",
            "    def getNumPages(self) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :code:`len(reader.pages)` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"reader.getNumPages\", \"len(reader.pages)\")",
            "        return self._get_num_pages()",
            "",
            "    @property",
            "    def numPages(self) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :code:`len(reader.pages)` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"reader.numPages\", \"len(reader.pages)\")",
            "        return self._get_num_pages()",
            "",
            "    def getPage(self, pageNumber: int) -> PageObject:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :code:`reader.pages[pageNumber]` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(",
            "            \"reader.getPage(pageNumber)\", \"reader.pages[pageNumber]\"",
            "        )",
            "        return self._get_page(pageNumber)",
            "",
            "    def _get_page(self, page_number: int) -> PageObject:",
            "        \"\"\"",
            "        Retrieve a page by number from this PDF file.",
            "",
            "        :param int page_number: The page number to retrieve",
            "            (pages begin at zero)",
            "        :return: a :class:`PageObject<PyPDF2._page.PageObject>` instance.",
            "        \"\"\"",
            "        # ensure that we're not trying to access an encrypted PDF",
            "        # assert not self.trailer.has_key(TK.ENCRYPT)",
            "        if self.flattened_pages is None:",
            "            self._flatten()",
            "        assert self.flattened_pages is not None, \"hint for mypy\"",
            "        return self.flattened_pages[page_number]",
            "",
            "    @property",
            "    def namedDestinations(self) -> Dict[str, Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`named_destinations` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"namedDestinations\", \"named_destinations\")",
            "        return self.named_destinations",
            "",
            "    @property",
            "    def named_destinations(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        A read-only dictionary which maps names to",
            "        :class:`Destinations<PyPDF2.generic.Destination>`",
            "        \"\"\"",
            "        return self._get_named_destinations()",
            "",
            "    # A select group of relevant field attributes. For the complete list,",
            "    # see section 8.6.2 of the PDF 1.7 reference.",
            "",
            "    def get_fields(",
            "        self,",
            "        tree: Optional[TreeObject] = None,",
            "        retval: Optional[Dict[Any, Any]] = None,",
            "        fileobj: Optional[Any] = None,",
            "    ) -> Optional[Dict[str, Any]]:",
            "        \"\"\"",
            "        Extract field data if this PDF contains interactive form fields.",
            "",
            "        The *tree* and *retval* parameters are for recursive use.",
            "",
            "        :param fileobj: A file object (usually a text file) to write",
            "            a report to on all interactive form fields found.",
            "        :return: A dictionary where each key is a field name, and each",
            "            value is a :class:`Field<PyPDF2.generic.Field>` object. By",
            "            default, the mapping name is used for keys.",
            "            ``None`` if form data could not be located.",
            "        \"\"\"",
            "        field_attributes = FieldDictionaryAttributes.attributes_dict()",
            "        field_attributes.update(CheckboxRadioButtonAttributes.attributes_dict())",
            "        if retval is None:",
            "            retval = {}",
            "            catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "            # get the AcroForm tree",
            "            if CD.ACRO_FORM in catalog:",
            "                tree = cast(Optional[TreeObject], catalog[CD.ACRO_FORM])",
            "            else:",
            "                return None",
            "        if tree is None:",
            "            return retval",
            "        self._check_kids(tree, retval, fileobj)",
            "        for attr in field_attributes:",
            "            if attr in tree:",
            "                # Tree is a field",
            "                self._build_field(tree, retval, fileobj, field_attributes)",
            "                break",
            "",
            "        if \"/Fields\" in tree:",
            "            fields = cast(ArrayObject, tree[\"/Fields\"])",
            "            for f in fields:",
            "                field = f.get_object()",
            "                self._build_field(field, retval, fileobj, field_attributes)",
            "",
            "        return retval",
            "",
            "    def getFields(",
            "        self,",
            "        tree: Optional[TreeObject] = None,",
            "        retval: Optional[Dict[Any, Any]] = None,",
            "        fileobj: Optional[Any] = None,",
            "    ) -> Optional[Dict[str, Any]]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_fields` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getFields\", \"get_fields\")",
            "        return self.get_fields(tree, retval, fileobj)",
            "",
            "    def _build_field(",
            "        self,",
            "        field: Union[TreeObject, DictionaryObject],",
            "        retval: Dict[Any, Any],",
            "        fileobj: Any,",
            "        field_attributes: Any,",
            "    ) -> None:",
            "        self._check_kids(field, retval, fileobj)",
            "        try:",
            "            key = field[\"/TM\"]",
            "        except KeyError:",
            "            try:",
            "                key = field[\"/T\"]",
            "            except KeyError:",
            "                # Ignore no-name field for now",
            "                return",
            "        if fileobj:",
            "            self._write_field(fileobj, field, field_attributes)",
            "            fileobj.write(\"\\n\")",
            "        retval[key] = Field(field)",
            "",
            "    def _check_kids(",
            "        self, tree: Union[TreeObject, DictionaryObject], retval: Any, fileobj: Any",
            "    ) -> None:",
            "        if PA.KIDS in tree:",
            "            # recurse down the tree",
            "            for kid in tree[PA.KIDS]:  # type: ignore",
            "                self.get_fields(kid.get_object(), retval, fileobj)",
            "",
            "    def _write_field(self, fileobj: Any, field: Any, field_attributes: Any) -> None:",
            "        field_attributes_tuple = FieldDictionaryAttributes.attributes()",
            "        field_attributes_tuple = (",
            "            field_attributes_tuple + CheckboxRadioButtonAttributes.attributes()",
            "        )",
            "",
            "        for attr in field_attributes_tuple:",
            "            if attr in (",
            "                FieldDictionaryAttributes.Kids,",
            "                FieldDictionaryAttributes.AA,",
            "            ):",
            "                continue",
            "            attr_name = field_attributes[attr]",
            "            try:",
            "                if attr == FieldDictionaryAttributes.FT:",
            "                    # Make the field type value more clear",
            "                    types = {",
            "                        \"/Btn\": \"Button\",",
            "                        \"/Tx\": \"Text\",",
            "                        \"/Ch\": \"Choice\",",
            "                        \"/Sig\": \"Signature\",",
            "                    }",
            "                    if field[attr] in types:",
            "                        fileobj.write(attr_name + \": \" + types[field[attr]] + \"\\n\")",
            "                elif attr == FieldDictionaryAttributes.Parent:",
            "                    # Let's just write the name of the parent",
            "                    try:",
            "                        name = field[attr][FieldDictionaryAttributes.TM]",
            "                    except KeyError:",
            "                        name = field[attr][FieldDictionaryAttributes.T]",
            "                    fileobj.write(attr_name + \": \" + name + \"\\n\")",
            "                else:",
            "                    fileobj.write(attr_name + \": \" + str(field[attr]) + \"\\n\")",
            "            except KeyError:",
            "                # Field attribute is N/A or unknown, so don't write anything",
            "                pass",
            "",
            "    def get_form_text_fields(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Retrieve form fields from the document with textual data.",
            "",
            "        The key is the name of the form field, the value is the content of the",
            "        field.",
            "",
            "        If the document contains multiple form fields with the same name, the",
            "        second and following will get the suffix _2, _3, ...",
            "        \"\"\"",
            "        # Retrieve document form fields",
            "        formfields = self.get_fields()",
            "        if formfields is None:",
            "            return {}",
            "        return {",
            "            formfields[field][\"/T\"]: formfields[field].get(\"/V\")",
            "            for field in formfields",
            "            if formfields[field].get(\"/FT\") == \"/Tx\"",
            "        }",
            "",
            "    def getFormTextFields(self) -> Dict[str, Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_form_text_fields` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getFormTextFields\", \"get_form_text_fields\")",
            "        return self.get_form_text_fields()",
            "",
            "    def _get_named_destinations(",
            "        self,",
            "        tree: Union[TreeObject, None] = None,",
            "        retval: Optional[Any] = None,",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Retrieve the named destinations present in the document.",
            "",
            "        :return: a dictionary which maps names to",
            "            :class:`Destinations<PyPDF2.generic.Destination>`.",
            "        \"\"\"",
            "        if retval is None:",
            "            retval = {}",
            "            catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "",
            "            # get the name tree",
            "            if CA.DESTS in catalog:",
            "                tree = cast(TreeObject, catalog[CA.DESTS])",
            "            elif CA.NAMES in catalog:",
            "                names = cast(DictionaryObject, catalog[CA.NAMES])",
            "                if CA.DESTS in names:",
            "                    tree = cast(TreeObject, names[CA.DESTS])",
            "",
            "        if tree is None:",
            "            return retval",
            "",
            "        if PA.KIDS in tree:",
            "            # recurse down the tree",
            "            for kid in cast(ArrayObject, tree[PA.KIDS]):",
            "                self._get_named_destinations(kid.get_object(), retval)",
            "        # TABLE 3.33 Entries in a name tree node dictionary (PDF 1.7 specs)",
            "        elif CA.NAMES in tree:  # KIDS and NAMES are exclusives (PDF 1.7 specs p 162)",
            "            names = cast(DictionaryObject, tree[CA.NAMES])",
            "            for i in range(0, len(names), 2):",
            "                key = cast(str, names[i].get_object())",
            "                value = names[i + 1].get_object()",
            "                if isinstance(value, DictionaryObject) and \"/D\" in value:",
            "                    value = value[\"/D\"]",
            "                dest = self._build_destination(key, value)  # type: ignore",
            "                if dest is not None:",
            "                    retval[key] = dest",
            "        else:  # case where Dests is in root catalog (PDF 1.7 specs, \u00a72 about PDF1.1",
            "            for k__, v__ in tree.items():",
            "                val = v__.get_object()",
            "                dest = self._build_destination(k__, val)",
            "                if dest is not None:",
            "                    retval[k__] = dest",
            "        return retval",
            "",
            "    def getNamedDestinations(",
            "        self,",
            "        tree: Union[TreeObject, None] = None,",
            "        retval: Optional[Any] = None,",
            "    ) -> Dict[str, Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`named_destinations` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getNamedDestinations\", \"named_destinations\")",
            "        return self._get_named_destinations(tree, retval)",
            "",
            "    @property",
            "    def outline(self) -> OutlineType:",
            "        \"\"\"",
            "        Read-only property for the outline (i.e., a collection of 'outline items'",
            "        which are also known as 'bookmarks') present in the document.",
            "",
            "        :return: a nested list of :class:`Destinations<PyPDF2.generic.Destination>`.",
            "        \"\"\"",
            "        return self._get_outline()",
            "",
            "    @property",
            "    def outlines(self) -> OutlineType:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 2.9.0",
            "",
            "            Use :py:attr:`outline` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"outlines\", \"outline\")",
            "        return self.outline",
            "",
            "    def _get_outline(",
            "        self, node: Optional[DictionaryObject] = None, outline: Optional[Any] = None",
            "    ) -> OutlineType:",
            "        if outline is None:",
            "            outline = []",
            "            catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "",
            "            # get the outline dictionary and named destinations",
            "            if CO.OUTLINES in catalog:",
            "                lines = cast(DictionaryObject, catalog[CO.OUTLINES])",
            "",
            "                if isinstance(lines, NullObject):",
            "                    return outline",
            "",
            "                # TABLE 8.3 Entries in the outline dictionary",
            "                if lines is not None and \"/First\" in lines:",
            "                    node = cast(DictionaryObject, lines[\"/First\"])",
            "            self._namedDests = self._get_named_destinations()",
            "",
            "        if node is None:",
            "            return outline",
            "",
            "        # see if there are any more outline items",
            "        while True:",
            "            outline_obj = self._build_outline_item(node)",
            "            if outline_obj:",
            "                outline.append(outline_obj)",
            "",
            "            # check for sub-outline",
            "            if \"/First\" in node:",
            "                sub_outline: List[Any] = []",
            "                self._get_outline(cast(DictionaryObject, node[\"/First\"]), sub_outline)",
            "                if sub_outline:",
            "                    outline.append(sub_outline)",
            "",
            "            if \"/Next\" not in node:",
            "                break",
            "            node = cast(DictionaryObject, node[\"/Next\"])",
            "",
            "        return outline",
            "",
            "    def getOutlines(",
            "        self, node: Optional[DictionaryObject] = None, outline: Optional[Any] = None",
            "    ) -> OutlineType:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`outline` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getOutlines\", \"outline\")",
            "        return self._get_outline(node, outline)",
            "",
            "    def _get_page_number_by_indirect(",
            "        self, indirect_ref: Union[None, int, NullObject, IndirectObject]",
            "    ) -> int:",
            "        \"\"\"Generate _page_id2num\"\"\"",
            "        if self._page_id2num is None:",
            "            self._page_id2num = {",
            "                x.indirect_ref.idnum: i for i, x in enumerate(self.pages)  # type: ignore",
            "            }",
            "",
            "        if indirect_ref is None or isinstance(indirect_ref, NullObject):",
            "            return -1",
            "        if isinstance(indirect_ref, int):",
            "            idnum = indirect_ref",
            "        else:",
            "            idnum = indirect_ref.idnum",
            "        assert self._page_id2num is not None, \"hint for mypy\"",
            "        ret = self._page_id2num.get(idnum, -1)",
            "        return ret",
            "",
            "    def get_page_number(self, page: PageObject) -> int:",
            "        \"\"\"",
            "        Retrieve page number of a given PageObject",
            "",
            "        :param PageObject page: The page to get page number. Should be",
            "            an instance of :class:`PageObject<PyPDF2._page.PageObject>`",
            "        :return: the page number or -1 if page not found",
            "        \"\"\"",
            "        return self._get_page_number_by_indirect(page.indirect_ref)",
            "",
            "    def getPageNumber(self, page: PageObject) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_page_number` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getPageNumber\", \"get_page_number\")",
            "        return self.get_page_number(page)",
            "",
            "    def get_destination_page_number(self, destination: Destination) -> int:",
            "        \"\"\"",
            "        Retrieve page number of a given Destination object.",
            "",
            "        :param Destination destination: The destination to get page number.",
            "        :return: the page number or -1 if page not found",
            "        \"\"\"",
            "        return self._get_page_number_by_indirect(destination.page)",
            "",
            "    def getDestinationPageNumber(",
            "        self, destination: Destination",
            "    ) -> int:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_destination_page_number` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(",
            "            \"getDestinationPageNumber\", \"get_destination_page_number\"",
            "        )",
            "        return self.get_destination_page_number(destination)",
            "",
            "    def _build_destination(",
            "        self,",
            "        title: str,",
            "        array: List[Union[NumberObject, IndirectObject, NullObject, DictionaryObject]],",
            "    ) -> Destination:",
            "        page, typ = None, None",
            "        # handle outline items with missing or invalid destination",
            "        if (",
            "            isinstance(array, (type(None), NullObject))",
            "            or (isinstance(array, ArrayObject) and len(array) == 0)",
            "            or (isinstance(array, str))",
            "        ):",
            "",
            "            page = NullObject()",
            "            typ = TextStringObject(\"/Fit\")",
            "            return Destination(title, page, typ)",
            "        else:",
            "            page, typ = array[0:2]  # type: ignore",
            "            array = array[2:]",
            "            try:",
            "                return Destination(title, page, typ, *array)  # type: ignore",
            "            except PdfReadError:",
            "                logger_warning(f\"Unknown destination: {title} {array}\", __name__)",
            "                if self.strict:",
            "                    raise",
            "                # create a link to first Page",
            "                tmp = self.pages[0].indirect_ref",
            "                indirect_ref = NullObject() if tmp is None else tmp",
            "                return Destination(",
            "                    title, indirect_ref, TextStringObject(\"/Fit\")  # type: ignore",
            "                )",
            "",
            "    def _build_outline_item(self, node: DictionaryObject) -> Optional[Destination]:",
            "        dest, title, outline_item = None, None, None",
            "",
            "        # title required for valid outline",
            "        # PDF Reference 1.7: TABLE 8.4 Entries in an outline item dictionary",
            "        try:",
            "            title = node[\"/Title\"]",
            "        except KeyError:",
            "            if self.strict:",
            "                raise PdfReadError(f\"Outline Entry Missing /Title attribute: {node!r}\")",
            "            title = \"\"  # type: ignore",
            "",
            "        if \"/A\" in node:",
            "            # Action, PDFv1.7 Section 12.6 (only type GoTo supported)",
            "            action = cast(DictionaryObject, node[\"/A\"])",
            "            action_type = cast(NameObject, action[GoToActionArguments.S])",
            "            if action_type == \"/GoTo\":",
            "                dest = action[GoToActionArguments.D]",
            "        elif \"/Dest\" in node:",
            "            # Destination, PDFv1.7 Section 12.3.2",
            "            dest = node[\"/Dest\"]",
            "            # if array was referenced in another object, will be a dict w/ key \"/D\"",
            "            if isinstance(dest, DictionaryObject) and \"/D\" in dest:",
            "                dest = dest[\"/D\"]",
            "",
            "        if isinstance(dest, ArrayObject):",
            "            outline_item = self._build_destination(title, dest)  # type: ignore",
            "        elif isinstance(dest, str):",
            "            # named destination, addresses NameObject Issue #193",
            "            try:",
            "                outline_item = self._build_destination(",
            "                    title, self._namedDests[dest].dest_array",
            "                )",
            "            except KeyError:",
            "                # named destination not found in Name Dict",
            "                outline_item = self._build_destination(title, None)",
            "        elif isinstance(dest, type(None)):",
            "            # outline item not required to have destination or action",
            "            # PDFv1.7 Table 153",
            "            outline_item = self._build_destination(title, dest)  # type: ignore",
            "        else:",
            "            if self.strict:",
            "                raise PdfReadError(f\"Unexpected destination {dest!r}\")",
            "            outline_item = self._build_destination(title, None)  # type: ignore",
            "",
            "        # if outline item created, add color, format, and child count if present",
            "        if outline_item:",
            "            if \"/C\" in node:",
            "                # Color of outline item font in (R, G, B) with values ranging 0.0-1.0",
            "                outline_item[NameObject(\"/C\")] = ArrayObject(FloatObject(c) for c in node[\"/C\"])  # type: ignore",
            "            if \"/F\" in node:",
            "                # specifies style characteristics bold and/or italic",
            "                # 1=italic, 2=bold, 3=both",
            "                outline_item[NameObject(\"/F\")] = node[\"/F\"]",
            "            if \"/Count\" in node:",
            "                # absolute value = num. visible children",
            "                # positive = open/unfolded, negative = closed/folded",
            "                outline_item[NameObject(\"/Count\")] = node[\"/Count\"]",
            "",
            "        return outline_item",
            "",
            "    @property",
            "    def pages(self) -> List[PageObject]:",
            "        \"\"\"Read-only property that emulates a list of :py:class:`Page<PyPDF2._page.Page>` objects.\"\"\"",
            "        return _VirtualList(self._get_num_pages, self._get_page)  # type: ignore",
            "",
            "    @property",
            "    def page_layout(self) -> Optional[str]:",
            "        \"\"\"",
            "        Get the page layout.",
            "",
            "        :return: Page layout currently being used.",
            "",
            "        .. list-table:: Valid ``layout`` values",
            "           :widths: 50 200",
            "",
            "           * - /NoLayout",
            "             - Layout explicitly not specified",
            "           * - /SinglePage",
            "             - Show one page at a time",
            "           * - /OneColumn",
            "             - Show one column at a time",
            "           * - /TwoColumnLeft",
            "             - Show pages in two columns, odd-numbered pages on the left",
            "           * - /TwoColumnRight",
            "             - Show pages in two columns, odd-numbered pages on the right",
            "           * - /TwoPageLeft",
            "             - Show two pages at a time, odd-numbered pages on the left",
            "           * - /TwoPageRight",
            "             - Show two pages at a time, odd-numbered pages on the right",
            "        \"\"\"",
            "        trailer = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "        if CD.PAGE_LAYOUT in trailer:",
            "            return cast(NameObject, trailer[CD.PAGE_LAYOUT])",
            "        return None",
            "",
            "    def getPageLayout(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_layout` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getPageLayout\", \"page_layout\")",
            "        return self.page_layout",
            "",
            "    @property",
            "    def pageLayout(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_layout` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"pageLayout\", \"page_layout\")",
            "        return self.page_layout",
            "",
            "    @property",
            "    def page_mode(self) -> Optional[PagemodeType]:",
            "        \"\"\"",
            "        Get the page mode.",
            "",
            "        :return: Page mode currently being used.",
            "",
            "        .. list-table:: Valid ``mode`` values",
            "           :widths: 50 200",
            "",
            "           * - /UseNone",
            "             - Do not show outline or thumbnails panels",
            "           * - /UseOutlines",
            "             - Show outline (aka bookmarks) panel",
            "           * - /UseThumbs",
            "             - Show page thumbnails panel",
            "           * - /FullScreen",
            "             - Fullscreen view",
            "           * - /UseOC",
            "             - Show Optional Content Group (OCG) panel",
            "           * - /UseAttachments",
            "             - Show attachments panel",
            "        \"\"\"",
            "        try:",
            "            return self.trailer[TK.ROOT][\"/PageMode\"]  # type: ignore",
            "        except KeyError:",
            "            return None",
            "",
            "    def getPageMode(self) -> Optional[PagemodeType]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_mode` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getPageMode\", \"page_mode\")",
            "        return self.page_mode",
            "",
            "    @property",
            "    def pageMode(self) -> Optional[PagemodeType]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`page_mode` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"pageMode\", \"page_mode\")",
            "        return self.page_mode",
            "",
            "    def _flatten(",
            "        self,",
            "        pages: Union[None, DictionaryObject, PageObject] = None,",
            "        inherit: Optional[Dict[str, Any]] = None,",
            "        indirect_ref: Optional[IndirectObject] = None,",
            "    ) -> None:",
            "        inheritable_page_attributes = (",
            "            NameObject(PG.RESOURCES),",
            "            NameObject(PG.MEDIABOX),",
            "            NameObject(PG.CROPBOX),",
            "            NameObject(PG.ROTATE),",
            "        )",
            "        if inherit is None:",
            "            inherit = {}",
            "        if pages is None:",
            "            # Fix issue 327: set flattened_pages attribute only for",
            "            # decrypted file",
            "            catalog = self.trailer[TK.ROOT].get_object()",
            "            pages = catalog[\"/Pages\"].get_object()  # type: ignore",
            "            self.flattened_pages = []",
            "",
            "        t = \"/Pages\"",
            "        if PA.TYPE in pages:",
            "            t = pages[PA.TYPE]  # type: ignore",
            "",
            "        if t == \"/Pages\":",
            "            for attr in inheritable_page_attributes:",
            "                if attr in pages:",
            "                    inherit[attr] = pages[attr]",
            "            for page in pages[PA.KIDS]:  # type: ignore",
            "                addt = {}",
            "                if isinstance(page, IndirectObject):",
            "                    addt[\"indirect_ref\"] = page",
            "                self._flatten(page.get_object(), inherit, **addt)",
            "        elif t == \"/Page\":",
            "            for attr_in, value in list(inherit.items()):",
            "                # if the page has it's own value, it does not inherit the",
            "                # parent's value:",
            "                if attr_in not in pages:",
            "                    pages[attr_in] = value",
            "            page_obj = PageObject(self, indirect_ref)",
            "            page_obj.update(pages)",
            "",
            "            # TODO: Could flattened_pages be None at this point?",
            "            self.flattened_pages.append(page_obj)  # type: ignore",
            "",
            "    def _get_object_from_stream(",
            "        self, indirect_reference: IndirectObject",
            "    ) -> Union[int, PdfObject, str]:",
            "        # indirect reference to object in object stream",
            "        # read the entire object stream into memory",
            "        stmnum, idx = self.xref_objStm[indirect_reference.idnum]",
            "        obj_stm: EncodedStreamObject = IndirectObject(stmnum, 0, self).get_object()  # type: ignore",
            "        # This is an xref to a stream, so its type better be a stream",
            "        assert cast(str, obj_stm[\"/Type\"]) == \"/ObjStm\"",
            "        # /N is the number of indirect objects in the stream",
            "        assert idx < obj_stm[\"/N\"]",
            "        stream_data = BytesIO(b_(obj_stm.get_data()))  # type: ignore",
            "        for i in range(obj_stm[\"/N\"]):  # type: ignore",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "            objnum = NumberObject.read_from_stream(stream_data)",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "            offset = NumberObject.read_from_stream(stream_data)",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "            if objnum != indirect_reference.idnum:",
            "                # We're only interested in one object",
            "                continue",
            "            if self.strict and idx != i:",
            "                raise PdfReadError(\"Object is in wrong index.\")",
            "            stream_data.seek(int(obj_stm[\"/First\"] + offset), 0)  # type: ignore",
            "",
            "            # to cope with some case where the 'pointer' is on a white space",
            "            read_non_whitespace(stream_data)",
            "            stream_data.seek(-1, 1)",
            "",
            "            try:",
            "                obj = read_object(stream_data, self)",
            "            except PdfStreamError as exc:",
            "                # Stream object cannot be read. Normally, a critical error, but",
            "                # Adobe Reader doesn't complain, so continue (in strict mode?)",
            "                logger_warning(",
            "                    f\"Invalid stream (index {i}) within object \"",
            "                    f\"{indirect_reference.idnum} {indirect_reference.generation}: \"",
            "                    f\"{exc}\",",
            "                    __name__,",
            "                )",
            "",
            "                if self.strict:",
            "                    raise PdfReadError(f\"Can't read object stream: {exc}\")",
            "                # Replace with null. Hopefully it's nothing important.",
            "                obj = NullObject()",
            "            return obj",
            "",
            "        if self.strict:",
            "            raise PdfReadError(\"This is a fatal error in strict mode.\")",
            "        return NullObject()",
            "",
            "    def get_object(self, indirect_reference: IndirectObject) -> Optional[PdfObject]:",
            "        retval = self.cache_get_indirect_object(",
            "            indirect_reference.generation, indirect_reference.idnum",
            "        )",
            "        if retval is not None:",
            "            return retval",
            "        if (",
            "            indirect_reference.generation == 0",
            "            and indirect_reference.idnum in self.xref_objStm",
            "        ):",
            "            retval = self._get_object_from_stream(indirect_reference)  # type: ignore",
            "        elif (",
            "            indirect_reference.generation in self.xref",
            "            and indirect_reference.idnum in self.xref[indirect_reference.generation]",
            "        ):",
            "            if self.xref_free_entry.get(indirect_reference.generation, {}).get(",
            "                indirect_reference.idnum, False",
            "            ):",
            "                return NullObject()",
            "            start = self.xref[indirect_reference.generation][indirect_reference.idnum]",
            "            self.stream.seek(start, 0)",
            "            try:",
            "                idnum, generation = self.read_object_header(self.stream)",
            "            except Exception:",
            "                if hasattr(self.stream, \"getbuffer\"):",
            "                    buf = bytes(self.stream.getbuffer())  # type: ignore",
            "                else:",
            "                    p = self.stream.tell()",
            "                    self.stream.seek(0, 0)",
            "                    buf = self.stream.read(-1)",
            "                    self.stream.seek(p, 0)",
            "                m = re.search(",
            "                    rf\"\\s{indirect_reference.idnum}\\s+{indirect_reference.generation}\\s+obj\".encode(),",
            "                    buf,",
            "                )",
            "                if m is not None:",
            "                    logger_warning(",
            "                        f\"Object ID {indirect_reference.idnum},{indirect_reference.generation} ref repaired\",",
            "                        __name__,",
            "                    )",
            "                    self.xref[indirect_reference.generation][",
            "                        indirect_reference.idnum",
            "                    ] = (m.start(0) + 1)",
            "                    self.stream.seek(m.start(0) + 1)",
            "                    idnum, generation = self.read_object_header(self.stream)",
            "                else:",
            "                    idnum = -1  # exception will be raised below",
            "            if idnum != indirect_reference.idnum and self.xref_index:",
            "                # Xref table probably had bad indexes due to not being zero-indexed",
            "                if self.strict:",
            "                    raise PdfReadError(",
            "                        f\"Expected object ID ({indirect_reference.idnum} {indirect_reference.generation}) \"",
            "                        f\"does not match actual ({idnum} {generation}); \"",
            "                        \"xref table not zero-indexed.\"",
            "                    )",
            "                # xref table is corrected in non-strict mode",
            "            elif idnum != indirect_reference.idnum and self.strict:",
            "                # some other problem",
            "                raise PdfReadError(",
            "                    f\"Expected object ID ({indirect_reference.idnum} \"",
            "                    f\"{indirect_reference.generation}) does not match actual \"",
            "                    f\"({idnum} {generation}).\"",
            "                )",
            "            if self.strict:",
            "                assert generation == indirect_reference.generation",
            "            retval = read_object(self.stream, self)  # type: ignore",
            "",
            "            # override encryption is used for the /Encrypt dictionary",
            "            if not self._override_encryption and self._encryption is not None:",
            "                # if we don't have the encryption key:",
            "                if not self._encryption.is_decrypted():",
            "                    raise FileNotDecryptedError(\"File has not been decrypted\")",
            "                # otherwise, decrypt here...",
            "                retval = cast(PdfObject, retval)",
            "                retval = self._encryption.decrypt_object(",
            "                    retval, indirect_reference.idnum, indirect_reference.generation",
            "                )",
            "        else:",
            "            if hasattr(self.stream, \"getbuffer\"):",
            "                buf = bytes(self.stream.getbuffer())  # type: ignore",
            "            else:",
            "                p = self.stream.tell()",
            "                self.stream.seek(0, 0)",
            "                buf = self.stream.read(-1)",
            "                self.stream.seek(p, 0)",
            "            m = re.search(",
            "                rf\"\\s{indirect_reference.idnum}\\s+{indirect_reference.generation}\\s+obj\".encode(),",
            "                buf,",
            "            )",
            "            if m is not None:",
            "                logger_warning(",
            "                    f\"Object {indirect_reference.idnum} {indirect_reference.generation} found\",",
            "                    __name__,",
            "                )",
            "                if indirect_reference.generation not in self.xref:",
            "                    self.xref[indirect_reference.generation] = {}",
            "                self.xref[indirect_reference.generation][indirect_reference.idnum] = (",
            "                    m.start(0) + 1",
            "                )",
            "                self.stream.seek(m.end(0) + 1)",
            "                skip_over_whitespace(self.stream)",
            "                self.stream.seek(-1, 1)",
            "                retval = read_object(self.stream, self)  # type: ignore",
            "",
            "                # override encryption is used for the /Encrypt dictionary",
            "                if not self._override_encryption and self._encryption is not None:",
            "                    # if we don't have the encryption key:",
            "                    if not self._encryption.is_decrypted():",
            "                        raise FileNotDecryptedError(\"File has not been decrypted\")",
            "                    # otherwise, decrypt here...",
            "                    retval = cast(PdfObject, retval)",
            "                    retval = self._encryption.decrypt_object(",
            "                        retval, indirect_reference.idnum, indirect_reference.generation",
            "                    )",
            "            else:",
            "                logger_warning(",
            "                    f\"Object {indirect_reference.idnum} {indirect_reference.generation} not defined.\",",
            "                    __name__,",
            "                )",
            "                if self.strict:",
            "                    raise PdfReadError(\"Could not find object.\")",
            "        self.cache_indirect_object(",
            "            indirect_reference.generation, indirect_reference.idnum, retval",
            "        )",
            "        return retval",
            "",
            "    def getObject(",
            "        self, indirectReference: IndirectObject",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`get_object` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getObject\", \"get_object\")",
            "        return self.get_object(indirectReference)",
            "",
            "    def read_object_header(self, stream: StreamType) -> Tuple[int, int]:",
            "        # Should never be necessary to read out whitespace, since the",
            "        # cross-reference table should put us in the right spot to read the",
            "        # object header.  In reality... some files have stupid cross reference",
            "        # tables that are off by whitespace bytes.",
            "        extra = False",
            "        skip_over_comment(stream)",
            "        extra |= skip_over_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        idnum = read_until_whitespace(stream)",
            "        extra |= skip_over_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        generation = read_until_whitespace(stream)",
            "        extra |= skip_over_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "",
            "        # although it's not used, it might still be necessary to read",
            "        _obj = stream.read(3)  # noqa: F841",
            "",
            "        read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        if extra and self.strict:",
            "            logger_warning(",
            "                f\"Superfluous whitespace found in object header {idnum} {generation}\",  # type: ignore",
            "                __name__,",
            "            )",
            "        return int(idnum), int(generation)",
            "",
            "    def readObjectHeader(",
            "        self, stream: StreamType",
            "    ) -> Tuple[int, int]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`read_object_header` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"readObjectHeader\", \"read_object_header\")",
            "        return self.read_object_header(stream)",
            "",
            "    def cache_get_indirect_object(",
            "        self, generation: int, idnum: int",
            "    ) -> Optional[PdfObject]:",
            "        return self.resolved_objects.get((generation, idnum))",
            "",
            "    def cacheGetIndirectObject(",
            "        self, generation: int, idnum: int",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`cache_get_indirect_object` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(",
            "            \"cacheGetIndirectObject\", \"cache_get_indirect_object\"",
            "        )",
            "        return self.cache_get_indirect_object(generation, idnum)",
            "",
            "    def cache_indirect_object(",
            "        self, generation: int, idnum: int, obj: Optional[PdfObject]",
            "    ) -> Optional[PdfObject]:",
            "        if (generation, idnum) in self.resolved_objects:",
            "            msg = f\"Overwriting cache for {generation} {idnum}\"",
            "            if self.strict:",
            "                raise PdfReadError(msg)",
            "            logger_warning(msg, __name__)",
            "        self.resolved_objects[(generation, idnum)] = obj",
            "        return obj",
            "",
            "    def cacheIndirectObject(",
            "        self, generation: int, idnum: int, obj: Optional[PdfObject]",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :meth:`cache_indirect_object` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"cacheIndirectObject\", \"cache_indirect_object\")",
            "        return self.cache_indirect_object(generation, idnum, obj)",
            "",
            "    def read(self, stream: StreamType) -> None:",
            "        self._basic_validation(stream)",
            "        self._find_eof_marker(stream)",
            "        startxref = self._find_startxref_pos(stream)",
            "",
            "        # check and eventually correct the startxref only in not strict",
            "        xref_issue_nr = self._get_xref_issues(stream, startxref)",
            "        if xref_issue_nr != 0:",
            "            if self.strict and xref_issue_nr:",
            "                raise PdfReadError(\"Broken xref table\")",
            "            logger_warning(f\"incorrect startxref pointer({xref_issue_nr})\", __name__)",
            "",
            "        # read all cross reference tables and their trailers",
            "        self._read_xref_tables_and_trailers(stream, startxref, xref_issue_nr)",
            "",
            "        # if not zero-indexed, verify that the table is correct; change it if necessary",
            "        if self.xref_index and not self.strict:",
            "            loc = stream.tell()",
            "            for gen, xref_entry in self.xref.items():",
            "                if gen == 65535:",
            "                    continue",
            "                xref_k = sorted(",
            "                    xref_entry.keys()",
            "                )  # must ensure ascendant to prevent damange",
            "                for id in xref_k:",
            "                    stream.seek(xref_entry[id], 0)",
            "                    try:",
            "                        pid, _pgen = self.read_object_header(stream)",
            "                    except ValueError:",
            "                        break",
            "                    if pid == id - self.xref_index:",
            "                        # fixing index item per item is required for revised PDF.",
            "                        self.xref[gen][pid] = self.xref[gen][id]",
            "                        del self.xref[gen][id]",
            "                    # if not, then either it's just plain wrong, or the",
            "                    # non-zero-index is actually correct",
            "            stream.seek(loc, 0)  # return to where it was",
            "",
            "    def _basic_validation(self, stream: StreamType) -> None:",
            "        # start at the end:",
            "        stream.seek(0, os.SEEK_END)",
            "        if not stream.tell():",
            "            raise EmptyFileError(\"Cannot read an empty file\")",
            "        if self.strict:",
            "            stream.seek(0, os.SEEK_SET)",
            "            header_byte = stream.read(5)",
            "            if header_byte != b\"%PDF-\":",
            "                raise PdfReadError(",
            "                    f\"PDF starts with '{header_byte.decode('utf8')}', \"",
            "                    \"but '%PDF-' expected\"",
            "                )",
            "            stream.seek(0, os.SEEK_END)",
            "",
            "    def _find_eof_marker(self, stream: StreamType) -> None:",
            "        last_mb = 8  # to parse whole file",
            "        line = b\"\"",
            "        while line[:5] != b\"%%EOF\":",
            "            if stream.tell() < last_mb:",
            "                raise PdfReadError(\"EOF marker not found\")",
            "            line = read_previous_line(stream)",
            "",
            "    def _find_startxref_pos(self, stream: StreamType) -> int:",
            "        \"\"\"Find startxref entry - the location of the xref table\"\"\"",
            "        line = read_previous_line(stream)",
            "        try:",
            "            startxref = int(line)",
            "        except ValueError:",
            "            # 'startxref' may be on the same line as the location",
            "            if not line.startswith(b\"startxref\"):",
            "                raise PdfReadError(\"startxref not found\")",
            "            startxref = int(line[9:].strip())",
            "            logger_warning(\"startxref on same line as offset\", __name__)",
            "        else:",
            "            line = read_previous_line(stream)",
            "            if line[:9] != b\"startxref\":",
            "                raise PdfReadError(\"startxref not found\")",
            "        return startxref",
            "",
            "    def _read_standard_xref_table(self, stream: StreamType) -> None:",
            "        # standard cross-reference table",
            "        ref = stream.read(4)",
            "        if ref[:3] != b\"ref\":",
            "            raise PdfReadError(\"xref table read error\")",
            "        read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        firsttime = True  # check if the first time looking at the xref table",
            "        while True:",
            "            num = cast(int, read_object(stream, self))",
            "            if firsttime and num != 0:",
            "                self.xref_index = num",
            "                if self.strict:",
            "                    logger_warning(",
            "                        \"Xref table not zero-indexed. ID numbers for objects will be corrected.\",",
            "                        __name__,",
            "                    )",
            "                    # if table not zero indexed, could be due to error from when PDF was created",
            "                    # which will lead to mismatched indices later on, only warned and corrected if self.strict==True",
            "            firsttime = False",
            "            read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            size = cast(int, read_object(stream, self))",
            "            read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            cnt = 0",
            "            while cnt < size:",
            "                line = stream.read(20)",
            "",
            "                # It's very clear in section 3.4.3 of the PDF spec",
            "                # that all cross-reference table lines are a fixed",
            "                # 20 bytes (as of PDF 1.7). However, some files have",
            "                # 21-byte entries (or more) due to the use of \\r\\n",
            "                # (CRLF) EOL's. Detect that case, and adjust the line",
            "                # until it does not begin with a \\r (CR) or \\n (LF).",
            "                while line[0] in b\"\\x0D\\x0A\":",
            "                    stream.seek(-20 + 1, 1)",
            "                    line = stream.read(20)",
            "",
            "                # On the other hand, some malformed PDF files",
            "                # use a single character EOL without a preceding",
            "                # space.  Detect that case, and seek the stream",
            "                # back one character.  (0-9 means we've bled into",
            "                # the next xref entry, t means we've bled into the",
            "                # text \"trailer\"):",
            "                if line[-1] in b\"0123456789t\":",
            "                    stream.seek(-1, 1)",
            "",
            "                try:",
            "                    offset_b, generation_b = line[:16].split(b\" \")",
            "                    entry_type_b = line[17:18]",
            "",
            "                    offset, generation = int(offset_b), int(generation_b)",
            "                except Exception:",
            "                    # if something wrong occured",
            "                    if hasattr(stream, \"getbuffer\"):",
            "                        buf = bytes(stream.getbuffer())  # type: ignore",
            "                    else:",
            "                        p = stream.tell()",
            "                        stream.seek(0, 0)",
            "                        buf = stream.read(-1)",
            "                        stream.seek(p)",
            "",
            "                    f = re.search(f\"{num}\\\\s+(\\\\d+)\\\\s+obj\".encode(), buf)",
            "                    if f is None:",
            "                        logger_warning(",
            "                            f\"entry {num} in Xref table invalid; object not found\",",
            "                            __name__,",
            "                        )",
            "                        generation = 65535",
            "                        offset = -1",
            "                    else:",
            "                        logger_warning(",
            "                            f\"entry {num} in Xref table invalid but object found\",",
            "                            __name__,",
            "                        )",
            "                        generation = int(f.group(1))",
            "                        offset = f.start()",
            "",
            "                if generation not in self.xref:",
            "                    self.xref[generation] = {}",
            "                    self.xref_free_entry[generation] = {}",
            "                if num in self.xref[generation]:",
            "                    # It really seems like we should allow the last",
            "                    # xref table in the file to override previous",
            "                    # ones. Since we read the file backwards, assume",
            "                    # any existing key is already set correctly.",
            "                    pass",
            "                else:",
            "                    self.xref[generation][num] = offset",
            "                    try:",
            "                        self.xref_free_entry[generation][num] = entry_type_b == b\"f\"",
            "                    except Exception:",
            "                        pass",
            "                    try:",
            "                        self.xref_free_entry[65535][num] = entry_type_b == b\"f\"",
            "                    except Exception:",
            "                        pass",
            "                cnt += 1",
            "                num += 1",
            "            read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            trailertag = stream.read(7)",
            "            if trailertag != b\"trailer\":",
            "                # more xrefs!",
            "                stream.seek(-7, 1)",
            "            else:",
            "                break",
            "",
            "    def _read_xref_tables_and_trailers(",
            "        self, stream: StreamType, startxref: Optional[int], xref_issue_nr: int",
            "    ) -> None:",
            "        self.xref: Dict[int, Dict[Any, Any]] = {}",
            "        self.xref_free_entry: Dict[int, Dict[Any, Any]] = {}",
            "        self.xref_objStm: Dict[int, Tuple[Any, Any]] = {}",
            "        self.trailer = DictionaryObject()",
            "        while startxref is not None:",
            "            # load the xref table",
            "            stream.seek(startxref, 0)",
            "            x = stream.read(1)",
            "            if x in b\"\\r\\n\":",
            "                x = stream.read(1)",
            "            if x == b\"x\":",
            "                startxref = self._read_xref(stream)",
            "            elif xref_issue_nr:",
            "                try:",
            "                    self._rebuild_xref_table(stream)",
            "                    break",
            "                except Exception:",
            "                    xref_issue_nr = 0",
            "            elif x.isdigit():",
            "                try:",
            "                    xrefstream = self._read_pdf15_xref_stream(stream)",
            "                except Exception as e:",
            "                    if TK.ROOT in self.trailer:",
            "                        logger_warning(",
            "                            f\"Previous trailer can not be read {e.args}\",",
            "                            __name__,",
            "                        )",
            "                        break",
            "                    else:",
            "                        raise PdfReadError(f\"trailer can not be read {e.args}\")",
            "                trailer_keys = TK.ROOT, TK.ENCRYPT, TK.INFO, TK.ID",
            "                for key in trailer_keys:",
            "                    if key in xrefstream and key not in self.trailer:",
            "                        self.trailer[NameObject(key)] = xrefstream.raw_get(key)",
            "                if \"/XRefStm\" in xrefstream:",
            "                    p = stream.tell()",
            "                    stream.seek(cast(int, xrefstream[\"/XRefStm\"]) + 1, 0)",
            "                    self._read_pdf15_xref_stream(stream)",
            "                    stream.seek(p, 0)",
            "                if \"/Prev\" in xrefstream:",
            "                    startxref = cast(int, xrefstream[\"/Prev\"])",
            "                else:",
            "                    break",
            "            else:",
            "                startxref = self._read_xref_other_error(stream, startxref)",
            "",
            "    def _read_xref(self, stream: StreamType) -> Optional[int]:",
            "        self._read_standard_xref_table(stream)",
            "        read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        new_trailer = cast(Dict[str, Any], read_object(stream, self))",
            "        for key, value in new_trailer.items():",
            "            if key not in self.trailer:",
            "                self.trailer[key] = value",
            "        if \"/XRefStm\" in new_trailer:",
            "            p = stream.tell()",
            "            stream.seek(cast(int, new_trailer[\"/XRefStm\"]) + 1, 0)",
            "            try:",
            "                self._read_pdf15_xref_stream(stream)",
            "            except Exception:",
            "                logger_warning(",
            "                    f\"XRef object at {new_trailer['/XRefStm']} can not be read, some object may be missing\",",
            "                    __name__,",
            "                )",
            "            stream.seek(p, 0)",
            "        if \"/Prev\" in new_trailer:",
            "            startxref = new_trailer[\"/Prev\"]",
            "            return startxref",
            "        else:",
            "            return None",
            "",
            "    def _read_xref_other_error(",
            "        self, stream: StreamType, startxref: int",
            "    ) -> Optional[int]:",
            "        # some PDFs have /Prev=0 in the trailer, instead of no /Prev",
            "        if startxref == 0:",
            "            if self.strict:",
            "                raise PdfReadError(",
            "                    \"/Prev=0 in the trailer (try opening with strict=False)\"",
            "                )",
            "            logger_warning(",
            "                \"/Prev=0 in the trailer - assuming there is no previous xref table\",",
            "                __name__,",
            "            )",
            "            return None",
            "        # bad xref character at startxref.  Let's see if we can find",
            "        # the xref table nearby, as we've observed this error with an",
            "        # off-by-one before.",
            "        stream.seek(-11, 1)",
            "        tmp = stream.read(20)",
            "        xref_loc = tmp.find(b\"xref\")",
            "        if xref_loc != -1:",
            "            startxref -= 10 - xref_loc",
            "            return startxref",
            "        # No explicit xref table, try finding a cross-reference stream.",
            "        stream.seek(startxref, 0)",
            "        for look in range(5):",
            "            if stream.read(1).isdigit():",
            "                # This is not a standard PDF, consider adding a warning",
            "                startxref += look",
            "                return startxref",
            "        # no xref table found at specified location",
            "        if \"/Root\" in self.trailer and not self.strict:",
            "            # if Root has been already found, just raise warning",
            "            logger_warning(\"Invalid parent xref., rebuild xref\", __name__)",
            "            try:",
            "                self._rebuild_xref_table(stream)",
            "                return None",
            "            except Exception:",
            "                raise PdfReadError(\"can not rebuild xref\")",
            "        raise PdfReadError(\"Could not find xref table at specified location\")",
            "",
            "    def _read_pdf15_xref_stream(",
            "        self, stream: StreamType",
            "    ) -> Union[ContentStream, EncodedStreamObject, DecodedStreamObject]:",
            "        # PDF 1.5+ Cross-Reference Stream",
            "        stream.seek(-1, 1)",
            "        idnum, generation = self.read_object_header(stream)",
            "        xrefstream = cast(ContentStream, read_object(stream, self))",
            "        assert cast(str, xrefstream[\"/Type\"]) == \"/XRef\"",
            "        self.cache_indirect_object(generation, idnum, xrefstream)",
            "        stream_data = BytesIO(b_(xrefstream.get_data()))",
            "        # Index pairs specify the subsections in the dictionary. If",
            "        # none create one subsection that spans everything.",
            "        idx_pairs = xrefstream.get(\"/Index\", [0, xrefstream.get(\"/Size\")])",
            "        entry_sizes = cast(Dict[Any, Any], xrefstream.get(\"/W\"))",
            "        assert len(entry_sizes) >= 3",
            "        if self.strict and len(entry_sizes) > 3:",
            "            raise PdfReadError(f\"Too many entry sizes: {entry_sizes}\")",
            "",
            "        def get_entry(i: int) -> Union[int, Tuple[int, ...]]:",
            "            # Reads the correct number of bytes for each entry. See the",
            "            # discussion of the W parameter in PDF spec table 17.",
            "            if entry_sizes[i] > 0:",
            "                d = stream_data.read(entry_sizes[i])",
            "                return convert_to_int(d, entry_sizes[i])",
            "",
            "            # PDF Spec Table 17: A value of zero for an element in the",
            "            # W array indicates...the default value shall be used",
            "            if i == 0:",
            "                return 1  # First value defaults to 1",
            "            else:",
            "                return 0",
            "",
            "        def used_before(num: int, generation: Union[int, Tuple[int, ...]]) -> bool:",
            "            # We move backwards through the xrefs, don't replace any.",
            "            return num in self.xref.get(generation, []) or num in self.xref_objStm  # type: ignore",
            "",
            "        # Iterate through each subsection",
            "        self._read_xref_subsections(idx_pairs, get_entry, used_before)",
            "        return xrefstream",
            "",
            "    @staticmethod",
            "    def _get_xref_issues(stream: StreamType, startxref: int) -> int:",
            "        \"\"\"Return an int which indicates an issue. 0 means there is no issue.\"\"\"",
            "        stream.seek(startxref - 1, 0)  # -1 to check character before",
            "        line = stream.read(1)",
            "        if line not in b\"\\r\\n \\t\":",
            "            return 1",
            "        line = stream.read(4)",
            "        if line != b\"xref\":",
            "            # not an xref so check if it is an XREF object",
            "            line = b\"\"",
            "            while line in b\"0123456789 \\t\":",
            "                line = stream.read(1)",
            "                if line == b\"\":",
            "                    return 2",
            "            line += stream.read(2)  # 1 char already read, +2 to check \"obj\"",
            "            if line.lower() != b\"obj\":",
            "                return 3",
            "            # while stream.read(1) in b\" \\t\\r\\n\":",
            "            #     pass",
            "            # line = stream.read(256)  # check that it is xref obj",
            "            # if b\"/xref\" not in line.lower():",
            "            #     return 4",
            "        return 0",
            "",
            "    def _rebuild_xref_table(self, stream: StreamType) -> None:",
            "        self.xref = {}",
            "        stream.seek(0, 0)",
            "        f_ = stream.read(-1)",
            "",
            "        for m in re.finditer(rb\"[\\r\\n \\t][ \\t]*(\\d+)[ \\t]+(\\d+)[ \\t]+obj\", f_):",
            "            idnum = int(m.group(1))",
            "            generation = int(m.group(2))",
            "            if generation not in self.xref:",
            "                self.xref[generation] = {}",
            "            self.xref[generation][idnum] = m.start(1)",
            "        stream.seek(0, 0)",
            "        for m in re.finditer(rb\"[\\r\\n \\t][ \\t]*trailer[\\r\\n \\t]*(<<)\", f_):",
            "            stream.seek(m.start(1), 0)",
            "            new_trailer = cast(Dict[Any, Any], read_object(stream, self))",
            "            # Here, we are parsing the file from start to end, the new data have to erase the existing.",
            "            for key, value in list(new_trailer.items()):",
            "                self.trailer[key] = value",
            "",
            "    def _read_xref_subsections(",
            "        self,",
            "        idx_pairs: List[int],",
            "        get_entry: Callable[[int], Union[int, Tuple[int, ...]]],",
            "        used_before: Callable[[int, Union[int, Tuple[int, ...]]], bool],",
            "    ) -> None:",
            "        last_end = 0",
            "        for start, size in self._pairs(idx_pairs):",
            "            # The subsections must increase",
            "            assert start >= last_end",
            "            last_end = start + size",
            "            for num in range(start, start + size):",
            "                # The first entry is the type",
            "                xref_type = get_entry(0)",
            "                # The rest of the elements depend on the xref_type",
            "                if xref_type == 0:",
            "                    # linked list of free objects",
            "                    next_free_object = get_entry(1)  # noqa: F841",
            "                    next_generation = get_entry(2)  # noqa: F841",
            "                elif xref_type == 1:",
            "                    # objects that are in use but are not compressed",
            "                    byte_offset = get_entry(1)",
            "                    generation = get_entry(2)",
            "                    if generation not in self.xref:",
            "                        self.xref[generation] = {}  # type: ignore",
            "                    if not used_before(num, generation):",
            "                        self.xref[generation][num] = byte_offset  # type: ignore",
            "                elif xref_type == 2:",
            "                    # compressed objects",
            "                    objstr_num = get_entry(1)",
            "                    obstr_idx = get_entry(2)",
            "                    generation = 0  # PDF spec table 18, generation is 0",
            "                    if not used_before(num, generation):",
            "                        self.xref_objStm[num] = (objstr_num, obstr_idx)",
            "                elif self.strict:",
            "                    raise PdfReadError(f\"Unknown xref type: {xref_type}\")",
            "",
            "    def _pairs(self, array: List[int]) -> Iterable[Tuple[int, int]]:",
            "        i = 0",
            "        while True:",
            "            yield array[i], array[i + 1]",
            "            i += 2",
            "            if (i + 1) >= len(array):",
            "                break",
            "",
            "    def read_next_end_line(",
            "        self, stream: StreamType, limit_offset: int = 0",
            "    ) -> bytes:  # pragma: no cover",
            "        \"\"\".. deprecated:: 2.1.0\"\"\"",
            "        deprecate_no_replacement(\"read_next_end_line\", removed_in=\"4.0.0\")",
            "        line_parts = []",
            "        while True:",
            "            # Prevent infinite loops in malformed PDFs",
            "            if stream.tell() == 0 or stream.tell() == limit_offset:",
            "                raise PdfReadError(\"Could not read malformed PDF file\")",
            "            x = stream.read(1)",
            "            if stream.tell() < 2:",
            "                raise PdfReadError(\"EOL marker not found\")",
            "            stream.seek(-2, 1)",
            "            if x in (b\"\\n\", b\"\\r\"):  # \\n = LF; \\r = CR",
            "                crlf = False",
            "                while x in (b\"\\n\", b\"\\r\"):",
            "                    x = stream.read(1)",
            "                    if x in (b\"\\n\", b\"\\r\"):  # account for CR+LF",
            "                        stream.seek(-1, 1)",
            "                        crlf = True",
            "                    if stream.tell() < 2:",
            "                        raise PdfReadError(\"EOL marker not found\")",
            "                    stream.seek(-2, 1)",
            "                stream.seek(",
            "                    2 if crlf else 1, 1",
            "                )  # if using CR+LF, go back 2 bytes, else 1",
            "                break",
            "            else:",
            "                line_parts.append(x)",
            "        line_parts.reverse()",
            "        return b\"\".join(line_parts)",
            "",
            "    def readNextEndLine(",
            "        self, stream: StreamType, limit_offset: int = 0",
            "    ) -> bytes:  # pragma: no cover",
            "        \"\"\".. deprecated:: 1.28.0\"\"\"",
            "        deprecate_no_replacement(\"readNextEndLine\")",
            "        return self.read_next_end_line(stream, limit_offset)",
            "",
            "    def decrypt(self, password: Union[str, bytes]) -> PasswordType:",
            "        \"\"\"",
            "        When using an encrypted / secured PDF file with the PDF Standard",
            "        encryption handler, this function will allow the file to be decrypted.",
            "        It checks the given password against the document's user password and",
            "        owner password, and then stores the resulting decryption key if either",
            "        password is correct.",
            "",
            "        It does not matter which password was matched.  Both passwords provide",
            "        the correct decryption key that will allow the document to be used with",
            "        this library.",
            "",
            "        :param str password: The password to match.",
            "        :return: `PasswordType`.",
            "        \"\"\"",
            "        if not self._encryption:",
            "            raise PdfReadError(\"Not encrypted file\")",
            "        # TODO: raise Exception for wrong password",
            "        return self._encryption.verify(password)",
            "",
            "    def decode_permissions(self, permissions_code: int) -> Dict[str, bool]:",
            "        # Takes the permissions as an integer, returns the allowed access",
            "        permissions = {}",
            "        permissions[\"print\"] = permissions_code & (1 << 3 - 1) != 0  # bit 3",
            "        permissions[\"modify\"] = permissions_code & (1 << 4 - 1) != 0  # bit 4",
            "        permissions[\"copy\"] = permissions_code & (1 << 5 - 1) != 0  # bit 5",
            "        permissions[\"annotations\"] = permissions_code & (1 << 6 - 1) != 0  # bit 6",
            "        permissions[\"forms\"] = permissions_code & (1 << 9 - 1) != 0  # bit 9",
            "        permissions[\"accessability\"] = permissions_code & (1 << 10 - 1) != 0  # bit 10",
            "        permissions[\"assemble\"] = permissions_code & (1 << 11 - 1) != 0  # bit 11",
            "        permissions[\"print_high_quality\"] = (",
            "            permissions_code & (1 << 12 - 1) != 0",
            "        )  # bit 12",
            "        return permissions",
            "",
            "    @property",
            "    def is_encrypted(self) -> bool:",
            "        \"\"\"",
            "        Read-only boolean property showing whether this PDF file is encrypted.",
            "        Note that this property, if true, will remain true even after the",
            "        :meth:`decrypt()<PyPDF2.PdfReader.decrypt>` method is called.",
            "        \"\"\"",
            "        return TK.ENCRYPT in self.trailer",
            "",
            "    def getIsEncrypted(self) -> bool:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`is_encrypted` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getIsEncrypted\", \"is_encrypted\")",
            "        return self.is_encrypted",
            "",
            "    @property",
            "    def isEncrypted(self) -> bool:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.0",
            "",
            "            Use :py:attr:`is_encrypted` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"isEncrypted\", \"is_encrypted\")",
            "        return self.is_encrypted",
            "",
            "    @property",
            "    def xfa(self) -> Optional[Dict[str, Any]]:",
            "        tree: Optional[TreeObject] = None",
            "        retval: Dict[str, Any] = {}",
            "        catalog = cast(DictionaryObject, self.trailer[TK.ROOT])",
            "",
            "        if \"/AcroForm\" not in catalog or not catalog[\"/AcroForm\"]:",
            "            return None",
            "",
            "        tree = cast(TreeObject, catalog[\"/AcroForm\"])",
            "",
            "        if \"/XFA\" in tree:",
            "            fields = cast(ArrayObject, tree[\"/XFA\"])",
            "            i = iter(fields)",
            "            for f in i:",
            "                tag = f",
            "                f = next(i)",
            "                if isinstance(f, IndirectObject):",
            "                    field = cast(Optional[EncodedStreamObject], f.get_object())",
            "                    if field:",
            "                        es = zlib.decompress(field._data)",
            "                        retval[tag] = es",
            "        return retval",
            "",
            "    def _get_indirect_object(self, num: int, gen: int) -> Optional[PdfObject]:",
            "        \"\"\"",
            "        used to ease development",
            "        equivalent to generic.IndirectObject(num,gen,self).get_object()",
            "        \"\"\"",
            "        return IndirectObject(num, gen, self).get_object()",
            "",
            "",
            "class PdfFileReader(PdfReader):  # pragma: no cover",
            "    def __init__(self, *args: Any, **kwargs: Any) -> None:",
            "        deprecate_with_replacement(\"PdfFileReader\", \"PdfReader\")",
            "        if \"strict\" not in kwargs and len(args) < 2:",
            "            kwargs[\"strict\"] = True  # maintain the default",
            "        super().__init__(*args, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "PyPDF2._reader.PdfReader.getObject",
            "litellm.utils.token_counter"
        ]
    },
    "PyPDF2/generic/_base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 420,
                "PatchRowcode": "         deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")"
            },
            "1": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 421,
                "PatchRowcode": "         self.write_to_stream(stream, encryption_key)"
            },
            "2": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 422,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+    @staticmethod"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+    def unnumber(sin: str) -> str:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+        i = sin.find(\"#\")"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+        while i >= 0:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+            sin = sin[:i] + chr(int(sin[i + 1 : i + 3], 16)) + sin[i + 3 :]"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+            i = sin.find(\"#\")"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+        return sin"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 431,
                "PatchRowcode": "     @staticmethod"
            },
            "12": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "     def read_from_stream(stream: StreamType, pdf: Any) -> \"NameObject\":  # PdfReader"
            },
            "13": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "         name = stream.read(1)"
            },
            "14": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "                 ret = name.decode(\"utf-8\")"
            },
            "15": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 440,
                "PatchRowcode": "             except (UnicodeEncodeError, UnicodeDecodeError):"
            },
            "16": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "                 ret = name.decode(\"gbk\")"
            },
            "17": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return NameObject(ret)"
            },
            "18": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except (UnicodeEncodeError, UnicodeDecodeError) as e:"
            },
            "19": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "             # Name objects should represent irregular characters"
            },
            "20": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "             # with a '#' followed by the symbol's hex number"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+            ret = NameObject.unnumber(ret)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+            return NameObject(ret)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+        except (UnicodeEncodeError, UnicodeDecodeError) as e:"
            },
            "24": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "             if not pdf.strict:"
            },
            "25": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "                 logger_warning(\"Illegal character in Name Object\", __name__)"
            },
            "26": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "                 return NameObject(name)"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2006, Mathieu Fenniak",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without",
            "# modification, are permitted provided that the following conditions are",
            "# met:",
            "#",
            "# * Redistributions of source code must retain the above copyright notice,",
            "# this list of conditions and the following disclaimer.",
            "# * Redistributions in binary form must reproduce the above copyright notice,",
            "# this list of conditions and the following disclaimer in the documentation",
            "# and/or other materials provided with the distribution.",
            "# * The name of the author may not be used to endorse or promote products",
            "# derived from this software without specific prior written permission.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
            "# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
            "# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
            "# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
            "# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
            "# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
            "# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
            "# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
            "# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
            "# POSSIBILITY OF SUCH DAMAGE.",
            "",
            "import codecs",
            "import decimal",
            "import hashlib",
            "import re",
            "from typing import Any, Callable, Optional, Union",
            "",
            "from .._codecs import _pdfdoc_encoding_rev",
            "from .._utils import (",
            "    StreamType,",
            "    b_,",
            "    deprecate_with_replacement,",
            "    hex_str,",
            "    hexencode,",
            "    logger_warning,",
            "    read_non_whitespace,",
            "    read_until_regex,",
            "    str_,",
            ")",
            "from ..errors import STREAM_TRUNCATED_PREMATURELY, PdfReadError, PdfStreamError",
            "",
            "__author__ = \"Mathieu Fenniak\"",
            "__author_email__ = \"biziqe@mathieu.fenniak.net\"",
            "",
            "",
            "class PdfObject:",
            "    # function for calculating a hash value",
            "    hash_func: Callable[..., \"hashlib._Hash\"] = hashlib.sha1",
            "",
            "    def hash_value_data(self) -> bytes:",
            "        return (\"%s\" % self).encode()",
            "",
            "    def hash_value(self) -> bytes:",
            "        return (",
            "            \"%s:%s\"",
            "            % (",
            "                self.__class__.__name__,",
            "                self.hash_func(self.hash_value_data()).hexdigest(),",
            "            )",
            "        ).encode()",
            "",
            "    def get_object(self) -> Optional[\"PdfObject\"]:",
            "        \"\"\"Resolve indirect references.\"\"\"",
            "        return self",
            "",
            "    def getObject(self) -> Optional[\"PdfObject\"]:  # pragma: no cover",
            "        deprecate_with_replacement(\"getObject\", \"get_object\")",
            "        return self.get_object()",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        raise NotImplementedError",
            "",
            "",
            "class NullObject(PdfObject):",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"null\")",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType) -> \"NullObject\":",
            "        nulltxt = stream.read(4)",
            "        if nulltxt != b\"null\":",
            "            raise PdfReadError(\"Could not read Null object\")",
            "        return NullObject()",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    def __repr__(self) -> str:",
            "        return \"NullObject\"",
            "",
            "    @staticmethod",
            "    def readFromStream(stream: StreamType) -> \"NullObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return NullObject.read_from_stream(stream)",
            "",
            "",
            "class BooleanObject(PdfObject):",
            "    def __init__(self, value: Any) -> None:",
            "        self.value = value",
            "",
            "    def __eq__(self, __o: object) -> bool:",
            "        if isinstance(__o, BooleanObject):",
            "            return self.value == __o.value",
            "        elif isinstance(__o, bool):",
            "            return self.value == __o",
            "        else:",
            "            return False",
            "",
            "    def __repr__(self) -> str:",
            "        return \"True\" if self.value else \"False\"",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        if self.value:",
            "            stream.write(b\"true\")",
            "        else:",
            "            stream.write(b\"false\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType) -> \"BooleanObject\":",
            "        word = stream.read(4)",
            "        if word == b\"true\":",
            "            return BooleanObject(True)",
            "        elif word == b\"fals\":",
            "            stream.read(1)",
            "            return BooleanObject(False)",
            "        else:",
            "            raise PdfReadError(\"Could not read Boolean object\")",
            "",
            "    @staticmethod",
            "    def readFromStream(stream: StreamType) -> \"BooleanObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return BooleanObject.read_from_stream(stream)",
            "",
            "",
            "class IndirectObject(PdfObject):",
            "    def __init__(self, idnum: int, generation: int, pdf: Any) -> None:  # PdfReader",
            "        self.idnum = idnum",
            "        self.generation = generation",
            "        self.pdf = pdf",
            "",
            "    def get_object(self) -> Optional[PdfObject]:",
            "        obj = self.pdf.get_object(self)",
            "        if obj is None:",
            "            return None",
            "        return obj.get_object()",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"IndirectObject({self.idnum!r}, {self.generation!r}, {id(self.pdf)})\"",
            "",
            "    def __eq__(self, other: Any) -> bool:",
            "        return (",
            "            other is not None",
            "            and isinstance(other, IndirectObject)",
            "            and self.idnum == other.idnum",
            "            and self.generation == other.generation",
            "            and self.pdf is other.pdf",
            "        )",
            "",
            "    def __ne__(self, other: Any) -> bool:",
            "        return not self.__eq__(other)",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b_(f\"{self.idnum} {self.generation} R\"))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType, pdf: Any) -> \"IndirectObject\":  # PdfReader",
            "        idnum = b\"\"",
            "        while True:",
            "            tok = stream.read(1)",
            "            if not tok:",
            "                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)",
            "            if tok.isspace():",
            "                break",
            "            idnum += tok",
            "        generation = b\"\"",
            "        while True:",
            "            tok = stream.read(1)",
            "            if not tok:",
            "                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)",
            "            if tok.isspace():",
            "                if not generation:",
            "                    continue",
            "                break",
            "            generation += tok",
            "        r = read_non_whitespace(stream)",
            "        if r != b\"R\":",
            "            raise PdfReadError(",
            "                f\"Error reading indirect object reference at byte {hex_str(stream.tell())}\"",
            "            )",
            "        return IndirectObject(int(idnum), int(generation), pdf)",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"IndirectObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return IndirectObject.read_from_stream(stream, pdf)",
            "",
            "",
            "class FloatObject(decimal.Decimal, PdfObject):",
            "    def __new__(",
            "        cls, value: Union[str, Any] = \"0\", context: Optional[Any] = None",
            "    ) -> \"FloatObject\":",
            "        try:",
            "            return decimal.Decimal.__new__(cls, str_(value), context)",
            "        except Exception:",
            "            # If this isn't a valid decimal (happens in malformed PDFs)",
            "            # fallback to 0",
            "            logger_warning(f\"FloatObject ({value}) invalid; use 0.0 instead\", __name__)",
            "            return decimal.Decimal.__new__(cls, \"0.0\")",
            "",
            "    def __repr__(self) -> str:",
            "        if self == self.to_integral():",
            "            return str(self.quantize(decimal.Decimal(1)))",
            "        else:",
            "            # Standard formatting adds useless extraneous zeros.",
            "            o = f\"{self:.5f}\"",
            "            # Remove the zeros.",
            "            while o and o[-1] == \"0\":",
            "                o = o[:-1]",
            "            return o",
            "",
            "    def as_numeric(self) -> float:",
            "        return float(repr(self).encode(\"utf8\"))",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(repr(self).encode(\"utf8\"))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "",
            "class NumberObject(int, PdfObject):",
            "    NumberPattern = re.compile(b\"[^+-.0-9]\")",
            "",
            "    def __new__(cls, value: Any) -> \"NumberObject\":",
            "        try:",
            "            return int.__new__(cls, int(value))",
            "        except ValueError:",
            "            logger_warning(f\"NumberObject({value}) invalid; use 0 instead\", __name__)",
            "            return int.__new__(cls, 0)",
            "",
            "    def as_numeric(self) -> int:",
            "        return int(repr(self).encode(\"utf8\"))",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(repr(self).encode(\"utf8\"))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType) -> Union[\"NumberObject\", FloatObject]:",
            "        num = read_until_regex(stream, NumberObject.NumberPattern)",
            "        if num.find(b\".\") != -1:",
            "            return FloatObject(num)",
            "        return NumberObject(num)",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType,",
            "    ) -> Union[\"NumberObject\", FloatObject]:  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return NumberObject.read_from_stream(stream)",
            "",
            "",
            "class ByteStringObject(bytes, PdfObject):",
            "    \"\"\"",
            "    Represents a string object where the text encoding could not be determined.",
            "    This occurs quite often, as the PDF spec doesn't provide an alternate way to",
            "    represent strings -- for example, the encryption data stored in files (like",
            "    /O) is clearly not text, but is still stored in a \"String\" object.",
            "    \"\"\"",
            "",
            "    @property",
            "    def original_bytes(self) -> bytes:",
            "        \"\"\"For compatibility with TextStringObject.original_bytes.\"\"\"",
            "        return self",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        bytearr = self",
            "        if encryption_key:",
            "            from .._security import RC4_encrypt",
            "",
            "            bytearr = RC4_encrypt(encryption_key, bytearr)  # type: ignore",
            "        stream.write(b\"<\")",
            "        stream.write(hexencode(bytearr))",
            "        stream.write(b\">\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "",
            "class TextStringObject(str, PdfObject):",
            "    \"\"\"",
            "    Represents a string object that has been decoded into a real unicode string.",
            "    If read from a PDF document, this string appeared to match the",
            "    PDFDocEncoding, or contained a UTF-16BE BOM mark to cause UTF-16 decoding to",
            "    occur.",
            "    \"\"\"",
            "",
            "    autodetect_pdfdocencoding = False",
            "    autodetect_utf16 = False",
            "",
            "    @property",
            "    def original_bytes(self) -> bytes:",
            "        \"\"\"",
            "        It is occasionally possible that a text string object gets created where",
            "        a byte string object was expected due to the autodetection mechanism --",
            "        if that occurs, this \"original_bytes\" property can be used to",
            "        back-calculate what the original encoded bytes were.",
            "        \"\"\"",
            "        return self.get_original_bytes()",
            "",
            "    def get_original_bytes(self) -> bytes:",
            "        # We're a text string object, but the library is trying to get our raw",
            "        # bytes.  This can happen if we auto-detected this string as text, but",
            "        # we were wrong.  It's pretty common.  Return the original bytes that",
            "        # would have been used to create this object, based upon the autodetect",
            "        # method.",
            "        if self.autodetect_utf16:",
            "            return codecs.BOM_UTF16_BE + self.encode(\"utf-16be\")",
            "        elif self.autodetect_pdfdocencoding:",
            "            return encode_pdfdocencoding(self)",
            "        else:",
            "            raise Exception(\"no information about original bytes\")",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        # Try to write the string out as a PDFDocEncoding encoded string.  It's",
            "        # nicer to look at in the PDF file.  Sadly, we take a performance hit",
            "        # here for trying...",
            "        try:",
            "            bytearr = encode_pdfdocencoding(self)",
            "        except UnicodeEncodeError:",
            "            bytearr = codecs.BOM_UTF16_BE + self.encode(\"utf-16be\")",
            "        if encryption_key:",
            "            from .._security import RC4_encrypt",
            "",
            "            bytearr = RC4_encrypt(encryption_key, bytearr)",
            "            obj = ByteStringObject(bytearr)",
            "            obj.write_to_stream(stream, None)",
            "        else:",
            "            stream.write(b\"(\")",
            "            for c in bytearr:",
            "                if not chr(c).isalnum() and c != b\" \":",
            "                    # This:",
            "                    #   stream.write(b_(rf\"\\{c:0>3o}\"))",
            "                    # gives",
            "                    #   https://github.com/davidhalter/parso/issues/207",
            "                    stream.write(b_(\"\\\\%03o\" % c))",
            "                else:",
            "                    stream.write(b_(chr(c)))",
            "            stream.write(b\")\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "",
            "class NameObject(str, PdfObject):",
            "    delimiter_pattern = re.compile(rb\"\\s+|[\\(\\)<>\\[\\]{}/%]\")",
            "    surfix = b\"/\"",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b_(self))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType, pdf: Any) -> \"NameObject\":  # PdfReader",
            "        name = stream.read(1)",
            "        if name != NameObject.surfix:",
            "            raise PdfReadError(\"name read error\")",
            "        name += read_until_regex(stream, NameObject.delimiter_pattern, ignore_eof=True)",
            "        try:",
            "            try:",
            "                ret = name.decode(\"utf-8\")",
            "            except (UnicodeEncodeError, UnicodeDecodeError):",
            "                ret = name.decode(\"gbk\")",
            "            return NameObject(ret)",
            "        except (UnicodeEncodeError, UnicodeDecodeError) as e:",
            "            # Name objects should represent irregular characters",
            "            # with a '#' followed by the symbol's hex number",
            "            if not pdf.strict:",
            "                logger_warning(\"Illegal character in Name Object\", __name__)",
            "                return NameObject(name)",
            "            else:",
            "                raise PdfReadError(\"Illegal character in Name Object\") from e",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"NameObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return NameObject.read_from_stream(stream, pdf)",
            "",
            "",
            "def encode_pdfdocencoding(unicode_string: str) -> bytes:",
            "    retval = b\"\"",
            "    for c in unicode_string:",
            "        try:",
            "            retval += b_(chr(_pdfdoc_encoding_rev[c]))",
            "        except KeyError:",
            "            raise UnicodeEncodeError(",
            "                \"pdfdocencoding\", c, -1, -1, \"does not exist in translation table\"",
            "            )",
            "    return retval"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2006, Mathieu Fenniak",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without",
            "# modification, are permitted provided that the following conditions are",
            "# met:",
            "#",
            "# * Redistributions of source code must retain the above copyright notice,",
            "# this list of conditions and the following disclaimer.",
            "# * Redistributions in binary form must reproduce the above copyright notice,",
            "# this list of conditions and the following disclaimer in the documentation",
            "# and/or other materials provided with the distribution.",
            "# * The name of the author may not be used to endorse or promote products",
            "# derived from this software without specific prior written permission.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
            "# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
            "# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
            "# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
            "# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
            "# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
            "# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
            "# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
            "# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
            "# POSSIBILITY OF SUCH DAMAGE.",
            "",
            "import codecs",
            "import decimal",
            "import hashlib",
            "import re",
            "from typing import Any, Callable, Optional, Union",
            "",
            "from .._codecs import _pdfdoc_encoding_rev",
            "from .._utils import (",
            "    StreamType,",
            "    b_,",
            "    deprecate_with_replacement,",
            "    hex_str,",
            "    hexencode,",
            "    logger_warning,",
            "    read_non_whitespace,",
            "    read_until_regex,",
            "    str_,",
            ")",
            "from ..errors import STREAM_TRUNCATED_PREMATURELY, PdfReadError, PdfStreamError",
            "",
            "__author__ = \"Mathieu Fenniak\"",
            "__author_email__ = \"biziqe@mathieu.fenniak.net\"",
            "",
            "",
            "class PdfObject:",
            "    # function for calculating a hash value",
            "    hash_func: Callable[..., \"hashlib._Hash\"] = hashlib.sha1",
            "",
            "    def hash_value_data(self) -> bytes:",
            "        return (\"%s\" % self).encode()",
            "",
            "    def hash_value(self) -> bytes:",
            "        return (",
            "            \"%s:%s\"",
            "            % (",
            "                self.__class__.__name__,",
            "                self.hash_func(self.hash_value_data()).hexdigest(),",
            "            )",
            "        ).encode()",
            "",
            "    def get_object(self) -> Optional[\"PdfObject\"]:",
            "        \"\"\"Resolve indirect references.\"\"\"",
            "        return self",
            "",
            "    def getObject(self) -> Optional[\"PdfObject\"]:  # pragma: no cover",
            "        deprecate_with_replacement(\"getObject\", \"get_object\")",
            "        return self.get_object()",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        raise NotImplementedError",
            "",
            "",
            "class NullObject(PdfObject):",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"null\")",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType) -> \"NullObject\":",
            "        nulltxt = stream.read(4)",
            "        if nulltxt != b\"null\":",
            "            raise PdfReadError(\"Could not read Null object\")",
            "        return NullObject()",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    def __repr__(self) -> str:",
            "        return \"NullObject\"",
            "",
            "    @staticmethod",
            "    def readFromStream(stream: StreamType) -> \"NullObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return NullObject.read_from_stream(stream)",
            "",
            "",
            "class BooleanObject(PdfObject):",
            "    def __init__(self, value: Any) -> None:",
            "        self.value = value",
            "",
            "    def __eq__(self, __o: object) -> bool:",
            "        if isinstance(__o, BooleanObject):",
            "            return self.value == __o.value",
            "        elif isinstance(__o, bool):",
            "            return self.value == __o",
            "        else:",
            "            return False",
            "",
            "    def __repr__(self) -> str:",
            "        return \"True\" if self.value else \"False\"",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        if self.value:",
            "            stream.write(b\"true\")",
            "        else:",
            "            stream.write(b\"false\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType) -> \"BooleanObject\":",
            "        word = stream.read(4)",
            "        if word == b\"true\":",
            "            return BooleanObject(True)",
            "        elif word == b\"fals\":",
            "            stream.read(1)",
            "            return BooleanObject(False)",
            "        else:",
            "            raise PdfReadError(\"Could not read Boolean object\")",
            "",
            "    @staticmethod",
            "    def readFromStream(stream: StreamType) -> \"BooleanObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return BooleanObject.read_from_stream(stream)",
            "",
            "",
            "class IndirectObject(PdfObject):",
            "    def __init__(self, idnum: int, generation: int, pdf: Any) -> None:  # PdfReader",
            "        self.idnum = idnum",
            "        self.generation = generation",
            "        self.pdf = pdf",
            "",
            "    def get_object(self) -> Optional[PdfObject]:",
            "        obj = self.pdf.get_object(self)",
            "        if obj is None:",
            "            return None",
            "        return obj.get_object()",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"IndirectObject({self.idnum!r}, {self.generation!r}, {id(self.pdf)})\"",
            "",
            "    def __eq__(self, other: Any) -> bool:",
            "        return (",
            "            other is not None",
            "            and isinstance(other, IndirectObject)",
            "            and self.idnum == other.idnum",
            "            and self.generation == other.generation",
            "            and self.pdf is other.pdf",
            "        )",
            "",
            "    def __ne__(self, other: Any) -> bool:",
            "        return not self.__eq__(other)",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b_(f\"{self.idnum} {self.generation} R\"))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType, pdf: Any) -> \"IndirectObject\":  # PdfReader",
            "        idnum = b\"\"",
            "        while True:",
            "            tok = stream.read(1)",
            "            if not tok:",
            "                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)",
            "            if tok.isspace():",
            "                break",
            "            idnum += tok",
            "        generation = b\"\"",
            "        while True:",
            "            tok = stream.read(1)",
            "            if not tok:",
            "                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)",
            "            if tok.isspace():",
            "                if not generation:",
            "                    continue",
            "                break",
            "            generation += tok",
            "        r = read_non_whitespace(stream)",
            "        if r != b\"R\":",
            "            raise PdfReadError(",
            "                f\"Error reading indirect object reference at byte {hex_str(stream.tell())}\"",
            "            )",
            "        return IndirectObject(int(idnum), int(generation), pdf)",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"IndirectObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return IndirectObject.read_from_stream(stream, pdf)",
            "",
            "",
            "class FloatObject(decimal.Decimal, PdfObject):",
            "    def __new__(",
            "        cls, value: Union[str, Any] = \"0\", context: Optional[Any] = None",
            "    ) -> \"FloatObject\":",
            "        try:",
            "            return decimal.Decimal.__new__(cls, str_(value), context)",
            "        except Exception:",
            "            # If this isn't a valid decimal (happens in malformed PDFs)",
            "            # fallback to 0",
            "            logger_warning(f\"FloatObject ({value}) invalid; use 0.0 instead\", __name__)",
            "            return decimal.Decimal.__new__(cls, \"0.0\")",
            "",
            "    def __repr__(self) -> str:",
            "        if self == self.to_integral():",
            "            return str(self.quantize(decimal.Decimal(1)))",
            "        else:",
            "            # Standard formatting adds useless extraneous zeros.",
            "            o = f\"{self:.5f}\"",
            "            # Remove the zeros.",
            "            while o and o[-1] == \"0\":",
            "                o = o[:-1]",
            "            return o",
            "",
            "    def as_numeric(self) -> float:",
            "        return float(repr(self).encode(\"utf8\"))",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(repr(self).encode(\"utf8\"))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "",
            "class NumberObject(int, PdfObject):",
            "    NumberPattern = re.compile(b\"[^+-.0-9]\")",
            "",
            "    def __new__(cls, value: Any) -> \"NumberObject\":",
            "        try:",
            "            return int.__new__(cls, int(value))",
            "        except ValueError:",
            "            logger_warning(f\"NumberObject({value}) invalid; use 0 instead\", __name__)",
            "            return int.__new__(cls, 0)",
            "",
            "    def as_numeric(self) -> int:",
            "        return int(repr(self).encode(\"utf8\"))",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(repr(self).encode(\"utf8\"))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType) -> Union[\"NumberObject\", FloatObject]:",
            "        num = read_until_regex(stream, NumberObject.NumberPattern)",
            "        if num.find(b\".\") != -1:",
            "            return FloatObject(num)",
            "        return NumberObject(num)",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType,",
            "    ) -> Union[\"NumberObject\", FloatObject]:  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return NumberObject.read_from_stream(stream)",
            "",
            "",
            "class ByteStringObject(bytes, PdfObject):",
            "    \"\"\"",
            "    Represents a string object where the text encoding could not be determined.",
            "    This occurs quite often, as the PDF spec doesn't provide an alternate way to",
            "    represent strings -- for example, the encryption data stored in files (like",
            "    /O) is clearly not text, but is still stored in a \"String\" object.",
            "    \"\"\"",
            "",
            "    @property",
            "    def original_bytes(self) -> bytes:",
            "        \"\"\"For compatibility with TextStringObject.original_bytes.\"\"\"",
            "        return self",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        bytearr = self",
            "        if encryption_key:",
            "            from .._security import RC4_encrypt",
            "",
            "            bytearr = RC4_encrypt(encryption_key, bytearr)  # type: ignore",
            "        stream.write(b\"<\")",
            "        stream.write(hexencode(bytearr))",
            "        stream.write(b\">\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "",
            "class TextStringObject(str, PdfObject):",
            "    \"\"\"",
            "    Represents a string object that has been decoded into a real unicode string.",
            "    If read from a PDF document, this string appeared to match the",
            "    PDFDocEncoding, or contained a UTF-16BE BOM mark to cause UTF-16 decoding to",
            "    occur.",
            "    \"\"\"",
            "",
            "    autodetect_pdfdocencoding = False",
            "    autodetect_utf16 = False",
            "",
            "    @property",
            "    def original_bytes(self) -> bytes:",
            "        \"\"\"",
            "        It is occasionally possible that a text string object gets created where",
            "        a byte string object was expected due to the autodetection mechanism --",
            "        if that occurs, this \"original_bytes\" property can be used to",
            "        back-calculate what the original encoded bytes were.",
            "        \"\"\"",
            "        return self.get_original_bytes()",
            "",
            "    def get_original_bytes(self) -> bytes:",
            "        # We're a text string object, but the library is trying to get our raw",
            "        # bytes.  This can happen if we auto-detected this string as text, but",
            "        # we were wrong.  It's pretty common.  Return the original bytes that",
            "        # would have been used to create this object, based upon the autodetect",
            "        # method.",
            "        if self.autodetect_utf16:",
            "            return codecs.BOM_UTF16_BE + self.encode(\"utf-16be\")",
            "        elif self.autodetect_pdfdocencoding:",
            "            return encode_pdfdocencoding(self)",
            "        else:",
            "            raise Exception(\"no information about original bytes\")",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        # Try to write the string out as a PDFDocEncoding encoded string.  It's",
            "        # nicer to look at in the PDF file.  Sadly, we take a performance hit",
            "        # here for trying...",
            "        try:",
            "            bytearr = encode_pdfdocencoding(self)",
            "        except UnicodeEncodeError:",
            "            bytearr = codecs.BOM_UTF16_BE + self.encode(\"utf-16be\")",
            "        if encryption_key:",
            "            from .._security import RC4_encrypt",
            "",
            "            bytearr = RC4_encrypt(encryption_key, bytearr)",
            "            obj = ByteStringObject(bytearr)",
            "            obj.write_to_stream(stream, None)",
            "        else:",
            "            stream.write(b\"(\")",
            "            for c in bytearr:",
            "                if not chr(c).isalnum() and c != b\" \":",
            "                    # This:",
            "                    #   stream.write(b_(rf\"\\{c:0>3o}\"))",
            "                    # gives",
            "                    #   https://github.com/davidhalter/parso/issues/207",
            "                    stream.write(b_(\"\\\\%03o\" % c))",
            "                else:",
            "                    stream.write(b_(chr(c)))",
            "            stream.write(b\")\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "",
            "class NameObject(str, PdfObject):",
            "    delimiter_pattern = re.compile(rb\"\\s+|[\\(\\)<>\\[\\]{}/%]\")",
            "    surfix = b\"/\"",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b_(self))",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def unnumber(sin: str) -> str:",
            "        i = sin.find(\"#\")",
            "        while i >= 0:",
            "            sin = sin[:i] + chr(int(sin[i + 1 : i + 3], 16)) + sin[i + 3 :]",
            "            i = sin.find(\"#\")",
            "        return sin",
            "",
            "    @staticmethod",
            "    def read_from_stream(stream: StreamType, pdf: Any) -> \"NameObject\":  # PdfReader",
            "        name = stream.read(1)",
            "        if name != NameObject.surfix:",
            "            raise PdfReadError(\"name read error\")",
            "        name += read_until_regex(stream, NameObject.delimiter_pattern, ignore_eof=True)",
            "        try:",
            "            try:",
            "                ret = name.decode(\"utf-8\")",
            "            except (UnicodeEncodeError, UnicodeDecodeError):",
            "                ret = name.decode(\"gbk\")",
            "            # Name objects should represent irregular characters",
            "            # with a '#' followed by the symbol's hex number",
            "            ret = NameObject.unnumber(ret)",
            "            return NameObject(ret)",
            "        except (UnicodeEncodeError, UnicodeDecodeError) as e:",
            "            if not pdf.strict:",
            "                logger_warning(\"Illegal character in Name Object\", __name__)",
            "                return NameObject(name)",
            "            else:",
            "                raise PdfReadError(\"Illegal character in Name Object\") from e",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"NameObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return NameObject.read_from_stream(stream, pdf)",
            "",
            "",
            "def encode_pdfdocencoding(unicode_string: str) -> bytes:",
            "    retval = b\"\"",
            "    for c in unicode_string:",
            "        try:",
            "            retval += b_(chr(_pdfdoc_encoding_rev[c]))",
            "        except KeyError:",
            "            raise UnicodeEncodeError(",
            "                \"pdfdocencoding\", c, -1, -1, \"does not exist in translation table\"",
            "            )",
            "    return retval"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "434": [
                "NameObject",
                "read_from_stream"
            ],
            "435": [
                "NameObject",
                "read_from_stream"
            ]
        },
        "addLocation": [
            "PyPDF2.generic._base.NameObject.read_from_stream",
            "PyPDF2.generic._base.NameObject.self",
            "litellm.utils.token_counter",
            "PyPDF2.generic._base.NameObject.readFromStream"
        ]
    },
    "PyPDF2/generic/_data_structures.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " from ._utils import read_hex_string_from_stream, read_string_from_stream"
            },
            "1": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "3": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-ObjectPrefix = b\"/<[tf(n%\""
            },
            "4": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " NumberSigns = b\"+-\""
            },
            "5": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " IndirectPattern = re.compile(rb\"[+-]?(\\d+)\\s+(\\d+)\\s+R[^a-zA-Z]\")"
            },
            "6": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "                 stream.read(1)"
            },
            "8": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "                 break"
            },
            "9": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "             stream.seek(-1, 1)"
            },
            "10": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            key = read_object(stream, pdf)"
            },
            "11": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tok = read_non_whitespace(stream)"
            },
            "12": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            stream.seek(-1, 1)"
            },
            "13": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            value = read_object(stream, pdf, forced_encoding)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+            try:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+                key = read_object(stream, pdf)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+                tok = read_non_whitespace(stream)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+                stream.seek(-1, 1)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+                value = read_object(stream, pdf, forced_encoding)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+            except Exception as exc:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+                if pdf is not None and pdf.strict:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+                    raise PdfReadError(exc.__repr__())"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+                logger_warning(exc.__repr__(), __name__)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+                retval = DictionaryObject()"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+                retval.update(data)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+                return retval  # return partial data"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "             if not data.get(key):"
            },
            "28": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "                 data[key] = value"
            },
            "29": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "             else:"
            },
            "30": {
                "beforePatchRowNumber": 812,
                "afterPatchRowNumber": 820,
                "PatchRowcode": " ) -> Union[PdfObject, int, str, ContentStream]:"
            },
            "31": {
                "beforePatchRowNumber": 813,
                "afterPatchRowNumber": 821,
                "PatchRowcode": "     tok = stream.read(1)"
            },
            "32": {
                "beforePatchRowNumber": 814,
                "afterPatchRowNumber": 822,
                "PatchRowcode": "     stream.seek(-1, 1)  # reset to start"
            },
            "33": {
                "beforePatchRowNumber": 815,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    idx = ObjectPrefix.find(tok)"
            },
            "34": {
                "beforePatchRowNumber": 816,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if idx == 0:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 823,
                "PatchRowcode": "+    if tok == b\"/\":"
            },
            "36": {
                "beforePatchRowNumber": 817,
                "afterPatchRowNumber": 824,
                "PatchRowcode": "         return NameObject.read_from_stream(stream, pdf)"
            },
            "37": {
                "beforePatchRowNumber": 818,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif idx == 1:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 825,
                "PatchRowcode": "+    elif tok == b\"<\":"
            },
            "39": {
                "beforePatchRowNumber": 819,
                "afterPatchRowNumber": 826,
                "PatchRowcode": "         # hexadecimal string OR dictionary"
            },
            "40": {
                "beforePatchRowNumber": 820,
                "afterPatchRowNumber": 827,
                "PatchRowcode": "         peek = stream.read(2)"
            },
            "41": {
                "beforePatchRowNumber": 821,
                "afterPatchRowNumber": 828,
                "PatchRowcode": "         stream.seek(-2, 1)  # reset to start"
            },
            "42": {
                "beforePatchRowNumber": 824,
                "afterPatchRowNumber": 831,
                "PatchRowcode": "             return DictionaryObject.read_from_stream(stream, pdf, forced_encoding)"
            },
            "43": {
                "beforePatchRowNumber": 825,
                "afterPatchRowNumber": 832,
                "PatchRowcode": "         else:"
            },
            "44": {
                "beforePatchRowNumber": 826,
                "afterPatchRowNumber": 833,
                "PatchRowcode": "             return read_hex_string_from_stream(stream, forced_encoding)"
            },
            "45": {
                "beforePatchRowNumber": 827,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif idx == 2:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 834,
                "PatchRowcode": "+    elif tok == b\"[\":"
            },
            "47": {
                "beforePatchRowNumber": 828,
                "afterPatchRowNumber": 835,
                "PatchRowcode": "         return ArrayObject.read_from_stream(stream, pdf, forced_encoding)"
            },
            "48": {
                "beforePatchRowNumber": 829,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif idx == 3 or idx == 4:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 836,
                "PatchRowcode": "+    elif tok == b\"t\" or tok == b\"f\":"
            },
            "50": {
                "beforePatchRowNumber": 830,
                "afterPatchRowNumber": 837,
                "PatchRowcode": "         return BooleanObject.read_from_stream(stream)"
            },
            "51": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif idx == 5:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 838,
                "PatchRowcode": "+    elif tok == b\"(\":"
            },
            "53": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": 839,
                "PatchRowcode": "         return read_string_from_stream(stream, forced_encoding)"
            },
            "54": {
                "beforePatchRowNumber": 833,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif idx == 6:"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 840,
                "PatchRowcode": "+    elif tok == b\"n\":"
            },
            "56": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": 841,
                "PatchRowcode": "         return NullObject.read_from_stream(stream)"
            },
            "57": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    elif idx == 7:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+    elif tok == b\"%\":"
            },
            "59": {
                "beforePatchRowNumber": 836,
                "afterPatchRowNumber": 843,
                "PatchRowcode": "         # comment"
            },
            "60": {
                "beforePatchRowNumber": 837,
                "afterPatchRowNumber": 844,
                "PatchRowcode": "         while tok not in (b\"\\r\", b\"\\n\"):"
            },
            "61": {
                "beforePatchRowNumber": 838,
                "afterPatchRowNumber": 845,
                "PatchRowcode": "             tok = stream.read(1)"
            },
            "62": {
                "beforePatchRowNumber": 843,
                "afterPatchRowNumber": 850,
                "PatchRowcode": "         tok = read_non_whitespace(stream)"
            },
            "63": {
                "beforePatchRowNumber": 844,
                "afterPatchRowNumber": 851,
                "PatchRowcode": "         stream.seek(-1, 1)"
            },
            "64": {
                "beforePatchRowNumber": 845,
                "afterPatchRowNumber": 852,
                "PatchRowcode": "         return read_object(stream, pdf, forced_encoding)"
            },
            "65": {
                "beforePatchRowNumber": 846,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 853,
                "PatchRowcode": "+    elif tok in b\"0123456789+-.\":"
            },
            "67": {
                "beforePatchRowNumber": 847,
                "afterPatchRowNumber": 854,
                "PatchRowcode": "         # number object OR indirect reference"
            },
            "68": {
                "beforePatchRowNumber": 848,
                "afterPatchRowNumber": 855,
                "PatchRowcode": "         peek = stream.read(20)"
            },
            "69": {
                "beforePatchRowNumber": 849,
                "afterPatchRowNumber": 856,
                "PatchRowcode": "         stream.seek(-len(peek), 1)  # reset to start"
            },
            "70": {
                "beforePatchRowNumber": 850,
                "afterPatchRowNumber": 857,
                "PatchRowcode": "         if IndirectPattern.match(peek) is not None:"
            },
            "71": {
                "beforePatchRowNumber": 851,
                "afterPatchRowNumber": 858,
                "PatchRowcode": "             return IndirectObject.read_from_stream(stream, pdf)"
            },
            "72": {
                "beforePatchRowNumber": 852,
                "afterPatchRowNumber": 859,
                "PatchRowcode": "         else:"
            },
            "73": {
                "beforePatchRowNumber": 853,
                "afterPatchRowNumber": 860,
                "PatchRowcode": "             return NumberObject.read_from_stream(stream)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 861,
                "PatchRowcode": "+    else:"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 862,
                "PatchRowcode": "+        raise PdfReadError("
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 863,
                "PatchRowcode": "+            f\"Invalid Elementary Object starting with {tok} @{stream.tell()}\"  # type: ignore"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 864,
                "PatchRowcode": "+        )"
            },
            "78": {
                "beforePatchRowNumber": 854,
                "afterPatchRowNumber": 865,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 855,
                "afterPatchRowNumber": 866,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 856,
                "afterPatchRowNumber": 867,
                "PatchRowcode": " class Field(TreeObject):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2006, Mathieu Fenniak",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without",
            "# modification, are permitted provided that the following conditions are",
            "# met:",
            "#",
            "# * Redistributions of source code must retain the above copyright notice,",
            "# this list of conditions and the following disclaimer.",
            "# * Redistributions in binary form must reproduce the above copyright notice,",
            "# this list of conditions and the following disclaimer in the documentation",
            "# and/or other materials provided with the distribution.",
            "# * The name of the author may not be used to endorse or promote products",
            "# derived from this software without specific prior written permission.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
            "# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
            "# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
            "# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
            "# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
            "# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
            "# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
            "# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
            "# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
            "# POSSIBILITY OF SUCH DAMAGE.",
            "",
            "",
            "__author__ = \"Mathieu Fenniak\"",
            "__author_email__ = \"biziqe@mathieu.fenniak.net\"",
            "",
            "import logging",
            "import re",
            "from io import BytesIO",
            "from typing import Any, Dict, Iterable, List, Optional, Tuple, Union, cast",
            "",
            "from .._utils import (",
            "    WHITESPACES,",
            "    StreamType,",
            "    b_,",
            "    deprecate_with_replacement,",
            "    hex_str,",
            "    logger_warning,",
            "    read_non_whitespace,",
            "    read_until_regex,",
            "    skip_over_comment,",
            ")",
            "from ..constants import (",
            "    CheckboxRadioButtonAttributes,",
            "    FieldDictionaryAttributes,",
            ")",
            "from ..constants import FilterTypes as FT",
            "from ..constants import OutlineFontFlag",
            "from ..constants import StreamAttributes as SA",
            "from ..constants import TypArguments as TA",
            "from ..constants import TypFitArguments as TF",
            "from ..errors import STREAM_TRUNCATED_PREMATURELY, PdfReadError, PdfStreamError",
            "from ._base import (",
            "    BooleanObject,",
            "    FloatObject,",
            "    IndirectObject,",
            "    NameObject,",
            "    NullObject,",
            "    NumberObject,",
            "    PdfObject,",
            ")",
            "from ._utils import read_hex_string_from_stream, read_string_from_stream",
            "",
            "logger = logging.getLogger(__name__)",
            "ObjectPrefix = b\"/<[tf(n%\"",
            "NumberSigns = b\"+-\"",
            "IndirectPattern = re.compile(rb\"[+-]?(\\d+)\\s+(\\d+)\\s+R[^a-zA-Z]\")",
            "",
            "",
            "class ArrayObject(list, PdfObject):",
            "    def items(self) -> Iterable[Any]:",
            "        \"\"\"",
            "        Emulate DictionaryObject.items for a list",
            "        (index, object)",
            "        \"\"\"",
            "        return enumerate(self)",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"[\")",
            "        for data in self:",
            "            stream.write(b\" \")",
            "            data.write_to_stream(stream, encryption_key)",
            "        stream.write(b\" ]\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(",
            "        stream: StreamType,",
            "        pdf: Any,",
            "        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            "    ) -> \"ArrayObject\":  # PdfReader",
            "        arr = ArrayObject()",
            "        tmp = stream.read(1)",
            "        if tmp != b\"[\":",
            "            raise PdfReadError(\"Could not read array\")",
            "        while True:",
            "            # skip leading whitespace",
            "            tok = stream.read(1)",
            "            while tok.isspace():",
            "                tok = stream.read(1)",
            "            stream.seek(-1, 1)",
            "            # check for array ending",
            "            peekahead = stream.read(1)",
            "            if peekahead == b\"]\":",
            "                break",
            "            stream.seek(-1, 1)",
            "            # read and append obj",
            "            arr.append(read_object(stream, pdf, forced_encoding))",
            "        return arr",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"ArrayObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return ArrayObject.read_from_stream(stream, pdf)",
            "",
            "",
            "class DictionaryObject(dict, PdfObject):",
            "    def raw_get(self, key: Any) -> Any:",
            "        return dict.__getitem__(self, key)",
            "",
            "    def __setitem__(self, key: Any, value: Any) -> Any:",
            "        if not isinstance(key, PdfObject):",
            "            raise ValueError(\"key must be PdfObject\")",
            "        if not isinstance(value, PdfObject):",
            "            raise ValueError(\"value must be PdfObject\")",
            "        return dict.__setitem__(self, key, value)",
            "",
            "    def setdefault(self, key: Any, value: Optional[Any] = None) -> Any:",
            "        if not isinstance(key, PdfObject):",
            "            raise ValueError(\"key must be PdfObject\")",
            "        if not isinstance(value, PdfObject):",
            "            raise ValueError(\"value must be PdfObject\")",
            "        return dict.setdefault(self, key, value)  # type: ignore",
            "",
            "    def __getitem__(self, key: Any) -> PdfObject:",
            "        return dict.__getitem__(self, key).get_object()",
            "",
            "    @property",
            "    def xmp_metadata(self) -> Optional[PdfObject]:",
            "        \"\"\"",
            "        Retrieve XMP (Extensible Metadata Platform) data relevant to the",
            "        this object, if available.",
            "",
            "        Stability: Added in v1.12, will exist for all future v1.x releases.",
            "        @return Returns a {@link #xmp.XmpInformation XmlInformation} instance",
            "        that can be used to access XMP metadata from the document.  Can also",
            "        return None if no metadata was found on the document root.",
            "        \"\"\"",
            "        from ..xmp import XmpInformation",
            "",
            "        metadata = self.get(\"/Metadata\", None)",
            "        if metadata is None:",
            "            return None",
            "        metadata = metadata.get_object()",
            "",
            "        if not isinstance(metadata, XmpInformation):",
            "            metadata = XmpInformation(metadata)",
            "            self[NameObject(\"/Metadata\")] = metadata",
            "        return metadata",
            "",
            "    def getXmpMetadata(",
            "        self,",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :meth:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getXmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    @property",
            "    def xmpMetadata(self) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :meth:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"xmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"<<\\n\")",
            "        for key, value in list(self.items()):",
            "            key.write_to_stream(stream, encryption_key)",
            "            stream.write(b\" \")",
            "            value.write_to_stream(stream, encryption_key)",
            "            stream.write(b\"\\n\")",
            "        stream.write(b\">>\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(",
            "        stream: StreamType,",
            "        pdf: Any,  # PdfReader",
            "        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            "    ) -> \"DictionaryObject\":",
            "        def get_next_obj_pos(",
            "            p: int, p1: int, rem_gens: List[int], pdf: Any",
            "        ) -> int:  # PdfReader",
            "            l = pdf.xref[rem_gens[0]]",
            "            for o in l:",
            "                if p1 > l[o] and p < l[o]:",
            "                    p1 = l[o]",
            "            if len(rem_gens) == 1:",
            "                return p1",
            "            else:",
            "                return get_next_obj_pos(p, p1, rem_gens[1:], pdf)",
            "",
            "        def read_unsized_from_steam(stream: StreamType, pdf: Any) -> bytes:  # PdfReader",
            "            # we are just pointing at beginning of the stream",
            "            eon = get_next_obj_pos(stream.tell(), 2**32, list(pdf.xref), pdf) - 1",
            "            curr = stream.tell()",
            "            rw = stream.read(eon - stream.tell())",
            "            p = rw.find(b\"endstream\")",
            "            if p < 0:",
            "                raise PdfReadError(",
            "                    f\"Unable to find 'endstream' marker for obj starting at {curr}.\"",
            "                )",
            "            stream.seek(curr + p + 9)",
            "            return rw[: p - 1]",
            "",
            "        tmp = stream.read(2)",
            "        if tmp != b\"<<\":",
            "            raise PdfReadError(",
            "                f\"Dictionary read error at byte {hex_str(stream.tell())}: \"",
            "                \"stream must begin with '<<'\"",
            "            )",
            "        data: Dict[Any, Any] = {}",
            "        while True:",
            "            tok = read_non_whitespace(stream)",
            "            if tok == b\"\\x00\":",
            "                continue",
            "            elif tok == b\"%\":",
            "                stream.seek(-1, 1)",
            "                skip_over_comment(stream)",
            "                continue",
            "            if not tok:",
            "                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)",
            "",
            "            if tok == b\">\":",
            "                stream.read(1)",
            "                break",
            "            stream.seek(-1, 1)",
            "            key = read_object(stream, pdf)",
            "            tok = read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            value = read_object(stream, pdf, forced_encoding)",
            "            if not data.get(key):",
            "                data[key] = value",
            "            else:",
            "                # multiple definitions of key not permitted",
            "                msg = (",
            "                    f\"Multiple definitions in dictionary at byte \"",
            "                    f\"{hex_str(stream.tell())} for key {key}\"",
            "                )",
            "                if pdf is not None and pdf.strict:",
            "                    raise PdfReadError(msg)",
            "                logger_warning(msg, __name__)",
            "",
            "        pos = stream.tell()",
            "        s = read_non_whitespace(stream)",
            "        if s == b\"s\" and stream.read(5) == b\"tream\":",
            "            eol = stream.read(1)",
            "            # odd PDF file output has spaces after 'stream' keyword but before EOL.",
            "            # patch provided by Danial Sandler",
            "            while eol == b\" \":",
            "                eol = stream.read(1)",
            "            if eol not in (b\"\\n\", b\"\\r\"):",
            "                raise PdfStreamError(\"Stream data must be followed by a newline\")",
            "            if eol == b\"\\r\":",
            "                # read \\n after",
            "                if stream.read(1) != b\"\\n\":",
            "                    stream.seek(-1, 1)",
            "            # this is a stream object, not a dictionary",
            "            if SA.LENGTH not in data:",
            "                raise PdfStreamError(\"Stream length not defined\")",
            "            length = data[SA.LENGTH]",
            "            if isinstance(length, IndirectObject):",
            "                t = stream.tell()",
            "                length = pdf.get_object(length)",
            "                stream.seek(t, 0)",
            "            pstart = stream.tell()",
            "            data[\"__streamdata__\"] = stream.read(length)",
            "            e = read_non_whitespace(stream)",
            "            ndstream = stream.read(8)",
            "            if (e + ndstream) != b\"endstream\":",
            "                # (sigh) - the odd PDF file has a length that is too long, so",
            "                # we need to read backwards to find the \"endstream\" ending.",
            "                # ReportLab (unknown version) generates files with this bug,",
            "                # and Python users into PDF files tend to be our audience.",
            "                # we need to do this to correct the streamdata and chop off",
            "                # an extra character.",
            "                pos = stream.tell()",
            "                stream.seek(-10, 1)",
            "                end = stream.read(9)",
            "                if end == b\"endstream\":",
            "                    # we found it by looking back one character further.",
            "                    data[\"__streamdata__\"] = data[\"__streamdata__\"][:-1]",
            "                elif not pdf.strict:",
            "                    stream.seek(pstart, 0)",
            "                    data[\"__streamdata__\"] = read_unsized_from_steam(stream, pdf)",
            "                    pos = stream.tell()",
            "                else:",
            "                    stream.seek(pos, 0)",
            "                    raise PdfReadError(",
            "                        \"Unable to find 'endstream' marker after stream at byte \"",
            "                        f\"{hex_str(stream.tell())} (nd='{ndstream!r}', end='{end!r}').\"",
            "                    )",
            "        else:",
            "            stream.seek(pos, 0)",
            "        if \"__streamdata__\" in data:",
            "            return StreamObject.initialize_from_dictionary(data)",
            "        else:",
            "            retval = DictionaryObject()",
            "            retval.update(data)",
            "            return retval",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"DictionaryObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return DictionaryObject.read_from_stream(stream, pdf)",
            "",
            "",
            "class TreeObject(DictionaryObject):",
            "    def __init__(self) -> None:",
            "        DictionaryObject.__init__(self)",
            "",
            "    def hasChildren(self) -> bool:  # pragma: no cover",
            "        deprecate_with_replacement(\"hasChildren\", \"has_children\", \"4.0.0\")",
            "        return self.has_children()",
            "",
            "    def has_children(self) -> bool:",
            "        return \"/First\" in self",
            "",
            "    def __iter__(self) -> Any:",
            "        return self.children()",
            "",
            "    def children(self) -> Iterable[Any]:",
            "        if not self.has_children():",
            "            return",
            "",
            "        child_ref = self[NameObject(\"/First\")]",
            "        child = child_ref.get_object()",
            "        while True:",
            "            yield child",
            "            if child == self[NameObject(\"/Last\")]:",
            "                return",
            "            child_ref = child.get(NameObject(\"/Next\"))  # type: ignore",
            "            if child_ref is None:",
            "                return",
            "            child = child_ref.get_object()",
            "",
            "    def addChild(self, child: Any, pdf: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"addChild\", \"add_child\")",
            "        self.add_child(child, pdf)",
            "",
            "    def add_child(self, child: Any, pdf: Any) -> None:  # PdfWriter",
            "        child_obj = child.get_object()",
            "        child = pdf.get_reference(child_obj)",
            "        assert isinstance(child, IndirectObject)",
            "",
            "        prev: Optional[DictionaryObject]",
            "        if \"/First\" not in self:",
            "            self[NameObject(\"/First\")] = child",
            "            self[NameObject(\"/Count\")] = NumberObject(0)",
            "            prev = None",
            "        else:",
            "            prev = cast(",
            "                DictionaryObject, self[\"/Last\"]",
            "            )  # TABLE 8.3 Entries in the outline dictionary",
            "",
            "        self[NameObject(\"/Last\")] = child",
            "        self[NameObject(\"/Count\")] = NumberObject(self[NameObject(\"/Count\")] + 1)  # type: ignore",
            "",
            "        if prev:",
            "            prev_ref = pdf.get_reference(prev)",
            "            assert isinstance(prev_ref, IndirectObject)",
            "            child_obj[NameObject(\"/Prev\")] = prev_ref",
            "            prev[NameObject(\"/Next\")] = child",
            "",
            "        parent_ref = pdf.get_reference(self)",
            "        assert isinstance(parent_ref, IndirectObject)",
            "        child_obj[NameObject(\"/Parent\")] = parent_ref",
            "",
            "    def removeChild(self, child: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"removeChild\", \"remove_child\")",
            "        self.remove_child(child)",
            "",
            "    def _remove_node_from_tree(",
            "        self, prev: Any, prev_ref: Any, cur: Any, last: Any",
            "    ) -> None:",
            "        \"\"\"Adjust the pointers of the linked list and tree node count.\"\"\"",
            "        next_ref = cur.get(NameObject(\"/Next\"), None)",
            "        if prev is None:",
            "            if next_ref:",
            "                # Removing first tree node",
            "                next_obj = next_ref.get_object()",
            "                del next_obj[NameObject(\"/Prev\")]",
            "                self[NameObject(\"/First\")] = next_ref",
            "                self[NameObject(\"/Count\")] = NumberObject(",
            "                    self[NameObject(\"/Count\")] - 1  # type: ignore",
            "                )",
            "",
            "            else:",
            "                # Removing only tree node",
            "                assert self[NameObject(\"/Count\")] == 1",
            "                del self[NameObject(\"/Count\")]",
            "                del self[NameObject(\"/First\")]",
            "                if NameObject(\"/Last\") in self:",
            "                    del self[NameObject(\"/Last\")]",
            "        else:",
            "            if next_ref:",
            "                # Removing middle tree node",
            "                next_obj = next_ref.get_object()",
            "                next_obj[NameObject(\"/Prev\")] = prev_ref",
            "                prev[NameObject(\"/Next\")] = next_ref",
            "            else:",
            "                # Removing last tree node",
            "                assert cur == last",
            "                del prev[NameObject(\"/Next\")]",
            "                self[NameObject(\"/Last\")] = prev_ref",
            "            self[NameObject(\"/Count\")] = NumberObject(self[NameObject(\"/Count\")] - 1)  # type: ignore",
            "",
            "    def remove_child(self, child: Any) -> None:",
            "        child_obj = child.get_object()",
            "",
            "        if NameObject(\"/Parent\") not in child_obj:",
            "            raise ValueError(\"Removed child does not appear to be a tree item\")",
            "        elif child_obj[NameObject(\"/Parent\")] != self:",
            "            raise ValueError(\"Removed child is not a member of this tree\")",
            "",
            "        found = False",
            "        prev_ref = None",
            "        prev = None",
            "        cur_ref: Optional[Any] = self[NameObject(\"/First\")]",
            "        cur: Optional[Dict[str, Any]] = cur_ref.get_object()  # type: ignore",
            "        last_ref = self[NameObject(\"/Last\")]",
            "        last = last_ref.get_object()",
            "        while cur is not None:",
            "            if cur == child_obj:",
            "                self._remove_node_from_tree(prev, prev_ref, cur, last)",
            "                found = True",
            "                break",
            "",
            "            # Go to the next node",
            "            prev_ref = cur_ref",
            "            prev = cur",
            "            if NameObject(\"/Next\") in cur:",
            "                cur_ref = cur[NameObject(\"/Next\")]",
            "                cur = cur_ref.get_object()",
            "            else:",
            "                cur_ref = None",
            "                cur = None",
            "",
            "        if not found:",
            "            raise ValueError(\"Removal couldn't find item in tree\")",
            "",
            "        _reset_node_tree_relationship(child_obj)",
            "",
            "    def emptyTree(self) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"emptyTree\", \"empty_tree\", \"4.0.0\")",
            "        self.empty_tree()",
            "",
            "    def empty_tree(self) -> None:",
            "        for child in self:",
            "            child_obj = child.get_object()",
            "            _reset_node_tree_relationship(child_obj)",
            "",
            "        if NameObject(\"/Count\") in self:",
            "            del self[NameObject(\"/Count\")]",
            "        if NameObject(\"/First\") in self:",
            "            del self[NameObject(\"/First\")]",
            "        if NameObject(\"/Last\") in self:",
            "            del self[NameObject(\"/Last\")]",
            "",
            "",
            "def _reset_node_tree_relationship(child_obj: Any) -> None:",
            "    \"\"\"",
            "    Call this after a node has been removed from a tree.",
            "",
            "    This resets the nodes attributes in respect to that tree.",
            "    \"\"\"",
            "    del child_obj[NameObject(\"/Parent\")]",
            "    if NameObject(\"/Next\") in child_obj:",
            "        del child_obj[NameObject(\"/Next\")]",
            "    if NameObject(\"/Prev\") in child_obj:",
            "        del child_obj[NameObject(\"/Prev\")]",
            "",
            "",
            "class StreamObject(DictionaryObject):",
            "    def __init__(self) -> None:",
            "        self.__data: Optional[str] = None",
            "        self.decoded_self: Optional[DecodedStreamObject] = None",
            "",
            "    def hash_value_data(self) -> bytes:",
            "        data = super().hash_value_data()",
            "        data += b_(self._data)",
            "        return data",
            "",
            "    @property",
            "    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        return self.decoded_self",
            "",
            "    @decodedSelf.setter",
            "    def decodedSelf(self, value: \"DecodedStreamObject\") -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        self.decoded_self = value",
            "",
            "    @property",
            "    def _data(self) -> Any:",
            "        return self.__data",
            "",
            "    @_data.setter",
            "    def _data(self, value: Any) -> None:",
            "        self.__data = value",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        self[NameObject(SA.LENGTH)] = NumberObject(len(self._data))",
            "        DictionaryObject.write_to_stream(self, stream, encryption_key)",
            "        del self[SA.LENGTH]",
            "        stream.write(b\"\\nstream\\n\")",
            "        data = self._data",
            "        if encryption_key:",
            "            from .._security import RC4_encrypt",
            "",
            "            data = RC4_encrypt(encryption_key, data)",
            "        stream.write(data)",
            "        stream.write(b\"\\nendstream\")",
            "",
            "    @staticmethod",
            "    def initializeFromDictionary(",
            "        data: Dict[str, Any]",
            "    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:  # pragma: no cover",
            "        return StreamObject.initialize_from_dictionary(data)",
            "",
            "    @staticmethod",
            "    def initialize_from_dictionary(",
            "        data: Dict[str, Any]",
            "    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:",
            "        retval: Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]",
            "        if SA.FILTER in data:",
            "            retval = EncodedStreamObject()",
            "        else:",
            "            retval = DecodedStreamObject()",
            "        retval._data = data[\"__streamdata__\"]",
            "        del data[\"__streamdata__\"]",
            "        del data[SA.LENGTH]",
            "        retval.update(data)",
            "        return retval",
            "",
            "    def flateEncode(self) -> \"EncodedStreamObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"flateEncode\", \"flate_encode\")",
            "        return self.flate_encode()",
            "",
            "    def flate_encode(self) -> \"EncodedStreamObject\":",
            "        from ..filters import FlateDecode",
            "",
            "        if SA.FILTER in self:",
            "            f = self[SA.FILTER]",
            "            if isinstance(f, ArrayObject):",
            "                f.insert(0, NameObject(FT.FLATE_DECODE))",
            "            else:",
            "                newf = ArrayObject()",
            "                newf.append(NameObject(\"/FlateDecode\"))",
            "                newf.append(f)",
            "                f = newf",
            "        else:",
            "            f = NameObject(\"/FlateDecode\")",
            "        retval = EncodedStreamObject()",
            "        retval[NameObject(SA.FILTER)] = f",
            "        retval._data = FlateDecode.encode(self._data)",
            "        return retval",
            "",
            "",
            "class DecodedStreamObject(StreamObject):",
            "    def get_data(self) -> Any:",
            "        return self._data",
            "",
            "    def set_data(self, data: Any) -> Any:",
            "        self._data = data",
            "",
            "    def getData(self) -> Any:  # pragma: no cover",
            "        deprecate_with_replacement(\"getData\", \"get_data\")",
            "        return self._data",
            "",
            "    def setData(self, data: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"setData\", \"set_data\")",
            "        self.set_data(data)",
            "",
            "",
            "class EncodedStreamObject(StreamObject):",
            "    def __init__(self) -> None:",
            "        self.decoded_self: Optional[DecodedStreamObject] = None",
            "",
            "    @property",
            "    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        return self.decoded_self",
            "",
            "    @decodedSelf.setter",
            "    def decodedSelf(self, value: DecodedStreamObject) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        self.decoded_self = value",
            "",
            "    def get_data(self) -> Union[None, str, bytes]:",
            "        from ..filters import decode_stream_data",
            "",
            "        if self.decoded_self is not None:",
            "            # cached version of decoded object",
            "            return self.decoded_self.get_data()",
            "        else:",
            "            # create decoded object",
            "            decoded = DecodedStreamObject()",
            "",
            "            decoded._data = decode_stream_data(self)",
            "            for key, value in list(self.items()):",
            "                if key not in (SA.LENGTH, SA.FILTER, SA.DECODE_PARMS):",
            "                    decoded[key] = value",
            "            self.decoded_self = decoded",
            "            return decoded._data",
            "",
            "    def getData(self) -> Union[None, str, bytes]:  # pragma: no cover",
            "        deprecate_with_replacement(\"getData\", \"get_data\")",
            "        return self.get_data()",
            "",
            "    def set_data(self, data: Any) -> None:  # pragma: no cover",
            "        raise PdfReadError(\"Creating EncodedStreamObject is not currently supported\")",
            "",
            "    def setData(self, data: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"setData\", \"set_data\")",
            "        return self.set_data(data)",
            "",
            "",
            "class ContentStream(DecodedStreamObject):",
            "    def __init__(",
            "        self,",
            "        stream: Any,",
            "        pdf: Any,",
            "        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            "    ) -> None:",
            "        self.pdf = pdf",
            "",
            "        # The inner list has two elements:",
            "        #  [0] : List",
            "        #  [1] : str",
            "        self.operations: List[Tuple[Any, Any]] = []",
            "",
            "        # stream may be a StreamObject or an ArrayObject containing",
            "        # multiple StreamObjects to be cat'd together.",
            "        stream = stream.get_object()",
            "        if isinstance(stream, ArrayObject):",
            "            data = b\"\"",
            "            for s in stream:",
            "                data += b_(s.get_object().get_data())",
            "                if data[-1] != b\"\\n\":",
            "                    data += b\"\\n\"",
            "            stream_bytes = BytesIO(data)",
            "        else:",
            "            stream_data = stream.get_data()",
            "            assert stream_data is not None",
            "            stream_data_bytes = b_(stream_data)",
            "            stream_bytes = BytesIO(stream_data_bytes)",
            "        self.forced_encoding = forced_encoding",
            "        self.__parse_content_stream(stream_bytes)",
            "",
            "    def __parse_content_stream(self, stream: StreamType) -> None:",
            "        stream.seek(0, 0)",
            "        operands: List[Union[int, str, PdfObject]] = []",
            "        while True:",
            "            peek = read_non_whitespace(stream)",
            "            if peek == b\"\" or peek == 0:",
            "                break",
            "            stream.seek(-1, 1)",
            "            if peek.isalpha() or peek in (b\"'\", b'\"'):",
            "                operator = read_until_regex(stream, NameObject.delimiter_pattern, True)",
            "                if operator == b\"BI\":",
            "                    # begin inline image - a completely different parsing",
            "                    # mechanism is required, of course... thanks buddy...",
            "                    assert operands == []",
            "                    ii = self._read_inline_image(stream)",
            "                    self.operations.append((ii, b\"INLINE IMAGE\"))",
            "                else:",
            "                    self.operations.append((operands, operator))",
            "                    operands = []",
            "            elif peek == b\"%\":",
            "                # If we encounter a comment in the content stream, we have to",
            "                # handle it here.  Typically, read_object will handle",
            "                # encountering a comment -- but read_object assumes that",
            "                # following the comment must be the object we're trying to",
            "                # read.  In this case, it could be an operator instead.",
            "                while peek not in (b\"\\r\", b\"\\n\"):",
            "                    peek = stream.read(1)",
            "            else:",
            "                operands.append(read_object(stream, None, self.forced_encoding))",
            "",
            "    def _read_inline_image(self, stream: StreamType) -> Dict[str, Any]:",
            "        # begin reading just after the \"BI\" - begin image",
            "        # first read the dictionary of settings.",
            "        settings = DictionaryObject()",
            "        while True:",
            "            tok = read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            if tok == b\"I\":",
            "                # \"ID\" - begin of image data",
            "                break",
            "            key = read_object(stream, self.pdf)",
            "            tok = read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            value = read_object(stream, self.pdf)",
            "            settings[key] = value",
            "        # left at beginning of ID",
            "        tmp = stream.read(3)",
            "        assert tmp[:2] == b\"ID\"",
            "        data = BytesIO()",
            "        # Read the inline image, while checking for EI (End Image) operator.",
            "        while True:",
            "            # Read 8 kB at a time and check if the chunk contains the E operator.",
            "            buf = stream.read(8192)",
            "            # We have reached the end of the stream, but haven't found the EI operator.",
            "            if not buf:",
            "                raise PdfReadError(\"Unexpected end of stream\")",
            "            loc = buf.find(b\"E\")",
            "",
            "            if loc == -1:",
            "                data.write(buf)",
            "            else:",
            "                # Write out everything before the E.",
            "                data.write(buf[0:loc])",
            "",
            "                # Seek back in the stream to read the E next.",
            "                stream.seek(loc - len(buf), 1)",
            "                tok = stream.read(1)",
            "                # Check for End Image",
            "                tok2 = stream.read(1)",
            "                if tok2 == b\"I\" and buf[loc - 1 : loc] in WHITESPACES:",
            "                    # Data can contain [\\s]EI,  so check for the separator \\s; 4 chars suffisent Q operator not required.",
            "                    tok3 = stream.read(1)",
            "                    info = tok + tok2",
            "                    # We need to find at least one whitespace after.",
            "                    has_q_whitespace = False",
            "                    while tok3 in WHITESPACES:",
            "                        has_q_whitespace = True",
            "                        info += tok3",
            "                        tok3 = stream.read(1)",
            "                    if has_q_whitespace:",
            "                        stream.seek(-1, 1)",
            "                        break",
            "                    else:",
            "                        stream.seek(-1, 1)",
            "                        data.write(info)",
            "                else:",
            "                    stream.seek(-1, 1)",
            "                    data.write(tok)",
            "        return {\"settings\": settings, \"data\": data.getvalue()}",
            "",
            "    @property",
            "    def _data(self) -> bytes:",
            "        newdata = BytesIO()",
            "        for operands, operator in self.operations:",
            "            if operator == b\"INLINE IMAGE\":",
            "                newdata.write(b\"BI\")",
            "                dicttext = BytesIO()",
            "                operands[\"settings\"].write_to_stream(dicttext, None)",
            "                newdata.write(dicttext.getvalue()[2:-2])",
            "                newdata.write(b\"ID \")",
            "                newdata.write(operands[\"data\"])",
            "                newdata.write(b\"EI\")",
            "            else:",
            "                for op in operands:",
            "                    op.write_to_stream(newdata, None)",
            "                    newdata.write(b\" \")",
            "                newdata.write(b_(operator))",
            "            newdata.write(b\"\\n\")",
            "        return newdata.getvalue()",
            "",
            "    @_data.setter",
            "    def _data(self, value: Union[str, bytes]) -> None:",
            "        self.__parse_content_stream(BytesIO(b_(value)))",
            "",
            "",
            "def read_object(",
            "    stream: StreamType,",
            "    pdf: Any,  # PdfReader",
            "    forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            ") -> Union[PdfObject, int, str, ContentStream]:",
            "    tok = stream.read(1)",
            "    stream.seek(-1, 1)  # reset to start",
            "    idx = ObjectPrefix.find(tok)",
            "    if idx == 0:",
            "        return NameObject.read_from_stream(stream, pdf)",
            "    elif idx == 1:",
            "        # hexadecimal string OR dictionary",
            "        peek = stream.read(2)",
            "        stream.seek(-2, 1)  # reset to start",
            "",
            "        if peek == b\"<<\":",
            "            return DictionaryObject.read_from_stream(stream, pdf, forced_encoding)",
            "        else:",
            "            return read_hex_string_from_stream(stream, forced_encoding)",
            "    elif idx == 2:",
            "        return ArrayObject.read_from_stream(stream, pdf, forced_encoding)",
            "    elif idx == 3 or idx == 4:",
            "        return BooleanObject.read_from_stream(stream)",
            "    elif idx == 5:",
            "        return read_string_from_stream(stream, forced_encoding)",
            "    elif idx == 6:",
            "        return NullObject.read_from_stream(stream)",
            "    elif idx == 7:",
            "        # comment",
            "        while tok not in (b\"\\r\", b\"\\n\"):",
            "            tok = stream.read(1)",
            "            # Prevents an infinite loop by raising an error if the stream is at",
            "            # the EOF",
            "            if len(tok) <= 0:",
            "                raise PdfStreamError(\"File ended unexpectedly.\")",
            "        tok = read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        return read_object(stream, pdf, forced_encoding)",
            "    else:",
            "        # number object OR indirect reference",
            "        peek = stream.read(20)",
            "        stream.seek(-len(peek), 1)  # reset to start",
            "        if IndirectPattern.match(peek) is not None:",
            "            return IndirectObject.read_from_stream(stream, pdf)",
            "        else:",
            "            return NumberObject.read_from_stream(stream)",
            "",
            "",
            "class Field(TreeObject):",
            "    \"\"\"",
            "    A class representing a field dictionary.",
            "",
            "    This class is accessed through",
            "    :meth:`get_fields()<PyPDF2.PdfReader.get_fields>`",
            "    \"\"\"",
            "",
            "    def __init__(self, data: Dict[str, Any]) -> None:",
            "        DictionaryObject.__init__(self)",
            "        field_attributes = (",
            "            FieldDictionaryAttributes.attributes()",
            "            + CheckboxRadioButtonAttributes.attributes()",
            "        )",
            "        for attr in field_attributes:",
            "            try:",
            "                self[NameObject(attr)] = data[attr]",
            "            except KeyError:",
            "                pass",
            "",
            "    # TABLE 8.69 Entries common to all field dictionaries",
            "    @property",
            "    def field_type(self) -> Optional[NameObject]:",
            "        \"\"\"Read-only property accessing the type of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.FT)",
            "",
            "    @property",
            "    def fieldType(self) -> Optional[NameObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`field_type` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"fieldType\", \"field_type\")",
            "        return self.field_type",
            "",
            "    @property",
            "    def parent(self) -> Optional[DictionaryObject]:",
            "        \"\"\"Read-only property accessing the parent of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.Parent)",
            "",
            "    @property",
            "    def kids(self) -> Optional[ArrayObject]:",
            "        \"\"\"Read-only property accessing the kids of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.Kids)",
            "",
            "    @property",
            "    def name(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the name of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.T)",
            "",
            "    @property",
            "    def alternate_name(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the alternate name of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.TU)",
            "",
            "    @property",
            "    def altName(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`alternate_name` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"altName\", \"alternate_name\")",
            "        return self.alternate_name",
            "",
            "    @property",
            "    def mapping_name(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the mapping name of this field. This",
            "        name is used by PyPDF2 as a key in the dictionary returned by",
            "        :meth:`get_fields()<PyPDF2.PdfReader.get_fields>`",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.TM)",
            "",
            "    @property",
            "    def mappingName(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`mapping_name` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"mappingName\", \"mapping_name\")",
            "        return self.mapping_name",
            "",
            "    @property",
            "    def flags(self) -> Optional[int]:",
            "        \"\"\"",
            "        Read-only property accessing the field flags, specifying various",
            "        characteristics of the field (see Table 8.70 of the PDF 1.7 reference).",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.Ff)",
            "",
            "    @property",
            "    def value(self) -> Optional[Any]:",
            "        \"\"\"",
            "        Read-only property accessing the value of this field. Format",
            "        varies based on field type.",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.V)",
            "",
            "    @property",
            "    def default_value(self) -> Optional[Any]:",
            "        \"\"\"Read-only property accessing the default value of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.DV)",
            "",
            "    @property",
            "    def defaultValue(self) -> Optional[Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`default_value` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"defaultValue\", \"default_value\")",
            "        return self.default_value",
            "",
            "    @property",
            "    def additional_actions(self) -> Optional[DictionaryObject]:",
            "        \"\"\"",
            "        Read-only property accessing the additional actions dictionary.",
            "        This dictionary defines the field's behavior in response to trigger events.",
            "        See Section 8.5.2 of the PDF 1.7 reference.",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.AA)",
            "",
            "    @property",
            "    def additionalActions(self) -> Optional[DictionaryObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`additional_actions` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"additionalActions\", \"additional_actions\")",
            "        return self.additional_actions",
            "",
            "",
            "class Destination(TreeObject):",
            "    \"\"\"",
            "    A class representing a destination within a PDF file.",
            "    See section 8.2.1 of the PDF 1.6 reference.",
            "",
            "    :param str title: Title of this destination.",
            "    :param IndirectObject page: Reference to the page of this destination. Should",
            "        be an instance of :class:`IndirectObject<PyPDF2.generic.IndirectObject>`.",
            "    :param str typ: How the destination is displayed.",
            "    :param args: Additional arguments may be necessary depending on the type.",
            "    :raises PdfReadError: If destination type is invalid.",
            "",
            "    .. list-table:: Valid ``typ`` arguments (see PDF spec for details)",
            "       :widths: 50 50",
            "",
            "       * - /Fit",
            "         - No additional arguments",
            "       * - /XYZ",
            "         - [left] [top] [zoomFactor]",
            "       * - /FitH",
            "         - [top]",
            "       * - /FitV",
            "         - [left]",
            "       * - /FitR",
            "         - [left] [bottom] [right] [top]",
            "       * - /FitB",
            "         - No additional arguments",
            "       * - /FitBH",
            "         - [top]",
            "       * - /FitBV",
            "         - [left]",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        title: str,",
            "        page: Union[NumberObject, IndirectObject, NullObject, DictionaryObject],",
            "        typ: Union[str, NumberObject],",
            "        *args: Any,  # ZoomArgType",
            "    ) -> None:",
            "        DictionaryObject.__init__(self)",
            "        self[NameObject(\"/Title\")] = title",
            "        self[NameObject(\"/Page\")] = page",
            "        self[NameObject(\"/Type\")] = typ",
            "",
            "        # from table 8.2 of the PDF 1.7 reference.",
            "        if typ == \"/XYZ\":",
            "            (",
            "                self[NameObject(TA.LEFT)],",
            "                self[NameObject(TA.TOP)],",
            "                self[NameObject(\"/Zoom\")],",
            "            ) = args",
            "        elif typ == TF.FIT_R:",
            "            (",
            "                self[NameObject(TA.LEFT)],",
            "                self[NameObject(TA.BOTTOM)],",
            "                self[NameObject(TA.RIGHT)],",
            "                self[NameObject(TA.TOP)],",
            "            ) = args",
            "        elif typ in [TF.FIT_H, TF.FIT_BH]:",
            "            try:  # Prefered to be more robust not only to null parameters",
            "                (self[NameObject(TA.TOP)],) = args",
            "            except Exception:",
            "                (self[NameObject(TA.TOP)],) = (NullObject(),)",
            "        elif typ in [TF.FIT_V, TF.FIT_BV]:",
            "            try:  # Prefered to be more robust not only to null parameters",
            "                (self[NameObject(TA.LEFT)],) = args",
            "            except Exception:",
            "                (self[NameObject(TA.LEFT)],) = (NullObject(),)",
            "        elif typ in [TF.FIT, TF.FIT_B]:",
            "            pass",
            "        else:",
            "            raise PdfReadError(f\"Unknown Destination Type: {typ!r}\")",
            "",
            "    @property",
            "    def dest_array(self) -> ArrayObject:",
            "        return ArrayObject(",
            "            [self.raw_get(\"/Page\"), self[\"/Type\"]]",
            "            + [",
            "                self[x]",
            "                for x in [\"/Left\", \"/Bottom\", \"/Right\", \"/Top\", \"/Zoom\"]",
            "                if x in self",
            "            ]",
            "        )",
            "",
            "    def getDestArray(self) -> ArrayObject:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`dest_array` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getDestArray\", \"dest_array\")",
            "        return self.dest_array",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"<<\\n\")",
            "        key = NameObject(\"/D\")",
            "        key.write_to_stream(stream, encryption_key)",
            "        stream.write(b\" \")",
            "        value = self.dest_array",
            "        value.write_to_stream(stream, encryption_key)",
            "",
            "        key = NameObject(\"/S\")",
            "        key.write_to_stream(stream, encryption_key)",
            "        stream.write(b\" \")",
            "        value_s = NameObject(\"/GoTo\")",
            "        value_s.write_to_stream(stream, encryption_key)",
            "",
            "        stream.write(b\"\\n\")",
            "        stream.write(b\">>\")",
            "",
            "    @property",
            "    def title(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the destination title.\"\"\"",
            "        return self.get(\"/Title\")",
            "",
            "    @property",
            "    def page(self) -> Optional[int]:",
            "        \"\"\"Read-only property accessing the destination page number.\"\"\"",
            "        return self.get(\"/Page\")",
            "",
            "    @property",
            "    def typ(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the destination type.\"\"\"",
            "        return self.get(\"/Type\")",
            "",
            "    @property",
            "    def zoom(self) -> Optional[int]:",
            "        \"\"\"Read-only property accessing the zoom factor.\"\"\"",
            "        return self.get(\"/Zoom\", None)",
            "",
            "    @property",
            "    def left(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the left horizontal coordinate.\"\"\"",
            "        return self.get(\"/Left\", None)",
            "",
            "    @property",
            "    def right(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the right horizontal coordinate.\"\"\"",
            "        return self.get(\"/Right\", None)",
            "",
            "    @property",
            "    def top(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the top vertical coordinate.\"\"\"",
            "        return self.get(\"/Top\", None)",
            "",
            "    @property",
            "    def bottom(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the bottom vertical coordinate.\"\"\"",
            "        return self.get(\"/Bottom\", None)",
            "",
            "    @property",
            "    def color(self) -> Optional[ArrayObject]:",
            "        \"\"\"Read-only property accessing the color in (R, G, B) with values 0.0-1.0\"\"\"",
            "        return self.get(",
            "            \"/C\", ArrayObject([FloatObject(0), FloatObject(0), FloatObject(0)])",
            "        )",
            "",
            "    @property",
            "    def font_format(self) -> Optional[OutlineFontFlag]:",
            "        \"\"\"Read-only property accessing the font type. 1=italic, 2=bold, 3=both\"\"\"",
            "        return self.get(\"/F\", 0)",
            "",
            "    @property",
            "    def outline_count(self) -> Optional[int]:",
            "        \"\"\"",
            "        Read-only property accessing the outline count.",
            "        positive = expanded",
            "        negative = collapsed",
            "        absolute value = number of visible descendents at all levels",
            "        \"\"\"",
            "        return self.get(\"/Count\", None)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2006, Mathieu Fenniak",
            "# All rights reserved.",
            "#",
            "# Redistribution and use in source and binary forms, with or without",
            "# modification, are permitted provided that the following conditions are",
            "# met:",
            "#",
            "# * Redistributions of source code must retain the above copyright notice,",
            "# this list of conditions and the following disclaimer.",
            "# * Redistributions in binary form must reproduce the above copyright notice,",
            "# this list of conditions and the following disclaimer in the documentation",
            "# and/or other materials provided with the distribution.",
            "# * The name of the author may not be used to endorse or promote products",
            "# derived from this software without specific prior written permission.",
            "#",
            "# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
            "# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
            "# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
            "# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
            "# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
            "# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
            "# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
            "# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
            "# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
            "# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
            "# POSSIBILITY OF SUCH DAMAGE.",
            "",
            "",
            "__author__ = \"Mathieu Fenniak\"",
            "__author_email__ = \"biziqe@mathieu.fenniak.net\"",
            "",
            "import logging",
            "import re",
            "from io import BytesIO",
            "from typing import Any, Dict, Iterable, List, Optional, Tuple, Union, cast",
            "",
            "from .._utils import (",
            "    WHITESPACES,",
            "    StreamType,",
            "    b_,",
            "    deprecate_with_replacement,",
            "    hex_str,",
            "    logger_warning,",
            "    read_non_whitespace,",
            "    read_until_regex,",
            "    skip_over_comment,",
            ")",
            "from ..constants import (",
            "    CheckboxRadioButtonAttributes,",
            "    FieldDictionaryAttributes,",
            ")",
            "from ..constants import FilterTypes as FT",
            "from ..constants import OutlineFontFlag",
            "from ..constants import StreamAttributes as SA",
            "from ..constants import TypArguments as TA",
            "from ..constants import TypFitArguments as TF",
            "from ..errors import STREAM_TRUNCATED_PREMATURELY, PdfReadError, PdfStreamError",
            "from ._base import (",
            "    BooleanObject,",
            "    FloatObject,",
            "    IndirectObject,",
            "    NameObject,",
            "    NullObject,",
            "    NumberObject,",
            "    PdfObject,",
            ")",
            "from ._utils import read_hex_string_from_stream, read_string_from_stream",
            "",
            "logger = logging.getLogger(__name__)",
            "NumberSigns = b\"+-\"",
            "IndirectPattern = re.compile(rb\"[+-]?(\\d+)\\s+(\\d+)\\s+R[^a-zA-Z]\")",
            "",
            "",
            "class ArrayObject(list, PdfObject):",
            "    def items(self) -> Iterable[Any]:",
            "        \"\"\"",
            "        Emulate DictionaryObject.items for a list",
            "        (index, object)",
            "        \"\"\"",
            "        return enumerate(self)",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"[\")",
            "        for data in self:",
            "            stream.write(b\" \")",
            "            data.write_to_stream(stream, encryption_key)",
            "        stream.write(b\" ]\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(",
            "        stream: StreamType,",
            "        pdf: Any,",
            "        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            "    ) -> \"ArrayObject\":  # PdfReader",
            "        arr = ArrayObject()",
            "        tmp = stream.read(1)",
            "        if tmp != b\"[\":",
            "            raise PdfReadError(\"Could not read array\")",
            "        while True:",
            "            # skip leading whitespace",
            "            tok = stream.read(1)",
            "            while tok.isspace():",
            "                tok = stream.read(1)",
            "            stream.seek(-1, 1)",
            "            # check for array ending",
            "            peekahead = stream.read(1)",
            "            if peekahead == b\"]\":",
            "                break",
            "            stream.seek(-1, 1)",
            "            # read and append obj",
            "            arr.append(read_object(stream, pdf, forced_encoding))",
            "        return arr",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"ArrayObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return ArrayObject.read_from_stream(stream, pdf)",
            "",
            "",
            "class DictionaryObject(dict, PdfObject):",
            "    def raw_get(self, key: Any) -> Any:",
            "        return dict.__getitem__(self, key)",
            "",
            "    def __setitem__(self, key: Any, value: Any) -> Any:",
            "        if not isinstance(key, PdfObject):",
            "            raise ValueError(\"key must be PdfObject\")",
            "        if not isinstance(value, PdfObject):",
            "            raise ValueError(\"value must be PdfObject\")",
            "        return dict.__setitem__(self, key, value)",
            "",
            "    def setdefault(self, key: Any, value: Optional[Any] = None) -> Any:",
            "        if not isinstance(key, PdfObject):",
            "            raise ValueError(\"key must be PdfObject\")",
            "        if not isinstance(value, PdfObject):",
            "            raise ValueError(\"value must be PdfObject\")",
            "        return dict.setdefault(self, key, value)  # type: ignore",
            "",
            "    def __getitem__(self, key: Any) -> PdfObject:",
            "        return dict.__getitem__(self, key).get_object()",
            "",
            "    @property",
            "    def xmp_metadata(self) -> Optional[PdfObject]:",
            "        \"\"\"",
            "        Retrieve XMP (Extensible Metadata Platform) data relevant to the",
            "        this object, if available.",
            "",
            "        Stability: Added in v1.12, will exist for all future v1.x releases.",
            "        @return Returns a {@link #xmp.XmpInformation XmlInformation} instance",
            "        that can be used to access XMP metadata from the document.  Can also",
            "        return None if no metadata was found on the document root.",
            "        \"\"\"",
            "        from ..xmp import XmpInformation",
            "",
            "        metadata = self.get(\"/Metadata\", None)",
            "        if metadata is None:",
            "            return None",
            "        metadata = metadata.get_object()",
            "",
            "        if not isinstance(metadata, XmpInformation):",
            "            metadata = XmpInformation(metadata)",
            "            self[NameObject(\"/Metadata\")] = metadata",
            "        return metadata",
            "",
            "    def getXmpMetadata(",
            "        self,",
            "    ) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :meth:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getXmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    @property",
            "    def xmpMetadata(self) -> Optional[PdfObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :meth:`xmp_metadata` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"xmpMetadata\", \"xmp_metadata\")",
            "        return self.xmp_metadata",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"<<\\n\")",
            "        for key, value in list(self.items()):",
            "            key.write_to_stream(stream, encryption_key)",
            "            stream.write(b\" \")",
            "            value.write_to_stream(stream, encryption_key)",
            "            stream.write(b\"\\n\")",
            "        stream.write(b\">>\")",
            "",
            "    def writeToStream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"writeToStream\", \"write_to_stream\")",
            "        self.write_to_stream(stream, encryption_key)",
            "",
            "    @staticmethod",
            "    def read_from_stream(",
            "        stream: StreamType,",
            "        pdf: Any,  # PdfReader",
            "        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            "    ) -> \"DictionaryObject\":",
            "        def get_next_obj_pos(",
            "            p: int, p1: int, rem_gens: List[int], pdf: Any",
            "        ) -> int:  # PdfReader",
            "            l = pdf.xref[rem_gens[0]]",
            "            for o in l:",
            "                if p1 > l[o] and p < l[o]:",
            "                    p1 = l[o]",
            "            if len(rem_gens) == 1:",
            "                return p1",
            "            else:",
            "                return get_next_obj_pos(p, p1, rem_gens[1:], pdf)",
            "",
            "        def read_unsized_from_steam(stream: StreamType, pdf: Any) -> bytes:  # PdfReader",
            "            # we are just pointing at beginning of the stream",
            "            eon = get_next_obj_pos(stream.tell(), 2**32, list(pdf.xref), pdf) - 1",
            "            curr = stream.tell()",
            "            rw = stream.read(eon - stream.tell())",
            "            p = rw.find(b\"endstream\")",
            "            if p < 0:",
            "                raise PdfReadError(",
            "                    f\"Unable to find 'endstream' marker for obj starting at {curr}.\"",
            "                )",
            "            stream.seek(curr + p + 9)",
            "            return rw[: p - 1]",
            "",
            "        tmp = stream.read(2)",
            "        if tmp != b\"<<\":",
            "            raise PdfReadError(",
            "                f\"Dictionary read error at byte {hex_str(stream.tell())}: \"",
            "                \"stream must begin with '<<'\"",
            "            )",
            "        data: Dict[Any, Any] = {}",
            "        while True:",
            "            tok = read_non_whitespace(stream)",
            "            if tok == b\"\\x00\":",
            "                continue",
            "            elif tok == b\"%\":",
            "                stream.seek(-1, 1)",
            "                skip_over_comment(stream)",
            "                continue",
            "            if not tok:",
            "                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)",
            "",
            "            if tok == b\">\":",
            "                stream.read(1)",
            "                break",
            "            stream.seek(-1, 1)",
            "            try:",
            "                key = read_object(stream, pdf)",
            "                tok = read_non_whitespace(stream)",
            "                stream.seek(-1, 1)",
            "                value = read_object(stream, pdf, forced_encoding)",
            "            except Exception as exc:",
            "                if pdf is not None and pdf.strict:",
            "                    raise PdfReadError(exc.__repr__())",
            "                logger_warning(exc.__repr__(), __name__)",
            "                retval = DictionaryObject()",
            "                retval.update(data)",
            "                return retval  # return partial data",
            "",
            "            if not data.get(key):",
            "                data[key] = value",
            "            else:",
            "                # multiple definitions of key not permitted",
            "                msg = (",
            "                    f\"Multiple definitions in dictionary at byte \"",
            "                    f\"{hex_str(stream.tell())} for key {key}\"",
            "                )",
            "                if pdf is not None and pdf.strict:",
            "                    raise PdfReadError(msg)",
            "                logger_warning(msg, __name__)",
            "",
            "        pos = stream.tell()",
            "        s = read_non_whitespace(stream)",
            "        if s == b\"s\" and stream.read(5) == b\"tream\":",
            "            eol = stream.read(1)",
            "            # odd PDF file output has spaces after 'stream' keyword but before EOL.",
            "            # patch provided by Danial Sandler",
            "            while eol == b\" \":",
            "                eol = stream.read(1)",
            "            if eol not in (b\"\\n\", b\"\\r\"):",
            "                raise PdfStreamError(\"Stream data must be followed by a newline\")",
            "            if eol == b\"\\r\":",
            "                # read \\n after",
            "                if stream.read(1) != b\"\\n\":",
            "                    stream.seek(-1, 1)",
            "            # this is a stream object, not a dictionary",
            "            if SA.LENGTH not in data:",
            "                raise PdfStreamError(\"Stream length not defined\")",
            "            length = data[SA.LENGTH]",
            "            if isinstance(length, IndirectObject):",
            "                t = stream.tell()",
            "                length = pdf.get_object(length)",
            "                stream.seek(t, 0)",
            "            pstart = stream.tell()",
            "            data[\"__streamdata__\"] = stream.read(length)",
            "            e = read_non_whitespace(stream)",
            "            ndstream = stream.read(8)",
            "            if (e + ndstream) != b\"endstream\":",
            "                # (sigh) - the odd PDF file has a length that is too long, so",
            "                # we need to read backwards to find the \"endstream\" ending.",
            "                # ReportLab (unknown version) generates files with this bug,",
            "                # and Python users into PDF files tend to be our audience.",
            "                # we need to do this to correct the streamdata and chop off",
            "                # an extra character.",
            "                pos = stream.tell()",
            "                stream.seek(-10, 1)",
            "                end = stream.read(9)",
            "                if end == b\"endstream\":",
            "                    # we found it by looking back one character further.",
            "                    data[\"__streamdata__\"] = data[\"__streamdata__\"][:-1]",
            "                elif not pdf.strict:",
            "                    stream.seek(pstart, 0)",
            "                    data[\"__streamdata__\"] = read_unsized_from_steam(stream, pdf)",
            "                    pos = stream.tell()",
            "                else:",
            "                    stream.seek(pos, 0)",
            "                    raise PdfReadError(",
            "                        \"Unable to find 'endstream' marker after stream at byte \"",
            "                        f\"{hex_str(stream.tell())} (nd='{ndstream!r}', end='{end!r}').\"",
            "                    )",
            "        else:",
            "            stream.seek(pos, 0)",
            "        if \"__streamdata__\" in data:",
            "            return StreamObject.initialize_from_dictionary(data)",
            "        else:",
            "            retval = DictionaryObject()",
            "            retval.update(data)",
            "            return retval",
            "",
            "    @staticmethod",
            "    def readFromStream(",
            "        stream: StreamType, pdf: Any  # PdfReader",
            "    ) -> \"DictionaryObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"readFromStream\", \"read_from_stream\")",
            "        return DictionaryObject.read_from_stream(stream, pdf)",
            "",
            "",
            "class TreeObject(DictionaryObject):",
            "    def __init__(self) -> None:",
            "        DictionaryObject.__init__(self)",
            "",
            "    def hasChildren(self) -> bool:  # pragma: no cover",
            "        deprecate_with_replacement(\"hasChildren\", \"has_children\", \"4.0.0\")",
            "        return self.has_children()",
            "",
            "    def has_children(self) -> bool:",
            "        return \"/First\" in self",
            "",
            "    def __iter__(self) -> Any:",
            "        return self.children()",
            "",
            "    def children(self) -> Iterable[Any]:",
            "        if not self.has_children():",
            "            return",
            "",
            "        child_ref = self[NameObject(\"/First\")]",
            "        child = child_ref.get_object()",
            "        while True:",
            "            yield child",
            "            if child == self[NameObject(\"/Last\")]:",
            "                return",
            "            child_ref = child.get(NameObject(\"/Next\"))  # type: ignore",
            "            if child_ref is None:",
            "                return",
            "            child = child_ref.get_object()",
            "",
            "    def addChild(self, child: Any, pdf: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"addChild\", \"add_child\")",
            "        self.add_child(child, pdf)",
            "",
            "    def add_child(self, child: Any, pdf: Any) -> None:  # PdfWriter",
            "        child_obj = child.get_object()",
            "        child = pdf.get_reference(child_obj)",
            "        assert isinstance(child, IndirectObject)",
            "",
            "        prev: Optional[DictionaryObject]",
            "        if \"/First\" not in self:",
            "            self[NameObject(\"/First\")] = child",
            "            self[NameObject(\"/Count\")] = NumberObject(0)",
            "            prev = None",
            "        else:",
            "            prev = cast(",
            "                DictionaryObject, self[\"/Last\"]",
            "            )  # TABLE 8.3 Entries in the outline dictionary",
            "",
            "        self[NameObject(\"/Last\")] = child",
            "        self[NameObject(\"/Count\")] = NumberObject(self[NameObject(\"/Count\")] + 1)  # type: ignore",
            "",
            "        if prev:",
            "            prev_ref = pdf.get_reference(prev)",
            "            assert isinstance(prev_ref, IndirectObject)",
            "            child_obj[NameObject(\"/Prev\")] = prev_ref",
            "            prev[NameObject(\"/Next\")] = child",
            "",
            "        parent_ref = pdf.get_reference(self)",
            "        assert isinstance(parent_ref, IndirectObject)",
            "        child_obj[NameObject(\"/Parent\")] = parent_ref",
            "",
            "    def removeChild(self, child: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"removeChild\", \"remove_child\")",
            "        self.remove_child(child)",
            "",
            "    def _remove_node_from_tree(",
            "        self, prev: Any, prev_ref: Any, cur: Any, last: Any",
            "    ) -> None:",
            "        \"\"\"Adjust the pointers of the linked list and tree node count.\"\"\"",
            "        next_ref = cur.get(NameObject(\"/Next\"), None)",
            "        if prev is None:",
            "            if next_ref:",
            "                # Removing first tree node",
            "                next_obj = next_ref.get_object()",
            "                del next_obj[NameObject(\"/Prev\")]",
            "                self[NameObject(\"/First\")] = next_ref",
            "                self[NameObject(\"/Count\")] = NumberObject(",
            "                    self[NameObject(\"/Count\")] - 1  # type: ignore",
            "                )",
            "",
            "            else:",
            "                # Removing only tree node",
            "                assert self[NameObject(\"/Count\")] == 1",
            "                del self[NameObject(\"/Count\")]",
            "                del self[NameObject(\"/First\")]",
            "                if NameObject(\"/Last\") in self:",
            "                    del self[NameObject(\"/Last\")]",
            "        else:",
            "            if next_ref:",
            "                # Removing middle tree node",
            "                next_obj = next_ref.get_object()",
            "                next_obj[NameObject(\"/Prev\")] = prev_ref",
            "                prev[NameObject(\"/Next\")] = next_ref",
            "            else:",
            "                # Removing last tree node",
            "                assert cur == last",
            "                del prev[NameObject(\"/Next\")]",
            "                self[NameObject(\"/Last\")] = prev_ref",
            "            self[NameObject(\"/Count\")] = NumberObject(self[NameObject(\"/Count\")] - 1)  # type: ignore",
            "",
            "    def remove_child(self, child: Any) -> None:",
            "        child_obj = child.get_object()",
            "",
            "        if NameObject(\"/Parent\") not in child_obj:",
            "            raise ValueError(\"Removed child does not appear to be a tree item\")",
            "        elif child_obj[NameObject(\"/Parent\")] != self:",
            "            raise ValueError(\"Removed child is not a member of this tree\")",
            "",
            "        found = False",
            "        prev_ref = None",
            "        prev = None",
            "        cur_ref: Optional[Any] = self[NameObject(\"/First\")]",
            "        cur: Optional[Dict[str, Any]] = cur_ref.get_object()  # type: ignore",
            "        last_ref = self[NameObject(\"/Last\")]",
            "        last = last_ref.get_object()",
            "        while cur is not None:",
            "            if cur == child_obj:",
            "                self._remove_node_from_tree(prev, prev_ref, cur, last)",
            "                found = True",
            "                break",
            "",
            "            # Go to the next node",
            "            prev_ref = cur_ref",
            "            prev = cur",
            "            if NameObject(\"/Next\") in cur:",
            "                cur_ref = cur[NameObject(\"/Next\")]",
            "                cur = cur_ref.get_object()",
            "            else:",
            "                cur_ref = None",
            "                cur = None",
            "",
            "        if not found:",
            "            raise ValueError(\"Removal couldn't find item in tree\")",
            "",
            "        _reset_node_tree_relationship(child_obj)",
            "",
            "    def emptyTree(self) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"emptyTree\", \"empty_tree\", \"4.0.0\")",
            "        self.empty_tree()",
            "",
            "    def empty_tree(self) -> None:",
            "        for child in self:",
            "            child_obj = child.get_object()",
            "            _reset_node_tree_relationship(child_obj)",
            "",
            "        if NameObject(\"/Count\") in self:",
            "            del self[NameObject(\"/Count\")]",
            "        if NameObject(\"/First\") in self:",
            "            del self[NameObject(\"/First\")]",
            "        if NameObject(\"/Last\") in self:",
            "            del self[NameObject(\"/Last\")]",
            "",
            "",
            "def _reset_node_tree_relationship(child_obj: Any) -> None:",
            "    \"\"\"",
            "    Call this after a node has been removed from a tree.",
            "",
            "    This resets the nodes attributes in respect to that tree.",
            "    \"\"\"",
            "    del child_obj[NameObject(\"/Parent\")]",
            "    if NameObject(\"/Next\") in child_obj:",
            "        del child_obj[NameObject(\"/Next\")]",
            "    if NameObject(\"/Prev\") in child_obj:",
            "        del child_obj[NameObject(\"/Prev\")]",
            "",
            "",
            "class StreamObject(DictionaryObject):",
            "    def __init__(self) -> None:",
            "        self.__data: Optional[str] = None",
            "        self.decoded_self: Optional[DecodedStreamObject] = None",
            "",
            "    def hash_value_data(self) -> bytes:",
            "        data = super().hash_value_data()",
            "        data += b_(self._data)",
            "        return data",
            "",
            "    @property",
            "    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        return self.decoded_self",
            "",
            "    @decodedSelf.setter",
            "    def decodedSelf(self, value: \"DecodedStreamObject\") -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        self.decoded_self = value",
            "",
            "    @property",
            "    def _data(self) -> Any:",
            "        return self.__data",
            "",
            "    @_data.setter",
            "    def _data(self, value: Any) -> None:",
            "        self.__data = value",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        self[NameObject(SA.LENGTH)] = NumberObject(len(self._data))",
            "        DictionaryObject.write_to_stream(self, stream, encryption_key)",
            "        del self[SA.LENGTH]",
            "        stream.write(b\"\\nstream\\n\")",
            "        data = self._data",
            "        if encryption_key:",
            "            from .._security import RC4_encrypt",
            "",
            "            data = RC4_encrypt(encryption_key, data)",
            "        stream.write(data)",
            "        stream.write(b\"\\nendstream\")",
            "",
            "    @staticmethod",
            "    def initializeFromDictionary(",
            "        data: Dict[str, Any]",
            "    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:  # pragma: no cover",
            "        return StreamObject.initialize_from_dictionary(data)",
            "",
            "    @staticmethod",
            "    def initialize_from_dictionary(",
            "        data: Dict[str, Any]",
            "    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:",
            "        retval: Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]",
            "        if SA.FILTER in data:",
            "            retval = EncodedStreamObject()",
            "        else:",
            "            retval = DecodedStreamObject()",
            "        retval._data = data[\"__streamdata__\"]",
            "        del data[\"__streamdata__\"]",
            "        del data[SA.LENGTH]",
            "        retval.update(data)",
            "        return retval",
            "",
            "    def flateEncode(self) -> \"EncodedStreamObject\":  # pragma: no cover",
            "        deprecate_with_replacement(\"flateEncode\", \"flate_encode\")",
            "        return self.flate_encode()",
            "",
            "    def flate_encode(self) -> \"EncodedStreamObject\":",
            "        from ..filters import FlateDecode",
            "",
            "        if SA.FILTER in self:",
            "            f = self[SA.FILTER]",
            "            if isinstance(f, ArrayObject):",
            "                f.insert(0, NameObject(FT.FLATE_DECODE))",
            "            else:",
            "                newf = ArrayObject()",
            "                newf.append(NameObject(\"/FlateDecode\"))",
            "                newf.append(f)",
            "                f = newf",
            "        else:",
            "            f = NameObject(\"/FlateDecode\")",
            "        retval = EncodedStreamObject()",
            "        retval[NameObject(SA.FILTER)] = f",
            "        retval._data = FlateDecode.encode(self._data)",
            "        return retval",
            "",
            "",
            "class DecodedStreamObject(StreamObject):",
            "    def get_data(self) -> Any:",
            "        return self._data",
            "",
            "    def set_data(self, data: Any) -> Any:",
            "        self._data = data",
            "",
            "    def getData(self) -> Any:  # pragma: no cover",
            "        deprecate_with_replacement(\"getData\", \"get_data\")",
            "        return self._data",
            "",
            "    def setData(self, data: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"setData\", \"set_data\")",
            "        self.set_data(data)",
            "",
            "",
            "class EncodedStreamObject(StreamObject):",
            "    def __init__(self) -> None:",
            "        self.decoded_self: Optional[DecodedStreamObject] = None",
            "",
            "    @property",
            "    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        return self.decoded_self",
            "",
            "    @decodedSelf.setter",
            "    def decodedSelf(self, value: DecodedStreamObject) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"decodedSelf\", \"decoded_self\")",
            "        self.decoded_self = value",
            "",
            "    def get_data(self) -> Union[None, str, bytes]:",
            "        from ..filters import decode_stream_data",
            "",
            "        if self.decoded_self is not None:",
            "            # cached version of decoded object",
            "            return self.decoded_self.get_data()",
            "        else:",
            "            # create decoded object",
            "            decoded = DecodedStreamObject()",
            "",
            "            decoded._data = decode_stream_data(self)",
            "            for key, value in list(self.items()):",
            "                if key not in (SA.LENGTH, SA.FILTER, SA.DECODE_PARMS):",
            "                    decoded[key] = value",
            "            self.decoded_self = decoded",
            "            return decoded._data",
            "",
            "    def getData(self) -> Union[None, str, bytes]:  # pragma: no cover",
            "        deprecate_with_replacement(\"getData\", \"get_data\")",
            "        return self.get_data()",
            "",
            "    def set_data(self, data: Any) -> None:  # pragma: no cover",
            "        raise PdfReadError(\"Creating EncodedStreamObject is not currently supported\")",
            "",
            "    def setData(self, data: Any) -> None:  # pragma: no cover",
            "        deprecate_with_replacement(\"setData\", \"set_data\")",
            "        return self.set_data(data)",
            "",
            "",
            "class ContentStream(DecodedStreamObject):",
            "    def __init__(",
            "        self,",
            "        stream: Any,",
            "        pdf: Any,",
            "        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            "    ) -> None:",
            "        self.pdf = pdf",
            "",
            "        # The inner list has two elements:",
            "        #  [0] : List",
            "        #  [1] : str",
            "        self.operations: List[Tuple[Any, Any]] = []",
            "",
            "        # stream may be a StreamObject or an ArrayObject containing",
            "        # multiple StreamObjects to be cat'd together.",
            "        stream = stream.get_object()",
            "        if isinstance(stream, ArrayObject):",
            "            data = b\"\"",
            "            for s in stream:",
            "                data += b_(s.get_object().get_data())",
            "                if data[-1] != b\"\\n\":",
            "                    data += b\"\\n\"",
            "            stream_bytes = BytesIO(data)",
            "        else:",
            "            stream_data = stream.get_data()",
            "            assert stream_data is not None",
            "            stream_data_bytes = b_(stream_data)",
            "            stream_bytes = BytesIO(stream_data_bytes)",
            "        self.forced_encoding = forced_encoding",
            "        self.__parse_content_stream(stream_bytes)",
            "",
            "    def __parse_content_stream(self, stream: StreamType) -> None:",
            "        stream.seek(0, 0)",
            "        operands: List[Union[int, str, PdfObject]] = []",
            "        while True:",
            "            peek = read_non_whitespace(stream)",
            "            if peek == b\"\" or peek == 0:",
            "                break",
            "            stream.seek(-1, 1)",
            "            if peek.isalpha() or peek in (b\"'\", b'\"'):",
            "                operator = read_until_regex(stream, NameObject.delimiter_pattern, True)",
            "                if operator == b\"BI\":",
            "                    # begin inline image - a completely different parsing",
            "                    # mechanism is required, of course... thanks buddy...",
            "                    assert operands == []",
            "                    ii = self._read_inline_image(stream)",
            "                    self.operations.append((ii, b\"INLINE IMAGE\"))",
            "                else:",
            "                    self.operations.append((operands, operator))",
            "                    operands = []",
            "            elif peek == b\"%\":",
            "                # If we encounter a comment in the content stream, we have to",
            "                # handle it here.  Typically, read_object will handle",
            "                # encountering a comment -- but read_object assumes that",
            "                # following the comment must be the object we're trying to",
            "                # read.  In this case, it could be an operator instead.",
            "                while peek not in (b\"\\r\", b\"\\n\"):",
            "                    peek = stream.read(1)",
            "            else:",
            "                operands.append(read_object(stream, None, self.forced_encoding))",
            "",
            "    def _read_inline_image(self, stream: StreamType) -> Dict[str, Any]:",
            "        # begin reading just after the \"BI\" - begin image",
            "        # first read the dictionary of settings.",
            "        settings = DictionaryObject()",
            "        while True:",
            "            tok = read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            if tok == b\"I\":",
            "                # \"ID\" - begin of image data",
            "                break",
            "            key = read_object(stream, self.pdf)",
            "            tok = read_non_whitespace(stream)",
            "            stream.seek(-1, 1)",
            "            value = read_object(stream, self.pdf)",
            "            settings[key] = value",
            "        # left at beginning of ID",
            "        tmp = stream.read(3)",
            "        assert tmp[:2] == b\"ID\"",
            "        data = BytesIO()",
            "        # Read the inline image, while checking for EI (End Image) operator.",
            "        while True:",
            "            # Read 8 kB at a time and check if the chunk contains the E operator.",
            "            buf = stream.read(8192)",
            "            # We have reached the end of the stream, but haven't found the EI operator.",
            "            if not buf:",
            "                raise PdfReadError(\"Unexpected end of stream\")",
            "            loc = buf.find(b\"E\")",
            "",
            "            if loc == -1:",
            "                data.write(buf)",
            "            else:",
            "                # Write out everything before the E.",
            "                data.write(buf[0:loc])",
            "",
            "                # Seek back in the stream to read the E next.",
            "                stream.seek(loc - len(buf), 1)",
            "                tok = stream.read(1)",
            "                # Check for End Image",
            "                tok2 = stream.read(1)",
            "                if tok2 == b\"I\" and buf[loc - 1 : loc] in WHITESPACES:",
            "                    # Data can contain [\\s]EI,  so check for the separator \\s; 4 chars suffisent Q operator not required.",
            "                    tok3 = stream.read(1)",
            "                    info = tok + tok2",
            "                    # We need to find at least one whitespace after.",
            "                    has_q_whitespace = False",
            "                    while tok3 in WHITESPACES:",
            "                        has_q_whitespace = True",
            "                        info += tok3",
            "                        tok3 = stream.read(1)",
            "                    if has_q_whitespace:",
            "                        stream.seek(-1, 1)",
            "                        break",
            "                    else:",
            "                        stream.seek(-1, 1)",
            "                        data.write(info)",
            "                else:",
            "                    stream.seek(-1, 1)",
            "                    data.write(tok)",
            "        return {\"settings\": settings, \"data\": data.getvalue()}",
            "",
            "    @property",
            "    def _data(self) -> bytes:",
            "        newdata = BytesIO()",
            "        for operands, operator in self.operations:",
            "            if operator == b\"INLINE IMAGE\":",
            "                newdata.write(b\"BI\")",
            "                dicttext = BytesIO()",
            "                operands[\"settings\"].write_to_stream(dicttext, None)",
            "                newdata.write(dicttext.getvalue()[2:-2])",
            "                newdata.write(b\"ID \")",
            "                newdata.write(operands[\"data\"])",
            "                newdata.write(b\"EI\")",
            "            else:",
            "                for op in operands:",
            "                    op.write_to_stream(newdata, None)",
            "                    newdata.write(b\" \")",
            "                newdata.write(b_(operator))",
            "            newdata.write(b\"\\n\")",
            "        return newdata.getvalue()",
            "",
            "    @_data.setter",
            "    def _data(self, value: Union[str, bytes]) -> None:",
            "        self.__parse_content_stream(BytesIO(b_(value)))",
            "",
            "",
            "def read_object(",
            "    stream: StreamType,",
            "    pdf: Any,  # PdfReader",
            "    forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,",
            ") -> Union[PdfObject, int, str, ContentStream]:",
            "    tok = stream.read(1)",
            "    stream.seek(-1, 1)  # reset to start",
            "    if tok == b\"/\":",
            "        return NameObject.read_from_stream(stream, pdf)",
            "    elif tok == b\"<\":",
            "        # hexadecimal string OR dictionary",
            "        peek = stream.read(2)",
            "        stream.seek(-2, 1)  # reset to start",
            "",
            "        if peek == b\"<<\":",
            "            return DictionaryObject.read_from_stream(stream, pdf, forced_encoding)",
            "        else:",
            "            return read_hex_string_from_stream(stream, forced_encoding)",
            "    elif tok == b\"[\":",
            "        return ArrayObject.read_from_stream(stream, pdf, forced_encoding)",
            "    elif tok == b\"t\" or tok == b\"f\":",
            "        return BooleanObject.read_from_stream(stream)",
            "    elif tok == b\"(\":",
            "        return read_string_from_stream(stream, forced_encoding)",
            "    elif tok == b\"n\":",
            "        return NullObject.read_from_stream(stream)",
            "    elif tok == b\"%\":",
            "        # comment",
            "        while tok not in (b\"\\r\", b\"\\n\"):",
            "            tok = stream.read(1)",
            "            # Prevents an infinite loop by raising an error if the stream is at",
            "            # the EOF",
            "            if len(tok) <= 0:",
            "                raise PdfStreamError(\"File ended unexpectedly.\")",
            "        tok = read_non_whitespace(stream)",
            "        stream.seek(-1, 1)",
            "        return read_object(stream, pdf, forced_encoding)",
            "    elif tok in b\"0123456789+-.\":",
            "        # number object OR indirect reference",
            "        peek = stream.read(20)",
            "        stream.seek(-len(peek), 1)  # reset to start",
            "        if IndirectPattern.match(peek) is not None:",
            "            return IndirectObject.read_from_stream(stream, pdf)",
            "        else:",
            "            return NumberObject.read_from_stream(stream)",
            "    else:",
            "        raise PdfReadError(",
            "            f\"Invalid Elementary Object starting with {tok} @{stream.tell()}\"  # type: ignore",
            "        )",
            "",
            "",
            "class Field(TreeObject):",
            "    \"\"\"",
            "    A class representing a field dictionary.",
            "",
            "    This class is accessed through",
            "    :meth:`get_fields()<PyPDF2.PdfReader.get_fields>`",
            "    \"\"\"",
            "",
            "    def __init__(self, data: Dict[str, Any]) -> None:",
            "        DictionaryObject.__init__(self)",
            "        field_attributes = (",
            "            FieldDictionaryAttributes.attributes()",
            "            + CheckboxRadioButtonAttributes.attributes()",
            "        )",
            "        for attr in field_attributes:",
            "            try:",
            "                self[NameObject(attr)] = data[attr]",
            "            except KeyError:",
            "                pass",
            "",
            "    # TABLE 8.69 Entries common to all field dictionaries",
            "    @property",
            "    def field_type(self) -> Optional[NameObject]:",
            "        \"\"\"Read-only property accessing the type of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.FT)",
            "",
            "    @property",
            "    def fieldType(self) -> Optional[NameObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`field_type` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"fieldType\", \"field_type\")",
            "        return self.field_type",
            "",
            "    @property",
            "    def parent(self) -> Optional[DictionaryObject]:",
            "        \"\"\"Read-only property accessing the parent of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.Parent)",
            "",
            "    @property",
            "    def kids(self) -> Optional[ArrayObject]:",
            "        \"\"\"Read-only property accessing the kids of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.Kids)",
            "",
            "    @property",
            "    def name(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the name of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.T)",
            "",
            "    @property",
            "    def alternate_name(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the alternate name of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.TU)",
            "",
            "    @property",
            "    def altName(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`alternate_name` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"altName\", \"alternate_name\")",
            "        return self.alternate_name",
            "",
            "    @property",
            "    def mapping_name(self) -> Optional[str]:",
            "        \"\"\"",
            "        Read-only property accessing the mapping name of this field. This",
            "        name is used by PyPDF2 as a key in the dictionary returned by",
            "        :meth:`get_fields()<PyPDF2.PdfReader.get_fields>`",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.TM)",
            "",
            "    @property",
            "    def mappingName(self) -> Optional[str]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`mapping_name` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"mappingName\", \"mapping_name\")",
            "        return self.mapping_name",
            "",
            "    @property",
            "    def flags(self) -> Optional[int]:",
            "        \"\"\"",
            "        Read-only property accessing the field flags, specifying various",
            "        characteristics of the field (see Table 8.70 of the PDF 1.7 reference).",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.Ff)",
            "",
            "    @property",
            "    def value(self) -> Optional[Any]:",
            "        \"\"\"",
            "        Read-only property accessing the value of this field. Format",
            "        varies based on field type.",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.V)",
            "",
            "    @property",
            "    def default_value(self) -> Optional[Any]:",
            "        \"\"\"Read-only property accessing the default value of this field.\"\"\"",
            "        return self.get(FieldDictionaryAttributes.DV)",
            "",
            "    @property",
            "    def defaultValue(self) -> Optional[Any]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`default_value` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"defaultValue\", \"default_value\")",
            "        return self.default_value",
            "",
            "    @property",
            "    def additional_actions(self) -> Optional[DictionaryObject]:",
            "        \"\"\"",
            "        Read-only property accessing the additional actions dictionary.",
            "        This dictionary defines the field's behavior in response to trigger events.",
            "        See Section 8.5.2 of the PDF 1.7 reference.",
            "        \"\"\"",
            "        return self.get(FieldDictionaryAttributes.AA)",
            "",
            "    @property",
            "    def additionalActions(self) -> Optional[DictionaryObject]:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`additional_actions` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"additionalActions\", \"additional_actions\")",
            "        return self.additional_actions",
            "",
            "",
            "class Destination(TreeObject):",
            "    \"\"\"",
            "    A class representing a destination within a PDF file.",
            "    See section 8.2.1 of the PDF 1.6 reference.",
            "",
            "    :param str title: Title of this destination.",
            "    :param IndirectObject page: Reference to the page of this destination. Should",
            "        be an instance of :class:`IndirectObject<PyPDF2.generic.IndirectObject>`.",
            "    :param str typ: How the destination is displayed.",
            "    :param args: Additional arguments may be necessary depending on the type.",
            "    :raises PdfReadError: If destination type is invalid.",
            "",
            "    .. list-table:: Valid ``typ`` arguments (see PDF spec for details)",
            "       :widths: 50 50",
            "",
            "       * - /Fit",
            "         - No additional arguments",
            "       * - /XYZ",
            "         - [left] [top] [zoomFactor]",
            "       * - /FitH",
            "         - [top]",
            "       * - /FitV",
            "         - [left]",
            "       * - /FitR",
            "         - [left] [bottom] [right] [top]",
            "       * - /FitB",
            "         - No additional arguments",
            "       * - /FitBH",
            "         - [top]",
            "       * - /FitBV",
            "         - [left]",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        title: str,",
            "        page: Union[NumberObject, IndirectObject, NullObject, DictionaryObject],",
            "        typ: Union[str, NumberObject],",
            "        *args: Any,  # ZoomArgType",
            "    ) -> None:",
            "        DictionaryObject.__init__(self)",
            "        self[NameObject(\"/Title\")] = title",
            "        self[NameObject(\"/Page\")] = page",
            "        self[NameObject(\"/Type\")] = typ",
            "",
            "        # from table 8.2 of the PDF 1.7 reference.",
            "        if typ == \"/XYZ\":",
            "            (",
            "                self[NameObject(TA.LEFT)],",
            "                self[NameObject(TA.TOP)],",
            "                self[NameObject(\"/Zoom\")],",
            "            ) = args",
            "        elif typ == TF.FIT_R:",
            "            (",
            "                self[NameObject(TA.LEFT)],",
            "                self[NameObject(TA.BOTTOM)],",
            "                self[NameObject(TA.RIGHT)],",
            "                self[NameObject(TA.TOP)],",
            "            ) = args",
            "        elif typ in [TF.FIT_H, TF.FIT_BH]:",
            "            try:  # Prefered to be more robust not only to null parameters",
            "                (self[NameObject(TA.TOP)],) = args",
            "            except Exception:",
            "                (self[NameObject(TA.TOP)],) = (NullObject(),)",
            "        elif typ in [TF.FIT_V, TF.FIT_BV]:",
            "            try:  # Prefered to be more robust not only to null parameters",
            "                (self[NameObject(TA.LEFT)],) = args",
            "            except Exception:",
            "                (self[NameObject(TA.LEFT)],) = (NullObject(),)",
            "        elif typ in [TF.FIT, TF.FIT_B]:",
            "            pass",
            "        else:",
            "            raise PdfReadError(f\"Unknown Destination Type: {typ!r}\")",
            "",
            "    @property",
            "    def dest_array(self) -> ArrayObject:",
            "        return ArrayObject(",
            "            [self.raw_get(\"/Page\"), self[\"/Type\"]]",
            "            + [",
            "                self[x]",
            "                for x in [\"/Left\", \"/Bottom\", \"/Right\", \"/Top\", \"/Zoom\"]",
            "                if x in self",
            "            ]",
            "        )",
            "",
            "    def getDestArray(self) -> ArrayObject:  # pragma: no cover",
            "        \"\"\"",
            "        .. deprecated:: 1.28.3",
            "",
            "            Use :py:attr:`dest_array` instead.",
            "        \"\"\"",
            "        deprecate_with_replacement(\"getDestArray\", \"dest_array\")",
            "        return self.dest_array",
            "",
            "    def write_to_stream(",
            "        self, stream: StreamType, encryption_key: Union[None, str, bytes]",
            "    ) -> None:",
            "        stream.write(b\"<<\\n\")",
            "        key = NameObject(\"/D\")",
            "        key.write_to_stream(stream, encryption_key)",
            "        stream.write(b\" \")",
            "        value = self.dest_array",
            "        value.write_to_stream(stream, encryption_key)",
            "",
            "        key = NameObject(\"/S\")",
            "        key.write_to_stream(stream, encryption_key)",
            "        stream.write(b\" \")",
            "        value_s = NameObject(\"/GoTo\")",
            "        value_s.write_to_stream(stream, encryption_key)",
            "",
            "        stream.write(b\"\\n\")",
            "        stream.write(b\">>\")",
            "",
            "    @property",
            "    def title(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the destination title.\"\"\"",
            "        return self.get(\"/Title\")",
            "",
            "    @property",
            "    def page(self) -> Optional[int]:",
            "        \"\"\"Read-only property accessing the destination page number.\"\"\"",
            "        return self.get(\"/Page\")",
            "",
            "    @property",
            "    def typ(self) -> Optional[str]:",
            "        \"\"\"Read-only property accessing the destination type.\"\"\"",
            "        return self.get(\"/Type\")",
            "",
            "    @property",
            "    def zoom(self) -> Optional[int]:",
            "        \"\"\"Read-only property accessing the zoom factor.\"\"\"",
            "        return self.get(\"/Zoom\", None)",
            "",
            "    @property",
            "    def left(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the left horizontal coordinate.\"\"\"",
            "        return self.get(\"/Left\", None)",
            "",
            "    @property",
            "    def right(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the right horizontal coordinate.\"\"\"",
            "        return self.get(\"/Right\", None)",
            "",
            "    @property",
            "    def top(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the top vertical coordinate.\"\"\"",
            "        return self.get(\"/Top\", None)",
            "",
            "    @property",
            "    def bottom(self) -> Optional[FloatObject]:",
            "        \"\"\"Read-only property accessing the bottom vertical coordinate.\"\"\"",
            "        return self.get(\"/Bottom\", None)",
            "",
            "    @property",
            "    def color(self) -> Optional[ArrayObject]:",
            "        \"\"\"Read-only property accessing the color in (R, G, B) with values 0.0-1.0\"\"\"",
            "        return self.get(",
            "            \"/C\", ArrayObject([FloatObject(0), FloatObject(0), FloatObject(0)])",
            "        )",
            "",
            "    @property",
            "    def font_format(self) -> Optional[OutlineFontFlag]:",
            "        \"\"\"Read-only property accessing the font type. 1=italic, 2=bold, 3=both\"\"\"",
            "        return self.get(\"/F\", 0)",
            "",
            "    @property",
            "    def outline_count(self) -> Optional[int]:",
            "        \"\"\"",
            "        Read-only property accessing the outline count.",
            "        positive = expanded",
            "        negative = collapsed",
            "        absolute value = number of visible descendents at all levels",
            "        \"\"\"",
            "        return self.get(\"/Count\", None)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "70": [
                "ObjectPrefix"
            ],
            "266": [
                "DictionaryObject",
                "read_from_stream"
            ],
            "267": [
                "DictionaryObject",
                "read_from_stream"
            ],
            "268": [
                "DictionaryObject",
                "read_from_stream"
            ],
            "269": [
                "DictionaryObject",
                "read_from_stream"
            ],
            "815": [
                "read_object"
            ],
            "816": [
                "read_object"
            ],
            "818": [
                "read_object"
            ],
            "827": [
                "read_object"
            ],
            "829": [
                "read_object"
            ],
            "831": [
                "read_object"
            ],
            "833": [
                "read_object"
            ],
            "835": [
                "read_object"
            ],
            "846": [
                "read_object"
            ]
        },
        "addLocation": []
    }
}