{
    "src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " .. image:: /_static/Systems/FS/TokenManager_getToken.png"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-The service and its client have a mechanism for caching the received tokens."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+The client has a mechanism for caching the received tokens."
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " This helps reduce the number of requests to both the service and the Identity Provider (IdP)."
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " If the client has a valid **access token** in the cache, it is used until it expires."
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " After that you need to update. The client can update it independently if on the server where it is in ``dirac.cfg``"
            },
            "9": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " ``client_id`` and ``client_secret`` of the Identity Provider client are registered."
            },
            "10": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " Otherwise, the client makes an RPC call to the **TornadoManager** service."
            },
            "12": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-It in turn checks the cache and if the ``access token`` is already invalid tries to update it using a ``refresh token``."
            },
            "13": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-If the required token is not in the cache, then the ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`"
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-is taken and the **exchange token** request to Identity Provider is made. The received tokens are cached."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+The ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+is taken and the **exchange token** request to Identity Provider is made."
            },
            "17": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " \"\"\""
            },
            "18": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " import pprint"
            },
            "20": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " )"
            },
            "21": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " from DIRAC.Resources.IdProvider.IdProviderFactory import IdProviderFactory"
            },
            "22": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# Used to synchronize the cache with user tokens"
            },
            "24": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-gTokensSync = ThreadSafe.Synchronizer()"
            },
            "25": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " class TornadoTokenManagerHandler(TornadoService):"
            },
            "28": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     DEFAULT_AUTHORIZATION = [\"authenticated\"]"
            },
            "29": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         :return: S_OK()/S_ERROR()"
            },
            "31": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         \"\"\""
            },
            "32": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Cache containing tokens from scope requested by the client"
            },
            "33": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cls.__tokensCache = DictCache()"
            },
            "34": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client."
            },
            "36": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         # This allows you to manage tokens without the involvement of their owners."
            },
            "37": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         # Not authorized!"
            },
            "38": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         return S_ERROR(\"You can't get tokens!\")"
            },
            "39": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @gTokensSync"
            },
            "41": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "     def export_getToken("
            },
            "42": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         self,"
            },
            "43": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         username: str = None,"
            },
            "44": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "             return result"
            },
            "45": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "         idpObj = result[\"Value\"]"
            },
            "46": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Search for an existing token in tokensCache"
            },
            "48": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cachedKey = getCachedKey(idpObj, username, userGroup, scope, audience)"
            },
            "49": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        result = getCachedToken(self.__tokensCache, cachedKey, requiredTimeLeft)"
            },
            "50": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if result[\"OK\"]:"
            },
            "51": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # A valid token has been found and is returned"
            },
            "52": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return result"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        # getCachedKey is just used here to resolve the default scopes"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+        _, scope, *_ = getCachedKey(idpObj, username, userGroup, scope, audience)"
            },
            "55": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 210,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         # A client token is requested"
            },
            "57": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         if not username:"
            },
            "58": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "                 return result"
            },
            "59": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 216,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "             # Get the client token with requested scope and audience"
            },
            "61": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            scope = cachedKey[1]"
            },
            "62": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            audience = cachedKey[2]"
            },
            "63": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)"
            },
            "64": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not result[\"OK\"]:"
            },
            "65": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return result"
            },
            "66": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            token = result[\"Value\"]"
            },
            "67": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "68": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Caching new token: only get an access token (no refresh token in this context)"
            },
            "69": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.__tokensCache.add("
            },
            "70": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cachedKey,"
            },
            "71": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result[\"Value\"].get_claim(\"exp\", \"access_token\") or DEFAULT_AT_EXPIRATION_TIME,"
            },
            "72": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                token,"
            },
            "73": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "             return result"
            },
            "76": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         # A user token is requested"
            },
            "78": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "                         # refresh token with requested scope"
            },
            "79": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "                         result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)"
            },
            "80": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "                         if result[\"OK\"]:"
            },
            "81": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            # caching new tokens"
            },
            "82": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            self.__tokensCache.add("
            },
            "83": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                cachedKey,"
            },
            "84": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                result[\"Value\"].get_claim(\"exp\", \"refresh_token\") or DEFAULT_RT_EXPIRATION_TIME,"
            },
            "85": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                result[\"Value\"],"
            },
            "86": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            )"
            },
            "87": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "                             return result"
            },
            "88": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "                 # Did not find any token associated with the found user ID"
            },
            "89": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "                 err.append(result.get(\"Message\", f\"No token found for {uid}\"))"
            }
        },
        "frontPatchFile": [
            "\"\"\"TokenManager service is a HTTPs-exposed service responsible for token management, namely storing, updating,",
            "requesting new tokens for DIRAC components that have the appropriate permissions.",
            "",
            ".. note:: As a newly created service, it will not support the old DIPS protocol, which is living to its age.",
            "",
            ".. literalinclude:: ../ConfigTemplate.cfg",
            "    :start-after: ##BEGIN TornadoTokenManager:",
            "    :end-before: ##END",
            "    :dedent: 2",
            "    :caption: TornadoTokenManager options",
            "",
            "The most common use of this service is to obtain tokens with certain scope to return to the user for its purposes,",
            "or to provide to the DIRAC service to perform asynchronous tasks on behalf of the user.",
            "This is mainly about the :py:meth:`export_getToken` method.",
            "",
            ".. image:: /_static/Systems/FS/TokenManager_getToken.png",
            "    :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)",
            "",
            "The service and its client have a mechanism for caching the received tokens.",
            "This helps reduce the number of requests to both the service and the Identity Provider (IdP).",
            "",
            "If the client has a valid **access token** in the cache, it is used until it expires.",
            "After that you need to update. The client can update it independently if on the server where it is in ``dirac.cfg``",
            "``client_id`` and ``client_secret`` of the Identity Provider client are registered.",
            "",
            "Otherwise, the client makes an RPC call to the **TornadoManager** service.",
            "It in turn checks the cache and if the ``access token`` is already invalid tries to update it using a ``refresh token``.",
            "If the required token is not in the cache, then the ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
            "is taken and the **exchange token** request to Identity Provider is made. The received tokens are cached.",
            "\"\"\"",
            "",
            "import pprint",
            "",
            "from DIRAC import S_ERROR, S_OK",
            "from DIRAC.ConfigurationSystem.Client.Helpers import Registry",
            "from DIRAC.Core.Security import Properties",
            "from DIRAC.Core.Tornado.Server.TornadoService import TornadoService",
            "from DIRAC.Core.Utilities import ThreadSafe",
            "from DIRAC.Core.Utilities.DictCache import DictCache",
            "from DIRAC.FrameworkSystem.DB.TokenDB import TokenDB",
            "from DIRAC.FrameworkSystem.Utilities.TokenManagementUtilities import (",
            "    DEFAULT_AT_EXPIRATION_TIME,",
            "    DEFAULT_RT_EXPIRATION_TIME,",
            "    getCachedKey,",
            "    getCachedToken,",
            "    getIdProviderClient,",
            ")",
            "from DIRAC.Resources.IdProvider.IdProviderFactory import IdProviderFactory",
            "",
            "# Used to synchronize the cache with user tokens",
            "gTokensSync = ThreadSafe.Synchronizer()",
            "",
            "",
            "class TornadoTokenManagerHandler(TornadoService):",
            "    DEFAULT_AUTHORIZATION = [\"authenticated\"]",
            "",
            "    @classmethod",
            "    def initializeHandler(cls, *args):",
            "        \"\"\"Initialization",
            "",
            "        :return: S_OK()/S_ERROR()",
            "        \"\"\"",
            "        # Cache containing tokens from scope requested by the client",
            "        cls.__tokensCache = DictCache()",
            "",
            "        # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.",
            "        # This allows you to manage tokens without the involvement of their owners.",
            "        cls.idps = IdProviderFactory()",
            "",
            "        # Let's try to connect to the database",
            "        try:",
            "            cls.__tokenDB = TokenDB(parentLogger=cls.log)",
            "        except Exception as e:",
            "            cls.log.exception(e)",
            "            return S_ERROR(f\"Could not connect to the database {repr(e)}\")",
            "",
            "        return S_OK()",
            "",
            "    def export_getUserTokensInfo(self):",
            "        \"\"\"Generate information dict about user tokens",
            "",
            "        :return: dict",
            "        \"\"\"",
            "        tokensInfo = []",
            "        credDict = self.getRemoteCredentials()",
            "        result = Registry.getDNForUsername(credDict[\"username\"])",
            "        if not result[\"OK\"]:",
            "            return result",
            "        for dn in result[\"Value\"]:",
            "            result = Registry.getIDFromDN(dn)",
            "            if result[\"OK\"]:",
            "                result = self.__tokenDB.getTokensByUserID(result[\"Value\"])",
            "                if not result[\"OK\"]:",
            "                    return result",
            "                tokensInfo += result[\"Value\"]",
            "        return S_OK(tokensInfo)",
            "",
            "    auth_getUsersTokensInfo = [Properties.PROXY_MANAGEMENT]",
            "",
            "    def export_getUsersTokensInfo(self, users: list):",
            "        \"\"\"Get the info about the user tokens in the database",
            "",
            "        :param users: user names",
            "",
            "        :return: S_OK(list) -- return list of tokens dictionaries",
            "        \"\"\"",
            "        tokensInfo = []",
            "        for user in users:",
            "            # Find the user ID among his DNs",
            "            result = Registry.getDNForUsername(user)",
            "            if not result[\"OK\"]:",
            "                return result",
            "            for dn in result[\"Value\"]:",
            "                uid = Registry.getIDFromDN(dn).get(\"Value\")",
            "                if uid:",
            "                    result = self.__tokenDB.getTokensByUserID(uid)",
            "                    if not result[\"OK\"]:",
            "                        self.log.error(result[\"Message\"])",
            "                    else:",
            "                        for tokenDict in result[\"Value\"]:",
            "                            if tokenDict not in tokensInfo:",
            "                                # The database does not contain a username,",
            "                                # as it is a unique user ID exclusively for DIRAC",
            "                                # and is not associated with a token.",
            "                                tokenDict[\"username\"] = user",
            "                                tokensInfo.append(tokenDict)",
            "        return S_OK(tokensInfo)",
            "",
            "    def export_updateToken(self, token: dict, userID: str, provider: str, rt_expired_in: int = 24 * 3600):",
            "        \"\"\"Using this method, you can transfer user tokens for storage in the TokenManager.",
            "",
            "        It is important to note that TokenManager saves only one token per user and, accordingly,",
            "        the Identity Provider from which it was issued. So when a new token is delegated,",
            "        keep in mind that the old token will be deleted.",
            "",
            "        :param token: token",
            "        :param userID: user ID",
            "        :param provider: provider name",
            "        :param rt_expired_in: refresh token expires time (in seconds)",
            "",
            "        :return: S_OK(list)/S_ERROR() -- list contain uploaded tokens info as dictionaries",
            "        \"\"\"",
            "        self.log.verbose(f\"Update {userID} user token issued by {provider}:\\n\", pprint.pformat(token))",
            "        # prepare the client instance of the appropriate IdP to revoke the old tokens",
            "        result = self.idps.getIdProvider(provider)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        idPObj = result[\"Value\"]",
            "        # overwrite old tokens with new ones",
            "        result = self.__tokenDB.updateToken(token, userID, provider, rt_expired_in)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        # revoke the old tokens",
            "        for oldToken in result[\"Value\"]:",
            "            if \"refresh_token\" in oldToken and oldToken[\"refresh_token\"] != token[\"refresh_token\"]:",
            "                self.log.verbose(\"Revoke old refresh token:\\n\", pprint.pformat(oldToken))",
            "                idPObj.revokeToken(oldToken[\"refresh_token\"])",
            "        # Let's return to the current situation with the storage of user tokens",
            "        return self.__tokenDB.getTokensByUserID(userID)",
            "",
            "    def __checkProperties(self, requestedUserDN: str, requestedUserGroup: str):",
            "        \"\"\"Check the properties and return if they can only download limited tokens if authorized",
            "",
            "        :param requestedUserDN: user DN",
            "        :param requestedUserGroup: DIRAC group",
            "",
            "        :return: S_OK(bool)/S_ERROR()",
            "        \"\"\"",
            "        credDict = self.getRemoteCredentials()",
            "        if Properties.FULL_DELEGATION in credDict[\"properties\"]:",
            "            return S_OK(False)",
            "        if Properties.LIMITED_DELEGATION in credDict[\"properties\"]:",
            "            return S_OK(True)",
            "        if Properties.PRIVATE_LIMITED_DELEGATION in credDict[\"properties\"]:",
            "            if credDict[\"DN\"] != requestedUserDN:",
            "                return S_ERROR(\"You are not allowed to download any token\")",
            "            if Properties.PRIVATE_LIMITED_DELEGATION not in Registry.getPropertiesForGroup(requestedUserGroup):",
            "                return S_ERROR(\"You can't download tokens for that group\")",
            "            return S_OK(True)",
            "        # Not authorized!",
            "        return S_ERROR(\"You can't get tokens!\")",
            "",
            "    @gTokensSync",
            "    def export_getToken(",
            "        self,",
            "        username: str = None,",
            "        userGroup: str = None,",
            "        scope: list[str] = None,",
            "        audience: str = None,",
            "        identityProvider: str = None,",
            "        requiredTimeLeft: int = 0,",
            "    ):",
            "        \"\"\"Get an access token for a user/group.",
            "",
            "        * Properties:",
            "            * FullDelegation <- permits full delegation of tokens",
            "            * LimitedDelegation <- permits downloading only limited tokens",
            "            * PrivateLimitedDelegation <- permits downloading only limited tokens for one self",
            "",
            "        :param username: user name",
            "        :param userGroup: user group",
            "        :param scope: requested scope",
            "        :param audience: requested audience",
            "        :param identityProvider: Identity Provider name",
            "        :param requiredTimeLeft: requested minimum life time",
            "",
            "        :return: S_OK(dict)/S_ERROR()",
            "        \"\"\"",
            "        # Get an IdProvider Client instance",
            "        result = getIdProviderClient(userGroup, identityProvider)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        idpObj = result[\"Value\"]",
            "",
            "        # Search for an existing token in tokensCache",
            "        cachedKey = getCachedKey(idpObj, username, userGroup, scope, audience)",
            "        result = getCachedToken(self.__tokensCache, cachedKey, requiredTimeLeft)",
            "        if result[\"OK\"]:",
            "            # A valid token has been found and is returned",
            "            return result",
            "",
            "        # A client token is requested",
            "        if not username:",
            "            result = self.__checkProperties(\"\", \"\")",
            "            if not result[\"OK\"]:",
            "                return result",
            "",
            "            # Get the client token with requested scope and audience",
            "            scope = cachedKey[1]",
            "            audience = cachedKey[2]",
            "            result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)",
            "            if not result[\"OK\"]:",
            "                return result",
            "            token = result[\"Value\"]",
            "",
            "            # Caching new token: only get an access token (no refresh token in this context)",
            "            self.__tokensCache.add(",
            "                cachedKey,",
            "                result[\"Value\"].get_claim(\"exp\", \"access_token\") or DEFAULT_AT_EXPIRATION_TIME,",
            "                token,",
            "            )",
            "            return result",
            "",
            "        # A user token is requested",
            "        err = []",
            "        # No luck so far, let's refresh the token stored in the database",
            "        result = Registry.getDNForUsername(username)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        for dn in result[\"Value\"]:",
            "            # For backward compatibility, the user ID is written as DN. So let's check if this DN contains a user ID",
            "            result = Registry.getIDFromDN(dn)",
            "            if result[\"OK\"]:",
            "                uid = result[\"Value\"]",
            "                # To do this, first find the refresh token stored in the database with the maximum scope",
            "                result = self.__tokenDB.getTokenForUserProvider(uid, idpObj.name)",
            "                if result[\"OK\"] and result[\"Value\"]:",
            "                    tokens = result[\"Value\"]",
            "                    result = self.__checkProperties(dn, userGroup)",
            "                    if result[\"OK\"]:",
            "                        # refresh token with requested scope",
            "                        result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)",
            "                        if result[\"OK\"]:",
            "                            # caching new tokens",
            "                            self.__tokensCache.add(",
            "                                cachedKey,",
            "                                result[\"Value\"].get_claim(\"exp\", \"refresh_token\") or DEFAULT_RT_EXPIRATION_TIME,",
            "                                result[\"Value\"],",
            "                            )",
            "                            return result",
            "                # Did not find any token associated with the found user ID",
            "                err.append(result.get(\"Message\", f\"No token found for {uid}\"))",
            "        # Collect all errors when trying to get a token, or if no user ID is registered",
            "        return S_ERROR(\"; \".join(err or [f\"No user ID found for {username}\"]))",
            "",
            "    def export_deleteToken(self, userDN: str):",
            "        \"\"\"Delete a token from the DB",
            "",
            "        :param userDN: user DN",
            "",
            "        :return: S_OK()/S_ERROR()",
            "        \"\"\"",
            "",
            "        # temporary ugly stuff to make it compliant with proxy management",
            "        userDN = f\"/O=DIRAC/CN={userDN}\"",
            "",
            "        # Delete it from cache",
            "        credDict = self.getRemoteCredentials()",
            "        if Properties.PROXY_MANAGEMENT not in credDict[\"properties\"]:",
            "            if userDN != credDict[\"DN\"]:",
            "                return S_ERROR(\"You aren't allowed!\")",
            "        result = Registry.getIDFromDN(userDN)",
            "        return self.__tokenDB.removeToken(user_id=result[\"Value\"]) if result[\"OK\"] else result",
            "",
            "    def export_getTokensByUserID(self, userID: str):",
            "        \"\"\"Retrieve a token from the DB",
            "",
            "        :param userID: user's token id",
            "",
            "        :return: S_OK(list)/S_ERROR() token row in dict format",
            "        \"\"\"",
            "        return self.__tokenDB.getTokensByUserID(userID)"
        ],
        "afterPatchFile": [
            "\"\"\"TokenManager service is a HTTPs-exposed service responsible for token management, namely storing, updating,",
            "requesting new tokens for DIRAC components that have the appropriate permissions.",
            "",
            ".. note:: As a newly created service, it will not support the old DIPS protocol, which is living to its age.",
            "",
            ".. literalinclude:: ../ConfigTemplate.cfg",
            "    :start-after: ##BEGIN TornadoTokenManager:",
            "    :end-before: ##END",
            "    :dedent: 2",
            "    :caption: TornadoTokenManager options",
            "",
            "The most common use of this service is to obtain tokens with certain scope to return to the user for its purposes,",
            "or to provide to the DIRAC service to perform asynchronous tasks on behalf of the user.",
            "This is mainly about the :py:meth:`export_getToken` method.",
            "",
            ".. image:: /_static/Systems/FS/TokenManager_getToken.png",
            "    :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)",
            "",
            "The client has a mechanism for caching the received tokens.",
            "This helps reduce the number of requests to both the service and the Identity Provider (IdP).",
            "",
            "If the client has a valid **access token** in the cache, it is used until it expires.",
            "After that you need to update. The client can update it independently if on the server where it is in ``dirac.cfg``",
            "``client_id`` and ``client_secret`` of the Identity Provider client are registered.",
            "",
            "Otherwise, the client makes an RPC call to the **TornadoManager** service.",
            "The ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
            "is taken and the **exchange token** request to Identity Provider is made.",
            "\"\"\"",
            "",
            "import pprint",
            "",
            "from DIRAC import S_ERROR, S_OK",
            "from DIRAC.ConfigurationSystem.Client.Helpers import Registry",
            "from DIRAC.Core.Security import Properties",
            "from DIRAC.Core.Tornado.Server.TornadoService import TornadoService",
            "from DIRAC.Core.Utilities import ThreadSafe",
            "from DIRAC.Core.Utilities.DictCache import DictCache",
            "from DIRAC.FrameworkSystem.DB.TokenDB import TokenDB",
            "from DIRAC.FrameworkSystem.Utilities.TokenManagementUtilities import (",
            "    DEFAULT_AT_EXPIRATION_TIME,",
            "    DEFAULT_RT_EXPIRATION_TIME,",
            "    getCachedKey,",
            "    getCachedToken,",
            "    getIdProviderClient,",
            ")",
            "from DIRAC.Resources.IdProvider.IdProviderFactory import IdProviderFactory",
            "",
            "",
            "class TornadoTokenManagerHandler(TornadoService):",
            "    DEFAULT_AUTHORIZATION = [\"authenticated\"]",
            "",
            "    @classmethod",
            "    def initializeHandler(cls, *args):",
            "        \"\"\"Initialization",
            "",
            "        :return: S_OK()/S_ERROR()",
            "        \"\"\"",
            "",
            "        # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.",
            "        # This allows you to manage tokens without the involvement of their owners.",
            "        cls.idps = IdProviderFactory()",
            "",
            "        # Let's try to connect to the database",
            "        try:",
            "            cls.__tokenDB = TokenDB(parentLogger=cls.log)",
            "        except Exception as e:",
            "            cls.log.exception(e)",
            "            return S_ERROR(f\"Could not connect to the database {repr(e)}\")",
            "",
            "        return S_OK()",
            "",
            "    def export_getUserTokensInfo(self):",
            "        \"\"\"Generate information dict about user tokens",
            "",
            "        :return: dict",
            "        \"\"\"",
            "        tokensInfo = []",
            "        credDict = self.getRemoteCredentials()",
            "        result = Registry.getDNForUsername(credDict[\"username\"])",
            "        if not result[\"OK\"]:",
            "            return result",
            "        for dn in result[\"Value\"]:",
            "            result = Registry.getIDFromDN(dn)",
            "            if result[\"OK\"]:",
            "                result = self.__tokenDB.getTokensByUserID(result[\"Value\"])",
            "                if not result[\"OK\"]:",
            "                    return result",
            "                tokensInfo += result[\"Value\"]",
            "        return S_OK(tokensInfo)",
            "",
            "    auth_getUsersTokensInfo = [Properties.PROXY_MANAGEMENT]",
            "",
            "    def export_getUsersTokensInfo(self, users: list):",
            "        \"\"\"Get the info about the user tokens in the database",
            "",
            "        :param users: user names",
            "",
            "        :return: S_OK(list) -- return list of tokens dictionaries",
            "        \"\"\"",
            "        tokensInfo = []",
            "        for user in users:",
            "            # Find the user ID among his DNs",
            "            result = Registry.getDNForUsername(user)",
            "            if not result[\"OK\"]:",
            "                return result",
            "            for dn in result[\"Value\"]:",
            "                uid = Registry.getIDFromDN(dn).get(\"Value\")",
            "                if uid:",
            "                    result = self.__tokenDB.getTokensByUserID(uid)",
            "                    if not result[\"OK\"]:",
            "                        self.log.error(result[\"Message\"])",
            "                    else:",
            "                        for tokenDict in result[\"Value\"]:",
            "                            if tokenDict not in tokensInfo:",
            "                                # The database does not contain a username,",
            "                                # as it is a unique user ID exclusively for DIRAC",
            "                                # and is not associated with a token.",
            "                                tokenDict[\"username\"] = user",
            "                                tokensInfo.append(tokenDict)",
            "        return S_OK(tokensInfo)",
            "",
            "    def export_updateToken(self, token: dict, userID: str, provider: str, rt_expired_in: int = 24 * 3600):",
            "        \"\"\"Using this method, you can transfer user tokens for storage in the TokenManager.",
            "",
            "        It is important to note that TokenManager saves only one token per user and, accordingly,",
            "        the Identity Provider from which it was issued. So when a new token is delegated,",
            "        keep in mind that the old token will be deleted.",
            "",
            "        :param token: token",
            "        :param userID: user ID",
            "        :param provider: provider name",
            "        :param rt_expired_in: refresh token expires time (in seconds)",
            "",
            "        :return: S_OK(list)/S_ERROR() -- list contain uploaded tokens info as dictionaries",
            "        \"\"\"",
            "        self.log.verbose(f\"Update {userID} user token issued by {provider}:\\n\", pprint.pformat(token))",
            "        # prepare the client instance of the appropriate IdP to revoke the old tokens",
            "        result = self.idps.getIdProvider(provider)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        idPObj = result[\"Value\"]",
            "        # overwrite old tokens with new ones",
            "        result = self.__tokenDB.updateToken(token, userID, provider, rt_expired_in)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        # revoke the old tokens",
            "        for oldToken in result[\"Value\"]:",
            "            if \"refresh_token\" in oldToken and oldToken[\"refresh_token\"] != token[\"refresh_token\"]:",
            "                self.log.verbose(\"Revoke old refresh token:\\n\", pprint.pformat(oldToken))",
            "                idPObj.revokeToken(oldToken[\"refresh_token\"])",
            "        # Let's return to the current situation with the storage of user tokens",
            "        return self.__tokenDB.getTokensByUserID(userID)",
            "",
            "    def __checkProperties(self, requestedUserDN: str, requestedUserGroup: str):",
            "        \"\"\"Check the properties and return if they can only download limited tokens if authorized",
            "",
            "        :param requestedUserDN: user DN",
            "        :param requestedUserGroup: DIRAC group",
            "",
            "        :return: S_OK(bool)/S_ERROR()",
            "        \"\"\"",
            "        credDict = self.getRemoteCredentials()",
            "        if Properties.FULL_DELEGATION in credDict[\"properties\"]:",
            "            return S_OK(False)",
            "        if Properties.LIMITED_DELEGATION in credDict[\"properties\"]:",
            "            return S_OK(True)",
            "        if Properties.PRIVATE_LIMITED_DELEGATION in credDict[\"properties\"]:",
            "            if credDict[\"DN\"] != requestedUserDN:",
            "                return S_ERROR(\"You are not allowed to download any token\")",
            "            if Properties.PRIVATE_LIMITED_DELEGATION not in Registry.getPropertiesForGroup(requestedUserGroup):",
            "                return S_ERROR(\"You can't download tokens for that group\")",
            "            return S_OK(True)",
            "        # Not authorized!",
            "        return S_ERROR(\"You can't get tokens!\")",
            "",
            "    def export_getToken(",
            "        self,",
            "        username: str = None,",
            "        userGroup: str = None,",
            "        scope: list[str] = None,",
            "        audience: str = None,",
            "        identityProvider: str = None,",
            "        requiredTimeLeft: int = 0,",
            "    ):",
            "        \"\"\"Get an access token for a user/group.",
            "",
            "        * Properties:",
            "            * FullDelegation <- permits full delegation of tokens",
            "            * LimitedDelegation <- permits downloading only limited tokens",
            "            * PrivateLimitedDelegation <- permits downloading only limited tokens for one self",
            "",
            "        :param username: user name",
            "        :param userGroup: user group",
            "        :param scope: requested scope",
            "        :param audience: requested audience",
            "        :param identityProvider: Identity Provider name",
            "        :param requiredTimeLeft: requested minimum life time",
            "",
            "        :return: S_OK(dict)/S_ERROR()",
            "        \"\"\"",
            "        # Get an IdProvider Client instance",
            "        result = getIdProviderClient(userGroup, identityProvider)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        idpObj = result[\"Value\"]",
            "",
            "        # getCachedKey is just used here to resolve the default scopes",
            "        _, scope, *_ = getCachedKey(idpObj, username, userGroup, scope, audience)",
            "",
            "        # A client token is requested",
            "        if not username:",
            "            result = self.__checkProperties(\"\", \"\")",
            "            if not result[\"OK\"]:",
            "                return result",
            "",
            "            # Get the client token with requested scope and audience",
            "            result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)",
            "",
            "            return result",
            "",
            "        # A user token is requested",
            "        err = []",
            "        # No luck so far, let's refresh the token stored in the database",
            "        result = Registry.getDNForUsername(username)",
            "        if not result[\"OK\"]:",
            "            return result",
            "        for dn in result[\"Value\"]:",
            "            # For backward compatibility, the user ID is written as DN. So let's check if this DN contains a user ID",
            "            result = Registry.getIDFromDN(dn)",
            "            if result[\"OK\"]:",
            "                uid = result[\"Value\"]",
            "                # To do this, first find the refresh token stored in the database with the maximum scope",
            "                result = self.__tokenDB.getTokenForUserProvider(uid, idpObj.name)",
            "                if result[\"OK\"] and result[\"Value\"]:",
            "                    tokens = result[\"Value\"]",
            "                    result = self.__checkProperties(dn, userGroup)",
            "                    if result[\"OK\"]:",
            "                        # refresh token with requested scope",
            "                        result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)",
            "                        if result[\"OK\"]:",
            "                            return result",
            "                # Did not find any token associated with the found user ID",
            "                err.append(result.get(\"Message\", f\"No token found for {uid}\"))",
            "        # Collect all errors when trying to get a token, or if no user ID is registered",
            "        return S_ERROR(\"; \".join(err or [f\"No user ID found for {username}\"]))",
            "",
            "    def export_deleteToken(self, userDN: str):",
            "        \"\"\"Delete a token from the DB",
            "",
            "        :param userDN: user DN",
            "",
            "        :return: S_OK()/S_ERROR()",
            "        \"\"\"",
            "",
            "        # temporary ugly stuff to make it compliant with proxy management",
            "        userDN = f\"/O=DIRAC/CN={userDN}\"",
            "",
            "        # Delete it from cache",
            "        credDict = self.getRemoteCredentials()",
            "        if Properties.PROXY_MANAGEMENT not in credDict[\"properties\"]:",
            "            if userDN != credDict[\"DN\"]:",
            "                return S_ERROR(\"You aren't allowed!\")",
            "        result = Registry.getIDFromDN(userDN)",
            "        return self.__tokenDB.removeToken(user_id=result[\"Value\"]) if result[\"OK\"] else result",
            "",
            "    def export_getTokensByUserID(self, userID: str):",
            "        \"\"\"Retrieve a token from the DB",
            "",
            "        :param userID: user's token id",
            "",
            "        :return: S_OK(list)/S_ERROR() token row in dict format",
            "        \"\"\"",
            "        return self.__tokenDB.getTokensByUserID(userID)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "19": [],
            "27": [],
            "28": [],
            "29": [],
            "50": [],
            "51": [
                "gTokensSync"
            ],
            "52": [],
            "63": [
                "TornadoTokenManagerHandler",
                "initializeHandler"
            ],
            "64": [
                "TornadoTokenManagerHandler",
                "initializeHandler"
            ],
            "183": [
                "TornadoTokenManagerHandler"
            ],
            "215": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "216": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "217": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "218": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "219": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "220": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "229": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "230": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "232": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "233": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "234": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "235": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "236": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "237": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "238": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "239": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "240": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "241": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "264": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "265": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "266": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "267": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "268": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ],
            "269": [
                "TornadoTokenManagerHandler",
                "export_getToken"
            ]
        },
        "addLocation": []
    }
}