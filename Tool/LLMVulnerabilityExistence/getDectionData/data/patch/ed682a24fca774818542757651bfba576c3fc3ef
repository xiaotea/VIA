{
    "django/contrib/postgres/fields/hstore.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     def as_sql(self, compiler, connection):"
            },
            "2": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         lhs, params = compiler.compile(self.lhs)"
            },
            "3": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return \"(%s -> '%s')\" % (lhs, self.key_name), params"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        return '(%s -> %%s)' % lhs, [self.key_name] + params"
            },
            "5": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " class KeyTransformFactory(object):"
            }
        },
        "frontPatchFile": [
            "import json",
            "",
            "from django.contrib.postgres import forms, lookups",
            "from django.contrib.postgres.fields.array import ArrayField",
            "from django.core import exceptions",
            "from django.db.models import Field, TextField, Transform",
            "from django.utils import six",
            "from django.utils.encoding import force_text",
            "from django.utils.translation import ugettext_lazy as _",
            "",
            "__all__ = ['HStoreField']",
            "",
            "",
            "class HStoreField(Field):",
            "    empty_strings_allowed = False",
            "    description = _('Map of strings to strings/nulls')",
            "    default_error_messages = {",
            "        'not_a_string': _('The value of \"%(key)s\" is not a string or null.'),",
            "    }",
            "",
            "    def db_type(self, connection):",
            "        return 'hstore'",
            "",
            "    def get_transform(self, name):",
            "        transform = super(HStoreField, self).get_transform(name)",
            "        if transform:",
            "            return transform",
            "        return KeyTransformFactory(name)",
            "",
            "    def validate(self, value, model_instance):",
            "        super(HStoreField, self).validate(value, model_instance)",
            "        for key, val in value.items():",
            "            if not isinstance(val, six.string_types) and val is not None:",
            "                raise exceptions.ValidationError(",
            "                    self.error_messages['not_a_string'],",
            "                    code='not_a_string',",
            "                    params={'key': key},",
            "                )",
            "",
            "    def to_python(self, value):",
            "        if isinstance(value, six.string_types):",
            "            value = json.loads(value)",
            "        return value",
            "",
            "    def value_to_string(self, obj):",
            "        return json.dumps(self.value_from_object(obj))",
            "",
            "    def formfield(self, **kwargs):",
            "        defaults = {",
            "            'form_class': forms.HStoreField,",
            "        }",
            "        defaults.update(kwargs)",
            "        return super(HStoreField, self).formfield(**defaults)",
            "",
            "    def get_prep_value(self, value):",
            "        value = super(HStoreField, self).get_prep_value(value)",
            "",
            "        if isinstance(value, dict):",
            "            prep_value = {}",
            "            for key, val in value.items():",
            "                key = force_text(key)",
            "                if val is not None:",
            "                    val = force_text(val)",
            "                prep_value[key] = val",
            "            value = prep_value",
            "",
            "        if isinstance(value, list):",
            "            value = [force_text(item) for item in value]",
            "",
            "        return value",
            "",
            "",
            "HStoreField.register_lookup(lookups.DataContains)",
            "HStoreField.register_lookup(lookups.ContainedBy)",
            "HStoreField.register_lookup(lookups.HasKey)",
            "HStoreField.register_lookup(lookups.HasKeys)",
            "HStoreField.register_lookup(lookups.HasAnyKeys)",
            "",
            "",
            "class KeyTransform(Transform):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, key_name, *args, **kwargs):",
            "        super(KeyTransform, self).__init__(*args, **kwargs)",
            "        self.key_name = key_name",
            "",
            "    def as_sql(self, compiler, connection):",
            "        lhs, params = compiler.compile(self.lhs)",
            "        return \"(%s -> '%s')\" % (lhs, self.key_name), params",
            "",
            "",
            "class KeyTransformFactory(object):",
            "",
            "    def __init__(self, key_name):",
            "        self.key_name = key_name",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        return KeyTransform(self.key_name, *args, **kwargs)",
            "",
            "",
            "@HStoreField.register_lookup",
            "class KeysTransform(Transform):",
            "    lookup_name = 'keys'",
            "    function = 'akeys'",
            "    output_field = ArrayField(TextField())",
            "",
            "",
            "@HStoreField.register_lookup",
            "class ValuesTransform(Transform):",
            "    lookup_name = 'values'",
            "    function = 'avals'",
            "    output_field = ArrayField(TextField())"
        ],
        "afterPatchFile": [
            "import json",
            "",
            "from django.contrib.postgres import forms, lookups",
            "from django.contrib.postgres.fields.array import ArrayField",
            "from django.core import exceptions",
            "from django.db.models import Field, TextField, Transform",
            "from django.utils import six",
            "from django.utils.encoding import force_text",
            "from django.utils.translation import ugettext_lazy as _",
            "",
            "__all__ = ['HStoreField']",
            "",
            "",
            "class HStoreField(Field):",
            "    empty_strings_allowed = False",
            "    description = _('Map of strings to strings/nulls')",
            "    default_error_messages = {",
            "        'not_a_string': _('The value of \"%(key)s\" is not a string or null.'),",
            "    }",
            "",
            "    def db_type(self, connection):",
            "        return 'hstore'",
            "",
            "    def get_transform(self, name):",
            "        transform = super(HStoreField, self).get_transform(name)",
            "        if transform:",
            "            return transform",
            "        return KeyTransformFactory(name)",
            "",
            "    def validate(self, value, model_instance):",
            "        super(HStoreField, self).validate(value, model_instance)",
            "        for key, val in value.items():",
            "            if not isinstance(val, six.string_types) and val is not None:",
            "                raise exceptions.ValidationError(",
            "                    self.error_messages['not_a_string'],",
            "                    code='not_a_string',",
            "                    params={'key': key},",
            "                )",
            "",
            "    def to_python(self, value):",
            "        if isinstance(value, six.string_types):",
            "            value = json.loads(value)",
            "        return value",
            "",
            "    def value_to_string(self, obj):",
            "        return json.dumps(self.value_from_object(obj))",
            "",
            "    def formfield(self, **kwargs):",
            "        defaults = {",
            "            'form_class': forms.HStoreField,",
            "        }",
            "        defaults.update(kwargs)",
            "        return super(HStoreField, self).formfield(**defaults)",
            "",
            "    def get_prep_value(self, value):",
            "        value = super(HStoreField, self).get_prep_value(value)",
            "",
            "        if isinstance(value, dict):",
            "            prep_value = {}",
            "            for key, val in value.items():",
            "                key = force_text(key)",
            "                if val is not None:",
            "                    val = force_text(val)",
            "                prep_value[key] = val",
            "            value = prep_value",
            "",
            "        if isinstance(value, list):",
            "            value = [force_text(item) for item in value]",
            "",
            "        return value",
            "",
            "",
            "HStoreField.register_lookup(lookups.DataContains)",
            "HStoreField.register_lookup(lookups.ContainedBy)",
            "HStoreField.register_lookup(lookups.HasKey)",
            "HStoreField.register_lookup(lookups.HasKeys)",
            "HStoreField.register_lookup(lookups.HasAnyKeys)",
            "",
            "",
            "class KeyTransform(Transform):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, key_name, *args, **kwargs):",
            "        super(KeyTransform, self).__init__(*args, **kwargs)",
            "        self.key_name = key_name",
            "",
            "    def as_sql(self, compiler, connection):",
            "        lhs, params = compiler.compile(self.lhs)",
            "        return '(%s -> %%s)' % lhs, [self.key_name] + params",
            "",
            "",
            "class KeyTransformFactory(object):",
            "",
            "    def __init__(self, key_name):",
            "        self.key_name = key_name",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        return KeyTransform(self.key_name, *args, **kwargs)",
            "",
            "",
            "@HStoreField.register_lookup",
            "class KeysTransform(Transform):",
            "    lookup_name = 'keys'",
            "    function = 'akeys'",
            "    output_field = ArrayField(TextField())",
            "",
            "",
            "@HStoreField.register_lookup",
            "class ValuesTransform(Transform):",
            "    lookup_name = 'values'",
            "    function = 'avals'",
            "    output_field = ArrayField(TextField())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "89": [
                "KeyTransform",
                "as_sql"
            ]
        },
        "addLocation": []
    },
    "django/contrib/postgres/fields/jsonb.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         if len(key_transforms) > 1:"
            },
            "1": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "             return \"(%s %s %%s)\" % (lhs, self.nested_operator), [key_transforms] + params"
            },
            "2": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         try:"
            },
            "3": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            int(self.key_name)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            lookup = int(self.key_name)"
            },
            "5": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         except ValueError:"
            },
            "6": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            lookup = \"'%s'\" % self.key_name"
            },
            "7": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "8": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            lookup = \"%s\" % self.key_name"
            },
            "9": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return \"(%s %s %s)\" % (lhs, self.operator, lookup), params"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            lookup = self.key_name"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        return '(%s %s %%s)' % (lhs, self.operator), [lookup] + params"
            },
            "12": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " class KeyTextTransform(KeyTransform):"
            }
        },
        "frontPatchFile": [
            "import json",
            "",
            "from psycopg2.extras import Json",
            "",
            "from django.contrib.postgres import forms, lookups",
            "from django.core import exceptions",
            "from django.db.models import (",
            "    Field, TextField, Transform, lookups as builtin_lookups,",
            ")",
            "from django.utils.translation import ugettext_lazy as _",
            "",
            "__all__ = ['JSONField']",
            "",
            "",
            "class JsonAdapter(Json):",
            "    \"\"\"",
            "    Customized psycopg2.extras.Json to allow for a custom encoder.",
            "    \"\"\"",
            "    def __init__(self, adapted, dumps=None, encoder=None):",
            "        self.encoder = encoder",
            "        super(JsonAdapter, self).__init__(adapted, dumps=dumps)",
            "",
            "    def dumps(self, obj):",
            "        options = {'cls': self.encoder} if self.encoder else {}",
            "        return json.dumps(obj, **options)",
            "",
            "",
            "class JSONField(Field):",
            "    empty_strings_allowed = False",
            "    description = _('A JSON object')",
            "    default_error_messages = {",
            "        'invalid': _(\"Value must be valid JSON.\"),",
            "    }",
            "",
            "    def __init__(self, verbose_name=None, name=None, encoder=None, **kwargs):",
            "        if encoder and not callable(encoder):",
            "            raise ValueError(\"The encoder parameter must be a callable object.\")",
            "        self.encoder = encoder",
            "        super(JSONField, self).__init__(verbose_name, name, **kwargs)",
            "",
            "    def db_type(self, connection):",
            "        return 'jsonb'",
            "",
            "    def deconstruct(self):",
            "        name, path, args, kwargs = super(JSONField, self).deconstruct()",
            "        if self.encoder is not None:",
            "            kwargs['encoder'] = self.encoder",
            "        return name, path, args, kwargs",
            "",
            "    def get_transform(self, name):",
            "        transform = super(JSONField, self).get_transform(name)",
            "        if transform:",
            "            return transform",
            "        return KeyTransformFactory(name)",
            "",
            "    def get_prep_value(self, value):",
            "        if value is not None:",
            "            return JsonAdapter(value, encoder=self.encoder)",
            "        return value",
            "",
            "    def validate(self, value, model_instance):",
            "        super(JSONField, self).validate(value, model_instance)",
            "        options = {'cls': self.encoder} if self.encoder else {}",
            "        try:",
            "            json.dumps(value, **options)",
            "        except TypeError:",
            "            raise exceptions.ValidationError(",
            "                self.error_messages['invalid'],",
            "                code='invalid',",
            "                params={'value': value},",
            "            )",
            "",
            "    def value_to_string(self, obj):",
            "        return self.value_from_object(obj)",
            "",
            "    def formfield(self, **kwargs):",
            "        defaults = {'form_class': forms.JSONField}",
            "        defaults.update(kwargs)",
            "        return super(JSONField, self).formfield(**defaults)",
            "",
            "",
            "JSONField.register_lookup(lookups.DataContains)",
            "JSONField.register_lookup(lookups.ContainedBy)",
            "JSONField.register_lookup(lookups.HasKey)",
            "JSONField.register_lookup(lookups.HasKeys)",
            "JSONField.register_lookup(lookups.HasAnyKeys)",
            "",
            "",
            "class KeyTransform(Transform):",
            "    operator = '->'",
            "    nested_operator = '#>'",
            "",
            "    def __init__(self, key_name, *args, **kwargs):",
            "        super(KeyTransform, self).__init__(*args, **kwargs)",
            "        self.key_name = key_name",
            "",
            "    def as_sql(self, compiler, connection):",
            "        key_transforms = [self.key_name]",
            "        previous = self.lhs",
            "        while isinstance(previous, KeyTransform):",
            "            key_transforms.insert(0, previous.key_name)",
            "            previous = previous.lhs",
            "        lhs, params = compiler.compile(previous)",
            "        if len(key_transforms) > 1:",
            "            return \"(%s %s %%s)\" % (lhs, self.nested_operator), [key_transforms] + params",
            "        try:",
            "            int(self.key_name)",
            "        except ValueError:",
            "            lookup = \"'%s'\" % self.key_name",
            "        else:",
            "            lookup = \"%s\" % self.key_name",
            "        return \"(%s %s %s)\" % (lhs, self.operator, lookup), params",
            "",
            "",
            "class KeyTextTransform(KeyTransform):",
            "    operator = '->>'",
            "    nested_operator = '#>>'",
            "    _output_field = TextField()",
            "",
            "",
            "class KeyTransformTextLookupMixin(object):",
            "    \"\"\"",
            "    Mixin for combining with a lookup expecting a text lhs from a JSONField",
            "    key lookup. Make use of the ->> operator instead of casting key values to",
            "    text and performing the lookup on the resulting representation.",
            "    \"\"\"",
            "    def __init__(self, key_transform, *args, **kwargs):",
            "        assert isinstance(key_transform, KeyTransform)",
            "        key_text_transform = KeyTextTransform(",
            "            key_transform.key_name, *key_transform.source_expressions, **key_transform.extra",
            "        )",
            "        super(KeyTransformTextLookupMixin, self).__init__(key_text_transform, *args, **kwargs)",
            "",
            "",
            "class KeyTransformIExact(KeyTransformTextLookupMixin, builtin_lookups.IExact):",
            "    pass",
            "",
            "",
            "class KeyTransformIContains(KeyTransformTextLookupMixin, builtin_lookups.IContains):",
            "    pass",
            "",
            "",
            "class KeyTransformStartsWith(KeyTransformTextLookupMixin, builtin_lookups.StartsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformIStartsWith(KeyTransformTextLookupMixin, builtin_lookups.IStartsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformEndsWith(KeyTransformTextLookupMixin, builtin_lookups.EndsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformIEndsWith(KeyTransformTextLookupMixin, builtin_lookups.IEndsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformRegex(KeyTransformTextLookupMixin, builtin_lookups.Regex):",
            "    pass",
            "",
            "",
            "class KeyTransformIRegex(KeyTransformTextLookupMixin, builtin_lookups.IRegex):",
            "    pass",
            "",
            "",
            "KeyTransform.register_lookup(KeyTransformIExact)",
            "KeyTransform.register_lookup(KeyTransformIContains)",
            "KeyTransform.register_lookup(KeyTransformStartsWith)",
            "KeyTransform.register_lookup(KeyTransformIStartsWith)",
            "KeyTransform.register_lookup(KeyTransformEndsWith)",
            "KeyTransform.register_lookup(KeyTransformIEndsWith)",
            "KeyTransform.register_lookup(KeyTransformRegex)",
            "KeyTransform.register_lookup(KeyTransformIRegex)",
            "",
            "",
            "class KeyTransformFactory(object):",
            "",
            "    def __init__(self, key_name):",
            "        self.key_name = key_name",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        return KeyTransform(self.key_name, *args, **kwargs)"
        ],
        "afterPatchFile": [
            "import json",
            "",
            "from psycopg2.extras import Json",
            "",
            "from django.contrib.postgres import forms, lookups",
            "from django.core import exceptions",
            "from django.db.models import (",
            "    Field, TextField, Transform, lookups as builtin_lookups,",
            ")",
            "from django.utils.translation import ugettext_lazy as _",
            "",
            "__all__ = ['JSONField']",
            "",
            "",
            "class JsonAdapter(Json):",
            "    \"\"\"",
            "    Customized psycopg2.extras.Json to allow for a custom encoder.",
            "    \"\"\"",
            "    def __init__(self, adapted, dumps=None, encoder=None):",
            "        self.encoder = encoder",
            "        super(JsonAdapter, self).__init__(adapted, dumps=dumps)",
            "",
            "    def dumps(self, obj):",
            "        options = {'cls': self.encoder} if self.encoder else {}",
            "        return json.dumps(obj, **options)",
            "",
            "",
            "class JSONField(Field):",
            "    empty_strings_allowed = False",
            "    description = _('A JSON object')",
            "    default_error_messages = {",
            "        'invalid': _(\"Value must be valid JSON.\"),",
            "    }",
            "",
            "    def __init__(self, verbose_name=None, name=None, encoder=None, **kwargs):",
            "        if encoder and not callable(encoder):",
            "            raise ValueError(\"The encoder parameter must be a callable object.\")",
            "        self.encoder = encoder",
            "        super(JSONField, self).__init__(verbose_name, name, **kwargs)",
            "",
            "    def db_type(self, connection):",
            "        return 'jsonb'",
            "",
            "    def deconstruct(self):",
            "        name, path, args, kwargs = super(JSONField, self).deconstruct()",
            "        if self.encoder is not None:",
            "            kwargs['encoder'] = self.encoder",
            "        return name, path, args, kwargs",
            "",
            "    def get_transform(self, name):",
            "        transform = super(JSONField, self).get_transform(name)",
            "        if transform:",
            "            return transform",
            "        return KeyTransformFactory(name)",
            "",
            "    def get_prep_value(self, value):",
            "        if value is not None:",
            "            return JsonAdapter(value, encoder=self.encoder)",
            "        return value",
            "",
            "    def validate(self, value, model_instance):",
            "        super(JSONField, self).validate(value, model_instance)",
            "        options = {'cls': self.encoder} if self.encoder else {}",
            "        try:",
            "            json.dumps(value, **options)",
            "        except TypeError:",
            "            raise exceptions.ValidationError(",
            "                self.error_messages['invalid'],",
            "                code='invalid',",
            "                params={'value': value},",
            "            )",
            "",
            "    def value_to_string(self, obj):",
            "        return self.value_from_object(obj)",
            "",
            "    def formfield(self, **kwargs):",
            "        defaults = {'form_class': forms.JSONField}",
            "        defaults.update(kwargs)",
            "        return super(JSONField, self).formfield(**defaults)",
            "",
            "",
            "JSONField.register_lookup(lookups.DataContains)",
            "JSONField.register_lookup(lookups.ContainedBy)",
            "JSONField.register_lookup(lookups.HasKey)",
            "JSONField.register_lookup(lookups.HasKeys)",
            "JSONField.register_lookup(lookups.HasAnyKeys)",
            "",
            "",
            "class KeyTransform(Transform):",
            "    operator = '->'",
            "    nested_operator = '#>'",
            "",
            "    def __init__(self, key_name, *args, **kwargs):",
            "        super(KeyTransform, self).__init__(*args, **kwargs)",
            "        self.key_name = key_name",
            "",
            "    def as_sql(self, compiler, connection):",
            "        key_transforms = [self.key_name]",
            "        previous = self.lhs",
            "        while isinstance(previous, KeyTransform):",
            "            key_transforms.insert(0, previous.key_name)",
            "            previous = previous.lhs",
            "        lhs, params = compiler.compile(previous)",
            "        if len(key_transforms) > 1:",
            "            return \"(%s %s %%s)\" % (lhs, self.nested_operator), [key_transforms] + params",
            "        try:",
            "            lookup = int(self.key_name)",
            "        except ValueError:",
            "            lookup = self.key_name",
            "        return '(%s %s %%s)' % (lhs, self.operator), [lookup] + params",
            "",
            "",
            "class KeyTextTransform(KeyTransform):",
            "    operator = '->>'",
            "    nested_operator = '#>>'",
            "    _output_field = TextField()",
            "",
            "",
            "class KeyTransformTextLookupMixin(object):",
            "    \"\"\"",
            "    Mixin for combining with a lookup expecting a text lhs from a JSONField",
            "    key lookup. Make use of the ->> operator instead of casting key values to",
            "    text and performing the lookup on the resulting representation.",
            "    \"\"\"",
            "    def __init__(self, key_transform, *args, **kwargs):",
            "        assert isinstance(key_transform, KeyTransform)",
            "        key_text_transform = KeyTextTransform(",
            "            key_transform.key_name, *key_transform.source_expressions, **key_transform.extra",
            "        )",
            "        super(KeyTransformTextLookupMixin, self).__init__(key_text_transform, *args, **kwargs)",
            "",
            "",
            "class KeyTransformIExact(KeyTransformTextLookupMixin, builtin_lookups.IExact):",
            "    pass",
            "",
            "",
            "class KeyTransformIContains(KeyTransformTextLookupMixin, builtin_lookups.IContains):",
            "    pass",
            "",
            "",
            "class KeyTransformStartsWith(KeyTransformTextLookupMixin, builtin_lookups.StartsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformIStartsWith(KeyTransformTextLookupMixin, builtin_lookups.IStartsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformEndsWith(KeyTransformTextLookupMixin, builtin_lookups.EndsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformIEndsWith(KeyTransformTextLookupMixin, builtin_lookups.IEndsWith):",
            "    pass",
            "",
            "",
            "class KeyTransformRegex(KeyTransformTextLookupMixin, builtin_lookups.Regex):",
            "    pass",
            "",
            "",
            "class KeyTransformIRegex(KeyTransformTextLookupMixin, builtin_lookups.IRegex):",
            "    pass",
            "",
            "",
            "KeyTransform.register_lookup(KeyTransformIExact)",
            "KeyTransform.register_lookup(KeyTransformIContains)",
            "KeyTransform.register_lookup(KeyTransformStartsWith)",
            "KeyTransform.register_lookup(KeyTransformIStartsWith)",
            "KeyTransform.register_lookup(KeyTransformEndsWith)",
            "KeyTransform.register_lookup(KeyTransformIEndsWith)",
            "KeyTransform.register_lookup(KeyTransformRegex)",
            "KeyTransform.register_lookup(KeyTransformIRegex)",
            "",
            "",
            "class KeyTransformFactory(object):",
            "",
            "    def __init__(self, key_name):",
            "        self.key_name = key_name",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        return KeyTransform(self.key_name, *args, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "107": [
                "KeyTransform",
                "as_sql"
            ],
            "109": [
                "KeyTransform",
                "as_sql"
            ],
            "110": [
                "KeyTransform",
                "as_sql"
            ],
            "111": [
                "KeyTransform",
                "as_sql"
            ],
            "112": [
                "KeyTransform",
                "as_sql"
            ]
        },
        "addLocation": []
    }
}