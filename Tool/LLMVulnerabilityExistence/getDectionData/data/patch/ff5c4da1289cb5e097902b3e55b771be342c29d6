{
    "synapse/http/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 720,
                "afterPatchRowNumber": 720,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 721,
                "afterPatchRowNumber": 721,
                "PatchRowcode": "         try:"
            },
            "2": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": 722,
                "PatchRowcode": "             length = await make_deferred_yieldable("
            },
            "3": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                readBodyToFile(response, output_stream, max_size)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 723,
                "PatchRowcode": "+                read_body_with_max_size(response, output_stream, max_size)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 724,
                "PatchRowcode": "+            )"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 725,
                "PatchRowcode": "+        except BodyExceededMaxSize:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 726,
                "PatchRowcode": "+            SynapseError("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 727,
                "PatchRowcode": "+                502,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 728,
                "PatchRowcode": "+                \"Requested file is too large > %r bytes\" % (max_size,),"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 729,
                "PatchRowcode": "+                Codes.TOO_LARGE,"
            },
            "11": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": 730,
                "PatchRowcode": "             )"
            },
            "12": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except SynapseError:"
            },
            "13": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # This can happen e.g. because the body is too large."
            },
            "14": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise"
            },
            "15": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 731,
                "PatchRowcode": "         except Exception as e:"
            },
            "16": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": 732,
                "PatchRowcode": "             raise SynapseError(502, (\"Failed to download remote body: %s\" % e)) from e"
            },
            "17": {
                "beforePatchRowNumber": 730,
                "afterPatchRowNumber": 733,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 748,
                "afterPatchRowNumber": 751,
                "PatchRowcode": "     return f"
            },
            "19": {
                "beforePatchRowNumber": 749,
                "afterPatchRowNumber": 752,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 750,
                "afterPatchRowNumber": 753,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 751,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class _ReadBodyToFileProtocol(protocol.Protocol):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 754,
                "PatchRowcode": "+class BodyExceededMaxSize(Exception):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 755,
                "PatchRowcode": "+    \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 756,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 757,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 758,
                "PatchRowcode": "+class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):"
            },
            "27": {
                "beforePatchRowNumber": 752,
                "afterPatchRowNumber": 759,
                "PatchRowcode": "     def __init__("
            },
            "28": {
                "beforePatchRowNumber": 753,
                "afterPatchRowNumber": 760,
                "PatchRowcode": "         self, stream: BinaryIO, deferred: defer.Deferred, max_size: Optional[int]"
            },
            "29": {
                "beforePatchRowNumber": 754,
                "afterPatchRowNumber": 761,
                "PatchRowcode": "     ):"
            },
            "30": {
                "beforePatchRowNumber": 761,
                "afterPatchRowNumber": 768,
                "PatchRowcode": "         self.stream.write(data)"
            },
            "31": {
                "beforePatchRowNumber": 762,
                "afterPatchRowNumber": 769,
                "PatchRowcode": "         self.length += len(data)"
            },
            "32": {
                "beforePatchRowNumber": 763,
                "afterPatchRowNumber": 770,
                "PatchRowcode": "         if self.max_size is not None and self.length >= self.max_size:"
            },
            "33": {
                "beforePatchRowNumber": 764,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.deferred.errback("
            },
            "34": {
                "beforePatchRowNumber": 765,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                SynapseError("
            },
            "35": {
                "beforePatchRowNumber": 766,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    502,"
            },
            "36": {
                "beforePatchRowNumber": 767,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"Requested file is too large > %r bytes\" % (self.max_size,),"
            },
            "37": {
                "beforePatchRowNumber": 768,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    Codes.TOO_LARGE,"
            },
            "38": {
                "beforePatchRowNumber": 769,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "39": {
                "beforePatchRowNumber": 770,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 771,
                "PatchRowcode": "+            self.deferred.errback(BodyExceededMaxSize())"
            },
            "41": {
                "beforePatchRowNumber": 771,
                "afterPatchRowNumber": 772,
                "PatchRowcode": "             self.deferred = defer.Deferred()"
            },
            "42": {
                "beforePatchRowNumber": 772,
                "afterPatchRowNumber": 773,
                "PatchRowcode": "             self.transport.loseConnection()"
            },
            "43": {
                "beforePatchRowNumber": 773,
                "afterPatchRowNumber": 774,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 782,
                "afterPatchRowNumber": 783,
                "PatchRowcode": "             self.deferred.errback(reason)"
            },
            "45": {
                "beforePatchRowNumber": 783,
                "afterPatchRowNumber": 784,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 784,
                "afterPatchRowNumber": 785,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 785,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def readBodyToFile("
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 786,
                "PatchRowcode": "+def read_body_with_max_size("
            },
            "49": {
                "beforePatchRowNumber": 786,
                "afterPatchRowNumber": 787,
                "PatchRowcode": "     response: IResponse, stream: BinaryIO, max_size: Optional[int]"
            },
            "50": {
                "beforePatchRowNumber": 787,
                "afterPatchRowNumber": 788,
                "PatchRowcode": " ) -> defer.Deferred:"
            },
            "51": {
                "beforePatchRowNumber": 788,
                "afterPatchRowNumber": 789,
                "PatchRowcode": "     \"\"\""
            },
            "52": {
                "beforePatchRowNumber": 789,
                "afterPatchRowNumber": 790,
                "PatchRowcode": "     Read a HTTP response body to a file-object. Optionally enforcing a maximum file size."
            },
            "53": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": 791,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 792,
                "PatchRowcode": "+    If the maximum file size is reached, the returned Deferred will resolve to a"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 793,
                "PatchRowcode": "+    Failure with a BodyExceededMaxSize exception."
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 794,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": 791,
                "afterPatchRowNumber": 795,
                "PatchRowcode": "     Args:"
            },
            "58": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": 796,
                "PatchRowcode": "         response: The HTTP response to read from."
            },
            "59": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": 797,
                "PatchRowcode": "         stream: The file-object to write to."
            },
            "60": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": 802,
                "PatchRowcode": "     \"\"\""
            },
            "61": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": 803,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": 804,
                "PatchRowcode": "     d = defer.Deferred()"
            },
            "63": {
                "beforePatchRowNumber": 801,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    response.deliverBody(_ReadBodyToFileProtocol(stream, d, max_size))"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 805,
                "PatchRowcode": "+    response.deliverBody(_ReadBodyWithMaxSizeProtocol(stream, d, max_size))"
            },
            "65": {
                "beforePatchRowNumber": 802,
                "afterPatchRowNumber": 806,
                "PatchRowcode": "     return d"
            },
            "66": {
                "beforePatchRowNumber": 803,
                "afterPatchRowNumber": 807,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 804,
                "afterPatchRowNumber": 808,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import urllib.parse",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    BinaryIO,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "import treq",
            "from canonicaljson import encode_canonical_json",
            "from netaddr import IPAddress, IPSet",
            "from prometheus_client import Counter",
            "from zope.interface import implementer, provider",
            "",
            "from OpenSSL import SSL",
            "from OpenSSL.SSL import VERIFY_NONE",
            "from twisted.internet import defer, error as twisted_error, protocol, ssl",
            "from twisted.internet.interfaces import (",
            "    IAddress,",
            "    IHostResolution,",
            "    IReactorPluggableNameResolver,",
            "    IResolutionReceiver,",
            ")",
            "from twisted.internet.task import Cooperator",
            "from twisted.python.failure import Failure",
            "from twisted.web._newclient import ResponseDone",
            "from twisted.web.client import (",
            "    Agent,",
            "    HTTPConnectionPool,",
            "    ResponseNeverReceived,",
            "    readBody,",
            ")",
            "from twisted.web.http import PotentialDataLoss",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IAgent, IBodyProducer, IResponse",
            "",
            "from synapse.api.errors import Codes, HttpResponseException, SynapseError",
            "from synapse.http import QuieterFileBodyProducer, RequestTimedOutError, redact_uri",
            "from synapse.http.proxyagent import ProxyAgent",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.logging.opentracing import set_tag, start_active_span, tags",
            "from synapse.util import json_decoder",
            "from synapse.util.async_helpers import timeout_deferred",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.app.homeserver import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "outgoing_requests_counter = Counter(\"synapse_http_client_requests\", \"\", [\"method\"])",
            "incoming_responses_counter = Counter(",
            "    \"synapse_http_client_responses\", \"\", [\"method\", \"code\"]",
            ")",
            "",
            "# the type of the headers list, to be passed to the t.w.h.Headers.",
            "# Actually we can mix str and bytes keys, but Mapping treats 'key' as invariant so",
            "# we simplify.",
            "RawHeaders = Union[Mapping[str, \"RawHeaderValue\"], Mapping[bytes, \"RawHeaderValue\"]]",
            "",
            "# the value actually has to be a List, but List is invariant so we can't specify that",
            "# the entries can either be Lists or bytes.",
            "RawHeaderValue = Sequence[Union[str, bytes]]",
            "",
            "# the type of the query params, to be passed into `urlencode`",
            "QueryParamValue = Union[str, bytes, Iterable[Union[str, bytes]]]",
            "QueryParams = Union[Mapping[str, QueryParamValue], Mapping[bytes, QueryParamValue]]",
            "",
            "",
            "def check_against_blacklist(",
            "    ip_address: IPAddress, ip_whitelist: Optional[IPSet], ip_blacklist: IPSet",
            ") -> bool:",
            "    \"\"\"",
            "    Compares an IP address to allowed and disallowed IP sets.",
            "",
            "    Args:",
            "        ip_address: The IP address to check",
            "        ip_whitelist: Allowed IP addresses.",
            "        ip_blacklist: Disallowed IP addresses.",
            "",
            "    Returns:",
            "        True if the IP address is in the blacklist and not in the whitelist.",
            "    \"\"\"",
            "    if ip_address in ip_blacklist:",
            "        if ip_whitelist is None or ip_address not in ip_whitelist:",
            "            return True",
            "    return False",
            "",
            "",
            "_EPSILON = 0.00000001",
            "",
            "",
            "def _make_scheduler(reactor):",
            "    \"\"\"Makes a schedular suitable for a Cooperator using the given reactor.",
            "",
            "    (This is effectively just a copy from `twisted.internet.task`)",
            "    \"\"\"",
            "",
            "    def _scheduler(x):",
            "        return reactor.callLater(_EPSILON, x)",
            "",
            "    return _scheduler",
            "",
            "",
            "class _IPBlacklistingResolver:",
            "    \"\"\"",
            "    A proxy for reactor.nameResolver which only produces non-blacklisted IP",
            "    addresses, preventing DNS rebinding attacks on URL preview.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            reactor: The twisted reactor.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._reactor = reactor",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def resolveHostName(",
            "        self, recv: IResolutionReceiver, hostname: str, portNumber: int = 0",
            "    ) -> IResolutionReceiver:",
            "",
            "        r = recv()",
            "        addresses = []  # type: List[IAddress]",
            "",
            "        def _callback() -> None:",
            "            r.resolutionBegan(None)",
            "",
            "            has_bad_ip = False",
            "            for i in addresses:",
            "                ip_address = IPAddress(i.host)",
            "",
            "                if check_against_blacklist(",
            "                    ip_address, self._ip_whitelist, self._ip_blacklist",
            "                ):",
            "                    logger.info(",
            "                        \"Dropped %s from DNS resolution to %s due to blacklist\"",
            "                        % (ip_address, hostname)",
            "                    )",
            "                    has_bad_ip = True",
            "",
            "            # if we have a blacklisted IP, we'd like to raise an error to block the",
            "            # request, but all we can really do from here is claim that there were no",
            "            # valid results.",
            "            if not has_bad_ip:",
            "                for i in addresses:",
            "                    r.addressResolved(i)",
            "            r.resolutionComplete()",
            "",
            "        @provider(IResolutionReceiver)",
            "        class EndpointReceiver:",
            "            @staticmethod",
            "            def resolutionBegan(resolutionInProgress: IHostResolution) -> None:",
            "                pass",
            "",
            "            @staticmethod",
            "            def addressResolved(address: IAddress) -> None:",
            "                addresses.append(address)",
            "",
            "            @staticmethod",
            "            def resolutionComplete() -> None:",
            "                _callback()",
            "",
            "        self._reactor.nameResolver.resolveHostName(",
            "            EndpointReceiver, hostname, portNumber=portNumber",
            "        )",
            "",
            "        return r",
            "",
            "",
            "@implementer(IReactorPluggableNameResolver)",
            "class BlacklistingReactorWrapper:",
            "    \"\"\"",
            "    A Reactor wrapper which will prevent DNS resolution to blacklisted IP",
            "    addresses, to prevent DNS rebinding.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        self._reactor = reactor",
            "",
            "        # We need to use a DNS resolver which filters out blacklisted IP",
            "        # addresses, to prevent DNS rebinding.",
            "        self._nameResolver = _IPBlacklistingResolver(",
            "            self._reactor, ip_whitelist, ip_blacklist",
            "        )",
            "",
            "    def __getattr__(self, attr: str) -> Any:",
            "        # Passthrough to the real reactor except for the DNS resolver.",
            "        if attr == \"nameResolver\":",
            "            return self._nameResolver",
            "        else:",
            "            return getattr(self._reactor, attr)",
            "",
            "",
            "class BlacklistingAgentWrapper(Agent):",
            "    \"\"\"",
            "    An Agent wrapper which will prevent access to IP addresses being accessed",
            "    directly (without an IP address lookup).",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        agent: IAgent,",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            agent: The Agent to wrap.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._agent = agent",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def request(",
            "        self,",
            "        method: bytes,",
            "        uri: bytes,",
            "        headers: Optional[Headers] = None,",
            "        bodyProducer: Optional[IBodyProducer] = None,",
            "    ) -> defer.Deferred:",
            "        h = urllib.parse.urlparse(uri.decode(\"ascii\"))",
            "",
            "        try:",
            "            ip_address = IPAddress(h.hostname)",
            "",
            "            if check_against_blacklist(",
            "                ip_address, self._ip_whitelist, self._ip_blacklist",
            "            ):",
            "                logger.info(\"Blocking access to %s due to blacklist\" % (ip_address,))",
            "                e = SynapseError(403, \"IP address blocked by IP blacklist entry\")",
            "                return defer.fail(Failure(e))",
            "        except Exception:",
            "            # Not an IP",
            "            pass",
            "",
            "        return self._agent.request(",
            "            method, uri, headers=headers, bodyProducer=bodyProducer",
            "        )",
            "",
            "",
            "class SimpleHttpClient:",
            "    \"\"\"",
            "    A simple, no-frills HTTP client with methods that wrap up common ways of",
            "    using HTTP in Matrix",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        treq_args: Dict[str, Any] = {},",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "        http_proxy: Optional[bytes] = None,",
            "        https_proxy: Optional[bytes] = None,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            hs",
            "            treq_args: Extra keyword arguments to be given to treq.request.",
            "            ip_blacklist: The IP addresses that are blacklisted that",
            "                we may not request.",
            "            ip_whitelist: The whitelisted IP addresses, that we can",
            "               request if it were otherwise caught in a blacklist.",
            "            http_proxy: proxy server to use for http connections. host[:port]",
            "            https_proxy: proxy server to use for https connections. host[:port]",
            "        \"\"\"",
            "        self.hs = hs",
            "",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "        self._extra_treq_args = treq_args",
            "",
            "        self.user_agent = hs.version_string",
            "        self.clock = hs.get_clock()",
            "        if hs.config.user_agent_suffix:",
            "            self.user_agent = \"%s %s\" % (self.user_agent, hs.config.user_agent_suffix)",
            "",
            "        # We use this for our body producers to ensure that they use the correct",
            "        # reactor.",
            "        self._cooperator = Cooperator(scheduler=_make_scheduler(hs.get_reactor()))",
            "",
            "        self.user_agent = self.user_agent.encode(\"ascii\")",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we need to use a DNS resolver which",
            "            # filters out blacklisted IP addresses, to prevent DNS rebinding.",
            "            self.reactor = BlacklistingReactorWrapper(",
            "                hs.get_reactor(), self._ip_whitelist, self._ip_blacklist",
            "            )",
            "        else:",
            "            self.reactor = hs.get_reactor()",
            "",
            "        # the pusher makes lots of concurrent SSL connections to sygnal, and",
            "        # tends to do so in batches, so we need to allow the pool to keep",
            "        # lots of idle connections around.",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        # XXX: The justification for using the cache factor here is that larger instances",
            "        # will need both more cache and more connections.",
            "        # Still, this should probably be a separate dial",
            "        pool.maxPersistentPerHost = max((100 * hs.config.caches.global_factor, 5))",
            "        pool.cachedConnectionTimeout = 2 * 60",
            "",
            "        self.agent = ProxyAgent(",
            "            self.reactor,",
            "            connectTimeout=15,",
            "            contextFactory=self.hs.get_http_client_context_factory(),",
            "            pool=pool,",
            "            http_proxy=http_proxy,",
            "            https_proxy=https_proxy,",
            "        )",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we then install the blacklisting Agent",
            "            # which prevents direct access to IP addresses, that are not caught",
            "            # by the DNS resolution.",
            "            self.agent = BlacklistingAgentWrapper(",
            "                self.agent,",
            "                ip_whitelist=self._ip_whitelist,",
            "                ip_blacklist=self._ip_blacklist,",
            "            )",
            "",
            "    async def request(",
            "        self,",
            "        method: str,",
            "        uri: str,",
            "        data: Optional[bytes] = None,",
            "        headers: Optional[Headers] = None,",
            "    ) -> IResponse:",
            "        \"\"\"",
            "        Args:",
            "            method: HTTP method to use.",
            "            uri: URI to query.",
            "            data: Data to send in the request body, if applicable.",
            "            headers: Request headers.",
            "",
            "        Returns:",
            "            Response object, once the headers have been read.",
            "",
            "        Raises:",
            "            RequestTimedOutError if the request times out before the headers are read",
            "",
            "        \"\"\"",
            "        outgoing_requests_counter.labels(method).inc()",
            "",
            "        # log request but strip `access_token` (AS requests for example include this)",
            "        logger.debug(\"Sending request %s %s\", method, redact_uri(uri))",
            "",
            "        with start_active_span(",
            "            \"outgoing-client-request\",",
            "            tags={",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_CLIENT,",
            "                tags.HTTP_METHOD: method,",
            "                tags.HTTP_URL: uri,",
            "            },",
            "            finish_on_close=True,",
            "        ):",
            "            try:",
            "                body_producer = None",
            "                if data is not None:",
            "                    body_producer = QuieterFileBodyProducer(",
            "                        BytesIO(data), cooperator=self._cooperator,",
            "                    )",
            "",
            "                request_deferred = treq.request(",
            "                    method,",
            "                    uri,",
            "                    agent=self.agent,",
            "                    data=body_producer,",
            "                    headers=headers,",
            "                    **self._extra_treq_args,",
            "                )  # type: defer.Deferred",
            "",
            "                # we use our own timeout mechanism rather than treq's as a workaround",
            "                # for https://twistedmatrix.com/trac/ticket/9534.",
            "                request_deferred = timeout_deferred(",
            "                    request_deferred, 60, self.hs.get_reactor(),",
            "                )",
            "",
            "                # turn timeouts into RequestTimedOutErrors",
            "                request_deferred.addErrback(_timeout_to_request_timed_out_error)",
            "",
            "                response = await make_deferred_yieldable(request_deferred)",
            "",
            "                incoming_responses_counter.labels(method, response.code).inc()",
            "                logger.info(",
            "                    \"Received response to %s %s: %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    response.code,",
            "                )",
            "                return response",
            "            except Exception as e:",
            "                incoming_responses_counter.labels(method, \"ERR\").inc()",
            "                logger.info(",
            "                    \"Error sending request to  %s %s: %s %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    type(e).__name__,",
            "                    e.args[0],",
            "                )",
            "                set_tag(tags.ERROR, True)",
            "                set_tag(\"error_reason\", e.args[0])",
            "                raise",
            "",
            "    async def post_urlencoded_get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[Mapping[str, Union[str, List[str]]]] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"",
            "        Args:",
            "            uri: uri to query",
            "            args: parameters to be url-encoded in the body",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "",
            "        # TODO: Do we ever want to log message contents?",
            "        logger.debug(\"post_urlencoded_get_json args: %s\", args)",
            "",
            "        query_bytes = encode_query_args(args)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/x-www-form-urlencoded\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=query_bytes",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def post_json_get_json(",
            "        self, uri: str, post_json: Any, headers: Optional[RawHeaders] = None",
            "    ) -> Any:",
            "        \"\"\"",
            "",
            "        Args:",
            "            uri: URI to query.",
            "            post_json: request body, to be encoded as json",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        json_str = encode_canonical_json(post_json)",
            "",
            "        logger.debug(\"HTTP POST %s -> %s\", json_str, uri)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"Gets some json from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query string",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        actual_headers = {b\"Accept\": [b\"application/json\"]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        body = await self.get_raw(uri, args, headers=headers)",
            "        return json_decoder.decode(body.decode(\"utf-8\"))",
            "",
            "    async def put_json(",
            "        self,",
            "        uri: str,",
            "        json_body: Any,",
            "        args: Optional[QueryParams] = None,",
            "        headers: RawHeaders = None,",
            "    ) -> Any:",
            "        \"\"\"Puts some json to the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            json_body: The JSON to put in the HTTP body,",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "             RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        json_str = encode_canonical_json(json_body)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"PUT\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_raw(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> bytes:",
            "        \"\"\"Gets raw text from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the",
            "            HTTP body as bytes.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException on a non-2xx HTTP response.",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", uri, headers=Headers(actual_headers))",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return body",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    # XXX: FIXME: This is horribly copy-pasted from matrixfederationclient.",
            "    # The two should be factored out.",
            "",
            "    async def get_file(",
            "        self,",
            "        url: str,",
            "        output_stream: BinaryIO,",
            "        max_size: Optional[int] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Tuple[int, Dict[bytes, List[bytes]], str, int]:",
            "        \"\"\"GETs a file from a given URL",
            "        Args:",
            "            url: The URL to GET",
            "            output_stream: File to write the response body to.",
            "            headers: A map from header name to a list of values for that header",
            "        Returns:",
            "            A tuple of the file length, dict of the response",
            "            headers, absolute URI of the response and HTTP response code.",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            SynapseError: if the response is not a 2xx, the remote file is too large, or",
            "               another exception happens during the download.",
            "        \"\"\"",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", url, headers=Headers(actual_headers))",
            "",
            "        resp_headers = dict(response.headers.getAllRawHeaders())",
            "",
            "        if (",
            "            b\"Content-Length\" in resp_headers",
            "            and max_size",
            "            and int(resp_headers[b\"Content-Length\"][0]) > max_size",
            "        ):",
            "            logger.warning(\"Requested URL is too large > %r bytes\" % (max_size,))",
            "            raise SynapseError(",
            "                502,",
            "                \"Requested file is too large > %r bytes\" % (max_size,),",
            "                Codes.TOO_LARGE,",
            "            )",
            "",
            "        if response.code > 299:",
            "            logger.warning(\"Got %d when downloading %s\" % (response.code, url))",
            "            raise SynapseError(502, \"Got error %d\" % (response.code,), Codes.UNKNOWN)",
            "",
            "        # TODO: if our Content-Type is HTML or something, just read the first",
            "        # N bytes into RAM rather than saving it all to disk only to read it",
            "        # straight back in again",
            "",
            "        try:",
            "            length = await make_deferred_yieldable(",
            "                readBodyToFile(response, output_stream, max_size)",
            "            )",
            "        except SynapseError:",
            "            # This can happen e.g. because the body is too large.",
            "            raise",
            "        except Exception as e:",
            "            raise SynapseError(502, (\"Failed to download remote body: %s\" % e)) from e",
            "",
            "        return (",
            "            length,",
            "            resp_headers,",
            "            response.request.absoluteURI.decode(\"ascii\"),",
            "            response.code,",
            "        )",
            "",
            "",
            "def _timeout_to_request_timed_out_error(f: Failure):",
            "    if f.check(twisted_error.TimeoutError, twisted_error.ConnectingCancelledError):",
            "        # The TCP connection has its own timeout (set by the 'connectTimeout' param",
            "        # on the Agent), which raises twisted_error.TimeoutError exception.",
            "        raise RequestTimedOutError(\"Timeout connecting to remote server\")",
            "    elif f.check(defer.TimeoutError, ResponseNeverReceived):",
            "        # this one means that we hit our overall timeout on the request",
            "        raise RequestTimedOutError(\"Timeout waiting for response from remote server\")",
            "",
            "    return f",
            "",
            "",
            "class _ReadBodyToFileProtocol(protocol.Protocol):",
            "    def __init__(",
            "        self, stream: BinaryIO, deferred: defer.Deferred, max_size: Optional[int]",
            "    ):",
            "        self.stream = stream",
            "        self.deferred = deferred",
            "        self.length = 0",
            "        self.max_size = max_size",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        self.stream.write(data)",
            "        self.length += len(data)",
            "        if self.max_size is not None and self.length >= self.max_size:",
            "            self.deferred.errback(",
            "                SynapseError(",
            "                    502,",
            "                    \"Requested file is too large > %r bytes\" % (self.max_size,),",
            "                    Codes.TOO_LARGE,",
            "                )",
            "            )",
            "            self.deferred = defer.Deferred()",
            "            self.transport.loseConnection()",
            "",
            "    def connectionLost(self, reason: Failure) -> None:",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(self.length)",
            "        elif reason.check(PotentialDataLoss):",
            "            # stolen from https://github.com/twisted/treq/pull/49/files",
            "            # http://twistedmatrix.com/trac/ticket/4840",
            "            self.deferred.callback(self.length)",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def readBodyToFile(",
            "    response: IResponse, stream: BinaryIO, max_size: Optional[int]",
            ") -> defer.Deferred:",
            "    \"\"\"",
            "    Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.",
            "",
            "    Args:",
            "        response: The HTTP response to read from.",
            "        stream: The file-object to write to.",
            "        max_size: The maximum file size to allow.",
            "",
            "    Returns:",
            "        A Deferred which resolves to the length of the read body.",
            "    \"\"\"",
            "",
            "    d = defer.Deferred()",
            "    response.deliverBody(_ReadBodyToFileProtocol(stream, d, max_size))",
            "    return d",
            "",
            "",
            "def encode_query_args(args: Optional[Mapping[str, Union[str, List[str]]]]) -> bytes:",
            "    \"\"\"",
            "    Encodes a map of query arguments to bytes which can be appended to a URL.",
            "",
            "    Args:",
            "        args: The query arguments, a mapping of string to string or list of strings.",
            "",
            "    Returns:",
            "        The query arguments encoded as bytes.",
            "    \"\"\"",
            "    if args is None:",
            "        return b\"\"",
            "",
            "    encoded_args = {}",
            "    for k, vs in args.items():",
            "        if isinstance(vs, str):",
            "            vs = [vs]",
            "        encoded_args[k] = [v.encode(\"utf8\") for v in vs]",
            "",
            "    query_str = urllib.parse.urlencode(encoded_args, True)",
            "",
            "    return query_str.encode(\"utf8\")",
            "",
            "",
            "class InsecureInterceptableContextFactory(ssl.ContextFactory):",
            "    \"\"\"",
            "    Factory for PyOpenSSL SSL contexts which accepts any certificate for any domain.",
            "",
            "    Do not use this since it allows an attacker to intercept your communications.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._context = SSL.Context(SSL.SSLv23_METHOD)",
            "        self._context.set_verify(VERIFY_NONE, lambda *_: None)",
            "",
            "    def getContext(self, hostname=None, port=None):",
            "        return self._context",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        return self"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import urllib.parse",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    BinaryIO,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "import treq",
            "from canonicaljson import encode_canonical_json",
            "from netaddr import IPAddress, IPSet",
            "from prometheus_client import Counter",
            "from zope.interface import implementer, provider",
            "",
            "from OpenSSL import SSL",
            "from OpenSSL.SSL import VERIFY_NONE",
            "from twisted.internet import defer, error as twisted_error, protocol, ssl",
            "from twisted.internet.interfaces import (",
            "    IAddress,",
            "    IHostResolution,",
            "    IReactorPluggableNameResolver,",
            "    IResolutionReceiver,",
            ")",
            "from twisted.internet.task import Cooperator",
            "from twisted.python.failure import Failure",
            "from twisted.web._newclient import ResponseDone",
            "from twisted.web.client import (",
            "    Agent,",
            "    HTTPConnectionPool,",
            "    ResponseNeverReceived,",
            "    readBody,",
            ")",
            "from twisted.web.http import PotentialDataLoss",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IAgent, IBodyProducer, IResponse",
            "",
            "from synapse.api.errors import Codes, HttpResponseException, SynapseError",
            "from synapse.http import QuieterFileBodyProducer, RequestTimedOutError, redact_uri",
            "from synapse.http.proxyagent import ProxyAgent",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.logging.opentracing import set_tag, start_active_span, tags",
            "from synapse.util import json_decoder",
            "from synapse.util.async_helpers import timeout_deferred",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.app.homeserver import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "outgoing_requests_counter = Counter(\"synapse_http_client_requests\", \"\", [\"method\"])",
            "incoming_responses_counter = Counter(",
            "    \"synapse_http_client_responses\", \"\", [\"method\", \"code\"]",
            ")",
            "",
            "# the type of the headers list, to be passed to the t.w.h.Headers.",
            "# Actually we can mix str and bytes keys, but Mapping treats 'key' as invariant so",
            "# we simplify.",
            "RawHeaders = Union[Mapping[str, \"RawHeaderValue\"], Mapping[bytes, \"RawHeaderValue\"]]",
            "",
            "# the value actually has to be a List, but List is invariant so we can't specify that",
            "# the entries can either be Lists or bytes.",
            "RawHeaderValue = Sequence[Union[str, bytes]]",
            "",
            "# the type of the query params, to be passed into `urlencode`",
            "QueryParamValue = Union[str, bytes, Iterable[Union[str, bytes]]]",
            "QueryParams = Union[Mapping[str, QueryParamValue], Mapping[bytes, QueryParamValue]]",
            "",
            "",
            "def check_against_blacklist(",
            "    ip_address: IPAddress, ip_whitelist: Optional[IPSet], ip_blacklist: IPSet",
            ") -> bool:",
            "    \"\"\"",
            "    Compares an IP address to allowed and disallowed IP sets.",
            "",
            "    Args:",
            "        ip_address: The IP address to check",
            "        ip_whitelist: Allowed IP addresses.",
            "        ip_blacklist: Disallowed IP addresses.",
            "",
            "    Returns:",
            "        True if the IP address is in the blacklist and not in the whitelist.",
            "    \"\"\"",
            "    if ip_address in ip_blacklist:",
            "        if ip_whitelist is None or ip_address not in ip_whitelist:",
            "            return True",
            "    return False",
            "",
            "",
            "_EPSILON = 0.00000001",
            "",
            "",
            "def _make_scheduler(reactor):",
            "    \"\"\"Makes a schedular suitable for a Cooperator using the given reactor.",
            "",
            "    (This is effectively just a copy from `twisted.internet.task`)",
            "    \"\"\"",
            "",
            "    def _scheduler(x):",
            "        return reactor.callLater(_EPSILON, x)",
            "",
            "    return _scheduler",
            "",
            "",
            "class _IPBlacklistingResolver:",
            "    \"\"\"",
            "    A proxy for reactor.nameResolver which only produces non-blacklisted IP",
            "    addresses, preventing DNS rebinding attacks on URL preview.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            reactor: The twisted reactor.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._reactor = reactor",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def resolveHostName(",
            "        self, recv: IResolutionReceiver, hostname: str, portNumber: int = 0",
            "    ) -> IResolutionReceiver:",
            "",
            "        r = recv()",
            "        addresses = []  # type: List[IAddress]",
            "",
            "        def _callback() -> None:",
            "            r.resolutionBegan(None)",
            "",
            "            has_bad_ip = False",
            "            for i in addresses:",
            "                ip_address = IPAddress(i.host)",
            "",
            "                if check_against_blacklist(",
            "                    ip_address, self._ip_whitelist, self._ip_blacklist",
            "                ):",
            "                    logger.info(",
            "                        \"Dropped %s from DNS resolution to %s due to blacklist\"",
            "                        % (ip_address, hostname)",
            "                    )",
            "                    has_bad_ip = True",
            "",
            "            # if we have a blacklisted IP, we'd like to raise an error to block the",
            "            # request, but all we can really do from here is claim that there were no",
            "            # valid results.",
            "            if not has_bad_ip:",
            "                for i in addresses:",
            "                    r.addressResolved(i)",
            "            r.resolutionComplete()",
            "",
            "        @provider(IResolutionReceiver)",
            "        class EndpointReceiver:",
            "            @staticmethod",
            "            def resolutionBegan(resolutionInProgress: IHostResolution) -> None:",
            "                pass",
            "",
            "            @staticmethod",
            "            def addressResolved(address: IAddress) -> None:",
            "                addresses.append(address)",
            "",
            "            @staticmethod",
            "            def resolutionComplete() -> None:",
            "                _callback()",
            "",
            "        self._reactor.nameResolver.resolveHostName(",
            "            EndpointReceiver, hostname, portNumber=portNumber",
            "        )",
            "",
            "        return r",
            "",
            "",
            "@implementer(IReactorPluggableNameResolver)",
            "class BlacklistingReactorWrapper:",
            "    \"\"\"",
            "    A Reactor wrapper which will prevent DNS resolution to blacklisted IP",
            "    addresses, to prevent DNS rebinding.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        self._reactor = reactor",
            "",
            "        # We need to use a DNS resolver which filters out blacklisted IP",
            "        # addresses, to prevent DNS rebinding.",
            "        self._nameResolver = _IPBlacklistingResolver(",
            "            self._reactor, ip_whitelist, ip_blacklist",
            "        )",
            "",
            "    def __getattr__(self, attr: str) -> Any:",
            "        # Passthrough to the real reactor except for the DNS resolver.",
            "        if attr == \"nameResolver\":",
            "            return self._nameResolver",
            "        else:",
            "            return getattr(self._reactor, attr)",
            "",
            "",
            "class BlacklistingAgentWrapper(Agent):",
            "    \"\"\"",
            "    An Agent wrapper which will prevent access to IP addresses being accessed",
            "    directly (without an IP address lookup).",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        agent: IAgent,",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            agent: The Agent to wrap.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._agent = agent",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def request(",
            "        self,",
            "        method: bytes,",
            "        uri: bytes,",
            "        headers: Optional[Headers] = None,",
            "        bodyProducer: Optional[IBodyProducer] = None,",
            "    ) -> defer.Deferred:",
            "        h = urllib.parse.urlparse(uri.decode(\"ascii\"))",
            "",
            "        try:",
            "            ip_address = IPAddress(h.hostname)",
            "",
            "            if check_against_blacklist(",
            "                ip_address, self._ip_whitelist, self._ip_blacklist",
            "            ):",
            "                logger.info(\"Blocking access to %s due to blacklist\" % (ip_address,))",
            "                e = SynapseError(403, \"IP address blocked by IP blacklist entry\")",
            "                return defer.fail(Failure(e))",
            "        except Exception:",
            "            # Not an IP",
            "            pass",
            "",
            "        return self._agent.request(",
            "            method, uri, headers=headers, bodyProducer=bodyProducer",
            "        )",
            "",
            "",
            "class SimpleHttpClient:",
            "    \"\"\"",
            "    A simple, no-frills HTTP client with methods that wrap up common ways of",
            "    using HTTP in Matrix",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        treq_args: Dict[str, Any] = {},",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "        http_proxy: Optional[bytes] = None,",
            "        https_proxy: Optional[bytes] = None,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            hs",
            "            treq_args: Extra keyword arguments to be given to treq.request.",
            "            ip_blacklist: The IP addresses that are blacklisted that",
            "                we may not request.",
            "            ip_whitelist: The whitelisted IP addresses, that we can",
            "               request if it were otherwise caught in a blacklist.",
            "            http_proxy: proxy server to use for http connections. host[:port]",
            "            https_proxy: proxy server to use for https connections. host[:port]",
            "        \"\"\"",
            "        self.hs = hs",
            "",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "        self._extra_treq_args = treq_args",
            "",
            "        self.user_agent = hs.version_string",
            "        self.clock = hs.get_clock()",
            "        if hs.config.user_agent_suffix:",
            "            self.user_agent = \"%s %s\" % (self.user_agent, hs.config.user_agent_suffix)",
            "",
            "        # We use this for our body producers to ensure that they use the correct",
            "        # reactor.",
            "        self._cooperator = Cooperator(scheduler=_make_scheduler(hs.get_reactor()))",
            "",
            "        self.user_agent = self.user_agent.encode(\"ascii\")",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we need to use a DNS resolver which",
            "            # filters out blacklisted IP addresses, to prevent DNS rebinding.",
            "            self.reactor = BlacklistingReactorWrapper(",
            "                hs.get_reactor(), self._ip_whitelist, self._ip_blacklist",
            "            )",
            "        else:",
            "            self.reactor = hs.get_reactor()",
            "",
            "        # the pusher makes lots of concurrent SSL connections to sygnal, and",
            "        # tends to do so in batches, so we need to allow the pool to keep",
            "        # lots of idle connections around.",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        # XXX: The justification for using the cache factor here is that larger instances",
            "        # will need both more cache and more connections.",
            "        # Still, this should probably be a separate dial",
            "        pool.maxPersistentPerHost = max((100 * hs.config.caches.global_factor, 5))",
            "        pool.cachedConnectionTimeout = 2 * 60",
            "",
            "        self.agent = ProxyAgent(",
            "            self.reactor,",
            "            connectTimeout=15,",
            "            contextFactory=self.hs.get_http_client_context_factory(),",
            "            pool=pool,",
            "            http_proxy=http_proxy,",
            "            https_proxy=https_proxy,",
            "        )",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we then install the blacklisting Agent",
            "            # which prevents direct access to IP addresses, that are not caught",
            "            # by the DNS resolution.",
            "            self.agent = BlacklistingAgentWrapper(",
            "                self.agent,",
            "                ip_whitelist=self._ip_whitelist,",
            "                ip_blacklist=self._ip_blacklist,",
            "            )",
            "",
            "    async def request(",
            "        self,",
            "        method: str,",
            "        uri: str,",
            "        data: Optional[bytes] = None,",
            "        headers: Optional[Headers] = None,",
            "    ) -> IResponse:",
            "        \"\"\"",
            "        Args:",
            "            method: HTTP method to use.",
            "            uri: URI to query.",
            "            data: Data to send in the request body, if applicable.",
            "            headers: Request headers.",
            "",
            "        Returns:",
            "            Response object, once the headers have been read.",
            "",
            "        Raises:",
            "            RequestTimedOutError if the request times out before the headers are read",
            "",
            "        \"\"\"",
            "        outgoing_requests_counter.labels(method).inc()",
            "",
            "        # log request but strip `access_token` (AS requests for example include this)",
            "        logger.debug(\"Sending request %s %s\", method, redact_uri(uri))",
            "",
            "        with start_active_span(",
            "            \"outgoing-client-request\",",
            "            tags={",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_CLIENT,",
            "                tags.HTTP_METHOD: method,",
            "                tags.HTTP_URL: uri,",
            "            },",
            "            finish_on_close=True,",
            "        ):",
            "            try:",
            "                body_producer = None",
            "                if data is not None:",
            "                    body_producer = QuieterFileBodyProducer(",
            "                        BytesIO(data), cooperator=self._cooperator,",
            "                    )",
            "",
            "                request_deferred = treq.request(",
            "                    method,",
            "                    uri,",
            "                    agent=self.agent,",
            "                    data=body_producer,",
            "                    headers=headers,",
            "                    **self._extra_treq_args,",
            "                )  # type: defer.Deferred",
            "",
            "                # we use our own timeout mechanism rather than treq's as a workaround",
            "                # for https://twistedmatrix.com/trac/ticket/9534.",
            "                request_deferred = timeout_deferred(",
            "                    request_deferred, 60, self.hs.get_reactor(),",
            "                )",
            "",
            "                # turn timeouts into RequestTimedOutErrors",
            "                request_deferred.addErrback(_timeout_to_request_timed_out_error)",
            "",
            "                response = await make_deferred_yieldable(request_deferred)",
            "",
            "                incoming_responses_counter.labels(method, response.code).inc()",
            "                logger.info(",
            "                    \"Received response to %s %s: %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    response.code,",
            "                )",
            "                return response",
            "            except Exception as e:",
            "                incoming_responses_counter.labels(method, \"ERR\").inc()",
            "                logger.info(",
            "                    \"Error sending request to  %s %s: %s %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    type(e).__name__,",
            "                    e.args[0],",
            "                )",
            "                set_tag(tags.ERROR, True)",
            "                set_tag(\"error_reason\", e.args[0])",
            "                raise",
            "",
            "    async def post_urlencoded_get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[Mapping[str, Union[str, List[str]]]] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"",
            "        Args:",
            "            uri: uri to query",
            "            args: parameters to be url-encoded in the body",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "",
            "        # TODO: Do we ever want to log message contents?",
            "        logger.debug(\"post_urlencoded_get_json args: %s\", args)",
            "",
            "        query_bytes = encode_query_args(args)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/x-www-form-urlencoded\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=query_bytes",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def post_json_get_json(",
            "        self, uri: str, post_json: Any, headers: Optional[RawHeaders] = None",
            "    ) -> Any:",
            "        \"\"\"",
            "",
            "        Args:",
            "            uri: URI to query.",
            "            post_json: request body, to be encoded as json",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        json_str = encode_canonical_json(post_json)",
            "",
            "        logger.debug(\"HTTP POST %s -> %s\", json_str, uri)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"Gets some json from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query string",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        actual_headers = {b\"Accept\": [b\"application/json\"]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        body = await self.get_raw(uri, args, headers=headers)",
            "        return json_decoder.decode(body.decode(\"utf-8\"))",
            "",
            "    async def put_json(",
            "        self,",
            "        uri: str,",
            "        json_body: Any,",
            "        args: Optional[QueryParams] = None,",
            "        headers: RawHeaders = None,",
            "    ) -> Any:",
            "        \"\"\"Puts some json to the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            json_body: The JSON to put in the HTTP body,",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "             RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        json_str = encode_canonical_json(json_body)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"PUT\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_raw(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> bytes:",
            "        \"\"\"Gets raw text from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the",
            "            HTTP body as bytes.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException on a non-2xx HTTP response.",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", uri, headers=Headers(actual_headers))",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return body",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    # XXX: FIXME: This is horribly copy-pasted from matrixfederationclient.",
            "    # The two should be factored out.",
            "",
            "    async def get_file(",
            "        self,",
            "        url: str,",
            "        output_stream: BinaryIO,",
            "        max_size: Optional[int] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Tuple[int, Dict[bytes, List[bytes]], str, int]:",
            "        \"\"\"GETs a file from a given URL",
            "        Args:",
            "            url: The URL to GET",
            "            output_stream: File to write the response body to.",
            "            headers: A map from header name to a list of values for that header",
            "        Returns:",
            "            A tuple of the file length, dict of the response",
            "            headers, absolute URI of the response and HTTP response code.",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            SynapseError: if the response is not a 2xx, the remote file is too large, or",
            "               another exception happens during the download.",
            "        \"\"\"",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", url, headers=Headers(actual_headers))",
            "",
            "        resp_headers = dict(response.headers.getAllRawHeaders())",
            "",
            "        if (",
            "            b\"Content-Length\" in resp_headers",
            "            and max_size",
            "            and int(resp_headers[b\"Content-Length\"][0]) > max_size",
            "        ):",
            "            logger.warning(\"Requested URL is too large > %r bytes\" % (max_size,))",
            "            raise SynapseError(",
            "                502,",
            "                \"Requested file is too large > %r bytes\" % (max_size,),",
            "                Codes.TOO_LARGE,",
            "            )",
            "",
            "        if response.code > 299:",
            "            logger.warning(\"Got %d when downloading %s\" % (response.code, url))",
            "            raise SynapseError(502, \"Got error %d\" % (response.code,), Codes.UNKNOWN)",
            "",
            "        # TODO: if our Content-Type is HTML or something, just read the first",
            "        # N bytes into RAM rather than saving it all to disk only to read it",
            "        # straight back in again",
            "",
            "        try:",
            "            length = await make_deferred_yieldable(",
            "                read_body_with_max_size(response, output_stream, max_size)",
            "            )",
            "        except BodyExceededMaxSize:",
            "            SynapseError(",
            "                502,",
            "                \"Requested file is too large > %r bytes\" % (max_size,),",
            "                Codes.TOO_LARGE,",
            "            )",
            "        except Exception as e:",
            "            raise SynapseError(502, (\"Failed to download remote body: %s\" % e)) from e",
            "",
            "        return (",
            "            length,",
            "            resp_headers,",
            "            response.request.absoluteURI.decode(\"ascii\"),",
            "            response.code,",
            "        )",
            "",
            "",
            "def _timeout_to_request_timed_out_error(f: Failure):",
            "    if f.check(twisted_error.TimeoutError, twisted_error.ConnectingCancelledError):",
            "        # The TCP connection has its own timeout (set by the 'connectTimeout' param",
            "        # on the Agent), which raises twisted_error.TimeoutError exception.",
            "        raise RequestTimedOutError(\"Timeout connecting to remote server\")",
            "    elif f.check(defer.TimeoutError, ResponseNeverReceived):",
            "        # this one means that we hit our overall timeout on the request",
            "        raise RequestTimedOutError(\"Timeout waiting for response from remote server\")",
            "",
            "    return f",
            "",
            "",
            "class BodyExceededMaxSize(Exception):",
            "    \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\"",
            "",
            "",
            "class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    def __init__(",
            "        self, stream: BinaryIO, deferred: defer.Deferred, max_size: Optional[int]",
            "    ):",
            "        self.stream = stream",
            "        self.deferred = deferred",
            "        self.length = 0",
            "        self.max_size = max_size",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        self.stream.write(data)",
            "        self.length += len(data)",
            "        if self.max_size is not None and self.length >= self.max_size:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            self.deferred = defer.Deferred()",
            "            self.transport.loseConnection()",
            "",
            "    def connectionLost(self, reason: Failure) -> None:",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(self.length)",
            "        elif reason.check(PotentialDataLoss):",
            "            # stolen from https://github.com/twisted/treq/pull/49/files",
            "            # http://twistedmatrix.com/trac/ticket/4840",
            "            self.deferred.callback(self.length)",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def read_body_with_max_size(",
            "    response: IResponse, stream: BinaryIO, max_size: Optional[int]",
            ") -> defer.Deferred:",
            "    \"\"\"",
            "    Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.",
            "",
            "    If the maximum file size is reached, the returned Deferred will resolve to a",
            "    Failure with a BodyExceededMaxSize exception.",
            "",
            "    Args:",
            "        response: The HTTP response to read from.",
            "        stream: The file-object to write to.",
            "        max_size: The maximum file size to allow.",
            "",
            "    Returns:",
            "        A Deferred which resolves to the length of the read body.",
            "    \"\"\"",
            "",
            "    d = defer.Deferred()",
            "    response.deliverBody(_ReadBodyWithMaxSizeProtocol(stream, d, max_size))",
            "    return d",
            "",
            "",
            "def encode_query_args(args: Optional[Mapping[str, Union[str, List[str]]]]) -> bytes:",
            "    \"\"\"",
            "    Encodes a map of query arguments to bytes which can be appended to a URL.",
            "",
            "    Args:",
            "        args: The query arguments, a mapping of string to string or list of strings.",
            "",
            "    Returns:",
            "        The query arguments encoded as bytes.",
            "    \"\"\"",
            "    if args is None:",
            "        return b\"\"",
            "",
            "    encoded_args = {}",
            "    for k, vs in args.items():",
            "        if isinstance(vs, str):",
            "            vs = [vs]",
            "        encoded_args[k] = [v.encode(\"utf8\") for v in vs]",
            "",
            "    query_str = urllib.parse.urlencode(encoded_args, True)",
            "",
            "    return query_str.encode(\"utf8\")",
            "",
            "",
            "class InsecureInterceptableContextFactory(ssl.ContextFactory):",
            "    \"\"\"",
            "    Factory for PyOpenSSL SSL contexts which accepts any certificate for any domain.",
            "",
            "    Do not use this since it allows an attacker to intercept your communications.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._context = SSL.Context(SSL.SSLv23_METHOD)",
            "        self._context.set_verify(VERIFY_NONE, lambda *_: None)",
            "",
            "    def getContext(self, hostname=None, port=None):",
            "        return self._context",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        return self"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "723": [
                "SimpleHttpClient"
            ],
            "725": [
                "SimpleHttpClient"
            ],
            "726": [
                "SimpleHttpClient"
            ],
            "727": [
                "SimpleHttpClient"
            ],
            "751": [
                "_ReadBodyToFileProtocol"
            ],
            "764": [
                "_ReadBodyToFileProtocol",
                "dataReceived"
            ],
            "765": [
                "_ReadBodyToFileProtocol",
                "dataReceived"
            ],
            "766": [
                "_ReadBodyToFileProtocol",
                "dataReceived"
            ],
            "767": [
                "_ReadBodyToFileProtocol",
                "dataReceived"
            ],
            "768": [
                "_ReadBodyToFileProtocol",
                "dataReceived"
            ],
            "769": [
                "_ReadBodyToFileProtocol",
                "dataReceived"
            ],
            "770": [
                "_ReadBodyToFileProtocol",
                "dataReceived"
            ],
            "785": [
                "readBodyToFile"
            ],
            "801": [
                "readBodyToFile"
            ]
        },
        "addLocation": []
    },
    "synapse/http/federation/well_known_resolver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import random"
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import time"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from io import BytesIO"
            },
            "4": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from typing import Callable, Dict, Optional, Tuple"
            },
            "5": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import attr"
            },
            "7": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from twisted.internet import defer"
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from twisted.internet.interfaces import IReactorTime"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from twisted.web.client import RedirectAgent, readBody"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from twisted.web.client import RedirectAgent"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from twisted.web.http import stringToDatetime"
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from twisted.web.http_headers import Headers"
            },
            "14": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from twisted.web.iweb import IAgent, IResponse"
            },
            "15": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+from synapse.http.client import BodyExceededMaxSize, read_body_with_max_size"
            },
            "17": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from synapse.logging.context import make_deferred_yieldable"
            },
            "18": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from synapse.util import Clock, json_decoder"
            },
            "19": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from synapse.util.caches.ttlcache import TTLCache"
            },
            "20": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " # lower bound for .well-known cache period"
            },
            "21": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " WELL_KNOWN_MIN_CACHE_PERIOD = 5 * 60"
            },
            "22": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+# The maximum size (in bytes) to allow a well-known file to be."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+WELL_KNOWN_MAX_SIZE = 50 * 1024  # 50 KiB"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " # Attempt to refetch a cached well-known N% of the TTL before it expires."
            },
            "27": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " # e.g. if set to 0.2 and we have a cached entry with a TTL of 5mins, then"
            },
            "28": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " # we'll start trying to refetch 1 minute before it expires."
            },
            "29": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             server_name: name of the server, from the requested url"
            },
            "30": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             retry: Whether to retry the request if it fails."
            },
            "31": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        Raises:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+            _FetchWellKnownFailure if we fail to lookup a result"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         Returns:"
            },
            "36": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "             Returns the response object and body. Response may be a non-200 response."
            },
            "37": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         \"\"\""
            },
            "38": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "                         b\"GET\", uri, headers=Headers(headers)"
            },
            "39": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "                     )"
            },
            "40": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "                 )"
            },
            "41": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                body = await make_deferred_yieldable(readBody(response))"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+                body_stream = BytesIO()"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+                await make_deferred_yieldable("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+                    read_body_with_max_size(response, body_stream, WELL_KNOWN_MAX_SIZE)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                )"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+                body = body_stream.getvalue()"
            },
            "47": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 266,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "                 if 500 <= response.code < 600:"
            },
            "49": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "                     raise Exception(\"Non-200 response %s\" % (response.code,))"
            },
            "50": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "             except defer.CancelledError:"
            },
            "51": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "                 # Bail if we've been cancelled"
            },
            "52": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "                 raise"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+            except BodyExceededMaxSize:"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+                # If the well-known file was too large, do not keep attempting"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+                # to download it, but consider it a temporary error."
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+                logger.warning("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+                    \"Requested .well-known file for %s is too large > %r bytes\","
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+                    server_name.decode(\"ascii\"),"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+                    WELL_KNOWN_MAX_SIZE,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+                )"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+                raise _FetchWellKnownFailure(temporary=True)"
            },
            "62": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "             except Exception as e:"
            },
            "63": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "                 if not retry or i >= WELL_KNOWN_RETRY_ATTEMPTS:"
            },
            "64": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "                     logger.info(\"Error fetching %s: %s\", uri_str, e)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import random",
            "import time",
            "from typing import Callable, Dict, Optional, Tuple",
            "",
            "import attr",
            "",
            "from twisted.internet import defer",
            "from twisted.internet.interfaces import IReactorTime",
            "from twisted.web.client import RedirectAgent, readBody",
            "from twisted.web.http import stringToDatetime",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IAgent, IResponse",
            "",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.util import Clock, json_decoder",
            "from synapse.util.caches.ttlcache import TTLCache",
            "from synapse.util.metrics import Measure",
            "",
            "# period to cache .well-known results for by default",
            "WELL_KNOWN_DEFAULT_CACHE_PERIOD = 24 * 3600",
            "",
            "# jitter factor to add to the .well-known default cache ttls",
            "WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER = 0.1",
            "",
            "# period to cache failure to fetch .well-known for",
            "WELL_KNOWN_INVALID_CACHE_PERIOD = 1 * 3600",
            "",
            "# period to cache failure to fetch .well-known if there has recently been a",
            "# valid well-known for that domain.",
            "WELL_KNOWN_DOWN_CACHE_PERIOD = 2 * 60",
            "",
            "# period to remember there was a valid well-known after valid record expires",
            "WELL_KNOWN_REMEMBER_DOMAIN_HAD_VALID = 2 * 3600",
            "",
            "# cap for .well-known cache period",
            "WELL_KNOWN_MAX_CACHE_PERIOD = 48 * 3600",
            "",
            "# lower bound for .well-known cache period",
            "WELL_KNOWN_MIN_CACHE_PERIOD = 5 * 60",
            "",
            "# Attempt to refetch a cached well-known N% of the TTL before it expires.",
            "# e.g. if set to 0.2 and we have a cached entry with a TTL of 5mins, then",
            "# we'll start trying to refetch 1 minute before it expires.",
            "WELL_KNOWN_GRACE_PERIOD_FACTOR = 0.2",
            "",
            "# Number of times we retry fetching a well-known for a domain we know recently",
            "# had a valid entry.",
            "WELL_KNOWN_RETRY_ATTEMPTS = 3",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "_well_known_cache = TTLCache(\"well-known\")",
            "_had_valid_well_known_cache = TTLCache(\"had-valid-well-known\")",
            "",
            "",
            "@attr.s(slots=True, frozen=True)",
            "class WellKnownLookupResult:",
            "    delegated_server = attr.ib()",
            "",
            "",
            "class WellKnownResolver:",
            "    \"\"\"Handles well-known lookups for matrix servers.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorTime,",
            "        agent: IAgent,",
            "        user_agent: bytes,",
            "        well_known_cache: Optional[TTLCache] = None,",
            "        had_well_known_cache: Optional[TTLCache] = None,",
            "    ):",
            "        self._reactor = reactor",
            "        self._clock = Clock(reactor)",
            "",
            "        if well_known_cache is None:",
            "            well_known_cache = _well_known_cache",
            "",
            "        if had_well_known_cache is None:",
            "            had_well_known_cache = _had_valid_well_known_cache",
            "",
            "        self._well_known_cache = well_known_cache",
            "        self._had_valid_well_known_cache = had_well_known_cache",
            "        self._well_known_agent = RedirectAgent(agent)",
            "        self.user_agent = user_agent",
            "",
            "    async def get_well_known(self, server_name: bytes) -> WellKnownLookupResult:",
            "        \"\"\"Attempt to fetch and parse a .well-known file for the given server",
            "",
            "        Args:",
            "            server_name: name of the server, from the requested url",
            "",
            "        Returns:",
            "            The result of the lookup",
            "        \"\"\"",
            "        try:",
            "            prev_result, expiry, ttl = self._well_known_cache.get_with_expiry(",
            "                server_name",
            "            )",
            "",
            "            now = self._clock.time()",
            "            if now < expiry - WELL_KNOWN_GRACE_PERIOD_FACTOR * ttl:",
            "                return WellKnownLookupResult(delegated_server=prev_result)",
            "        except KeyError:",
            "            prev_result = None",
            "",
            "        # TODO: should we linearise so that we don't end up doing two .well-known",
            "        # requests for the same server in parallel?",
            "        try:",
            "            with Measure(self._clock, \"get_well_known\"):",
            "                result, cache_period = await self._fetch_well_known(",
            "                    server_name",
            "                )  # type: Optional[bytes], float",
            "",
            "        except _FetchWellKnownFailure as e:",
            "            if prev_result and e.temporary:",
            "                # This is a temporary failure and we have a still valid cached",
            "                # result, so lets return that. Hopefully the next time we ask",
            "                # the remote will be back up again.",
            "                return WellKnownLookupResult(delegated_server=prev_result)",
            "",
            "            result = None",
            "",
            "            if self._had_valid_well_known_cache.get(server_name, False):",
            "                # We have recently seen a valid well-known record for this",
            "                # server, so we cache the lack of well-known for a shorter time.",
            "                cache_period = WELL_KNOWN_DOWN_CACHE_PERIOD",
            "            else:",
            "                cache_period = WELL_KNOWN_INVALID_CACHE_PERIOD",
            "",
            "            # add some randomness to the TTL to avoid a stampeding herd",
            "            cache_period *= random.uniform(",
            "                1 - WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "                1 + WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "            )",
            "",
            "        if cache_period > 0:",
            "            self._well_known_cache.set(server_name, result, cache_period)",
            "",
            "        return WellKnownLookupResult(delegated_server=result)",
            "",
            "    async def _fetch_well_known(self, server_name: bytes) -> Tuple[bytes, float]:",
            "        \"\"\"Actually fetch and parse a .well-known, without checking the cache",
            "",
            "        Args:",
            "            server_name: name of the server, from the requested url",
            "",
            "        Raises:",
            "            _FetchWellKnownFailure if we fail to lookup a result",
            "",
            "        Returns:",
            "            The lookup result and cache period.",
            "        \"\"\"",
            "",
            "        had_valid_well_known = self._had_valid_well_known_cache.get(server_name, False)",
            "",
            "        # We do this in two steps to differentiate between possibly transient",
            "        # errors (e.g. can't connect to host, 503 response) and more permanent",
            "        # errors (such as getting a 404 response).",
            "        response, body = await self._make_well_known_request(",
            "            server_name, retry=had_valid_well_known",
            "        )",
            "",
            "        try:",
            "            if response.code != 200:",
            "                raise Exception(\"Non-200 response %s\" % (response.code,))",
            "",
            "            parsed_body = json_decoder.decode(body.decode(\"utf-8\"))",
            "            logger.info(\"Response from .well-known: %s\", parsed_body)",
            "",
            "            result = parsed_body[\"m.server\"].encode(\"ascii\")",
            "        except defer.CancelledError:",
            "            # Bail if we've been cancelled",
            "            raise",
            "        except Exception as e:",
            "            logger.info(\"Error parsing well-known for %s: %s\", server_name, e)",
            "            raise _FetchWellKnownFailure(temporary=False)",
            "",
            "        cache_period = _cache_period_from_headers(",
            "            response.headers, time_now=self._reactor.seconds",
            "        )",
            "        if cache_period is None:",
            "            cache_period = WELL_KNOWN_DEFAULT_CACHE_PERIOD",
            "            # add some randomness to the TTL to avoid a stampeding herd every 24 hours",
            "            # after startup",
            "            cache_period *= random.uniform(",
            "                1 - WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "                1 + WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "            )",
            "        else:",
            "            cache_period = min(cache_period, WELL_KNOWN_MAX_CACHE_PERIOD)",
            "            cache_period = max(cache_period, WELL_KNOWN_MIN_CACHE_PERIOD)",
            "",
            "        # We got a success, mark as such in the cache",
            "        self._had_valid_well_known_cache.set(",
            "            server_name,",
            "            bool(result),",
            "            cache_period + WELL_KNOWN_REMEMBER_DOMAIN_HAD_VALID,",
            "        )",
            "",
            "        return result, cache_period",
            "",
            "    async def _make_well_known_request(",
            "        self, server_name: bytes, retry: bool",
            "    ) -> Tuple[IResponse, bytes]:",
            "        \"\"\"Make the well known request.",
            "",
            "        This will retry the request if requested and it fails (with unable",
            "        to connect or receives a 5xx error).",
            "",
            "        Args:",
            "            server_name: name of the server, from the requested url",
            "            retry: Whether to retry the request if it fails.",
            "",
            "        Returns:",
            "            Returns the response object and body. Response may be a non-200 response.",
            "        \"\"\"",
            "        uri = b\"https://%s/.well-known/matrix/server\" % (server_name,)",
            "        uri_str = uri.decode(\"ascii\")",
            "",
            "        headers = {",
            "            b\"User-Agent\": [self.user_agent],",
            "        }",
            "",
            "        i = 0",
            "        while True:",
            "            i += 1",
            "",
            "            logger.info(\"Fetching %s\", uri_str)",
            "            try:",
            "                response = await make_deferred_yieldable(",
            "                    self._well_known_agent.request(",
            "                        b\"GET\", uri, headers=Headers(headers)",
            "                    )",
            "                )",
            "                body = await make_deferred_yieldable(readBody(response))",
            "",
            "                if 500 <= response.code < 600:",
            "                    raise Exception(\"Non-200 response %s\" % (response.code,))",
            "",
            "                return response, body",
            "            except defer.CancelledError:",
            "                # Bail if we've been cancelled",
            "                raise",
            "            except Exception as e:",
            "                if not retry or i >= WELL_KNOWN_RETRY_ATTEMPTS:",
            "                    logger.info(\"Error fetching %s: %s\", uri_str, e)",
            "                    raise _FetchWellKnownFailure(temporary=True)",
            "",
            "                logger.info(\"Error fetching %s: %s. Retrying\", uri_str, e)",
            "",
            "            # Sleep briefly in the hopes that they come back up",
            "            await self._clock.sleep(0.5)",
            "",
            "",
            "def _cache_period_from_headers(",
            "    headers: Headers, time_now: Callable[[], float] = time.time",
            ") -> Optional[float]:",
            "    cache_controls = _parse_cache_control(headers)",
            "",
            "    if b\"no-store\" in cache_controls:",
            "        return 0",
            "",
            "    if b\"max-age\" in cache_controls:",
            "        max_age = cache_controls[b\"max-age\"]",
            "        if max_age:",
            "            try:",
            "                return int(max_age)",
            "            except ValueError:",
            "                pass",
            "",
            "    expires = headers.getRawHeaders(b\"expires\")",
            "    if expires is not None:",
            "        try:",
            "            expires_date = stringToDatetime(expires[-1])",
            "            return expires_date - time_now()",
            "        except ValueError:",
            "            # RFC7234 says 'A cache recipient MUST interpret invalid date formats,",
            "            # especially the value \"0\", as representing a time in the past (i.e.,",
            "            # \"already expired\").",
            "            return 0",
            "",
            "    return None",
            "",
            "",
            "def _parse_cache_control(headers: Headers) -> Dict[bytes, Optional[bytes]]:",
            "    cache_controls = {}",
            "    for hdr in headers.getRawHeaders(b\"cache-control\", []):",
            "        for directive in hdr.split(b\",\"):",
            "            splits = [x.strip() for x in directive.split(b\"=\", 1)]",
            "            k = splits[0].lower()",
            "            v = splits[1] if len(splits) > 1 else None",
            "            cache_controls[k] = v",
            "    return cache_controls",
            "",
            "",
            "@attr.s(slots=True)",
            "class _FetchWellKnownFailure(Exception):",
            "    # True if we didn't get a non-5xx HTTP response, i.e. this may or may not be",
            "    # a temporary failure.",
            "    temporary = attr.ib()"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import random",
            "import time",
            "from io import BytesIO",
            "from typing import Callable, Dict, Optional, Tuple",
            "",
            "import attr",
            "",
            "from twisted.internet import defer",
            "from twisted.internet.interfaces import IReactorTime",
            "from twisted.web.client import RedirectAgent",
            "from twisted.web.http import stringToDatetime",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IAgent, IResponse",
            "",
            "from synapse.http.client import BodyExceededMaxSize, read_body_with_max_size",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.util import Clock, json_decoder",
            "from synapse.util.caches.ttlcache import TTLCache",
            "from synapse.util.metrics import Measure",
            "",
            "# period to cache .well-known results for by default",
            "WELL_KNOWN_DEFAULT_CACHE_PERIOD = 24 * 3600",
            "",
            "# jitter factor to add to the .well-known default cache ttls",
            "WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER = 0.1",
            "",
            "# period to cache failure to fetch .well-known for",
            "WELL_KNOWN_INVALID_CACHE_PERIOD = 1 * 3600",
            "",
            "# period to cache failure to fetch .well-known if there has recently been a",
            "# valid well-known for that domain.",
            "WELL_KNOWN_DOWN_CACHE_PERIOD = 2 * 60",
            "",
            "# period to remember there was a valid well-known after valid record expires",
            "WELL_KNOWN_REMEMBER_DOMAIN_HAD_VALID = 2 * 3600",
            "",
            "# cap for .well-known cache period",
            "WELL_KNOWN_MAX_CACHE_PERIOD = 48 * 3600",
            "",
            "# lower bound for .well-known cache period",
            "WELL_KNOWN_MIN_CACHE_PERIOD = 5 * 60",
            "",
            "# The maximum size (in bytes) to allow a well-known file to be.",
            "WELL_KNOWN_MAX_SIZE = 50 * 1024  # 50 KiB",
            "",
            "# Attempt to refetch a cached well-known N% of the TTL before it expires.",
            "# e.g. if set to 0.2 and we have a cached entry with a TTL of 5mins, then",
            "# we'll start trying to refetch 1 minute before it expires.",
            "WELL_KNOWN_GRACE_PERIOD_FACTOR = 0.2",
            "",
            "# Number of times we retry fetching a well-known for a domain we know recently",
            "# had a valid entry.",
            "WELL_KNOWN_RETRY_ATTEMPTS = 3",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "_well_known_cache = TTLCache(\"well-known\")",
            "_had_valid_well_known_cache = TTLCache(\"had-valid-well-known\")",
            "",
            "",
            "@attr.s(slots=True, frozen=True)",
            "class WellKnownLookupResult:",
            "    delegated_server = attr.ib()",
            "",
            "",
            "class WellKnownResolver:",
            "    \"\"\"Handles well-known lookups for matrix servers.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorTime,",
            "        agent: IAgent,",
            "        user_agent: bytes,",
            "        well_known_cache: Optional[TTLCache] = None,",
            "        had_well_known_cache: Optional[TTLCache] = None,",
            "    ):",
            "        self._reactor = reactor",
            "        self._clock = Clock(reactor)",
            "",
            "        if well_known_cache is None:",
            "            well_known_cache = _well_known_cache",
            "",
            "        if had_well_known_cache is None:",
            "            had_well_known_cache = _had_valid_well_known_cache",
            "",
            "        self._well_known_cache = well_known_cache",
            "        self._had_valid_well_known_cache = had_well_known_cache",
            "        self._well_known_agent = RedirectAgent(agent)",
            "        self.user_agent = user_agent",
            "",
            "    async def get_well_known(self, server_name: bytes) -> WellKnownLookupResult:",
            "        \"\"\"Attempt to fetch and parse a .well-known file for the given server",
            "",
            "        Args:",
            "            server_name: name of the server, from the requested url",
            "",
            "        Returns:",
            "            The result of the lookup",
            "        \"\"\"",
            "        try:",
            "            prev_result, expiry, ttl = self._well_known_cache.get_with_expiry(",
            "                server_name",
            "            )",
            "",
            "            now = self._clock.time()",
            "            if now < expiry - WELL_KNOWN_GRACE_PERIOD_FACTOR * ttl:",
            "                return WellKnownLookupResult(delegated_server=prev_result)",
            "        except KeyError:",
            "            prev_result = None",
            "",
            "        # TODO: should we linearise so that we don't end up doing two .well-known",
            "        # requests for the same server in parallel?",
            "        try:",
            "            with Measure(self._clock, \"get_well_known\"):",
            "                result, cache_period = await self._fetch_well_known(",
            "                    server_name",
            "                )  # type: Optional[bytes], float",
            "",
            "        except _FetchWellKnownFailure as e:",
            "            if prev_result and e.temporary:",
            "                # This is a temporary failure and we have a still valid cached",
            "                # result, so lets return that. Hopefully the next time we ask",
            "                # the remote will be back up again.",
            "                return WellKnownLookupResult(delegated_server=prev_result)",
            "",
            "            result = None",
            "",
            "            if self._had_valid_well_known_cache.get(server_name, False):",
            "                # We have recently seen a valid well-known record for this",
            "                # server, so we cache the lack of well-known for a shorter time.",
            "                cache_period = WELL_KNOWN_DOWN_CACHE_PERIOD",
            "            else:",
            "                cache_period = WELL_KNOWN_INVALID_CACHE_PERIOD",
            "",
            "            # add some randomness to the TTL to avoid a stampeding herd",
            "            cache_period *= random.uniform(",
            "                1 - WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "                1 + WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "            )",
            "",
            "        if cache_period > 0:",
            "            self._well_known_cache.set(server_name, result, cache_period)",
            "",
            "        return WellKnownLookupResult(delegated_server=result)",
            "",
            "    async def _fetch_well_known(self, server_name: bytes) -> Tuple[bytes, float]:",
            "        \"\"\"Actually fetch and parse a .well-known, without checking the cache",
            "",
            "        Args:",
            "            server_name: name of the server, from the requested url",
            "",
            "        Raises:",
            "            _FetchWellKnownFailure if we fail to lookup a result",
            "",
            "        Returns:",
            "            The lookup result and cache period.",
            "        \"\"\"",
            "",
            "        had_valid_well_known = self._had_valid_well_known_cache.get(server_name, False)",
            "",
            "        # We do this in two steps to differentiate between possibly transient",
            "        # errors (e.g. can't connect to host, 503 response) and more permanent",
            "        # errors (such as getting a 404 response).",
            "        response, body = await self._make_well_known_request(",
            "            server_name, retry=had_valid_well_known",
            "        )",
            "",
            "        try:",
            "            if response.code != 200:",
            "                raise Exception(\"Non-200 response %s\" % (response.code,))",
            "",
            "            parsed_body = json_decoder.decode(body.decode(\"utf-8\"))",
            "            logger.info(\"Response from .well-known: %s\", parsed_body)",
            "",
            "            result = parsed_body[\"m.server\"].encode(\"ascii\")",
            "        except defer.CancelledError:",
            "            # Bail if we've been cancelled",
            "            raise",
            "        except Exception as e:",
            "            logger.info(\"Error parsing well-known for %s: %s\", server_name, e)",
            "            raise _FetchWellKnownFailure(temporary=False)",
            "",
            "        cache_period = _cache_period_from_headers(",
            "            response.headers, time_now=self._reactor.seconds",
            "        )",
            "        if cache_period is None:",
            "            cache_period = WELL_KNOWN_DEFAULT_CACHE_PERIOD",
            "            # add some randomness to the TTL to avoid a stampeding herd every 24 hours",
            "            # after startup",
            "            cache_period *= random.uniform(",
            "                1 - WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "                1 + WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER,",
            "            )",
            "        else:",
            "            cache_period = min(cache_period, WELL_KNOWN_MAX_CACHE_PERIOD)",
            "            cache_period = max(cache_period, WELL_KNOWN_MIN_CACHE_PERIOD)",
            "",
            "        # We got a success, mark as such in the cache",
            "        self._had_valid_well_known_cache.set(",
            "            server_name,",
            "            bool(result),",
            "            cache_period + WELL_KNOWN_REMEMBER_DOMAIN_HAD_VALID,",
            "        )",
            "",
            "        return result, cache_period",
            "",
            "    async def _make_well_known_request(",
            "        self, server_name: bytes, retry: bool",
            "    ) -> Tuple[IResponse, bytes]:",
            "        \"\"\"Make the well known request.",
            "",
            "        This will retry the request if requested and it fails (with unable",
            "        to connect or receives a 5xx error).",
            "",
            "        Args:",
            "            server_name: name of the server, from the requested url",
            "            retry: Whether to retry the request if it fails.",
            "",
            "        Raises:",
            "            _FetchWellKnownFailure if we fail to lookup a result",
            "",
            "        Returns:",
            "            Returns the response object and body. Response may be a non-200 response.",
            "        \"\"\"",
            "        uri = b\"https://%s/.well-known/matrix/server\" % (server_name,)",
            "        uri_str = uri.decode(\"ascii\")",
            "",
            "        headers = {",
            "            b\"User-Agent\": [self.user_agent],",
            "        }",
            "",
            "        i = 0",
            "        while True:",
            "            i += 1",
            "",
            "            logger.info(\"Fetching %s\", uri_str)",
            "            try:",
            "                response = await make_deferred_yieldable(",
            "                    self._well_known_agent.request(",
            "                        b\"GET\", uri, headers=Headers(headers)",
            "                    )",
            "                )",
            "                body_stream = BytesIO()",
            "                await make_deferred_yieldable(",
            "                    read_body_with_max_size(response, body_stream, WELL_KNOWN_MAX_SIZE)",
            "                )",
            "                body = body_stream.getvalue()",
            "",
            "                if 500 <= response.code < 600:",
            "                    raise Exception(\"Non-200 response %s\" % (response.code,))",
            "",
            "                return response, body",
            "            except defer.CancelledError:",
            "                # Bail if we've been cancelled",
            "                raise",
            "            except BodyExceededMaxSize:",
            "                # If the well-known file was too large, do not keep attempting",
            "                # to download it, but consider it a temporary error.",
            "                logger.warning(",
            "                    \"Requested .well-known file for %s is too large > %r bytes\",",
            "                    server_name.decode(\"ascii\"),",
            "                    WELL_KNOWN_MAX_SIZE,",
            "                )",
            "                raise _FetchWellKnownFailure(temporary=True)",
            "            except Exception as e:",
            "                if not retry or i >= WELL_KNOWN_RETRY_ATTEMPTS:",
            "                    logger.info(\"Error fetching %s: %s\", uri_str, e)",
            "                    raise _FetchWellKnownFailure(temporary=True)",
            "",
            "                logger.info(\"Error fetching %s: %s. Retrying\", uri_str, e)",
            "",
            "            # Sleep briefly in the hopes that they come back up",
            "            await self._clock.sleep(0.5)",
            "",
            "",
            "def _cache_period_from_headers(",
            "    headers: Headers, time_now: Callable[[], float] = time.time",
            ") -> Optional[float]:",
            "    cache_controls = _parse_cache_control(headers)",
            "",
            "    if b\"no-store\" in cache_controls:",
            "        return 0",
            "",
            "    if b\"max-age\" in cache_controls:",
            "        max_age = cache_controls[b\"max-age\"]",
            "        if max_age:",
            "            try:",
            "                return int(max_age)",
            "            except ValueError:",
            "                pass",
            "",
            "    expires = headers.getRawHeaders(b\"expires\")",
            "    if expires is not None:",
            "        try:",
            "            expires_date = stringToDatetime(expires[-1])",
            "            return expires_date - time_now()",
            "        except ValueError:",
            "            # RFC7234 says 'A cache recipient MUST interpret invalid date formats,",
            "            # especially the value \"0\", as representing a time in the past (i.e.,",
            "            # \"already expired\").",
            "            return 0",
            "",
            "    return None",
            "",
            "",
            "def _parse_cache_control(headers: Headers) -> Dict[bytes, Optional[bytes]]:",
            "    cache_controls = {}",
            "    for hdr in headers.getRawHeaders(b\"cache-control\", []):",
            "        for directive in hdr.split(b\",\"):",
            "            splits = [x.strip() for x in directive.split(b\"=\", 1)]",
            "            k = splits[0].lower()",
            "            v = splits[1] if len(splits) > 1 else None",
            "            cache_controls[k] = v",
            "    return cache_controls",
            "",
            "",
            "@attr.s(slots=True)",
            "class _FetchWellKnownFailure(Exception):",
            "    # True if we didn't get a non-5xx HTTP response, i.e. this may or may not be",
            "    # a temporary failure.",
            "    temporary = attr.ib()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [],
            "253": [
                "WellKnownResolver"
            ]
        },
        "addLocation": []
    },
    "synapse/http/matrixfederationclient.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " import synapse.metrics"
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " import synapse.util.retryutils"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " from synapse.api.errors import ("
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    Codes,"
            },
            "4": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     FederationDeniedError,"
            },
            "5": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     HttpResponseException,"
            },
            "6": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     RequestSendFailed,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    SynapseError,"
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " )"
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " from synapse.http import QuieterFileBodyProducer"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " from synapse.http.client import ("
            },
            "11": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     BlacklistingAgentWrapper,"
            },
            "12": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     BlacklistingReactorWrapper,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    BodyExceededMaxSize,"
            },
            "14": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     encode_query_args,"
            },
            "15": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    readBodyToFile,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    read_body_with_max_size,"
            },
            "17": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " )"
            },
            "18": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " from synapse.http.federation.matrix_federation_agent import MatrixFederationAgent"
            },
            "19": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " from synapse.logging.context import make_deferred_yieldable"
            },
            "20": {
                "beforePatchRowNumber": 975,
                "afterPatchRowNumber": 978,
                "PatchRowcode": "         headers = dict(response.headers.getAllRawHeaders())"
            },
            "21": {
                "beforePatchRowNumber": 976,
                "afterPatchRowNumber": 979,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 977,
                "afterPatchRowNumber": 980,
                "PatchRowcode": "         try:"
            },
            "23": {
                "beforePatchRowNumber": 978,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            d = readBodyToFile(response, output_stream, max_size)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 981,
                "PatchRowcode": "+            d = read_body_with_max_size(response, output_stream, max_size)"
            },
            "25": {
                "beforePatchRowNumber": 979,
                "afterPatchRowNumber": 982,
                "PatchRowcode": "             d.addTimeout(self.default_timeout, self.reactor)"
            },
            "26": {
                "beforePatchRowNumber": 980,
                "afterPatchRowNumber": 983,
                "PatchRowcode": "             length = await make_deferred_yieldable(d)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 984,
                "PatchRowcode": "+        except BodyExceededMaxSize:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 985,
                "PatchRowcode": "+            msg = \"Requested file is too large > %r bytes\" % (max_size,)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 986,
                "PatchRowcode": "+            logger.warning("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 987,
                "PatchRowcode": "+                \"{%s} [%s] %s\", request.txn_id, request.destination, msg,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 988,
                "PatchRowcode": "+            )"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 989,
                "PatchRowcode": "+            SynapseError(502, msg, Codes.TOO_LARGE)"
            },
            "33": {
                "beforePatchRowNumber": 981,
                "afterPatchRowNumber": 990,
                "PatchRowcode": "         except Exception as e:"
            },
            "34": {
                "beforePatchRowNumber": 982,
                "afterPatchRowNumber": 991,
                "PatchRowcode": "             logger.warning("
            },
            "35": {
                "beforePatchRowNumber": 983,
                "afterPatchRowNumber": 992,
                "PatchRowcode": "                 \"{%s} [%s] Error reading response: %s\","
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import cgi",
            "import logging",
            "import random",
            "import sys",
            "import urllib.parse",
            "from io import BytesIO",
            "from typing import Callable, Dict, List, Optional, Tuple, Union",
            "",
            "import attr",
            "import treq",
            "from canonicaljson import encode_canonical_json",
            "from prometheus_client import Counter",
            "from signedjson.sign import sign_json",
            "",
            "from twisted.internet import defer",
            "from twisted.internet.error import DNSLookupError",
            "from twisted.internet.interfaces import IReactorTime",
            "from twisted.internet.task import _EPSILON, Cooperator",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IBodyProducer, IResponse",
            "",
            "import synapse.metrics",
            "import synapse.util.retryutils",
            "from synapse.api.errors import (",
            "    FederationDeniedError,",
            "    HttpResponseException,",
            "    RequestSendFailed,",
            ")",
            "from synapse.http import QuieterFileBodyProducer",
            "from synapse.http.client import (",
            "    BlacklistingAgentWrapper,",
            "    BlacklistingReactorWrapper,",
            "    encode_query_args,",
            "    readBodyToFile,",
            ")",
            "from synapse.http.federation.matrix_federation_agent import MatrixFederationAgent",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.logging.opentracing import (",
            "    inject_active_span_byte_dict,",
            "    set_tag,",
            "    start_active_span,",
            "    tags,",
            ")",
            "from synapse.types import JsonDict",
            "from synapse.util import json_decoder",
            "from synapse.util.async_helpers import timeout_deferred",
            "from synapse.util.metrics import Measure",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "outgoing_requests_counter = Counter(",
            "    \"synapse_http_matrixfederationclient_requests\", \"\", [\"method\"]",
            ")",
            "incoming_responses_counter = Counter(",
            "    \"synapse_http_matrixfederationclient_responses\", \"\", [\"method\", \"code\"]",
            ")",
            "",
            "",
            "MAX_LONG_RETRIES = 10",
            "MAX_SHORT_RETRIES = 3",
            "MAXINT = sys.maxsize",
            "",
            "",
            "_next_id = 1",
            "",
            "",
            "QueryArgs = Dict[str, Union[str, List[str]]]",
            "",
            "",
            "@attr.s(slots=True, frozen=True)",
            "class MatrixFederationRequest:",
            "    method = attr.ib(type=str)",
            "    \"\"\"HTTP method",
            "    \"\"\"",
            "",
            "    path = attr.ib(type=str)",
            "    \"\"\"HTTP path",
            "    \"\"\"",
            "",
            "    destination = attr.ib(type=str)",
            "    \"\"\"The remote server to send the HTTP request to.",
            "    \"\"\"",
            "",
            "    json = attr.ib(default=None, type=Optional[JsonDict])",
            "    \"\"\"JSON to send in the body.",
            "    \"\"\"",
            "",
            "    json_callback = attr.ib(default=None, type=Optional[Callable[[], JsonDict]])",
            "    \"\"\"A callback to generate the JSON.",
            "    \"\"\"",
            "",
            "    query = attr.ib(default=None, type=Optional[dict])",
            "    \"\"\"Query arguments.",
            "    \"\"\"",
            "",
            "    txn_id = attr.ib(default=None, type=Optional[str])",
            "    \"\"\"Unique ID for this request (for logging)",
            "    \"\"\"",
            "",
            "    uri = attr.ib(init=False, type=bytes)",
            "    \"\"\"The URI of this request",
            "    \"\"\"",
            "",
            "    def __attrs_post_init__(self) -> None:",
            "        global _next_id",
            "        txn_id = \"%s-O-%s\" % (self.method, _next_id)",
            "        _next_id = (_next_id + 1) % (MAXINT - 1)",
            "",
            "        object.__setattr__(self, \"txn_id\", txn_id)",
            "",
            "        destination_bytes = self.destination.encode(\"ascii\")",
            "        path_bytes = self.path.encode(\"ascii\")",
            "        if self.query:",
            "            query_bytes = encode_query_args(self.query)",
            "        else:",
            "            query_bytes = b\"\"",
            "",
            "        # The object is frozen so we can pre-compute this.",
            "        uri = urllib.parse.urlunparse(",
            "            (b\"matrix\", destination_bytes, path_bytes, None, query_bytes, b\"\")",
            "        )",
            "        object.__setattr__(self, \"uri\", uri)",
            "",
            "    def get_json(self) -> Optional[JsonDict]:",
            "        if self.json_callback:",
            "            return self.json_callback()",
            "        return self.json",
            "",
            "",
            "async def _handle_json_response(",
            "    reactor: IReactorTime,",
            "    timeout_sec: float,",
            "    request: MatrixFederationRequest,",
            "    response: IResponse,",
            "    start_ms: int,",
            ") -> JsonDict:",
            "    \"\"\"",
            "    Reads the JSON body of a response, with a timeout",
            "",
            "    Args:",
            "        reactor: twisted reactor, for the timeout",
            "        timeout_sec: number of seconds to wait for response to complete",
            "        request: the request that triggered the response",
            "        response: response to the request",
            "        start_ms: Timestamp when request was made",
            "",
            "    Returns:",
            "        The parsed JSON response",
            "    \"\"\"",
            "    try:",
            "        check_content_type_is_json(response.headers)",
            "",
            "        # Use the custom JSON decoder (partially re-implements treq.json_content).",
            "        d = treq.text_content(response, encoding=\"utf-8\")",
            "        d.addCallback(json_decoder.decode)",
            "        d = timeout_deferred(d, timeout=timeout_sec, reactor=reactor)",
            "",
            "        body = await make_deferred_yieldable(d)",
            "    except defer.TimeoutError as e:",
            "        logger.warning(",
            "            \"{%s} [%s] Timed out reading response - %s %s\",",
            "            request.txn_id,",
            "            request.destination,",
            "            request.method,",
            "            request.uri.decode(\"ascii\"),",
            "        )",
            "        raise RequestSendFailed(e, can_retry=True) from e",
            "    except Exception as e:",
            "        logger.warning(",
            "            \"{%s} [%s] Error reading response %s %s: %s\",",
            "            request.txn_id,",
            "            request.destination,",
            "            request.method,",
            "            request.uri.decode(\"ascii\"),",
            "            e,",
            "        )",
            "        raise",
            "",
            "    time_taken_secs = reactor.seconds() - start_ms / 1000",
            "",
            "    logger.info(",
            "        \"{%s} [%s] Completed request: %d %s in %.2f secs - %s %s\",",
            "        request.txn_id,",
            "        request.destination,",
            "        response.code,",
            "        response.phrase.decode(\"ascii\", errors=\"replace\"),",
            "        time_taken_secs,",
            "        request.method,",
            "        request.uri.decode(\"ascii\"),",
            "    )",
            "    return body",
            "",
            "",
            "class MatrixFederationHttpClient:",
            "    \"\"\"HTTP client used to talk to other homeservers over the federation",
            "    protocol. Send client certificates and signs requests.",
            "",
            "    Attributes:",
            "        agent (twisted.web.client.Agent): The twisted Agent used to send the",
            "            requests.",
            "    \"\"\"",
            "",
            "    def __init__(self, hs, tls_client_options_factory):",
            "        self.hs = hs",
            "        self.signing_key = hs.signing_key",
            "        self.server_name = hs.hostname",
            "",
            "        # We need to use a DNS resolver which filters out blacklisted IP",
            "        # addresses, to prevent DNS rebinding.",
            "        self.reactor = BlacklistingReactorWrapper(",
            "            hs.get_reactor(), None, hs.config.federation_ip_range_blacklist",
            "        )",
            "",
            "        user_agent = hs.version_string",
            "        if hs.config.user_agent_suffix:",
            "            user_agent = \"%s %s\" % (user_agent, hs.config.user_agent_suffix)",
            "        user_agent = user_agent.encode(\"ascii\")",
            "",
            "        self.agent = MatrixFederationAgent(",
            "            self.reactor,",
            "            tls_client_options_factory,",
            "            user_agent,",
            "            hs.config.federation_ip_range_blacklist,",
            "        )",
            "",
            "        # Use a BlacklistingAgentWrapper to prevent circumventing the IP",
            "        # blacklist via IP literals in server names",
            "        self.agent = BlacklistingAgentWrapper(",
            "            self.agent, ip_blacklist=hs.config.federation_ip_range_blacklist,",
            "        )",
            "",
            "        self.clock = hs.get_clock()",
            "        self._store = hs.get_datastore()",
            "        self.version_string_bytes = hs.version_string.encode(\"ascii\")",
            "        self.default_timeout = 60",
            "",
            "        def schedule(x):",
            "            self.reactor.callLater(_EPSILON, x)",
            "",
            "        self._cooperator = Cooperator(scheduler=schedule)",
            "",
            "    async def _send_request_with_optional_trailing_slash(",
            "        self,",
            "        request: MatrixFederationRequest,",
            "        try_trailing_slash_on_400: bool = False,",
            "        **send_request_args",
            "    ) -> IResponse:",
            "        \"\"\"Wrapper for _send_request which can optionally retry the request",
            "        upon receiving a combination of a 400 HTTP response code and a",
            "        'M_UNRECOGNIZED' errcode. This is a workaround for Synapse <= v0.99.3",
            "        due to #3622.",
            "",
            "        Args:",
            "            request: details of request to be sent",
            "            try_trailing_slash_on_400: Whether on receiving a 400",
            "                'M_UNRECOGNIZED' from the server to retry the request with a",
            "                trailing slash appended to the request path.",
            "            send_request_args: A dictionary of arguments to pass to `_send_request()`.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "",
            "        Returns:",
            "            Parsed JSON response body.",
            "        \"\"\"",
            "        try:",
            "            response = await self._send_request(request, **send_request_args)",
            "        except HttpResponseException as e:",
            "            # Received an HTTP error > 300. Check if it meets the requirements",
            "            # to retry with a trailing slash",
            "            if not try_trailing_slash_on_400:",
            "                raise",
            "",
            "            if e.code != 400 or e.to_synapse_error().errcode != \"M_UNRECOGNIZED\":",
            "                raise",
            "",
            "            # Retry with a trailing slash if we received a 400 with",
            "            # 'M_UNRECOGNIZED' which some endpoints can return when omitting a",
            "            # trailing slash on Synapse <= v0.99.3.",
            "            logger.info(\"Retrying request with trailing slash\")",
            "",
            "            # Request is frozen so we create a new instance",
            "            request = attr.evolve(request, path=request.path + \"/\")",
            "",
            "            response = await self._send_request(request, **send_request_args)",
            "",
            "        return response",
            "",
            "    async def _send_request(",
            "        self,",
            "        request: MatrixFederationRequest,",
            "        retry_on_dns_fail: bool = True,",
            "        timeout: Optional[int] = None,",
            "        long_retries: bool = False,",
            "        ignore_backoff: bool = False,",
            "        backoff_on_404: bool = False,",
            "    ) -> IResponse:",
            "        \"\"\"",
            "        Sends a request to the given server.",
            "",
            "        Args:",
            "            request: details of request to be sent",
            "",
            "            retry_on_dns_fail: true if the request should be retied on DNS failures",
            "",
            "            timeout: number of milliseconds to wait for the response headers",
            "                (including connecting to the server), *for each attempt*.",
            "                60s by default.",
            "",
            "            long_retries: whether to use the long retry algorithm.",
            "",
            "                The regular retry algorithm makes 4 attempts, with intervals",
            "                [0.5s, 1s, 2s].",
            "",
            "                The long retry algorithm makes 11 attempts, with intervals",
            "                [4s, 16s, 60s, 60s, ...]",
            "",
            "                Both algorithms add -20%/+40% jitter to the retry intervals.",
            "",
            "                Note that the above intervals are *in addition* to the time spent",
            "                waiting for the request to complete (up to `timeout` ms).",
            "",
            "                NB: the long retry algorithm takes over 20 minutes to complete, with",
            "                a default timeout of 60s!",
            "",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "",
            "            backoff_on_404: Back off if we get a 404",
            "",
            "        Returns:",
            "            Resolves with the HTTP response object on success.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        if timeout:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        if (",
            "            self.hs.config.federation_domain_whitelist is not None",
            "            and request.destination not in self.hs.config.federation_domain_whitelist",
            "        ):",
            "            raise FederationDeniedError(request.destination)",
            "",
            "        limiter = await synapse.util.retryutils.get_retry_limiter(",
            "            request.destination,",
            "            self.clock,",
            "            self._store,",
            "            backoff_on_404=backoff_on_404,",
            "            ignore_backoff=ignore_backoff,",
            "        )",
            "",
            "        method_bytes = request.method.encode(\"ascii\")",
            "        destination_bytes = request.destination.encode(\"ascii\")",
            "        path_bytes = request.path.encode(\"ascii\")",
            "        if request.query:",
            "            query_bytes = encode_query_args(request.query)",
            "        else:",
            "            query_bytes = b\"\"",
            "",
            "        scope = start_active_span(",
            "            \"outgoing-federation-request\",",
            "            tags={",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_CLIENT,",
            "                tags.PEER_ADDRESS: request.destination,",
            "                tags.HTTP_METHOD: request.method,",
            "                tags.HTTP_URL: request.path,",
            "            },",
            "            finish_on_close=True,",
            "        )",
            "",
            "        # Inject the span into the headers",
            "        headers_dict = {}  # type: Dict[bytes, List[bytes]]",
            "        inject_active_span_byte_dict(headers_dict, request.destination)",
            "",
            "        headers_dict[b\"User-Agent\"] = [self.version_string_bytes]",
            "",
            "        with limiter, scope:",
            "            # XXX: Would be much nicer to retry only at the transaction-layer",
            "            # (once we have reliable transactions in place)",
            "            if long_retries:",
            "                retries_left = MAX_LONG_RETRIES",
            "            else:",
            "                retries_left = MAX_SHORT_RETRIES",
            "",
            "            url_bytes = request.uri",
            "            url_str = url_bytes.decode(\"ascii\")",
            "",
            "            url_to_sign_bytes = urllib.parse.urlunparse(",
            "                (b\"\", b\"\", path_bytes, None, query_bytes, b\"\")",
            "            )",
            "",
            "            while True:",
            "                try:",
            "                    json = request.get_json()",
            "                    if json:",
            "                        headers_dict[b\"Content-Type\"] = [b\"application/json\"]",
            "                        auth_headers = self.build_auth_headers(",
            "                            destination_bytes, method_bytes, url_to_sign_bytes, json",
            "                        )",
            "                        data = encode_canonical_json(json)",
            "                        producer = QuieterFileBodyProducer(",
            "                            BytesIO(data), cooperator=self._cooperator",
            "                        )  # type: Optional[IBodyProducer]",
            "                    else:",
            "                        producer = None",
            "                        auth_headers = self.build_auth_headers(",
            "                            destination_bytes, method_bytes, url_to_sign_bytes",
            "                        )",
            "",
            "                    headers_dict[b\"Authorization\"] = auth_headers",
            "",
            "                    logger.debug(",
            "                        \"{%s} [%s] Sending request: %s %s; timeout %fs\",",
            "                        request.txn_id,",
            "                        request.destination,",
            "                        request.method,",
            "                        url_str,",
            "                        _sec_timeout,",
            "                    )",
            "",
            "                    outgoing_requests_counter.labels(request.method).inc()",
            "",
            "                    try:",
            "                        with Measure(self.clock, \"outbound_request\"):",
            "                            # we don't want all the fancy cookie and redirect handling",
            "                            # that treq.request gives: just use the raw Agent.",
            "                            request_deferred = self.agent.request(",
            "                                method_bytes,",
            "                                url_bytes,",
            "                                headers=Headers(headers_dict),",
            "                                bodyProducer=producer,",
            "                            )",
            "",
            "                            request_deferred = timeout_deferred(",
            "                                request_deferred,",
            "                                timeout=_sec_timeout,",
            "                                reactor=self.reactor,",
            "                            )",
            "",
            "                            response = await request_deferred",
            "                    except DNSLookupError as e:",
            "                        raise RequestSendFailed(e, can_retry=retry_on_dns_fail) from e",
            "                    except Exception as e:",
            "                        raise RequestSendFailed(e, can_retry=True) from e",
            "",
            "                    incoming_responses_counter.labels(",
            "                        request.method, response.code",
            "                    ).inc()",
            "",
            "                    set_tag(tags.HTTP_STATUS_CODE, response.code)",
            "                    response_phrase = response.phrase.decode(\"ascii\", errors=\"replace\")",
            "",
            "                    if 200 <= response.code < 300:",
            "                        logger.debug(",
            "                            \"{%s} [%s] Got response headers: %d %s\",",
            "                            request.txn_id,",
            "                            request.destination,",
            "                            response.code,",
            "                            response_phrase,",
            "                        )",
            "                        pass",
            "                    else:",
            "                        logger.info(",
            "                            \"{%s} [%s] Got response headers: %d %s\",",
            "                            request.txn_id,",
            "                            request.destination,",
            "                            response.code,",
            "                            response_phrase,",
            "                        )",
            "                        # :'(",
            "                        # Update transactions table?",
            "                        d = treq.content(response)",
            "                        d = timeout_deferred(",
            "                            d, timeout=_sec_timeout, reactor=self.reactor",
            "                        )",
            "",
            "                        try:",
            "                            body = await make_deferred_yieldable(d)",
            "                        except Exception as e:",
            "                            # Eh, we're already going to raise an exception so lets",
            "                            # ignore if this fails.",
            "                            logger.warning(",
            "                                \"{%s} [%s] Failed to get error response: %s %s: %s\",",
            "                                request.txn_id,",
            "                                request.destination,",
            "                                request.method,",
            "                                url_str,",
            "                                _flatten_response_never_received(e),",
            "                            )",
            "                            body = None",
            "",
            "                        exc = HttpResponseException(",
            "                            response.code, response_phrase, body",
            "                        )",
            "",
            "                        # Retry if the error is a 429 (Too Many Requests),",
            "                        # otherwise just raise a standard HttpResponseException",
            "                        if response.code == 429:",
            "                            raise RequestSendFailed(exc, can_retry=True) from exc",
            "                        else:",
            "                            raise exc",
            "",
            "                    break",
            "                except RequestSendFailed as e:",
            "                    logger.info(",
            "                        \"{%s} [%s] Request failed: %s %s: %s\",",
            "                        request.txn_id,",
            "                        request.destination,",
            "                        request.method,",
            "                        url_str,",
            "                        _flatten_response_never_received(e.inner_exception),",
            "                    )",
            "",
            "                    if not e.can_retry:",
            "                        raise",
            "",
            "                    if retries_left and not timeout:",
            "                        if long_retries:",
            "                            delay = 4 ** (MAX_LONG_RETRIES + 1 - retries_left)",
            "                            delay = min(delay, 60)",
            "                            delay *= random.uniform(0.8, 1.4)",
            "                        else:",
            "                            delay = 0.5 * 2 ** (MAX_SHORT_RETRIES - retries_left)",
            "                            delay = min(delay, 2)",
            "                            delay *= random.uniform(0.8, 1.4)",
            "",
            "                        logger.debug(",
            "                            \"{%s} [%s] Waiting %ss before re-sending...\",",
            "                            request.txn_id,",
            "                            request.destination,",
            "                            delay,",
            "                        )",
            "",
            "                        await self.clock.sleep(delay)",
            "                        retries_left -= 1",
            "                    else:",
            "                        raise",
            "",
            "                except Exception as e:",
            "                    logger.warning(",
            "                        \"{%s} [%s] Request failed: %s %s: %s\",",
            "                        request.txn_id,",
            "                        request.destination,",
            "                        request.method,",
            "                        url_str,",
            "                        _flatten_response_never_received(e),",
            "                    )",
            "                    raise",
            "        return response",
            "",
            "    def build_auth_headers(",
            "        self,",
            "        destination: Optional[bytes],",
            "        method: bytes,",
            "        url_bytes: bytes,",
            "        content: Optional[JsonDict] = None,",
            "        destination_is: Optional[bytes] = None,",
            "    ) -> List[bytes]:",
            "        \"\"\"",
            "        Builds the Authorization headers for a federation request",
            "        Args:",
            "            destination: The destination homeserver of the request.",
            "                May be None if the destination is an identity server, in which case",
            "                destination_is must be non-None.",
            "            method: The HTTP method of the request",
            "            url_bytes: The URI path of the request",
            "            content: The body of the request",
            "            destination_is: As 'destination', but if the destination is an",
            "                identity server",
            "",
            "        Returns:",
            "            A list of headers to be added as \"Authorization:\" headers",
            "        \"\"\"",
            "        request = {",
            "            \"method\": method.decode(\"ascii\"),",
            "            \"uri\": url_bytes.decode(\"ascii\"),",
            "            \"origin\": self.server_name,",
            "        }",
            "",
            "        if destination is not None:",
            "            request[\"destination\"] = destination.decode(\"ascii\")",
            "",
            "        if destination_is is not None:",
            "            request[\"destination_is\"] = destination_is.decode(\"ascii\")",
            "",
            "        if content is not None:",
            "            request[\"content\"] = content",
            "",
            "        request = sign_json(request, self.server_name, self.signing_key)",
            "",
            "        auth_headers = []",
            "",
            "        for key, sig in request[\"signatures\"][self.server_name].items():",
            "            auth_headers.append(",
            "                (",
            "                    'X-Matrix origin=%s,key=\"%s\",sig=\"%s\"'",
            "                    % (self.server_name, key, sig)",
            "                ).encode(\"ascii\")",
            "            )",
            "        return auth_headers",
            "",
            "    async def put_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        args: Optional[QueryArgs] = None,",
            "        data: Optional[JsonDict] = None,",
            "        json_data_callback: Optional[Callable[[], JsonDict]] = None,",
            "        long_retries: bool = False,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        backoff_on_404: bool = False,",
            "        try_trailing_slash_on_400: bool = False,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\" Sends the specified json data using PUT",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "            path: The HTTP path.",
            "            args: query params",
            "            data: A dict containing the data that will be used as",
            "                the request body. This will be encoded as JSON.",
            "            json_data_callback: A callable returning the dict to",
            "                use as the request body.",
            "",
            "            long_retries: whether to use the long retry algorithm. See",
            "                docs on _send_request for details.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "            backoff_on_404: True if we should count a 404 response as",
            "                a failure of the server (and should therefore back off future",
            "                requests).",
            "            try_trailing_slash_on_400: True if on a 400 M_UNRECOGNIZED",
            "                response we should try appending a trailing slash to the end",
            "                of the request. Workaround for #3622 in Synapse <= v0.99.3. This",
            "                will be attempted before backing off if backing off has been",
            "                enabled.",
            "",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"PUT\",",
            "            destination=destination,",
            "            path=path,",
            "            query=args,",
            "            json_callback=json_data_callback,",
            "            json=data,",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request_with_optional_trailing_slash(",
            "            request,",
            "            try_trailing_slash_on_400,",
            "            backoff_on_404=backoff_on_404,",
            "            ignore_backoff=ignore_backoff,",
            "            long_retries=long_retries,",
            "            timeout=timeout,",
            "        )",
            "",
            "        if timeout is not None:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms",
            "        )",
            "",
            "        return body",
            "",
            "    async def post_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        data: Optional[JsonDict] = None,",
            "        long_retries: bool = False,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        args: Optional[QueryArgs] = None,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\" Sends the specified json data using POST",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "",
            "            path: The HTTP path.",
            "",
            "            data: A dict containing the data that will be used as",
            "                the request body. This will be encoded as JSON.",
            "",
            "            long_retries: whether to use the long retry algorithm. See",
            "                docs on _send_request for details.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data and",
            "                try the request anyway.",
            "",
            "            args: query params",
            "        Returns:",
            "            dict|list: Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "",
            "        request = MatrixFederationRequest(",
            "            method=\"POST\", destination=destination, path=path, query=args, json=data",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request(",
            "            request,",
            "            long_retries=long_retries,",
            "            timeout=timeout,",
            "            ignore_backoff=ignore_backoff,",
            "        )",
            "",
            "        if timeout:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms,",
            "        )",
            "        return body",
            "",
            "    async def get_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        args: Optional[QueryArgs] = None,",
            "        retry_on_dns_fail: bool = True,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        try_trailing_slash_on_400: bool = False,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\" GETs some json from the given host homeserver and path",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "",
            "            path: The HTTP path.",
            "",
            "            args: A dictionary used to create query strings, defaults to",
            "                None.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "",
            "            try_trailing_slash_on_400: True if on a 400 M_UNRECOGNIZED",
            "                response we should try appending a trailing slash to the end of",
            "                the request. Workaround for #3622 in Synapse <= v0.99.3.",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"GET\", destination=destination, path=path, query=args",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request_with_optional_trailing_slash(",
            "            request,",
            "            try_trailing_slash_on_400,",
            "            backoff_on_404=False,",
            "            ignore_backoff=ignore_backoff,",
            "            retry_on_dns_fail=retry_on_dns_fail,",
            "            timeout=timeout,",
            "        )",
            "",
            "        if timeout is not None:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms",
            "        )",
            "",
            "        return body",
            "",
            "    async def delete_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        long_retries: bool = False,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        args: Optional[QueryArgs] = None,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\"Send a DELETE request to the remote expecting some json response",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "            path: The HTTP path.",
            "",
            "            long_retries: whether to use the long retry algorithm. See",
            "                docs on _send_request for details.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data and",
            "                try the request anyway.",
            "",
            "            args: query params",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"DELETE\", destination=destination, path=path, query=args",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request(",
            "            request,",
            "            long_retries=long_retries,",
            "            timeout=timeout,",
            "            ignore_backoff=ignore_backoff,",
            "        )",
            "",
            "        if timeout is not None:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms",
            "        )",
            "        return body",
            "",
            "    async def get_file(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        output_stream,",
            "        args: Optional[QueryArgs] = None,",
            "        retry_on_dns_fail: bool = True,",
            "        max_size: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "    ) -> Tuple[int, Dict[bytes, List[bytes]]]:",
            "        \"\"\"GETs a file from a given homeserver",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "            path: The HTTP path to GET.",
            "            output_stream: File to write the response body to.",
            "            args: Optional dictionary used to create the query string.",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "",
            "        Returns:",
            "            Resolves with an (int,dict) tuple of",
            "            the file length and a dict of the response headers.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"GET\", destination=destination, path=path, query=args",
            "        )",
            "",
            "        response = await self._send_request(",
            "            request, retry_on_dns_fail=retry_on_dns_fail, ignore_backoff=ignore_backoff",
            "        )",
            "",
            "        headers = dict(response.headers.getAllRawHeaders())",
            "",
            "        try:",
            "            d = readBodyToFile(response, output_stream, max_size)",
            "            d.addTimeout(self.default_timeout, self.reactor)",
            "            length = await make_deferred_yieldable(d)",
            "        except Exception as e:",
            "            logger.warning(",
            "                \"{%s} [%s] Error reading response: %s\",",
            "                request.txn_id,",
            "                request.destination,",
            "                e,",
            "            )",
            "            raise",
            "        logger.info(",
            "            \"{%s} [%s] Completed: %d %s [%d bytes] %s %s\",",
            "            request.txn_id,",
            "            request.destination,",
            "            response.code,",
            "            response.phrase.decode(\"ascii\", errors=\"replace\"),",
            "            length,",
            "            request.method,",
            "            request.uri.decode(\"ascii\"),",
            "        )",
            "        return (length, headers)",
            "",
            "",
            "def _flatten_response_never_received(e):",
            "    if hasattr(e, \"reasons\"):",
            "        reasons = \", \".join(",
            "            _flatten_response_never_received(f.value) for f in e.reasons",
            "        )",
            "",
            "        return \"%s:[%s]\" % (type(e).__name__, reasons)",
            "    else:",
            "        return repr(e)",
            "",
            "",
            "def check_content_type_is_json(headers: Headers) -> None:",
            "    \"\"\"",
            "    Check that a set of HTTP headers have a Content-Type header, and that it",
            "    is application/json.",
            "",
            "    Args:",
            "        headers: headers to check",
            "",
            "    Raises:",
            "        RequestSendFailed: if the Content-Type header is missing or isn't JSON",
            "",
            "    \"\"\"",
            "    c_type = headers.getRawHeaders(b\"Content-Type\")",
            "    if c_type is None:",
            "        raise RequestSendFailed(",
            "            RuntimeError(\"No Content-Type header received from remote server\"),",
            "            can_retry=False,",
            "        )",
            "",
            "    c_type = c_type[0].decode(\"ascii\")  # only the first header",
            "    val, options = cgi.parse_header(c_type)",
            "    if val != \"application/json\":",
            "        raise RequestSendFailed(",
            "            RuntimeError(",
            "                \"Remote server sent Content-Type header of '%s', not 'application/json'\"",
            "                % c_type,",
            "            ),",
            "            can_retry=False,",
            "        )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import cgi",
            "import logging",
            "import random",
            "import sys",
            "import urllib.parse",
            "from io import BytesIO",
            "from typing import Callable, Dict, List, Optional, Tuple, Union",
            "",
            "import attr",
            "import treq",
            "from canonicaljson import encode_canonical_json",
            "from prometheus_client import Counter",
            "from signedjson.sign import sign_json",
            "",
            "from twisted.internet import defer",
            "from twisted.internet.error import DNSLookupError",
            "from twisted.internet.interfaces import IReactorTime",
            "from twisted.internet.task import _EPSILON, Cooperator",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IBodyProducer, IResponse",
            "",
            "import synapse.metrics",
            "import synapse.util.retryutils",
            "from synapse.api.errors import (",
            "    Codes,",
            "    FederationDeniedError,",
            "    HttpResponseException,",
            "    RequestSendFailed,",
            "    SynapseError,",
            ")",
            "from synapse.http import QuieterFileBodyProducer",
            "from synapse.http.client import (",
            "    BlacklistingAgentWrapper,",
            "    BlacklistingReactorWrapper,",
            "    BodyExceededMaxSize,",
            "    encode_query_args,",
            "    read_body_with_max_size,",
            ")",
            "from synapse.http.federation.matrix_federation_agent import MatrixFederationAgent",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.logging.opentracing import (",
            "    inject_active_span_byte_dict,",
            "    set_tag,",
            "    start_active_span,",
            "    tags,",
            ")",
            "from synapse.types import JsonDict",
            "from synapse.util import json_decoder",
            "from synapse.util.async_helpers import timeout_deferred",
            "from synapse.util.metrics import Measure",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "outgoing_requests_counter = Counter(",
            "    \"synapse_http_matrixfederationclient_requests\", \"\", [\"method\"]",
            ")",
            "incoming_responses_counter = Counter(",
            "    \"synapse_http_matrixfederationclient_responses\", \"\", [\"method\", \"code\"]",
            ")",
            "",
            "",
            "MAX_LONG_RETRIES = 10",
            "MAX_SHORT_RETRIES = 3",
            "MAXINT = sys.maxsize",
            "",
            "",
            "_next_id = 1",
            "",
            "",
            "QueryArgs = Dict[str, Union[str, List[str]]]",
            "",
            "",
            "@attr.s(slots=True, frozen=True)",
            "class MatrixFederationRequest:",
            "    method = attr.ib(type=str)",
            "    \"\"\"HTTP method",
            "    \"\"\"",
            "",
            "    path = attr.ib(type=str)",
            "    \"\"\"HTTP path",
            "    \"\"\"",
            "",
            "    destination = attr.ib(type=str)",
            "    \"\"\"The remote server to send the HTTP request to.",
            "    \"\"\"",
            "",
            "    json = attr.ib(default=None, type=Optional[JsonDict])",
            "    \"\"\"JSON to send in the body.",
            "    \"\"\"",
            "",
            "    json_callback = attr.ib(default=None, type=Optional[Callable[[], JsonDict]])",
            "    \"\"\"A callback to generate the JSON.",
            "    \"\"\"",
            "",
            "    query = attr.ib(default=None, type=Optional[dict])",
            "    \"\"\"Query arguments.",
            "    \"\"\"",
            "",
            "    txn_id = attr.ib(default=None, type=Optional[str])",
            "    \"\"\"Unique ID for this request (for logging)",
            "    \"\"\"",
            "",
            "    uri = attr.ib(init=False, type=bytes)",
            "    \"\"\"The URI of this request",
            "    \"\"\"",
            "",
            "    def __attrs_post_init__(self) -> None:",
            "        global _next_id",
            "        txn_id = \"%s-O-%s\" % (self.method, _next_id)",
            "        _next_id = (_next_id + 1) % (MAXINT - 1)",
            "",
            "        object.__setattr__(self, \"txn_id\", txn_id)",
            "",
            "        destination_bytes = self.destination.encode(\"ascii\")",
            "        path_bytes = self.path.encode(\"ascii\")",
            "        if self.query:",
            "            query_bytes = encode_query_args(self.query)",
            "        else:",
            "            query_bytes = b\"\"",
            "",
            "        # The object is frozen so we can pre-compute this.",
            "        uri = urllib.parse.urlunparse(",
            "            (b\"matrix\", destination_bytes, path_bytes, None, query_bytes, b\"\")",
            "        )",
            "        object.__setattr__(self, \"uri\", uri)",
            "",
            "    def get_json(self) -> Optional[JsonDict]:",
            "        if self.json_callback:",
            "            return self.json_callback()",
            "        return self.json",
            "",
            "",
            "async def _handle_json_response(",
            "    reactor: IReactorTime,",
            "    timeout_sec: float,",
            "    request: MatrixFederationRequest,",
            "    response: IResponse,",
            "    start_ms: int,",
            ") -> JsonDict:",
            "    \"\"\"",
            "    Reads the JSON body of a response, with a timeout",
            "",
            "    Args:",
            "        reactor: twisted reactor, for the timeout",
            "        timeout_sec: number of seconds to wait for response to complete",
            "        request: the request that triggered the response",
            "        response: response to the request",
            "        start_ms: Timestamp when request was made",
            "",
            "    Returns:",
            "        The parsed JSON response",
            "    \"\"\"",
            "    try:",
            "        check_content_type_is_json(response.headers)",
            "",
            "        # Use the custom JSON decoder (partially re-implements treq.json_content).",
            "        d = treq.text_content(response, encoding=\"utf-8\")",
            "        d.addCallback(json_decoder.decode)",
            "        d = timeout_deferred(d, timeout=timeout_sec, reactor=reactor)",
            "",
            "        body = await make_deferred_yieldable(d)",
            "    except defer.TimeoutError as e:",
            "        logger.warning(",
            "            \"{%s} [%s] Timed out reading response - %s %s\",",
            "            request.txn_id,",
            "            request.destination,",
            "            request.method,",
            "            request.uri.decode(\"ascii\"),",
            "        )",
            "        raise RequestSendFailed(e, can_retry=True) from e",
            "    except Exception as e:",
            "        logger.warning(",
            "            \"{%s} [%s] Error reading response %s %s: %s\",",
            "            request.txn_id,",
            "            request.destination,",
            "            request.method,",
            "            request.uri.decode(\"ascii\"),",
            "            e,",
            "        )",
            "        raise",
            "",
            "    time_taken_secs = reactor.seconds() - start_ms / 1000",
            "",
            "    logger.info(",
            "        \"{%s} [%s] Completed request: %d %s in %.2f secs - %s %s\",",
            "        request.txn_id,",
            "        request.destination,",
            "        response.code,",
            "        response.phrase.decode(\"ascii\", errors=\"replace\"),",
            "        time_taken_secs,",
            "        request.method,",
            "        request.uri.decode(\"ascii\"),",
            "    )",
            "    return body",
            "",
            "",
            "class MatrixFederationHttpClient:",
            "    \"\"\"HTTP client used to talk to other homeservers over the federation",
            "    protocol. Send client certificates and signs requests.",
            "",
            "    Attributes:",
            "        agent (twisted.web.client.Agent): The twisted Agent used to send the",
            "            requests.",
            "    \"\"\"",
            "",
            "    def __init__(self, hs, tls_client_options_factory):",
            "        self.hs = hs",
            "        self.signing_key = hs.signing_key",
            "        self.server_name = hs.hostname",
            "",
            "        # We need to use a DNS resolver which filters out blacklisted IP",
            "        # addresses, to prevent DNS rebinding.",
            "        self.reactor = BlacklistingReactorWrapper(",
            "            hs.get_reactor(), None, hs.config.federation_ip_range_blacklist",
            "        )",
            "",
            "        user_agent = hs.version_string",
            "        if hs.config.user_agent_suffix:",
            "            user_agent = \"%s %s\" % (user_agent, hs.config.user_agent_suffix)",
            "        user_agent = user_agent.encode(\"ascii\")",
            "",
            "        self.agent = MatrixFederationAgent(",
            "            self.reactor,",
            "            tls_client_options_factory,",
            "            user_agent,",
            "            hs.config.federation_ip_range_blacklist,",
            "        )",
            "",
            "        # Use a BlacklistingAgentWrapper to prevent circumventing the IP",
            "        # blacklist via IP literals in server names",
            "        self.agent = BlacklistingAgentWrapper(",
            "            self.agent, ip_blacklist=hs.config.federation_ip_range_blacklist,",
            "        )",
            "",
            "        self.clock = hs.get_clock()",
            "        self._store = hs.get_datastore()",
            "        self.version_string_bytes = hs.version_string.encode(\"ascii\")",
            "        self.default_timeout = 60",
            "",
            "        def schedule(x):",
            "            self.reactor.callLater(_EPSILON, x)",
            "",
            "        self._cooperator = Cooperator(scheduler=schedule)",
            "",
            "    async def _send_request_with_optional_trailing_slash(",
            "        self,",
            "        request: MatrixFederationRequest,",
            "        try_trailing_slash_on_400: bool = False,",
            "        **send_request_args",
            "    ) -> IResponse:",
            "        \"\"\"Wrapper for _send_request which can optionally retry the request",
            "        upon receiving a combination of a 400 HTTP response code and a",
            "        'M_UNRECOGNIZED' errcode. This is a workaround for Synapse <= v0.99.3",
            "        due to #3622.",
            "",
            "        Args:",
            "            request: details of request to be sent",
            "            try_trailing_slash_on_400: Whether on receiving a 400",
            "                'M_UNRECOGNIZED' from the server to retry the request with a",
            "                trailing slash appended to the request path.",
            "            send_request_args: A dictionary of arguments to pass to `_send_request()`.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "",
            "        Returns:",
            "            Parsed JSON response body.",
            "        \"\"\"",
            "        try:",
            "            response = await self._send_request(request, **send_request_args)",
            "        except HttpResponseException as e:",
            "            # Received an HTTP error > 300. Check if it meets the requirements",
            "            # to retry with a trailing slash",
            "            if not try_trailing_slash_on_400:",
            "                raise",
            "",
            "            if e.code != 400 or e.to_synapse_error().errcode != \"M_UNRECOGNIZED\":",
            "                raise",
            "",
            "            # Retry with a trailing slash if we received a 400 with",
            "            # 'M_UNRECOGNIZED' which some endpoints can return when omitting a",
            "            # trailing slash on Synapse <= v0.99.3.",
            "            logger.info(\"Retrying request with trailing slash\")",
            "",
            "            # Request is frozen so we create a new instance",
            "            request = attr.evolve(request, path=request.path + \"/\")",
            "",
            "            response = await self._send_request(request, **send_request_args)",
            "",
            "        return response",
            "",
            "    async def _send_request(",
            "        self,",
            "        request: MatrixFederationRequest,",
            "        retry_on_dns_fail: bool = True,",
            "        timeout: Optional[int] = None,",
            "        long_retries: bool = False,",
            "        ignore_backoff: bool = False,",
            "        backoff_on_404: bool = False,",
            "    ) -> IResponse:",
            "        \"\"\"",
            "        Sends a request to the given server.",
            "",
            "        Args:",
            "            request: details of request to be sent",
            "",
            "            retry_on_dns_fail: true if the request should be retied on DNS failures",
            "",
            "            timeout: number of milliseconds to wait for the response headers",
            "                (including connecting to the server), *for each attempt*.",
            "                60s by default.",
            "",
            "            long_retries: whether to use the long retry algorithm.",
            "",
            "                The regular retry algorithm makes 4 attempts, with intervals",
            "                [0.5s, 1s, 2s].",
            "",
            "                The long retry algorithm makes 11 attempts, with intervals",
            "                [4s, 16s, 60s, 60s, ...]",
            "",
            "                Both algorithms add -20%/+40% jitter to the retry intervals.",
            "",
            "                Note that the above intervals are *in addition* to the time spent",
            "                waiting for the request to complete (up to `timeout` ms).",
            "",
            "                NB: the long retry algorithm takes over 20 minutes to complete, with",
            "                a default timeout of 60s!",
            "",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "",
            "            backoff_on_404: Back off if we get a 404",
            "",
            "        Returns:",
            "            Resolves with the HTTP response object on success.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        if timeout:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        if (",
            "            self.hs.config.federation_domain_whitelist is not None",
            "            and request.destination not in self.hs.config.federation_domain_whitelist",
            "        ):",
            "            raise FederationDeniedError(request.destination)",
            "",
            "        limiter = await synapse.util.retryutils.get_retry_limiter(",
            "            request.destination,",
            "            self.clock,",
            "            self._store,",
            "            backoff_on_404=backoff_on_404,",
            "            ignore_backoff=ignore_backoff,",
            "        )",
            "",
            "        method_bytes = request.method.encode(\"ascii\")",
            "        destination_bytes = request.destination.encode(\"ascii\")",
            "        path_bytes = request.path.encode(\"ascii\")",
            "        if request.query:",
            "            query_bytes = encode_query_args(request.query)",
            "        else:",
            "            query_bytes = b\"\"",
            "",
            "        scope = start_active_span(",
            "            \"outgoing-federation-request\",",
            "            tags={",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_CLIENT,",
            "                tags.PEER_ADDRESS: request.destination,",
            "                tags.HTTP_METHOD: request.method,",
            "                tags.HTTP_URL: request.path,",
            "            },",
            "            finish_on_close=True,",
            "        )",
            "",
            "        # Inject the span into the headers",
            "        headers_dict = {}  # type: Dict[bytes, List[bytes]]",
            "        inject_active_span_byte_dict(headers_dict, request.destination)",
            "",
            "        headers_dict[b\"User-Agent\"] = [self.version_string_bytes]",
            "",
            "        with limiter, scope:",
            "            # XXX: Would be much nicer to retry only at the transaction-layer",
            "            # (once we have reliable transactions in place)",
            "            if long_retries:",
            "                retries_left = MAX_LONG_RETRIES",
            "            else:",
            "                retries_left = MAX_SHORT_RETRIES",
            "",
            "            url_bytes = request.uri",
            "            url_str = url_bytes.decode(\"ascii\")",
            "",
            "            url_to_sign_bytes = urllib.parse.urlunparse(",
            "                (b\"\", b\"\", path_bytes, None, query_bytes, b\"\")",
            "            )",
            "",
            "            while True:",
            "                try:",
            "                    json = request.get_json()",
            "                    if json:",
            "                        headers_dict[b\"Content-Type\"] = [b\"application/json\"]",
            "                        auth_headers = self.build_auth_headers(",
            "                            destination_bytes, method_bytes, url_to_sign_bytes, json",
            "                        )",
            "                        data = encode_canonical_json(json)",
            "                        producer = QuieterFileBodyProducer(",
            "                            BytesIO(data), cooperator=self._cooperator",
            "                        )  # type: Optional[IBodyProducer]",
            "                    else:",
            "                        producer = None",
            "                        auth_headers = self.build_auth_headers(",
            "                            destination_bytes, method_bytes, url_to_sign_bytes",
            "                        )",
            "",
            "                    headers_dict[b\"Authorization\"] = auth_headers",
            "",
            "                    logger.debug(",
            "                        \"{%s} [%s] Sending request: %s %s; timeout %fs\",",
            "                        request.txn_id,",
            "                        request.destination,",
            "                        request.method,",
            "                        url_str,",
            "                        _sec_timeout,",
            "                    )",
            "",
            "                    outgoing_requests_counter.labels(request.method).inc()",
            "",
            "                    try:",
            "                        with Measure(self.clock, \"outbound_request\"):",
            "                            # we don't want all the fancy cookie and redirect handling",
            "                            # that treq.request gives: just use the raw Agent.",
            "                            request_deferred = self.agent.request(",
            "                                method_bytes,",
            "                                url_bytes,",
            "                                headers=Headers(headers_dict),",
            "                                bodyProducer=producer,",
            "                            )",
            "",
            "                            request_deferred = timeout_deferred(",
            "                                request_deferred,",
            "                                timeout=_sec_timeout,",
            "                                reactor=self.reactor,",
            "                            )",
            "",
            "                            response = await request_deferred",
            "                    except DNSLookupError as e:",
            "                        raise RequestSendFailed(e, can_retry=retry_on_dns_fail) from e",
            "                    except Exception as e:",
            "                        raise RequestSendFailed(e, can_retry=True) from e",
            "",
            "                    incoming_responses_counter.labels(",
            "                        request.method, response.code",
            "                    ).inc()",
            "",
            "                    set_tag(tags.HTTP_STATUS_CODE, response.code)",
            "                    response_phrase = response.phrase.decode(\"ascii\", errors=\"replace\")",
            "",
            "                    if 200 <= response.code < 300:",
            "                        logger.debug(",
            "                            \"{%s} [%s] Got response headers: %d %s\",",
            "                            request.txn_id,",
            "                            request.destination,",
            "                            response.code,",
            "                            response_phrase,",
            "                        )",
            "                        pass",
            "                    else:",
            "                        logger.info(",
            "                            \"{%s} [%s] Got response headers: %d %s\",",
            "                            request.txn_id,",
            "                            request.destination,",
            "                            response.code,",
            "                            response_phrase,",
            "                        )",
            "                        # :'(",
            "                        # Update transactions table?",
            "                        d = treq.content(response)",
            "                        d = timeout_deferred(",
            "                            d, timeout=_sec_timeout, reactor=self.reactor",
            "                        )",
            "",
            "                        try:",
            "                            body = await make_deferred_yieldable(d)",
            "                        except Exception as e:",
            "                            # Eh, we're already going to raise an exception so lets",
            "                            # ignore if this fails.",
            "                            logger.warning(",
            "                                \"{%s} [%s] Failed to get error response: %s %s: %s\",",
            "                                request.txn_id,",
            "                                request.destination,",
            "                                request.method,",
            "                                url_str,",
            "                                _flatten_response_never_received(e),",
            "                            )",
            "                            body = None",
            "",
            "                        exc = HttpResponseException(",
            "                            response.code, response_phrase, body",
            "                        )",
            "",
            "                        # Retry if the error is a 429 (Too Many Requests),",
            "                        # otherwise just raise a standard HttpResponseException",
            "                        if response.code == 429:",
            "                            raise RequestSendFailed(exc, can_retry=True) from exc",
            "                        else:",
            "                            raise exc",
            "",
            "                    break",
            "                except RequestSendFailed as e:",
            "                    logger.info(",
            "                        \"{%s} [%s] Request failed: %s %s: %s\",",
            "                        request.txn_id,",
            "                        request.destination,",
            "                        request.method,",
            "                        url_str,",
            "                        _flatten_response_never_received(e.inner_exception),",
            "                    )",
            "",
            "                    if not e.can_retry:",
            "                        raise",
            "",
            "                    if retries_left and not timeout:",
            "                        if long_retries:",
            "                            delay = 4 ** (MAX_LONG_RETRIES + 1 - retries_left)",
            "                            delay = min(delay, 60)",
            "                            delay *= random.uniform(0.8, 1.4)",
            "                        else:",
            "                            delay = 0.5 * 2 ** (MAX_SHORT_RETRIES - retries_left)",
            "                            delay = min(delay, 2)",
            "                            delay *= random.uniform(0.8, 1.4)",
            "",
            "                        logger.debug(",
            "                            \"{%s} [%s] Waiting %ss before re-sending...\",",
            "                            request.txn_id,",
            "                            request.destination,",
            "                            delay,",
            "                        )",
            "",
            "                        await self.clock.sleep(delay)",
            "                        retries_left -= 1",
            "                    else:",
            "                        raise",
            "",
            "                except Exception as e:",
            "                    logger.warning(",
            "                        \"{%s} [%s] Request failed: %s %s: %s\",",
            "                        request.txn_id,",
            "                        request.destination,",
            "                        request.method,",
            "                        url_str,",
            "                        _flatten_response_never_received(e),",
            "                    )",
            "                    raise",
            "        return response",
            "",
            "    def build_auth_headers(",
            "        self,",
            "        destination: Optional[bytes],",
            "        method: bytes,",
            "        url_bytes: bytes,",
            "        content: Optional[JsonDict] = None,",
            "        destination_is: Optional[bytes] = None,",
            "    ) -> List[bytes]:",
            "        \"\"\"",
            "        Builds the Authorization headers for a federation request",
            "        Args:",
            "            destination: The destination homeserver of the request.",
            "                May be None if the destination is an identity server, in which case",
            "                destination_is must be non-None.",
            "            method: The HTTP method of the request",
            "            url_bytes: The URI path of the request",
            "            content: The body of the request",
            "            destination_is: As 'destination', but if the destination is an",
            "                identity server",
            "",
            "        Returns:",
            "            A list of headers to be added as \"Authorization:\" headers",
            "        \"\"\"",
            "        request = {",
            "            \"method\": method.decode(\"ascii\"),",
            "            \"uri\": url_bytes.decode(\"ascii\"),",
            "            \"origin\": self.server_name,",
            "        }",
            "",
            "        if destination is not None:",
            "            request[\"destination\"] = destination.decode(\"ascii\")",
            "",
            "        if destination_is is not None:",
            "            request[\"destination_is\"] = destination_is.decode(\"ascii\")",
            "",
            "        if content is not None:",
            "            request[\"content\"] = content",
            "",
            "        request = sign_json(request, self.server_name, self.signing_key)",
            "",
            "        auth_headers = []",
            "",
            "        for key, sig in request[\"signatures\"][self.server_name].items():",
            "            auth_headers.append(",
            "                (",
            "                    'X-Matrix origin=%s,key=\"%s\",sig=\"%s\"'",
            "                    % (self.server_name, key, sig)",
            "                ).encode(\"ascii\")",
            "            )",
            "        return auth_headers",
            "",
            "    async def put_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        args: Optional[QueryArgs] = None,",
            "        data: Optional[JsonDict] = None,",
            "        json_data_callback: Optional[Callable[[], JsonDict]] = None,",
            "        long_retries: bool = False,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        backoff_on_404: bool = False,",
            "        try_trailing_slash_on_400: bool = False,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\" Sends the specified json data using PUT",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "            path: The HTTP path.",
            "            args: query params",
            "            data: A dict containing the data that will be used as",
            "                the request body. This will be encoded as JSON.",
            "            json_data_callback: A callable returning the dict to",
            "                use as the request body.",
            "",
            "            long_retries: whether to use the long retry algorithm. See",
            "                docs on _send_request for details.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "            backoff_on_404: True if we should count a 404 response as",
            "                a failure of the server (and should therefore back off future",
            "                requests).",
            "            try_trailing_slash_on_400: True if on a 400 M_UNRECOGNIZED",
            "                response we should try appending a trailing slash to the end",
            "                of the request. Workaround for #3622 in Synapse <= v0.99.3. This",
            "                will be attempted before backing off if backing off has been",
            "                enabled.",
            "",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"PUT\",",
            "            destination=destination,",
            "            path=path,",
            "            query=args,",
            "            json_callback=json_data_callback,",
            "            json=data,",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request_with_optional_trailing_slash(",
            "            request,",
            "            try_trailing_slash_on_400,",
            "            backoff_on_404=backoff_on_404,",
            "            ignore_backoff=ignore_backoff,",
            "            long_retries=long_retries,",
            "            timeout=timeout,",
            "        )",
            "",
            "        if timeout is not None:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms",
            "        )",
            "",
            "        return body",
            "",
            "    async def post_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        data: Optional[JsonDict] = None,",
            "        long_retries: bool = False,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        args: Optional[QueryArgs] = None,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\" Sends the specified json data using POST",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "",
            "            path: The HTTP path.",
            "",
            "            data: A dict containing the data that will be used as",
            "                the request body. This will be encoded as JSON.",
            "",
            "            long_retries: whether to use the long retry algorithm. See",
            "                docs on _send_request for details.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data and",
            "                try the request anyway.",
            "",
            "            args: query params",
            "        Returns:",
            "            dict|list: Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "",
            "        request = MatrixFederationRequest(",
            "            method=\"POST\", destination=destination, path=path, query=args, json=data",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request(",
            "            request,",
            "            long_retries=long_retries,",
            "            timeout=timeout,",
            "            ignore_backoff=ignore_backoff,",
            "        )",
            "",
            "        if timeout:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms,",
            "        )",
            "        return body",
            "",
            "    async def get_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        args: Optional[QueryArgs] = None,",
            "        retry_on_dns_fail: bool = True,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        try_trailing_slash_on_400: bool = False,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\" GETs some json from the given host homeserver and path",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "",
            "            path: The HTTP path.",
            "",
            "            args: A dictionary used to create query strings, defaults to",
            "                None.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "",
            "            try_trailing_slash_on_400: True if on a 400 M_UNRECOGNIZED",
            "                response we should try appending a trailing slash to the end of",
            "                the request. Workaround for #3622 in Synapse <= v0.99.3.",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"GET\", destination=destination, path=path, query=args",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request_with_optional_trailing_slash(",
            "            request,",
            "            try_trailing_slash_on_400,",
            "            backoff_on_404=False,",
            "            ignore_backoff=ignore_backoff,",
            "            retry_on_dns_fail=retry_on_dns_fail,",
            "            timeout=timeout,",
            "        )",
            "",
            "        if timeout is not None:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms",
            "        )",
            "",
            "        return body",
            "",
            "    async def delete_json(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        long_retries: bool = False,",
            "        timeout: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "        args: Optional[QueryArgs] = None,",
            "    ) -> Union[JsonDict, list]:",
            "        \"\"\"Send a DELETE request to the remote expecting some json response",
            "",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "            path: The HTTP path.",
            "",
            "            long_retries: whether to use the long retry algorithm. See",
            "                docs on _send_request for details.",
            "",
            "            timeout: number of milliseconds to wait for the response.",
            "                self._default_timeout (60s) by default.",
            "",
            "                Note that we may make several attempts to send the request; this",
            "                timeout applies to the time spent waiting for response headers for",
            "                *each* attempt (including connection time) as well as the time spent",
            "                reading the response body after a 200 response.",
            "",
            "            ignore_backoff: true to ignore the historical backoff data and",
            "                try the request anyway.",
            "",
            "            args: query params",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response. The",
            "            result will be the decoded JSON body.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"DELETE\", destination=destination, path=path, query=args",
            "        )",
            "",
            "        start_ms = self.clock.time_msec()",
            "",
            "        response = await self._send_request(",
            "            request,",
            "            long_retries=long_retries,",
            "            timeout=timeout,",
            "            ignore_backoff=ignore_backoff,",
            "        )",
            "",
            "        if timeout is not None:",
            "            _sec_timeout = timeout / 1000",
            "        else:",
            "            _sec_timeout = self.default_timeout",
            "",
            "        body = await _handle_json_response(",
            "            self.reactor, _sec_timeout, request, response, start_ms",
            "        )",
            "        return body",
            "",
            "    async def get_file(",
            "        self,",
            "        destination: str,",
            "        path: str,",
            "        output_stream,",
            "        args: Optional[QueryArgs] = None,",
            "        retry_on_dns_fail: bool = True,",
            "        max_size: Optional[int] = None,",
            "        ignore_backoff: bool = False,",
            "    ) -> Tuple[int, Dict[bytes, List[bytes]]]:",
            "        \"\"\"GETs a file from a given homeserver",
            "        Args:",
            "            destination: The remote server to send the HTTP request to.",
            "            path: The HTTP path to GET.",
            "            output_stream: File to write the response body to.",
            "            args: Optional dictionary used to create the query string.",
            "            ignore_backoff: true to ignore the historical backoff data",
            "                and try the request anyway.",
            "",
            "        Returns:",
            "            Resolves with an (int,dict) tuple of",
            "            the file length and a dict of the response headers.",
            "",
            "        Raises:",
            "            HttpResponseException: If we get an HTTP response code >= 300",
            "                (except 429).",
            "            NotRetryingDestination: If we are not yet ready to retry this",
            "                server.",
            "            FederationDeniedError: If this destination  is not on our",
            "                federation whitelist",
            "            RequestSendFailed: If there were problems connecting to the",
            "                remote, due to e.g. DNS failures, connection timeouts etc.",
            "        \"\"\"",
            "        request = MatrixFederationRequest(",
            "            method=\"GET\", destination=destination, path=path, query=args",
            "        )",
            "",
            "        response = await self._send_request(",
            "            request, retry_on_dns_fail=retry_on_dns_fail, ignore_backoff=ignore_backoff",
            "        )",
            "",
            "        headers = dict(response.headers.getAllRawHeaders())",
            "",
            "        try:",
            "            d = read_body_with_max_size(response, output_stream, max_size)",
            "            d.addTimeout(self.default_timeout, self.reactor)",
            "            length = await make_deferred_yieldable(d)",
            "        except BodyExceededMaxSize:",
            "            msg = \"Requested file is too large > %r bytes\" % (max_size,)",
            "            logger.warning(",
            "                \"{%s} [%s] %s\", request.txn_id, request.destination, msg,",
            "            )",
            "            SynapseError(502, msg, Codes.TOO_LARGE)",
            "        except Exception as e:",
            "            logger.warning(",
            "                \"{%s} [%s] Error reading response: %s\",",
            "                request.txn_id,",
            "                request.destination,",
            "                e,",
            "            )",
            "            raise",
            "        logger.info(",
            "            \"{%s} [%s] Completed: %d %s [%d bytes] %s %s\",",
            "            request.txn_id,",
            "            request.destination,",
            "            response.code,",
            "            response.phrase.decode(\"ascii\", errors=\"replace\"),",
            "            length,",
            "            request.method,",
            "            request.uri.decode(\"ascii\"),",
            "        )",
            "        return (length, headers)",
            "",
            "",
            "def _flatten_response_never_received(e):",
            "    if hasattr(e, \"reasons\"):",
            "        reasons = \", \".join(",
            "            _flatten_response_never_received(f.value) for f in e.reasons",
            "        )",
            "",
            "        return \"%s:[%s]\" % (type(e).__name__, reasons)",
            "    else:",
            "        return repr(e)",
            "",
            "",
            "def check_content_type_is_json(headers: Headers) -> None:",
            "    \"\"\"",
            "    Check that a set of HTTP headers have a Content-Type header, and that it",
            "    is application/json.",
            "",
            "    Args:",
            "        headers: headers to check",
            "",
            "    Raises:",
            "        RequestSendFailed: if the Content-Type header is missing or isn't JSON",
            "",
            "    \"\"\"",
            "    c_type = headers.getRawHeaders(b\"Content-Type\")",
            "    if c_type is None:",
            "        raise RequestSendFailed(",
            "            RuntimeError(\"No Content-Type header received from remote server\"),",
            "            can_retry=False,",
            "        )",
            "",
            "    c_type = c_type[0].decode(\"ascii\")  # only the first header",
            "    val, options = cgi.parse_header(c_type)",
            "    if val != \"application/json\":",
            "        raise RequestSendFailed(",
            "            RuntimeError(",
            "                \"Remote server sent Content-Type header of '%s', not 'application/json'\"",
            "                % c_type,",
            "            ),",
            "            can_retry=False,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "49": [],
            "978": [
                "MatrixFederationHttpClient"
            ]
        },
        "addLocation": []
    }
}