{
    "cinder/image/image_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " CONF = cfg.CONF"
            },
            "1": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " CONF.register_opts(image_helper_opts)"
            },
            "2": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+QEMU_IMG_LIMITS = processutils.ProcessLimits("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    cpu_time=2,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    address_space=1 * units.Gi)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " def qemu_img_info(path, run_as_root=True):"
            },
            "9": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     \"\"\"Return a object containing the parsed output from qemu-img info.\"\"\""
            },
            "10": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     cmd = ('env', 'LC_ALL=C', 'qemu-img', 'info', path)"
            },
            "11": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     if os.name == 'nt':"
            },
            "12": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         cmd = cmd[2:]"
            },
            "13": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    out, _err = utils.execute(*cmd, run_as_root=run_as_root)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    out, _err = utils.execute(*cmd, run_as_root=run_as_root,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                              prlimit=QEMU_IMG_LIMITS)"
            },
            "16": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     return imageutils.QemuImgInfo(out)"
            },
            "17": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Helper methods to deal with images.",
            "",
            "This is essentially a copy from nova.virt.images.py",
            "Some slight modifications, but at some point",
            "we should look at maybe pushing this up to Oslo",
            "\"\"\"",
            "",
            "",
            "import contextlib",
            "import math",
            "import os",
            "import re",
            "import tempfile",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_utils import fileutils",
            "from oslo_utils import timeutils",
            "from oslo_utils import units",
            "",
            "from cinder import exception",
            "from cinder.i18n import _, _LI, _LW",
            "from cinder.openstack.common import imageutils",
            "from cinder import utils",
            "from cinder.volume import throttling",
            "from cinder.volume import utils as volume_utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "image_helper_opts = [cfg.StrOpt('image_conversion_dir',",
            "                                default='$state_path/conversion',",
            "                                help='Directory used for temporary storage '",
            "                                'during image conversion'), ]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(image_helper_opts)",
            "",
            "",
            "def qemu_img_info(path, run_as_root=True):",
            "    \"\"\"Return a object containing the parsed output from qemu-img info.\"\"\"",
            "    cmd = ('env', 'LC_ALL=C', 'qemu-img', 'info', path)",
            "    if os.name == 'nt':",
            "        cmd = cmd[2:]",
            "    out, _err = utils.execute(*cmd, run_as_root=run_as_root)",
            "    return imageutils.QemuImgInfo(out)",
            "",
            "",
            "def get_qemu_img_version():",
            "    info = utils.execute('qemu-img', '--help', check_exit_code=False)[0]",
            "    pattern = r\"qemu-img version ([0-9\\.]*)\"",
            "    version = re.match(pattern, info)",
            "    if not version:",
            "        LOG.warning(_LW(\"qemu-img is not installed.\"))",
            "        return None",
            "    return _get_version_from_string(version.groups()[0])",
            "",
            "",
            "def _get_version_from_string(version_string):",
            "    return [int(x) for x in version_string.split('.')]",
            "",
            "",
            "def check_qemu_img_version(minimum_version):",
            "    qemu_version = get_qemu_img_version()",
            "    if qemu_version < _get_version_from_string(minimum_version):",
            "        if qemu_version:",
            "            current_version = '.'.join((str(element)",
            "                                       for element in qemu_version))",
            "        else:",
            "            current_version = None",
            "",
            "        _msg = _('qemu-img %(minimum_version)s or later is required by '",
            "                 'this volume driver. Current qemu-img version: '",
            "                 '%(current_version)s') % {'minimum_version': minimum_version,",
            "                                           'current_version': current_version}",
            "        raise exception.VolumeBackendAPIException(data=_msg)",
            "",
            "",
            "def _convert_image(prefix, source, dest, out_format, run_as_root=True):",
            "    \"\"\"Convert image to other format.\"\"\"",
            "",
            "    cmd = prefix + ('qemu-img', 'convert',",
            "                    '-O', out_format, source, dest)",
            "",
            "    # Check whether O_DIRECT is supported and set '-t none' if it is",
            "    # This is needed to ensure that all data hit the device before",
            "    # it gets unmapped remotely from the host for some backends",
            "    # Reference Bug: #1363016",
            "",
            "    # NOTE(jdg): In the case of file devices qemu does the",
            "    # flush properly and more efficiently than would be done",
            "    # setting O_DIRECT, so check for that and skip the",
            "    # setting for non BLK devs",
            "    if (utils.is_blk_device(dest) and",
            "            volume_utils.check_for_odirect_support(source,",
            "                                                   dest,",
            "                                                   'oflag=direct')):",
            "        cmd = prefix + ('qemu-img', 'convert',",
            "                        '-t', 'none',",
            "                        '-O', out_format, source, dest)",
            "",
            "    start_time = timeutils.utcnow()",
            "    utils.execute(*cmd, run_as_root=run_as_root)",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(source).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image conversion details: src %(src)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec, destination %(dest)s\")",
            "    LOG.debug(msg, {\"src\": source,",
            "                    \"sz\": fsz_mb,",
            "                    \"duration\": duration,",
            "                    \"dest\": dest})",
            "",
            "    msg = _LI(\"Converted %(sz).2f MB image at %(mbps).2f MB/s\")",
            "    LOG.info(msg, {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def convert_image(source, dest, out_format, run_as_root=True, throttle=None):",
            "    if not throttle:",
            "        throttle = throttling.Throttle.get_default()",
            "    with throttle.subcommand(source, dest) as throttle_cmd:",
            "        _convert_image(tuple(throttle_cmd['prefix']),",
            "                       source, dest,",
            "                       out_format, run_as_root=run_as_root)",
            "",
            "",
            "def resize_image(source, size, run_as_root=False):",
            "    \"\"\"Changes the virtual size of the image.\"\"\"",
            "    cmd = ('qemu-img', 'resize', source, '%sG' % size)",
            "    utils.execute(*cmd, run_as_root=run_as_root)",
            "",
            "",
            "def fetch(context, image_service, image_id, path, _user_id, _project_id):",
            "    # TODO(vish): Improve context handling and add owner and auth data",
            "    #             when it is added to glance.  Right now there is no",
            "    #             auth checking in glance, so we assume that access was",
            "    #             checked before we got here.",
            "    start_time = timeutils.utcnow()",
            "    with fileutils.remove_path_on_error(path):",
            "        with open(path, \"wb\") as image_file:",
            "            image_service.download(context, image_id, image_file)",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(image_file.name).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image fetch details: dest %(dest)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec\")",
            "    LOG.debug(msg, {\"dest\": image_file.name,",
            "                    \"sz\": fsz_mb,",
            "                    \"duration\": duration})",
            "    msg = _LI(\"Image download %(sz).2f MB at %(mbps).2f MB/s\")",
            "    LOG.info(msg, {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def fetch_verify_image(context, image_service, image_id, dest,",
            "                       user_id=None, project_id=None, size=None,",
            "                       run_as_root=True):",
            "    fetch(context, image_service, image_id, dest,",
            "          None, None)",
            "",
            "    with fileutils.remove_path_on_error(dest):",
            "        data = qemu_img_info(dest, run_as_root=run_as_root)",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=(_(\"fmt=%(fmt)s backed by: %(backing_file)s\") %",
            "                        {'fmt': fmt, 'backing_file': backing_file}))",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and data.virtual_size > size:",
            "            params = {'image_size': data.virtual_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "",
            "def fetch_to_vhd(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None, run_as_root=True):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'vpc',",
            "                           blocksize, user_id, project_id,",
            "                           run_as_root=run_as_root)",
            "",
            "",
            "def fetch_to_raw(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None, size=None, run_as_root=True):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'raw',",
            "                           blocksize, user_id, project_id, size,",
            "                           run_as_root=run_as_root)",
            "",
            "",
            "def fetch_to_volume_format(context, image_service,",
            "                           image_id, dest, volume_format, blocksize,",
            "                           user_id=None, project_id=None, size=None,",
            "                           run_as_root=True):",
            "    qemu_img = True",
            "    image_meta = image_service.show(context, image_id)",
            "",
            "    # NOTE(avishay): I'm not crazy about creating temp files which may be",
            "    # large and cause disk full errors which would confuse users.",
            "    # Unfortunately it seems that you can't pipe to 'qemu-img convert' because",
            "    # it seeks. Maybe we can think of something for a future version.",
            "    with temporary_file() as tmp:",
            "        # We may be on a system that doesn't have qemu-img installed.  That",
            "        # is ok if we are working with a RAW image.  This logic checks to see",
            "        # if qemu-img is installed.  If not we make sure the image is RAW and",
            "        # throw an exception if not.  Otherwise we stop before needing",
            "        # qemu-img.  Systems with qemu-img will always progress through the",
            "        # whole function.",
            "        try:",
            "            # Use the empty tmp file to make sure qemu_img_info works.",
            "            qemu_img_info(tmp, run_as_root=run_as_root)",
            "        except processutils.ProcessExecutionError:",
            "            qemu_img = False",
            "            if image_meta:",
            "                if image_meta['disk_format'] != 'raw':",
            "                    raise exception.ImageUnacceptable(",
            "                        reason=_(\"qemu-img is not installed and image is of \"",
            "                                 \"type %s.  Only RAW images can be used if \"",
            "                                 \"qemu-img is not installed.\") %",
            "                        image_meta['disk_format'],",
            "                        image_id=image_id)",
            "            else:",
            "                raise exception.ImageUnacceptable(",
            "                    reason=_(\"qemu-img is not installed and the disk \"",
            "                             \"format is not specified.  Only RAW images \"",
            "                             \"can be used if qemu-img is not installed.\"),",
            "                    image_id=image_id)",
            "",
            "        tmp_images = TemporaryImages.for_image_service(image_service)",
            "        tmp_image = tmp_images.get(context, image_id)",
            "        if tmp_image:",
            "            tmp = tmp_image",
            "        else:",
            "            fetch(context, image_service, image_id, tmp, user_id, project_id)",
            "",
            "        if is_xenserver_image(context, image_service, image_id):",
            "            replace_xenserver_image_with_coalesced_vhd(tmp)",
            "",
            "        if not qemu_img:",
            "            # qemu-img is not installed but we do have a RAW image.  As a",
            "            # result we only need to copy the image to the destination and then",
            "            # return.",
            "            LOG.debug('Copying image from %(tmp)s to volume %(dest)s - '",
            "                      'size: %(size)s', {'tmp': tmp, 'dest': dest,",
            "                                         'size': image_meta['size']})",
            "            image_size_m = math.ceil(image_meta['size'] / units.Mi)",
            "            volume_utils.copy_volume(tmp, dest, image_size_m, blocksize)",
            "            return",
            "",
            "        data = qemu_img_info(tmp, run_as_root=run_as_root)",
            "        virt_size = data.virtual_size / units.Gi",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and virt_size > size:",
            "            params = {'image_size': virt_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")",
            "                % {'fmt': fmt, 'backing_file': backing_file, })",
            "",
            "        # NOTE(jdg): I'm using qemu-img convert to write",
            "        # to the volume regardless if it *needs* conversion or not",
            "        # TODO(avishay): We can speed this up by checking if the image is raw",
            "        # and if so, writing directly to the device. However, we need to keep",
            "        # check via 'qemu-img info' that what we copied was in fact a raw",
            "        # image and not a different format with a backing file, which may be",
            "        # malicious.",
            "        LOG.debug(\"%s was %s, converting to %s \", image_id, fmt, volume_format)",
            "        convert_image(tmp, dest, volume_format,",
            "                      run_as_root=run_as_root)",
            "",
            "        data = qemu_img_info(dest, run_as_root=run_as_root)",
            "",
            "        if not _validate_file_format(data, volume_format):",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(vol_format)s, but format is \"",
            "                         \"now %(file_format)s\") % {'vol_format': volume_format,",
            "                                                   'file_format': data.",
            "                                                   file_format})",
            "",
            "",
            "def _validate_file_format(image_data, expected_format):",
            "    if image_data.file_format == expected_format:",
            "        return True",
            "    elif image_data.file_format == 'vpc' and expected_format == 'vhd':",
            "        # qemu-img still uses the legacy 'vpc' name for the vhd format.",
            "        return True",
            "    return False",
            "",
            "",
            "def upload_volume(context, image_service, image_meta, volume_path,",
            "                  volume_format='raw', run_as_root=True):",
            "    image_id = image_meta['id']",
            "    if (image_meta['disk_format'] == volume_format):",
            "        LOG.debug(\"%s was %s, no need to convert to %s\",",
            "                  image_id, volume_format, image_meta['disk_format'])",
            "        if os.name == 'nt' or os.access(volume_path, os.R_OK):",
            "            with open(volume_path, 'rb') as image_file:",
            "                image_service.update(context, image_id, {}, image_file)",
            "        else:",
            "            with utils.temporary_chown(volume_path):",
            "                with open(volume_path) as image_file:",
            "                    image_service.update(context, image_id, {}, image_file)",
            "        return",
            "",
            "    with temporary_file() as tmp:",
            "        LOG.debug(\"%s was %s, converting to %s\",",
            "                  image_id, volume_format, image_meta['disk_format'])",
            "",
            "        data = qemu_img_info(volume_path, run_as_root=run_as_root)",
            "        backing_file = data.backing_file",
            "        fmt = data.file_format",
            "        if backing_file is not None:",
            "            # Disallow backing files as a security measure.",
            "            # This prevents a user from writing an image header into a raw",
            "            # volume with a backing file pointing to data they wish to",
            "            # access.",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")",
            "                % {'fmt': fmt, 'backing_file': backing_file})",
            "",
            "        convert_image(volume_path, tmp, image_meta['disk_format'],",
            "                      run_as_root=run_as_root)",
            "",
            "        data = qemu_img_info(tmp, run_as_root=run_as_root)",
            "        if data.file_format != image_meta['disk_format']:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(f1)s, but format is now %(f2)s\") %",
            "                {'f1': image_meta['disk_format'], 'f2': data.file_format})",
            "",
            "        with open(tmp, 'rb') as image_file:",
            "            image_service.update(context, image_id, {}, image_file)",
            "",
            "",
            "def is_xenserver_image(context, image_service, image_id):",
            "    image_meta = image_service.show(context, image_id)",
            "    return is_xenserver_format(image_meta)",
            "",
            "",
            "def is_xenserver_format(image_meta):",
            "    return (",
            "        image_meta['disk_format'] == 'vhd'",
            "        and image_meta['container_format'] == 'ovf'",
            "    )",
            "",
            "",
            "def set_vhd_parent(vhd_path, parentpath):",
            "    utils.execute('vhd-util', 'modify', '-n', vhd_path, '-p', parentpath)",
            "",
            "",
            "def extract_targz(archive_name, target):",
            "    utils.execute('tar', '-xzf', archive_name, '-C', target)",
            "",
            "",
            "def fix_vhd_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        set_vhd_parent(child, parent)",
            "",
            "",
            "def get_vhd_size(vhd_path):",
            "    out, _err = utils.execute('vhd-util', 'query', '-n', vhd_path, '-v')",
            "    return int(out)",
            "",
            "",
            "def resize_vhd(vhd_path, size, journal):",
            "    utils.execute(",
            "        'vhd-util', 'resize', '-n', vhd_path, '-s', '%d' % size, '-j', journal)",
            "",
            "",
            "def coalesce_vhd(vhd_path):",
            "    utils.execute(",
            "        'vhd-util', 'coalesce', '-n', vhd_path)",
            "",
            "",
            "def create_temporary_file(*args, **kwargs):",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    fd, tmp = tempfile.mkstemp(dir=CONF.image_conversion_dir, *args, **kwargs)",
            "    os.close(fd)",
            "    return tmp",
            "",
            "",
            "@contextlib.contextmanager",
            "def temporary_file(*args, **kwargs):",
            "    tmp = None",
            "    try:",
            "        tmp = create_temporary_file(*args, **kwargs)",
            "        yield tmp",
            "    finally:",
            "        if tmp:",
            "            fileutils.delete_if_exists(tmp)",
            "",
            "",
            "def temporary_dir():",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    return utils.tempdir(dir=CONF.image_conversion_dir)",
            "",
            "",
            "def coalesce_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        with temporary_dir() as directory_for_journal:",
            "            size = get_vhd_size(child)",
            "            journal_file = os.path.join(",
            "                directory_for_journal, 'vhd-util-resize-journal')",
            "            resize_vhd(parent, size, journal_file)",
            "            coalesce_vhd(child)",
            "",
            "    return vhd_chain[-1]",
            "",
            "",
            "def discover_vhd_chain(directory):",
            "    counter = 0",
            "    chain = []",
            "",
            "    while True:",
            "        fpath = os.path.join(directory, '%d.vhd' % counter)",
            "        if os.path.exists(fpath):",
            "            chain.append(fpath)",
            "        else:",
            "            break",
            "        counter += 1",
            "",
            "    return chain",
            "",
            "",
            "def replace_xenserver_image_with_coalesced_vhd(image_file):",
            "    with temporary_dir() as tempdir:",
            "        extract_targz(image_file, tempdir)",
            "        chain = discover_vhd_chain(tempdir)",
            "        fix_vhd_chain(chain)",
            "        coalesced = coalesce_chain(chain)",
            "        fileutils.delete_if_exists(image_file)",
            "        os.rename(coalesced, image_file)",
            "",
            "",
            "class TemporaryImages(object):",
            "    \"\"\"Manage temporarily downloaded images to avoid downloading it twice.",
            "",
            "    In the 'with TemporaryImages.fetch(image_service, ctx, image_id) as tmp'",
            "    clause, 'tmp' can be used as the downloaded image path. In addition,",
            "    image_utils.fetch() will use the pre-fetched image by the TemporaryImages.",
            "    This is useful to inspect image contents before conversion.",
            "    \"\"\"",
            "",
            "    def __init__(self, image_service):",
            "        self.temporary_images = {}",
            "        self.image_service = image_service",
            "        image_service.temp_images = self",
            "",
            "    @staticmethod",
            "    def for_image_service(image_service):",
            "        instance = image_service.temp_images",
            "        if instance:",
            "            return instance",
            "        return TemporaryImages(image_service)",
            "",
            "    @classmethod",
            "    @contextlib.contextmanager",
            "    def fetch(cls, image_service, context, image_id):",
            "        tmp_images = cls.for_image_service(image_service).temporary_images",
            "        with temporary_file() as tmp:",
            "            fetch_verify_image(context, image_service, image_id, tmp)",
            "            user = context.user_id",
            "            if not tmp_images.get(user):",
            "                tmp_images[user] = {}",
            "            tmp_images[user][image_id] = tmp",
            "            LOG.debug(\"Temporary image %(id)s is fetched for user %(user)s.\",",
            "                      {'id': image_id, 'user': user})",
            "            yield tmp",
            "            del tmp_images[user][image_id]",
            "        LOG.debug(\"Temporary image %(id)s for user %(user)s is deleted.\",",
            "                  {'id': image_id, 'user': user})",
            "",
            "    def get(self, context, image_id):",
            "        user = context.user_id",
            "        if not self.temporary_images.get(user):",
            "            return None",
            "        return self.temporary_images[user].get(image_id)"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Helper methods to deal with images.",
            "",
            "This is essentially a copy from nova.virt.images.py",
            "Some slight modifications, but at some point",
            "we should look at maybe pushing this up to Oslo",
            "\"\"\"",
            "",
            "",
            "import contextlib",
            "import math",
            "import os",
            "import re",
            "import tempfile",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_utils import fileutils",
            "from oslo_utils import timeutils",
            "from oslo_utils import units",
            "",
            "from cinder import exception",
            "from cinder.i18n import _, _LI, _LW",
            "from cinder.openstack.common import imageutils",
            "from cinder import utils",
            "from cinder.volume import throttling",
            "from cinder.volume import utils as volume_utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "image_helper_opts = [cfg.StrOpt('image_conversion_dir',",
            "                                default='$state_path/conversion',",
            "                                help='Directory used for temporary storage '",
            "                                'during image conversion'), ]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(image_helper_opts)",
            "",
            "QEMU_IMG_LIMITS = processutils.ProcessLimits(",
            "    cpu_time=2,",
            "    address_space=1 * units.Gi)",
            "",
            "",
            "def qemu_img_info(path, run_as_root=True):",
            "    \"\"\"Return a object containing the parsed output from qemu-img info.\"\"\"",
            "    cmd = ('env', 'LC_ALL=C', 'qemu-img', 'info', path)",
            "    if os.name == 'nt':",
            "        cmd = cmd[2:]",
            "    out, _err = utils.execute(*cmd, run_as_root=run_as_root,",
            "                              prlimit=QEMU_IMG_LIMITS)",
            "    return imageutils.QemuImgInfo(out)",
            "",
            "",
            "def get_qemu_img_version():",
            "    info = utils.execute('qemu-img', '--help', check_exit_code=False)[0]",
            "    pattern = r\"qemu-img version ([0-9\\.]*)\"",
            "    version = re.match(pattern, info)",
            "    if not version:",
            "        LOG.warning(_LW(\"qemu-img is not installed.\"))",
            "        return None",
            "    return _get_version_from_string(version.groups()[0])",
            "",
            "",
            "def _get_version_from_string(version_string):",
            "    return [int(x) for x in version_string.split('.')]",
            "",
            "",
            "def check_qemu_img_version(minimum_version):",
            "    qemu_version = get_qemu_img_version()",
            "    if qemu_version < _get_version_from_string(minimum_version):",
            "        if qemu_version:",
            "            current_version = '.'.join((str(element)",
            "                                       for element in qemu_version))",
            "        else:",
            "            current_version = None",
            "",
            "        _msg = _('qemu-img %(minimum_version)s or later is required by '",
            "                 'this volume driver. Current qemu-img version: '",
            "                 '%(current_version)s') % {'minimum_version': minimum_version,",
            "                                           'current_version': current_version}",
            "        raise exception.VolumeBackendAPIException(data=_msg)",
            "",
            "",
            "def _convert_image(prefix, source, dest, out_format, run_as_root=True):",
            "    \"\"\"Convert image to other format.\"\"\"",
            "",
            "    cmd = prefix + ('qemu-img', 'convert',",
            "                    '-O', out_format, source, dest)",
            "",
            "    # Check whether O_DIRECT is supported and set '-t none' if it is",
            "    # This is needed to ensure that all data hit the device before",
            "    # it gets unmapped remotely from the host for some backends",
            "    # Reference Bug: #1363016",
            "",
            "    # NOTE(jdg): In the case of file devices qemu does the",
            "    # flush properly and more efficiently than would be done",
            "    # setting O_DIRECT, so check for that and skip the",
            "    # setting for non BLK devs",
            "    if (utils.is_blk_device(dest) and",
            "            volume_utils.check_for_odirect_support(source,",
            "                                                   dest,",
            "                                                   'oflag=direct')):",
            "        cmd = prefix + ('qemu-img', 'convert',",
            "                        '-t', 'none',",
            "                        '-O', out_format, source, dest)",
            "",
            "    start_time = timeutils.utcnow()",
            "    utils.execute(*cmd, run_as_root=run_as_root)",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(source).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image conversion details: src %(src)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec, destination %(dest)s\")",
            "    LOG.debug(msg, {\"src\": source,",
            "                    \"sz\": fsz_mb,",
            "                    \"duration\": duration,",
            "                    \"dest\": dest})",
            "",
            "    msg = _LI(\"Converted %(sz).2f MB image at %(mbps).2f MB/s\")",
            "    LOG.info(msg, {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def convert_image(source, dest, out_format, run_as_root=True, throttle=None):",
            "    if not throttle:",
            "        throttle = throttling.Throttle.get_default()",
            "    with throttle.subcommand(source, dest) as throttle_cmd:",
            "        _convert_image(tuple(throttle_cmd['prefix']),",
            "                       source, dest,",
            "                       out_format, run_as_root=run_as_root)",
            "",
            "",
            "def resize_image(source, size, run_as_root=False):",
            "    \"\"\"Changes the virtual size of the image.\"\"\"",
            "    cmd = ('qemu-img', 'resize', source, '%sG' % size)",
            "    utils.execute(*cmd, run_as_root=run_as_root)",
            "",
            "",
            "def fetch(context, image_service, image_id, path, _user_id, _project_id):",
            "    # TODO(vish): Improve context handling and add owner and auth data",
            "    #             when it is added to glance.  Right now there is no",
            "    #             auth checking in glance, so we assume that access was",
            "    #             checked before we got here.",
            "    start_time = timeutils.utcnow()",
            "    with fileutils.remove_path_on_error(path):",
            "        with open(path, \"wb\") as image_file:",
            "            image_service.download(context, image_id, image_file)",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(image_file.name).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image fetch details: dest %(dest)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec\")",
            "    LOG.debug(msg, {\"dest\": image_file.name,",
            "                    \"sz\": fsz_mb,",
            "                    \"duration\": duration})",
            "    msg = _LI(\"Image download %(sz).2f MB at %(mbps).2f MB/s\")",
            "    LOG.info(msg, {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def fetch_verify_image(context, image_service, image_id, dest,",
            "                       user_id=None, project_id=None, size=None,",
            "                       run_as_root=True):",
            "    fetch(context, image_service, image_id, dest,",
            "          None, None)",
            "",
            "    with fileutils.remove_path_on_error(dest):",
            "        data = qemu_img_info(dest, run_as_root=run_as_root)",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=(_(\"fmt=%(fmt)s backed by: %(backing_file)s\") %",
            "                        {'fmt': fmt, 'backing_file': backing_file}))",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and data.virtual_size > size:",
            "            params = {'image_size': data.virtual_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "",
            "def fetch_to_vhd(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None, run_as_root=True):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'vpc',",
            "                           blocksize, user_id, project_id,",
            "                           run_as_root=run_as_root)",
            "",
            "",
            "def fetch_to_raw(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None, size=None, run_as_root=True):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'raw',",
            "                           blocksize, user_id, project_id, size,",
            "                           run_as_root=run_as_root)",
            "",
            "",
            "def fetch_to_volume_format(context, image_service,",
            "                           image_id, dest, volume_format, blocksize,",
            "                           user_id=None, project_id=None, size=None,",
            "                           run_as_root=True):",
            "    qemu_img = True",
            "    image_meta = image_service.show(context, image_id)",
            "",
            "    # NOTE(avishay): I'm not crazy about creating temp files which may be",
            "    # large and cause disk full errors which would confuse users.",
            "    # Unfortunately it seems that you can't pipe to 'qemu-img convert' because",
            "    # it seeks. Maybe we can think of something for a future version.",
            "    with temporary_file() as tmp:",
            "        # We may be on a system that doesn't have qemu-img installed.  That",
            "        # is ok if we are working with a RAW image.  This logic checks to see",
            "        # if qemu-img is installed.  If not we make sure the image is RAW and",
            "        # throw an exception if not.  Otherwise we stop before needing",
            "        # qemu-img.  Systems with qemu-img will always progress through the",
            "        # whole function.",
            "        try:",
            "            # Use the empty tmp file to make sure qemu_img_info works.",
            "            qemu_img_info(tmp, run_as_root=run_as_root)",
            "        except processutils.ProcessExecutionError:",
            "            qemu_img = False",
            "            if image_meta:",
            "                if image_meta['disk_format'] != 'raw':",
            "                    raise exception.ImageUnacceptable(",
            "                        reason=_(\"qemu-img is not installed and image is of \"",
            "                                 \"type %s.  Only RAW images can be used if \"",
            "                                 \"qemu-img is not installed.\") %",
            "                        image_meta['disk_format'],",
            "                        image_id=image_id)",
            "            else:",
            "                raise exception.ImageUnacceptable(",
            "                    reason=_(\"qemu-img is not installed and the disk \"",
            "                             \"format is not specified.  Only RAW images \"",
            "                             \"can be used if qemu-img is not installed.\"),",
            "                    image_id=image_id)",
            "",
            "        tmp_images = TemporaryImages.for_image_service(image_service)",
            "        tmp_image = tmp_images.get(context, image_id)",
            "        if tmp_image:",
            "            tmp = tmp_image",
            "        else:",
            "            fetch(context, image_service, image_id, tmp, user_id, project_id)",
            "",
            "        if is_xenserver_image(context, image_service, image_id):",
            "            replace_xenserver_image_with_coalesced_vhd(tmp)",
            "",
            "        if not qemu_img:",
            "            # qemu-img is not installed but we do have a RAW image.  As a",
            "            # result we only need to copy the image to the destination and then",
            "            # return.",
            "            LOG.debug('Copying image from %(tmp)s to volume %(dest)s - '",
            "                      'size: %(size)s', {'tmp': tmp, 'dest': dest,",
            "                                         'size': image_meta['size']})",
            "            image_size_m = math.ceil(image_meta['size'] / units.Mi)",
            "            volume_utils.copy_volume(tmp, dest, image_size_m, blocksize)",
            "            return",
            "",
            "        data = qemu_img_info(tmp, run_as_root=run_as_root)",
            "        virt_size = data.virtual_size / units.Gi",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and virt_size > size:",
            "            params = {'image_size': virt_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")",
            "                % {'fmt': fmt, 'backing_file': backing_file, })",
            "",
            "        # NOTE(jdg): I'm using qemu-img convert to write",
            "        # to the volume regardless if it *needs* conversion or not",
            "        # TODO(avishay): We can speed this up by checking if the image is raw",
            "        # and if so, writing directly to the device. However, we need to keep",
            "        # check via 'qemu-img info' that what we copied was in fact a raw",
            "        # image and not a different format with a backing file, which may be",
            "        # malicious.",
            "        LOG.debug(\"%s was %s, converting to %s \", image_id, fmt, volume_format)",
            "        convert_image(tmp, dest, volume_format,",
            "                      run_as_root=run_as_root)",
            "",
            "        data = qemu_img_info(dest, run_as_root=run_as_root)",
            "",
            "        if not _validate_file_format(data, volume_format):",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(vol_format)s, but format is \"",
            "                         \"now %(file_format)s\") % {'vol_format': volume_format,",
            "                                                   'file_format': data.",
            "                                                   file_format})",
            "",
            "",
            "def _validate_file_format(image_data, expected_format):",
            "    if image_data.file_format == expected_format:",
            "        return True",
            "    elif image_data.file_format == 'vpc' and expected_format == 'vhd':",
            "        # qemu-img still uses the legacy 'vpc' name for the vhd format.",
            "        return True",
            "    return False",
            "",
            "",
            "def upload_volume(context, image_service, image_meta, volume_path,",
            "                  volume_format='raw', run_as_root=True):",
            "    image_id = image_meta['id']",
            "    if (image_meta['disk_format'] == volume_format):",
            "        LOG.debug(\"%s was %s, no need to convert to %s\",",
            "                  image_id, volume_format, image_meta['disk_format'])",
            "        if os.name == 'nt' or os.access(volume_path, os.R_OK):",
            "            with open(volume_path, 'rb') as image_file:",
            "                image_service.update(context, image_id, {}, image_file)",
            "        else:",
            "            with utils.temporary_chown(volume_path):",
            "                with open(volume_path) as image_file:",
            "                    image_service.update(context, image_id, {}, image_file)",
            "        return",
            "",
            "    with temporary_file() as tmp:",
            "        LOG.debug(\"%s was %s, converting to %s\",",
            "                  image_id, volume_format, image_meta['disk_format'])",
            "",
            "        data = qemu_img_info(volume_path, run_as_root=run_as_root)",
            "        backing_file = data.backing_file",
            "        fmt = data.file_format",
            "        if backing_file is not None:",
            "            # Disallow backing files as a security measure.",
            "            # This prevents a user from writing an image header into a raw",
            "            # volume with a backing file pointing to data they wish to",
            "            # access.",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")",
            "                % {'fmt': fmt, 'backing_file': backing_file})",
            "",
            "        convert_image(volume_path, tmp, image_meta['disk_format'],",
            "                      run_as_root=run_as_root)",
            "",
            "        data = qemu_img_info(tmp, run_as_root=run_as_root)",
            "        if data.file_format != image_meta['disk_format']:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(f1)s, but format is now %(f2)s\") %",
            "                {'f1': image_meta['disk_format'], 'f2': data.file_format})",
            "",
            "        with open(tmp, 'rb') as image_file:",
            "            image_service.update(context, image_id, {}, image_file)",
            "",
            "",
            "def is_xenserver_image(context, image_service, image_id):",
            "    image_meta = image_service.show(context, image_id)",
            "    return is_xenserver_format(image_meta)",
            "",
            "",
            "def is_xenserver_format(image_meta):",
            "    return (",
            "        image_meta['disk_format'] == 'vhd'",
            "        and image_meta['container_format'] == 'ovf'",
            "    )",
            "",
            "",
            "def set_vhd_parent(vhd_path, parentpath):",
            "    utils.execute('vhd-util', 'modify', '-n', vhd_path, '-p', parentpath)",
            "",
            "",
            "def extract_targz(archive_name, target):",
            "    utils.execute('tar', '-xzf', archive_name, '-C', target)",
            "",
            "",
            "def fix_vhd_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        set_vhd_parent(child, parent)",
            "",
            "",
            "def get_vhd_size(vhd_path):",
            "    out, _err = utils.execute('vhd-util', 'query', '-n', vhd_path, '-v')",
            "    return int(out)",
            "",
            "",
            "def resize_vhd(vhd_path, size, journal):",
            "    utils.execute(",
            "        'vhd-util', 'resize', '-n', vhd_path, '-s', '%d' % size, '-j', journal)",
            "",
            "",
            "def coalesce_vhd(vhd_path):",
            "    utils.execute(",
            "        'vhd-util', 'coalesce', '-n', vhd_path)",
            "",
            "",
            "def create_temporary_file(*args, **kwargs):",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    fd, tmp = tempfile.mkstemp(dir=CONF.image_conversion_dir, *args, **kwargs)",
            "    os.close(fd)",
            "    return tmp",
            "",
            "",
            "@contextlib.contextmanager",
            "def temporary_file(*args, **kwargs):",
            "    tmp = None",
            "    try:",
            "        tmp = create_temporary_file(*args, **kwargs)",
            "        yield tmp",
            "    finally:",
            "        if tmp:",
            "            fileutils.delete_if_exists(tmp)",
            "",
            "",
            "def temporary_dir():",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    return utils.tempdir(dir=CONF.image_conversion_dir)",
            "",
            "",
            "def coalesce_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        with temporary_dir() as directory_for_journal:",
            "            size = get_vhd_size(child)",
            "            journal_file = os.path.join(",
            "                directory_for_journal, 'vhd-util-resize-journal')",
            "            resize_vhd(parent, size, journal_file)",
            "            coalesce_vhd(child)",
            "",
            "    return vhd_chain[-1]",
            "",
            "",
            "def discover_vhd_chain(directory):",
            "    counter = 0",
            "    chain = []",
            "",
            "    while True:",
            "        fpath = os.path.join(directory, '%d.vhd' % counter)",
            "        if os.path.exists(fpath):",
            "            chain.append(fpath)",
            "        else:",
            "            break",
            "        counter += 1",
            "",
            "    return chain",
            "",
            "",
            "def replace_xenserver_image_with_coalesced_vhd(image_file):",
            "    with temporary_dir() as tempdir:",
            "        extract_targz(image_file, tempdir)",
            "        chain = discover_vhd_chain(tempdir)",
            "        fix_vhd_chain(chain)",
            "        coalesced = coalesce_chain(chain)",
            "        fileutils.delete_if_exists(image_file)",
            "        os.rename(coalesced, image_file)",
            "",
            "",
            "class TemporaryImages(object):",
            "    \"\"\"Manage temporarily downloaded images to avoid downloading it twice.",
            "",
            "    In the 'with TemporaryImages.fetch(image_service, ctx, image_id) as tmp'",
            "    clause, 'tmp' can be used as the downloaded image path. In addition,",
            "    image_utils.fetch() will use the pre-fetched image by the TemporaryImages.",
            "    This is useful to inspect image contents before conversion.",
            "    \"\"\"",
            "",
            "    def __init__(self, image_service):",
            "        self.temporary_images = {}",
            "        self.image_service = image_service",
            "        image_service.temp_images = self",
            "",
            "    @staticmethod",
            "    def for_image_service(image_service):",
            "        instance = image_service.temp_images",
            "        if instance:",
            "            return instance",
            "        return TemporaryImages(image_service)",
            "",
            "    @classmethod",
            "    @contextlib.contextmanager",
            "    def fetch(cls, image_service, context, image_id):",
            "        tmp_images = cls.for_image_service(image_service).temporary_images",
            "        with temporary_file() as tmp:",
            "            fetch_verify_image(context, image_service, image_id, tmp)",
            "            user = context.user_id",
            "            if not tmp_images.get(user):",
            "                tmp_images[user] = {}",
            "            tmp_images[user][image_id] = tmp",
            "            LOG.debug(\"Temporary image %(id)s is fetched for user %(user)s.\",",
            "                      {'id': image_id, 'user': user})",
            "            yield tmp",
            "            del tmp_images[user][image_id]",
            "        LOG.debug(\"Temporary image %(id)s for user %(user)s is deleted.\",",
            "                  {'id': image_id, 'user': user})",
            "",
            "    def get(self, context, image_id):",
            "        user = context.user_id",
            "        if not self.temporary_images.get(user):",
            "            return None",
            "        return self.temporary_images[user].get(image_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "63": [
                "qemu_img_info"
            ]
        },
        "addLocation": []
    },
    "cinder/tests/unit/test_image_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         output = image_utils.qemu_img_info(test_path)"
            },
            "2": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         mock_exec.assert_called_once_with('env', 'LC_ALL=C', 'qemu-img',"
            },
            "3": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          'info', test_path, run_as_root=True)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+                                          'info', test_path, run_as_root=True,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+                                          prlimit=image_utils.QEMU_IMG_LIMITS)"
            },
            "6": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         self.assertEqual(mock_info.return_value, output)"
            },
            "7": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     @mock.patch('cinder.openstack.common.imageutils.QemuImgInfo')"
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         output = image_utils.qemu_img_info(test_path, run_as_root=False)"
            },
            "11": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         mock_exec.assert_called_once_with('env', 'LC_ALL=C', 'qemu-img',"
            },
            "12": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          'info', test_path, run_as_root=False)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                                          'info', test_path, run_as_root=False,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                                          prlimit=image_utils.QEMU_IMG_LIMITS)"
            },
            "15": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         self.assertEqual(mock_info.return_value, output)"
            },
            "16": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     @mock.patch('cinder.image.image_utils.os')"
            },
            "18": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         output = image_utils.qemu_img_info(test_path)"
            },
            "20": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         mock_exec.assert_called_once_with('qemu-img', 'info', test_path,"
            },
            "21": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          run_as_root=True)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                                          run_as_root=True,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                                          prlimit=image_utils.QEMU_IMG_LIMITS)"
            },
            "24": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         self.assertEqual(mock_info.return_value, output)"
            },
            "25": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     @mock.patch('cinder.utils.execute')"
            }
        },
        "frontPatchFile": [
            "",
            "# Copyright (c) 2013 eNovance , Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"Unit tests for image utils.\"\"\"",
            "",
            "import math",
            "",
            "import mock",
            "from oslo_concurrency import processutils",
            "from oslo_utils import units",
            "",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder import test",
            "from cinder.volume import throttling",
            "",
            "",
            "class TestQemuImgInfo(test.TestCase):",
            "    @mock.patch('cinder.openstack.common.imageutils.QemuImgInfo')",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_qemu_img_info(self, mock_exec, mock_info):",
            "        mock_out = mock.sentinel.out",
            "        mock_err = mock.sentinel.err",
            "        test_path = mock.sentinel.path",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "",
            "        output = image_utils.qemu_img_info(test_path)",
            "        mock_exec.assert_called_once_with('env', 'LC_ALL=C', 'qemu-img',",
            "                                          'info', test_path, run_as_root=True)",
            "        self.assertEqual(mock_info.return_value, output)",
            "",
            "    @mock.patch('cinder.openstack.common.imageutils.QemuImgInfo')",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_qemu_img_info_not_root(self, mock_exec, mock_info):",
            "        mock_out = mock.sentinel.out",
            "        mock_err = mock.sentinel.err",
            "        test_path = mock.sentinel.path",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "",
            "        output = image_utils.qemu_img_info(test_path, run_as_root=False)",
            "        mock_exec.assert_called_once_with('env', 'LC_ALL=C', 'qemu-img',",
            "                                          'info', test_path, run_as_root=False)",
            "        self.assertEqual(mock_info.return_value, output)",
            "",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    @mock.patch('cinder.openstack.common.imageutils.QemuImgInfo')",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_qemu_img_info_on_nt(self, mock_exec, mock_info, mock_os):",
            "        mock_out = mock.sentinel.out",
            "        mock_err = mock.sentinel.err",
            "        test_path = mock.sentinel.path",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "        mock_os.name = 'nt'",
            "",
            "        output = image_utils.qemu_img_info(test_path)",
            "        mock_exec.assert_called_once_with('qemu-img', 'info', test_path,",
            "                                          run_as_root=True)",
            "        self.assertEqual(mock_info.return_value, output)",
            "",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_get_qemu_img_version(self, mock_exec):",
            "        mock_out = \"qemu-img version 2.0.0\"",
            "        mock_err = mock.sentinel.err",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "",
            "        expected_version = [2, 0, 0]",
            "        version = image_utils.get_qemu_img_version()",
            "",
            "        mock_exec.assert_called_once_with('qemu-img', '--help',",
            "                                          check_exit_code=False)",
            "        self.assertEqual(expected_version, version)",
            "",
            "    @mock.patch.object(image_utils, 'get_qemu_img_version')",
            "    def test_validate_qemu_img_version(self, mock_get_qemu_img_version):",
            "        fake_current_version = [1, 8]",
            "        mock_get_qemu_img_version.return_value = fake_current_version",
            "        minimum_version = '1.8'",
            "",
            "        image_utils.check_qemu_img_version(minimum_version)",
            "",
            "        mock_get_qemu_img_version.assert_called_once_with()",
            "",
            "    @mock.patch.object(image_utils, 'get_qemu_img_version')",
            "    def _test_validate_unsupported_qemu_img_version(self,",
            "                                                    mock_get_qemu_img_version,",
            "                                                    current_version=None):",
            "        mock_get_qemu_img_version.return_value = current_version",
            "        minimum_version = '2.0'",
            "",
            "        self.assertRaises(exception.VolumeBackendAPIException,",
            "                          image_utils.check_qemu_img_version,",
            "                          minimum_version)",
            "",
            "        mock_get_qemu_img_version.assert_called_once_with()",
            "",
            "    def test_validate_qemu_img_version_not_installed(self):",
            "        self._test_validate_unsupported_qemu_img_version()",
            "",
            "    def test_validate_older_qemu_img_version(self):",
            "        self._test_validate_unsupported_qemu_img_version(",
            "            current_version=[1, 8])",
            "",
            "",
            "class TestConvertImage(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.os.stat')",
            "    @mock.patch('cinder.utils.execute')",
            "    @mock.patch('cinder.utils.is_blk_device', return_value=True)",
            "    def test_defaults_block_dev(self, mock_isblk, mock_exec,",
            "                                mock_stat):",
            "        source = mock.sentinel.source",
            "        dest = mock.sentinel.dest",
            "        out_format = mock.sentinel.out_format",
            "        mock_stat.return_value.st_size = 1048576",
            "        throttle = throttling.Throttle(prefix=['cgcmd'])",
            "",
            "        with mock.patch('cinder.volume.utils.check_for_odirect_support',",
            "                        return_value=True):",
            "            output = image_utils.convert_image(source, dest, out_format,",
            "                                               throttle=throttle)",
            "",
            "            self.assertIsNone(output)",
            "            mock_exec.assert_called_once_with('cgcmd', 'qemu-img', 'convert',",
            "                                              '-t', 'none', '-O', out_format,",
            "                                              source, dest, run_as_root=True)",
            "",
            "        mock_exec.reset_mock()",
            "",
            "        with mock.patch('cinder.volume.utils.check_for_odirect_support',",
            "                        return_value=False):",
            "            output = image_utils.convert_image(source, dest, out_format)",
            "",
            "            self.assertIsNone(output)",
            "            mock_exec.assert_called_once_with('qemu-img', 'convert',",
            "                                              '-O', out_format, source, dest,",
            "                                              run_as_root=True)",
            "",
            "    @mock.patch('cinder.volume.utils.check_for_odirect_support',",
            "                return_value=True)",
            "    @mock.patch('cinder.image.image_utils.os.stat')",
            "    @mock.patch('cinder.utils.execute')",
            "    @mock.patch('cinder.utils.is_blk_device', return_value=False)",
            "    def test_defaults_not_block_dev(self, mock_isblk, mock_exec,",
            "                                    mock_stat, mock_odirect):",
            "        source = mock.sentinel.source",
            "        dest = mock.sentinel.dest",
            "        out_format = mock.sentinel.out_format",
            "        mock_stat.return_value.st_size = 1048576",
            "",
            "        output = image_utils.convert_image(source, dest, out_format)",
            "",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('qemu-img', 'convert', '-O',",
            "                                          out_format, source, dest,",
            "                                          run_as_root=True)",
            "",
            "",
            "class TestResizeImage(test.TestCase):",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_defaults(self, mock_exec):",
            "        source = mock.sentinel.source",
            "        size = mock.sentinel.size",
            "        output = image_utils.resize_image(source, size)",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('qemu-img', 'resize', source,",
            "                                          'sentinel.sizeG', run_as_root=False)",
            "",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_run_as_root(self, mock_exec):",
            "        source = mock.sentinel.source",
            "        size = mock.sentinel.size",
            "        output = image_utils.resize_image(source, size, run_as_root=True)",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('qemu-img', 'resize', source,",
            "                                          'sentinel.sizeG', run_as_root=True)",
            "",
            "",
            "class TestFetch(test.TestCase):",
            "    @mock.patch('os.stat')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    def test_defaults(self, mock_fileutils, mock_stat):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        path = 'test_path'",
            "        _user_id = mock.sentinel._user_id",
            "        _project_id = mock.sentinel._project_id",
            "        mock_open = mock.mock_open()",
            "        mock_stat.return_value.st_size = 1048576",
            "",
            "        with mock.patch('cinder.image.image_utils.open',",
            "                        new=mock_open, create=True):",
            "            output = image_utils.fetch(ctxt, image_service, image_id, path,",
            "                                       _user_id, _project_id)",
            "        self.assertIsNone(output)",
            "        image_service.download.assert_called_once_with(ctxt, image_id,",
            "                                                       mock_open.return_value)",
            "        mock_open.assert_called_once_with(path, 'wb')",
            "        mock_fileutils.remove_path_on_error.assert_called_once_with(path)",
            "        (mock_fileutils.remove_path_on_error.return_value.__enter__",
            "            .assert_called_once_with())",
            "        (mock_fileutils.remove_path_on_error.return_value.__exit__",
            "            .assert_called_once_with(None, None, None))",
            "",
            "",
            "class TestVerifyImage(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_defaults(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = None",
            "",
            "        output = image_utils.fetch_verify_image(ctxt, image_service,",
            "                                                image_id, dest)",
            "        self.assertIsNone(output)",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           dest, None, None)",
            "        mock_info.assert_called_once_with(dest, run_as_root=True)",
            "        mock_fileutils.remove_path_on_error.assert_called_once_with(dest)",
            "        (mock_fileutils.remove_path_on_error.return_value.__enter__",
            "            .assert_called_once_with())",
            "        (mock_fileutils.remove_path_on_error.return_value.__exit__",
            "            .assert_called_once_with(None, None, None))",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_kwargs(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 2",
            "        run_as_root = mock.sentinel.run_as_root",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = None",
            "        mock_data.virtual_size = 1",
            "",
            "        output = image_utils.fetch_verify_image(",
            "            ctxt, image_service, image_id, dest, user_id=user_id,",
            "            project_id=project_id, size=size, run_as_root=run_as_root)",
            "        self.assertIsNone(output)",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           dest, None, None)",
            "        mock_info.assert_called_once_with(dest, run_as_root=run_as_root)",
            "        mock_fileutils.remove_path_on_error.assert_called_once_with(dest)",
            "        (mock_fileutils.remove_path_on_error.return_value.__enter__",
            "            .assert_called_once_with())",
            "        (mock_fileutils.remove_path_on_error.return_value.__exit__",
            "            .assert_called_once_with(None, None, None))",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_format_error(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = None",
            "        mock_data.backing_file = None",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          ctxt, image_service, image_id, dest)",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_backing_file_error(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = 'test_backing_file'",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          ctxt, image_service, image_id, dest)",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_size_error(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        size = 1",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = None",
            "        mock_data.virtual_size = 2",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          ctxt, image_service, image_id, dest, size=size)",
            "",
            "",
            "class TestTemporaryDir(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('os.makedirs')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('cinder.image.image_utils.utils.tempdir')",
            "    def test_conv_dir_exists(self, mock_tempdir, mock_exists, mock_make,",
            "                             mock_conf):",
            "        mock_conf.image_conversion_dir = mock.sentinel.conv_dir",
            "",
            "        output = image_utils.temporary_dir()",
            "",
            "        self.assertFalse(mock_make.called)",
            "        mock_tempdir.assert_called_once_with(dir=mock.sentinel.conv_dir)",
            "        self.assertEqual(output, mock_tempdir.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('os.makedirs')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    @mock.patch('cinder.image.image_utils.utils.tempdir')",
            "    def test_create_conv_dir(self, mock_tempdir, mock_exists, mock_make,",
            "                             mock_conf):",
            "        mock_conf.image_conversion_dir = mock.sentinel.conv_dir",
            "",
            "        output = image_utils.temporary_dir()",
            "",
            "        mock_make.assert_called_once_with(mock.sentinel.conv_dir)",
            "        mock_tempdir.assert_called_once_with(dir=mock.sentinel.conv_dir)",
            "        self.assertEqual(output, mock_tempdir.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('os.makedirs')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    @mock.patch('cinder.image.image_utils.utils.tempdir')",
            "    def test_no_conv_dir(self, mock_tempdir, mock_exists, mock_make,",
            "                         mock_conf):",
            "        mock_conf.image_conversion_dir = None",
            "",
            "        output = image_utils.temporary_dir()",
            "",
            "        self.assertFalse(mock_make.called)",
            "        mock_tempdir.assert_called_once_with(dir=None)",
            "        self.assertEqual(output, mock_tempdir.return_value)",
            "",
            "",
            "class TestUploadVolume(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_diff_format(self, mock_os, mock_temp, mock_convert, mock_info,",
            "                         mock_open, mock_conf):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': mock.sentinel.disk_format}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'posix'",
            "        data = mock_info.return_value",
            "        data.file_format = mock.sentinel.disk_format",
            "        data.backing_file = None",
            "        temp_file = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.upload_volume(ctxt, image_service, image_meta,",
            "                                           volume_path)",
            "",
            "        self.assertIsNone(output)",
            "        mock_convert.assert_called_once_with(volume_path,",
            "                                             temp_file,",
            "                                             mock.sentinel.disk_format,",
            "                                             run_as_root=True)",
            "        mock_info.assert_called_with(temp_file, run_as_root=True)",
            "        self.assertEqual(2, mock_info.call_count)",
            "        mock_open.assert_called_once_with(temp_file, 'rb')",
            "        image_service.update.assert_called_once_with(",
            "            ctxt, image_meta['id'], {},",
            "            mock_open.return_value.__enter__.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.temporary_chown')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_same_format(self, mock_os, mock_temp, mock_convert, mock_info,",
            "                         mock_open, mock_conf, mock_chown):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': 'raw'}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'posix'",
            "        mock_os.access.return_value = False",
            "",
            "        output = image_utils.upload_volume(ctxt, image_service, image_meta,",
            "                                           volume_path)",
            "",
            "        self.assertIsNone(output)",
            "        self.assertFalse(mock_convert.called)",
            "        self.assertFalse(mock_info.called)",
            "        mock_chown.assert_called_once_with(volume_path)",
            "        mock_open.assert_called_once_with(volume_path)",
            "        image_service.update.assert_called_once_with(",
            "            ctxt, image_meta['id'], {},",
            "            mock_open.return_value.__enter__.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.temporary_chown')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_same_format_on_nt(self, mock_os, mock_temp, mock_convert,",
            "                               mock_info, mock_open, mock_conf, mock_chown):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': 'raw'}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'nt'",
            "        mock_os.access.return_value = False",
            "",
            "        output = image_utils.upload_volume(ctxt, image_service, image_meta,",
            "                                           volume_path)",
            "",
            "        self.assertIsNone(output)",
            "        self.assertFalse(mock_convert.called)",
            "        self.assertFalse(mock_info.called)",
            "        mock_open.assert_called_once_with(volume_path, 'rb')",
            "        image_service.update.assert_called_once_with(",
            "            ctxt, image_meta['id'], {},",
            "            mock_open.return_value.__enter__.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_convert_error(self, mock_os, mock_temp, mock_convert, mock_info,",
            "                           mock_open, mock_conf):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': mock.sentinel.disk_format}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'posix'",
            "        data = mock_info.return_value",
            "        data.file_format = mock.sentinel.other_disk_format",
            "        data.backing_file = None",
            "        temp_file = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.upload_volume,",
            "                          ctxt, image_service, image_meta, volume_path)",
            "        mock_convert.assert_called_once_with(volume_path,",
            "                                             temp_file,",
            "                                             mock.sentinel.disk_format,",
            "                                             run_as_root=True)",
            "        mock_info.assert_called_with(temp_file, run_as_root=True)",
            "        self.assertEqual(2, mock_info.call_count)",
            "        self.assertFalse(image_service.update.called)",
            "",
            "",
            "class TestFetchToVhd(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_defaults(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        output = image_utils.fetch_to_vhd(ctxt, image_service, image_id,",
            "                                          dest, blocksize)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'vpc', blocksize, None,",
            "                                              None, run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_kwargs(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        output = image_utils.fetch_to_vhd(ctxt, image_service, image_id,",
            "                                          dest, blocksize, user_id=user_id,",
            "                                          project_id=project_id,",
            "                                          run_as_root=run_as_root)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'vpc', blocksize, user_id,",
            "                                              project_id,",
            "                                              run_as_root=run_as_root)",
            "",
            "",
            "class TestFetchToRaw(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_defaults(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        output = image_utils.fetch_to_raw(ctxt, image_service, image_id,",
            "                                          dest, blocksize)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'raw', blocksize, None,",
            "                                              None, None, run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_kwargs(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = mock.sentinel.size",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        output = image_utils.fetch_to_raw(ctxt, image_service, image_id,",
            "                                          dest, blocksize, user_id=user_id,",
            "                                          project_id=project_id, size=size,",
            "                                          run_as_root=run_as_root)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'raw', blocksize, user_id,",
            "                                              project_id, size,",
            "                                              run_as_root=run_as_root)",
            "",
            "",
            "class TestFetchToVolumeFormat(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_defaults(self, mock_conf, mock_temp, mock_info, mock_fetch,",
            "                      mock_is_xen, mock_repl_xen, mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        ctxt.user_id = mock.sentinel.user_id",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.fetch_to_volume_format(ctxt, image_service,",
            "                                                    image_id, dest,",
            "                                                    volume_format, blocksize)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(dest, run_as_root=True)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, None, None)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_kwargs(self, mock_conf, mock_temp, mock_info, mock_fetch,",
            "                    mock_is_xen, mock_repl_xen, mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.fetch_to_volume_format(",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(dest, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=run_as_root)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_temporary_images(self, mock_conf, mock_temp, mock_info,",
            "                              mock_fetch, mock_is_xen, mock_repl_xen,",
            "                              mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        ctxt.user_id = mock.sentinel.user_id",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock.sentinel.tmp",
            "        dummy = mock.sentinel.dummy",
            "        mock_temp.return_value.__enter__.side_effect = [tmp, dummy]",
            "",
            "        with image_utils.TemporaryImages.fetch(image_service, ctxt,",
            "                                               image_id) as tmp_img:",
            "            self.assertEqual(tmp_img, tmp)",
            "            output = image_utils.fetch_to_volume_format(ctxt, image_service,",
            "                                                        image_id, dest,",
            "                                                        volume_format,",
            "                                                        blocksize)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        self.assertEqual(2, mock_temp.call_count)",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(dummy, run_as_root=True),",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(dest, run_as_root=True)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, None, None)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info',",
            "                side_effect=processutils.ProcessExecutionError)",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_no_qemu_img_and_is_raw(self, mock_conf, mock_temp, mock_info,",
            "                                    mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                    mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "        image_service.show.return_value = {'disk_format': 'raw',",
            "                                           'size': 41126400}",
            "        image_size_m = math.ceil(41126400 / units.Mi)",
            "",
            "        output = image_utils.fetch_to_volume_format(",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_called_once_with(tmp, run_as_root=run_as_root)",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        mock_copy.assert_called_once_with(tmp, dest, image_size_m,",
            "                                          blocksize)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info',",
            "                side_effect=processutils.ProcessExecutionError)",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_no_qemu_img_not_raw(self, mock_conf, mock_temp, mock_info,",
            "                                 mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                 mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "        image_service.show.return_value = {'disk_format': 'not_raw'}",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_called_once_with(tmp, run_as_root=run_as_root)",
            "        self.assertFalse(mock_fetch.called)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info',",
            "                side_effect=processutils.ProcessExecutionError)",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_no_qemu_img_no_metadata(self, mock_conf, mock_temp, mock_info,",
            "                                     mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                     mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "        image_service.show.return_value = None",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_called_once_with(tmp, run_as_root=run_as_root)",
            "        self.assertFalse(mock_fetch.called)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_size_error(self, mock_conf, mock_temp, mock_info, mock_fetch,",
            "                        mock_is_xen, mock_repl_xen, mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 1234",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 4321 * 1024 ** 3",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_qemu_img_parse_error(self, mock_conf, mock_temp, mock_info,",
            "                                  mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                  mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = None",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_backing_file_error(self, mock_conf, mock_temp, mock_info,",
            "                                mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = mock.sentinel.backing_file",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def _test_format_name_mismatch(self, mock_conf, mock_temp, mock_info,",
            "                                   mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                   mock_copy, mock_convert,",
            "                                   legacy_format_name=False):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = 'vhd'",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = 'vpc' if legacy_format_name else 'raw'",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        if legacy_format_name:",
            "            image_utils.fetch_to_volume_format(",
            "                ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "                user_id=user_id, project_id=project_id, size=size,",
            "                run_as_root=run_as_root)",
            "        else:",
            "            self.assertRaises(",
            "                exception.ImageUnacceptable,",
            "                image_utils.fetch_to_volume_format,",
            "                ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "                user_id=user_id, project_id=project_id, size=size,",
            "                run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(dest, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=run_as_root)",
            "",
            "    def test_format_mismatch(self):",
            "        self._test_format_name_mismatch()",
            "",
            "    def test_format_name_mismatch_same_format(self):",
            "        # Make sure no exception is raised because of qemu-img still using",
            "        # the legacy 'vpc' format name if 'vhd' is requested.",
            "        self._test_format_name_mismatch(legacy_format_name=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=True)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_xenserver_to_vhd(self, mock_conf, mock_temp, mock_info,",
            "                              mock_fetch, mock_is_xen, mock_repl_xen,",
            "                              mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.fetch_to_volume_format(",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(dest, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        mock_repl_xen.assert_called_once_with(tmp)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=run_as_root)",
            "",
            "",
            "class TestXenserverUtils(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_format')",
            "    def test_is_xenserver_image(self, mock_format):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "",
            "        output = image_utils.is_xenserver_image(ctxt, image_service, image_id)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_format.assert_called_once_with(image_service.show.return_value)",
            "        self.assertEqual(mock_format.return_value, output)",
            "",
            "    def test_is_xenserver_format(self):",
            "        image_meta1 = {'disk_format': 'vhd', 'container_format': 'ovf'}",
            "        self.assertTrue(image_utils.is_xenserver_format(image_meta1))",
            "",
            "        image_meta2 = {'disk_format': 'test_disk_format',",
            "                       'container_format': 'test_cont_format'}",
            "        self.assertFalse(image_utils.is_xenserver_format(image_meta2))",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_extract_targz(self, mock_exec):",
            "        name = mock.sentinel.archive_name",
            "        target = mock.sentinel.target",
            "",
            "        output = image_utils.extract_targz(name, target)",
            "",
            "        mock_exec.assert_called_once_with('tar', '-xzf', name, '-C', target)",
            "        self.assertIsNone(output)",
            "",
            "",
            "class TestVhdUtils(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_set_vhd_parent(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "        parentpath = mock.sentinel.parentpath",
            "",
            "        output = image_utils.set_vhd_parent(vhd_path, parentpath)",
            "",
            "        mock_exec.assert_called_once_with('vhd-util', 'modify', '-n', vhd_path,",
            "                                          '-p', parentpath)",
            "        self.assertIsNone(output)",
            "",
            "    @mock.patch('cinder.image.image_utils.set_vhd_parent')",
            "    def test_fix_vhd_chain(self, mock_set_parent):",
            "        vhd_chain = (mock.sentinel.first,",
            "                     mock.sentinel.second,",
            "                     mock.sentinel.third,",
            "                     mock.sentinel.fourth,",
            "                     mock.sentinel.fifth)",
            "",
            "        output = image_utils.fix_vhd_chain(vhd_chain)",
            "",
            "        self.assertIsNone(output)",
            "        mock_set_parent.assert_has_calls([",
            "            mock.call(mock.sentinel.first, mock.sentinel.second),",
            "            mock.call(mock.sentinel.second, mock.sentinel.third),",
            "            mock.call(mock.sentinel.third, mock.sentinel.fourth),",
            "            mock.call(mock.sentinel.fourth, mock.sentinel.fifth)])",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute',",
            "                return_value=(98765.43210, mock.sentinel.error))",
            "    def test_get_vhd_size(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "",
            "        output = image_utils.get_vhd_size(vhd_path)",
            "",
            "        mock_exec.assert_called_once_with('vhd-util', 'query', '-n', vhd_path,",
            "                                          '-v')",
            "        self.assertEqual(98765, output)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_resize_vhd(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "        size = 387549349",
            "        journal = mock.sentinel.journal",
            "",
            "        output = image_utils.resize_vhd(vhd_path, size, journal)",
            "",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('vhd-util', 'resize', '-n', vhd_path,",
            "                                          '-s', str(size), '-j', journal)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_coalesce_vhd(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "",
            "        output = image_utils.coalesce_vhd(vhd_path)",
            "",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('vhd-util', 'coalesce', '-n',",
            "                                          vhd_path)",
            "",
            "    @mock.patch('cinder.image.image_utils.coalesce_vhd')",
            "    @mock.patch('cinder.image.image_utils.resize_vhd')",
            "    @mock.patch('cinder.image.image_utils.get_vhd_size')",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_coalesce_chain(self, mock_exec, mock_size, mock_resize,",
            "                            mock_coal):",
            "        vhd_chain = (mock.sentinel.first,",
            "                     mock.sentinel.second,",
            "                     mock.sentinel.third,",
            "                     mock.sentinel.fourth,",
            "                     mock.sentinel.fifth)",
            "",
            "        output = image_utils.coalesce_chain(vhd_chain)",
            "",
            "        self.assertEqual(mock.sentinel.fifth, output)",
            "        mock_size.assert_has_calls([",
            "            mock.call(mock.sentinel.first),",
            "            mock.call(mock.sentinel.second),",
            "            mock.call(mock.sentinel.third),",
            "            mock.call(mock.sentinel.fourth)])",
            "        mock_resize.assert_has_calls([",
            "            mock.call(mock.sentinel.second, mock_size.return_value, mock.ANY),",
            "            mock.call(mock.sentinel.third, mock_size.return_value, mock.ANY),",
            "            mock.call(mock.sentinel.fourth, mock_size.return_value, mock.ANY),",
            "            mock.call(mock.sentinel.fifth, mock_size.return_value, mock.ANY)])",
            "        mock_coal.assert_has_calls([",
            "            mock.call(mock.sentinel.first),",
            "            mock.call(mock.sentinel.second),",
            "            mock.call(mock.sentinel.third),",
            "            mock.call(mock.sentinel.fourth)])",
            "",
            "    @mock.patch('cinder.image.image_utils.os.path')",
            "    def test_discover_vhd_chain(self, mock_path):",
            "        directory = '/some/test/directory'",
            "        mock_path.join.side_effect = lambda x, y: '/'.join((x, y))",
            "        mock_path.exists.side_effect = (True, True, True, False)",
            "",
            "        output = image_utils.discover_vhd_chain(directory)",
            "",
            "        expected_output = ['/some/test/directory/0.vhd',",
            "                           '/some/test/directory/1.vhd',",
            "                           '/some/test/directory/2.vhd']",
            "        self.assertEqual(expected_output, output)",
            "",
            "    @mock.patch('cinder.image.image_utils.temporary_dir')",
            "    @mock.patch('cinder.image.image_utils.os.rename')",
            "    @mock.patch('cinder.image.image_utils.fileutils.delete_if_exists')",
            "    @mock.patch('cinder.image.image_utils.coalesce_chain')",
            "    @mock.patch('cinder.image.image_utils.fix_vhd_chain')",
            "    @mock.patch('cinder.image.image_utils.discover_vhd_chain')",
            "    @mock.patch('cinder.image.image_utils.extract_targz')",
            "    def test_replace_xenserver_image_with_coalesced_vhd(",
            "            self, mock_targz, mock_discover, mock_fix, mock_coal, mock_delete,",
            "            mock_rename, mock_temp):",
            "        image_file = mock.sentinel.image_file",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.replace_xenserver_image_with_coalesced_vhd(",
            "            image_file)",
            "",
            "        self.assertIsNone(output)",
            "        mock_targz.assert_called_once_with(image_file, tmp)",
            "        mock_discover.assert_called_once_with(tmp)",
            "        mock_fix.assert_called_once_with(mock_discover.return_value)",
            "        mock_coal.assert_called_once_with(mock_discover.return_value)",
            "        mock_delete.assert_called_once_with(image_file)",
            "        mock_rename.assert_called_once_with(mock_coal.return_value, image_file)",
            "",
            "",
            "class TestCreateTemporaryFile(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.os.close')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('cinder.image.image_utils.os.path.exists')",
            "    @mock.patch('cinder.image.image_utils.os.makedirs')",
            "    @mock.patch('cinder.image.image_utils.tempfile.mkstemp')",
            "    def test_create_temporary_file_no_dir(self, mock_mkstemp, mock_dirs,",
            "                                          mock_path, mock_conf, mock_close):",
            "        mock_conf.image_conversion_dir = None",
            "        fd = mock.sentinel.file_descriptor",
            "        path = mock.sentinel.absolute_pathname",
            "        mock_mkstemp.return_value = (fd, path)",
            "",
            "        output = image_utils.create_temporary_file()",
            "",
            "        self.assertEqual(path, output)",
            "        mock_mkstemp.assert_called_once_with(dir=None)",
            "        mock_close.assert_called_once_with(fd)",
            "",
            "    @mock.patch('cinder.image.image_utils.os.close')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('cinder.image.image_utils.os.path.exists', return_value=True)",
            "    @mock.patch('cinder.image.image_utils.os.makedirs')",
            "    @mock.patch('cinder.image.image_utils.tempfile.mkstemp')",
            "    def test_create_temporary_file_with_dir(self, mock_mkstemp, mock_dirs,",
            "                                            mock_path, mock_conf, mock_close):",
            "        conv_dir = mock.sentinel.image_conversion_dir",
            "        mock_conf.image_conversion_dir = conv_dir",
            "        fd = mock.sentinel.file_descriptor",
            "        path = mock.sentinel.absolute_pathname",
            "        mock_mkstemp.return_value = (fd, path)",
            "",
            "        output = image_utils.create_temporary_file()",
            "",
            "        self.assertEqual(path, output)",
            "        self.assertFalse(mock_dirs.called)",
            "        mock_mkstemp.assert_called_once_with(dir=conv_dir)",
            "        mock_close.assert_called_once_with(fd)",
            "",
            "    @mock.patch('cinder.image.image_utils.os.close')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('cinder.image.image_utils.os.path.exists', return_value=False)",
            "    @mock.patch('cinder.image.image_utils.os.makedirs')",
            "    @mock.patch('cinder.image.image_utils.tempfile.mkstemp')",
            "    def test_create_temporary_file_and_dir(self, mock_mkstemp, mock_dirs,",
            "                                           mock_path, mock_conf, mock_close):",
            "        conv_dir = mock.sentinel.image_conversion_dir",
            "        mock_conf.image_conversion_dir = conv_dir",
            "        fd = mock.sentinel.file_descriptor",
            "        path = mock.sentinel.absolute_pathname",
            "        mock_mkstemp.return_value = (fd, path)",
            "",
            "        output = image_utils.create_temporary_file()",
            "",
            "        self.assertEqual(path, output)",
            "        mock_dirs.assert_called_once_with(conv_dir)",
            "        mock_mkstemp.assert_called_once_with(dir=conv_dir)",
            "        mock_close.assert_called_once_with(fd)",
            "",
            "",
            "class TestTemporaryFileContextManager(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.create_temporary_file',",
            "                return_value=mock.sentinel.temporary_file)",
            "    @mock.patch('cinder.image.image_utils.fileutils.delete_if_exists')",
            "    def test_temporary_file(self, mock_delete, mock_create):",
            "        with image_utils.temporary_file() as tmp_file:",
            "            self.assertEqual(mock.sentinel.temporary_file, tmp_file)",
            "            self.assertFalse(mock_delete.called)",
            "        mock_delete.assert_called_once_with(mock.sentinel.temporary_file)"
        ],
        "afterPatchFile": [
            "",
            "# Copyright (c) 2013 eNovance , Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"Unit tests for image utils.\"\"\"",
            "",
            "import math",
            "",
            "import mock",
            "from oslo_concurrency import processutils",
            "from oslo_utils import units",
            "",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder import test",
            "from cinder.volume import throttling",
            "",
            "",
            "class TestQemuImgInfo(test.TestCase):",
            "    @mock.patch('cinder.openstack.common.imageutils.QemuImgInfo')",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_qemu_img_info(self, mock_exec, mock_info):",
            "        mock_out = mock.sentinel.out",
            "        mock_err = mock.sentinel.err",
            "        test_path = mock.sentinel.path",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "",
            "        output = image_utils.qemu_img_info(test_path)",
            "        mock_exec.assert_called_once_with('env', 'LC_ALL=C', 'qemu-img',",
            "                                          'info', test_path, run_as_root=True,",
            "                                          prlimit=image_utils.QEMU_IMG_LIMITS)",
            "        self.assertEqual(mock_info.return_value, output)",
            "",
            "    @mock.patch('cinder.openstack.common.imageutils.QemuImgInfo')",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_qemu_img_info_not_root(self, mock_exec, mock_info):",
            "        mock_out = mock.sentinel.out",
            "        mock_err = mock.sentinel.err",
            "        test_path = mock.sentinel.path",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "",
            "        output = image_utils.qemu_img_info(test_path, run_as_root=False)",
            "        mock_exec.assert_called_once_with('env', 'LC_ALL=C', 'qemu-img',",
            "                                          'info', test_path, run_as_root=False,",
            "                                          prlimit=image_utils.QEMU_IMG_LIMITS)",
            "        self.assertEqual(mock_info.return_value, output)",
            "",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    @mock.patch('cinder.openstack.common.imageutils.QemuImgInfo')",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_qemu_img_info_on_nt(self, mock_exec, mock_info, mock_os):",
            "        mock_out = mock.sentinel.out",
            "        mock_err = mock.sentinel.err",
            "        test_path = mock.sentinel.path",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "        mock_os.name = 'nt'",
            "",
            "        output = image_utils.qemu_img_info(test_path)",
            "        mock_exec.assert_called_once_with('qemu-img', 'info', test_path,",
            "                                          run_as_root=True,",
            "                                          prlimit=image_utils.QEMU_IMG_LIMITS)",
            "        self.assertEqual(mock_info.return_value, output)",
            "",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_get_qemu_img_version(self, mock_exec):",
            "        mock_out = \"qemu-img version 2.0.0\"",
            "        mock_err = mock.sentinel.err",
            "        mock_exec.return_value = (mock_out, mock_err)",
            "",
            "        expected_version = [2, 0, 0]",
            "        version = image_utils.get_qemu_img_version()",
            "",
            "        mock_exec.assert_called_once_with('qemu-img', '--help',",
            "                                          check_exit_code=False)",
            "        self.assertEqual(expected_version, version)",
            "",
            "    @mock.patch.object(image_utils, 'get_qemu_img_version')",
            "    def test_validate_qemu_img_version(self, mock_get_qemu_img_version):",
            "        fake_current_version = [1, 8]",
            "        mock_get_qemu_img_version.return_value = fake_current_version",
            "        minimum_version = '1.8'",
            "",
            "        image_utils.check_qemu_img_version(minimum_version)",
            "",
            "        mock_get_qemu_img_version.assert_called_once_with()",
            "",
            "    @mock.patch.object(image_utils, 'get_qemu_img_version')",
            "    def _test_validate_unsupported_qemu_img_version(self,",
            "                                                    mock_get_qemu_img_version,",
            "                                                    current_version=None):",
            "        mock_get_qemu_img_version.return_value = current_version",
            "        minimum_version = '2.0'",
            "",
            "        self.assertRaises(exception.VolumeBackendAPIException,",
            "                          image_utils.check_qemu_img_version,",
            "                          minimum_version)",
            "",
            "        mock_get_qemu_img_version.assert_called_once_with()",
            "",
            "    def test_validate_qemu_img_version_not_installed(self):",
            "        self._test_validate_unsupported_qemu_img_version()",
            "",
            "    def test_validate_older_qemu_img_version(self):",
            "        self._test_validate_unsupported_qemu_img_version(",
            "            current_version=[1, 8])",
            "",
            "",
            "class TestConvertImage(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.os.stat')",
            "    @mock.patch('cinder.utils.execute')",
            "    @mock.patch('cinder.utils.is_blk_device', return_value=True)",
            "    def test_defaults_block_dev(self, mock_isblk, mock_exec,",
            "                                mock_stat):",
            "        source = mock.sentinel.source",
            "        dest = mock.sentinel.dest",
            "        out_format = mock.sentinel.out_format",
            "        mock_stat.return_value.st_size = 1048576",
            "        throttle = throttling.Throttle(prefix=['cgcmd'])",
            "",
            "        with mock.patch('cinder.volume.utils.check_for_odirect_support',",
            "                        return_value=True):",
            "            output = image_utils.convert_image(source, dest, out_format,",
            "                                               throttle=throttle)",
            "",
            "            self.assertIsNone(output)",
            "            mock_exec.assert_called_once_with('cgcmd', 'qemu-img', 'convert',",
            "                                              '-t', 'none', '-O', out_format,",
            "                                              source, dest, run_as_root=True)",
            "",
            "        mock_exec.reset_mock()",
            "",
            "        with mock.patch('cinder.volume.utils.check_for_odirect_support',",
            "                        return_value=False):",
            "            output = image_utils.convert_image(source, dest, out_format)",
            "",
            "            self.assertIsNone(output)",
            "            mock_exec.assert_called_once_with('qemu-img', 'convert',",
            "                                              '-O', out_format, source, dest,",
            "                                              run_as_root=True)",
            "",
            "    @mock.patch('cinder.volume.utils.check_for_odirect_support',",
            "                return_value=True)",
            "    @mock.patch('cinder.image.image_utils.os.stat')",
            "    @mock.patch('cinder.utils.execute')",
            "    @mock.patch('cinder.utils.is_blk_device', return_value=False)",
            "    def test_defaults_not_block_dev(self, mock_isblk, mock_exec,",
            "                                    mock_stat, mock_odirect):",
            "        source = mock.sentinel.source",
            "        dest = mock.sentinel.dest",
            "        out_format = mock.sentinel.out_format",
            "        mock_stat.return_value.st_size = 1048576",
            "",
            "        output = image_utils.convert_image(source, dest, out_format)",
            "",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('qemu-img', 'convert', '-O',",
            "                                          out_format, source, dest,",
            "                                          run_as_root=True)",
            "",
            "",
            "class TestResizeImage(test.TestCase):",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_defaults(self, mock_exec):",
            "        source = mock.sentinel.source",
            "        size = mock.sentinel.size",
            "        output = image_utils.resize_image(source, size)",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('qemu-img', 'resize', source,",
            "                                          'sentinel.sizeG', run_as_root=False)",
            "",
            "    @mock.patch('cinder.utils.execute')",
            "    def test_run_as_root(self, mock_exec):",
            "        source = mock.sentinel.source",
            "        size = mock.sentinel.size",
            "        output = image_utils.resize_image(source, size, run_as_root=True)",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('qemu-img', 'resize', source,",
            "                                          'sentinel.sizeG', run_as_root=True)",
            "",
            "",
            "class TestFetch(test.TestCase):",
            "    @mock.patch('os.stat')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    def test_defaults(self, mock_fileutils, mock_stat):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        path = 'test_path'",
            "        _user_id = mock.sentinel._user_id",
            "        _project_id = mock.sentinel._project_id",
            "        mock_open = mock.mock_open()",
            "        mock_stat.return_value.st_size = 1048576",
            "",
            "        with mock.patch('cinder.image.image_utils.open',",
            "                        new=mock_open, create=True):",
            "            output = image_utils.fetch(ctxt, image_service, image_id, path,",
            "                                       _user_id, _project_id)",
            "        self.assertIsNone(output)",
            "        image_service.download.assert_called_once_with(ctxt, image_id,",
            "                                                       mock_open.return_value)",
            "        mock_open.assert_called_once_with(path, 'wb')",
            "        mock_fileutils.remove_path_on_error.assert_called_once_with(path)",
            "        (mock_fileutils.remove_path_on_error.return_value.__enter__",
            "            .assert_called_once_with())",
            "        (mock_fileutils.remove_path_on_error.return_value.__exit__",
            "            .assert_called_once_with(None, None, None))",
            "",
            "",
            "class TestVerifyImage(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_defaults(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = None",
            "",
            "        output = image_utils.fetch_verify_image(ctxt, image_service,",
            "                                                image_id, dest)",
            "        self.assertIsNone(output)",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           dest, None, None)",
            "        mock_info.assert_called_once_with(dest, run_as_root=True)",
            "        mock_fileutils.remove_path_on_error.assert_called_once_with(dest)",
            "        (mock_fileutils.remove_path_on_error.return_value.__enter__",
            "            .assert_called_once_with())",
            "        (mock_fileutils.remove_path_on_error.return_value.__exit__",
            "            .assert_called_once_with(None, None, None))",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_kwargs(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 2",
            "        run_as_root = mock.sentinel.run_as_root",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = None",
            "        mock_data.virtual_size = 1",
            "",
            "        output = image_utils.fetch_verify_image(",
            "            ctxt, image_service, image_id, dest, user_id=user_id,",
            "            project_id=project_id, size=size, run_as_root=run_as_root)",
            "        self.assertIsNone(output)",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           dest, None, None)",
            "        mock_info.assert_called_once_with(dest, run_as_root=run_as_root)",
            "        mock_fileutils.remove_path_on_error.assert_called_once_with(dest)",
            "        (mock_fileutils.remove_path_on_error.return_value.__enter__",
            "            .assert_called_once_with())",
            "        (mock_fileutils.remove_path_on_error.return_value.__exit__",
            "            .assert_called_once_with(None, None, None))",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_format_error(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = None",
            "        mock_data.backing_file = None",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          ctxt, image_service, image_id, dest)",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_backing_file_error(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = 'test_backing_file'",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          ctxt, image_service, image_id, dest)",
            "",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.fileutils')",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    def test_size_error(self, mock_fetch, mock_fileutils, mock_info):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        size = 1",
            "        mock_data = mock_info.return_value",
            "        mock_data.file_format = 'test_format'",
            "        mock_data.backing_file = None",
            "        mock_data.virtual_size = 2",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          ctxt, image_service, image_id, dest, size=size)",
            "",
            "",
            "class TestTemporaryDir(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('os.makedirs')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('cinder.image.image_utils.utils.tempdir')",
            "    def test_conv_dir_exists(self, mock_tempdir, mock_exists, mock_make,",
            "                             mock_conf):",
            "        mock_conf.image_conversion_dir = mock.sentinel.conv_dir",
            "",
            "        output = image_utils.temporary_dir()",
            "",
            "        self.assertFalse(mock_make.called)",
            "        mock_tempdir.assert_called_once_with(dir=mock.sentinel.conv_dir)",
            "        self.assertEqual(output, mock_tempdir.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('os.makedirs')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    @mock.patch('cinder.image.image_utils.utils.tempdir')",
            "    def test_create_conv_dir(self, mock_tempdir, mock_exists, mock_make,",
            "                             mock_conf):",
            "        mock_conf.image_conversion_dir = mock.sentinel.conv_dir",
            "",
            "        output = image_utils.temporary_dir()",
            "",
            "        mock_make.assert_called_once_with(mock.sentinel.conv_dir)",
            "        mock_tempdir.assert_called_once_with(dir=mock.sentinel.conv_dir)",
            "        self.assertEqual(output, mock_tempdir.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('os.makedirs')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    @mock.patch('cinder.image.image_utils.utils.tempdir')",
            "    def test_no_conv_dir(self, mock_tempdir, mock_exists, mock_make,",
            "                         mock_conf):",
            "        mock_conf.image_conversion_dir = None",
            "",
            "        output = image_utils.temporary_dir()",
            "",
            "        self.assertFalse(mock_make.called)",
            "        mock_tempdir.assert_called_once_with(dir=None)",
            "        self.assertEqual(output, mock_tempdir.return_value)",
            "",
            "",
            "class TestUploadVolume(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_diff_format(self, mock_os, mock_temp, mock_convert, mock_info,",
            "                         mock_open, mock_conf):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': mock.sentinel.disk_format}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'posix'",
            "        data = mock_info.return_value",
            "        data.file_format = mock.sentinel.disk_format",
            "        data.backing_file = None",
            "        temp_file = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.upload_volume(ctxt, image_service, image_meta,",
            "                                           volume_path)",
            "",
            "        self.assertIsNone(output)",
            "        mock_convert.assert_called_once_with(volume_path,",
            "                                             temp_file,",
            "                                             mock.sentinel.disk_format,",
            "                                             run_as_root=True)",
            "        mock_info.assert_called_with(temp_file, run_as_root=True)",
            "        self.assertEqual(2, mock_info.call_count)",
            "        mock_open.assert_called_once_with(temp_file, 'rb')",
            "        image_service.update.assert_called_once_with(",
            "            ctxt, image_meta['id'], {},",
            "            mock_open.return_value.__enter__.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.temporary_chown')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_same_format(self, mock_os, mock_temp, mock_convert, mock_info,",
            "                         mock_open, mock_conf, mock_chown):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': 'raw'}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'posix'",
            "        mock_os.access.return_value = False",
            "",
            "        output = image_utils.upload_volume(ctxt, image_service, image_meta,",
            "                                           volume_path)",
            "",
            "        self.assertIsNone(output)",
            "        self.assertFalse(mock_convert.called)",
            "        self.assertFalse(mock_info.called)",
            "        mock_chown.assert_called_once_with(volume_path)",
            "        mock_open.assert_called_once_with(volume_path)",
            "        image_service.update.assert_called_once_with(",
            "            ctxt, image_meta['id'], {},",
            "            mock_open.return_value.__enter__.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.temporary_chown')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_same_format_on_nt(self, mock_os, mock_temp, mock_convert,",
            "                               mock_info, mock_open, mock_conf, mock_chown):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': 'raw'}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'nt'",
            "        mock_os.access.return_value = False",
            "",
            "        output = image_utils.upload_volume(ctxt, image_service, image_meta,",
            "                                           volume_path)",
            "",
            "        self.assertIsNone(output)",
            "        self.assertFalse(mock_convert.called)",
            "        self.assertFalse(mock_info.called)",
            "        mock_open.assert_called_once_with(volume_path, 'rb')",
            "        image_service.update.assert_called_once_with(",
            "            ctxt, image_meta['id'], {},",
            "            mock_open.return_value.__enter__.return_value)",
            "",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('six.moves.builtins.open')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.os')",
            "    def test_convert_error(self, mock_os, mock_temp, mock_convert, mock_info,",
            "                           mock_open, mock_conf):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_meta = {'id': 'test_id',",
            "                      'disk_format': mock.sentinel.disk_format}",
            "        volume_path = mock.sentinel.volume_path",
            "        mock_os.name = 'posix'",
            "        data = mock_info.return_value",
            "        data.file_format = mock.sentinel.other_disk_format",
            "        data.backing_file = None",
            "        temp_file = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.upload_volume,",
            "                          ctxt, image_service, image_meta, volume_path)",
            "        mock_convert.assert_called_once_with(volume_path,",
            "                                             temp_file,",
            "                                             mock.sentinel.disk_format,",
            "                                             run_as_root=True)",
            "        mock_info.assert_called_with(temp_file, run_as_root=True)",
            "        self.assertEqual(2, mock_info.call_count)",
            "        self.assertFalse(image_service.update.called)",
            "",
            "",
            "class TestFetchToVhd(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_defaults(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        output = image_utils.fetch_to_vhd(ctxt, image_service, image_id,",
            "                                          dest, blocksize)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'vpc', blocksize, None,",
            "                                              None, run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_kwargs(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        output = image_utils.fetch_to_vhd(ctxt, image_service, image_id,",
            "                                          dest, blocksize, user_id=user_id,",
            "                                          project_id=project_id,",
            "                                          run_as_root=run_as_root)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'vpc', blocksize, user_id,",
            "                                              project_id,",
            "                                              run_as_root=run_as_root)",
            "",
            "",
            "class TestFetchToRaw(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_defaults(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        output = image_utils.fetch_to_raw(ctxt, image_service, image_id,",
            "                                          dest, blocksize)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'raw', blocksize, None,",
            "                                              None, None, run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.fetch_to_volume_format')",
            "    def test_kwargs(self, mock_fetch_to):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.sentinel.image_service",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        blocksize = mock.sentinel.blocksize",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = mock.sentinel.size",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        output = image_utils.fetch_to_raw(ctxt, image_service, image_id,",
            "                                          dest, blocksize, user_id=user_id,",
            "                                          project_id=project_id, size=size,",
            "                                          run_as_root=run_as_root)",
            "        self.assertIsNone(output)",
            "        mock_fetch_to.assert_called_once_with(ctxt, image_service, image_id,",
            "                                              dest, 'raw', blocksize, user_id,",
            "                                              project_id, size,",
            "                                              run_as_root=run_as_root)",
            "",
            "",
            "class TestFetchToVolumeFormat(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_defaults(self, mock_conf, mock_temp, mock_info, mock_fetch,",
            "                      mock_is_xen, mock_repl_xen, mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        ctxt.user_id = mock.sentinel.user_id",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.fetch_to_volume_format(ctxt, image_service,",
            "                                                    image_id, dest,",
            "                                                    volume_format, blocksize)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(dest, run_as_root=True)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, None, None)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_kwargs(self, mock_conf, mock_temp, mock_info, mock_fetch,",
            "                    mock_is_xen, mock_repl_xen, mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.fetch_to_volume_format(",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(dest, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=run_as_root)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_temporary_images(self, mock_conf, mock_temp, mock_info,",
            "                              mock_fetch, mock_is_xen, mock_repl_xen,",
            "                              mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        ctxt.user_id = mock.sentinel.user_id",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock.sentinel.tmp",
            "        dummy = mock.sentinel.dummy",
            "        mock_temp.return_value.__enter__.side_effect = [tmp, dummy]",
            "",
            "        with image_utils.TemporaryImages.fetch(image_service, ctxt,",
            "                                               image_id) as tmp_img:",
            "            self.assertEqual(tmp_img, tmp)",
            "            output = image_utils.fetch_to_volume_format(ctxt, image_service,",
            "                                                        image_id, dest,",
            "                                                        volume_format,",
            "                                                        blocksize)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        self.assertEqual(2, mock_temp.call_count)",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(dummy, run_as_root=True),",
            "            mock.call(tmp, run_as_root=True),",
            "            mock.call(dest, run_as_root=True)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, None, None)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info',",
            "                side_effect=processutils.ProcessExecutionError)",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_no_qemu_img_and_is_raw(self, mock_conf, mock_temp, mock_info,",
            "                                    mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                    mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "        image_service.show.return_value = {'disk_format': 'raw',",
            "                                           'size': 41126400}",
            "        image_size_m = math.ceil(41126400 / units.Mi)",
            "",
            "        output = image_utils.fetch_to_volume_format(",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_called_once_with(tmp, run_as_root=run_as_root)",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        mock_copy.assert_called_once_with(tmp, dest, image_size_m,",
            "                                          blocksize)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info',",
            "                side_effect=processutils.ProcessExecutionError)",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_no_qemu_img_not_raw(self, mock_conf, mock_temp, mock_info,",
            "                                 mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                 mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "        image_service.show.return_value = {'disk_format': 'not_raw'}",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_called_once_with(tmp, run_as_root=run_as_root)",
            "        self.assertFalse(mock_fetch.called)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info',",
            "                side_effect=processutils.ProcessExecutionError)",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_no_qemu_img_no_metadata(self, mock_conf, mock_temp, mock_info,",
            "                                     mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                     mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "        image_service.show.return_value = None",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_called_once_with(tmp, run_as_root=run_as_root)",
            "        self.assertFalse(mock_fetch.called)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_size_error(self, mock_conf, mock_temp, mock_info, mock_fetch,",
            "                        mock_is_xen, mock_repl_xen, mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 1234",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 4321 * 1024 ** 3",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_qemu_img_parse_error(self, mock_conf, mock_temp, mock_info,",
            "                                  mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                  mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = None",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_backing_file_error(self, mock_conf, mock_temp, mock_info,",
            "                                mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = mock.sentinel.backing_file",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        self.assertRaises(",
            "            exception.ImageUnacceptable,",
            "            image_utils.fetch_to_volume_format,",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        self.assertFalse(mock_convert.called)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=False)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def _test_format_name_mismatch(self, mock_conf, mock_temp, mock_info,",
            "                                   mock_fetch, mock_is_xen, mock_repl_xen,",
            "                                   mock_copy, mock_convert,",
            "                                   legacy_format_name=False):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = 'vhd'",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = 'vpc' if legacy_format_name else 'raw'",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        if legacy_format_name:",
            "            image_utils.fetch_to_volume_format(",
            "                ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "                user_id=user_id, project_id=project_id, size=size,",
            "                run_as_root=run_as_root)",
            "        else:",
            "            self.assertRaises(",
            "                exception.ImageUnacceptable,",
            "                image_utils.fetch_to_volume_format,",
            "                ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "                user_id=user_id, project_id=project_id, size=size,",
            "                run_as_root=run_as_root)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(dest, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        self.assertFalse(mock_repl_xen.called)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=run_as_root)",
            "",
            "    def test_format_mismatch(self):",
            "        self._test_format_name_mismatch()",
            "",
            "    def test_format_name_mismatch_same_format(self):",
            "        # Make sure no exception is raised because of qemu-img still using",
            "        # the legacy 'vpc' format name if 'vhd' is requested.",
            "        self._test_format_name_mismatch(legacy_format_name=True)",
            "",
            "    @mock.patch('cinder.image.image_utils.convert_image')",
            "    @mock.patch('cinder.image.image_utils.volume_utils.copy_volume')",
            "    @mock.patch(",
            "        'cinder.image.image_utils.replace_xenserver_image_with_coalesced_vhd')",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_image',",
            "                return_value=True)",
            "    @mock.patch('cinder.image.image_utils.fetch')",
            "    @mock.patch('cinder.image.image_utils.qemu_img_info')",
            "    @mock.patch('cinder.image.image_utils.temporary_file')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    def test_xenserver_to_vhd(self, mock_conf, mock_temp, mock_info,",
            "                              mock_fetch, mock_is_xen, mock_repl_xen,",
            "                              mock_copy, mock_convert):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock(temp_images=None)",
            "        image_id = mock.sentinel.image_id",
            "        dest = mock.sentinel.dest",
            "        volume_format = mock.sentinel.volume_format",
            "        blocksize = mock.sentinel.blocksize",
            "        ctxt.user_id = user_id = mock.sentinel.user_id",
            "        project_id = mock.sentinel.project_id",
            "        size = 4321",
            "        run_as_root = mock.sentinel.run_as_root",
            "",
            "        data = mock_info.return_value",
            "        data.file_format = volume_format",
            "        data.backing_file = None",
            "        data.virtual_size = 1234",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.fetch_to_volume_format(",
            "            ctxt, image_service, image_id, dest, volume_format, blocksize,",
            "            user_id=user_id, project_id=project_id, size=size,",
            "            run_as_root=run_as_root)",
            "",
            "        self.assertIsNone(output)",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_temp.assert_called_once_with()",
            "        mock_info.assert_has_calls([",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(tmp, run_as_root=run_as_root),",
            "            mock.call(dest, run_as_root=run_as_root)])",
            "        mock_fetch.assert_called_once_with(ctxt, image_service, image_id,",
            "                                           tmp, user_id, project_id)",
            "        mock_repl_xen.assert_called_once_with(tmp)",
            "        self.assertFalse(mock_copy.called)",
            "        mock_convert.assert_called_once_with(tmp, dest, volume_format,",
            "                                             run_as_root=run_as_root)",
            "",
            "",
            "class TestXenserverUtils(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.is_xenserver_format')",
            "    def test_is_xenserver_image(self, mock_format):",
            "        ctxt = mock.sentinel.context",
            "        image_service = mock.Mock()",
            "        image_id = mock.sentinel.image_id",
            "",
            "        output = image_utils.is_xenserver_image(ctxt, image_service, image_id)",
            "",
            "        image_service.show.assert_called_once_with(ctxt, image_id)",
            "        mock_format.assert_called_once_with(image_service.show.return_value)",
            "        self.assertEqual(mock_format.return_value, output)",
            "",
            "    def test_is_xenserver_format(self):",
            "        image_meta1 = {'disk_format': 'vhd', 'container_format': 'ovf'}",
            "        self.assertTrue(image_utils.is_xenserver_format(image_meta1))",
            "",
            "        image_meta2 = {'disk_format': 'test_disk_format',",
            "                       'container_format': 'test_cont_format'}",
            "        self.assertFalse(image_utils.is_xenserver_format(image_meta2))",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_extract_targz(self, mock_exec):",
            "        name = mock.sentinel.archive_name",
            "        target = mock.sentinel.target",
            "",
            "        output = image_utils.extract_targz(name, target)",
            "",
            "        mock_exec.assert_called_once_with('tar', '-xzf', name, '-C', target)",
            "        self.assertIsNone(output)",
            "",
            "",
            "class TestVhdUtils(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_set_vhd_parent(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "        parentpath = mock.sentinel.parentpath",
            "",
            "        output = image_utils.set_vhd_parent(vhd_path, parentpath)",
            "",
            "        mock_exec.assert_called_once_with('vhd-util', 'modify', '-n', vhd_path,",
            "                                          '-p', parentpath)",
            "        self.assertIsNone(output)",
            "",
            "    @mock.patch('cinder.image.image_utils.set_vhd_parent')",
            "    def test_fix_vhd_chain(self, mock_set_parent):",
            "        vhd_chain = (mock.sentinel.first,",
            "                     mock.sentinel.second,",
            "                     mock.sentinel.third,",
            "                     mock.sentinel.fourth,",
            "                     mock.sentinel.fifth)",
            "",
            "        output = image_utils.fix_vhd_chain(vhd_chain)",
            "",
            "        self.assertIsNone(output)",
            "        mock_set_parent.assert_has_calls([",
            "            mock.call(mock.sentinel.first, mock.sentinel.second),",
            "            mock.call(mock.sentinel.second, mock.sentinel.third),",
            "            mock.call(mock.sentinel.third, mock.sentinel.fourth),",
            "            mock.call(mock.sentinel.fourth, mock.sentinel.fifth)])",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute',",
            "                return_value=(98765.43210, mock.sentinel.error))",
            "    def test_get_vhd_size(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "",
            "        output = image_utils.get_vhd_size(vhd_path)",
            "",
            "        mock_exec.assert_called_once_with('vhd-util', 'query', '-n', vhd_path,",
            "                                          '-v')",
            "        self.assertEqual(98765, output)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_resize_vhd(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "        size = 387549349",
            "        journal = mock.sentinel.journal",
            "",
            "        output = image_utils.resize_vhd(vhd_path, size, journal)",
            "",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('vhd-util', 'resize', '-n', vhd_path,",
            "                                          '-s', str(size), '-j', journal)",
            "",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_coalesce_vhd(self, mock_exec):",
            "        vhd_path = mock.sentinel.vhd_path",
            "",
            "        output = image_utils.coalesce_vhd(vhd_path)",
            "",
            "        self.assertIsNone(output)",
            "        mock_exec.assert_called_once_with('vhd-util', 'coalesce', '-n',",
            "                                          vhd_path)",
            "",
            "    @mock.patch('cinder.image.image_utils.coalesce_vhd')",
            "    @mock.patch('cinder.image.image_utils.resize_vhd')",
            "    @mock.patch('cinder.image.image_utils.get_vhd_size')",
            "    @mock.patch('cinder.image.image_utils.utils.execute')",
            "    def test_coalesce_chain(self, mock_exec, mock_size, mock_resize,",
            "                            mock_coal):",
            "        vhd_chain = (mock.sentinel.first,",
            "                     mock.sentinel.second,",
            "                     mock.sentinel.third,",
            "                     mock.sentinel.fourth,",
            "                     mock.sentinel.fifth)",
            "",
            "        output = image_utils.coalesce_chain(vhd_chain)",
            "",
            "        self.assertEqual(mock.sentinel.fifth, output)",
            "        mock_size.assert_has_calls([",
            "            mock.call(mock.sentinel.first),",
            "            mock.call(mock.sentinel.second),",
            "            mock.call(mock.sentinel.third),",
            "            mock.call(mock.sentinel.fourth)])",
            "        mock_resize.assert_has_calls([",
            "            mock.call(mock.sentinel.second, mock_size.return_value, mock.ANY),",
            "            mock.call(mock.sentinel.third, mock_size.return_value, mock.ANY),",
            "            mock.call(mock.sentinel.fourth, mock_size.return_value, mock.ANY),",
            "            mock.call(mock.sentinel.fifth, mock_size.return_value, mock.ANY)])",
            "        mock_coal.assert_has_calls([",
            "            mock.call(mock.sentinel.first),",
            "            mock.call(mock.sentinel.second),",
            "            mock.call(mock.sentinel.third),",
            "            mock.call(mock.sentinel.fourth)])",
            "",
            "    @mock.patch('cinder.image.image_utils.os.path')",
            "    def test_discover_vhd_chain(self, mock_path):",
            "        directory = '/some/test/directory'",
            "        mock_path.join.side_effect = lambda x, y: '/'.join((x, y))",
            "        mock_path.exists.side_effect = (True, True, True, False)",
            "",
            "        output = image_utils.discover_vhd_chain(directory)",
            "",
            "        expected_output = ['/some/test/directory/0.vhd',",
            "                           '/some/test/directory/1.vhd',",
            "                           '/some/test/directory/2.vhd']",
            "        self.assertEqual(expected_output, output)",
            "",
            "    @mock.patch('cinder.image.image_utils.temporary_dir')",
            "    @mock.patch('cinder.image.image_utils.os.rename')",
            "    @mock.patch('cinder.image.image_utils.fileutils.delete_if_exists')",
            "    @mock.patch('cinder.image.image_utils.coalesce_chain')",
            "    @mock.patch('cinder.image.image_utils.fix_vhd_chain')",
            "    @mock.patch('cinder.image.image_utils.discover_vhd_chain')",
            "    @mock.patch('cinder.image.image_utils.extract_targz')",
            "    def test_replace_xenserver_image_with_coalesced_vhd(",
            "            self, mock_targz, mock_discover, mock_fix, mock_coal, mock_delete,",
            "            mock_rename, mock_temp):",
            "        image_file = mock.sentinel.image_file",
            "        tmp = mock_temp.return_value.__enter__.return_value",
            "",
            "        output = image_utils.replace_xenserver_image_with_coalesced_vhd(",
            "            image_file)",
            "",
            "        self.assertIsNone(output)",
            "        mock_targz.assert_called_once_with(image_file, tmp)",
            "        mock_discover.assert_called_once_with(tmp)",
            "        mock_fix.assert_called_once_with(mock_discover.return_value)",
            "        mock_coal.assert_called_once_with(mock_discover.return_value)",
            "        mock_delete.assert_called_once_with(image_file)",
            "        mock_rename.assert_called_once_with(mock_coal.return_value, image_file)",
            "",
            "",
            "class TestCreateTemporaryFile(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.os.close')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('cinder.image.image_utils.os.path.exists')",
            "    @mock.patch('cinder.image.image_utils.os.makedirs')",
            "    @mock.patch('cinder.image.image_utils.tempfile.mkstemp')",
            "    def test_create_temporary_file_no_dir(self, mock_mkstemp, mock_dirs,",
            "                                          mock_path, mock_conf, mock_close):",
            "        mock_conf.image_conversion_dir = None",
            "        fd = mock.sentinel.file_descriptor",
            "        path = mock.sentinel.absolute_pathname",
            "        mock_mkstemp.return_value = (fd, path)",
            "",
            "        output = image_utils.create_temporary_file()",
            "",
            "        self.assertEqual(path, output)",
            "        mock_mkstemp.assert_called_once_with(dir=None)",
            "        mock_close.assert_called_once_with(fd)",
            "",
            "    @mock.patch('cinder.image.image_utils.os.close')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('cinder.image.image_utils.os.path.exists', return_value=True)",
            "    @mock.patch('cinder.image.image_utils.os.makedirs')",
            "    @mock.patch('cinder.image.image_utils.tempfile.mkstemp')",
            "    def test_create_temporary_file_with_dir(self, mock_mkstemp, mock_dirs,",
            "                                            mock_path, mock_conf, mock_close):",
            "        conv_dir = mock.sentinel.image_conversion_dir",
            "        mock_conf.image_conversion_dir = conv_dir",
            "        fd = mock.sentinel.file_descriptor",
            "        path = mock.sentinel.absolute_pathname",
            "        mock_mkstemp.return_value = (fd, path)",
            "",
            "        output = image_utils.create_temporary_file()",
            "",
            "        self.assertEqual(path, output)",
            "        self.assertFalse(mock_dirs.called)",
            "        mock_mkstemp.assert_called_once_with(dir=conv_dir)",
            "        mock_close.assert_called_once_with(fd)",
            "",
            "    @mock.patch('cinder.image.image_utils.os.close')",
            "    @mock.patch('cinder.image.image_utils.CONF')",
            "    @mock.patch('cinder.image.image_utils.os.path.exists', return_value=False)",
            "    @mock.patch('cinder.image.image_utils.os.makedirs')",
            "    @mock.patch('cinder.image.image_utils.tempfile.mkstemp')",
            "    def test_create_temporary_file_and_dir(self, mock_mkstemp, mock_dirs,",
            "                                           mock_path, mock_conf, mock_close):",
            "        conv_dir = mock.sentinel.image_conversion_dir",
            "        mock_conf.image_conversion_dir = conv_dir",
            "        fd = mock.sentinel.file_descriptor",
            "        path = mock.sentinel.absolute_pathname",
            "        mock_mkstemp.return_value = (fd, path)",
            "",
            "        output = image_utils.create_temporary_file()",
            "",
            "        self.assertEqual(path, output)",
            "        mock_dirs.assert_called_once_with(conv_dir)",
            "        mock_mkstemp.assert_called_once_with(dir=conv_dir)",
            "        mock_close.assert_called_once_with(fd)",
            "",
            "",
            "class TestTemporaryFileContextManager(test.TestCase):",
            "    @mock.patch('cinder.image.image_utils.create_temporary_file',",
            "                return_value=mock.sentinel.temporary_file)",
            "    @mock.patch('cinder.image.image_utils.fileutils.delete_if_exists')",
            "    def test_temporary_file(self, mock_delete, mock_create):",
            "        with image_utils.temporary_file() as tmp_file:",
            "            self.assertEqual(mock.sentinel.temporary_file, tmp_file)",
            "            self.assertFalse(mock_delete.called)",
            "        mock_delete.assert_called_once_with(mock.sentinel.temporary_file)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "41": [
                "TestQemuImgInfo",
                "test_qemu_img_info"
            ],
            "54": [
                "TestQemuImgInfo",
                "test_qemu_img_info_not_root"
            ],
            "69": [
                "TestQemuImgInfo",
                "test_qemu_img_info_on_nt"
            ]
        },
        "addLocation": []
    }
}