{
    "keystone/tests/unit/test_auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from keystone.models import token_model"
            },
            "1": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from keystone.tests import unit"
            },
            "2": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from keystone.tests.unit import default_fixtures"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+from keystone.tests.unit import ksfixtures"
            },
            "4": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " from keystone.tests.unit.ksfixtures import database"
            },
            "5": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " from keystone import token"
            },
            "6": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " from keystone.token import provider"
            },
            "7": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": 672,
                "PatchRowcode": "                               token_id=token_2_id)"
            },
            "8": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 673,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": 674,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 675,
                "PatchRowcode": "+class FernetAuthWithToken(AuthWithToken):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 676,
                "PatchRowcode": "+    def config_overrides(self):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 677,
                "PatchRowcode": "+        super(FernetAuthWithToken, self).config_overrides()"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 678,
                "PatchRowcode": "+        self.config_fixture.config(group='token', provider='fernet')"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 679,
                "PatchRowcode": "+        self.useFixture(ksfixtures.KeyRepository(self.config_fixture))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 680,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 681,
                "PatchRowcode": "+    def test_token_auth_with_binding(self):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 682,
                "PatchRowcode": "+        self.config_fixture.config(group='token', bind=['kerberos'])"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 683,
                "PatchRowcode": "+        body_dict = _build_user_auth()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+        self.assertRaises(exception.NotImplemented,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 685,
                "PatchRowcode": "+                          self.controller.authenticate,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+                          self.context_with_remote_user,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 687,
                "PatchRowcode": "+                          body_dict)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 688,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 689,
                "PatchRowcode": "+    def test_revoke_with_no_audit_info(self):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 690,
                "PatchRowcode": "+        self.skipTest('Fernet with v2.0 and revocation is broken')"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 691,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 692,
                "PatchRowcode": "+    def test_deleting_role_revokes_token(self):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 693,
                "PatchRowcode": "+        self.skipTest('Fernet with v2.0 and revocation is broken')"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 694,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 695,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 674,
                "afterPatchRowNumber": 696,
                "PatchRowcode": " class AuthWithPasswordCredentials(AuthTest):"
            },
            "32": {
                "beforePatchRowNumber": 675,
                "afterPatchRowNumber": 697,
                "PatchRowcode": "     def test_auth_invalid_user(self):"
            },
            "33": {
                "beforePatchRowNumber": 676,
                "afterPatchRowNumber": 698,
                "PatchRowcode": "         \"\"\"Verify exception is raised if invalid user.\"\"\""
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import datetime",
            "import random",
            "import string",
            "import uuid",
            "",
            "import mock",
            "from oslo_config import cfg",
            "import oslo_utils.fixture",
            "from oslo_utils import timeutils",
            "import six",
            "from testtools import matchers",
            "",
            "from keystone import assignment",
            "from keystone import auth",
            "from keystone.common import authorization",
            "from keystone.common import config",
            "from keystone import exception",
            "from keystone.models import token_model",
            "from keystone.tests import unit",
            "from keystone.tests.unit import default_fixtures",
            "from keystone.tests.unit.ksfixtures import database",
            "from keystone import token",
            "from keystone.token import provider",
            "from keystone import trust",
            "",
            "",
            "CONF = cfg.CONF",
            "TIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'",
            "",
            "HOST = ''.join(random.choice(string.ascii_lowercase) for x in range(",
            "    random.randint(5, 15)))",
            "HOST_URL = 'http://%s' % (HOST)",
            "",
            "",
            "def _build_user_auth(token=None, user_id=None, username=None,",
            "                     password=None, tenant_id=None, tenant_name=None,",
            "                     trust_id=None):",
            "    \"\"\"Build auth dictionary.",
            "",
            "    It will create an auth dictionary based on all the arguments",
            "    that it receives.",
            "    \"\"\"",
            "    auth_json = {}",
            "    if token is not None:",
            "        auth_json['token'] = token",
            "    if username or password:",
            "        auth_json['passwordCredentials'] = {}",
            "    if username is not None:",
            "        auth_json['passwordCredentials']['username'] = username",
            "    if user_id is not None:",
            "        auth_json['passwordCredentials']['userId'] = user_id",
            "    if password is not None:",
            "        auth_json['passwordCredentials']['password'] = password",
            "    if tenant_name is not None:",
            "        auth_json['tenantName'] = tenant_name",
            "    if tenant_id is not None:",
            "        auth_json['tenantId'] = tenant_id",
            "    if trust_id is not None:",
            "        auth_json['trust_id'] = trust_id",
            "    return auth_json",
            "",
            "",
            "class AuthTest(unit.TestCase):",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(AuthTest, self).setUp()",
            "        self.time_fixture = self.useFixture(oslo_utils.fixture.TimeFixture())",
            "",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        self.context_with_remote_user = {'environment':",
            "                                         {'REMOTE_USER': 'FOO',",
            "                                          'AUTH_TYPE': 'Negotiate'}}",
            "        self.empty_context = {'environment': {}}",
            "",
            "        self.controller = token.controllers.Auth()",
            "",
            "    def assertEqualTokens(self, a, b, enforce_audit_ids=True):",
            "        \"\"\"Assert that two tokens are equal.",
            "",
            "        Compare two tokens except for their ids. This also truncates",
            "        the time in the comparison.",
            "        \"\"\"",
            "        def normalize(token):",
            "            token['access']['token']['id'] = 'dummy'",
            "            del token['access']['token']['expires']",
            "            del token['access']['token']['issued_at']",
            "            del token['access']['token']['audit_ids']",
            "            return token",
            "",
            "        self.assertCloseEnoughForGovernmentWork(",
            "            timeutils.parse_isotime(a['access']['token']['expires']),",
            "            timeutils.parse_isotime(b['access']['token']['expires']))",
            "        self.assertCloseEnoughForGovernmentWork(",
            "            timeutils.parse_isotime(a['access']['token']['issued_at']),",
            "            timeutils.parse_isotime(b['access']['token']['issued_at']))",
            "        if enforce_audit_ids:",
            "            self.assertIn(a['access']['token']['audit_ids'][0],",
            "                          b['access']['token']['audit_ids'])",
            "            self.assertThat(len(a['access']['token']['audit_ids']),",
            "                            matchers.LessThan(3))",
            "            self.assertThat(len(b['access']['token']['audit_ids']),",
            "                            matchers.LessThan(3))",
            "",
            "        return self.assertDictEqual(normalize(a), normalize(b))",
            "",
            "",
            "class AuthBadRequests(AuthTest):",
            "    def test_no_external_auth(self):",
            "        \"\"\"Verify that _authenticate_external() raises exception if N/A.\"\"\"",
            "        self.assertRaises(",
            "            token.controllers.ExternalAuthNotApplicable,",
            "            self.controller._authenticate_external,",
            "            context={}, auth={})",
            "",
            "    def test_empty_remote_user(self):",
            "        \"\"\"Verify exception is raised when REMOTE_USER is an empty string.\"\"\"",
            "        context = {'environment': {'REMOTE_USER': ''}}",
            "        self.assertRaises(",
            "            token.controllers.ExternalAuthNotApplicable,",
            "            self.controller._authenticate_external,",
            "            context=context, auth={})",
            "",
            "    def test_no_token_in_auth(self):",
            "        \"\"\"Verify that _authenticate_token() raises exception if no token.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller._authenticate_token,",
            "            None, {})",
            "",
            "    def test_no_credentials_in_auth(self):",
            "        \"\"\"Verify that _authenticate_local() raises exception if no creds.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller._authenticate_local,",
            "            None, {})",
            "",
            "    def test_empty_username_and_userid_in_auth(self):",
            "        \"\"\"Verify that empty username and userID raises ValidationError.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller._authenticate_local,",
            "            None, {'passwordCredentials': {'password': 'abc',",
            "                                           'userId': '', 'username': ''}})",
            "",
            "    def test_authenticate_blank_request_body(self):",
            "        \"\"\"Verify sending empty json dict raises the right exception.\"\"\"",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, {})",
            "",
            "    def test_authenticate_blank_auth(self):",
            "        \"\"\"Verify sending blank 'auth' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth()",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_invalid_auth_content(self):",
            "        \"\"\"Verify sending invalid 'auth' raises the right exception.\"\"\"",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, {'auth': 'abcd'})",
            "",
            "    def test_authenticate_user_id_too_large(self):",
            "        \"\"\"Verify sending large 'userId' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(user_id='0' * 65, username='FOO',",
            "                                     password='foo2')",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_username_too_large(self):",
            "        \"\"\"Verify sending large 'username' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(username='0' * 65, password='foo2')",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_tenant_id_too_large(self):",
            "        \"\"\"Verify sending large 'tenantId' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(username='FOO', password='foo2',",
            "                                     tenant_id='0' * 65)",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_tenant_name_too_large(self):",
            "        \"\"\"Verify sending large 'tenantName' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(username='FOO', password='foo2',",
            "                                     tenant_name='0' * 65)",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_token_too_large(self):",
            "        \"\"\"Verify sending large 'token' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(token={'id': '0' * 8193})",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_password_too_large(self):",
            "        \"\"\"Verify sending large 'password' raises the right exception.\"\"\"",
            "        length = CONF.identity.max_password_length + 1",
            "        body_dict = _build_user_auth(username='FOO', password='0' * length)",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_fails_if_project_unsafe(self):",
            "        \"\"\"Verify authenticate to a project with unsafe name fails.\"\"\"",
            "        # Start with url name restrictions off, so we can create the unsafe",
            "        # named project",
            "        self.config_fixture.config(group='resource',",
            "                                   project_name_url_safe='off')",
            "        unsafe_name = 'i am not / safe'",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id, name=unsafe_name)",
            "        self.resource_api.create_project(project['id'], project)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], project['id'], self.role_member['id'])",
            "        no_context = {}",
            "",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_name=project['name'])",
            "",
            "        # Since name url restriction is off, we should be able to authenticate",
            "        self.controller.authenticate(no_context, body_dict)",
            "",
            "        # Set the name url restriction to strict and we should fail to",
            "        # authenticate",
            "        self.config_fixture.config(group='resource',",
            "                                   project_name_url_safe='strict')",
            "        self.assertRaises(exception.Unauthorized,",
            "                          self.controller.authenticate,",
            "                          no_context, body_dict)",
            "",
            "",
            "class AuthWithToken(AuthTest):",
            "    def test_unscoped_token(self):",
            "        \"\"\"Verify getting an unscoped token with password creds.\"\"\"",
            "        body_dict = _build_user_auth(username='FOO',",
            "                                     password='foo2')",
            "        unscoped_token = self.controller.authenticate({}, body_dict)",
            "        self.assertNotIn('tenant', unscoped_token['access']['token'])",
            "",
            "    def test_auth_invalid_token(self):",
            "        \"\"\"Verify exception is raised if invalid token.\"\"\"",
            "        body_dict = _build_user_auth(token={\"id\": uuid.uuid4().hex})",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_bad_formatted_token(self):",
            "        \"\"\"Verify exception is raised if invalid token.\"\"\"",
            "        body_dict = _build_user_auth(token={})",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_unscoped_token_no_project(self):",
            "        \"\"\"Verify getting an unscoped token with an unscoped token.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2')",
            "        unscoped_token = self.controller.authenticate({}, body_dict)",
            "",
            "        body_dict = _build_user_auth(",
            "            token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate({}, body_dict)",
            "",
            "        self.assertEqualTokens(unscoped_token, unscoped_token_2)",
            "",
            "    def test_auth_unscoped_token_project(self):",
            "        \"\"\"Verify getting a token in a tenant with an unscoped token.\"\"\"",
            "        # Add a role in so we can check we get this back",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_member['id'])",
            "        # Get an unscoped token",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2')",
            "        unscoped_token = self.controller.authenticate({}, body_dict)",
            "        # Get a token on BAR tenant using the unscoped token",
            "        body_dict = _build_user_auth(",
            "            token=unscoped_token[\"access\"][\"token\"],",
            "            tenant_name=\"BAR\")",
            "        scoped_token = self.controller.authenticate({}, body_dict)",
            "",
            "        tenant = scoped_token[\"access\"][\"token\"][\"tenant\"]",
            "        roles = scoped_token[\"access\"][\"metadata\"][\"roles\"]",
            "        self.assertEqual(self.tenant_bar['id'], tenant[\"id\"])",
            "        self.assertThat(roles, matchers.Contains(self.role_member['id']))",
            "",
            "    def test_auth_scoped_token_bad_project_with_debug(self):",
            "        \"\"\"Authenticating with an invalid project fails.\"\"\"",
            "        # Bug 1379952 reports poor user feedback, even in insecure_debug mode,",
            "        # when the user accidentally passes a project name as an ID.",
            "        # This test intentionally does exactly that.",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_id=self.tenant_bar['name'])",
            "",
            "        # with insecure_debug enabled, this produces a friendly exception.",
            "        self.config_fixture.config(debug=True, insecure_debug=True)",
            "        e = self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "        # explicitly verify that the error message shows that a *name* is",
            "        # found where an *ID* is expected",
            "        self.assertIn(",
            "            'Project ID not found: %s' % self.tenant_bar['name'],",
            "            six.text_type(e))",
            "",
            "    def test_auth_scoped_token_bad_project_without_debug(self):",
            "        \"\"\"Authenticating with an invalid project fails.\"\"\"",
            "        # Bug 1379952 reports poor user feedback, even in insecure_debug mode,",
            "        # when the user accidentally passes a project name as an ID.",
            "        # This test intentionally does exactly that.",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_id=self.tenant_bar['name'])",
            "",
            "        # with insecure_debug disabled (the default), authentication failure",
            "        # details are suppressed.",
            "        e = self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "        # explicitly verify that the error message details above have been",
            "        # suppressed.",
            "        self.assertNotIn(",
            "            'Project ID not found: %s' % self.tenant_bar['name'],",
            "            six.text_type(e))",
            "",
            "    def test_auth_token_project_group_role(self):",
            "        \"\"\"Verify getting a token in a tenant with group roles.\"\"\"",
            "        # Add a v2 style role in so we can check we get this back",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_member['id'])",
            "        # Now create a group role for this user as well",
            "        domain1 = unit.new_domain_ref()",
            "        self.resource_api.create_domain(domain1['id'], domain1)",
            "        new_group = unit.new_group_ref(domain_id=domain1['id'])",
            "        new_group = self.identity_api.create_group(new_group)",
            "        self.identity_api.add_user_to_group(self.user_foo['id'],",
            "                                            new_group['id'])",
            "        self.assignment_api.create_grant(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'],",
            "            role_id=self.role_admin['id'])",
            "",
            "        # Get a scoped token for the tenant",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        scoped_token = self.controller.authenticate({}, body_dict)",
            "",
            "        tenant = scoped_token[\"access\"][\"token\"][\"tenant\"]",
            "        roles = scoped_token[\"access\"][\"metadata\"][\"roles\"]",
            "        self.assertEqual(self.tenant_bar['id'], tenant[\"id\"])",
            "        self.assertIn(self.role_member['id'], roles)",
            "        self.assertIn(self.role_admin['id'], roles)",
            "",
            "    def test_belongs_to_no_tenant(self):",
            "        r = self.controller.authenticate(",
            "            {},",
            "            auth={",
            "                'passwordCredentials': {",
            "                    'username': self.user_foo['name'],",
            "                    'password': self.user_foo['password']",
            "                }",
            "            })",
            "        unscoped_token_id = r['access']['token']['id']",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={'belongsTo': 'BAR'}),",
            "            token_id=unscoped_token_id)",
            "",
            "    def test_belongs_to(self):",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        scoped_token = self.controller.authenticate({}, body_dict)",
            "        scoped_token_id = scoped_token['access']['token']['id']",
            "",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={'belongsTo': 'me'}),",
            "            token_id=scoped_token_id)",
            "",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={'belongsTo': 'BAR'}),",
            "            token_id=scoped_token_id)",
            "",
            "    def test_token_auth_with_binding(self):",
            "        self.config_fixture.config(group='token', bind=['kerberos'])",
            "        body_dict = _build_user_auth()",
            "        unscoped_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        # the token should have bind information in it",
            "        bind = unscoped_token['access']['token']['bind']",
            "        self.assertEqual('FOO', bind['kerberos'])",
            "",
            "        body_dict = _build_user_auth(",
            "            token=unscoped_token['access']['token'],",
            "            tenant_name='BAR')",
            "",
            "        # using unscoped token without remote user context fails",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            self.empty_context, body_dict)",
            "",
            "        # using token with remote user context succeeds",
            "        scoped_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        # the bind information should be carried over from the original token",
            "        bind = scoped_token['access']['token']['bind']",
            "        self.assertEqual('FOO', bind['kerberos'])",
            "",
            "    def test_deleting_role_revokes_token(self):",
            "        role_controller = assignment.controllers.Role()",
            "        project1 = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id)",
            "        self.resource_api.create_project(project1['id'], project1)",
            "        role_one = unit.new_role_ref(id='role_one')",
            "        self.role_api.create_role(role_one['id'], role_one)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], project1['id'], role_one['id'])",
            "        no_context = {}",
            "",
            "        # Get a scoped token for the tenant",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_name=project1['name'])",
            "        token = self.controller.authenticate(no_context, body_dict)",
            "        # Ensure it is valid",
            "        token_id = token['access']['token']['id']",
            "        self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=token_id)",
            "",
            "        # Delete the role, which should invalidate the token",
            "        role_controller.delete_role(",
            "            dict(is_admin=True, query_string={}), role_one['id'])",
            "",
            "        # Check the token is now invalid",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=token_id)",
            "",
            "    def test_deleting_role_assignment_does_not_revoke_unscoped_token(self):",
            "        no_context = {}",
            "        admin_context = dict(is_admin=True, query_string={})",
            "",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id)",
            "        self.resource_api.create_project(project['id'], project)",
            "        role = unit.new_role_ref()",
            "        self.role_api.create_role(role['id'], role)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], project['id'], role['id'])",
            "",
            "        # Get an unscoped token.",
            "        token = self.controller.authenticate(no_context, _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password']))",
            "        token_id = token['access']['token']['id']",
            "",
            "        # Ensure it is valid",
            "        self.controller.validate_token(admin_context, token_id=token_id)",
            "",
            "        # Delete the role assignment, which should not invalidate the token,",
            "        # because we're not consuming it with just an unscoped token.",
            "        self.assignment_api.remove_role_from_user_and_project(",
            "            self.user_foo['id'], project['id'], role['id'])",
            "",
            "        # Ensure it is still valid",
            "        self.controller.validate_token(admin_context, token_id=token_id)",
            "",
            "    def test_only_original_audit_id_is_kept(self):",
            "        context = {}",
            "",
            "        def get_audit_ids(token):",
            "            return token['access']['token']['audit_ids']",
            "",
            "        # get a token",
            "        body_dict = _build_user_auth(username='FOO', password='foo2')",
            "        unscoped_token = self.controller.authenticate(context, body_dict)",
            "        starting_audit_id = get_audit_ids(unscoped_token)[0]",
            "        self.assertIsNotNone(starting_audit_id)",
            "",
            "        # get another token to ensure the correct parent audit_id is set",
            "        body_dict = _build_user_auth(token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "        audit_ids = get_audit_ids(unscoped_token_2)",
            "        self.assertThat(audit_ids, matchers.HasLength(2))",
            "        self.assertThat(audit_ids[-1], matchers.Equals(starting_audit_id))",
            "",
            "        # get another token from token 2 and ensure the correct parent",
            "        # audit_id is set",
            "        body_dict = _build_user_auth(token=unscoped_token_2[\"access\"][\"token\"])",
            "        unscoped_token_3 = self.controller.authenticate(context, body_dict)",
            "        audit_ids = get_audit_ids(unscoped_token_3)",
            "        self.assertThat(audit_ids, matchers.HasLength(2))",
            "        self.assertThat(audit_ids[-1], matchers.Equals(starting_audit_id))",
            "",
            "    def test_revoke_by_audit_chain_id_original_token(self):",
            "        self.config_fixture.config(group='token', revoke_by_id=False)",
            "        context = {}",
            "",
            "        # get a token",
            "        body_dict = _build_user_auth(username='FOO', password='foo2')",
            "        unscoped_token = self.controller.authenticate(context, body_dict)",
            "        token_id = unscoped_token['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        # get a second token",
            "        body_dict = _build_user_auth(token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "        token_2_id = unscoped_token_2['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        self.token_provider_api.revoke_token(token_id, revoke_chain=True)",
            "",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_2_id)",
            "",
            "    def test_revoke_by_audit_chain_id_chained_token(self):",
            "        self.config_fixture.config(group='token', revoke_by_id=False)",
            "        context = {}",
            "",
            "        # get a token",
            "        body_dict = _build_user_auth(username='FOO', password='foo2')",
            "        unscoped_token = self.controller.authenticate(context, body_dict)",
            "        token_id = unscoped_token['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        # get a second token",
            "        body_dict = _build_user_auth(token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "        token_2_id = unscoped_token_2['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        self.token_provider_api.revoke_token(token_2_id, revoke_chain=True)",
            "",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_2_id)",
            "",
            "    def _mock_audit_info(self, parent_audit_id):",
            "        # NOTE(morgainfainberg): The token model and other cases that are",
            "        # extracting the audit id expect 'None' if the audit id doesn't",
            "        # exist. This ensures that the audit_id is None and the",
            "        # audit_chain_id will also return None.",
            "        return [None, None]",
            "",
            "    def test_revoke_with_no_audit_info(self):",
            "        self.config_fixture.config(group='token', revoke_by_id=False)",
            "        context = {}",
            "",
            "        with mock.patch.object(provider, 'audit_info', self._mock_audit_info):",
            "            # get a token",
            "            body_dict = _build_user_auth(username='FOO', password='foo2')",
            "            unscoped_token = self.controller.authenticate(context, body_dict)",
            "            token_id = unscoped_token['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            # get a second token",
            "            body_dict = _build_user_auth(",
            "                token=unscoped_token['access']['token'])",
            "            unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "            token_2_id = unscoped_token_2['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            self.token_provider_api.revoke_token(token_id, revoke_chain=True)",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            revoke_events = self.revoke_api.list_events()",
            "            self.assertThat(revoke_events, matchers.HasLength(1))",
            "            revoke_event = revoke_events[0].to_dict()",
            "            self.assertIn('expires_at', revoke_event)",
            "            self.assertEqual(unscoped_token_2['access']['token']['expires'],",
            "                             revoke_event['expires_at'])",
            "",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_id)",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_2_id)",
            "",
            "            # get a new token, with no audit info",
            "            body_dict = _build_user_auth(username='FOO', password='foo2')",
            "            unscoped_token = self.controller.authenticate(context, body_dict)",
            "            token_id = unscoped_token['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "            # get a second token",
            "            body_dict = _build_user_auth(",
            "                token=unscoped_token['access']['token'])",
            "            unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "            token_2_id = unscoped_token_2['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            # Revoke by audit_id, no audit_info means both parent and child",
            "            # token are revoked.",
            "            self.token_provider_api.revoke_token(token_id)",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            revoke_events = self.revoke_api.list_events()",
            "            self.assertThat(revoke_events, matchers.HasLength(2))",
            "            revoke_event = revoke_events[1].to_dict()",
            "            self.assertIn('expires_at', revoke_event)",
            "            self.assertEqual(unscoped_token_2['access']['token']['expires'],",
            "                             revoke_event['expires_at'])",
            "",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_id)",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_2_id)",
            "",
            "",
            "class AuthWithPasswordCredentials(AuthTest):",
            "    def test_auth_invalid_user(self):",
            "        \"\"\"Verify exception is raised if invalid user.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username=uuid.uuid4().hex,",
            "            password=uuid.uuid4().hex)",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_valid_user_invalid_password(self):",
            "        \"\"\"Verify exception is raised if invalid password.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username=\"FOO\",",
            "            password=uuid.uuid4().hex)",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_empty_password(self):",
            "        \"\"\"Verify exception is raised if empty password.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username=\"FOO\",",
            "            password=\"\")",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_no_password(self):",
            "        \"\"\"Verify exception is raised if empty password.\"\"\"",
            "        body_dict = _build_user_auth(username=\"FOO\")",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_authenticate_blank_password_credentials(self):",
            "        \"\"\"Sending empty dict as passwordCredentials raises 400 Bad Requset.\"\"\"",
            "        body_dict = {'passwordCredentials': {}, 'tenantName': 'demo'}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_no_username(self):",
            "        \"\"\"Verify skipping username raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(password=\"pass\",",
            "                                     tenant_name=\"demo\")",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_bind_without_remote_user(self):",
            "        self.config_fixture.config(group='token', bind=['kerberos'])",
            "        body_dict = _build_user_auth(username='FOO', password='foo2',",
            "                                     tenant_name='BAR')",
            "        token = self.controller.authenticate({}, body_dict)",
            "        self.assertNotIn('bind', token['access']['token'])",
            "",
            "    def test_change_default_domain_id(self):",
            "        # If the default_domain_id config option is not the default then the",
            "        # user in auth data is from the new default domain.",
            "",
            "        # 1) Create a new domain.",
            "        new_domain = unit.new_domain_ref()",
            "        new_domain_id = new_domain['id']",
            "",
            "        self.resource_api.create_domain(new_domain_id, new_domain)",
            "",
            "        # 2) Create user \"foo\" in new domain with different password than",
            "        #    default-domain foo.",
            "        new_user = unit.create_user(self.identity_api,",
            "                                    name=self.user_foo['name'],",
            "                                    domain_id=new_domain_id)",
            "",
            "        # 3) Update the default_domain_id config option to the new domain",
            "",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        # 4) Authenticate as \"foo\" using the password in the new domain.",
            "",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=new_user['password'])",
            "",
            "        # The test is successful if this doesn't raise, so no need to assert.",
            "        self.controller.authenticate({}, body_dict)",
            "",
            "",
            "class AuthWithRemoteUser(AuthTest):",
            "    def test_unscoped_remote_authn(self):",
            "        \"\"\"Verify getting an unscoped token with external authn.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2')",
            "        local_token = self.controller.authenticate(",
            "            {}, body_dict)",
            "",
            "        body_dict = _build_user_auth()",
            "        remote_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        self.assertEqualTokens(local_token, remote_token,",
            "                               enforce_audit_ids=False)",
            "",
            "    def test_unscoped_remote_authn_jsonless(self):",
            "        \"\"\"Verify that external auth with invalid request fails.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller.authenticate,",
            "            {'REMOTE_USER': 'FOO'},",
            "            None)",
            "",
            "    def test_scoped_remote_authn(self):",
            "        \"\"\"Verify getting a token with external authn.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name='BAR')",
            "        local_token = self.controller.authenticate(",
            "            {}, body_dict)",
            "",
            "        body_dict = _build_user_auth(",
            "            tenant_name='BAR')",
            "        remote_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        self.assertEqualTokens(local_token, remote_token,",
            "                               enforce_audit_ids=False)",
            "",
            "    def test_scoped_nometa_remote_authn(self):",
            "        \"\"\"Verify getting a token with external authn and no metadata.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='TWO',",
            "            password='two2',",
            "            tenant_name='BAZ')",
            "        local_token = self.controller.authenticate(",
            "            {}, body_dict)",
            "",
            "        body_dict = _build_user_auth(tenant_name='BAZ')",
            "        remote_token = self.controller.authenticate(",
            "            {'environment': {'REMOTE_USER': 'TWO'}}, body_dict)",
            "",
            "        self.assertEqualTokens(local_token, remote_token,",
            "                               enforce_audit_ids=False)",
            "",
            "    def test_scoped_remote_authn_invalid_user(self):",
            "        \"\"\"Verify that external auth with invalid user fails.\"\"\"",
            "        body_dict = _build_user_auth(tenant_name=\"BAR\")",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {'environment': {'REMOTE_USER': uuid.uuid4().hex}},",
            "            body_dict)",
            "",
            "    def test_bind_with_kerberos(self):",
            "        self.config_fixture.config(group='token', bind=['kerberos'])",
            "        body_dict = _build_user_auth(tenant_name=\"BAR\")",
            "        token = self.controller.authenticate(self.context_with_remote_user,",
            "                                             body_dict)",
            "        self.assertEqual('FOO', token['access']['token']['bind']['kerberos'])",
            "",
            "    def test_bind_without_config_opt(self):",
            "        self.config_fixture.config(group='token', bind=['x509'])",
            "        body_dict = _build_user_auth(tenant_name='BAR')",
            "        token = self.controller.authenticate(self.context_with_remote_user,",
            "                                             body_dict)",
            "        self.assertNotIn('bind', token['access']['token'])",
            "",
            "",
            "class AuthWithTrust(AuthTest):",
            "    def setUp(self):",
            "        super(AuthWithTrust, self).setUp()",
            "",
            "        self.trust_controller = trust.controllers.TrustV3()",
            "        self.auth_v3_controller = auth.controllers.Auth()",
            "        self.trustor = self.user_foo",
            "        self.trustee = self.user_two",
            "        self.assigned_roles = [self.role_member['id'],",
            "                               self.role_browser['id']]",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "",
            "        self.sample_data = {'trustor_user_id': self.trustor['id'],",
            "                            'trustee_user_id': self.trustee['id'],",
            "                            'project_id': self.tenant_bar['id'],",
            "                            'impersonation': True,",
            "                            'roles': [{'id': self.role_browser['id']},",
            "                                      {'name': self.role_member['name']}]}",
            "",
            "    def config_overrides(self):",
            "        super(AuthWithTrust, self).config_overrides()",
            "        self.config_fixture.config(group='trust', enabled=True)",
            "",
            "    def _create_auth_context(self, token_id):",
            "        token_ref = token_model.KeystoneToken(",
            "            token_id=token_id,",
            "            token_data=self.token_provider_api.validate_token(token_id))",
            "        auth_context = authorization.token_to_auth_context(token_ref)",
            "        # NOTE(gyee): if public_endpoint and admin_endpoint are not set, which",
            "        # is the default, the base url will be constructed from the environment",
            "        # variables wsgi.url_scheme, SERVER_NAME, SERVER_PORT, and SCRIPT_NAME.",
            "        # We have to set them in the context so the base url can be constructed",
            "        # accordingly.",
            "        return {'environment': {authorization.AUTH_CONTEXT_ENV: auth_context,",
            "                                'wsgi.url_scheme': 'http',",
            "                                'SCRIPT_NAME': '/v3',",
            "                                'SERVER_PORT': '80',",
            "                                'SERVER_NAME': HOST},",
            "                'token_id': token_id,",
            "                'host_url': HOST_URL}",
            "",
            "    def create_trust(self, trust_data, trustor_name, expires_at=None,",
            "                     impersonation=True):",
            "        username = trustor_name",
            "        password = 'foo2'",
            "        unscoped_token = self.get_unscoped_token(username, password)",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        trust_data_copy = copy.deepcopy(trust_data)",
            "        trust_data_copy['expires_at'] = expires_at",
            "        trust_data_copy['impersonation'] = impersonation",
            "",
            "        return self.trust_controller.create_trust(",
            "            context, trust=trust_data_copy)['trust']",
            "",
            "    def get_unscoped_token(self, username, password='foo2'):",
            "        body_dict = _build_user_auth(username=username, password=password)",
            "        return self.controller.authenticate({}, body_dict)",
            "",
            "    def build_v2_token_request(self, username, password, trust,",
            "                               tenant_id=None):",
            "        if not tenant_id:",
            "            tenant_id = self.tenant_bar['id']",
            "        unscoped_token = self.get_unscoped_token(username, password)",
            "        unscoped_token_id = unscoped_token['access']['token']['id']",
            "        request_body = _build_user_auth(token={'id': unscoped_token_id},",
            "                                        trust_id=trust['id'],",
            "                                        tenant_id=tenant_id)",
            "        return request_body",
            "",
            "    def test_create_trust_bad_data_fails(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        bad_sample_data = {'trustor_user_id': self.trustor['id'],",
            "                           'project_id': self.tenant_bar['id'],",
            "                           'roles': [{'id': self.role_browser['id']}]}",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.trust_controller.create_trust,",
            "                          context, trust=bad_sample_data)",
            "",
            "    def test_create_trust_no_roles(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = {'token_id': unscoped_token['access']['token']['id']}",
            "        self.sample_data['roles'] = []",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.trust_controller.create_trust,",
            "                          context, trust=self.sample_data)",
            "",
            "    def test_create_trust(self):",
            "        expires_at = (timeutils.utcnow() +",
            "                      datetime.timedelta(minutes=10)).strftime(TIME_FORMAT)",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'],",
            "                                      expires_at=expires_at)",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        role_ids = [self.role_browser['id'], self.role_member['id']]",
            "        self.assertTrue(timeutils.parse_strtime(new_trust['expires_at'],",
            "                                                fmt=TIME_FORMAT))",
            "        self.assertIn('%s/v3/OS-TRUST/' % HOST_URL,",
            "                      new_trust['links']['self'])",
            "        self.assertIn('%s/v3/OS-TRUST/' % HOST_URL,",
            "                      new_trust['roles_links']['self'])",
            "",
            "        for role in new_trust['roles']:",
            "            self.assertIn(role['id'], role_ids)",
            "",
            "    def test_create_trust_expires_bad(self):",
            "        self.assertRaises(exception.ValidationTimeStampError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'], expires_at=\"bad\")",
            "        self.assertRaises(exception.ValidationTimeStampError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'], expires_at=\"\")",
            "        self.assertRaises(exception.ValidationTimeStampError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'], expires_at=\"Z\")",
            "",
            "    def test_create_trust_expires_older_than_now(self):",
            "        self.assertRaises(exception.ValidationExpirationError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'],",
            "                          expires_at=\"2010-06-04T08:44:31.999999Z\")",
            "",
            "    def test_create_trust_without_project_id(self):",
            "        \"\"\"Verify that trust can be created without project id.",
            "",
            "        Also, token can be generated with that trust.",
            "        \"\"\"",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        self.sample_data['project_id'] = None",
            "        self.sample_data['roles'] = []",
            "        new_trust = self.trust_controller.create_trust(",
            "            context, trust=self.sample_data)['trust']",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        self.assertIs(new_trust['impersonation'], True)",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        token_user = auth_response['access']['user']",
            "        self.assertEqual(token_user['id'], new_trust['trustor_user_id'])",
            "",
            "    def test_get_trust(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        new_trust = self.trust_controller.create_trust(",
            "            context, trust=self.sample_data)['trust']",
            "        trust = self.trust_controller.get_trust(context,",
            "                                                new_trust['id'])['trust']",
            "        self.assertEqual(self.trustor['id'], trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], trust['trustee_user_id'])",
            "        role_ids = [self.role_browser['id'], self.role_member['id']]",
            "        for role in new_trust['roles']:",
            "            self.assertIn(role['id'], role_ids)",
            "",
            "    def test_get_trust_without_auth_context(self):",
            "        \"\"\"Verify a trust cannot be retrieved if auth context is missing.\"\"\"",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        new_trust = self.trust_controller.create_trust(",
            "            context, trust=self.sample_data)['trust']",
            "        # Delete the auth context before calling get_trust().",
            "        del context['environment'][authorization.AUTH_CONTEXT_ENV]",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.trust_controller.get_trust, context,",
            "                          new_trust['id'])",
            "",
            "    def test_create_trust_no_impersonation(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'],",
            "                                      expires_at=None, impersonation=False)",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        self.assertIs(new_trust['impersonation'], False)",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        token_user = auth_response['access']['user']",
            "        self.assertEqual(token_user['id'], new_trust['trustee_user_id'])",
            "",
            "    def test_create_trust_impersonation(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        self.assertIs(new_trust['impersonation'], True)",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        token_user = auth_response['access']['user']",
            "        self.assertEqual(token_user['id'], new_trust['trustor_user_id'])",
            "",
            "    def test_token_from_trust_wrong_user_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request('FOO', 'foo2', new_trust)",
            "        self.assertRaises(exception.Forbidden, self.controller.authenticate,",
            "                          {}, request_body)",
            "",
            "    def test_token_from_trust_wrong_project_fails(self):",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                self.trustor['id'], self.tenant_baz['id'], assigned_role)",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust,",
            "                                                   self.tenant_baz['id'])",
            "        self.assertRaises(exception.Forbidden, self.controller.authenticate,",
            "                          {}, request_body)",
            "",
            "    def fetch_v2_token_from_trust(self, trust):",
            "        request_body = self.build_v2_token_request('TWO', 'two2', trust)",
            "        auth_response = self.controller.authenticate({}, request_body)",
            "        return auth_response",
            "",
            "    def fetch_v3_token_from_trust(self, trust, trustee):",
            "        v3_password_data = {",
            "            'identity': {",
            "                \"methods\": [\"password\"],",
            "                \"password\": {",
            "                    \"user\": {",
            "                        \"id\": trustee[\"id\"],",
            "                        \"password\": trustee[\"password\"]",
            "                    }",
            "                }",
            "            },",
            "            'scope': {",
            "                'project': {",
            "                    'id': self.tenant_baz['id']",
            "                }",
            "            }",
            "        }",
            "        auth_response = (self.auth_v3_controller.authenticate_for_token",
            "                         ({'environment': {},",
            "                           'query_string': {}},",
            "                          v3_password_data))",
            "        token = auth_response.headers['X-Subject-Token']",
            "",
            "        v3_req_with_trust = {",
            "            \"identity\": {",
            "                \"methods\": [\"token\"],",
            "                \"token\": {\"id\": token}},",
            "            \"scope\": {",
            "                \"OS-TRUST:trust\": {\"id\": trust['id']}}}",
            "        token_auth_response = (self.auth_v3_controller.authenticate_for_token",
            "                               ({'environment': {},",
            "                                 'query_string': {}},",
            "                                v3_req_with_trust))",
            "        return token_auth_response",
            "",
            "    def test_create_v3_token_from_trust(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v3_token_from_trust(new_trust, self.trustee)",
            "",
            "        trust_token_user = auth_response.json['token']['user']",
            "        self.assertEqual(self.trustor['id'], trust_token_user['id'])",
            "",
            "        trust_token_trust = auth_response.json['token']['OS-TRUST:trust']",
            "        self.assertEqual(trust_token_trust['id'], new_trust['id'])",
            "        self.assertEqual(self.trustor['id'],",
            "                         trust_token_trust['trustor_user']['id'])",
            "        self.assertEqual(self.trustee['id'],",
            "                         trust_token_trust['trustee_user']['id'])",
            "",
            "        trust_token_roles = auth_response.json['token']['roles']",
            "        self.assertEqual(2, len(trust_token_roles))",
            "",
            "    def test_v3_trust_token_get_token_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v3_token_from_trust(new_trust, self.trustee)",
            "        trust_token = auth_response.headers['X-Subject-Token']",
            "        v3_token_data = {'identity': {",
            "            'methods': ['token'],",
            "            'token': {'id': trust_token}",
            "        }}",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.auth_v3_controller.authenticate_for_token,",
            "            {'environment': {},",
            "             'query_string': {}}, v3_token_data)",
            "",
            "    def test_token_from_trust(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "",
            "        self.assertIsNotNone(auth_response)",
            "        self.assertEqual(2,",
            "                         len(auth_response['access']['metadata']['roles']),",
            "                         \"user_foo has three roles, but the token should\"",
            "                         \" only get the two roles specified in the trust.\")",
            "",
            "    def assert_token_count_for_trust(self, trust, expected_value):",
            "        tokens = self.token_provider_api._persistence._list_tokens(",
            "            self.trustee['id'], trust_id=trust['id'])",
            "        token_count = len(tokens)",
            "        self.assertEqual(expected_value, token_count)",
            "",
            "    def test_delete_tokens_for_user_invalidates_tokens_from_trust(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        self.assert_token_count_for_trust(new_trust, 0)",
            "        self.fetch_v2_token_from_trust(new_trust)",
            "        self.assert_token_count_for_trust(new_trust, 1)",
            "        self.token_provider_api._persistence.delete_tokens_for_user(",
            "            self.trustee['id'])",
            "        self.assert_token_count_for_trust(new_trust, 0)",
            "",
            "    def test_token_from_trust_cant_get_another_token(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        trust_token_id = auth_response['access']['token']['id']",
            "        request_body = _build_user_auth(token={'id': trust_token_id},",
            "                                        tenant_id=self.tenant_bar['id'])",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_delete_trust_revokes_token(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        self.fetch_v2_token_from_trust(new_trust)",
            "        trust_id = new_trust['id']",
            "        tokens = self.token_provider_api._persistence._list_tokens(",
            "            self.trustor['id'],",
            "            trust_id=trust_id)",
            "        self.assertEqual(1, len(tokens))",
            "        self.trust_controller.delete_trust(context, trust_id=trust_id)",
            "        tokens = self.token_provider_api._persistence._list_tokens(",
            "            self.trustor['id'],",
            "            trust_id=trust_id)",
            "        self.assertEqual(0, len(tokens))",
            "",
            "    def test_token_from_trust_with_no_role_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.remove_role_from_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust)",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_expired_trust_get_token_fails(self):",
            "        expires_at = (timeutils.utcnow() +",
            "                      datetime.timedelta(minutes=5)).strftime(TIME_FORMAT)",
            "        time_expired = timeutils.utcnow() + datetime.timedelta(minutes=10)",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'],",
            "                                      expires_at)",
            "        with mock.patch.object(timeutils, 'utcnow') as mock_now:",
            "            mock_now.return_value = time_expired",
            "            request_body = self.build_v2_token_request('TWO', 'two2',",
            "                                                       new_trust)",
            "            self.assertRaises(",
            "                exception.Forbidden,",
            "                self.controller.authenticate, {}, request_body)",
            "",
            "    def test_token_from_trust_with_wrong_role_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.trustor['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_other['id'])",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.remove_role_from_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust)",
            "",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_do_not_consume_remaining_uses_when_get_token_fails(self):",
            "        trust_data = copy.deepcopy(self.sample_data)",
            "        trust_data['remaining_uses'] = 3",
            "        new_trust = self.create_trust(trust_data, self.trustor['name'])",
            "",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.remove_role_from_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust)",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.controller.authenticate, {}, request_body)",
            "",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        trust = self.trust_controller.get_trust(context,",
            "                                                new_trust['id'])['trust']",
            "        self.assertEqual(3, trust['remaining_uses'])",
            "",
            "    def disable_user(self, user):",
            "        user['enabled'] = False",
            "        self.identity_api.update_user(user['id'], user)",
            "",
            "    def test_trust_get_token_fails_if_trustor_disabled(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request(self.trustee['name'],",
            "                                                   self.trustee['password'],",
            "                                                   new_trust)",
            "        self.disable_user(self.trustor)",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_trust_get_token_fails_if_trustee_disabled(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request(self.trustee['name'],",
            "                                                   self.trustee['password'],",
            "                                                   new_trust)",
            "        self.disable_user(self.trustee)",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "",
            "class TokenExpirationTest(AuthTest):",
            "",
            "    @mock.patch.object(timeutils, 'utcnow')",
            "    def _maintain_token_expiration(self, mock_utcnow):",
            "        \"\"\"Token expiration should be maintained after re-auth & validation.\"\"\"",
            "        now = datetime.datetime.utcnow()",
            "        mock_utcnow.return_value = now",
            "",
            "        r = self.controller.authenticate(",
            "            {},",
            "            auth={",
            "                'passwordCredentials': {",
            "                    'username': self.user_foo['name'],",
            "                    'password': self.user_foo['password']",
            "                }",
            "            })",
            "        unscoped_token_id = r['access']['token']['id']",
            "        original_expiration = r['access']['token']['expires']",
            "",
            "        mock_utcnow.return_value = now + datetime.timedelta(seconds=1)",
            "",
            "        r = self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=unscoped_token_id)",
            "        self.assertEqual(original_expiration, r['access']['token']['expires'])",
            "",
            "        mock_utcnow.return_value = now + datetime.timedelta(seconds=2)",
            "",
            "        r = self.controller.authenticate(",
            "            {},",
            "            auth={",
            "                'token': {",
            "                    'id': unscoped_token_id,",
            "                },",
            "                'tenantId': self.tenant_bar['id'],",
            "            })",
            "        scoped_token_id = r['access']['token']['id']",
            "        self.assertEqual(original_expiration, r['access']['token']['expires'])",
            "",
            "        mock_utcnow.return_value = now + datetime.timedelta(seconds=3)",
            "",
            "        r = self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=scoped_token_id)",
            "        self.assertEqual(original_expiration, r['access']['token']['expires'])",
            "",
            "    def test_maintain_uuid_token_expiration(self):",
            "        self.config_fixture.config(group='token', provider='uuid')",
            "        self._maintain_token_expiration()",
            "",
            "",
            "class AuthCatalog(unit.SQLDriverOverrides, AuthTest):",
            "    \"\"\"Test for the catalog provided in the auth response.\"\"\"",
            "",
            "    def config_files(self):",
            "        config_files = super(AuthCatalog, self).config_files()",
            "        # We need to use a backend that supports disabled endpoints, like the",
            "        # SQL backend.",
            "        config_files.append(unit.dirs.tests_conf('backend_sql.conf'))",
            "        return config_files",
            "",
            "    def _create_endpoints(self):",
            "        def create_region(**kwargs):",
            "            ref = unit.new_region_ref(**kwargs)",
            "            self.catalog_api.create_region(ref)",
            "            return ref",
            "",
            "        def create_endpoint(service_id, region, **kwargs):",
            "            endpoint = unit.new_endpoint_ref(region_id=region,",
            "                                             service_id=service_id, **kwargs)",
            "",
            "            self.catalog_api.create_endpoint(endpoint['id'], endpoint)",
            "            return endpoint",
            "",
            "        # Create a service for use with the endpoints.",
            "        def create_service(**kwargs):",
            "            ref = unit.new_service_ref(**kwargs)",
            "            self.catalog_api.create_service(ref['id'], ref)",
            "            return ref",
            "",
            "        enabled_service_ref = create_service(enabled=True)",
            "        disabled_service_ref = create_service(enabled=False)",
            "",
            "        region = create_region()",
            "",
            "        # Create endpoints",
            "        enabled_endpoint_ref = create_endpoint(",
            "            enabled_service_ref['id'], region['id'])",
            "        create_endpoint(",
            "            enabled_service_ref['id'], region['id'], enabled=False,",
            "            interface='internal')",
            "        create_endpoint(",
            "            disabled_service_ref['id'], region['id'])",
            "",
            "        return enabled_endpoint_ref",
            "",
            "    def test_auth_catalog_disabled_endpoint(self):",
            "        \"\"\"On authenticate, get a catalog that excludes disabled endpoints.\"\"\"",
            "        endpoint_ref = self._create_endpoints()",
            "",
            "        # Authenticate",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        token = self.controller.authenticate({}, body_dict)",
            "",
            "        # Check the catalog",
            "        self.assertEqual(1, len(token['access']['serviceCatalog']))",
            "        endpoint = token['access']['serviceCatalog'][0]['endpoints'][0]",
            "        self.assertEqual(",
            "            1, len(token['access']['serviceCatalog'][0]['endpoints']))",
            "",
            "        exp_endpoint = {",
            "            'id': endpoint_ref['id'],",
            "            'publicURL': endpoint_ref['url'],",
            "            'region': endpoint_ref['region_id'],",
            "        }",
            "",
            "        self.assertEqual(exp_endpoint, endpoint)",
            "",
            "    def test_validate_catalog_disabled_endpoint(self):",
            "        \"\"\"On validate, get back a catalog that excludes disabled endpoints.\"\"\"",
            "        endpoint_ref = self._create_endpoints()",
            "",
            "        # Authenticate",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        token = self.controller.authenticate({}, body_dict)",
            "",
            "        # Validate",
            "        token_id = token['access']['token']['id']",
            "        validate_ref = self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=token_id)",
            "",
            "        # Check the catalog",
            "        self.assertEqual(1, len(token['access']['serviceCatalog']))",
            "        endpoint = validate_ref['access']['serviceCatalog'][0]['endpoints'][0]",
            "        self.assertEqual(",
            "            1, len(token['access']['serviceCatalog'][0]['endpoints']))",
            "",
            "        exp_endpoint = {",
            "            'id': endpoint_ref['id'],",
            "            'publicURL': endpoint_ref['url'],",
            "            'region': endpoint_ref['region_id'],",
            "        }",
            "",
            "        self.assertEqual(exp_endpoint, endpoint)",
            "",
            "",
            "class NonDefaultAuthTest(unit.TestCase):",
            "",
            "    def test_add_non_default_auth_method(self):",
            "        self.config_fixture.config(group='auth',",
            "                                   methods=['password', 'token', 'custom'])",
            "        config.setup_authentication()",
            "        self.assertTrue(hasattr(CONF.auth, 'custom'))"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import datetime",
            "import random",
            "import string",
            "import uuid",
            "",
            "import mock",
            "from oslo_config import cfg",
            "import oslo_utils.fixture",
            "from oslo_utils import timeutils",
            "import six",
            "from testtools import matchers",
            "",
            "from keystone import assignment",
            "from keystone import auth",
            "from keystone.common import authorization",
            "from keystone.common import config",
            "from keystone import exception",
            "from keystone.models import token_model",
            "from keystone.tests import unit",
            "from keystone.tests.unit import default_fixtures",
            "from keystone.tests.unit import ksfixtures",
            "from keystone.tests.unit.ksfixtures import database",
            "from keystone import token",
            "from keystone.token import provider",
            "from keystone import trust",
            "",
            "",
            "CONF = cfg.CONF",
            "TIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'",
            "",
            "HOST = ''.join(random.choice(string.ascii_lowercase) for x in range(",
            "    random.randint(5, 15)))",
            "HOST_URL = 'http://%s' % (HOST)",
            "",
            "",
            "def _build_user_auth(token=None, user_id=None, username=None,",
            "                     password=None, tenant_id=None, tenant_name=None,",
            "                     trust_id=None):",
            "    \"\"\"Build auth dictionary.",
            "",
            "    It will create an auth dictionary based on all the arguments",
            "    that it receives.",
            "    \"\"\"",
            "    auth_json = {}",
            "    if token is not None:",
            "        auth_json['token'] = token",
            "    if username or password:",
            "        auth_json['passwordCredentials'] = {}",
            "    if username is not None:",
            "        auth_json['passwordCredentials']['username'] = username",
            "    if user_id is not None:",
            "        auth_json['passwordCredentials']['userId'] = user_id",
            "    if password is not None:",
            "        auth_json['passwordCredentials']['password'] = password",
            "    if tenant_name is not None:",
            "        auth_json['tenantName'] = tenant_name",
            "    if tenant_id is not None:",
            "        auth_json['tenantId'] = tenant_id",
            "    if trust_id is not None:",
            "        auth_json['trust_id'] = trust_id",
            "    return auth_json",
            "",
            "",
            "class AuthTest(unit.TestCase):",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(AuthTest, self).setUp()",
            "        self.time_fixture = self.useFixture(oslo_utils.fixture.TimeFixture())",
            "",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        self.context_with_remote_user = {'environment':",
            "                                         {'REMOTE_USER': 'FOO',",
            "                                          'AUTH_TYPE': 'Negotiate'}}",
            "        self.empty_context = {'environment': {}}",
            "",
            "        self.controller = token.controllers.Auth()",
            "",
            "    def assertEqualTokens(self, a, b, enforce_audit_ids=True):",
            "        \"\"\"Assert that two tokens are equal.",
            "",
            "        Compare two tokens except for their ids. This also truncates",
            "        the time in the comparison.",
            "        \"\"\"",
            "        def normalize(token):",
            "            token['access']['token']['id'] = 'dummy'",
            "            del token['access']['token']['expires']",
            "            del token['access']['token']['issued_at']",
            "            del token['access']['token']['audit_ids']",
            "            return token",
            "",
            "        self.assertCloseEnoughForGovernmentWork(",
            "            timeutils.parse_isotime(a['access']['token']['expires']),",
            "            timeutils.parse_isotime(b['access']['token']['expires']))",
            "        self.assertCloseEnoughForGovernmentWork(",
            "            timeutils.parse_isotime(a['access']['token']['issued_at']),",
            "            timeutils.parse_isotime(b['access']['token']['issued_at']))",
            "        if enforce_audit_ids:",
            "            self.assertIn(a['access']['token']['audit_ids'][0],",
            "                          b['access']['token']['audit_ids'])",
            "            self.assertThat(len(a['access']['token']['audit_ids']),",
            "                            matchers.LessThan(3))",
            "            self.assertThat(len(b['access']['token']['audit_ids']),",
            "                            matchers.LessThan(3))",
            "",
            "        return self.assertDictEqual(normalize(a), normalize(b))",
            "",
            "",
            "class AuthBadRequests(AuthTest):",
            "    def test_no_external_auth(self):",
            "        \"\"\"Verify that _authenticate_external() raises exception if N/A.\"\"\"",
            "        self.assertRaises(",
            "            token.controllers.ExternalAuthNotApplicable,",
            "            self.controller._authenticate_external,",
            "            context={}, auth={})",
            "",
            "    def test_empty_remote_user(self):",
            "        \"\"\"Verify exception is raised when REMOTE_USER is an empty string.\"\"\"",
            "        context = {'environment': {'REMOTE_USER': ''}}",
            "        self.assertRaises(",
            "            token.controllers.ExternalAuthNotApplicable,",
            "            self.controller._authenticate_external,",
            "            context=context, auth={})",
            "",
            "    def test_no_token_in_auth(self):",
            "        \"\"\"Verify that _authenticate_token() raises exception if no token.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller._authenticate_token,",
            "            None, {})",
            "",
            "    def test_no_credentials_in_auth(self):",
            "        \"\"\"Verify that _authenticate_local() raises exception if no creds.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller._authenticate_local,",
            "            None, {})",
            "",
            "    def test_empty_username_and_userid_in_auth(self):",
            "        \"\"\"Verify that empty username and userID raises ValidationError.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller._authenticate_local,",
            "            None, {'passwordCredentials': {'password': 'abc',",
            "                                           'userId': '', 'username': ''}})",
            "",
            "    def test_authenticate_blank_request_body(self):",
            "        \"\"\"Verify sending empty json dict raises the right exception.\"\"\"",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, {})",
            "",
            "    def test_authenticate_blank_auth(self):",
            "        \"\"\"Verify sending blank 'auth' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth()",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_invalid_auth_content(self):",
            "        \"\"\"Verify sending invalid 'auth' raises the right exception.\"\"\"",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, {'auth': 'abcd'})",
            "",
            "    def test_authenticate_user_id_too_large(self):",
            "        \"\"\"Verify sending large 'userId' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(user_id='0' * 65, username='FOO',",
            "                                     password='foo2')",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_username_too_large(self):",
            "        \"\"\"Verify sending large 'username' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(username='0' * 65, password='foo2')",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_tenant_id_too_large(self):",
            "        \"\"\"Verify sending large 'tenantId' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(username='FOO', password='foo2',",
            "                                     tenant_id='0' * 65)",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_tenant_name_too_large(self):",
            "        \"\"\"Verify sending large 'tenantName' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(username='FOO', password='foo2',",
            "                                     tenant_name='0' * 65)",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_token_too_large(self):",
            "        \"\"\"Verify sending large 'token' raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(token={'id': '0' * 8193})",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_password_too_large(self):",
            "        \"\"\"Verify sending large 'password' raises the right exception.\"\"\"",
            "        length = CONF.identity.max_password_length + 1",
            "        body_dict = _build_user_auth(username='FOO', password='0' * length)",
            "        self.assertRaises(exception.ValidationSizeError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_fails_if_project_unsafe(self):",
            "        \"\"\"Verify authenticate to a project with unsafe name fails.\"\"\"",
            "        # Start with url name restrictions off, so we can create the unsafe",
            "        # named project",
            "        self.config_fixture.config(group='resource',",
            "                                   project_name_url_safe='off')",
            "        unsafe_name = 'i am not / safe'",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id, name=unsafe_name)",
            "        self.resource_api.create_project(project['id'], project)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], project['id'], self.role_member['id'])",
            "        no_context = {}",
            "",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_name=project['name'])",
            "",
            "        # Since name url restriction is off, we should be able to authenticate",
            "        self.controller.authenticate(no_context, body_dict)",
            "",
            "        # Set the name url restriction to strict and we should fail to",
            "        # authenticate",
            "        self.config_fixture.config(group='resource',",
            "                                   project_name_url_safe='strict')",
            "        self.assertRaises(exception.Unauthorized,",
            "                          self.controller.authenticate,",
            "                          no_context, body_dict)",
            "",
            "",
            "class AuthWithToken(AuthTest):",
            "    def test_unscoped_token(self):",
            "        \"\"\"Verify getting an unscoped token with password creds.\"\"\"",
            "        body_dict = _build_user_auth(username='FOO',",
            "                                     password='foo2')",
            "        unscoped_token = self.controller.authenticate({}, body_dict)",
            "        self.assertNotIn('tenant', unscoped_token['access']['token'])",
            "",
            "    def test_auth_invalid_token(self):",
            "        \"\"\"Verify exception is raised if invalid token.\"\"\"",
            "        body_dict = _build_user_auth(token={\"id\": uuid.uuid4().hex})",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_bad_formatted_token(self):",
            "        \"\"\"Verify exception is raised if invalid token.\"\"\"",
            "        body_dict = _build_user_auth(token={})",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_unscoped_token_no_project(self):",
            "        \"\"\"Verify getting an unscoped token with an unscoped token.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2')",
            "        unscoped_token = self.controller.authenticate({}, body_dict)",
            "",
            "        body_dict = _build_user_auth(",
            "            token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate({}, body_dict)",
            "",
            "        self.assertEqualTokens(unscoped_token, unscoped_token_2)",
            "",
            "    def test_auth_unscoped_token_project(self):",
            "        \"\"\"Verify getting a token in a tenant with an unscoped token.\"\"\"",
            "        # Add a role in so we can check we get this back",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_member['id'])",
            "        # Get an unscoped token",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2')",
            "        unscoped_token = self.controller.authenticate({}, body_dict)",
            "        # Get a token on BAR tenant using the unscoped token",
            "        body_dict = _build_user_auth(",
            "            token=unscoped_token[\"access\"][\"token\"],",
            "            tenant_name=\"BAR\")",
            "        scoped_token = self.controller.authenticate({}, body_dict)",
            "",
            "        tenant = scoped_token[\"access\"][\"token\"][\"tenant\"]",
            "        roles = scoped_token[\"access\"][\"metadata\"][\"roles\"]",
            "        self.assertEqual(self.tenant_bar['id'], tenant[\"id\"])",
            "        self.assertThat(roles, matchers.Contains(self.role_member['id']))",
            "",
            "    def test_auth_scoped_token_bad_project_with_debug(self):",
            "        \"\"\"Authenticating with an invalid project fails.\"\"\"",
            "        # Bug 1379952 reports poor user feedback, even in insecure_debug mode,",
            "        # when the user accidentally passes a project name as an ID.",
            "        # This test intentionally does exactly that.",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_id=self.tenant_bar['name'])",
            "",
            "        # with insecure_debug enabled, this produces a friendly exception.",
            "        self.config_fixture.config(debug=True, insecure_debug=True)",
            "        e = self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "        # explicitly verify that the error message shows that a *name* is",
            "        # found where an *ID* is expected",
            "        self.assertIn(",
            "            'Project ID not found: %s' % self.tenant_bar['name'],",
            "            six.text_type(e))",
            "",
            "    def test_auth_scoped_token_bad_project_without_debug(self):",
            "        \"\"\"Authenticating with an invalid project fails.\"\"\"",
            "        # Bug 1379952 reports poor user feedback, even in insecure_debug mode,",
            "        # when the user accidentally passes a project name as an ID.",
            "        # This test intentionally does exactly that.",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_id=self.tenant_bar['name'])",
            "",
            "        # with insecure_debug disabled (the default), authentication failure",
            "        # details are suppressed.",
            "        e = self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "        # explicitly verify that the error message details above have been",
            "        # suppressed.",
            "        self.assertNotIn(",
            "            'Project ID not found: %s' % self.tenant_bar['name'],",
            "            six.text_type(e))",
            "",
            "    def test_auth_token_project_group_role(self):",
            "        \"\"\"Verify getting a token in a tenant with group roles.\"\"\"",
            "        # Add a v2 style role in so we can check we get this back",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_member['id'])",
            "        # Now create a group role for this user as well",
            "        domain1 = unit.new_domain_ref()",
            "        self.resource_api.create_domain(domain1['id'], domain1)",
            "        new_group = unit.new_group_ref(domain_id=domain1['id'])",
            "        new_group = self.identity_api.create_group(new_group)",
            "        self.identity_api.add_user_to_group(self.user_foo['id'],",
            "                                            new_group['id'])",
            "        self.assignment_api.create_grant(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'],",
            "            role_id=self.role_admin['id'])",
            "",
            "        # Get a scoped token for the tenant",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        scoped_token = self.controller.authenticate({}, body_dict)",
            "",
            "        tenant = scoped_token[\"access\"][\"token\"][\"tenant\"]",
            "        roles = scoped_token[\"access\"][\"metadata\"][\"roles\"]",
            "        self.assertEqual(self.tenant_bar['id'], tenant[\"id\"])",
            "        self.assertIn(self.role_member['id'], roles)",
            "        self.assertIn(self.role_admin['id'], roles)",
            "",
            "    def test_belongs_to_no_tenant(self):",
            "        r = self.controller.authenticate(",
            "            {},",
            "            auth={",
            "                'passwordCredentials': {",
            "                    'username': self.user_foo['name'],",
            "                    'password': self.user_foo['password']",
            "                }",
            "            })",
            "        unscoped_token_id = r['access']['token']['id']",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={'belongsTo': 'BAR'}),",
            "            token_id=unscoped_token_id)",
            "",
            "    def test_belongs_to(self):",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        scoped_token = self.controller.authenticate({}, body_dict)",
            "        scoped_token_id = scoped_token['access']['token']['id']",
            "",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={'belongsTo': 'me'}),",
            "            token_id=scoped_token_id)",
            "",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={'belongsTo': 'BAR'}),",
            "            token_id=scoped_token_id)",
            "",
            "    def test_token_auth_with_binding(self):",
            "        self.config_fixture.config(group='token', bind=['kerberos'])",
            "        body_dict = _build_user_auth()",
            "        unscoped_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        # the token should have bind information in it",
            "        bind = unscoped_token['access']['token']['bind']",
            "        self.assertEqual('FOO', bind['kerberos'])",
            "",
            "        body_dict = _build_user_auth(",
            "            token=unscoped_token['access']['token'],",
            "            tenant_name='BAR')",
            "",
            "        # using unscoped token without remote user context fails",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            self.empty_context, body_dict)",
            "",
            "        # using token with remote user context succeeds",
            "        scoped_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        # the bind information should be carried over from the original token",
            "        bind = scoped_token['access']['token']['bind']",
            "        self.assertEqual('FOO', bind['kerberos'])",
            "",
            "    def test_deleting_role_revokes_token(self):",
            "        role_controller = assignment.controllers.Role()",
            "        project1 = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id)",
            "        self.resource_api.create_project(project1['id'], project1)",
            "        role_one = unit.new_role_ref(id='role_one')",
            "        self.role_api.create_role(role_one['id'], role_one)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], project1['id'], role_one['id'])",
            "        no_context = {}",
            "",
            "        # Get a scoped token for the tenant",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password'],",
            "            tenant_name=project1['name'])",
            "        token = self.controller.authenticate(no_context, body_dict)",
            "        # Ensure it is valid",
            "        token_id = token['access']['token']['id']",
            "        self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=token_id)",
            "",
            "        # Delete the role, which should invalidate the token",
            "        role_controller.delete_role(",
            "            dict(is_admin=True, query_string={}), role_one['id'])",
            "",
            "        # Check the token is now invalid",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.controller.validate_token,",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=token_id)",
            "",
            "    def test_deleting_role_assignment_does_not_revoke_unscoped_token(self):",
            "        no_context = {}",
            "        admin_context = dict(is_admin=True, query_string={})",
            "",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id)",
            "        self.resource_api.create_project(project['id'], project)",
            "        role = unit.new_role_ref()",
            "        self.role_api.create_role(role['id'], role)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], project['id'], role['id'])",
            "",
            "        # Get an unscoped token.",
            "        token = self.controller.authenticate(no_context, _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=self.user_foo['password']))",
            "        token_id = token['access']['token']['id']",
            "",
            "        # Ensure it is valid",
            "        self.controller.validate_token(admin_context, token_id=token_id)",
            "",
            "        # Delete the role assignment, which should not invalidate the token,",
            "        # because we're not consuming it with just an unscoped token.",
            "        self.assignment_api.remove_role_from_user_and_project(",
            "            self.user_foo['id'], project['id'], role['id'])",
            "",
            "        # Ensure it is still valid",
            "        self.controller.validate_token(admin_context, token_id=token_id)",
            "",
            "    def test_only_original_audit_id_is_kept(self):",
            "        context = {}",
            "",
            "        def get_audit_ids(token):",
            "            return token['access']['token']['audit_ids']",
            "",
            "        # get a token",
            "        body_dict = _build_user_auth(username='FOO', password='foo2')",
            "        unscoped_token = self.controller.authenticate(context, body_dict)",
            "        starting_audit_id = get_audit_ids(unscoped_token)[0]",
            "        self.assertIsNotNone(starting_audit_id)",
            "",
            "        # get another token to ensure the correct parent audit_id is set",
            "        body_dict = _build_user_auth(token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "        audit_ids = get_audit_ids(unscoped_token_2)",
            "        self.assertThat(audit_ids, matchers.HasLength(2))",
            "        self.assertThat(audit_ids[-1], matchers.Equals(starting_audit_id))",
            "",
            "        # get another token from token 2 and ensure the correct parent",
            "        # audit_id is set",
            "        body_dict = _build_user_auth(token=unscoped_token_2[\"access\"][\"token\"])",
            "        unscoped_token_3 = self.controller.authenticate(context, body_dict)",
            "        audit_ids = get_audit_ids(unscoped_token_3)",
            "        self.assertThat(audit_ids, matchers.HasLength(2))",
            "        self.assertThat(audit_ids[-1], matchers.Equals(starting_audit_id))",
            "",
            "    def test_revoke_by_audit_chain_id_original_token(self):",
            "        self.config_fixture.config(group='token', revoke_by_id=False)",
            "        context = {}",
            "",
            "        # get a token",
            "        body_dict = _build_user_auth(username='FOO', password='foo2')",
            "        unscoped_token = self.controller.authenticate(context, body_dict)",
            "        token_id = unscoped_token['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        # get a second token",
            "        body_dict = _build_user_auth(token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "        token_2_id = unscoped_token_2['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        self.token_provider_api.revoke_token(token_id, revoke_chain=True)",
            "",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_2_id)",
            "",
            "    def test_revoke_by_audit_chain_id_chained_token(self):",
            "        self.config_fixture.config(group='token', revoke_by_id=False)",
            "        context = {}",
            "",
            "        # get a token",
            "        body_dict = _build_user_auth(username='FOO', password='foo2')",
            "        unscoped_token = self.controller.authenticate(context, body_dict)",
            "        token_id = unscoped_token['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        # get a second token",
            "        body_dict = _build_user_auth(token=unscoped_token[\"access\"][\"token\"])",
            "        unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "        token_2_id = unscoped_token_2['access']['token']['id']",
            "        self.time_fixture.advance_time_seconds(1)",
            "",
            "        self.token_provider_api.revoke_token(token_2_id, revoke_chain=True)",
            "",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_provider_api.validate_v2_token,",
            "                          token_id=token_2_id)",
            "",
            "    def _mock_audit_info(self, parent_audit_id):",
            "        # NOTE(morgainfainberg): The token model and other cases that are",
            "        # extracting the audit id expect 'None' if the audit id doesn't",
            "        # exist. This ensures that the audit_id is None and the",
            "        # audit_chain_id will also return None.",
            "        return [None, None]",
            "",
            "    def test_revoke_with_no_audit_info(self):",
            "        self.config_fixture.config(group='token', revoke_by_id=False)",
            "        context = {}",
            "",
            "        with mock.patch.object(provider, 'audit_info', self._mock_audit_info):",
            "            # get a token",
            "            body_dict = _build_user_auth(username='FOO', password='foo2')",
            "            unscoped_token = self.controller.authenticate(context, body_dict)",
            "            token_id = unscoped_token['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            # get a second token",
            "            body_dict = _build_user_auth(",
            "                token=unscoped_token['access']['token'])",
            "            unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "            token_2_id = unscoped_token_2['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            self.token_provider_api.revoke_token(token_id, revoke_chain=True)",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            revoke_events = self.revoke_api.list_events()",
            "            self.assertThat(revoke_events, matchers.HasLength(1))",
            "            revoke_event = revoke_events[0].to_dict()",
            "            self.assertIn('expires_at', revoke_event)",
            "            self.assertEqual(unscoped_token_2['access']['token']['expires'],",
            "                             revoke_event['expires_at'])",
            "",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_id)",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_2_id)",
            "",
            "            # get a new token, with no audit info",
            "            body_dict = _build_user_auth(username='FOO', password='foo2')",
            "            unscoped_token = self.controller.authenticate(context, body_dict)",
            "            token_id = unscoped_token['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "            # get a second token",
            "            body_dict = _build_user_auth(",
            "                token=unscoped_token['access']['token'])",
            "            unscoped_token_2 = self.controller.authenticate(context, body_dict)",
            "            token_2_id = unscoped_token_2['access']['token']['id']",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            # Revoke by audit_id, no audit_info means both parent and child",
            "            # token are revoked.",
            "            self.token_provider_api.revoke_token(token_id)",
            "            self.time_fixture.advance_time_seconds(1)",
            "",
            "            revoke_events = self.revoke_api.list_events()",
            "            self.assertThat(revoke_events, matchers.HasLength(2))",
            "            revoke_event = revoke_events[1].to_dict()",
            "            self.assertIn('expires_at', revoke_event)",
            "            self.assertEqual(unscoped_token_2['access']['token']['expires'],",
            "                             revoke_event['expires_at'])",
            "",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_id)",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_provider_api.validate_v2_token,",
            "                              token_id=token_2_id)",
            "",
            "",
            "class FernetAuthWithToken(AuthWithToken):",
            "    def config_overrides(self):",
            "        super(FernetAuthWithToken, self).config_overrides()",
            "        self.config_fixture.config(group='token', provider='fernet')",
            "        self.useFixture(ksfixtures.KeyRepository(self.config_fixture))",
            "",
            "    def test_token_auth_with_binding(self):",
            "        self.config_fixture.config(group='token', bind=['kerberos'])",
            "        body_dict = _build_user_auth()",
            "        self.assertRaises(exception.NotImplemented,",
            "                          self.controller.authenticate,",
            "                          self.context_with_remote_user,",
            "                          body_dict)",
            "",
            "    def test_revoke_with_no_audit_info(self):",
            "        self.skipTest('Fernet with v2.0 and revocation is broken')",
            "",
            "    def test_deleting_role_revokes_token(self):",
            "        self.skipTest('Fernet with v2.0 and revocation is broken')",
            "",
            "",
            "class AuthWithPasswordCredentials(AuthTest):",
            "    def test_auth_invalid_user(self):",
            "        \"\"\"Verify exception is raised if invalid user.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username=uuid.uuid4().hex,",
            "            password=uuid.uuid4().hex)",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_valid_user_invalid_password(self):",
            "        \"\"\"Verify exception is raised if invalid password.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username=\"FOO\",",
            "            password=uuid.uuid4().hex)",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_empty_password(self):",
            "        \"\"\"Verify exception is raised if empty password.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username=\"FOO\",",
            "            password=\"\")",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_auth_no_password(self):",
            "        \"\"\"Verify exception is raised if empty password.\"\"\"",
            "        body_dict = _build_user_auth(username=\"FOO\")",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller.authenticate,",
            "            {}, body_dict)",
            "",
            "    def test_authenticate_blank_password_credentials(self):",
            "        \"\"\"Sending empty dict as passwordCredentials raises 400 Bad Requset.\"\"\"",
            "        body_dict = {'passwordCredentials': {}, 'tenantName': 'demo'}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_authenticate_no_username(self):",
            "        \"\"\"Verify skipping username raises the right exception.\"\"\"",
            "        body_dict = _build_user_auth(password=\"pass\",",
            "                                     tenant_name=\"demo\")",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.controller.authenticate,",
            "                          {}, body_dict)",
            "",
            "    def test_bind_without_remote_user(self):",
            "        self.config_fixture.config(group='token', bind=['kerberos'])",
            "        body_dict = _build_user_auth(username='FOO', password='foo2',",
            "                                     tenant_name='BAR')",
            "        token = self.controller.authenticate({}, body_dict)",
            "        self.assertNotIn('bind', token['access']['token'])",
            "",
            "    def test_change_default_domain_id(self):",
            "        # If the default_domain_id config option is not the default then the",
            "        # user in auth data is from the new default domain.",
            "",
            "        # 1) Create a new domain.",
            "        new_domain = unit.new_domain_ref()",
            "        new_domain_id = new_domain['id']",
            "",
            "        self.resource_api.create_domain(new_domain_id, new_domain)",
            "",
            "        # 2) Create user \"foo\" in new domain with different password than",
            "        #    default-domain foo.",
            "        new_user = unit.create_user(self.identity_api,",
            "                                    name=self.user_foo['name'],",
            "                                    domain_id=new_domain_id)",
            "",
            "        # 3) Update the default_domain_id config option to the new domain",
            "",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        # 4) Authenticate as \"foo\" using the password in the new domain.",
            "",
            "        body_dict = _build_user_auth(",
            "            username=self.user_foo['name'],",
            "            password=new_user['password'])",
            "",
            "        # The test is successful if this doesn't raise, so no need to assert.",
            "        self.controller.authenticate({}, body_dict)",
            "",
            "",
            "class AuthWithRemoteUser(AuthTest):",
            "    def test_unscoped_remote_authn(self):",
            "        \"\"\"Verify getting an unscoped token with external authn.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2')",
            "        local_token = self.controller.authenticate(",
            "            {}, body_dict)",
            "",
            "        body_dict = _build_user_auth()",
            "        remote_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        self.assertEqualTokens(local_token, remote_token,",
            "                               enforce_audit_ids=False)",
            "",
            "    def test_unscoped_remote_authn_jsonless(self):",
            "        \"\"\"Verify that external auth with invalid request fails.\"\"\"",
            "        self.assertRaises(",
            "            exception.ValidationError,",
            "            self.controller.authenticate,",
            "            {'REMOTE_USER': 'FOO'},",
            "            None)",
            "",
            "    def test_scoped_remote_authn(self):",
            "        \"\"\"Verify getting a token with external authn.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name='BAR')",
            "        local_token = self.controller.authenticate(",
            "            {}, body_dict)",
            "",
            "        body_dict = _build_user_auth(",
            "            tenant_name='BAR')",
            "        remote_token = self.controller.authenticate(",
            "            self.context_with_remote_user, body_dict)",
            "",
            "        self.assertEqualTokens(local_token, remote_token,",
            "                               enforce_audit_ids=False)",
            "",
            "    def test_scoped_nometa_remote_authn(self):",
            "        \"\"\"Verify getting a token with external authn and no metadata.\"\"\"",
            "        body_dict = _build_user_auth(",
            "            username='TWO',",
            "            password='two2',",
            "            tenant_name='BAZ')",
            "        local_token = self.controller.authenticate(",
            "            {}, body_dict)",
            "",
            "        body_dict = _build_user_auth(tenant_name='BAZ')",
            "        remote_token = self.controller.authenticate(",
            "            {'environment': {'REMOTE_USER': 'TWO'}}, body_dict)",
            "",
            "        self.assertEqualTokens(local_token, remote_token,",
            "                               enforce_audit_ids=False)",
            "",
            "    def test_scoped_remote_authn_invalid_user(self):",
            "        \"\"\"Verify that external auth with invalid user fails.\"\"\"",
            "        body_dict = _build_user_auth(tenant_name=\"BAR\")",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate,",
            "            {'environment': {'REMOTE_USER': uuid.uuid4().hex}},",
            "            body_dict)",
            "",
            "    def test_bind_with_kerberos(self):",
            "        self.config_fixture.config(group='token', bind=['kerberos'])",
            "        body_dict = _build_user_auth(tenant_name=\"BAR\")",
            "        token = self.controller.authenticate(self.context_with_remote_user,",
            "                                             body_dict)",
            "        self.assertEqual('FOO', token['access']['token']['bind']['kerberos'])",
            "",
            "    def test_bind_without_config_opt(self):",
            "        self.config_fixture.config(group='token', bind=['x509'])",
            "        body_dict = _build_user_auth(tenant_name='BAR')",
            "        token = self.controller.authenticate(self.context_with_remote_user,",
            "                                             body_dict)",
            "        self.assertNotIn('bind', token['access']['token'])",
            "",
            "",
            "class AuthWithTrust(AuthTest):",
            "    def setUp(self):",
            "        super(AuthWithTrust, self).setUp()",
            "",
            "        self.trust_controller = trust.controllers.TrustV3()",
            "        self.auth_v3_controller = auth.controllers.Auth()",
            "        self.trustor = self.user_foo",
            "        self.trustee = self.user_two",
            "        self.assigned_roles = [self.role_member['id'],",
            "                               self.role_browser['id']]",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "",
            "        self.sample_data = {'trustor_user_id': self.trustor['id'],",
            "                            'trustee_user_id': self.trustee['id'],",
            "                            'project_id': self.tenant_bar['id'],",
            "                            'impersonation': True,",
            "                            'roles': [{'id': self.role_browser['id']},",
            "                                      {'name': self.role_member['name']}]}",
            "",
            "    def config_overrides(self):",
            "        super(AuthWithTrust, self).config_overrides()",
            "        self.config_fixture.config(group='trust', enabled=True)",
            "",
            "    def _create_auth_context(self, token_id):",
            "        token_ref = token_model.KeystoneToken(",
            "            token_id=token_id,",
            "            token_data=self.token_provider_api.validate_token(token_id))",
            "        auth_context = authorization.token_to_auth_context(token_ref)",
            "        # NOTE(gyee): if public_endpoint and admin_endpoint are not set, which",
            "        # is the default, the base url will be constructed from the environment",
            "        # variables wsgi.url_scheme, SERVER_NAME, SERVER_PORT, and SCRIPT_NAME.",
            "        # We have to set them in the context so the base url can be constructed",
            "        # accordingly.",
            "        return {'environment': {authorization.AUTH_CONTEXT_ENV: auth_context,",
            "                                'wsgi.url_scheme': 'http',",
            "                                'SCRIPT_NAME': '/v3',",
            "                                'SERVER_PORT': '80',",
            "                                'SERVER_NAME': HOST},",
            "                'token_id': token_id,",
            "                'host_url': HOST_URL}",
            "",
            "    def create_trust(self, trust_data, trustor_name, expires_at=None,",
            "                     impersonation=True):",
            "        username = trustor_name",
            "        password = 'foo2'",
            "        unscoped_token = self.get_unscoped_token(username, password)",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        trust_data_copy = copy.deepcopy(trust_data)",
            "        trust_data_copy['expires_at'] = expires_at",
            "        trust_data_copy['impersonation'] = impersonation",
            "",
            "        return self.trust_controller.create_trust(",
            "            context, trust=trust_data_copy)['trust']",
            "",
            "    def get_unscoped_token(self, username, password='foo2'):",
            "        body_dict = _build_user_auth(username=username, password=password)",
            "        return self.controller.authenticate({}, body_dict)",
            "",
            "    def build_v2_token_request(self, username, password, trust,",
            "                               tenant_id=None):",
            "        if not tenant_id:",
            "            tenant_id = self.tenant_bar['id']",
            "        unscoped_token = self.get_unscoped_token(username, password)",
            "        unscoped_token_id = unscoped_token['access']['token']['id']",
            "        request_body = _build_user_auth(token={'id': unscoped_token_id},",
            "                                        trust_id=trust['id'],",
            "                                        tenant_id=tenant_id)",
            "        return request_body",
            "",
            "    def test_create_trust_bad_data_fails(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        bad_sample_data = {'trustor_user_id': self.trustor['id'],",
            "                           'project_id': self.tenant_bar['id'],",
            "                           'roles': [{'id': self.role_browser['id']}]}",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.trust_controller.create_trust,",
            "                          context, trust=bad_sample_data)",
            "",
            "    def test_create_trust_no_roles(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = {'token_id': unscoped_token['access']['token']['id']}",
            "        self.sample_data['roles'] = []",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.trust_controller.create_trust,",
            "                          context, trust=self.sample_data)",
            "",
            "    def test_create_trust(self):",
            "        expires_at = (timeutils.utcnow() +",
            "                      datetime.timedelta(minutes=10)).strftime(TIME_FORMAT)",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'],",
            "                                      expires_at=expires_at)",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        role_ids = [self.role_browser['id'], self.role_member['id']]",
            "        self.assertTrue(timeutils.parse_strtime(new_trust['expires_at'],",
            "                                                fmt=TIME_FORMAT))",
            "        self.assertIn('%s/v3/OS-TRUST/' % HOST_URL,",
            "                      new_trust['links']['self'])",
            "        self.assertIn('%s/v3/OS-TRUST/' % HOST_URL,",
            "                      new_trust['roles_links']['self'])",
            "",
            "        for role in new_trust['roles']:",
            "            self.assertIn(role['id'], role_ids)",
            "",
            "    def test_create_trust_expires_bad(self):",
            "        self.assertRaises(exception.ValidationTimeStampError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'], expires_at=\"bad\")",
            "        self.assertRaises(exception.ValidationTimeStampError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'], expires_at=\"\")",
            "        self.assertRaises(exception.ValidationTimeStampError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'], expires_at=\"Z\")",
            "",
            "    def test_create_trust_expires_older_than_now(self):",
            "        self.assertRaises(exception.ValidationExpirationError,",
            "                          self.create_trust, self.sample_data,",
            "                          self.trustor['name'],",
            "                          expires_at=\"2010-06-04T08:44:31.999999Z\")",
            "",
            "    def test_create_trust_without_project_id(self):",
            "        \"\"\"Verify that trust can be created without project id.",
            "",
            "        Also, token can be generated with that trust.",
            "        \"\"\"",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        self.sample_data['project_id'] = None",
            "        self.sample_data['roles'] = []",
            "        new_trust = self.trust_controller.create_trust(",
            "            context, trust=self.sample_data)['trust']",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        self.assertIs(new_trust['impersonation'], True)",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        token_user = auth_response['access']['user']",
            "        self.assertEqual(token_user['id'], new_trust['trustor_user_id'])",
            "",
            "    def test_get_trust(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        new_trust = self.trust_controller.create_trust(",
            "            context, trust=self.sample_data)['trust']",
            "        trust = self.trust_controller.get_trust(context,",
            "                                                new_trust['id'])['trust']",
            "        self.assertEqual(self.trustor['id'], trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], trust['trustee_user_id'])",
            "        role_ids = [self.role_browser['id'], self.role_member['id']]",
            "        for role in new_trust['roles']:",
            "            self.assertIn(role['id'], role_ids)",
            "",
            "    def test_get_trust_without_auth_context(self):",
            "        \"\"\"Verify a trust cannot be retrieved if auth context is missing.\"\"\"",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        new_trust = self.trust_controller.create_trust(",
            "            context, trust=self.sample_data)['trust']",
            "        # Delete the auth context before calling get_trust().",
            "        del context['environment'][authorization.AUTH_CONTEXT_ENV]",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.trust_controller.get_trust, context,",
            "                          new_trust['id'])",
            "",
            "    def test_create_trust_no_impersonation(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'],",
            "                                      expires_at=None, impersonation=False)",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        self.assertIs(new_trust['impersonation'], False)",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        token_user = auth_response['access']['user']",
            "        self.assertEqual(token_user['id'], new_trust['trustee_user_id'])",
            "",
            "    def test_create_trust_impersonation(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        self.assertEqual(self.trustor['id'], new_trust['trustor_user_id'])",
            "        self.assertEqual(self.trustee['id'], new_trust['trustee_user_id'])",
            "        self.assertIs(new_trust['impersonation'], True)",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        token_user = auth_response['access']['user']",
            "        self.assertEqual(token_user['id'], new_trust['trustor_user_id'])",
            "",
            "    def test_token_from_trust_wrong_user_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request('FOO', 'foo2', new_trust)",
            "        self.assertRaises(exception.Forbidden, self.controller.authenticate,",
            "                          {}, request_body)",
            "",
            "    def test_token_from_trust_wrong_project_fails(self):",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                self.trustor['id'], self.tenant_baz['id'], assigned_role)",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust,",
            "                                                   self.tenant_baz['id'])",
            "        self.assertRaises(exception.Forbidden, self.controller.authenticate,",
            "                          {}, request_body)",
            "",
            "    def fetch_v2_token_from_trust(self, trust):",
            "        request_body = self.build_v2_token_request('TWO', 'two2', trust)",
            "        auth_response = self.controller.authenticate({}, request_body)",
            "        return auth_response",
            "",
            "    def fetch_v3_token_from_trust(self, trust, trustee):",
            "        v3_password_data = {",
            "            'identity': {",
            "                \"methods\": [\"password\"],",
            "                \"password\": {",
            "                    \"user\": {",
            "                        \"id\": trustee[\"id\"],",
            "                        \"password\": trustee[\"password\"]",
            "                    }",
            "                }",
            "            },",
            "            'scope': {",
            "                'project': {",
            "                    'id': self.tenant_baz['id']",
            "                }",
            "            }",
            "        }",
            "        auth_response = (self.auth_v3_controller.authenticate_for_token",
            "                         ({'environment': {},",
            "                           'query_string': {}},",
            "                          v3_password_data))",
            "        token = auth_response.headers['X-Subject-Token']",
            "",
            "        v3_req_with_trust = {",
            "            \"identity\": {",
            "                \"methods\": [\"token\"],",
            "                \"token\": {\"id\": token}},",
            "            \"scope\": {",
            "                \"OS-TRUST:trust\": {\"id\": trust['id']}}}",
            "        token_auth_response = (self.auth_v3_controller.authenticate_for_token",
            "                               ({'environment': {},",
            "                                 'query_string': {}},",
            "                                v3_req_with_trust))",
            "        return token_auth_response",
            "",
            "    def test_create_v3_token_from_trust(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v3_token_from_trust(new_trust, self.trustee)",
            "",
            "        trust_token_user = auth_response.json['token']['user']",
            "        self.assertEqual(self.trustor['id'], trust_token_user['id'])",
            "",
            "        trust_token_trust = auth_response.json['token']['OS-TRUST:trust']",
            "        self.assertEqual(trust_token_trust['id'], new_trust['id'])",
            "        self.assertEqual(self.trustor['id'],",
            "                         trust_token_trust['trustor_user']['id'])",
            "        self.assertEqual(self.trustee['id'],",
            "                         trust_token_trust['trustee_user']['id'])",
            "",
            "        trust_token_roles = auth_response.json['token']['roles']",
            "        self.assertEqual(2, len(trust_token_roles))",
            "",
            "    def test_v3_trust_token_get_token_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v3_token_from_trust(new_trust, self.trustee)",
            "        trust_token = auth_response.headers['X-Subject-Token']",
            "        v3_token_data = {'identity': {",
            "            'methods': ['token'],",
            "            'token': {'id': trust_token}",
            "        }}",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.auth_v3_controller.authenticate_for_token,",
            "            {'environment': {},",
            "             'query_string': {}}, v3_token_data)",
            "",
            "    def test_token_from_trust(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "",
            "        self.assertIsNotNone(auth_response)",
            "        self.assertEqual(2,",
            "                         len(auth_response['access']['metadata']['roles']),",
            "                         \"user_foo has three roles, but the token should\"",
            "                         \" only get the two roles specified in the trust.\")",
            "",
            "    def assert_token_count_for_trust(self, trust, expected_value):",
            "        tokens = self.token_provider_api._persistence._list_tokens(",
            "            self.trustee['id'], trust_id=trust['id'])",
            "        token_count = len(tokens)",
            "        self.assertEqual(expected_value, token_count)",
            "",
            "    def test_delete_tokens_for_user_invalidates_tokens_from_trust(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        self.assert_token_count_for_trust(new_trust, 0)",
            "        self.fetch_v2_token_from_trust(new_trust)",
            "        self.assert_token_count_for_trust(new_trust, 1)",
            "        self.token_provider_api._persistence.delete_tokens_for_user(",
            "            self.trustee['id'])",
            "        self.assert_token_count_for_trust(new_trust, 0)",
            "",
            "    def test_token_from_trust_cant_get_another_token(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        auth_response = self.fetch_v2_token_from_trust(new_trust)",
            "        trust_token_id = auth_response['access']['token']['id']",
            "        request_body = _build_user_auth(token={'id': trust_token_id},",
            "                                        tenant_id=self.tenant_bar['id'])",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_delete_trust_revokes_token(self):",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        self.fetch_v2_token_from_trust(new_trust)",
            "        trust_id = new_trust['id']",
            "        tokens = self.token_provider_api._persistence._list_tokens(",
            "            self.trustor['id'],",
            "            trust_id=trust_id)",
            "        self.assertEqual(1, len(tokens))",
            "        self.trust_controller.delete_trust(context, trust_id=trust_id)",
            "        tokens = self.token_provider_api._persistence._list_tokens(",
            "            self.trustor['id'],",
            "            trust_id=trust_id)",
            "        self.assertEqual(0, len(tokens))",
            "",
            "    def test_token_from_trust_with_no_role_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.remove_role_from_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust)",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_expired_trust_get_token_fails(self):",
            "        expires_at = (timeutils.utcnow() +",
            "                      datetime.timedelta(minutes=5)).strftime(TIME_FORMAT)",
            "        time_expired = timeutils.utcnow() + datetime.timedelta(minutes=10)",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'],",
            "                                      expires_at)",
            "        with mock.patch.object(timeutils, 'utcnow') as mock_now:",
            "            mock_now.return_value = time_expired",
            "            request_body = self.build_v2_token_request('TWO', 'two2',",
            "                                                       new_trust)",
            "            self.assertRaises(",
            "                exception.Forbidden,",
            "                self.controller.authenticate, {}, request_body)",
            "",
            "    def test_token_from_trust_with_wrong_role_fails(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.trustor['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_other['id'])",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.remove_role_from_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust)",
            "",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_do_not_consume_remaining_uses_when_get_token_fails(self):",
            "        trust_data = copy.deepcopy(self.sample_data)",
            "        trust_data['remaining_uses'] = 3",
            "        new_trust = self.create_trust(trust_data, self.trustor['name'])",
            "",
            "        for assigned_role in self.assigned_roles:",
            "            self.assignment_api.remove_role_from_user_and_project(",
            "                self.trustor['id'], self.tenant_bar['id'], assigned_role)",
            "",
            "        request_body = self.build_v2_token_request('TWO', 'two2', new_trust)",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.controller.authenticate, {}, request_body)",
            "",
            "        unscoped_token = self.get_unscoped_token(self.trustor['name'])",
            "        context = self._create_auth_context(",
            "            unscoped_token['access']['token']['id'])",
            "        trust = self.trust_controller.get_trust(context,",
            "                                                new_trust['id'])['trust']",
            "        self.assertEqual(3, trust['remaining_uses'])",
            "",
            "    def disable_user(self, user):",
            "        user['enabled'] = False",
            "        self.identity_api.update_user(user['id'], user)",
            "",
            "    def test_trust_get_token_fails_if_trustor_disabled(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request(self.trustee['name'],",
            "                                                   self.trustee['password'],",
            "                                                   new_trust)",
            "        self.disable_user(self.trustor)",
            "        self.assertRaises(",
            "            exception.Forbidden,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "    def test_trust_get_token_fails_if_trustee_disabled(self):",
            "        new_trust = self.create_trust(self.sample_data, self.trustor['name'])",
            "        request_body = self.build_v2_token_request(self.trustee['name'],",
            "                                                   self.trustee['password'],",
            "                                                   new_trust)",
            "        self.disable_user(self.trustee)",
            "        self.assertRaises(",
            "            exception.Unauthorized,",
            "            self.controller.authenticate, {}, request_body)",
            "",
            "",
            "class TokenExpirationTest(AuthTest):",
            "",
            "    @mock.patch.object(timeutils, 'utcnow')",
            "    def _maintain_token_expiration(self, mock_utcnow):",
            "        \"\"\"Token expiration should be maintained after re-auth & validation.\"\"\"",
            "        now = datetime.datetime.utcnow()",
            "        mock_utcnow.return_value = now",
            "",
            "        r = self.controller.authenticate(",
            "            {},",
            "            auth={",
            "                'passwordCredentials': {",
            "                    'username': self.user_foo['name'],",
            "                    'password': self.user_foo['password']",
            "                }",
            "            })",
            "        unscoped_token_id = r['access']['token']['id']",
            "        original_expiration = r['access']['token']['expires']",
            "",
            "        mock_utcnow.return_value = now + datetime.timedelta(seconds=1)",
            "",
            "        r = self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=unscoped_token_id)",
            "        self.assertEqual(original_expiration, r['access']['token']['expires'])",
            "",
            "        mock_utcnow.return_value = now + datetime.timedelta(seconds=2)",
            "",
            "        r = self.controller.authenticate(",
            "            {},",
            "            auth={",
            "                'token': {",
            "                    'id': unscoped_token_id,",
            "                },",
            "                'tenantId': self.tenant_bar['id'],",
            "            })",
            "        scoped_token_id = r['access']['token']['id']",
            "        self.assertEqual(original_expiration, r['access']['token']['expires'])",
            "",
            "        mock_utcnow.return_value = now + datetime.timedelta(seconds=3)",
            "",
            "        r = self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=scoped_token_id)",
            "        self.assertEqual(original_expiration, r['access']['token']['expires'])",
            "",
            "    def test_maintain_uuid_token_expiration(self):",
            "        self.config_fixture.config(group='token', provider='uuid')",
            "        self._maintain_token_expiration()",
            "",
            "",
            "class AuthCatalog(unit.SQLDriverOverrides, AuthTest):",
            "    \"\"\"Test for the catalog provided in the auth response.\"\"\"",
            "",
            "    def config_files(self):",
            "        config_files = super(AuthCatalog, self).config_files()",
            "        # We need to use a backend that supports disabled endpoints, like the",
            "        # SQL backend.",
            "        config_files.append(unit.dirs.tests_conf('backend_sql.conf'))",
            "        return config_files",
            "",
            "    def _create_endpoints(self):",
            "        def create_region(**kwargs):",
            "            ref = unit.new_region_ref(**kwargs)",
            "            self.catalog_api.create_region(ref)",
            "            return ref",
            "",
            "        def create_endpoint(service_id, region, **kwargs):",
            "            endpoint = unit.new_endpoint_ref(region_id=region,",
            "                                             service_id=service_id, **kwargs)",
            "",
            "            self.catalog_api.create_endpoint(endpoint['id'], endpoint)",
            "            return endpoint",
            "",
            "        # Create a service for use with the endpoints.",
            "        def create_service(**kwargs):",
            "            ref = unit.new_service_ref(**kwargs)",
            "            self.catalog_api.create_service(ref['id'], ref)",
            "            return ref",
            "",
            "        enabled_service_ref = create_service(enabled=True)",
            "        disabled_service_ref = create_service(enabled=False)",
            "",
            "        region = create_region()",
            "",
            "        # Create endpoints",
            "        enabled_endpoint_ref = create_endpoint(",
            "            enabled_service_ref['id'], region['id'])",
            "        create_endpoint(",
            "            enabled_service_ref['id'], region['id'], enabled=False,",
            "            interface='internal')",
            "        create_endpoint(",
            "            disabled_service_ref['id'], region['id'])",
            "",
            "        return enabled_endpoint_ref",
            "",
            "    def test_auth_catalog_disabled_endpoint(self):",
            "        \"\"\"On authenticate, get a catalog that excludes disabled endpoints.\"\"\"",
            "        endpoint_ref = self._create_endpoints()",
            "",
            "        # Authenticate",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        token = self.controller.authenticate({}, body_dict)",
            "",
            "        # Check the catalog",
            "        self.assertEqual(1, len(token['access']['serviceCatalog']))",
            "        endpoint = token['access']['serviceCatalog'][0]['endpoints'][0]",
            "        self.assertEqual(",
            "            1, len(token['access']['serviceCatalog'][0]['endpoints']))",
            "",
            "        exp_endpoint = {",
            "            'id': endpoint_ref['id'],",
            "            'publicURL': endpoint_ref['url'],",
            "            'region': endpoint_ref['region_id'],",
            "        }",
            "",
            "        self.assertEqual(exp_endpoint, endpoint)",
            "",
            "    def test_validate_catalog_disabled_endpoint(self):",
            "        \"\"\"On validate, get back a catalog that excludes disabled endpoints.\"\"\"",
            "        endpoint_ref = self._create_endpoints()",
            "",
            "        # Authenticate",
            "        body_dict = _build_user_auth(",
            "            username='FOO',",
            "            password='foo2',",
            "            tenant_name=\"BAR\")",
            "",
            "        token = self.controller.authenticate({}, body_dict)",
            "",
            "        # Validate",
            "        token_id = token['access']['token']['id']",
            "        validate_ref = self.controller.validate_token(",
            "            dict(is_admin=True, query_string={}),",
            "            token_id=token_id)",
            "",
            "        # Check the catalog",
            "        self.assertEqual(1, len(token['access']['serviceCatalog']))",
            "        endpoint = validate_ref['access']['serviceCatalog'][0]['endpoints'][0]",
            "        self.assertEqual(",
            "            1, len(token['access']['serviceCatalog'][0]['endpoints']))",
            "",
            "        exp_endpoint = {",
            "            'id': endpoint_ref['id'],",
            "            'publicURL': endpoint_ref['url'],",
            "            'region': endpoint_ref['region_id'],",
            "        }",
            "",
            "        self.assertEqual(exp_endpoint, endpoint)",
            "",
            "",
            "class NonDefaultAuthTest(unit.TestCase):",
            "",
            "    def test_add_non_default_auth_method(self):",
            "        self.config_fixture.config(group='auth',",
            "                                   methods=['password', 'token', 'custom'])",
            "        config.setup_authentication()",
            "        self.assertTrue(hasattr(CONF.auth, 'custom'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "web.server.codechecker_server.server"
        ]
    },
    "keystone/token/controllers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         try:"
            },
            "1": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             token_model_ref = token_model.KeystoneToken("
            },
            "2": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                 token_id=old_token,"
            },
            "3": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                token_data=self.token_provider_api.validate_token(old_token))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+                token_data=self.token_provider_api.validate_v2_token(old_token)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+            )"
            },
            "6": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         except exception.NotFound as e:"
            },
            "7": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "             raise exception.Unauthorized(e)"
            },
            "8": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import datetime",
            "import sys",
            "",
            "from keystone.common import utils",
            "from keystoneclient.common import cms",
            "from oslo_config import cfg",
            "from oslo_log import log",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import timeutils",
            "import six",
            "",
            "from keystone.common import controller",
            "from keystone.common import dependency",
            "from keystone.common import wsgi",
            "from keystone import exception",
            "from keystone.i18n import _",
            "from keystone.models import token_model",
            "from keystone.token import provider",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "class ExternalAuthNotApplicable(Exception):",
            "    \"\"\"External authentication is not applicable.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "@dependency.requires('assignment_api', 'catalog_api', 'identity_api',",
            "                     'resource_api', 'role_api', 'token_provider_api',",
            "                     'trust_api')",
            "class Auth(controller.V2Controller):",
            "",
            "    @controller.v2_deprecated",
            "    def ca_cert(self, context, auth=None):",
            "        with open(CONF.signing.ca_certs, 'r') as ca_file:",
            "            data = ca_file.read()",
            "        return data",
            "",
            "    @controller.v2_deprecated",
            "    def signing_cert(self, context, auth=None):",
            "        with open(CONF.signing.certfile, 'r') as cert_file:",
            "            data = cert_file.read()",
            "        return data",
            "",
            "    @controller.v2_auth_deprecated",
            "    def authenticate(self, context, auth=None):",
            "        \"\"\"Authenticate credentials and return a token.",
            "",
            "        Accept auth as a dict that looks like::",
            "",
            "            {",
            "                \"auth\":{",
            "                    \"passwordCredentials\":{",
            "                        \"username\":\"test_user\",",
            "                        \"password\":\"mypass\"",
            "                    },",
            "                    \"tenantName\":\"customer-x\"",
            "                }",
            "            }",
            "",
            "        In this case, tenant is optional, if not provided the token will be",
            "        considered \"unscoped\" and can later be used to get a scoped token.",
            "",
            "        Alternatively, this call accepts auth with only a token and tenant",
            "        that will return a token that is scoped to that tenant.",
            "        \"\"\"",
            "        if auth is None:",
            "            raise exception.ValidationError(attribute='auth',",
            "                                            target='request body')",
            "",
            "        if \"token\" in auth:",
            "            # Try to authenticate using a token",
            "            auth_info = self._authenticate_token(",
            "                context, auth)",
            "        else:",
            "            # Try external authentication",
            "            try:",
            "                auth_info = self._authenticate_external(",
            "                    context, auth)",
            "            except ExternalAuthNotApplicable:",
            "                # Try local authentication",
            "                auth_info = self._authenticate_local(",
            "                    context, auth)",
            "",
            "        user_ref, tenant_ref, metadata_ref, expiry, bind, audit_id = auth_info",
            "        # Validate that the auth info is valid and nothing is disabled",
            "        try:",
            "            self.identity_api.assert_user_enabled(",
            "                user_id=user_ref['id'], user=user_ref)",
            "            if tenant_ref:",
            "                self.resource_api.assert_project_enabled(",
            "                    project_id=tenant_ref['id'], project=tenant_ref)",
            "        except AssertionError as e:",
            "            six.reraise(exception.Unauthorized, exception.Unauthorized(e),",
            "                        sys.exc_info()[2])",
            "        # NOTE(morganfainberg): Make sure the data is in correct form since it",
            "        # might be consumed external to Keystone and this is a v2.0 controller.",
            "        # The user_ref is encoded into the auth_token_data which is returned as",
            "        # part of the token data. The token provider doesn't care about the",
            "        # format.",
            "        user_ref = self.v3_to_v2_user(user_ref)",
            "        if tenant_ref:",
            "            tenant_ref = self.v3_to_v2_project(tenant_ref)",
            "",
            "        auth_token_data = self._get_auth_token_data(user_ref,",
            "                                                    tenant_ref,",
            "                                                    metadata_ref,",
            "                                                    expiry,",
            "                                                    audit_id)",
            "",
            "        if tenant_ref:",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                user_ref['id'], tenant_ref['id'])",
            "        else:",
            "            catalog_ref = {}",
            "",
            "        auth_token_data['id'] = 'placeholder'",
            "        if bind:",
            "            auth_token_data['bind'] = bind",
            "",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            role_ref = self.role_api.get_role(role_id)",
            "            roles_ref.append(dict(name=role_ref['name']))",
            "",
            "        (token_id, token_data) = self.token_provider_api.issue_v2_token(",
            "            auth_token_data, roles_ref=roles_ref, catalog_ref=catalog_ref)",
            "",
            "        # NOTE(wanghong): We consume a trust use only when we are using trusts",
            "        # and have successfully issued a token.",
            "        if CONF.trust.enabled and 'trust_id' in auth:",
            "            self.trust_api.consume_use(auth['trust_id'])",
            "",
            "        return token_data",
            "",
            "    def _restrict_scope(self, token_model_ref):",
            "        # A trust token cannot be used to get another token",
            "        if token_model_ref.trust_scoped:",
            "            raise exception.Forbidden()",
            "        if not CONF.token.allow_rescope_scoped_token:",
            "            # Do not allow conversion from scoped tokens.",
            "            if token_model_ref.project_scoped or token_model_ref.domain_scoped:",
            "                raise exception.Forbidden(action=_(\"rescope a scoped token\"))",
            "",
            "    def _authenticate_token(self, context, auth):",
            "        \"\"\"Try to authenticate using an already existing token.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'token' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='token', target='auth')",
            "",
            "        if \"id\" not in auth['token']:",
            "            raise exception.ValidationError(",
            "                attribute=\"id\", target=\"token\")",
            "",
            "        old_token = auth['token']['id']",
            "        if len(old_token) > CONF.max_token_size:",
            "            raise exception.ValidationSizeError(attribute='token',",
            "                                                size=CONF.max_token_size)",
            "",
            "        try:",
            "            token_model_ref = token_model.KeystoneToken(",
            "                token_id=old_token,",
            "                token_data=self.token_provider_api.validate_token(old_token))",
            "        except exception.NotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        wsgi.validate_token_bind(context, token_model_ref)",
            "",
            "        self._restrict_scope(token_model_ref)",
            "        user_id = token_model_ref.user_id",
            "        tenant_id = self._get_project_id_from_auth(auth)",
            "",
            "        if not CONF.trust.enabled and 'trust_id' in auth:",
            "            raise exception.Forbidden('Trusts are disabled.')",
            "        elif CONF.trust.enabled and 'trust_id' in auth:",
            "            try:",
            "                trust_ref = self.trust_api.get_trust(auth['trust_id'])",
            "            except exception.TrustNotFound:",
            "                raise exception.Forbidden()",
            "            if user_id != trust_ref['trustee_user_id']:",
            "                raise exception.Forbidden()",
            "            if (trust_ref['project_id'] and",
            "                    tenant_id != trust_ref['project_id']):",
            "                raise exception.Forbidden()",
            "            if ('expires' in trust_ref) and (trust_ref['expires']):",
            "                expiry = trust_ref['expires']",
            "                if expiry < timeutils.parse_isotime(utils.isotime()):",
            "                    raise exception.Forbidden()",
            "            user_id = trust_ref['trustor_user_id']",
            "            trustor_user_ref = self.identity_api.get_user(",
            "                trust_ref['trustor_user_id'])",
            "            if not trustor_user_ref['enabled']:",
            "                raise exception.Forbidden()",
            "            trustee_user_ref = self.identity_api.get_user(",
            "                trust_ref['trustee_user_id'])",
            "            if not trustee_user_ref['enabled']:",
            "                raise exception.Forbidden()",
            "",
            "            if trust_ref['impersonation'] is True:",
            "                current_user_ref = trustor_user_ref",
            "            else:",
            "                current_user_ref = trustee_user_ref",
            "",
            "        else:",
            "            current_user_ref = self.identity_api.get_user(user_id)",
            "",
            "        metadata_ref = {}",
            "        tenant_ref, metadata_ref['roles'] = self._get_project_roles_and_ref(",
            "            user_id, tenant_id)",
            "",
            "        expiry = token_model_ref.expires",
            "        if CONF.trust.enabled and 'trust_id' in auth:",
            "            trust_id = auth['trust_id']",
            "            trust_roles = []",
            "            for role in trust_ref['roles']:",
            "                if 'roles' not in metadata_ref:",
            "                    raise exception.Forbidden()",
            "                if role['id'] in metadata_ref['roles']:",
            "                    trust_roles.append(role['id'])",
            "                else:",
            "                    raise exception.Forbidden()",
            "            if 'expiry' in trust_ref and trust_ref['expiry']:",
            "                trust_expiry = timeutils.parse_isotime(trust_ref['expiry'])",
            "                if trust_expiry < expiry:",
            "                    expiry = trust_expiry",
            "            metadata_ref['roles'] = trust_roles",
            "            metadata_ref['trustee_user_id'] = trust_ref['trustee_user_id']",
            "            metadata_ref['trust_id'] = trust_id",
            "",
            "        bind = token_model_ref.bind",
            "        audit_id = token_model_ref.audit_chain_id",
            "",
            "        return (current_user_ref, tenant_ref, metadata_ref, expiry, bind,",
            "                audit_id)",
            "",
            "    def _authenticate_local(self, context, auth):",
            "        \"\"\"Try to authenticate against the identity backend.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'passwordCredentials' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='passwordCredentials', target='auth')",
            "",
            "        if \"password\" not in auth['passwordCredentials']:",
            "            raise exception.ValidationError(",
            "                attribute='password', target='passwordCredentials')",
            "",
            "        password = auth['passwordCredentials']['password']",
            "        if password and len(password) > CONF.identity.max_password_length:",
            "            raise exception.ValidationSizeError(",
            "                attribute='password', size=CONF.identity.max_password_length)",
            "",
            "        if (not auth['passwordCredentials'].get(\"userId\") and",
            "                not auth['passwordCredentials'].get(\"username\")):",
            "            raise exception.ValidationError(",
            "                attribute='username or userId',",
            "                target='passwordCredentials')",
            "",
            "        user_id = auth['passwordCredentials'].get('userId')",
            "        if user_id and len(user_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='userId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        username = auth['passwordCredentials'].get('username', '')",
            "",
            "        if username:",
            "            if len(username) > CONF.max_param_size:",
            "                raise exception.ValidationSizeError(attribute='username',",
            "                                                    size=CONF.max_param_size)",
            "            try:",
            "                user_ref = self.identity_api.get_user_by_name(",
            "                    username, CONF.identity.default_domain_id)",
            "                user_id = user_ref['id']",
            "            except exception.UserNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "",
            "        try:",
            "            user_ref = self.identity_api.authenticate(",
            "                context,",
            "                user_id=user_id,",
            "                password=password)",
            "        except AssertionError as e:",
            "            raise exception.Unauthorized(e.args[0])",
            "",
            "        metadata_ref = {}",
            "        tenant_id = self._get_project_id_from_auth(auth)",
            "        tenant_ref, metadata_ref['roles'] = self._get_project_roles_and_ref(",
            "            user_id, tenant_id)",
            "",
            "        expiry = provider.default_expire_time()",
            "        bind = None",
            "        audit_id = None",
            "        return (user_ref, tenant_ref, metadata_ref, expiry, bind, audit_id)",
            "",
            "    def _authenticate_external(self, context, auth):",
            "        \"\"\"Try to authenticate an external user via REMOTE_USER variable.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        environment = context.get('environment', {})",
            "        if not environment.get('REMOTE_USER'):",
            "            raise ExternalAuthNotApplicable()",
            "",
            "        username = environment['REMOTE_USER']",
            "        try:",
            "            user_ref = self.identity_api.get_user_by_name(",
            "                username, CONF.identity.default_domain_id)",
            "            user_id = user_ref['id']",
            "        except exception.UserNotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        metadata_ref = {}",
            "        tenant_id = self._get_project_id_from_auth(auth)",
            "        tenant_ref, metadata_ref['roles'] = self._get_project_roles_and_ref(",
            "            user_id, tenant_id)",
            "",
            "        expiry = provider.default_expire_time()",
            "        bind = None",
            "        if ('kerberos' in CONF.token.bind and",
            "                environment.get('AUTH_TYPE', '').lower() == 'negotiate'):",
            "            bind = {'kerberos': username}",
            "        audit_id = None",
            "",
            "        return (user_ref, tenant_ref, metadata_ref, expiry, bind, audit_id)",
            "",
            "    def _get_auth_token_data(self, user, tenant, metadata, expiry, audit_id):",
            "        return dict(user=user,",
            "                    tenant=tenant,",
            "                    metadata=metadata,",
            "                    expires=expiry,",
            "                    parent_audit_id=audit_id)",
            "",
            "    def _get_project_id_from_auth(self, auth):",
            "        \"\"\"Extract tenant information from auth dict.",
            "",
            "        Returns a valid tenant_id if it exists, or None if not specified.",
            "        \"\"\"",
            "        tenant_id = auth.get('tenantId')",
            "        if tenant_id and len(tenant_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        tenant_name = auth.get('tenantName')",
            "        if tenant_name and len(tenant_name) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantName',",
            "                                                size=CONF.max_param_size)",
            "",
            "        if tenant_name:",
            "            if (CONF.resource.project_name_url_safe == 'strict' and",
            "                    utils.is_not_url_safe(tenant_name)):",
            "                msg = _('Tenant name cannot contain reserved characters.')",
            "                raise exception.Unauthorized(message=msg)",
            "            try:",
            "                tenant_ref = self.resource_api.get_project_by_name(",
            "                    tenant_name, CONF.identity.default_domain_id)",
            "                tenant_id = tenant_ref['id']",
            "            except exception.ProjectNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "        return tenant_id",
            "",
            "    def _get_project_roles_and_ref(self, user_id, tenant_id):",
            "        \"\"\"Return the project roles for this user, and the project ref.\"\"\"",
            "        tenant_ref = None",
            "        role_list = []",
            "        if tenant_id:",
            "            try:",
            "                tenant_ref = self.resource_api.get_project(tenant_id)",
            "                role_list = self.assignment_api.get_roles_for_user_and_project(",
            "                    user_id, tenant_id)",
            "            except exception.ProjectNotFound:",
            "                msg = _('Project ID not found: %(t_id)s') % {'t_id': tenant_id}",
            "                raise exception.Unauthorized(msg)",
            "",
            "            if not role_list:",
            "                msg = _('User %(u_id)s is unauthorized for tenant %(t_id)s')",
            "                msg = msg % {'u_id': user_id, 't_id': tenant_id}",
            "                LOG.warning(msg)",
            "                raise exception.Unauthorized(msg)",
            "",
            "        return (tenant_ref, role_list)",
            "",
            "    def _get_token_ref(self, token_id, belongs_to=None):",
            "        \"\"\"Return a token if a valid one exists.",
            "",
            "        Optionally, limited to a token owned by a specific tenant.",
            "",
            "        \"\"\"",
            "        token_ref = token_model.KeystoneToken(",
            "            token_id=token_id,",
            "            token_data=self.token_provider_api.validate_token(token_id))",
            "        if belongs_to:",
            "            if not token_ref.project_scoped:",
            "                raise exception.Unauthorized(",
            "                    _('Token does not belong to specified tenant.'))",
            "            if token_ref.project_id != belongs_to:",
            "                raise exception.Unauthorized(",
            "                    _('Token does not belong to specified tenant.'))",
            "        return token_ref",
            "",
            "    @controller.v2_deprecated",
            "    @controller.protected()",
            "    def validate_token_head(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Identical to ``validate_token``, except does not return a response.",
            "",
            "        The code in ``keystone.common.wsgi.render_response`` will remove",
            "        the content body.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        return self.token_provider_api.validate_v2_token(token_id, belongs_to)",
            "",
            "    @controller.v2_deprecated",
            "    @controller.protected()",
            "    def validate_token(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Returns metadata about the token along any associated roles.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        # TODO(ayoung) validate against revocation API",
            "        return self.token_provider_api.validate_v2_token(token_id, belongs_to)",
            "",
            "    @controller.v2_deprecated",
            "    def delete_token(self, context, token_id):",
            "        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "        self.token_provider_api.revoke_token(token_id)",
            "",
            "    @controller.v2_deprecated",
            "    @controller.protected()",
            "    def revocation_list(self, context, auth=None):",
            "        if not CONF.token.revoke_by_id:",
            "            raise exception.Gone()",
            "        tokens = self.token_provider_api.list_revoked_tokens()",
            "",
            "        for t in tokens:",
            "            expires = t['expires']",
            "            if expires and isinstance(expires, datetime.datetime):",
            "                t['expires'] = utils.isotime(expires)",
            "        data = {'revoked': tokens}",
            "        json_data = jsonutils.dumps(data)",
            "        signed_text = cms.cms_sign_text(json_data,",
            "                                        CONF.signing.certfile,",
            "                                        CONF.signing.keyfile)",
            "",
            "        return {'signed': signed_text}",
            "",
            "    @controller.v2_deprecated",
            "    def endpoints(self, context, token_id):",
            "        \"\"\"Return a list of endpoints available to the token.\"\"\"",
            "        self.assert_admin(context)",
            "",
            "        token_ref = self._get_token_ref(token_id)",
            "",
            "        catalog_ref = None",
            "        if token_ref.project_id:",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                token_ref.user_id,",
            "                token_ref.project_id)",
            "",
            "        return Auth.format_endpoint_list(catalog_ref)",
            "",
            "    @classmethod",
            "    def format_endpoint_list(cls, catalog_ref):",
            "        \"\"\"Format a list of endpoints according to Identity API v2.",
            "",
            "        The v2.0 API wants an endpoint list to look like::",
            "",
            "            {",
            "                'endpoints': [",
            "                    {",
            "                        'id': $endpoint_id,",
            "                        'name': $SERVICE[name],",
            "                        'type': $SERVICE,",
            "                        'tenantId': $tenant_id,",
            "                        'region': $REGION,",
            "                    }",
            "                ],",
            "                'endpoints_links': [],",
            "            }",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return {}",
            "",
            "        endpoints = []",
            "        for region_name, region_ref in catalog_ref.items():",
            "            for service_type, service_ref in region_ref.items():",
            "                endpoints.append({",
            "                    'id': service_ref.get('id'),",
            "                    'name': service_ref.get('name'),",
            "                    'type': service_type,",
            "                    'region': region_name,",
            "                    'publicURL': service_ref.get('publicURL'),",
            "                    'internalURL': service_ref.get('internalURL'),",
            "                    'adminURL': service_ref.get('adminURL'),",
            "                })",
            "",
            "        return {'endpoints': endpoints, 'endpoints_links': []}"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import datetime",
            "import sys",
            "",
            "from keystone.common import utils",
            "from keystoneclient.common import cms",
            "from oslo_config import cfg",
            "from oslo_log import log",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import timeutils",
            "import six",
            "",
            "from keystone.common import controller",
            "from keystone.common import dependency",
            "from keystone.common import wsgi",
            "from keystone import exception",
            "from keystone.i18n import _",
            "from keystone.models import token_model",
            "from keystone.token import provider",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "class ExternalAuthNotApplicable(Exception):",
            "    \"\"\"External authentication is not applicable.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "@dependency.requires('assignment_api', 'catalog_api', 'identity_api',",
            "                     'resource_api', 'role_api', 'token_provider_api',",
            "                     'trust_api')",
            "class Auth(controller.V2Controller):",
            "",
            "    @controller.v2_deprecated",
            "    def ca_cert(self, context, auth=None):",
            "        with open(CONF.signing.ca_certs, 'r') as ca_file:",
            "            data = ca_file.read()",
            "        return data",
            "",
            "    @controller.v2_deprecated",
            "    def signing_cert(self, context, auth=None):",
            "        with open(CONF.signing.certfile, 'r') as cert_file:",
            "            data = cert_file.read()",
            "        return data",
            "",
            "    @controller.v2_auth_deprecated",
            "    def authenticate(self, context, auth=None):",
            "        \"\"\"Authenticate credentials and return a token.",
            "",
            "        Accept auth as a dict that looks like::",
            "",
            "            {",
            "                \"auth\":{",
            "                    \"passwordCredentials\":{",
            "                        \"username\":\"test_user\",",
            "                        \"password\":\"mypass\"",
            "                    },",
            "                    \"tenantName\":\"customer-x\"",
            "                }",
            "            }",
            "",
            "        In this case, tenant is optional, if not provided the token will be",
            "        considered \"unscoped\" and can later be used to get a scoped token.",
            "",
            "        Alternatively, this call accepts auth with only a token and tenant",
            "        that will return a token that is scoped to that tenant.",
            "        \"\"\"",
            "        if auth is None:",
            "            raise exception.ValidationError(attribute='auth',",
            "                                            target='request body')",
            "",
            "        if \"token\" in auth:",
            "            # Try to authenticate using a token",
            "            auth_info = self._authenticate_token(",
            "                context, auth)",
            "        else:",
            "            # Try external authentication",
            "            try:",
            "                auth_info = self._authenticate_external(",
            "                    context, auth)",
            "            except ExternalAuthNotApplicable:",
            "                # Try local authentication",
            "                auth_info = self._authenticate_local(",
            "                    context, auth)",
            "",
            "        user_ref, tenant_ref, metadata_ref, expiry, bind, audit_id = auth_info",
            "        # Validate that the auth info is valid and nothing is disabled",
            "        try:",
            "            self.identity_api.assert_user_enabled(",
            "                user_id=user_ref['id'], user=user_ref)",
            "            if tenant_ref:",
            "                self.resource_api.assert_project_enabled(",
            "                    project_id=tenant_ref['id'], project=tenant_ref)",
            "        except AssertionError as e:",
            "            six.reraise(exception.Unauthorized, exception.Unauthorized(e),",
            "                        sys.exc_info()[2])",
            "        # NOTE(morganfainberg): Make sure the data is in correct form since it",
            "        # might be consumed external to Keystone and this is a v2.0 controller.",
            "        # The user_ref is encoded into the auth_token_data which is returned as",
            "        # part of the token data. The token provider doesn't care about the",
            "        # format.",
            "        user_ref = self.v3_to_v2_user(user_ref)",
            "        if tenant_ref:",
            "            tenant_ref = self.v3_to_v2_project(tenant_ref)",
            "",
            "        auth_token_data = self._get_auth_token_data(user_ref,",
            "                                                    tenant_ref,",
            "                                                    metadata_ref,",
            "                                                    expiry,",
            "                                                    audit_id)",
            "",
            "        if tenant_ref:",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                user_ref['id'], tenant_ref['id'])",
            "        else:",
            "            catalog_ref = {}",
            "",
            "        auth_token_data['id'] = 'placeholder'",
            "        if bind:",
            "            auth_token_data['bind'] = bind",
            "",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            role_ref = self.role_api.get_role(role_id)",
            "            roles_ref.append(dict(name=role_ref['name']))",
            "",
            "        (token_id, token_data) = self.token_provider_api.issue_v2_token(",
            "            auth_token_data, roles_ref=roles_ref, catalog_ref=catalog_ref)",
            "",
            "        # NOTE(wanghong): We consume a trust use only when we are using trusts",
            "        # and have successfully issued a token.",
            "        if CONF.trust.enabled and 'trust_id' in auth:",
            "            self.trust_api.consume_use(auth['trust_id'])",
            "",
            "        return token_data",
            "",
            "    def _restrict_scope(self, token_model_ref):",
            "        # A trust token cannot be used to get another token",
            "        if token_model_ref.trust_scoped:",
            "            raise exception.Forbidden()",
            "        if not CONF.token.allow_rescope_scoped_token:",
            "            # Do not allow conversion from scoped tokens.",
            "            if token_model_ref.project_scoped or token_model_ref.domain_scoped:",
            "                raise exception.Forbidden(action=_(\"rescope a scoped token\"))",
            "",
            "    def _authenticate_token(self, context, auth):",
            "        \"\"\"Try to authenticate using an already existing token.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'token' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='token', target='auth')",
            "",
            "        if \"id\" not in auth['token']:",
            "            raise exception.ValidationError(",
            "                attribute=\"id\", target=\"token\")",
            "",
            "        old_token = auth['token']['id']",
            "        if len(old_token) > CONF.max_token_size:",
            "            raise exception.ValidationSizeError(attribute='token',",
            "                                                size=CONF.max_token_size)",
            "",
            "        try:",
            "            token_model_ref = token_model.KeystoneToken(",
            "                token_id=old_token,",
            "                token_data=self.token_provider_api.validate_v2_token(old_token)",
            "            )",
            "        except exception.NotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        wsgi.validate_token_bind(context, token_model_ref)",
            "",
            "        self._restrict_scope(token_model_ref)",
            "        user_id = token_model_ref.user_id",
            "        tenant_id = self._get_project_id_from_auth(auth)",
            "",
            "        if not CONF.trust.enabled and 'trust_id' in auth:",
            "            raise exception.Forbidden('Trusts are disabled.')",
            "        elif CONF.trust.enabled and 'trust_id' in auth:",
            "            try:",
            "                trust_ref = self.trust_api.get_trust(auth['trust_id'])",
            "            except exception.TrustNotFound:",
            "                raise exception.Forbidden()",
            "            if user_id != trust_ref['trustee_user_id']:",
            "                raise exception.Forbidden()",
            "            if (trust_ref['project_id'] and",
            "                    tenant_id != trust_ref['project_id']):",
            "                raise exception.Forbidden()",
            "            if ('expires' in trust_ref) and (trust_ref['expires']):",
            "                expiry = trust_ref['expires']",
            "                if expiry < timeutils.parse_isotime(utils.isotime()):",
            "                    raise exception.Forbidden()",
            "            user_id = trust_ref['trustor_user_id']",
            "            trustor_user_ref = self.identity_api.get_user(",
            "                trust_ref['trustor_user_id'])",
            "            if not trustor_user_ref['enabled']:",
            "                raise exception.Forbidden()",
            "            trustee_user_ref = self.identity_api.get_user(",
            "                trust_ref['trustee_user_id'])",
            "            if not trustee_user_ref['enabled']:",
            "                raise exception.Forbidden()",
            "",
            "            if trust_ref['impersonation'] is True:",
            "                current_user_ref = trustor_user_ref",
            "            else:",
            "                current_user_ref = trustee_user_ref",
            "",
            "        else:",
            "            current_user_ref = self.identity_api.get_user(user_id)",
            "",
            "        metadata_ref = {}",
            "        tenant_ref, metadata_ref['roles'] = self._get_project_roles_and_ref(",
            "            user_id, tenant_id)",
            "",
            "        expiry = token_model_ref.expires",
            "        if CONF.trust.enabled and 'trust_id' in auth:",
            "            trust_id = auth['trust_id']",
            "            trust_roles = []",
            "            for role in trust_ref['roles']:",
            "                if 'roles' not in metadata_ref:",
            "                    raise exception.Forbidden()",
            "                if role['id'] in metadata_ref['roles']:",
            "                    trust_roles.append(role['id'])",
            "                else:",
            "                    raise exception.Forbidden()",
            "            if 'expiry' in trust_ref and trust_ref['expiry']:",
            "                trust_expiry = timeutils.parse_isotime(trust_ref['expiry'])",
            "                if trust_expiry < expiry:",
            "                    expiry = trust_expiry",
            "            metadata_ref['roles'] = trust_roles",
            "            metadata_ref['trustee_user_id'] = trust_ref['trustee_user_id']",
            "            metadata_ref['trust_id'] = trust_id",
            "",
            "        bind = token_model_ref.bind",
            "        audit_id = token_model_ref.audit_chain_id",
            "",
            "        return (current_user_ref, tenant_ref, metadata_ref, expiry, bind,",
            "                audit_id)",
            "",
            "    def _authenticate_local(self, context, auth):",
            "        \"\"\"Try to authenticate against the identity backend.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        if 'passwordCredentials' not in auth:",
            "            raise exception.ValidationError(",
            "                attribute='passwordCredentials', target='auth')",
            "",
            "        if \"password\" not in auth['passwordCredentials']:",
            "            raise exception.ValidationError(",
            "                attribute='password', target='passwordCredentials')",
            "",
            "        password = auth['passwordCredentials']['password']",
            "        if password and len(password) > CONF.identity.max_password_length:",
            "            raise exception.ValidationSizeError(",
            "                attribute='password', size=CONF.identity.max_password_length)",
            "",
            "        if (not auth['passwordCredentials'].get(\"userId\") and",
            "                not auth['passwordCredentials'].get(\"username\")):",
            "            raise exception.ValidationError(",
            "                attribute='username or userId',",
            "                target='passwordCredentials')",
            "",
            "        user_id = auth['passwordCredentials'].get('userId')",
            "        if user_id and len(user_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='userId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        username = auth['passwordCredentials'].get('username', '')",
            "",
            "        if username:",
            "            if len(username) > CONF.max_param_size:",
            "                raise exception.ValidationSizeError(attribute='username',",
            "                                                    size=CONF.max_param_size)",
            "            try:",
            "                user_ref = self.identity_api.get_user_by_name(",
            "                    username, CONF.identity.default_domain_id)",
            "                user_id = user_ref['id']",
            "            except exception.UserNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "",
            "        try:",
            "            user_ref = self.identity_api.authenticate(",
            "                context,",
            "                user_id=user_id,",
            "                password=password)",
            "        except AssertionError as e:",
            "            raise exception.Unauthorized(e.args[0])",
            "",
            "        metadata_ref = {}",
            "        tenant_id = self._get_project_id_from_auth(auth)",
            "        tenant_ref, metadata_ref['roles'] = self._get_project_roles_and_ref(",
            "            user_id, tenant_id)",
            "",
            "        expiry = provider.default_expire_time()",
            "        bind = None",
            "        audit_id = None",
            "        return (user_ref, tenant_ref, metadata_ref, expiry, bind, audit_id)",
            "",
            "    def _authenticate_external(self, context, auth):",
            "        \"\"\"Try to authenticate an external user via REMOTE_USER variable.",
            "",
            "        Returns auth_token_data, (user_ref, tenant_ref, metadata_ref)",
            "        \"\"\"",
            "        environment = context.get('environment', {})",
            "        if not environment.get('REMOTE_USER'):",
            "            raise ExternalAuthNotApplicable()",
            "",
            "        username = environment['REMOTE_USER']",
            "        try:",
            "            user_ref = self.identity_api.get_user_by_name(",
            "                username, CONF.identity.default_domain_id)",
            "            user_id = user_ref['id']",
            "        except exception.UserNotFound as e:",
            "            raise exception.Unauthorized(e)",
            "",
            "        metadata_ref = {}",
            "        tenant_id = self._get_project_id_from_auth(auth)",
            "        tenant_ref, metadata_ref['roles'] = self._get_project_roles_and_ref(",
            "            user_id, tenant_id)",
            "",
            "        expiry = provider.default_expire_time()",
            "        bind = None",
            "        if ('kerberos' in CONF.token.bind and",
            "                environment.get('AUTH_TYPE', '').lower() == 'negotiate'):",
            "            bind = {'kerberos': username}",
            "        audit_id = None",
            "",
            "        return (user_ref, tenant_ref, metadata_ref, expiry, bind, audit_id)",
            "",
            "    def _get_auth_token_data(self, user, tenant, metadata, expiry, audit_id):",
            "        return dict(user=user,",
            "                    tenant=tenant,",
            "                    metadata=metadata,",
            "                    expires=expiry,",
            "                    parent_audit_id=audit_id)",
            "",
            "    def _get_project_id_from_auth(self, auth):",
            "        \"\"\"Extract tenant information from auth dict.",
            "",
            "        Returns a valid tenant_id if it exists, or None if not specified.",
            "        \"\"\"",
            "        tenant_id = auth.get('tenantId')",
            "        if tenant_id and len(tenant_id) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantId',",
            "                                                size=CONF.max_param_size)",
            "",
            "        tenant_name = auth.get('tenantName')",
            "        if tenant_name and len(tenant_name) > CONF.max_param_size:",
            "            raise exception.ValidationSizeError(attribute='tenantName',",
            "                                                size=CONF.max_param_size)",
            "",
            "        if tenant_name:",
            "            if (CONF.resource.project_name_url_safe == 'strict' and",
            "                    utils.is_not_url_safe(tenant_name)):",
            "                msg = _('Tenant name cannot contain reserved characters.')",
            "                raise exception.Unauthorized(message=msg)",
            "            try:",
            "                tenant_ref = self.resource_api.get_project_by_name(",
            "                    tenant_name, CONF.identity.default_domain_id)",
            "                tenant_id = tenant_ref['id']",
            "            except exception.ProjectNotFound as e:",
            "                raise exception.Unauthorized(e)",
            "        return tenant_id",
            "",
            "    def _get_project_roles_and_ref(self, user_id, tenant_id):",
            "        \"\"\"Return the project roles for this user, and the project ref.\"\"\"",
            "        tenant_ref = None",
            "        role_list = []",
            "        if tenant_id:",
            "            try:",
            "                tenant_ref = self.resource_api.get_project(tenant_id)",
            "                role_list = self.assignment_api.get_roles_for_user_and_project(",
            "                    user_id, tenant_id)",
            "            except exception.ProjectNotFound:",
            "                msg = _('Project ID not found: %(t_id)s') % {'t_id': tenant_id}",
            "                raise exception.Unauthorized(msg)",
            "",
            "            if not role_list:",
            "                msg = _('User %(u_id)s is unauthorized for tenant %(t_id)s')",
            "                msg = msg % {'u_id': user_id, 't_id': tenant_id}",
            "                LOG.warning(msg)",
            "                raise exception.Unauthorized(msg)",
            "",
            "        return (tenant_ref, role_list)",
            "",
            "    def _get_token_ref(self, token_id, belongs_to=None):",
            "        \"\"\"Return a token if a valid one exists.",
            "",
            "        Optionally, limited to a token owned by a specific tenant.",
            "",
            "        \"\"\"",
            "        token_ref = token_model.KeystoneToken(",
            "            token_id=token_id,",
            "            token_data=self.token_provider_api.validate_token(token_id))",
            "        if belongs_to:",
            "            if not token_ref.project_scoped:",
            "                raise exception.Unauthorized(",
            "                    _('Token does not belong to specified tenant.'))",
            "            if token_ref.project_id != belongs_to:",
            "                raise exception.Unauthorized(",
            "                    _('Token does not belong to specified tenant.'))",
            "        return token_ref",
            "",
            "    @controller.v2_deprecated",
            "    @controller.protected()",
            "    def validate_token_head(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Identical to ``validate_token``, except does not return a response.",
            "",
            "        The code in ``keystone.common.wsgi.render_response`` will remove",
            "        the content body.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        return self.token_provider_api.validate_v2_token(token_id, belongs_to)",
            "",
            "    @controller.v2_deprecated",
            "    @controller.protected()",
            "    def validate_token(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Returns metadata about the token along any associated roles.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get('belongsTo')",
            "        # TODO(ayoung) validate against revocation API",
            "        return self.token_provider_api.validate_v2_token(token_id, belongs_to)",
            "",
            "    @controller.v2_deprecated",
            "    def delete_token(self, context, token_id):",
            "        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "        self.token_provider_api.revoke_token(token_id)",
            "",
            "    @controller.v2_deprecated",
            "    @controller.protected()",
            "    def revocation_list(self, context, auth=None):",
            "        if not CONF.token.revoke_by_id:",
            "            raise exception.Gone()",
            "        tokens = self.token_provider_api.list_revoked_tokens()",
            "",
            "        for t in tokens:",
            "            expires = t['expires']",
            "            if expires and isinstance(expires, datetime.datetime):",
            "                t['expires'] = utils.isotime(expires)",
            "        data = {'revoked': tokens}",
            "        json_data = jsonutils.dumps(data)",
            "        signed_text = cms.cms_sign_text(json_data,",
            "                                        CONF.signing.certfile,",
            "                                        CONF.signing.keyfile)",
            "",
            "        return {'signed': signed_text}",
            "",
            "    @controller.v2_deprecated",
            "    def endpoints(self, context, token_id):",
            "        \"\"\"Return a list of endpoints available to the token.\"\"\"",
            "        self.assert_admin(context)",
            "",
            "        token_ref = self._get_token_ref(token_id)",
            "",
            "        catalog_ref = None",
            "        if token_ref.project_id:",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                token_ref.user_id,",
            "                token_ref.project_id)",
            "",
            "        return Auth.format_endpoint_list(catalog_ref)",
            "",
            "    @classmethod",
            "    def format_endpoint_list(cls, catalog_ref):",
            "        \"\"\"Format a list of endpoints according to Identity API v2.",
            "",
            "        The v2.0 API wants an endpoint list to look like::",
            "",
            "            {",
            "                'endpoints': [",
            "                    {",
            "                        'id': $endpoint_id,",
            "                        'name': $SERVICE[name],",
            "                        'type': $SERVICE,",
            "                        'tenantId': $tenant_id,",
            "                        'region': $REGION,",
            "                    }",
            "                ],",
            "                'endpoints_links': [],",
            "            }",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return {}",
            "",
            "        endpoints = []",
            "        for region_name, region_ref in catalog_ref.items():",
            "            for service_type, service_ref in region_ref.items():",
            "                endpoints.append({",
            "                    'id': service_ref.get('id'),",
            "                    'name': service_ref.get('name'),",
            "                    'type': service_type,",
            "                    'region': region_name,",
            "                    'publicURL': service_ref.get('publicURL'),",
            "                    'internalURL': service_ref.get('internalURL'),",
            "                    'adminURL': service_ref.get('adminURL'),",
            "                })",
            "",
            "        return {'endpoints': endpoints, 'endpoints_links': []}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "183": [
                "Auth",
                "_authenticate_token"
            ]
        },
        "addLocation": []
    },
    "keystone/token/providers/fernet/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from keystone.common import dependency"
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from keystone.common import utils as ks_utils"
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from keystone.federation import constants as federation_constants"
            },
            "3": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from keystone.token import provider"
            },
            "4": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from keystone.token.providers import common"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from keystone.token.providers.fernet import token_formatters as tf"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         expires_at = token_data['access']['token']['expires']"
            },
            "8": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         audit_ids = token_data['access']['token'].get('audit_ids')"
            },
            "9": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         methods = ['password']"
            },
            "10": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if audit_ids:"
            },
            "11": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            parent_audit_id = token_data['access']['token'].get("
            },
            "12": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'parent_audit_id')"
            },
            "13": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            audit_ids = provider.audit_info(parent_audit_id)"
            },
            "14": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if parent_audit_id:"
            },
            "15": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                methods.append('token')"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        if len(audit_ids) > 1:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            methods.append('token')"
            },
            "18": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         project_id = token_data['access']['token'].get('tenant', {}).get('id')"
            },
            "19": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         domain_id = None"
            },
            "20": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         trust_id = None"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from oslo_config import cfg",
            "",
            "from keystone.common import dependency",
            "from keystone.common import utils as ks_utils",
            "from keystone.federation import constants as federation_constants",
            "from keystone.token import provider",
            "from keystone.token.providers import common",
            "from keystone.token.providers.fernet import token_formatters as tf",
            "",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "@dependency.requires('trust_api', 'oauth_api')",
            "class Provider(common.BaseProvider):",
            "    def __init__(self, *args, **kwargs):",
            "        super(Provider, self).__init__(*args, **kwargs)",
            "",
            "        self.token_formatter = tf.TokenFormatter()",
            "",
            "    def needs_persistence(self):",
            "        \"\"\"Should the token be written to a backend.\"\"\"",
            "        return False",
            "",
            "    def issue_v2_token(self, *args, **kwargs):",
            "        token_id, token_data = super(Provider, self).issue_v2_token(",
            "            *args, **kwargs)",
            "        self._build_issued_at_info(token_id, token_data)",
            "        return token_id, token_data",
            "",
            "    def issue_v3_token(self, *args, **kwargs):",
            "        token_id, token_data = super(Provider, self).issue_v3_token(",
            "            *args, **kwargs)",
            "        self._build_issued_at_info(token_id, token_data)",
            "        return token_id, token_data",
            "",
            "    def _build_issued_at_info(self, token_id, token_data):",
            "        # NOTE(roxanaghe, lbragstad): We must use the creation time that",
            "        # Fernet builds into it's token. The Fernet spec details that the",
            "        # token creation time is built into the token, outside of the payload",
            "        # provided by Keystone. This is the reason why we don't pass the",
            "        # issued_at time in the payload. This also means that we shouldn't",
            "        # return a token reference with a creation time that we created",
            "        # when Fernet uses a different creation time. We should use the",
            "        # creation time provided by Fernet because it's the creation time",
            "        # that we have to rely on when we validate the token.",
            "        fernet_creation_datetime_obj = self.token_formatter.creation_time(",
            "            token_id)",
            "        if token_data.get('access'):",
            "            token_data['access']['token']['issued_at'] = ks_utils.isotime(",
            "                at=fernet_creation_datetime_obj, subsecond=True)",
            "        else:",
            "            token_data['token']['issued_at'] = ks_utils.isotime(",
            "                at=fernet_creation_datetime_obj, subsecond=True)",
            "",
            "    def _build_federated_info(self, token_data):",
            "        \"\"\"Extract everything needed for federated tokens.",
            "",
            "        This dictionary is passed to federated token formatters, which unpack",
            "        the values and build federated Fernet tokens.",
            "",
            "        \"\"\"",
            "        token_data = token_data['token']",
            "        try:",
            "            user = token_data['user']",
            "            federation = user[federation_constants.FEDERATION]",
            "            idp_id = federation['identity_provider']['id']",
            "            protocol_id = federation['protocol']['id']",
            "        except KeyError:",
            "            # The token data doesn't have federated info, so we aren't dealing",
            "            # with a federated token and no federated info to build.",
            "            return",
            "",
            "        group_ids = federation.get('groups')",
            "",
            "        return {'group_ids': group_ids,",
            "                'idp_id': idp_id,",
            "                'protocol_id': protocol_id}",
            "",
            "    def _rebuild_federated_info(self, federated_dict, user_id):",
            "        \"\"\"Format federated information into the token reference.",
            "",
            "        The federated_dict is passed back from the federated token formatters.",
            "        The responsibility of this method is to format the information passed",
            "        back from the token formatter into the token reference before",
            "        constructing the token data from the V3TokenDataHelper.",
            "",
            "        \"\"\"",
            "        g_ids = federated_dict['group_ids']",
            "        idp_id = federated_dict['idp_id']",
            "        protocol_id = federated_dict['protocol_id']",
            "",
            "        federated_info = {",
            "            'groups': g_ids,",
            "            'identity_provider': {'id': idp_id},",
            "            'protocol': {'id': protocol_id}",
            "        }",
            "",
            "        token_dict = {",
            "            'user': {",
            "                federation_constants.FEDERATION: federated_info,",
            "                'id': user_id,",
            "                'name': user_id,",
            "                'domain': {'id': CONF.federation.federated_domain_name,",
            "                           'name': CONF.federation.federated_domain_name, },",
            "            }",
            "        }",
            "",
            "        return token_dict",
            "",
            "    def _rebuild_federated_token_roles(self, token_dict, federated_dict,",
            "                                       user_id, project_id, domain_id):",
            "        \"\"\"Populate roles based on (groups, project/domain) pair.",
            "",
            "        We must populate roles from (groups, project/domain) as ephemeral users",
            "        don't exist in the backend. Upon success, a ``roles`` key will be added",
            "        to ``token_dict``.",
            "",
            "        :param token_dict: dictionary with data used for building token",
            "        :param federated_dict: federated information such as identity provider",
            "            protocol and set of group IDs",
            "        :param user_id: user ID",
            "        :param project_id: project ID the token is being scoped to",
            "        :param domain_id: domain ID the token is being scoped to",
            "",
            "        \"\"\"",
            "        group_ids = [x['id'] for x in federated_dict['group_ids']]",
            "        self.v3_token_data_helper.populate_roles_for_groups(",
            "            token_dict, group_ids, project_id, domain_id, user_id)",
            "",
            "    def _extract_v2_token_data(self, token_data):",
            "        user_id = token_data['access']['user']['id']",
            "        expires_at = token_data['access']['token']['expires']",
            "        audit_ids = token_data['access']['token'].get('audit_ids')",
            "        methods = ['password']",
            "        if audit_ids:",
            "            parent_audit_id = token_data['access']['token'].get(",
            "                'parent_audit_id')",
            "            audit_ids = provider.audit_info(parent_audit_id)",
            "            if parent_audit_id:",
            "                methods.append('token')",
            "        project_id = token_data['access']['token'].get('tenant', {}).get('id')",
            "        domain_id = None",
            "        trust_id = None",
            "        access_token_id = None",
            "        federated_info = None",
            "        return (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info)",
            "",
            "    def _extract_v3_token_data(self, token_data):",
            "        \"\"\"Extract information from a v3 token reference.\"\"\"",
            "        user_id = token_data['token']['user']['id']",
            "        expires_at = token_data['token']['expires_at']",
            "        audit_ids = token_data['token']['audit_ids']",
            "        methods = token_data['token'].get('methods')",
            "        domain_id = token_data['token'].get('domain', {}).get('id')",
            "        project_id = token_data['token'].get('project', {}).get('id')",
            "        trust_id = token_data['token'].get('OS-TRUST:trust', {}).get('id')",
            "        access_token_id = token_data['token'].get('OS-OAUTH1', {}).get(",
            "            'access_token_id')",
            "        federated_info = self._build_federated_info(token_data)",
            "",
            "        return (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info)",
            "",
            "    def _get_token_id(self, token_data):",
            "        \"\"\"Generate the token_id based upon the data in token_data.",
            "",
            "        :param token_data: token information",
            "        :type token_data: dict",
            "        :rtype: six.text_type",
            "",
            "        \"\"\"",
            "        # NOTE(lbragstad): Only v2.0 token responses include an 'access'",
            "        # attribute.",
            "        if token_data.get('access'):",
            "            (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info) = (",
            "                    self._extract_v2_token_data(token_data))",
            "        else:",
            "            (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info) = (",
            "                    self._extract_v3_token_data(token_data))",
            "",
            "        return self.token_formatter.create_token(",
            "            user_id,",
            "            expires_at,",
            "            audit_ids,",
            "            methods=methods,",
            "            domain_id=domain_id,",
            "            project_id=project_id,",
            "            trust_id=trust_id,",
            "            federated_info=federated_info,",
            "            access_token_id=access_token_id",
            "        )",
            "",
            "    @property",
            "    def _supports_bind_authentication(self):",
            "        \"\"\"Return if the token provider supports bind authentication methods.",
            "",
            "        :returns: False",
            "",
            "        \"\"\"",
            "        return False"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from oslo_config import cfg",
            "",
            "from keystone.common import dependency",
            "from keystone.common import utils as ks_utils",
            "from keystone.federation import constants as federation_constants",
            "from keystone.token.providers import common",
            "from keystone.token.providers.fernet import token_formatters as tf",
            "",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "@dependency.requires('trust_api', 'oauth_api')",
            "class Provider(common.BaseProvider):",
            "    def __init__(self, *args, **kwargs):",
            "        super(Provider, self).__init__(*args, **kwargs)",
            "",
            "        self.token_formatter = tf.TokenFormatter()",
            "",
            "    def needs_persistence(self):",
            "        \"\"\"Should the token be written to a backend.\"\"\"",
            "        return False",
            "",
            "    def issue_v2_token(self, *args, **kwargs):",
            "        token_id, token_data = super(Provider, self).issue_v2_token(",
            "            *args, **kwargs)",
            "        self._build_issued_at_info(token_id, token_data)",
            "        return token_id, token_data",
            "",
            "    def issue_v3_token(self, *args, **kwargs):",
            "        token_id, token_data = super(Provider, self).issue_v3_token(",
            "            *args, **kwargs)",
            "        self._build_issued_at_info(token_id, token_data)",
            "        return token_id, token_data",
            "",
            "    def _build_issued_at_info(self, token_id, token_data):",
            "        # NOTE(roxanaghe, lbragstad): We must use the creation time that",
            "        # Fernet builds into it's token. The Fernet spec details that the",
            "        # token creation time is built into the token, outside of the payload",
            "        # provided by Keystone. This is the reason why we don't pass the",
            "        # issued_at time in the payload. This also means that we shouldn't",
            "        # return a token reference with a creation time that we created",
            "        # when Fernet uses a different creation time. We should use the",
            "        # creation time provided by Fernet because it's the creation time",
            "        # that we have to rely on when we validate the token.",
            "        fernet_creation_datetime_obj = self.token_formatter.creation_time(",
            "            token_id)",
            "        if token_data.get('access'):",
            "            token_data['access']['token']['issued_at'] = ks_utils.isotime(",
            "                at=fernet_creation_datetime_obj, subsecond=True)",
            "        else:",
            "            token_data['token']['issued_at'] = ks_utils.isotime(",
            "                at=fernet_creation_datetime_obj, subsecond=True)",
            "",
            "    def _build_federated_info(self, token_data):",
            "        \"\"\"Extract everything needed for federated tokens.",
            "",
            "        This dictionary is passed to federated token formatters, which unpack",
            "        the values and build federated Fernet tokens.",
            "",
            "        \"\"\"",
            "        token_data = token_data['token']",
            "        try:",
            "            user = token_data['user']",
            "            federation = user[federation_constants.FEDERATION]",
            "            idp_id = federation['identity_provider']['id']",
            "            protocol_id = federation['protocol']['id']",
            "        except KeyError:",
            "            # The token data doesn't have federated info, so we aren't dealing",
            "            # with a federated token and no federated info to build.",
            "            return",
            "",
            "        group_ids = federation.get('groups')",
            "",
            "        return {'group_ids': group_ids,",
            "                'idp_id': idp_id,",
            "                'protocol_id': protocol_id}",
            "",
            "    def _rebuild_federated_info(self, federated_dict, user_id):",
            "        \"\"\"Format federated information into the token reference.",
            "",
            "        The federated_dict is passed back from the federated token formatters.",
            "        The responsibility of this method is to format the information passed",
            "        back from the token formatter into the token reference before",
            "        constructing the token data from the V3TokenDataHelper.",
            "",
            "        \"\"\"",
            "        g_ids = federated_dict['group_ids']",
            "        idp_id = federated_dict['idp_id']",
            "        protocol_id = federated_dict['protocol_id']",
            "",
            "        federated_info = {",
            "            'groups': g_ids,",
            "            'identity_provider': {'id': idp_id},",
            "            'protocol': {'id': protocol_id}",
            "        }",
            "",
            "        token_dict = {",
            "            'user': {",
            "                federation_constants.FEDERATION: federated_info,",
            "                'id': user_id,",
            "                'name': user_id,",
            "                'domain': {'id': CONF.federation.federated_domain_name,",
            "                           'name': CONF.federation.federated_domain_name, },",
            "            }",
            "        }",
            "",
            "        return token_dict",
            "",
            "    def _rebuild_federated_token_roles(self, token_dict, federated_dict,",
            "                                       user_id, project_id, domain_id):",
            "        \"\"\"Populate roles based on (groups, project/domain) pair.",
            "",
            "        We must populate roles from (groups, project/domain) as ephemeral users",
            "        don't exist in the backend. Upon success, a ``roles`` key will be added",
            "        to ``token_dict``.",
            "",
            "        :param token_dict: dictionary with data used for building token",
            "        :param federated_dict: federated information such as identity provider",
            "            protocol and set of group IDs",
            "        :param user_id: user ID",
            "        :param project_id: project ID the token is being scoped to",
            "        :param domain_id: domain ID the token is being scoped to",
            "",
            "        \"\"\"",
            "        group_ids = [x['id'] for x in federated_dict['group_ids']]",
            "        self.v3_token_data_helper.populate_roles_for_groups(",
            "            token_dict, group_ids, project_id, domain_id, user_id)",
            "",
            "    def _extract_v2_token_data(self, token_data):",
            "        user_id = token_data['access']['user']['id']",
            "        expires_at = token_data['access']['token']['expires']",
            "        audit_ids = token_data['access']['token'].get('audit_ids')",
            "        methods = ['password']",
            "        if len(audit_ids) > 1:",
            "            methods.append('token')",
            "        project_id = token_data['access']['token'].get('tenant', {}).get('id')",
            "        domain_id = None",
            "        trust_id = None",
            "        access_token_id = None",
            "        federated_info = None",
            "        return (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info)",
            "",
            "    def _extract_v3_token_data(self, token_data):",
            "        \"\"\"Extract information from a v3 token reference.\"\"\"",
            "        user_id = token_data['token']['user']['id']",
            "        expires_at = token_data['token']['expires_at']",
            "        audit_ids = token_data['token']['audit_ids']",
            "        methods = token_data['token'].get('methods')",
            "        domain_id = token_data['token'].get('domain', {}).get('id')",
            "        project_id = token_data['token'].get('project', {}).get('id')",
            "        trust_id = token_data['token'].get('OS-TRUST:trust', {}).get('id')",
            "        access_token_id = token_data['token'].get('OS-OAUTH1', {}).get(",
            "            'access_token_id')",
            "        federated_info = self._build_federated_info(token_data)",
            "",
            "        return (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info)",
            "",
            "    def _get_token_id(self, token_data):",
            "        \"\"\"Generate the token_id based upon the data in token_data.",
            "",
            "        :param token_data: token information",
            "        :type token_data: dict",
            "        :rtype: six.text_type",
            "",
            "        \"\"\"",
            "        # NOTE(lbragstad): Only v2.0 token responses include an 'access'",
            "        # attribute.",
            "        if token_data.get('access'):",
            "            (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info) = (",
            "                    self._extract_v2_token_data(token_data))",
            "        else:",
            "            (user_id, expires_at, audit_ids, methods, domain_id, project_id,",
            "                trust_id, access_token_id, federated_info) = (",
            "                    self._extract_v3_token_data(token_data))",
            "",
            "        return self.token_formatter.create_token(",
            "            user_id,",
            "            expires_at,",
            "            audit_ids,",
            "            methods=methods,",
            "            domain_id=domain_id,",
            "            project_id=project_id,",
            "            trust_id=trust_id,",
            "            federated_info=federated_info,",
            "            access_token_id=access_token_id",
            "        )",
            "",
            "    @property",
            "    def _supports_bind_authentication(self):",
            "        \"\"\"Return if the token provider supports bind authentication methods.",
            "",
            "        :returns: False",
            "",
            "        \"\"\"",
            "        return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "18": [],
            "148": [
                "Provider",
                "_extract_v2_token_data"
            ],
            "149": [
                "Provider",
                "_extract_v2_token_data"
            ],
            "150": [
                "Provider",
                "_extract_v2_token_data"
            ],
            "151": [
                "Provider",
                "_extract_v2_token_data"
            ],
            "152": [
                "Provider",
                "_extract_v2_token_data"
            ],
            "153": [
                "Provider",
                "_extract_v2_token_data"
            ]
        },
        "addLocation": []
    }
}