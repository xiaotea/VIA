{
    "src/fides/api/api/v1/endpoints/user_endpoints.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import random"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import time"
            },
            "3": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from datetime import datetime"
            },
            "4": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from typing import List, Optional"
            },
            "5": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " from fides.api.models.sql_models import System  # type: ignore[attr-defined]"
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " from fides.api.oauth.roles import APPROVER, VIEWER"
            },
            "8": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " from fides.api.oauth.utils import ("
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    create_temporary_user_for_login_flow,"
            },
            "10": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     extract_payload,"
            },
            "11": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     get_current_user,"
            },
            "12": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     oauth2_scheme,"
            },
            "13": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " router = APIRouter(tags=[\"Users\"], prefix=V1_URL_PREFIX)"
            },
            "14": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+ARTIFICIAL_TEMP_USER = create_temporary_user_for_login_flow("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    CONFIG"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+)  # To reduce likelihood of timing attacks.  Creating once and holding in memory"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " def get_system_by_fides_key(db: Session, system_key: FidesKey) -> System:"
            },
            "22": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     \"\"\"Load a system by FidesKey or throw a 404\"\"\""
            },
            "23": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     system = System.get_by(db, field=\"fides_key\", value=system_key)"
            },
            "24": {
                "beforePatchRowNumber": 541,
                "afterPatchRowNumber": 549,
                "PatchRowcode": "     generate a token.\"\"\""
            },
            "25": {
                "beforePatchRowNumber": 542,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "     user: FidesUser"
            },
            "26": {
                "beforePatchRowNumber": 543,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "     client: ClientDetail"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 552,
                "PatchRowcode": "+    should_raise_exception: bool = False"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 553,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 544,
                "afterPatchRowNumber": 554,
                "PatchRowcode": "     if ("
            },
            "30": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 555,
                "PatchRowcode": "         config.security.root_username"
            },
            "31": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 556,
                "PatchRowcode": "         and config.security.root_password"
            },
            "32": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": 588,
                "PatchRowcode": "             db, field=\"username\", value=user_data.username"
            },
            "33": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": 589,
                "PatchRowcode": "         )"
            },
            "34": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": 590,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        invalid_user_error_msg = \"Incorrect username or password.\""
            },
            "36": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "37": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 591,
                "PatchRowcode": "         if not user_check:"
            },
            "38": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise HTTPException("
            },
            "39": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                status_code=HTTP_403_FORBIDDEN, detail=invalid_user_error_msg"
            },
            "40": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 592,
                "PatchRowcode": "+            # Postpone raising the exception to reduce the time differences between"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 593,
                "PatchRowcode": "+            # login flows for valid and invalid users. Instead, create a temporary user"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 594,
                "PatchRowcode": "+            # on which we'll perform parallel operations"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 595,
                "PatchRowcode": "+            should_raise_exception = True"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+            user_check = ARTIFICIAL_TEMP_USER"
            },
            "46": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": 597,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": 598,
                "PatchRowcode": "         if not user_check.credentials_valid(user_data.password):"
            },
            "48": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise HTTPException("
            },
            "49": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                status_code=HTTP_403_FORBIDDEN,"
            },
            "50": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                detail=invalid_user_error_msg,"
            },
            "51": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+            should_raise_exception = True"
            },
            "53": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 600,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 601,
                "PatchRowcode": "         # We have already checked for None but mypy still complains. This prevents mypy"
            },
            "55": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 602,
                "PatchRowcode": "         # from complaining."
            },
            "56": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": 607,
                "PatchRowcode": "             config.security.oauth_client_id_length_bytes,"
            },
            "57": {
                "beforePatchRowNumber": 601,
                "afterPatchRowNumber": 608,
                "PatchRowcode": "             config.security.oauth_client_secret_length_bytes,"
            },
            "58": {
                "beforePatchRowNumber": 602,
                "afterPatchRowNumber": 609,
                "PatchRowcode": "             user,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 610,
                "PatchRowcode": "+            skip_save=should_raise_exception,"
            },
            "60": {
                "beforePatchRowNumber": 603,
                "afterPatchRowNumber": 611,
                "PatchRowcode": "         )"
            },
            "61": {
                "beforePatchRowNumber": 604,
                "afterPatchRowNumber": 612,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 605,
                "afterPatchRowNumber": 613,
                "PatchRowcode": "     logger.info(\"Creating login access token\")"
            },
            "63": {
                "beforePatchRowNumber": 606,
                "afterPatchRowNumber": 614,
                "PatchRowcode": "     access_code = client.create_access_code_jwe(config.security.app_encryption_key)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+    # Sleep for a random time period"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+    time.sleep(random.uniform(0.00, 0.50))"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+    if should_raise_exception:"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+        # Now raise postponed exception!"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+        raise HTTPException("
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+            status_code=HTTP_403_FORBIDDEN, detail=\"Incorrect username or password.\""
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 623,
                "PatchRowcode": "+        )"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "     return UserLoginResponse("
            },
            "75": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "         user_data=user,"
            },
            "76": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "         token_data=AccessToken(access_token=access_code),"
            }
        },
        "frontPatchFile": [
            "import json",
            "from datetime import datetime",
            "from typing import List, Optional",
            "",
            "import jose.exceptions",
            "from fastapi import Depends, HTTPException, Security",
            "from fastapi_pagination import Page, Params",
            "from fastapi_pagination.bases import AbstractPage",
            "from fastapi_pagination.ext.sqlalchemy import paginate",
            "from fideslang.models import System as SystemSchema",
            "from fideslang.validation import FidesKey",
            "from loguru import logger",
            "from sqlalchemy.orm import Query, Session",
            "from sqlalchemy_utils import escape_like",
            "from starlette.status import (",
            "    HTTP_200_OK,",
            "    HTTP_201_CREATED,",
            "    HTTP_204_NO_CONTENT,",
            "    HTTP_400_BAD_REQUEST,",
            "    HTTP_401_UNAUTHORIZED,",
            "    HTTP_403_FORBIDDEN,",
            "    HTTP_404_NOT_FOUND,",
            ")",
            "",
            "from fides.api.api import deps",
            "from fides.api.api.deps import get_config_proxy, get_db",
            "from fides.api.api.v1.endpoints.user_permission_endpoints import validate_user_id",
            "from fides.api.common_exceptions import AuthenticationError",
            "from fides.api.cryptography.cryptographic_util import b64_str_to_str",
            "from fides.api.cryptography.schemas.jwt import JWE_PAYLOAD_CLIENT_ID",
            "from fides.api.models.client import ClientDetail",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.models.fides_user_invite import FidesUserInvite",
            "from fides.api.models.fides_user_permissions import FidesUserPermissions",
            "from fides.api.models.sql_models import System  # type: ignore[attr-defined]",
            "from fides.api.oauth.roles import APPROVER, VIEWER",
            "from fides.api.oauth.utils import (",
            "    extract_payload,",
            "    get_current_user,",
            "    oauth2_scheme,",
            "    verify_oauth_client,",
            ")",
            "from fides.api.schemas.oauth import AccessToken",
            "from fides.api.schemas.user import (",
            "    UserCreate,",
            "    UserCreateResponse,",
            "    UserForcePasswordReset,",
            "    UserLogin,",
            "    UserLoginResponse,",
            "    UserPasswordReset,",
            "    UserResponse,",
            "    UserUpdate,",
            ")",
            "from fides.api.service.user.fides_user_service import (",
            "    accept_invite,",
            "    invite_user,",
            "    perform_login,",
            ")",
            "from fides.api.util.api_router import APIRouter",
            "from fides.common.api.scope_registry import (",
            "    SCOPE_REGISTRY,",
            "    SYSTEM_MANAGER_DELETE,",
            "    SYSTEM_MANAGER_READ,",
            "    SYSTEM_MANAGER_UPDATE,",
            "    USER_CREATE,",
            "    USER_DELETE,",
            "    USER_PASSWORD_RESET,",
            "    USER_READ,",
            "    USER_UPDATE,",
            ")",
            "from fides.common.api.v1 import urn_registry as urls",
            "from fides.common.api.v1.urn_registry import V1_URL_PREFIX",
            "from fides.config import CONFIG, FidesConfig, get_config",
            "from fides.config.config_proxy import ConfigProxy",
            "",
            "router = APIRouter(tags=[\"Users\"], prefix=V1_URL_PREFIX)",
            "",
            "",
            "def get_system_by_fides_key(db: Session, system_key: FidesKey) -> System:",
            "    \"\"\"Load a system by FidesKey or throw a 404\"\"\"",
            "    system = System.get_by(db, field=\"fides_key\", value=system_key)",
            "",
            "    if not system:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No system found with fides_key {system_key}.\",",
            "        )",
            "    return system",
            "",
            "",
            "def _validate_current_user(user_id: str, user_from_token: FidesUser) -> None:",
            "    if not user_from_token:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User with ID {user_id} does not exist.\",",
            "        )",
            "",
            "    if user_id != user_from_token.id:",
            "        raise HTTPException(",
            "            status_code=HTTP_401_UNAUTHORIZED,",
            "            detail=\"You are only authorised to update your own user data.\",",
            "        )",
            "",
            "",
            "@router.put(",
            "    urls.USER_DETAIL,",
            "    dependencies=[Security(verify_oauth_client)],",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserResponse,",
            ")",
            "async def update_user(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    authorization: str = Security(oauth2_scheme),",
            "    current_user: FidesUser = Depends(get_current_user),",
            "    user_id: str,",
            "    data: UserUpdate,",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Update a user given a `user_id`. If the user is not updating their own data,",
            "    they need the USER_UPDATE scope",
            "    \"\"\"",
            "    user = FidesUser.get(db=db, object_id=user_id)",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND, detail=f\"User with id {user_id} not found.\"",
            "        )",
            "",
            "    is_this_user = user.id == current_user.id",
            "    if not is_this_user:",
            "        await verify_oauth_client(",
            "            security_scopes=Security(verify_oauth_client, scopes=[USER_UPDATE]),",
            "            authorization=authorization,",
            "            db=db,",
            "        )",
            "",
            "    user.update(db=db, data=data.model_dump(mode=\"json\"))",
            "    logger.info(\"Updated user with id: '{}'.\", user.id)",
            "    return user",
            "",
            "",
            "@router.post(",
            "    urls.USER_PASSWORD_RESET,",
            "    dependencies=[Security(verify_oauth_client)],",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserResponse,",
            ")",
            "def update_user_password(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    current_user: FidesUser = Depends(get_current_user),",
            "    user_id: str,",
            "    data: UserPasswordReset,",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Update a user's password given a `user_id`. By default this is limited to users",
            "    updating their own data.",
            "    \"\"\"",
            "    _validate_current_user(user_id, current_user)",
            "",
            "    if not current_user.credentials_valid(",
            "        b64_str_to_str(data.old_password), CONFIG.security.encoding",
            "    ):",
            "        raise HTTPException(",
            "            status_code=HTTP_401_UNAUTHORIZED, detail=\"Incorrect password.\"",
            "        )",
            "",
            "    current_user.update_password(db=db, new_password=b64_str_to_str(data.new_password))",
            "",
            "    logger.info(\"Updated user with id: '{}'.\", current_user.id)",
            "    return current_user",
            "",
            "",
            "@router.post(",
            "    urls.USER_FORCE_PASSWORD_RESET,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_PASSWORD_RESET])],",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserResponse,",
            ")",
            "def force_update_password(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    user_id: str,",
            "    data: UserForcePasswordReset,",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Update any user's password given a `user_id` without needing to know the user's",
            "    previous password.",
            "    \"\"\"",
            "    user: Optional[FidesUser] = FidesUser.get(db=db, object_id=user_id)",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User with ID {user_id} does not exist.\",",
            "        )",
            "",
            "    user.update_password(db=db, new_password=b64_str_to_str(data.new_password))",
            "    logger.info(\"Updated user with id: '{}'.\", user.id)",
            "    return user",
            "",
            "",
            "def logout_oauth_client(",
            "    authorization: str = Security(oauth2_scheme), db: Session = Depends(get_db)",
            ") -> Optional[ClientDetail]:",
            "    \"\"\"",
            "    Streamlined oauth checks for logout.  Only raises an error if no authorization is supplied.",
            "    Otherwise, regardless if the token is malformed or expired, still return a 204.",
            "    Returns a client if we can extract one from the token.",
            "    \"\"\"",
            "    if authorization is None:",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    try:",
            "        token_data = json.loads(",
            "            extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "        )",
            "    except jose.exceptions.JWEParseError:",
            "        return None",
            "",
            "    client_id = token_data.get(JWE_PAYLOAD_CLIENT_ID)",
            "    if (",
            "        not client_id or client_id == CONFIG.security.oauth_root_client_id",
            "    ):  # The root client is not a persisted object",
            "        return None",
            "",
            "    client = ClientDetail.get(",
            "        db, object_id=client_id, config=CONFIG, scopes=SCOPE_REGISTRY",
            "    )",
            "",
            "    return client",
            "",
            "",
            "@router.post(",
            "    urls.LOGOUT,",
            "    status_code=HTTP_204_NO_CONTENT,",
            ")",
            "def user_logout(",
            "    *,",
            "    client: Optional[ClientDetail] = Security(",
            "        logout_oauth_client,",
            "    ),",
            "    db: Session = Depends(deps.get_db),",
            ") -> None:",
            "    \"\"\"Logout the user by deleting its client where applicable\"\"\"",
            "",
            "    logger.info(\"Logging out user.\")",
            "    if client:",
            "        client.delete(db)",
            "",
            "",
            "@router.put(",
            "    urls.SYSTEM_MANAGER,",
            "    dependencies=[Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_UPDATE])],",
            "    response_model=List[SystemSchema],",
            ")",
            "def update_managed_systems(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    user_id: str,",
            "    systems: List[FidesKey],",
            ") -> List[SystemSchema]:",
            "    \"\"\"",
            "    Endpoint to override the systems for which a user is \"system manager\".",
            "    All systems the user manages are replaced with those in the request body.",
            "    \"\"\"",
            "    user = validate_user_id(db, user_id)",
            "",
            "    if not (user.permissions and user.permissions.roles):  # type: ignore",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=f\"User {user_id} needs permissions before they can be assigned as system manager.\",",
            "        )",
            "",
            "    if APPROVER in user.permissions.roles:  # type: ignore",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=f\"User {user_id} is an {APPROVER} and cannot be assigned as a system manager.\",",
            "        )",
            "",
            "    if len(set(systems)) != len(systems):",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=f\"Cannot add user {user_id} as system manager. Duplicate systems in request body.\",",
            "        )",
            "",
            "    retrieved_systems: Query = db.query(System).filter(System.fides_key.in_(systems))",
            "    if retrieved_systems.count() != len(systems):",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"Cannot add user {user_id} as system manager. System(s) not found.\",",
            "        )",
            "",
            "    logger.info(\"Updating systems for which user {} is system manager\", user_id)",
            "",
            "    # Adding new systems for which the user is not already a manager",
            "    for system in retrieved_systems:",
            "        if user not in system.data_stewards:",
            "            user.set_as_system_manager(db, system)",
            "",
            "    # Removing systems for which the user in no longer a manager",
            "    for system in user.systems.copy():",
            "        if system not in retrieved_systems:",
            "            user.remove_as_system_manager(db, system)",
            "",
            "    return user.systems",
            "",
            "",
            "@router.get(",
            "    urls.SYSTEM_MANAGER,",
            "    response_model=List[SystemSchema],",
            ")",
            "async def get_managed_systems(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    authorization: str = Security(oauth2_scheme),",
            "    current_user: FidesUser = Depends(get_current_user),",
            "    user_id: str,",
            ") -> List[SystemSchema]:",
            "    \"\"\"",
            "    Endpoint to retrieve all the systems for which a user is \"system manager\".",
            "    \"\"\"",
            "    # A user is able to retrieve their own systems",
            "    if current_user and current_user.id == user_id:",
            "        logger.info(",
            "            \"Retrieving current user's {} systems for which they are system manager\",",
            "            user_id,",
            "        )",
            "        return current_user.systems",
            "",
            "    # User must have a specific scope to be able to read another user's systems",
            "    user = validate_user_id(db, user_id)",
            "    await verify_oauth_client(",
            "        security_scopes=Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_READ]),",
            "        authorization=authorization,",
            "        db=db,",
            "    )",
            "    logger.info(\"Getting systems for which user {} is system manager\", user_id)",
            "    return user.systems",
            "",
            "",
            "@router.get(",
            "    urls.SYSTEM_MANAGER_DETAIL,",
            "    response_model=SystemSchema,",
            ")",
            "async def get_managed_system_details(",
            "    *,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(deps.get_db),",
            "    user_id: str,",
            "    system_key: FidesKey,",
            "    current_user: FidesUser = Depends(get_current_user),",
            ") -> SystemSchema:",
            "    \"\"\"",
            "    Endpoint to retrieve a single system managed by the given user.",
            "    \"\"\"",
            "    system: System = get_system_by_fides_key(db, system_key)",
            "",
            "    if current_user and current_user.id == user_id:",
            "        user = current_user",
            "    else:",
            "        await verify_oauth_client(",
            "            security_scopes=Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_READ]),",
            "            authorization=authorization,",
            "            db=db,",
            "        )",
            "        user = validate_user_id(db, user_id)",
            "",
            "    if not system in user.systems:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User {user_id} is not a manager of system {system.fides_key}\",",
            "        )",
            "",
            "    logger.info(",
            "        \"Getting system {} for which user {} is system manager\",",
            "        system.fides_key,",
            "        user_id,",
            "    )",
            "",
            "    return system",
            "",
            "",
            "@router.delete(",
            "    urls.SYSTEM_MANAGER_DETAIL,",
            "    dependencies=[Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_DELETE])],",
            "    status_code=HTTP_204_NO_CONTENT,",
            ")",
            "def remove_user_as_system_manager(",
            "    *, db: Session = Depends(deps.get_db), user_id: str, system_key: FidesKey",
            ") -> None:",
            "    \"\"\"",
            "    Endpoint to remove user as system manager from the given system",
            "    \"\"\"",
            "    user = validate_user_id(db, user_id)",
            "    system: System = get_system_by_fides_key(db, system_key)",
            "",
            "    if not system in user.systems:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"Cannot delete user as system manager. User {user_id} is not a manager of system {system.fides_key}.\",",
            "        )",
            "",
            "    user.remove_as_system_manager(db, system)",
            "    logger.info(\"Removed user {} as system manager of {}\", user_id, system.fides_key)",
            "",
            "",
            "@router.post(",
            "    urls.USERS,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_CREATE])],",
            "    status_code=HTTP_201_CREATED,",
            "    response_model=UserCreateResponse,",
            ")",
            "def create_user(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    user_data: UserCreate,",
            "    config_proxy: ConfigProxy = Depends(get_config_proxy),",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Create a user given a username and password.",
            "    If `password` is sent as a base64 encoded string, it will automatically be decoded",
            "    server-side before being encrypted and persisted.",
            "    If `password` is sent as a plaintext string, it will be encrypted and persisted as is.",
            "",
            "    The user is given no roles by default.",
            "    \"\"\"",
            "",
            "    # The root user is not stored in the database so make sure here that the user name",
            "    # is not the same as the root user name.",
            "    if (",
            "        config_proxy.security.root_username",
            "        and config_proxy.security.root_username == user_data.username",
            "    ):",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST, detail=\"Username already exists.\"",
            "        )",
            "",
            "    user = FidesUser.get_by(db, field=\"username\", value=user_data.username)",
            "",
            "    if user:",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST, detail=\"Username already exists.\"",
            "        )",
            "",
            "    user = FidesUser.get_by(db, field=\"email_address\", value=user_data.email_address)",
            "",
            "    if user:",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=\"User with this email address already exists.\",",
            "        )",
            "",
            "    user = FidesUser.create(db=db, data=user_data.model_dump(mode=\"json\"))",
            "",
            "    # invite user via email",
            "    invite_user(db=db, config_proxy=config_proxy, user=user)",
            "",
            "    logger.info(\"Created user with id: '{}'.\", user.id)",
            "    FidesUserPermissions.create(",
            "        db=db,",
            "        data={\"user_id\": user.id, \"roles\": [VIEWER]},",
            "    )",
            "    return user",
            "",
            "",
            "@router.delete(",
            "    urls.USER_DETAIL,",
            "    status_code=HTTP_204_NO_CONTENT,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_DELETE])],",
            ")",
            "def delete_user(",
            "    *,",
            "    client: ClientDetail = Security(",
            "        verify_oauth_client,",
            "        scopes=[USER_DELETE],",
            "    ),",
            "    db: Session = Depends(get_db),",
            "    user_id: str,",
            ") -> None:",
            "    \"\"\"Deletes the User and associated ClientDetail if applicable.\"\"\"",
            "    user = FidesUser.get_by(db, field=\"id\", value=user_id)",
            "",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND, detail=f\"No user found with id {user_id}.\"",
            "        )",
            "",
            "    logger.info(\"User with id {} deleted by user with id {}\", user_id, client.user_id)",
            "",
            "    user.delete(db)",
            "",
            "",
            "@router.get(",
            "    urls.USER_DETAIL,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_READ])],",
            "    response_model=UserResponse,",
            ")",
            "def get_user(*, db: Session = Depends(get_db), user_id: str) -> FidesUser:",
            "    \"\"\"Returns a User based on an Id\"\"\"",
            "    user: Optional[FidesUser] = FidesUser.get_by_key_or_id(db, data={\"id\": user_id})",
            "    if user is None:",
            "        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail=\"User not found\")",
            "",
            "    logger.info(\"Returning user with id: '{}'.\", user_id)",
            "    return user",
            "",
            "",
            "@router.get(",
            "    urls.USERS,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_READ])],",
            "    response_model=Page[UserResponse],",
            ")",
            "def get_users(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    params: Params = Depends(),",
            "    username: Optional[str] = None,",
            ") -> AbstractPage[FidesUser]:",
            "    \"\"\"Returns a paginated list of all users\"\"\"",
            "    query = FidesUser.query(db)",
            "    if username:",
            "        query = query.filter(FidesUser.username.ilike(f\"%{escape_like(username)}%\"))",
            "",
            "    logger.info(\"Returning a paginated list of users.\")",
            "",
            "    return paginate(query.order_by(FidesUser.created_at.desc()), params=params)",
            "",
            "",
            "@router.post(",
            "    urls.LOGIN,",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserLoginResponse,",
            ")",
            "def user_login(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    config: FidesConfig = Depends(get_config),",
            "    user_data: UserLogin,",
            ") -> UserLoginResponse:",
            "    \"\"\"Login the user by creating a client if it doesn't exist, and have that client",
            "    generate a token.\"\"\"",
            "    user: FidesUser",
            "    client: ClientDetail",
            "    if (",
            "        config.security.root_username",
            "        and config.security.root_password",
            "        and config.security.root_username == user_data.username",
            "        and config.security.root_password == user_data.password",
            "    ):",
            "        client_check = ClientDetail.get(",
            "            db,",
            "            object_id=config.security.oauth_root_client_id,",
            "            config=config,",
            "            scopes=config.security.root_user_scopes,",
            "            roles=config.security.root_user_roles,",
            "        )",
            "",
            "        if not client_check:",
            "            raise HTTPException(",
            "                status_code=HTTP_404_NOT_FOUND, detail=\"No root client found.\"",
            "            )",
            "",
            "        # We have already checked for None but mypy still complains. This prevents mypy",
            "        # from complaining.",
            "        client = client_check",
            "        user = FidesUser(",
            "            id=config.security.oauth_root_client_id,",
            "            username=config.security.root_username,",
            "            created_at=datetime.utcnow(),",
            "        )",
            "",
            "        logger.warning(",
            "            \"Root Username & Password were used to login! If unexpected, review security settings (FIDES__SECURITY__ROOT_USERNAME and FIDES__SECURITY__ROOT_PASSWORD)\"",
            "        )",
            "",
            "    else:",
            "        user_check: Optional[FidesUser] = FidesUser.get_by(",
            "            db, field=\"username\", value=user_data.username",
            "        )",
            "",
            "        invalid_user_error_msg = \"Incorrect username or password.\"",
            "",
            "        if not user_check:",
            "            raise HTTPException(",
            "                status_code=HTTP_403_FORBIDDEN, detail=invalid_user_error_msg",
            "            )",
            "",
            "        if not user_check.credentials_valid(user_data.password):",
            "            raise HTTPException(",
            "                status_code=HTTP_403_FORBIDDEN,",
            "                detail=invalid_user_error_msg,",
            "            )",
            "",
            "        # We have already checked for None but mypy still complains. This prevents mypy",
            "        # from complaining.",
            "        user = user_check",
            "",
            "        client = perform_login(",
            "            db,",
            "            config.security.oauth_client_id_length_bytes,",
            "            config.security.oauth_client_secret_length_bytes,",
            "            user,",
            "        )",
            "",
            "    logger.info(\"Creating login access token\")",
            "    access_code = client.create_access_code_jwe(config.security.app_encryption_key)",
            "    return UserLoginResponse(",
            "        user_data=user,",
            "        token_data=AccessToken(access_token=access_code),",
            "    )",
            "",
            "",
            "def verify_invite_code(",
            "    username: str,",
            "    invite_code: str,",
            "    db: Session = Depends(get_db),",
            ") -> FidesUserInvite:",
            "    \"\"\"",
            "    Security dependency to verify the invite code.",
            "    Returns the validated FidesUserInvite if all the checks pass.",
            "    \"\"\"",
            "    user_invite = FidesUserInvite.get_by(db, field=\"username\", value=username)",
            "",
            "    if not user_invite:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=\"User not found.\",",
            "        )",
            "",
            "    if not user_invite.invite_code_valid(invite_code):",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=\"Invite code is invalid.\",",
            "        )",
            "",
            "    if user_invite.is_expired():",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=\"Invite code has expired.\",",
            "        )",
            "",
            "    return user_invite",
            "",
            "",
            "@router.post(",
            "    urls.USER_ACCEPT_INVITE,",
            ")",
            "def accept_user_invite(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    config: FidesConfig = Depends(get_config),",
            "    user_data: UserForcePasswordReset,",
            "    verified_invite: FidesUserInvite = Depends(verify_invite_code),",
            ") -> UserLoginResponse:",
            "    \"\"\"Sets the password and enables the user if a valid username and invite code are provided.\"\"\"",
            "",
            "    user: Optional[FidesUser] = FidesUser.get_by(",
            "        db=db, field=\"username\", value=verified_invite.username",
            "    )",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User with username {verified_invite.username} does not exist.\",",
            "        )",
            "",
            "    user, access_code = accept_invite(",
            "        db=db, config=config, user=user, new_password=user_data.new_password",
            "    )",
            "",
            "    return UserLoginResponse(",
            "        user_data=user,",
            "        token_data=AccessToken(access_token=access_code),",
            "    )"
        ],
        "afterPatchFile": [
            "import json",
            "import random",
            "import time",
            "from datetime import datetime",
            "from typing import List, Optional",
            "",
            "import jose.exceptions",
            "from fastapi import Depends, HTTPException, Security",
            "from fastapi_pagination import Page, Params",
            "from fastapi_pagination.bases import AbstractPage",
            "from fastapi_pagination.ext.sqlalchemy import paginate",
            "from fideslang.models import System as SystemSchema",
            "from fideslang.validation import FidesKey",
            "from loguru import logger",
            "from sqlalchemy.orm import Query, Session",
            "from sqlalchemy_utils import escape_like",
            "from starlette.status import (",
            "    HTTP_200_OK,",
            "    HTTP_201_CREATED,",
            "    HTTP_204_NO_CONTENT,",
            "    HTTP_400_BAD_REQUEST,",
            "    HTTP_401_UNAUTHORIZED,",
            "    HTTP_403_FORBIDDEN,",
            "    HTTP_404_NOT_FOUND,",
            ")",
            "",
            "from fides.api.api import deps",
            "from fides.api.api.deps import get_config_proxy, get_db",
            "from fides.api.api.v1.endpoints.user_permission_endpoints import validate_user_id",
            "from fides.api.common_exceptions import AuthenticationError",
            "from fides.api.cryptography.cryptographic_util import b64_str_to_str",
            "from fides.api.cryptography.schemas.jwt import JWE_PAYLOAD_CLIENT_ID",
            "from fides.api.models.client import ClientDetail",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.models.fides_user_invite import FidesUserInvite",
            "from fides.api.models.fides_user_permissions import FidesUserPermissions",
            "from fides.api.models.sql_models import System  # type: ignore[attr-defined]",
            "from fides.api.oauth.roles import APPROVER, VIEWER",
            "from fides.api.oauth.utils import (",
            "    create_temporary_user_for_login_flow,",
            "    extract_payload,",
            "    get_current_user,",
            "    oauth2_scheme,",
            "    verify_oauth_client,",
            ")",
            "from fides.api.schemas.oauth import AccessToken",
            "from fides.api.schemas.user import (",
            "    UserCreate,",
            "    UserCreateResponse,",
            "    UserForcePasswordReset,",
            "    UserLogin,",
            "    UserLoginResponse,",
            "    UserPasswordReset,",
            "    UserResponse,",
            "    UserUpdate,",
            ")",
            "from fides.api.service.user.fides_user_service import (",
            "    accept_invite,",
            "    invite_user,",
            "    perform_login,",
            ")",
            "from fides.api.util.api_router import APIRouter",
            "from fides.common.api.scope_registry import (",
            "    SCOPE_REGISTRY,",
            "    SYSTEM_MANAGER_DELETE,",
            "    SYSTEM_MANAGER_READ,",
            "    SYSTEM_MANAGER_UPDATE,",
            "    USER_CREATE,",
            "    USER_DELETE,",
            "    USER_PASSWORD_RESET,",
            "    USER_READ,",
            "    USER_UPDATE,",
            ")",
            "from fides.common.api.v1 import urn_registry as urls",
            "from fides.common.api.v1.urn_registry import V1_URL_PREFIX",
            "from fides.config import CONFIG, FidesConfig, get_config",
            "from fides.config.config_proxy import ConfigProxy",
            "",
            "router = APIRouter(tags=[\"Users\"], prefix=V1_URL_PREFIX)",
            "",
            "",
            "ARTIFICIAL_TEMP_USER = create_temporary_user_for_login_flow(",
            "    CONFIG",
            ")  # To reduce likelihood of timing attacks.  Creating once and holding in memory",
            "",
            "",
            "def get_system_by_fides_key(db: Session, system_key: FidesKey) -> System:",
            "    \"\"\"Load a system by FidesKey or throw a 404\"\"\"",
            "    system = System.get_by(db, field=\"fides_key\", value=system_key)",
            "",
            "    if not system:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No system found with fides_key {system_key}.\",",
            "        )",
            "    return system",
            "",
            "",
            "def _validate_current_user(user_id: str, user_from_token: FidesUser) -> None:",
            "    if not user_from_token:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User with ID {user_id} does not exist.\",",
            "        )",
            "",
            "    if user_id != user_from_token.id:",
            "        raise HTTPException(",
            "            status_code=HTTP_401_UNAUTHORIZED,",
            "            detail=\"You are only authorised to update your own user data.\",",
            "        )",
            "",
            "",
            "@router.put(",
            "    urls.USER_DETAIL,",
            "    dependencies=[Security(verify_oauth_client)],",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserResponse,",
            ")",
            "async def update_user(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    authorization: str = Security(oauth2_scheme),",
            "    current_user: FidesUser = Depends(get_current_user),",
            "    user_id: str,",
            "    data: UserUpdate,",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Update a user given a `user_id`. If the user is not updating their own data,",
            "    they need the USER_UPDATE scope",
            "    \"\"\"",
            "    user = FidesUser.get(db=db, object_id=user_id)",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND, detail=f\"User with id {user_id} not found.\"",
            "        )",
            "",
            "    is_this_user = user.id == current_user.id",
            "    if not is_this_user:",
            "        await verify_oauth_client(",
            "            security_scopes=Security(verify_oauth_client, scopes=[USER_UPDATE]),",
            "            authorization=authorization,",
            "            db=db,",
            "        )",
            "",
            "    user.update(db=db, data=data.model_dump(mode=\"json\"))",
            "    logger.info(\"Updated user with id: '{}'.\", user.id)",
            "    return user",
            "",
            "",
            "@router.post(",
            "    urls.USER_PASSWORD_RESET,",
            "    dependencies=[Security(verify_oauth_client)],",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserResponse,",
            ")",
            "def update_user_password(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    current_user: FidesUser = Depends(get_current_user),",
            "    user_id: str,",
            "    data: UserPasswordReset,",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Update a user's password given a `user_id`. By default this is limited to users",
            "    updating their own data.",
            "    \"\"\"",
            "    _validate_current_user(user_id, current_user)",
            "",
            "    if not current_user.credentials_valid(",
            "        b64_str_to_str(data.old_password), CONFIG.security.encoding",
            "    ):",
            "        raise HTTPException(",
            "            status_code=HTTP_401_UNAUTHORIZED, detail=\"Incorrect password.\"",
            "        )",
            "",
            "    current_user.update_password(db=db, new_password=b64_str_to_str(data.new_password))",
            "",
            "    logger.info(\"Updated user with id: '{}'.\", current_user.id)",
            "    return current_user",
            "",
            "",
            "@router.post(",
            "    urls.USER_FORCE_PASSWORD_RESET,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_PASSWORD_RESET])],",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserResponse,",
            ")",
            "def force_update_password(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    user_id: str,",
            "    data: UserForcePasswordReset,",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Update any user's password given a `user_id` without needing to know the user's",
            "    previous password.",
            "    \"\"\"",
            "    user: Optional[FidesUser] = FidesUser.get(db=db, object_id=user_id)",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User with ID {user_id} does not exist.\",",
            "        )",
            "",
            "    user.update_password(db=db, new_password=b64_str_to_str(data.new_password))",
            "    logger.info(\"Updated user with id: '{}'.\", user.id)",
            "    return user",
            "",
            "",
            "def logout_oauth_client(",
            "    authorization: str = Security(oauth2_scheme), db: Session = Depends(get_db)",
            ") -> Optional[ClientDetail]:",
            "    \"\"\"",
            "    Streamlined oauth checks for logout.  Only raises an error if no authorization is supplied.",
            "    Otherwise, regardless if the token is malformed or expired, still return a 204.",
            "    Returns a client if we can extract one from the token.",
            "    \"\"\"",
            "    if authorization is None:",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    try:",
            "        token_data = json.loads(",
            "            extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "        )",
            "    except jose.exceptions.JWEParseError:",
            "        return None",
            "",
            "    client_id = token_data.get(JWE_PAYLOAD_CLIENT_ID)",
            "    if (",
            "        not client_id or client_id == CONFIG.security.oauth_root_client_id",
            "    ):  # The root client is not a persisted object",
            "        return None",
            "",
            "    client = ClientDetail.get(",
            "        db, object_id=client_id, config=CONFIG, scopes=SCOPE_REGISTRY",
            "    )",
            "",
            "    return client",
            "",
            "",
            "@router.post(",
            "    urls.LOGOUT,",
            "    status_code=HTTP_204_NO_CONTENT,",
            ")",
            "def user_logout(",
            "    *,",
            "    client: Optional[ClientDetail] = Security(",
            "        logout_oauth_client,",
            "    ),",
            "    db: Session = Depends(deps.get_db),",
            ") -> None:",
            "    \"\"\"Logout the user by deleting its client where applicable\"\"\"",
            "",
            "    logger.info(\"Logging out user.\")",
            "    if client:",
            "        client.delete(db)",
            "",
            "",
            "@router.put(",
            "    urls.SYSTEM_MANAGER,",
            "    dependencies=[Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_UPDATE])],",
            "    response_model=List[SystemSchema],",
            ")",
            "def update_managed_systems(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    user_id: str,",
            "    systems: List[FidesKey],",
            ") -> List[SystemSchema]:",
            "    \"\"\"",
            "    Endpoint to override the systems for which a user is \"system manager\".",
            "    All systems the user manages are replaced with those in the request body.",
            "    \"\"\"",
            "    user = validate_user_id(db, user_id)",
            "",
            "    if not (user.permissions and user.permissions.roles):  # type: ignore",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=f\"User {user_id} needs permissions before they can be assigned as system manager.\",",
            "        )",
            "",
            "    if APPROVER in user.permissions.roles:  # type: ignore",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=f\"User {user_id} is an {APPROVER} and cannot be assigned as a system manager.\",",
            "        )",
            "",
            "    if len(set(systems)) != len(systems):",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=f\"Cannot add user {user_id} as system manager. Duplicate systems in request body.\",",
            "        )",
            "",
            "    retrieved_systems: Query = db.query(System).filter(System.fides_key.in_(systems))",
            "    if retrieved_systems.count() != len(systems):",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"Cannot add user {user_id} as system manager. System(s) not found.\",",
            "        )",
            "",
            "    logger.info(\"Updating systems for which user {} is system manager\", user_id)",
            "",
            "    # Adding new systems for which the user is not already a manager",
            "    for system in retrieved_systems:",
            "        if user not in system.data_stewards:",
            "            user.set_as_system_manager(db, system)",
            "",
            "    # Removing systems for which the user in no longer a manager",
            "    for system in user.systems.copy():",
            "        if system not in retrieved_systems:",
            "            user.remove_as_system_manager(db, system)",
            "",
            "    return user.systems",
            "",
            "",
            "@router.get(",
            "    urls.SYSTEM_MANAGER,",
            "    response_model=List[SystemSchema],",
            ")",
            "async def get_managed_systems(",
            "    *,",
            "    db: Session = Depends(deps.get_db),",
            "    authorization: str = Security(oauth2_scheme),",
            "    current_user: FidesUser = Depends(get_current_user),",
            "    user_id: str,",
            ") -> List[SystemSchema]:",
            "    \"\"\"",
            "    Endpoint to retrieve all the systems for which a user is \"system manager\".",
            "    \"\"\"",
            "    # A user is able to retrieve their own systems",
            "    if current_user and current_user.id == user_id:",
            "        logger.info(",
            "            \"Retrieving current user's {} systems for which they are system manager\",",
            "            user_id,",
            "        )",
            "        return current_user.systems",
            "",
            "    # User must have a specific scope to be able to read another user's systems",
            "    user = validate_user_id(db, user_id)",
            "    await verify_oauth_client(",
            "        security_scopes=Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_READ]),",
            "        authorization=authorization,",
            "        db=db,",
            "    )",
            "    logger.info(\"Getting systems for which user {} is system manager\", user_id)",
            "    return user.systems",
            "",
            "",
            "@router.get(",
            "    urls.SYSTEM_MANAGER_DETAIL,",
            "    response_model=SystemSchema,",
            ")",
            "async def get_managed_system_details(",
            "    *,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(deps.get_db),",
            "    user_id: str,",
            "    system_key: FidesKey,",
            "    current_user: FidesUser = Depends(get_current_user),",
            ") -> SystemSchema:",
            "    \"\"\"",
            "    Endpoint to retrieve a single system managed by the given user.",
            "    \"\"\"",
            "    system: System = get_system_by_fides_key(db, system_key)",
            "",
            "    if current_user and current_user.id == user_id:",
            "        user = current_user",
            "    else:",
            "        await verify_oauth_client(",
            "            security_scopes=Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_READ]),",
            "            authorization=authorization,",
            "            db=db,",
            "        )",
            "        user = validate_user_id(db, user_id)",
            "",
            "    if not system in user.systems:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User {user_id} is not a manager of system {system.fides_key}\",",
            "        )",
            "",
            "    logger.info(",
            "        \"Getting system {} for which user {} is system manager\",",
            "        system.fides_key,",
            "        user_id,",
            "    )",
            "",
            "    return system",
            "",
            "",
            "@router.delete(",
            "    urls.SYSTEM_MANAGER_DETAIL,",
            "    dependencies=[Security(verify_oauth_client, scopes=[SYSTEM_MANAGER_DELETE])],",
            "    status_code=HTTP_204_NO_CONTENT,",
            ")",
            "def remove_user_as_system_manager(",
            "    *, db: Session = Depends(deps.get_db), user_id: str, system_key: FidesKey",
            ") -> None:",
            "    \"\"\"",
            "    Endpoint to remove user as system manager from the given system",
            "    \"\"\"",
            "    user = validate_user_id(db, user_id)",
            "    system: System = get_system_by_fides_key(db, system_key)",
            "",
            "    if not system in user.systems:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"Cannot delete user as system manager. User {user_id} is not a manager of system {system.fides_key}.\",",
            "        )",
            "",
            "    user.remove_as_system_manager(db, system)",
            "    logger.info(\"Removed user {} as system manager of {}\", user_id, system.fides_key)",
            "",
            "",
            "@router.post(",
            "    urls.USERS,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_CREATE])],",
            "    status_code=HTTP_201_CREATED,",
            "    response_model=UserCreateResponse,",
            ")",
            "def create_user(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    user_data: UserCreate,",
            "    config_proxy: ConfigProxy = Depends(get_config_proxy),",
            ") -> FidesUser:",
            "    \"\"\"",
            "    Create a user given a username and password.",
            "    If `password` is sent as a base64 encoded string, it will automatically be decoded",
            "    server-side before being encrypted and persisted.",
            "    If `password` is sent as a plaintext string, it will be encrypted and persisted as is.",
            "",
            "    The user is given no roles by default.",
            "    \"\"\"",
            "",
            "    # The root user is not stored in the database so make sure here that the user name",
            "    # is not the same as the root user name.",
            "    if (",
            "        config_proxy.security.root_username",
            "        and config_proxy.security.root_username == user_data.username",
            "    ):",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST, detail=\"Username already exists.\"",
            "        )",
            "",
            "    user = FidesUser.get_by(db, field=\"username\", value=user_data.username)",
            "",
            "    if user:",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST, detail=\"Username already exists.\"",
            "        )",
            "",
            "    user = FidesUser.get_by(db, field=\"email_address\", value=user_data.email_address)",
            "",
            "    if user:",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=\"User with this email address already exists.\",",
            "        )",
            "",
            "    user = FidesUser.create(db=db, data=user_data.model_dump(mode=\"json\"))",
            "",
            "    # invite user via email",
            "    invite_user(db=db, config_proxy=config_proxy, user=user)",
            "",
            "    logger.info(\"Created user with id: '{}'.\", user.id)",
            "    FidesUserPermissions.create(",
            "        db=db,",
            "        data={\"user_id\": user.id, \"roles\": [VIEWER]},",
            "    )",
            "    return user",
            "",
            "",
            "@router.delete(",
            "    urls.USER_DETAIL,",
            "    status_code=HTTP_204_NO_CONTENT,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_DELETE])],",
            ")",
            "def delete_user(",
            "    *,",
            "    client: ClientDetail = Security(",
            "        verify_oauth_client,",
            "        scopes=[USER_DELETE],",
            "    ),",
            "    db: Session = Depends(get_db),",
            "    user_id: str,",
            ") -> None:",
            "    \"\"\"Deletes the User and associated ClientDetail if applicable.\"\"\"",
            "    user = FidesUser.get_by(db, field=\"id\", value=user_id)",
            "",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND, detail=f\"No user found with id {user_id}.\"",
            "        )",
            "",
            "    logger.info(\"User with id {} deleted by user with id {}\", user_id, client.user_id)",
            "",
            "    user.delete(db)",
            "",
            "",
            "@router.get(",
            "    urls.USER_DETAIL,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_READ])],",
            "    response_model=UserResponse,",
            ")",
            "def get_user(*, db: Session = Depends(get_db), user_id: str) -> FidesUser:",
            "    \"\"\"Returns a User based on an Id\"\"\"",
            "    user: Optional[FidesUser] = FidesUser.get_by_key_or_id(db, data={\"id\": user_id})",
            "    if user is None:",
            "        raise HTTPException(status_code=HTTP_404_NOT_FOUND, detail=\"User not found\")",
            "",
            "    logger.info(\"Returning user with id: '{}'.\", user_id)",
            "    return user",
            "",
            "",
            "@router.get(",
            "    urls.USERS,",
            "    dependencies=[Security(verify_oauth_client, scopes=[USER_READ])],",
            "    response_model=Page[UserResponse],",
            ")",
            "def get_users(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    params: Params = Depends(),",
            "    username: Optional[str] = None,",
            ") -> AbstractPage[FidesUser]:",
            "    \"\"\"Returns a paginated list of all users\"\"\"",
            "    query = FidesUser.query(db)",
            "    if username:",
            "        query = query.filter(FidesUser.username.ilike(f\"%{escape_like(username)}%\"))",
            "",
            "    logger.info(\"Returning a paginated list of users.\")",
            "",
            "    return paginate(query.order_by(FidesUser.created_at.desc()), params=params)",
            "",
            "",
            "@router.post(",
            "    urls.LOGIN,",
            "    status_code=HTTP_200_OK,",
            "    response_model=UserLoginResponse,",
            ")",
            "def user_login(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    config: FidesConfig = Depends(get_config),",
            "    user_data: UserLogin,",
            ") -> UserLoginResponse:",
            "    \"\"\"Login the user by creating a client if it doesn't exist, and have that client",
            "    generate a token.\"\"\"",
            "    user: FidesUser",
            "    client: ClientDetail",
            "    should_raise_exception: bool = False",
            "",
            "    if (",
            "        config.security.root_username",
            "        and config.security.root_password",
            "        and config.security.root_username == user_data.username",
            "        and config.security.root_password == user_data.password",
            "    ):",
            "        client_check = ClientDetail.get(",
            "            db,",
            "            object_id=config.security.oauth_root_client_id,",
            "            config=config,",
            "            scopes=config.security.root_user_scopes,",
            "            roles=config.security.root_user_roles,",
            "        )",
            "",
            "        if not client_check:",
            "            raise HTTPException(",
            "                status_code=HTTP_404_NOT_FOUND, detail=\"No root client found.\"",
            "            )",
            "",
            "        # We have already checked for None but mypy still complains. This prevents mypy",
            "        # from complaining.",
            "        client = client_check",
            "        user = FidesUser(",
            "            id=config.security.oauth_root_client_id,",
            "            username=config.security.root_username,",
            "            created_at=datetime.utcnow(),",
            "        )",
            "",
            "        logger.warning(",
            "            \"Root Username & Password were used to login! If unexpected, review security settings (FIDES__SECURITY__ROOT_USERNAME and FIDES__SECURITY__ROOT_PASSWORD)\"",
            "        )",
            "",
            "    else:",
            "        user_check: Optional[FidesUser] = FidesUser.get_by(",
            "            db, field=\"username\", value=user_data.username",
            "        )",
            "",
            "        if not user_check:",
            "            # Postpone raising the exception to reduce the time differences between",
            "            # login flows for valid and invalid users. Instead, create a temporary user",
            "            # on which we'll perform parallel operations",
            "            should_raise_exception = True",
            "            user_check = ARTIFICIAL_TEMP_USER",
            "",
            "        if not user_check.credentials_valid(user_data.password):",
            "            should_raise_exception = True",
            "",
            "        # We have already checked for None but mypy still complains. This prevents mypy",
            "        # from complaining.",
            "        user = user_check",
            "",
            "        client = perform_login(",
            "            db,",
            "            config.security.oauth_client_id_length_bytes,",
            "            config.security.oauth_client_secret_length_bytes,",
            "            user,",
            "            skip_save=should_raise_exception,",
            "        )",
            "",
            "    logger.info(\"Creating login access token\")",
            "    access_code = client.create_access_code_jwe(config.security.app_encryption_key)",
            "",
            "    # Sleep for a random time period",
            "    time.sleep(random.uniform(0.00, 0.50))",
            "",
            "    if should_raise_exception:",
            "        # Now raise postponed exception!",
            "        raise HTTPException(",
            "            status_code=HTTP_403_FORBIDDEN, detail=\"Incorrect username or password.\"",
            "        )",
            "",
            "    return UserLoginResponse(",
            "        user_data=user,",
            "        token_data=AccessToken(access_token=access_code),",
            "    )",
            "",
            "",
            "def verify_invite_code(",
            "    username: str,",
            "    invite_code: str,",
            "    db: Session = Depends(get_db),",
            ") -> FidesUserInvite:",
            "    \"\"\"",
            "    Security dependency to verify the invite code.",
            "    Returns the validated FidesUserInvite if all the checks pass.",
            "    \"\"\"",
            "    user_invite = FidesUserInvite.get_by(db, field=\"username\", value=username)",
            "",
            "    if not user_invite:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=\"User not found.\",",
            "        )",
            "",
            "    if not user_invite.invite_code_valid(invite_code):",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=\"Invite code is invalid.\",",
            "        )",
            "",
            "    if user_invite.is_expired():",
            "        raise HTTPException(",
            "            status_code=HTTP_400_BAD_REQUEST,",
            "            detail=\"Invite code has expired.\",",
            "        )",
            "",
            "    return user_invite",
            "",
            "",
            "@router.post(",
            "    urls.USER_ACCEPT_INVITE,",
            ")",
            "def accept_user_invite(",
            "    *,",
            "    db: Session = Depends(get_db),",
            "    config: FidesConfig = Depends(get_config),",
            "    user_data: UserForcePasswordReset,",
            "    verified_invite: FidesUserInvite = Depends(verify_invite_code),",
            ") -> UserLoginResponse:",
            "    \"\"\"Sets the password and enables the user if a valid username and invite code are provided.\"\"\"",
            "",
            "    user: Optional[FidesUser] = FidesUser.get_by(",
            "        db=db, field=\"username\", value=verified_invite.username",
            "    )",
            "    if not user:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"User with username {verified_invite.username} does not exist.\",",
            "        )",
            "",
            "    user, access_code = accept_invite(",
            "        db=db, config=config, user=user, new_password=user_data.new_password",
            "    )",
            "",
            "    return UserLoginResponse(",
            "        user_data=user,",
            "        token_data=AccessToken(access_token=access_code),",
            "    )"
        ],
        "action": [
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "581": [
                "user_login"
            ],
            "582": [
                "user_login"
            ],
            "584": [
                "user_login"
            ],
            "585": [
                "user_login"
            ],
            "586": [
                "user_login"
            ],
            "589": [
                "user_login"
            ],
            "590": [
                "user_login"
            ],
            "591": [
                "user_login"
            ],
            "592": [
                "user_login"
            ]
        },
        "addLocation": [
            "numpy.lib.tests.test_io.TestFromTxt"
        ]
    },
    "src/fides/api/models/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         roles: list[str] | None = None,"
            },
            "1": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         systems: list[str] | None = None,"
            },
            "2": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         connections: list[str] | None = None,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        in_memory: bool | None = False,"
            },
            "4": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     ) -> tuple[\"ClientDetail\", str]:"
            },
            "5": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         \"\"\"Creates a ClientDetail and returns that along with the unhashed secret"
            },
            "6": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         so it can be returned to the user on create"
            },
            "7": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             salt.encode(encoding),"
            },
            "8": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         )"
            },
            "9": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        client = super().create("
            },
            "11": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            db,"
            },
            "12": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data={"
            },
            "13": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"id\": client_id,"
            },
            "14": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"salt\": salt,"
            },
            "15": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"hashed_secret\": hashed_secret,"
            },
            "16": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"scopes\": scopes,"
            },
            "17": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"fides_key\": fides_key,"
            },
            "18": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"user_id\": user_id,"
            },
            "19": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"roles\": roles,"
            },
            "20": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"systems\": systems,"
            },
            "21": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"connections\": connections,"
            },
            "22": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            },"
            },
            "23": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        data = {"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            \"id\": client_id,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            \"salt\": salt,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            \"hashed_secret\": hashed_secret,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            \"scopes\": scopes,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            \"fides_key\": fides_key,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            \"user_id\": user_id,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            \"roles\": roles,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            \"systems\": systems,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            \"connections\": connections,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        }"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        if in_memory:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            client = ClientDetail("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+                **data"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            )  # For creating a temporary ClientDetail for invalid user login flow"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        else:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+            client = super().create("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+                db,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                data=data,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+            )"
            },
            "45": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         return client, secret  # type: ignore"
            },
            "46": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     @classmethod"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "from datetime import datetime",
            "from typing import Any, Optional",
            "",
            "from sqlalchemy import ARRAY, Column, ForeignKey, String",
            "from sqlalchemy.ext.declarative import declared_attr",
            "from sqlalchemy.orm import Session",
            "",
            "from fides.api.cryptography.cryptographic_util import (",
            "    generate_salt,",
            "    generate_secure_random_string,",
            "    hash_with_salt,",
            ")",
            "from fides.api.cryptography.schemas.jwt import (",
            "    JWE_ISSUED_AT,",
            "    JWE_PAYLOAD_CLIENT_ID,",
            "    JWE_PAYLOAD_CONNECTIONS,",
            "    JWE_PAYLOAD_ROLES,",
            "    JWE_PAYLOAD_SCOPES,",
            "    JWE_PAYLOAD_SYSTEMS,",
            ")",
            "from fides.api.db.base_class import Base",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.oauth.jwt import generate_jwe",
            "from fides.config import FidesConfig",
            "",
            "DEFAULT_SCOPES: list[str] = []",
            "DEFAULT_ROLES: list[str] = []",
            "DEFAULT_SYSTEMS: list[str] = []",
            "DEFAULT_CONNECTIONS: list[str] = []",
            "",
            "",
            "class ClientDetail(Base):",
            "    \"\"\"The persisted details about a client in the system\"\"\"",
            "",
            "    @declared_attr",
            "    def __tablename__(self) -> str:",
            "        return \"client\"",
            "",
            "    hashed_secret = Column(String, nullable=False)",
            "    salt = Column(String, nullable=False)",
            "    scopes = Column(ARRAY(String), nullable=False, server_default=\"{}\", default=dict)",
            "    roles = Column(ARRAY(String), nullable=False, server_default=\"{}\", default=dict)",
            "    systems = Column(ARRAY(String), nullable=False, server_default=\"{}\", default=dict)",
            "    connections = Column(",
            "        ARRAY(String), nullable=False, server_default=\"{}\", default=dict",
            "    )",
            "    fides_key = Column(String, index=True, unique=True, nullable=True)",
            "    user_id = Column(",
            "        String, ForeignKey(FidesUser.id_field_path), nullable=True, unique=True",
            "    )",
            "",
            "    @classmethod",
            "    def create_client_and_secret(",
            "        cls,",
            "        db: Session,",
            "        client_id_byte_length: int,",
            "        client_secret_byte_length: int,",
            "        *,",
            "        scopes: list[str] | None = None,",
            "        fides_key: Optional[str] = None,",
            "        user_id: Optional[str] = None,",
            "        encoding: str = \"UTF-8\",",
            "        roles: list[str] | None = None,",
            "        systems: list[str] | None = None,",
            "        connections: list[str] | None = None,",
            "    ) -> tuple[\"ClientDetail\", str]:",
            "        \"\"\"Creates a ClientDetail and returns that along with the unhashed secret",
            "        so it can be returned to the user on create",
            "        \"\"\"",
            "",
            "        client_id = generate_secure_random_string(client_id_byte_length)",
            "        secret = generate_secure_random_string(client_secret_byte_length)",
            "",
            "        if not scopes:",
            "            scopes = DEFAULT_SCOPES",
            "",
            "        if not roles:",
            "            roles = DEFAULT_ROLES",
            "",
            "        if not systems:",
            "            systems = DEFAULT_SYSTEMS",
            "",
            "        if not connections:",
            "            connections = DEFAULT_CONNECTIONS",
            "",
            "        salt = generate_salt()",
            "        hashed_secret = hash_with_salt(",
            "            secret.encode(encoding),",
            "            salt.encode(encoding),",
            "        )",
            "",
            "        client = super().create(",
            "            db,",
            "            data={",
            "                \"id\": client_id,",
            "                \"salt\": salt,",
            "                \"hashed_secret\": hashed_secret,",
            "                \"scopes\": scopes,",
            "                \"fides_key\": fides_key,",
            "                \"user_id\": user_id,",
            "                \"roles\": roles,",
            "                \"systems\": systems,",
            "                \"connections\": connections,",
            "            },",
            "        )",
            "        return client, secret  # type: ignore",
            "",
            "    @classmethod",
            "    def get(  # type: ignore",
            "        cls,",
            "        db: Session,",
            "        *,",
            "        object_id: Any,",
            "        config: FidesConfig,",
            "        scopes: list[str] = [],",
            "        roles: list[str] = [],",
            "    ) -> ClientDetail | None:",
            "        \"\"\"Fetch a database record via a client_id\"\"\"",
            "        if object_id == config.security.oauth_root_client_id:",
            "            return _get_root_client_detail(config, scopes=scopes, roles=roles)",
            "        return super().get(db, object_id=object_id)",
            "",
            "    def create_access_code_jwe(self, encryption_key: str) -> str:",
            "        \"\"\"Generates a JWE from the client detail provided\"\"\"",
            "        payload = {",
            "            # client id may not be necessary",
            "            JWE_PAYLOAD_CLIENT_ID: self.id,",
            "            JWE_PAYLOAD_SCOPES: self.scopes,",
            "            JWE_ISSUED_AT: datetime.now().isoformat(),",
            "            JWE_PAYLOAD_ROLES: self.roles,",
            "            JWE_PAYLOAD_SYSTEMS: self.systems,",
            "            JWE_PAYLOAD_CONNECTIONS: self.connections,",
            "        }",
            "        return generate_jwe(json.dumps(payload), encryption_key)",
            "",
            "    def credentials_valid(self, provided_secret: str, encoding: str = \"UTF-8\") -> bool:",
            "        \"\"\"Verifies that the provided secret is correct.\"\"\"",
            "        provided_secret_hash = hash_with_salt(",
            "            provided_secret.encode(encoding),",
            "            self.salt.encode(encoding),",
            "        )",
            "",
            "        return provided_secret_hash == self.hashed_secret",
            "",
            "",
            "def _get_root_client_detail(",
            "    config: FidesConfig,",
            "    scopes: list[str],",
            "    roles: list[str],",
            "    encoding: str = \"UTF-8\",",
            ") -> ClientDetail | None:",
            "    \"\"\"",
            "    Return a root ClientDetail",
            "    \"\"\"",
            "    if not config.security.oauth_root_client_secret_hash:",
            "        raise ValueError(\"A root client hash is required\")",
            "",
            "    if scopes or roles:",
            "        return ClientDetail(",
            "            id=config.security.oauth_root_client_id,",
            "            hashed_secret=config.security.oauth_root_client_secret_hash[0],",
            "            salt=config.security.oauth_root_client_secret_hash[1].decode(encoding),",
            "            scopes=scopes,",
            "            roles=roles,",
            "            systems=[],",
            "            connections=[],",
            "        )",
            "",
            "    return ClientDetail(",
            "        id=config.security.oauth_root_client_id,",
            "        hashed_secret=config.security.oauth_root_client_secret_hash[0],",
            "        salt=config.security.oauth_root_client_secret_hash[1].decode(encoding),",
            "        scopes=DEFAULT_SCOPES,",
            "        roles=DEFAULT_ROLES,",
            "        systems=DEFAULT_SYSTEMS,",
            "        connections=DEFAULT_CONNECTIONS,",
            "    )"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "from datetime import datetime",
            "from typing import Any, Optional",
            "",
            "from sqlalchemy import ARRAY, Column, ForeignKey, String",
            "from sqlalchemy.ext.declarative import declared_attr",
            "from sqlalchemy.orm import Session",
            "",
            "from fides.api.cryptography.cryptographic_util import (",
            "    generate_salt,",
            "    generate_secure_random_string,",
            "    hash_with_salt,",
            ")",
            "from fides.api.cryptography.schemas.jwt import (",
            "    JWE_ISSUED_AT,",
            "    JWE_PAYLOAD_CLIENT_ID,",
            "    JWE_PAYLOAD_CONNECTIONS,",
            "    JWE_PAYLOAD_ROLES,",
            "    JWE_PAYLOAD_SCOPES,",
            "    JWE_PAYLOAD_SYSTEMS,",
            ")",
            "from fides.api.db.base_class import Base",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.oauth.jwt import generate_jwe",
            "from fides.config import FidesConfig",
            "",
            "DEFAULT_SCOPES: list[str] = []",
            "DEFAULT_ROLES: list[str] = []",
            "DEFAULT_SYSTEMS: list[str] = []",
            "DEFAULT_CONNECTIONS: list[str] = []",
            "",
            "",
            "class ClientDetail(Base):",
            "    \"\"\"The persisted details about a client in the system\"\"\"",
            "",
            "    @declared_attr",
            "    def __tablename__(self) -> str:",
            "        return \"client\"",
            "",
            "    hashed_secret = Column(String, nullable=False)",
            "    salt = Column(String, nullable=False)",
            "    scopes = Column(ARRAY(String), nullable=False, server_default=\"{}\", default=dict)",
            "    roles = Column(ARRAY(String), nullable=False, server_default=\"{}\", default=dict)",
            "    systems = Column(ARRAY(String), nullable=False, server_default=\"{}\", default=dict)",
            "    connections = Column(",
            "        ARRAY(String), nullable=False, server_default=\"{}\", default=dict",
            "    )",
            "    fides_key = Column(String, index=True, unique=True, nullable=True)",
            "    user_id = Column(",
            "        String, ForeignKey(FidesUser.id_field_path), nullable=True, unique=True",
            "    )",
            "",
            "    @classmethod",
            "    def create_client_and_secret(",
            "        cls,",
            "        db: Session,",
            "        client_id_byte_length: int,",
            "        client_secret_byte_length: int,",
            "        *,",
            "        scopes: list[str] | None = None,",
            "        fides_key: Optional[str] = None,",
            "        user_id: Optional[str] = None,",
            "        encoding: str = \"UTF-8\",",
            "        roles: list[str] | None = None,",
            "        systems: list[str] | None = None,",
            "        connections: list[str] | None = None,",
            "        in_memory: bool | None = False,",
            "    ) -> tuple[\"ClientDetail\", str]:",
            "        \"\"\"Creates a ClientDetail and returns that along with the unhashed secret",
            "        so it can be returned to the user on create",
            "        \"\"\"",
            "",
            "        client_id = generate_secure_random_string(client_id_byte_length)",
            "        secret = generate_secure_random_string(client_secret_byte_length)",
            "",
            "        if not scopes:",
            "            scopes = DEFAULT_SCOPES",
            "",
            "        if not roles:",
            "            roles = DEFAULT_ROLES",
            "",
            "        if not systems:",
            "            systems = DEFAULT_SYSTEMS",
            "",
            "        if not connections:",
            "            connections = DEFAULT_CONNECTIONS",
            "",
            "        salt = generate_salt()",
            "        hashed_secret = hash_with_salt(",
            "            secret.encode(encoding),",
            "            salt.encode(encoding),",
            "        )",
            "",
            "        data = {",
            "            \"id\": client_id,",
            "            \"salt\": salt,",
            "            \"hashed_secret\": hashed_secret,",
            "            \"scopes\": scopes,",
            "            \"fides_key\": fides_key,",
            "            \"user_id\": user_id,",
            "            \"roles\": roles,",
            "            \"systems\": systems,",
            "            \"connections\": connections,",
            "        }",
            "",
            "        if in_memory:",
            "            client = ClientDetail(",
            "                **data",
            "            )  # For creating a temporary ClientDetail for invalid user login flow",
            "        else:",
            "            client = super().create(",
            "                db,",
            "                data=data,",
            "            )",
            "        return client, secret  # type: ignore",
            "",
            "    @classmethod",
            "    def get(  # type: ignore",
            "        cls,",
            "        db: Session,",
            "        *,",
            "        object_id: Any,",
            "        config: FidesConfig,",
            "        scopes: list[str] = [],",
            "        roles: list[str] = [],",
            "    ) -> ClientDetail | None:",
            "        \"\"\"Fetch a database record via a client_id\"\"\"",
            "        if object_id == config.security.oauth_root_client_id:",
            "            return _get_root_client_detail(config, scopes=scopes, roles=roles)",
            "        return super().get(db, object_id=object_id)",
            "",
            "    def create_access_code_jwe(self, encryption_key: str) -> str:",
            "        \"\"\"Generates a JWE from the client detail provided\"\"\"",
            "        payload = {",
            "            # client id may not be necessary",
            "            JWE_PAYLOAD_CLIENT_ID: self.id,",
            "            JWE_PAYLOAD_SCOPES: self.scopes,",
            "            JWE_ISSUED_AT: datetime.now().isoformat(),",
            "            JWE_PAYLOAD_ROLES: self.roles,",
            "            JWE_PAYLOAD_SYSTEMS: self.systems,",
            "            JWE_PAYLOAD_CONNECTIONS: self.connections,",
            "        }",
            "        return generate_jwe(json.dumps(payload), encryption_key)",
            "",
            "    def credentials_valid(self, provided_secret: str, encoding: str = \"UTF-8\") -> bool:",
            "        \"\"\"Verifies that the provided secret is correct.\"\"\"",
            "        provided_secret_hash = hash_with_salt(",
            "            provided_secret.encode(encoding),",
            "            self.salt.encode(encoding),",
            "        )",
            "",
            "        return provided_secret_hash == self.hashed_secret",
            "",
            "",
            "def _get_root_client_detail(",
            "    config: FidesConfig,",
            "    scopes: list[str],",
            "    roles: list[str],",
            "    encoding: str = \"UTF-8\",",
            ") -> ClientDetail | None:",
            "    \"\"\"",
            "    Return a root ClientDetail",
            "    \"\"\"",
            "    if not config.security.oauth_root_client_secret_hash:",
            "        raise ValueError(\"A root client hash is required\")",
            "",
            "    if scopes or roles:",
            "        return ClientDetail(",
            "            id=config.security.oauth_root_client_id,",
            "            hashed_secret=config.security.oauth_root_client_secret_hash[0],",
            "            salt=config.security.oauth_root_client_secret_hash[1].decode(encoding),",
            "            scopes=scopes,",
            "            roles=roles,",
            "            systems=[],",
            "            connections=[],",
            "        )",
            "",
            "    return ClientDetail(",
            "        id=config.security.oauth_root_client_id,",
            "        hashed_secret=config.security.oauth_root_client_secret_hash[0],",
            "        salt=config.security.oauth_root_client_secret_hash[1].decode(encoding),",
            "        scopes=DEFAULT_SCOPES,",
            "        roles=DEFAULT_ROLES,",
            "        systems=DEFAULT_SYSTEMS,",
            "        connections=DEFAULT_CONNECTIONS,",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "95": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "96": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "97": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "98": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "99": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "100": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "101": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "102": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "103": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "104": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "105": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "106": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "107": [
                "ClientDetail",
                "create_client_and_secret"
            ],
            "108": [
                "ClientDetail",
                "create_client_and_secret"
            ]
        },
        "addLocation": [
            "numpy.lib.tests.test_io.TestFromTxt"
        ]
    },
    "src/fides/api/oauth/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from fides.api.api.deps import get_db"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from fides.api.common_exceptions import AuthenticationError, AuthorizationError"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from fides.api.cryptography.cryptographic_util import generate_secure_random_string"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from fides.api.cryptography.schemas.jwt import ("
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     JWE_ISSUED_AT,"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     JWE_PAYLOAD_CLIENT_ID,"
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " )"
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from fides.api.models.client import ClientDetail"
            },
            "9": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from fides.api.models.fides_user import FidesUser"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from fides.api.models.fides_user_permissions import FidesUserPermissions"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from fides.api.models.policy import PolicyPreWebhook"
            },
            "12": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from fides.api.models.pre_approval_webhook import PreApprovalWebhook"
            },
            "13": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from fides.api.models.privacy_request import RequestTask"
            },
            "14": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from fides.api.oauth.roles import get_scopes_from_roles"
            },
            "15": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from fides.api.schemas.external_https import RequestTaskJWE, WebhookJWE"
            },
            "16": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from fides.api.schemas.oauth import OAuth2ClientCredentialsBearer"
            },
            "17": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " from fides.common.api.v1.urn_registry import TOKEN, V1_URL_PREFIX"
            },
            "18": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from fides.config import CONFIG"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+from fides.config import CONFIG, FidesConfig"
            },
            "20": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " JWT_ENCRYPTION_ALGORITHM = ALGORITHMS.A256GCM"
            },
            "22": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "     return True"
            },
            "24": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 398,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 399,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+def create_temporary_user_for_login_flow(config: FidesConfig) -> FidesUser:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+    \"\"\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+    Create a temporary FidesUser in-memory with an attached in-memory ClientDetail"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+    and attached in-memory FidesUserPermissions"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+    This is for reducing the time differences in the user login flow between a"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+    valid and an invalid user"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+    \"\"\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+    hashed_password, salt = FidesUser.hash_password(generate_secure_random_string(16))"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+    user = FidesUser("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        **{"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+            \"salt\": salt,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+            \"hashed_password\": hashed_password,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+            \"username\": \"temp_user\","
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+            \"email_address\": \"temp_user@example.com\","
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+            \"first_name\": \"temp_first_name\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+            \"last_name\": \"temp_surname\","
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+            \"disabled\": True,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        }"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+    )"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+    # Create in-memory user permissions"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+    user.permissions = FidesUserPermissions(  # type: ignore[attr-defined]"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+        id=\"temp_user_id\","
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+        user_id=\"temp_user_id\","
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+        roles=[\"fake_role\"],"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+    )"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+    # Create in-memory client, not persisted to db"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+    client, _ = ClientDetail.create_client_and_secret("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+        None,  # type: ignore[arg-type]"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 431,
                "PatchRowcode": "+        config.security.oauth_client_id_length_bytes,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 432,
                "PatchRowcode": "+        config.security.oauth_client_secret_length_bytes,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 433,
                "PatchRowcode": "+        scopes=[],  # type: ignore"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 434,
                "PatchRowcode": "+        roles=user.permissions.roles,  # type: ignore"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 435,
                "PatchRowcode": "+        systems=user.system_ids,  # type: ignore"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+        user_id=\"temp_user_id\","
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+        in_memory=True,"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+    )"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+    user.client = client"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+    return user"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 445,
                "PatchRowcode": " # This allows us to selectively enforce auth depending on user environment settings"
            },
            "72": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 446,
                "PatchRowcode": " verify_oauth_client_prod = copy_func(verify_oauth_client)"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "from datetime import datetime",
            "from functools import update_wrapper",
            "from types import FunctionType",
            "from typing import Any, Callable, Dict, List, Optional, Tuple",
            "",
            "from fastapi import Depends, HTTPException, Security",
            "from fastapi.security import SecurityScopes",
            "from jose import exceptions, jwe",
            "from jose.constants import ALGORITHMS",
            "from loguru import logger",
            "from pydantic import ValidationError",
            "from sqlalchemy.orm import Session",
            "from starlette.status import HTTP_404_NOT_FOUND",
            "",
            "from fides.api.api.deps import get_db",
            "from fides.api.common_exceptions import AuthenticationError, AuthorizationError",
            "from fides.api.cryptography.schemas.jwt import (",
            "    JWE_ISSUED_AT,",
            "    JWE_PAYLOAD_CLIENT_ID,",
            "    JWE_PAYLOAD_ROLES,",
            "    JWE_PAYLOAD_SCOPES,",
            ")",
            "from fides.api.models.client import ClientDetail",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.models.policy import PolicyPreWebhook",
            "from fides.api.models.pre_approval_webhook import PreApprovalWebhook",
            "from fides.api.models.privacy_request import RequestTask",
            "from fides.api.oauth.roles import get_scopes_from_roles",
            "from fides.api.schemas.external_https import RequestTaskJWE, WebhookJWE",
            "from fides.api.schemas.oauth import OAuth2ClientCredentialsBearer",
            "from fides.common.api.v1.urn_registry import TOKEN, V1_URL_PREFIX",
            "from fides.config import CONFIG",
            "",
            "JWT_ENCRYPTION_ALGORITHM = ALGORITHMS.A256GCM",
            "",
            "",
            "# TODO: include list of all scopes in the docs via the scopes={} dict",
            "# (see https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/)",
            "oauth2_scheme = OAuth2ClientCredentialsBearer(",
            "    tokenUrl=(V1_URL_PREFIX + TOKEN),",
            ")",
            "",
            "",
            "def extract_payload(jwe_string: str, encryption_key: str) -> str:",
            "    \"\"\"Given a jwe, extracts the payload and returns it in string form.\"\"\"",
            "    return jwe.decrypt(jwe_string, encryption_key)",
            "",
            "",
            "def is_token_expired(issued_at: datetime | None, token_duration_min: int) -> bool:",
            "    \"\"\"Returns True if the datetime is earlier than token_duration_min ago.\"\"\"",
            "    if not issued_at:",
            "        return True",
            "",
            "    return (datetime.now() - issued_at).total_seconds() / 60.0 > token_duration_min",
            "",
            "",
            "def copy_func(source_function: Callable) -> Callable:",
            "    \"\"\"Based on http://stackoverflow.com/a/6528148/190597 (Glenn Maynard)\"\"\"",
            "    target_function = FunctionType(",
            "        source_function.__code__,",
            "        source_function.__globals__,",
            "        name=source_function.__name__,",
            "        argdefs=source_function.__defaults__,",
            "        closure=source_function.__closure__,",
            "    )",
            "    updated_target_function: Callable = update_wrapper(target_function, source_function)",
            "    updated_target_function.__kwdefaults__ = source_function.__kwdefaults__",
            "    return updated_target_function",
            "",
            "",
            "async def get_current_user(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> FidesUser:",
            "    \"\"\"A wrapper around verify_oauth_client that returns that client's user if one exists.\"\"\"",
            "    client = await verify_oauth_client(",
            "        security_scopes=security_scopes,",
            "        authorization=authorization,",
            "        db=db,",
            "    )",
            "",
            "    if client.id == CONFIG.security.oauth_root_client_id:",
            "        return FidesUser(",
            "            id=CONFIG.security.oauth_root_client_id,",
            "            username=CONFIG.security.root_username,",
            "            created_at=datetime.utcnow(),",
            "        )",
            "",
            "    return client.user  # type: ignore[attr-defined]",
            "",
            "",
            "def is_callback_token_expired(issued_at: datetime | None) -> bool:",
            "    \"\"\"Returns True if the token is older than the expiration of the redis cache.  We",
            "    can't resume executing the privacy request if the identity data is gone.",
            "    \"\"\"",
            "    if not issued_at:",
            "        return True",
            "",
            "    return (",
            "        datetime.now() - issued_at",
            "    ).total_seconds() / 60.0 > CONFIG.execution.privacy_request_delay_timeout",
            "",
            "",
            "def _get_webhook_jwe_or_error(",
            "    security_scopes: SecurityScopes, authorization: str = Security(oauth2_scheme)",
            ") -> WebhookJWE:",
            "    if authorization is None:",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    token_data = json.loads(",
            "        extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "    )",
            "    try:",
            "        token = WebhookJWE(**token_data)",
            "    except ValidationError:",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    assigned_scopes = token_data[JWE_PAYLOAD_SCOPES]",
            "    if not set(security_scopes.scopes).issubset(assigned_scopes):",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    if is_callback_token_expired(datetime.fromisoformat(token.iat)):",
            "        raise AuthorizationError(detail=\"Webhook token expired\")",
            "",
            "    return token",
            "",
            "",
            "def _get_request_task_jwe_or_error(",
            "    security_scopes: SecurityScopes, authorization: str = Security(oauth2_scheme)",
            ") -> RequestTaskJWE:",
            "    if authorization is None:",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    try:",
            "        token_data = json.loads(",
            "            extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "        )",
            "    except exceptions.JWEError:",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    try:",
            "        token = RequestTaskJWE(**token_data)",
            "    except ValidationError:",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    assigned_scopes = token_data[JWE_PAYLOAD_SCOPES]",
            "    if not set(security_scopes.scopes).issubset(assigned_scopes):",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    if is_callback_token_expired(datetime.fromisoformat(token.iat)):",
            "        raise AuthorizationError(detail=\"Request Task token expired\")",
            "",
            "    return token",
            "",
            "",
            "def verify_callback_oauth_policy_pre_webhook(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> PolicyPreWebhook:",
            "    \"\"\"",
            "    Verifies the specific token that accompanies a request when the caller wants to resume executing a",
            "    PrivacyRequest after it was paused by a webhook.",
            "",
            "    Note that this token was sent along with the request when calling the webhook originally.",
            "    Verifies that the webhook token hasn't expired and loads the webhook from that token.",
            "    Also verifies scopes, but note that this was given to the user in a request header and they've",
            "    just returned it back.",
            "    \"\"\"",
            "    token = _get_webhook_jwe_or_error(security_scopes, authorization)",
            "",
            "    webhook = PolicyPreWebhook.get_by(db, field=\"id\", value=token.webhook_id)",
            "",
            "    if not webhook:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No Policy Pre-Execution Webhook found with id '{token.webhook_id}'.\",",
            "        )",
            "    return webhook",
            "",
            "",
            "def verify_callback_oauth_pre_approval_webhook(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> PreApprovalWebhook:",
            "    \"\"\"",
            "    Verifies the specific token that accompanies a request when the caller wants to mark a PrivacyRequest",
            "    as eligible or not eligible for pre-approval.",
            "",
            "    Note that this token was sent along with the request when calling the webhook originally.",
            "    Verifies that the webhook token hasn't expired and loads the webhook from that token.",
            "    Also verifies scopes, but note that this was given to the user in a request header and they've",
            "    just returned it back.",
            "    \"\"\"",
            "    token = _get_webhook_jwe_or_error(security_scopes, authorization)",
            "",
            "    webhook = PreApprovalWebhook.get_by(db, field=\"id\", value=token.webhook_id)",
            "",
            "    if not webhook:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No Pre-Approval Webhook found with id '{token.webhook_id}'.\",",
            "        )",
            "    return webhook",
            "",
            "",
            "def verify_request_task_callback(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> RequestTask:",
            "    \"\"\"",
            "    Verifies that the specific token when the request task callback endpoint is hit is valid.",
            "    Loads the Request Task included in the token",
            "    \"\"\"",
            "    token = _get_request_task_jwe_or_error(security_scopes, authorization)",
            "",
            "    request_task = RequestTask.get_by(db, field=\"id\", value=token.request_task_id)",
            "",
            "    if not request_task:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No Request Task found with id '{token.request_task_id}'.\",",
            "        )",
            "    return request_task",
            "",
            "",
            "async def get_root_client(",
            "    db: Session = Depends(get_db), client_id: str = CONFIG.security.oauth_root_client_id",
            ") -> ClientDetail:",
            "    \"\"\"",
            "    Gets the root_client directly.",
            "",
            "    This function is primarily used to let users bypass endpoint authorization",
            "    \"\"\"",
            "    client = ClientDetail.get(",
            "        db,",
            "        object_id=client_id,",
            "        config=CONFIG,",
            "        scopes=CONFIG.security.root_user_scopes,",
            "        roles=CONFIG.security.root_user_roles,",
            "    )",
            "    if not client:",
            "        logger.debug(\"Auth token belongs to an invalid client_id.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "    return client",
            "",
            "",
            "async def verify_oauth_client(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> ClientDetail:",
            "    \"\"\"",
            "    Verifies that the access token provided in the authorization header contains",
            "    the necessary scopes or roles specified by the caller. Yields a 403 forbidden error",
            "    if not.",
            "",
            "    NOTE: This function may be overwritten in `main.py` when changing",
            "    the security environment.",
            "    \"\"\"",
            "    token_data, client = extract_token_and_load_client(authorization, db)",
            "    if not has_permissions(",
            "        token_data=token_data, client=client, endpoint_scopes=security_scopes",
            "    ):",
            "        raise AuthorizationError(",
            "            detail=f\"Not Authorized for this action. Required scope(s): [{', '.join(security_scopes.scopes)}]\"",
            "        )",
            "",
            "    return client",
            "",
            "",
            "def extract_token_and_load_client(",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            "    *,",
            "    token_duration_override: Optional[int] = None,",
            ") -> Tuple[Dict, ClientDetail]:",
            "    \"\"\"Extract the token, verify it's valid, and likewise load the client as part of authorization\"\"\"",
            "    if authorization is None:",
            "        logger.debug(\"No authorization supplied.\")",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    try:",
            "        token_data = json.loads(",
            "            extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "        )",
            "    except exceptions.JWEParseError as exc:",
            "        logger.debug(\"Unable to parse auth token.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\") from exc",
            "",
            "    issued_at = token_data.get(JWE_ISSUED_AT, None)",
            "    if not issued_at:",
            "        logger.debug(\"Auth token expired.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    if is_token_expired(",
            "        datetime.fromisoformat(issued_at),",
            "        token_duration_override or CONFIG.security.oauth_access_token_expire_minutes,",
            "    ):",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    client_id = token_data.get(JWE_PAYLOAD_CLIENT_ID)",
            "    if not client_id:",
            "        logger.debug(\"No client_id included in auth token.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    # scopes/roles param is only used if client is root client, otherwise we use the client's associated scopes",
            "    client = ClientDetail.get(",
            "        db,",
            "        object_id=client_id,",
            "        config=CONFIG,",
            "        scopes=CONFIG.security.root_user_scopes,",
            "        roles=CONFIG.security.root_user_roles,",
            "    )",
            "",
            "    if not client:",
            "        logger.debug(\"Auth token belongs to an invalid client_id.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    return token_data, client",
            "",
            "",
            "def has_permissions(",
            "    token_data: Dict[str, Any], client: ClientDetail, endpoint_scopes: SecurityScopes",
            ") -> bool:",
            "    \"\"\"Does the user have the necessary scopes, either via a scope they were assigned directly,",
            "    or a scope associated with their role(s)?\"\"\"",
            "    has_direct_scope: bool = _has_direct_scopes(",
            "        token_data=token_data, client=client, endpoint_scopes=endpoint_scopes",
            "    )",
            "    has_role: bool = _has_scope_via_role(",
            "        token_data=token_data, client=client, endpoint_scopes=endpoint_scopes",
            "    )",
            "    return has_direct_scope or has_role",
            "",
            "",
            "def _has_scope_via_role(",
            "    token_data: Dict[str, Any], client: ClientDetail, endpoint_scopes: SecurityScopes",
            ") -> bool:",
            "    \"\"\"Does the user have the required scopes indirectly via a role and is the token valid?\"\"\"",
            "    assigned_roles: List[str] = token_data.get(JWE_PAYLOAD_ROLES, [])",
            "    associated_scopes: List[str] = get_scopes_from_roles(assigned_roles)",
            "",
            "    if not has_scope_subset(",
            "        user_scopes=associated_scopes, endpoint_scopes=endpoint_scopes",
            "    ):",
            "        return False",
            "",
            "    if not set(assigned_roles).issubset(set(client.roles or [])):",
            "        # If the roles on the token are not a subset of the roles available",
            "        # one the associated oauth client, this token is not valid",
            "        logger.debug(\"Client no longer allowed to issue these roles.\")",
            "        return False",
            "",
            "    return True",
            "",
            "",
            "def _has_direct_scopes(",
            "    token_data: Dict[str, Any], client: ClientDetail, endpoint_scopes: SecurityScopes",
            ") -> bool:",
            "    \"\"\"Does the token have the required scopes directly and is the token still valid?\"\"\"",
            "    assigned_scopes: List[str] = token_data.get(JWE_PAYLOAD_SCOPES, [])",
            "",
            "    if not has_scope_subset(",
            "        user_scopes=assigned_scopes, endpoint_scopes=endpoint_scopes",
            "    ):",
            "        return False",
            "",
            "    if not set(assigned_scopes).issubset(set(client.scopes or [])):",
            "        # If the scopes on the token are not a subset of the scopes available",
            "        # to the associated oauth client, this token is not valid",
            "        logger.debug(\"Client no longer allowed to issue these scopes.\")",
            "        return False",
            "",
            "    return True",
            "",
            "",
            "def has_scope_subset(user_scopes: List[str], endpoint_scopes: SecurityScopes) -> bool:",
            "    \"\"\"Are the required scopes a subset of the scopes belonging to the user?\"\"\"",
            "    if not set(endpoint_scopes.scopes).issubset(user_scopes):",
            "        scopes_required = \",\".join(endpoint_scopes.scopes)",
            "        scopes_provided = \",\".join(user_scopes)",
            "        logger.debug(",
            "            \"Auth token missing required scopes: {}. Scopes provided: {}.\",",
            "            scopes_required,",
            "            scopes_provided,",
            "        )",
            "        return False",
            "    return True",
            "",
            "",
            "# This allows us to selectively enforce auth depending on user environment settings",
            "verify_oauth_client_prod = copy_func(verify_oauth_client)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "from datetime import datetime",
            "from functools import update_wrapper",
            "from types import FunctionType",
            "from typing import Any, Callable, Dict, List, Optional, Tuple",
            "",
            "from fastapi import Depends, HTTPException, Security",
            "from fastapi.security import SecurityScopes",
            "from jose import exceptions, jwe",
            "from jose.constants import ALGORITHMS",
            "from loguru import logger",
            "from pydantic import ValidationError",
            "from sqlalchemy.orm import Session",
            "from starlette.status import HTTP_404_NOT_FOUND",
            "",
            "from fides.api.api.deps import get_db",
            "from fides.api.common_exceptions import AuthenticationError, AuthorizationError",
            "from fides.api.cryptography.cryptographic_util import generate_secure_random_string",
            "from fides.api.cryptography.schemas.jwt import (",
            "    JWE_ISSUED_AT,",
            "    JWE_PAYLOAD_CLIENT_ID,",
            "    JWE_PAYLOAD_ROLES,",
            "    JWE_PAYLOAD_SCOPES,",
            ")",
            "from fides.api.models.client import ClientDetail",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.models.fides_user_permissions import FidesUserPermissions",
            "from fides.api.models.policy import PolicyPreWebhook",
            "from fides.api.models.pre_approval_webhook import PreApprovalWebhook",
            "from fides.api.models.privacy_request import RequestTask",
            "from fides.api.oauth.roles import get_scopes_from_roles",
            "from fides.api.schemas.external_https import RequestTaskJWE, WebhookJWE",
            "from fides.api.schemas.oauth import OAuth2ClientCredentialsBearer",
            "from fides.common.api.v1.urn_registry import TOKEN, V1_URL_PREFIX",
            "from fides.config import CONFIG, FidesConfig",
            "",
            "JWT_ENCRYPTION_ALGORITHM = ALGORITHMS.A256GCM",
            "",
            "",
            "# TODO: include list of all scopes in the docs via the scopes={} dict",
            "# (see https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/)",
            "oauth2_scheme = OAuth2ClientCredentialsBearer(",
            "    tokenUrl=(V1_URL_PREFIX + TOKEN),",
            ")",
            "",
            "",
            "def extract_payload(jwe_string: str, encryption_key: str) -> str:",
            "    \"\"\"Given a jwe, extracts the payload and returns it in string form.\"\"\"",
            "    return jwe.decrypt(jwe_string, encryption_key)",
            "",
            "",
            "def is_token_expired(issued_at: datetime | None, token_duration_min: int) -> bool:",
            "    \"\"\"Returns True if the datetime is earlier than token_duration_min ago.\"\"\"",
            "    if not issued_at:",
            "        return True",
            "",
            "    return (datetime.now() - issued_at).total_seconds() / 60.0 > token_duration_min",
            "",
            "",
            "def copy_func(source_function: Callable) -> Callable:",
            "    \"\"\"Based on http://stackoverflow.com/a/6528148/190597 (Glenn Maynard)\"\"\"",
            "    target_function = FunctionType(",
            "        source_function.__code__,",
            "        source_function.__globals__,",
            "        name=source_function.__name__,",
            "        argdefs=source_function.__defaults__,",
            "        closure=source_function.__closure__,",
            "    )",
            "    updated_target_function: Callable = update_wrapper(target_function, source_function)",
            "    updated_target_function.__kwdefaults__ = source_function.__kwdefaults__",
            "    return updated_target_function",
            "",
            "",
            "async def get_current_user(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> FidesUser:",
            "    \"\"\"A wrapper around verify_oauth_client that returns that client's user if one exists.\"\"\"",
            "    client = await verify_oauth_client(",
            "        security_scopes=security_scopes,",
            "        authorization=authorization,",
            "        db=db,",
            "    )",
            "",
            "    if client.id == CONFIG.security.oauth_root_client_id:",
            "        return FidesUser(",
            "            id=CONFIG.security.oauth_root_client_id,",
            "            username=CONFIG.security.root_username,",
            "            created_at=datetime.utcnow(),",
            "        )",
            "",
            "    return client.user  # type: ignore[attr-defined]",
            "",
            "",
            "def is_callback_token_expired(issued_at: datetime | None) -> bool:",
            "    \"\"\"Returns True if the token is older than the expiration of the redis cache.  We",
            "    can't resume executing the privacy request if the identity data is gone.",
            "    \"\"\"",
            "    if not issued_at:",
            "        return True",
            "",
            "    return (",
            "        datetime.now() - issued_at",
            "    ).total_seconds() / 60.0 > CONFIG.execution.privacy_request_delay_timeout",
            "",
            "",
            "def _get_webhook_jwe_or_error(",
            "    security_scopes: SecurityScopes, authorization: str = Security(oauth2_scheme)",
            ") -> WebhookJWE:",
            "    if authorization is None:",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    token_data = json.loads(",
            "        extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "    )",
            "    try:",
            "        token = WebhookJWE(**token_data)",
            "    except ValidationError:",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    assigned_scopes = token_data[JWE_PAYLOAD_SCOPES]",
            "    if not set(security_scopes.scopes).issubset(assigned_scopes):",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    if is_callback_token_expired(datetime.fromisoformat(token.iat)):",
            "        raise AuthorizationError(detail=\"Webhook token expired\")",
            "",
            "    return token",
            "",
            "",
            "def _get_request_task_jwe_or_error(",
            "    security_scopes: SecurityScopes, authorization: str = Security(oauth2_scheme)",
            ") -> RequestTaskJWE:",
            "    if authorization is None:",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    try:",
            "        token_data = json.loads(",
            "            extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "        )",
            "    except exceptions.JWEError:",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    try:",
            "        token = RequestTaskJWE(**token_data)",
            "    except ValidationError:",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    assigned_scopes = token_data[JWE_PAYLOAD_SCOPES]",
            "    if not set(security_scopes.scopes).issubset(assigned_scopes):",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    if is_callback_token_expired(datetime.fromisoformat(token.iat)):",
            "        raise AuthorizationError(detail=\"Request Task token expired\")",
            "",
            "    return token",
            "",
            "",
            "def verify_callback_oauth_policy_pre_webhook(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> PolicyPreWebhook:",
            "    \"\"\"",
            "    Verifies the specific token that accompanies a request when the caller wants to resume executing a",
            "    PrivacyRequest after it was paused by a webhook.",
            "",
            "    Note that this token was sent along with the request when calling the webhook originally.",
            "    Verifies that the webhook token hasn't expired and loads the webhook from that token.",
            "    Also verifies scopes, but note that this was given to the user in a request header and they've",
            "    just returned it back.",
            "    \"\"\"",
            "    token = _get_webhook_jwe_or_error(security_scopes, authorization)",
            "",
            "    webhook = PolicyPreWebhook.get_by(db, field=\"id\", value=token.webhook_id)",
            "",
            "    if not webhook:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No Policy Pre-Execution Webhook found with id '{token.webhook_id}'.\",",
            "        )",
            "    return webhook",
            "",
            "",
            "def verify_callback_oauth_pre_approval_webhook(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> PreApprovalWebhook:",
            "    \"\"\"",
            "    Verifies the specific token that accompanies a request when the caller wants to mark a PrivacyRequest",
            "    as eligible or not eligible for pre-approval.",
            "",
            "    Note that this token was sent along with the request when calling the webhook originally.",
            "    Verifies that the webhook token hasn't expired and loads the webhook from that token.",
            "    Also verifies scopes, but note that this was given to the user in a request header and they've",
            "    just returned it back.",
            "    \"\"\"",
            "    token = _get_webhook_jwe_or_error(security_scopes, authorization)",
            "",
            "    webhook = PreApprovalWebhook.get_by(db, field=\"id\", value=token.webhook_id)",
            "",
            "    if not webhook:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No Pre-Approval Webhook found with id '{token.webhook_id}'.\",",
            "        )",
            "    return webhook",
            "",
            "",
            "def verify_request_task_callback(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> RequestTask:",
            "    \"\"\"",
            "    Verifies that the specific token when the request task callback endpoint is hit is valid.",
            "    Loads the Request Task included in the token",
            "    \"\"\"",
            "    token = _get_request_task_jwe_or_error(security_scopes, authorization)",
            "",
            "    request_task = RequestTask.get_by(db, field=\"id\", value=token.request_task_id)",
            "",
            "    if not request_task:",
            "        raise HTTPException(",
            "            status_code=HTTP_404_NOT_FOUND,",
            "            detail=f\"No Request Task found with id '{token.request_task_id}'.\",",
            "        )",
            "    return request_task",
            "",
            "",
            "async def get_root_client(",
            "    db: Session = Depends(get_db), client_id: str = CONFIG.security.oauth_root_client_id",
            ") -> ClientDetail:",
            "    \"\"\"",
            "    Gets the root_client directly.",
            "",
            "    This function is primarily used to let users bypass endpoint authorization",
            "    \"\"\"",
            "    client = ClientDetail.get(",
            "        db,",
            "        object_id=client_id,",
            "        config=CONFIG,",
            "        scopes=CONFIG.security.root_user_scopes,",
            "        roles=CONFIG.security.root_user_roles,",
            "    )",
            "    if not client:",
            "        logger.debug(\"Auth token belongs to an invalid client_id.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "    return client",
            "",
            "",
            "async def verify_oauth_client(",
            "    security_scopes: SecurityScopes,",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            ") -> ClientDetail:",
            "    \"\"\"",
            "    Verifies that the access token provided in the authorization header contains",
            "    the necessary scopes or roles specified by the caller. Yields a 403 forbidden error",
            "    if not.",
            "",
            "    NOTE: This function may be overwritten in `main.py` when changing",
            "    the security environment.",
            "    \"\"\"",
            "    token_data, client = extract_token_and_load_client(authorization, db)",
            "    if not has_permissions(",
            "        token_data=token_data, client=client, endpoint_scopes=security_scopes",
            "    ):",
            "        raise AuthorizationError(",
            "            detail=f\"Not Authorized for this action. Required scope(s): [{', '.join(security_scopes.scopes)}]\"",
            "        )",
            "",
            "    return client",
            "",
            "",
            "def extract_token_and_load_client(",
            "    authorization: str = Security(oauth2_scheme),",
            "    db: Session = Depends(get_db),",
            "    *,",
            "    token_duration_override: Optional[int] = None,",
            ") -> Tuple[Dict, ClientDetail]:",
            "    \"\"\"Extract the token, verify it's valid, and likewise load the client as part of authorization\"\"\"",
            "    if authorization is None:",
            "        logger.debug(\"No authorization supplied.\")",
            "        raise AuthenticationError(detail=\"Authentication Failure\")",
            "",
            "    try:",
            "        token_data = json.loads(",
            "            extract_payload(authorization, CONFIG.security.app_encryption_key)",
            "        )",
            "    except exceptions.JWEParseError as exc:",
            "        logger.debug(\"Unable to parse auth token.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\") from exc",
            "",
            "    issued_at = token_data.get(JWE_ISSUED_AT, None)",
            "    if not issued_at:",
            "        logger.debug(\"Auth token expired.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    if is_token_expired(",
            "        datetime.fromisoformat(issued_at),",
            "        token_duration_override or CONFIG.security.oauth_access_token_expire_minutes,",
            "    ):",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    client_id = token_data.get(JWE_PAYLOAD_CLIENT_ID)",
            "    if not client_id:",
            "        logger.debug(\"No client_id included in auth token.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    # scopes/roles param is only used if client is root client, otherwise we use the client's associated scopes",
            "    client = ClientDetail.get(",
            "        db,",
            "        object_id=client_id,",
            "        config=CONFIG,",
            "        scopes=CONFIG.security.root_user_scopes,",
            "        roles=CONFIG.security.root_user_roles,",
            "    )",
            "",
            "    if not client:",
            "        logger.debug(\"Auth token belongs to an invalid client_id.\")",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    return token_data, client",
            "",
            "",
            "def has_permissions(",
            "    token_data: Dict[str, Any], client: ClientDetail, endpoint_scopes: SecurityScopes",
            ") -> bool:",
            "    \"\"\"Does the user have the necessary scopes, either via a scope they were assigned directly,",
            "    or a scope associated with their role(s)?\"\"\"",
            "    has_direct_scope: bool = _has_direct_scopes(",
            "        token_data=token_data, client=client, endpoint_scopes=endpoint_scopes",
            "    )",
            "    has_role: bool = _has_scope_via_role(",
            "        token_data=token_data, client=client, endpoint_scopes=endpoint_scopes",
            "    )",
            "    return has_direct_scope or has_role",
            "",
            "",
            "def _has_scope_via_role(",
            "    token_data: Dict[str, Any], client: ClientDetail, endpoint_scopes: SecurityScopes",
            ") -> bool:",
            "    \"\"\"Does the user have the required scopes indirectly via a role and is the token valid?\"\"\"",
            "    assigned_roles: List[str] = token_data.get(JWE_PAYLOAD_ROLES, [])",
            "    associated_scopes: List[str] = get_scopes_from_roles(assigned_roles)",
            "",
            "    if not has_scope_subset(",
            "        user_scopes=associated_scopes, endpoint_scopes=endpoint_scopes",
            "    ):",
            "        return False",
            "",
            "    if not set(assigned_roles).issubset(set(client.roles or [])):",
            "        # If the roles on the token are not a subset of the roles available",
            "        # one the associated oauth client, this token is not valid",
            "        logger.debug(\"Client no longer allowed to issue these roles.\")",
            "        return False",
            "",
            "    return True",
            "",
            "",
            "def _has_direct_scopes(",
            "    token_data: Dict[str, Any], client: ClientDetail, endpoint_scopes: SecurityScopes",
            ") -> bool:",
            "    \"\"\"Does the token have the required scopes directly and is the token still valid?\"\"\"",
            "    assigned_scopes: List[str] = token_data.get(JWE_PAYLOAD_SCOPES, [])",
            "",
            "    if not has_scope_subset(",
            "        user_scopes=assigned_scopes, endpoint_scopes=endpoint_scopes",
            "    ):",
            "        return False",
            "",
            "    if not set(assigned_scopes).issubset(set(client.scopes or [])):",
            "        # If the scopes on the token are not a subset of the scopes available",
            "        # to the associated oauth client, this token is not valid",
            "        logger.debug(\"Client no longer allowed to issue these scopes.\")",
            "        return False",
            "",
            "    return True",
            "",
            "",
            "def has_scope_subset(user_scopes: List[str], endpoint_scopes: SecurityScopes) -> bool:",
            "    \"\"\"Are the required scopes a subset of the scopes belonging to the user?\"\"\"",
            "    if not set(endpoint_scopes.scopes).issubset(user_scopes):",
            "        scopes_required = \",\".join(endpoint_scopes.scopes)",
            "        scopes_provided = \",\".join(user_scopes)",
            "        logger.debug(",
            "            \"Auth token missing required scopes: {}. Scopes provided: {}.\",",
            "            scopes_required,",
            "            scopes_provided,",
            "        )",
            "        return False",
            "    return True",
            "",
            "",
            "def create_temporary_user_for_login_flow(config: FidesConfig) -> FidesUser:",
            "    \"\"\"",
            "    Create a temporary FidesUser in-memory with an attached in-memory ClientDetail",
            "    and attached in-memory FidesUserPermissions",
            "",
            "    This is for reducing the time differences in the user login flow between a",
            "    valid and an invalid user",
            "    \"\"\"",
            "    hashed_password, salt = FidesUser.hash_password(generate_secure_random_string(16))",
            "    user = FidesUser(",
            "        **{",
            "            \"salt\": salt,",
            "            \"hashed_password\": hashed_password,",
            "            \"username\": \"temp_user\",",
            "            \"email_address\": \"temp_user@example.com\",",
            "            \"first_name\": \"temp_first_name\",",
            "            \"last_name\": \"temp_surname\",",
            "            \"disabled\": True,",
            "        }",
            "    )",
            "",
            "    # Create in-memory user permissions",
            "    user.permissions = FidesUserPermissions(  # type: ignore[attr-defined]",
            "        id=\"temp_user_id\",",
            "        user_id=\"temp_user_id\",",
            "        roles=[\"fake_role\"],",
            "    )",
            "",
            "    # Create in-memory client, not persisted to db",
            "    client, _ = ClientDetail.create_client_and_secret(",
            "        None,  # type: ignore[arg-type]",
            "        config.security.oauth_client_id_length_bytes,",
            "        config.security.oauth_client_secret_length_bytes,",
            "        scopes=[],  # type: ignore",
            "        roles=user.permissions.roles,  # type: ignore",
            "        systems=user.system_ids,  # type: ignore",
            "        user_id=\"temp_user_id\",",
            "        in_memory=True,",
            "    )",
            "",
            "    user.client = client",
            "",
            "    return user",
            "",
            "",
            "# This allows us to selectively enforce auth depending on user environment settings",
            "verify_oauth_client_prod = copy_func(verify_oauth_client)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "35": []
        },
        "addLocation": []
    },
    "src/fides/api/service/user/fides_user_service.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import uuid"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from datetime import datetime"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Tuple"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from typing import Optional, Tuple"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from loguru import logger"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from sqlalchemy.orm import Session"
            },
            "7": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     client_id_byte_length: int,"
            },
            "8": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     client_secret_byte_length: int,"
            },
            "9": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     user: FidesUser,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+    skip_save: Optional[bool] = False,"
            },
            "11": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " ) -> ClientDetail:"
            },
            "12": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     \"\"\"Performs a login by updating the FidesUser instance and creating and returning"
            },
            "13": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     an associated ClientDetail."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    If the username or password was bad, skip_save should be True. We still run through"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    parallel operations to keep the timing of operations similar, but should skip"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    saving to the database."
            },
            "18": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     \"\"\""
            },
            "19": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     client = user.client"
            },
            "21": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             roles=user.permissions.roles,  # type: ignore"
            },
            "22": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             systems=user.system_ids,  # type: ignore"
            },
            "23": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             user_id=user.id,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            in_memory=skip_save,  # If login flow has already errored, don't persist this to the database"
            },
            "25": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         )"
            },
            "26": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "     else:"
            },
            "27": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         # Refresh the client just in case - for example, scopes and roles were added via the db directly."
            },
            "28": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         client.roles = user.permissions.roles  # type: ignore"
            },
            "29": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         client.systems = user.system_ids  # type: ignore"
            },
            "30": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        client.save(db)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        if not skip_save:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            client.save(db)"
            },
            "33": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not user.permissions.roles and not user.systems:  # type: ignore"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    if user.permissions and (not user.permissions.roles and not user.systems):  # type: ignore"
            },
            "36": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         logger.warning(\"User {} needs roles or systems to login.\", user.id)"
            },
            "37": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         raise AuthorizationError(detail=\"Not Authorized for this action\")"
            },
            "38": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    user.last_login_at = datetime.utcnow()"
            },
            "40": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    user.save(db)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    if not skip_save:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        user.last_login_at = datetime.utcnow()"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        user.save(db)"
            },
            "44": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     return client"
            }
        },
        "frontPatchFile": [
            "import uuid",
            "from datetime import datetime",
            "from typing import Tuple",
            "",
            "from loguru import logger",
            "from sqlalchemy.orm import Session",
            "",
            "from fides.api.api.v1.endpoints.messaging_endpoints import user_email_invite_status",
            "from fides.api.common_exceptions import AuthorizationError",
            "from fides.api.models.client import ClientDetail",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.models.fides_user_invite import FidesUserInvite",
            "from fides.api.schemas.messaging.messaging import (",
            "    MessagingActionType,",
            "    UserInviteBodyParams,",
            ")",
            "from fides.api.schemas.redis_cache import Identity",
            "from fides.api.service.messaging.message_dispatch_service import dispatch_message",
            "from fides.config import FidesConfig",
            "from fides.config.config_proxy import ConfigProxy",
            "",
            "",
            "def invite_user(db: Session, config_proxy: ConfigProxy, user: FidesUser) -> None:",
            "    \"\"\"",
            "    Generates a user invite and sends the invite code to the user via email.",
            "",
            "    This is a no-op if email messaging isn't configured.",
            "    \"\"\"",
            "",
            "    # invite user via email if email messaging is enabled and the Admin UI URL is defined",
            "    if user_email_invite_status(db=db, config_proxy=config_proxy).enabled:",
            "        invite_code = str(uuid.uuid4())",
            "        FidesUserInvite.create(",
            "            db=db, data={\"username\": user.username, \"invite_code\": invite_code}",
            "        )",
            "        user.update(db, data={\"disabled\": True})",
            "        dispatch_message(",
            "            db,",
            "            action_type=MessagingActionType.USER_INVITE,",
            "            to_identity=Identity(email=user.email_address),",
            "            service_type=config_proxy.notifications.notification_service_type,",
            "            message_body_params=UserInviteBodyParams(",
            "                username=user.username, invite_code=invite_code",
            "            ),",
            "        )",
            "",
            "",
            "def accept_invite(",
            "    db: Session, config: FidesConfig, user: FidesUser, new_password: str",
            ") -> Tuple[FidesUser, str]:",
            "    \"\"\"",
            "    Updates the user password and enables the user. Also removes the user invite from the database.",
            "    Returns a tuple of the updated user and their access code.",
            "    \"\"\"",
            "",
            "    # update password and enable",
            "    user.update_password(db=db, new_password=new_password)",
            "    user.update(",
            "        db,",
            "        data={\"disabled\": False, \"disabled_reason\": None},",
            "    )",
            "    db.refresh(user)",
            "",
            "    # delete invite",
            "    if user.username:",
            "        invite = FidesUserInvite.get_by(db=db, field=\"username\", value=user.username)",
            "        if invite:",
            "            invite.delete(db)",
            "    else:",
            "        logger.warning(\"Username is missing, skipping invite deletion.\")",
            "",
            "    client = perform_login(",
            "        db,",
            "        config.security.oauth_client_id_length_bytes,",
            "        config.security.oauth_client_secret_length_bytes,",
            "        user,",
            "    )",
            "",
            "    logger.info(\"Creating login access token\")",
            "    access_code = client.create_access_code_jwe(config.security.app_encryption_key)",
            "",
            "    return user, access_code",
            "",
            "",
            "def perform_login(",
            "    db: Session,",
            "    client_id_byte_length: int,",
            "    client_secret_byte_length: int,",
            "    user: FidesUser,",
            ") -> ClientDetail:",
            "    \"\"\"Performs a login by updating the FidesUser instance and creating and returning",
            "    an associated ClientDetail.",
            "    \"\"\"",
            "",
            "    client = user.client",
            "    if not client:",
            "        logger.info(\"Creating client for login\")",
            "        client, _ = ClientDetail.create_client_and_secret(",
            "            db,",
            "            client_id_byte_length,",
            "            client_secret_byte_length,",
            "            scopes=[],  # type: ignore",
            "            roles=user.permissions.roles,  # type: ignore",
            "            systems=user.system_ids,  # type: ignore",
            "            user_id=user.id,",
            "        )",
            "    else:",
            "        # Refresh the client just in case - for example, scopes and roles were added via the db directly.",
            "        client.roles = user.permissions.roles  # type: ignore",
            "        client.systems = user.system_ids  # type: ignore",
            "        client.save(db)",
            "",
            "    if not user.permissions.roles and not user.systems:  # type: ignore",
            "        logger.warning(\"User {} needs roles or systems to login.\", user.id)",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    user.last_login_at = datetime.utcnow()",
            "    user.save(db)",
            "",
            "    return client"
        ],
        "afterPatchFile": [
            "import uuid",
            "from datetime import datetime",
            "from typing import Optional, Tuple",
            "",
            "from loguru import logger",
            "from sqlalchemy.orm import Session",
            "",
            "from fides.api.api.v1.endpoints.messaging_endpoints import user_email_invite_status",
            "from fides.api.common_exceptions import AuthorizationError",
            "from fides.api.models.client import ClientDetail",
            "from fides.api.models.fides_user import FidesUser",
            "from fides.api.models.fides_user_invite import FidesUserInvite",
            "from fides.api.schemas.messaging.messaging import (",
            "    MessagingActionType,",
            "    UserInviteBodyParams,",
            ")",
            "from fides.api.schemas.redis_cache import Identity",
            "from fides.api.service.messaging.message_dispatch_service import dispatch_message",
            "from fides.config import FidesConfig",
            "from fides.config.config_proxy import ConfigProxy",
            "",
            "",
            "def invite_user(db: Session, config_proxy: ConfigProxy, user: FidesUser) -> None:",
            "    \"\"\"",
            "    Generates a user invite and sends the invite code to the user via email.",
            "",
            "    This is a no-op if email messaging isn't configured.",
            "    \"\"\"",
            "",
            "    # invite user via email if email messaging is enabled and the Admin UI URL is defined",
            "    if user_email_invite_status(db=db, config_proxy=config_proxy).enabled:",
            "        invite_code = str(uuid.uuid4())",
            "        FidesUserInvite.create(",
            "            db=db, data={\"username\": user.username, \"invite_code\": invite_code}",
            "        )",
            "        user.update(db, data={\"disabled\": True})",
            "        dispatch_message(",
            "            db,",
            "            action_type=MessagingActionType.USER_INVITE,",
            "            to_identity=Identity(email=user.email_address),",
            "            service_type=config_proxy.notifications.notification_service_type,",
            "            message_body_params=UserInviteBodyParams(",
            "                username=user.username, invite_code=invite_code",
            "            ),",
            "        )",
            "",
            "",
            "def accept_invite(",
            "    db: Session, config: FidesConfig, user: FidesUser, new_password: str",
            ") -> Tuple[FidesUser, str]:",
            "    \"\"\"",
            "    Updates the user password and enables the user. Also removes the user invite from the database.",
            "    Returns a tuple of the updated user and their access code.",
            "    \"\"\"",
            "",
            "    # update password and enable",
            "    user.update_password(db=db, new_password=new_password)",
            "    user.update(",
            "        db,",
            "        data={\"disabled\": False, \"disabled_reason\": None},",
            "    )",
            "    db.refresh(user)",
            "",
            "    # delete invite",
            "    if user.username:",
            "        invite = FidesUserInvite.get_by(db=db, field=\"username\", value=user.username)",
            "        if invite:",
            "            invite.delete(db)",
            "    else:",
            "        logger.warning(\"Username is missing, skipping invite deletion.\")",
            "",
            "    client = perform_login(",
            "        db,",
            "        config.security.oauth_client_id_length_bytes,",
            "        config.security.oauth_client_secret_length_bytes,",
            "        user,",
            "    )",
            "",
            "    logger.info(\"Creating login access token\")",
            "    access_code = client.create_access_code_jwe(config.security.app_encryption_key)",
            "",
            "    return user, access_code",
            "",
            "",
            "def perform_login(",
            "    db: Session,",
            "    client_id_byte_length: int,",
            "    client_secret_byte_length: int,",
            "    user: FidesUser,",
            "    skip_save: Optional[bool] = False,",
            ") -> ClientDetail:",
            "    \"\"\"Performs a login by updating the FidesUser instance and creating and returning",
            "    an associated ClientDetail.",
            "",
            "    If the username or password was bad, skip_save should be True. We still run through",
            "    parallel operations to keep the timing of operations similar, but should skip",
            "    saving to the database.",
            "    \"\"\"",
            "",
            "    client = user.client",
            "    if not client:",
            "        logger.info(\"Creating client for login\")",
            "        client, _ = ClientDetail.create_client_and_secret(",
            "            db,",
            "            client_id_byte_length,",
            "            client_secret_byte_length,",
            "            scopes=[],  # type: ignore",
            "            roles=user.permissions.roles,  # type: ignore",
            "            systems=user.system_ids,  # type: ignore",
            "            user_id=user.id,",
            "            in_memory=skip_save,  # If login flow has already errored, don't persist this to the database",
            "        )",
            "    else:",
            "        # Refresh the client just in case - for example, scopes and roles were added via the db directly.",
            "        client.roles = user.permissions.roles  # type: ignore",
            "        client.systems = user.system_ids  # type: ignore",
            "        if not skip_save:",
            "            client.save(db)",
            "",
            "    if user.permissions and (not user.permissions.roles and not user.systems):  # type: ignore",
            "        logger.warning(\"User {} needs roles or systems to login.\", user.id)",
            "        raise AuthorizationError(detail=\"Not Authorized for this action\")",
            "",
            "    if not skip_save:",
            "        user.last_login_at = datetime.utcnow()",
            "        user.save(db)",
            "",
            "    return client"
        ],
        "action": [
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "3": [],
            "111": [
                "perform_login"
            ],
            "113": [
                "perform_login"
            ],
            "117": [
                "perform_login"
            ],
            "118": [
                "perform_login"
            ]
        },
        "addLocation": []
    }
}