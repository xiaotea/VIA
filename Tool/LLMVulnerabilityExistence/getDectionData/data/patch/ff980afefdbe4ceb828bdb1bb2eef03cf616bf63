{
    "lib/ansible/config/manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import sys"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+import stat"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import tempfile"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from collections import namedtuple"
            },
            "7": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     return value"
            },
            "8": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def find_ini_config_file():"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+def find_ini_config_file(warnings=None):"
            },
            "12": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     ''' Load INI Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''"
            },
            "13": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     # FIXME: eventually deprecate ini configs"
            },
            "14": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         if os.path.isdir(path0):"
            },
            "16": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             path0 += \"/ansible.cfg\""
            },
            "17": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "     try:"
            },
            "18": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path1 = os.getcwd() + \"/ansible.cfg\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        path1 = os.getcwd()"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        perms1 = os.stat(path1)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        if perms1.st_mode & stat.S_IWOTH:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            if warnings is not None:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                warnings.add(\"Ansible is in a world writable directory (%s), ignoring it as an ansible.cfg source.\" % to_text(path1))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            path1 = None"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        else:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            path1 += \"/ansible.cfg\""
            },
            "27": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     except OSError:"
            },
            "28": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         path1 = None"
            },
            "29": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     path2 = unfrackpath(\"~/.ansible.cfg\", follow=False)"
            },
            "30": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "     UNABLE = []"
            },
            "32": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     DEPRECATED = []"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+    WARNINGS = set()"
            },
            "34": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "     def __init__(self, conf_file=None, defs_file=None):"
            },
            "36": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 202,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         if self._config_file is None:"
            },
            "39": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "             # set config using ini"
            },
            "40": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._config_file = find_ini_config_file()"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            self._config_file = find_ini_config_file(self.WARNINGS)"
            },
            "42": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 206,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         # consume configuration"
            },
            "44": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         if self._config_file:"
            }
        },
        "frontPatchFile": [
            "# Copyright: (c) 2017, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import sys",
            "import tempfile",
            "",
            "from collections import namedtuple",
            "",
            "from yaml import load as yaml_load",
            "try:",
            "    # use C version if possible for speedup",
            "    from yaml import CSafeLoader as SafeLoader",
            "except ImportError:",
            "    from yaml import SafeLoader",
            "",
            "from ansible.config.data import ConfigData",
            "from ansible.errors import AnsibleOptionsError, AnsibleError",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.six.moves import configparser",
            "from ansible.module_utils._text import to_text, to_bytes, to_native",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.parsing.quoting import unquote",
            "from ansible.utils.path import unfrackpath",
            "from ansible.utils.path import makedirs_safe",
            "",
            "Plugin = namedtuple('Plugin', 'name type')",
            "Setting = namedtuple('Setting', 'name value origin type')",
            "",
            "",
            "# FIXME: see if we can unify in module_utils with similar function used by argspec",
            "def ensure_type(value, value_type, origin=None):",
            "    ''' return a configuration variable with casting",
            "    :arg value: The value to ensure correct typing of",
            "    :kwarg value_type: The type of the value.  This can be any of the following strings:",
            "        :boolean: sets the value to a True or False value",
            "        :integer: Sets the value to an integer or raises a ValueType error",
            "        :float: Sets the value to a float or raises a ValueType error",
            "        :list: Treats the value as a comma separated list.  Split the value",
            "            and return it as a python list.",
            "        :none: Sets the value to None",
            "        :path: Expands any environment variables and tilde's in the value.",
            "        :tmp_path: Create a unique temporary directory inside of the directory",
            "            specified by value and return its path.",
            "        :pathlist: Treat the value as a typical PATH string.  (On POSIX, this",
            "            means colon separated strings.)  Split the value and then expand",
            "            each part for environment variables and tildes.",
            "    '''",
            "",
            "    basedir = None",
            "    if origin and os.path.isabs(origin) and os.path.exists(origin):",
            "        basedir = origin",
            "",
            "    if value_type:",
            "        value_type = value_type.lower()",
            "",
            "    if value_type in ('boolean', 'bool'):",
            "        value = boolean(value, strict=False)",
            "",
            "    elif value:",
            "        if value_type in ('integer', 'int'):",
            "            value = int(value)",
            "",
            "        elif value_type == 'float':",
            "            value = float(value)",
            "",
            "        elif value_type == 'list':",
            "            if isinstance(value, string_types):",
            "                value = [x.strip() for x in value.split(',')]",
            "",
            "        elif value_type == 'none':",
            "            if value == \"None\":",
            "                value = None",
            "",
            "        elif value_type == 'path':",
            "            value = resolve_path(value, basedir=basedir)",
            "",
            "        elif value_type in ('tmp', 'temppath', 'tmppath'):",
            "            value = resolve_path(value, basedir=basedir)",
            "            if not os.path.exists(value):",
            "                makedirs_safe(value, 0o700)",
            "            prefix = 'ansible-local-%s' % os.getpid()",
            "            value = tempfile.mkdtemp(prefix=prefix, dir=value)",
            "",
            "        elif value_type == 'pathspec':",
            "            if isinstance(value, string_types):",
            "                value = value.split(os.pathsep)",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        elif value_type == 'pathlist':",
            "            if isinstance(value, string_types):",
            "                value = value.split(',')",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        # defaults to string types",
            "        elif isinstance(value, string_types):",
            "            value = unquote(value)",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "# FIXME: see if this can live in utils/path",
            "def resolve_path(path, basedir=None):",
            "    ''' resolve relative or 'varaible' paths '''",
            "    if '{{CWD}}' in path:  # allow users to force CWD using 'magic' {{CWD}}",
            "        path = path.replace('{{CWD}}', os.getcwd())",
            "",
            "    return unfrackpath(path, follow=False, basedir=basedir)",
            "",
            "",
            "# FIXME: generic file type?",
            "def get_config_type(cfile):",
            "",
            "    ftype = None",
            "    if cfile is not None:",
            "        ext = os.path.splitext(cfile)[-1]",
            "        if ext in ('.ini', '.cfg'):",
            "            ftype = 'ini'",
            "        elif ext in ('.yaml', '.yml'):",
            "            ftype = 'yaml'",
            "        else:",
            "            raise AnsibleOptionsError(\"Unsupported configuration file extension for %s: %s\" % (cfile, to_native(ext)))",
            "",
            "    return ftype",
            "",
            "",
            "# FIXME: can move to module_utils for use for ini plugins also?",
            "def get_ini_config_value(p, entry):",
            "    ''' returns the value of last ini entry found '''",
            "    value = None",
            "    if p is not None:",
            "        try:",
            "            value = p.get(entry.get('section', 'defaults'), entry.get('key', ''), raw=True)",
            "        except Exception:  # FIXME: actually report issues here",
            "            pass",
            "    return value",
            "",
            "",
            "def find_ini_config_file():",
            "    ''' Load INI Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''",
            "    # FIXME: eventually deprecate ini configs",
            "",
            "    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)",
            "    if path0 is not None:",
            "        path0 = unfrackpath(path0, follow=False)",
            "        if os.path.isdir(path0):",
            "            path0 += \"/ansible.cfg\"",
            "    try:",
            "        path1 = os.getcwd() + \"/ansible.cfg\"",
            "    except OSError:",
            "        path1 = None",
            "    path2 = unfrackpath(\"~/.ansible.cfg\", follow=False)",
            "    path3 = \"/etc/ansible/ansible.cfg\"",
            "",
            "    for path in [path0, path1, path2, path3]:",
            "        if path is not None and os.path.exists(path):",
            "            break",
            "    else:",
            "        path = None",
            "",
            "    return path",
            "",
            "",
            "class ConfigManager(object):",
            "",
            "    UNABLE = []",
            "    DEPRECATED = []",
            "",
            "    def __init__(self, conf_file=None, defs_file=None):",
            "",
            "        self._base_defs = {}",
            "        self._plugins = {}",
            "        self._parsers = {}",
            "",
            "        self._config_file = conf_file",
            "        self.data = ConfigData()",
            "",
            "        if defs_file is None:",
            "            # Create configuration definitions from source",
            "            b_defs_file = to_bytes('%s/base.yml' % os.path.dirname(__file__))",
            "        else:",
            "            b_defs_file = to_bytes(defs_file)",
            "",
            "        # consume definitions",
            "        if os.path.exists(b_defs_file):",
            "            with open(b_defs_file, 'rb') as config_def:",
            "                self._base_defs = yaml_load(config_def, Loader=SafeLoader)",
            "        else:",
            "            raise AnsibleError(\"Missing base configuration definition file (bad install?): %s\" % to_native(b_defs_file))",
            "",
            "        if self._config_file is None:",
            "            # set config using ini",
            "            self._config_file = find_ini_config_file()",
            "",
            "        # consume configuration",
            "        if self._config_file:",
            "            if os.path.exists(self._config_file):",
            "                # initialize parser and read config",
            "                self._parse_config_file()",
            "",
            "        # update constants",
            "        self.update_config_data()",
            "",
            "    def _parse_config_file(self, cfile=None):",
            "        ''' return flat configuration settings from file(s) '''",
            "        # TODO: take list of files with merge/nomerge",
            "",
            "        if cfile is None:",
            "            cfile = self._config_file",
            "",
            "        ftype = get_config_type(cfile)",
            "        if cfile is not None:",
            "            if ftype == 'ini':",
            "                self._parsers[cfile] = configparser.ConfigParser()",
            "                try:",
            "                    self._parsers[cfile].read(cfile)",
            "                except configparser.Error as e:",
            "                    raise AnsibleOptionsError(\"Error reading config file (%s): %s\" % (cfile, to_native(e)))",
            "            # FIXME: this should eventually handle yaml config files",
            "            # elif ftype == 'yaml':",
            "            #     with open(cfile, 'rb') as config_stream:",
            "            #         self._parsers[cfile] = yaml.safe_load(config_stream)",
            "            else:",
            "                raise AnsibleOptionsError(\"Unsupported configuration file type: %s\" % to_native(ftype))",
            "",
            "    def _find_yaml_config_files(self):",
            "        ''' Load YAML Config Files in order, check merge flags, keep origin of settings'''",
            "        pass",
            "",
            "    def get_plugin_options(self, plugin_type, name, keys=None, variables=None):",
            "",
            "        options = {}",
            "        defs = self.get_configuration_definitions(plugin_type, name)",
            "        for option in defs:",
            "            options[option] = self.get_config_value(option, plugin_type=plugin_type, plugin_name=name, keys=keys, variables=variables)",
            "",
            "        return options",
            "",
            "    def get_plugin_vars(self, plugin_type, name):",
            "",
            "        pvars = []",
            "        for pdef in self.get_configuration_definitions(plugin_type, name).values():",
            "            if 'vars' in pdef and pdef['vars']:",
            "                for var_entry in pdef['vars']:",
            "                    pvars.append(var_entry['name'])",
            "        return pvars",
            "",
            "    def get_configuration_definitions(self, plugin_type=None, name=None):",
            "        ''' just list the possible settings, either base or for specific plugins or plugin '''",
            "",
            "        ret = {}",
            "        if plugin_type is None:",
            "            ret = self._base_defs",
            "        elif name is None:",
            "            ret = self._plugins.get(plugin_type, {})",
            "        else:",
            "            ret = self._plugins.get(plugin_type, {}).get(name, {})",
            "",
            "        return ret",
            "",
            "    def _loop_entries(self, container, entry_list):",
            "        ''' repeat code for value entry assignment '''",
            "",
            "        value = None",
            "        origin = None",
            "        for entry in entry_list:",
            "            name = entry.get('name')",
            "            temp_value = container.get(name, None)",
            "            if temp_value is not None:  # only set if env var is defined",
            "                value = temp_value",
            "                origin = name",
            "",
            "                # deal with deprecation of setting source, if used",
            "                if 'deprecated' in entry:",
            "                    self.DEPRECATED.append((entry['name'], entry['deprecated']))",
            "",
            "        return value, origin",
            "",
            "    def get_config_value(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None):",
            "        ''' wrapper '''",
            "        value, _drop = self.get_config_value_and_origin(config, cfile=cfile, plugin_type=plugin_type, plugin_name=plugin_name, keys=keys, variables=variables)",
            "        return value",
            "",
            "    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None):",
            "        ''' Given a config key figure out the actual value and report on the origin of the settings '''",
            "",
            "        if cfile is None:",
            "            # use default config",
            "            cfile = self._config_file",
            "",
            "        # Note: sources that are lists listed in low to high precedence (last one wins)",
            "        value = None",
            "        origin = None",
            "        defs = {}",
            "        if plugin_type is None:",
            "            defs = self._base_defs",
            "        elif plugin_name is None:",
            "            defs = self._plugins[plugin_type]",
            "        else:",
            "            defs = self._plugins[plugin_type][plugin_name]",
            "",
            "        if config in defs:",
            "            # Use 'variable overrides' if present, highest precedence, but only present when querying running play",
            "            if variables and defs[config].get('vars'):",
            "                value, origin = self._loop_entries(variables, defs[config]['vars'])",
            "                origin = 'var: %s' % origin",
            "",
            "            # use playbook keywords if you have em",
            "            if value is None and keys:",
            "                value, origin = self._loop_entries(keys, defs[config]['keywords'])",
            "                origin = 'keyword: %s' % origin",
            "",
            "            # env vars are next precedence",
            "            if value is None and defs[config].get('env'):",
            "                value, origin = self._loop_entries(os.environ, defs[config]['env'])",
            "                origin = 'env: %s' % origin",
            "",
            "            # try config file entries next, if we have one",
            "            if self._parsers.get(cfile, None) is None:",
            "                self._parse_config_file(cfile)",
            "",
            "            if value is None and cfile is not None:",
            "                ftype = get_config_type(cfile)",
            "                if ftype and defs[config].get(ftype):",
            "                    if ftype == 'ini':",
            "                        # load from ini config",
            "                        try:  # FIXME: generalize _loop_entries to allow for files also, most of this code is dupe",
            "                            for ini_entry in defs[config]['ini']:",
            "                                temp_value = get_ini_config_value(self._parsers[cfile], ini_entry)",
            "                                if temp_value is not None:",
            "                                    value = temp_value",
            "                                    origin = cfile",
            "                                    if 'deprecated' in ini_entry:",
            "                                        self.DEPRECATED.append(('[%s]%s' % (ini_entry['section'], ini_entry['key']), ini_entry['deprecated']))",
            "                        except Exception as e:",
            "                            sys.stderr.write(\"Error while loading ini config %s: %s\" % (cfile, to_native(e)))",
            "                    elif ftype == 'yaml':",
            "                        # FIXME: implement, also , break down key from defs (. notation???)",
            "                        origin = cfile",
            "",
            "            # set default if we got here w/o a value",
            "            if value is None:",
            "                value = defs[config].get('default')",
            "                origin = 'default'",
            "                # skip typing as this is a temlated default that will be resolved later in constants, which has needed vars",
            "                if plugin_type is None and isinstance(value, string_types) and (value.startswith('{{') and value.endswith('}}')):",
            "                    return value, origin",
            "",
            "            # ensure correct type",
            "            try:",
            "                value = ensure_type(value, defs[config].get('type'), origin=origin)",
            "            except Exception as e:",
            "                self.UNABLE.append(config)",
            "",
            "            # deal with deprecation of the setting",
            "            if 'deprecated' in defs[config] and origin != 'default':",
            "                self.DEPRECATED.append((config, defs[config].get('deprecated')))",
            "        else:",
            "            raise AnsibleError('Requested option %s was not defined in configuration' % to_native(config))",
            "",
            "        return value, origin",
            "",
            "    def initialize_plugin_configuration_definitions(self, plugin_type, name, defs):",
            "",
            "        if plugin_type not in self._plugins:",
            "            self._plugins[plugin_type] = {}",
            "",
            "        self._plugins[plugin_type][name] = defs",
            "",
            "    def update_config_data(self, defs=None, configfile=None):",
            "        ''' really: update constants '''",
            "",
            "        if defs is None:",
            "            defs = self._base_defs",
            "",
            "        if configfile is None:",
            "            configfile = self._config_file",
            "",
            "        if not isinstance(defs, dict):",
            "            raise AnsibleOptionsError(\"Invalid configuration definition type: %s for %s\" % (type(defs), defs))",
            "",
            "        # update the constant for config file",
            "        self.data.update_setting(Setting('CONFIG_FILE', configfile, '', 'string'))",
            "",
            "        origin = None",
            "        # env and config defs can have several entries, ordered in list from lowest to highest precedence",
            "        for config in defs:",
            "            if not isinstance(defs[config], dict):",
            "                raise AnsibleOptionsError(\"Invalid configuration definition '%s': type is %s\" % (to_native(config), type(defs[config])))",
            "",
            "            # get value and origin",
            "            value, origin = self.get_config_value_and_origin(config, configfile)",
            "",
            "            # set the constant",
            "            self.data.update_setting(Setting(config, value, origin, defs[config].get('type', 'string')))"
        ],
        "afterPatchFile": [
            "# Copyright: (c) 2017, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import sys",
            "import stat",
            "import tempfile",
            "",
            "from collections import namedtuple",
            "",
            "from yaml import load as yaml_load",
            "try:",
            "    # use C version if possible for speedup",
            "    from yaml import CSafeLoader as SafeLoader",
            "except ImportError:",
            "    from yaml import SafeLoader",
            "",
            "from ansible.config.data import ConfigData",
            "from ansible.errors import AnsibleOptionsError, AnsibleError",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.six.moves import configparser",
            "from ansible.module_utils._text import to_text, to_bytes, to_native",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.parsing.quoting import unquote",
            "from ansible.utils.path import unfrackpath",
            "from ansible.utils.path import makedirs_safe",
            "",
            "Plugin = namedtuple('Plugin', 'name type')",
            "Setting = namedtuple('Setting', 'name value origin type')",
            "",
            "",
            "# FIXME: see if we can unify in module_utils with similar function used by argspec",
            "def ensure_type(value, value_type, origin=None):",
            "    ''' return a configuration variable with casting",
            "    :arg value: The value to ensure correct typing of",
            "    :kwarg value_type: The type of the value.  This can be any of the following strings:",
            "        :boolean: sets the value to a True or False value",
            "        :integer: Sets the value to an integer or raises a ValueType error",
            "        :float: Sets the value to a float or raises a ValueType error",
            "        :list: Treats the value as a comma separated list.  Split the value",
            "            and return it as a python list.",
            "        :none: Sets the value to None",
            "        :path: Expands any environment variables and tilde's in the value.",
            "        :tmp_path: Create a unique temporary directory inside of the directory",
            "            specified by value and return its path.",
            "        :pathlist: Treat the value as a typical PATH string.  (On POSIX, this",
            "            means colon separated strings.)  Split the value and then expand",
            "            each part for environment variables and tildes.",
            "    '''",
            "",
            "    basedir = None",
            "    if origin and os.path.isabs(origin) and os.path.exists(origin):",
            "        basedir = origin",
            "",
            "    if value_type:",
            "        value_type = value_type.lower()",
            "",
            "    if value_type in ('boolean', 'bool'):",
            "        value = boolean(value, strict=False)",
            "",
            "    elif value:",
            "        if value_type in ('integer', 'int'):",
            "            value = int(value)",
            "",
            "        elif value_type == 'float':",
            "            value = float(value)",
            "",
            "        elif value_type == 'list':",
            "            if isinstance(value, string_types):",
            "                value = [x.strip() for x in value.split(',')]",
            "",
            "        elif value_type == 'none':",
            "            if value == \"None\":",
            "                value = None",
            "",
            "        elif value_type == 'path':",
            "            value = resolve_path(value, basedir=basedir)",
            "",
            "        elif value_type in ('tmp', 'temppath', 'tmppath'):",
            "            value = resolve_path(value, basedir=basedir)",
            "            if not os.path.exists(value):",
            "                makedirs_safe(value, 0o700)",
            "            prefix = 'ansible-local-%s' % os.getpid()",
            "            value = tempfile.mkdtemp(prefix=prefix, dir=value)",
            "",
            "        elif value_type == 'pathspec':",
            "            if isinstance(value, string_types):",
            "                value = value.split(os.pathsep)",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        elif value_type == 'pathlist':",
            "            if isinstance(value, string_types):",
            "                value = value.split(',')",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        # defaults to string types",
            "        elif isinstance(value, string_types):",
            "            value = unquote(value)",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "# FIXME: see if this can live in utils/path",
            "def resolve_path(path, basedir=None):",
            "    ''' resolve relative or 'varaible' paths '''",
            "    if '{{CWD}}' in path:  # allow users to force CWD using 'magic' {{CWD}}",
            "        path = path.replace('{{CWD}}', os.getcwd())",
            "",
            "    return unfrackpath(path, follow=False, basedir=basedir)",
            "",
            "",
            "# FIXME: generic file type?",
            "def get_config_type(cfile):",
            "",
            "    ftype = None",
            "    if cfile is not None:",
            "        ext = os.path.splitext(cfile)[-1]",
            "        if ext in ('.ini', '.cfg'):",
            "            ftype = 'ini'",
            "        elif ext in ('.yaml', '.yml'):",
            "            ftype = 'yaml'",
            "        else:",
            "            raise AnsibleOptionsError(\"Unsupported configuration file extension for %s: %s\" % (cfile, to_native(ext)))",
            "",
            "    return ftype",
            "",
            "",
            "# FIXME: can move to module_utils for use for ini plugins also?",
            "def get_ini_config_value(p, entry):",
            "    ''' returns the value of last ini entry found '''",
            "    value = None",
            "    if p is not None:",
            "        try:",
            "            value = p.get(entry.get('section', 'defaults'), entry.get('key', ''), raw=True)",
            "        except Exception:  # FIXME: actually report issues here",
            "            pass",
            "    return value",
            "",
            "",
            "def find_ini_config_file(warnings=None):",
            "    ''' Load INI Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''",
            "    # FIXME: eventually deprecate ini configs",
            "",
            "    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)",
            "    if path0 is not None:",
            "        path0 = unfrackpath(path0, follow=False)",
            "        if os.path.isdir(path0):",
            "            path0 += \"/ansible.cfg\"",
            "    try:",
            "        path1 = os.getcwd()",
            "        perms1 = os.stat(path1)",
            "        if perms1.st_mode & stat.S_IWOTH:",
            "            if warnings is not None:",
            "                warnings.add(\"Ansible is in a world writable directory (%s), ignoring it as an ansible.cfg source.\" % to_text(path1))",
            "            path1 = None",
            "        else:",
            "            path1 += \"/ansible.cfg\"",
            "    except OSError:",
            "        path1 = None",
            "    path2 = unfrackpath(\"~/.ansible.cfg\", follow=False)",
            "    path3 = \"/etc/ansible/ansible.cfg\"",
            "",
            "    for path in [path0, path1, path2, path3]:",
            "        if path is not None and os.path.exists(path):",
            "            break",
            "    else:",
            "        path = None",
            "",
            "    return path",
            "",
            "",
            "class ConfigManager(object):",
            "",
            "    UNABLE = []",
            "    DEPRECATED = []",
            "    WARNINGS = set()",
            "",
            "    def __init__(self, conf_file=None, defs_file=None):",
            "",
            "        self._base_defs = {}",
            "        self._plugins = {}",
            "        self._parsers = {}",
            "",
            "        self._config_file = conf_file",
            "        self.data = ConfigData()",
            "",
            "        if defs_file is None:",
            "            # Create configuration definitions from source",
            "            b_defs_file = to_bytes('%s/base.yml' % os.path.dirname(__file__))",
            "        else:",
            "            b_defs_file = to_bytes(defs_file)",
            "",
            "        # consume definitions",
            "        if os.path.exists(b_defs_file):",
            "            with open(b_defs_file, 'rb') as config_def:",
            "                self._base_defs = yaml_load(config_def, Loader=SafeLoader)",
            "        else:",
            "            raise AnsibleError(\"Missing base configuration definition file (bad install?): %s\" % to_native(b_defs_file))",
            "",
            "        if self._config_file is None:",
            "            # set config using ini",
            "            self._config_file = find_ini_config_file(self.WARNINGS)",
            "",
            "        # consume configuration",
            "        if self._config_file:",
            "            if os.path.exists(self._config_file):",
            "                # initialize parser and read config",
            "                self._parse_config_file()",
            "",
            "        # update constants",
            "        self.update_config_data()",
            "",
            "    def _parse_config_file(self, cfile=None):",
            "        ''' return flat configuration settings from file(s) '''",
            "        # TODO: take list of files with merge/nomerge",
            "",
            "        if cfile is None:",
            "            cfile = self._config_file",
            "",
            "        ftype = get_config_type(cfile)",
            "        if cfile is not None:",
            "            if ftype == 'ini':",
            "                self._parsers[cfile] = configparser.ConfigParser()",
            "                try:",
            "                    self._parsers[cfile].read(cfile)",
            "                except configparser.Error as e:",
            "                    raise AnsibleOptionsError(\"Error reading config file (%s): %s\" % (cfile, to_native(e)))",
            "            # FIXME: this should eventually handle yaml config files",
            "            # elif ftype == 'yaml':",
            "            #     with open(cfile, 'rb') as config_stream:",
            "            #         self._parsers[cfile] = yaml.safe_load(config_stream)",
            "            else:",
            "                raise AnsibleOptionsError(\"Unsupported configuration file type: %s\" % to_native(ftype))",
            "",
            "    def _find_yaml_config_files(self):",
            "        ''' Load YAML Config Files in order, check merge flags, keep origin of settings'''",
            "        pass",
            "",
            "    def get_plugin_options(self, plugin_type, name, keys=None, variables=None):",
            "",
            "        options = {}",
            "        defs = self.get_configuration_definitions(plugin_type, name)",
            "        for option in defs:",
            "            options[option] = self.get_config_value(option, plugin_type=plugin_type, plugin_name=name, keys=keys, variables=variables)",
            "",
            "        return options",
            "",
            "    def get_plugin_vars(self, plugin_type, name):",
            "",
            "        pvars = []",
            "        for pdef in self.get_configuration_definitions(plugin_type, name).values():",
            "            if 'vars' in pdef and pdef['vars']:",
            "                for var_entry in pdef['vars']:",
            "                    pvars.append(var_entry['name'])",
            "        return pvars",
            "",
            "    def get_configuration_definitions(self, plugin_type=None, name=None):",
            "        ''' just list the possible settings, either base or for specific plugins or plugin '''",
            "",
            "        ret = {}",
            "        if plugin_type is None:",
            "            ret = self._base_defs",
            "        elif name is None:",
            "            ret = self._plugins.get(plugin_type, {})",
            "        else:",
            "            ret = self._plugins.get(plugin_type, {}).get(name, {})",
            "",
            "        return ret",
            "",
            "    def _loop_entries(self, container, entry_list):",
            "        ''' repeat code for value entry assignment '''",
            "",
            "        value = None",
            "        origin = None",
            "        for entry in entry_list:",
            "            name = entry.get('name')",
            "            temp_value = container.get(name, None)",
            "            if temp_value is not None:  # only set if env var is defined",
            "                value = temp_value",
            "                origin = name",
            "",
            "                # deal with deprecation of setting source, if used",
            "                if 'deprecated' in entry:",
            "                    self.DEPRECATED.append((entry['name'], entry['deprecated']))",
            "",
            "        return value, origin",
            "",
            "    def get_config_value(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None):",
            "        ''' wrapper '''",
            "        value, _drop = self.get_config_value_and_origin(config, cfile=cfile, plugin_type=plugin_type, plugin_name=plugin_name, keys=keys, variables=variables)",
            "        return value",
            "",
            "    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, keys=None, variables=None):",
            "        ''' Given a config key figure out the actual value and report on the origin of the settings '''",
            "",
            "        if cfile is None:",
            "            # use default config",
            "            cfile = self._config_file",
            "",
            "        # Note: sources that are lists listed in low to high precedence (last one wins)",
            "        value = None",
            "        origin = None",
            "        defs = {}",
            "        if plugin_type is None:",
            "            defs = self._base_defs",
            "        elif plugin_name is None:",
            "            defs = self._plugins[plugin_type]",
            "        else:",
            "            defs = self._plugins[plugin_type][plugin_name]",
            "",
            "        if config in defs:",
            "            # Use 'variable overrides' if present, highest precedence, but only present when querying running play",
            "            if variables and defs[config].get('vars'):",
            "                value, origin = self._loop_entries(variables, defs[config]['vars'])",
            "                origin = 'var: %s' % origin",
            "",
            "            # use playbook keywords if you have em",
            "            if value is None and keys:",
            "                value, origin = self._loop_entries(keys, defs[config]['keywords'])",
            "                origin = 'keyword: %s' % origin",
            "",
            "            # env vars are next precedence",
            "            if value is None and defs[config].get('env'):",
            "                value, origin = self._loop_entries(os.environ, defs[config]['env'])",
            "                origin = 'env: %s' % origin",
            "",
            "            # try config file entries next, if we have one",
            "            if self._parsers.get(cfile, None) is None:",
            "                self._parse_config_file(cfile)",
            "",
            "            if value is None and cfile is not None:",
            "                ftype = get_config_type(cfile)",
            "                if ftype and defs[config].get(ftype):",
            "                    if ftype == 'ini':",
            "                        # load from ini config",
            "                        try:  # FIXME: generalize _loop_entries to allow for files also, most of this code is dupe",
            "                            for ini_entry in defs[config]['ini']:",
            "                                temp_value = get_ini_config_value(self._parsers[cfile], ini_entry)",
            "                                if temp_value is not None:",
            "                                    value = temp_value",
            "                                    origin = cfile",
            "                                    if 'deprecated' in ini_entry:",
            "                                        self.DEPRECATED.append(('[%s]%s' % (ini_entry['section'], ini_entry['key']), ini_entry['deprecated']))",
            "                        except Exception as e:",
            "                            sys.stderr.write(\"Error while loading ini config %s: %s\" % (cfile, to_native(e)))",
            "                    elif ftype == 'yaml':",
            "                        # FIXME: implement, also , break down key from defs (. notation???)",
            "                        origin = cfile",
            "",
            "            # set default if we got here w/o a value",
            "            if value is None:",
            "                value = defs[config].get('default')",
            "                origin = 'default'",
            "                # skip typing as this is a temlated default that will be resolved later in constants, which has needed vars",
            "                if plugin_type is None and isinstance(value, string_types) and (value.startswith('{{') and value.endswith('}}')):",
            "                    return value, origin",
            "",
            "            # ensure correct type",
            "            try:",
            "                value = ensure_type(value, defs[config].get('type'), origin=origin)",
            "            except Exception as e:",
            "                self.UNABLE.append(config)",
            "",
            "            # deal with deprecation of the setting",
            "            if 'deprecated' in defs[config] and origin != 'default':",
            "                self.DEPRECATED.append((config, defs[config].get('deprecated')))",
            "        else:",
            "            raise AnsibleError('Requested option %s was not defined in configuration' % to_native(config))",
            "",
            "        return value, origin",
            "",
            "    def initialize_plugin_configuration_definitions(self, plugin_type, name, defs):",
            "",
            "        if plugin_type not in self._plugins:",
            "            self._plugins[plugin_type] = {}",
            "",
            "        self._plugins[plugin_type][name] = defs",
            "",
            "    def update_config_data(self, defs=None, configfile=None):",
            "        ''' really: update constants '''",
            "",
            "        if defs is None:",
            "            defs = self._base_defs",
            "",
            "        if configfile is None:",
            "            configfile = self._config_file",
            "",
            "        if not isinstance(defs, dict):",
            "            raise AnsibleOptionsError(\"Invalid configuration definition type: %s for %s\" % (type(defs), defs))",
            "",
            "        # update the constant for config file",
            "        self.data.update_setting(Setting('CONFIG_FILE', configfile, '', 'string'))",
            "",
            "        origin = None",
            "        # env and config defs can have several entries, ordered in list from lowest to highest precedence",
            "        for config in defs:",
            "            if not isinstance(defs[config], dict):",
            "                raise AnsibleOptionsError(\"Invalid configuration definition '%s': type is %s\" % (to_native(config), type(defs[config])))",
            "",
            "            # get value and origin",
            "            value, origin = self.get_config_value_and_origin(config, configfile)",
            "",
            "            # set the constant",
            "            self.data.update_setting(Setting(config, value, origin, defs[config].get('type', 'string')))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "142": [
                "find_ini_config_file"
            ],
            "152": [
                "find_ini_config_file"
            ],
            "196": [
                "ConfigManager",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+def _warning(msg):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    try:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+        from __main__ import display"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+        display.warning(msg)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    except:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+        import sys"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        sys.stderr.write(' [WARNING] %s\\n' % (msg))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " def _deprecated(msg, version='2.8'):"
            },
            "14": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''"
            },
            "15": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     try:"
            },
            "16": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         from __main__ import display"
            },
            "17": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         display.deprecated(msg, version=version)"
            },
            "18": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     except:"
            },
            "19": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         import sys"
            },
            "20": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sys.stderr.write('[DEPRECATED] %s, to be removed in %s' % (msg, version))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        sys.stderr.write(' [DEPRECATED] %s, to be removed in %s\\n' % (msg, version))"
            },
            "22": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " def mk_boolean(value):"
            },
            "25": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         value = ensure_type(value, setting.name)"
            },
            "26": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 197,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "     set_constant(setting.name, value)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+for warn in config.WARNINGS:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+    _warning(warn)"
            }
        },
        "frontPatchFile": [
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2017, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "",
            "from ast import literal_eval",
            "from jinja2 import Template",
            "from string import ascii_letters, digits",
            "",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils.parsing.convert_bool import boolean, BOOLEANS_TRUE",
            "from ansible.module_utils.six import string_types",
            "from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value",
            "",
            "",
            "def _deprecated(msg, version='2.8'):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.deprecated(msg, version=version)",
            "    except:",
            "        import sys",
            "        sys.stderr.write('[DEPRECATED] %s, to be removed in %s' % (msg, version))",
            "",
            "",
            "def mk_boolean(value):",
            "    ''' moved to module_utils'''",
            "    _deprecated('ansible.constants.mk_boolean() is deprecated.  Use ansible.module_utils.parsing.convert_bool.boolean() instead')",
            "    return boolean(value, strict=False)",
            "",
            "",
            "def get_config(parser, section, key, env_var, default_value, value_type=None, expand_relative_paths=False):",
            "    ''' kept for backwarsd compatibility, but deprecated '''",
            "    _deprecated('ansible.constants.get_config() is deprecated. There is new config API, see porting docs.')",
            "",
            "    value = None",
            "    # small reconstruction of the old code env/ini/default",
            "    value = os.environ.get(env_var, None)",
            "    if value is None:",
            "        try:",
            "            value = get_ini_config_value(parser, {'key': key, 'section': section})",
            "        except:",
            "            pass",
            "    if value is None:",
            "        value = default_value",
            "",
            "    value = ensure_type(value, value_type)",
            "",
            "    return value",
            "",
            "",
            "def set_constant(name, value, export=vars()):",
            "    ''' sets constants and returns resolved options dict '''",
            "    export[name] = value",
            "",
            "",
            "# CONSTANTS ### yes, actual ones",
            "BECOME_METHODS = ['sudo', 'su', 'pbrun', 'pfexec', 'doas', 'dzdo', 'ksu', 'runas', 'pmrun', 'enable']",
            "BECOME_ERROR_STRINGS = {",
            "    'sudo': 'Sorry, try again.',",
            "    'su': 'Authentication failure',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Permission denied',",
            "    'dzdo': '',",
            "    'ksu': 'Password incorrect',",
            "    'pmrun': 'You are not permitted to run this command',",
            "    'enable': '',",
            "}  # FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS = {",
            "    'sudo': 'sorry, a password is required to run sudo',",
            "    'su': '',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Authorization required',",
            "    'dzdo': '',",
            "    'ksu': 'No password given',",
            "    'pmrun': '',",
            "    'enable': '',",
            "}  # FIXME: deal with i18n",
            "BLACKLIST_EXTS = ('.pyc', '.pyo', '.swp', '.bak', '~', '.rpm', '.md', '.txt')",
            "BOOL_TRUE = BOOLEANS_TRUE",
            "CONTROLER_LANG = os.getenv('LANG', 'en_US.UTF-8')",
            "DEFAULT_BECOME_PASS = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS = None",
            "DEFAULT_REMOTE_PASS = None",
            "DEFAULT_SUBSET = None",
            "DEFAULT_SU_PASS = None",
            "# FIXME: expand to other plugins, but never doc fragments",
            "CONFIGURABLE_PLUGINS = ('cache', 'callback', 'connection', 'inventory', 'lookup', 'shell')",
            "# NOTE: always update the docs/docsite/Makefile to match",
            "DOCUMENTABLE_PLUGINS = CONFIGURABLE_PLUGINS + ('module', 'strategy', 'vars')",
            "IGNORE_FILES = (\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\")  # ignore during module search",
            "INTERNAL_RESULT_KEYS = ('add_host', 'add_group')",
            "LOCALHOST = ('127.0.0.1', 'localhost', '::1')",
            "MODULE_REQUIRE_ARGS = ('command', 'win_command', 'shell', 'win_shell', 'raw', 'script')",
            "MODULE_NO_JSON = ('command', 'win_command', 'shell', 'win_shell', 'raw')",
            "RESTRICTED_RESULT_KEYS = ('ansible_rsync_path', 'ansible_playbook_python')",
            "TREE_DIR = None",
            "VAULT_VERSION_MIN = 1.0",
            "VAULT_VERSION_MAX = 1.0",
            "",
            "# FIXME: remove once play_context mangling is removed",
            "# the magic variable mapping dictionary below is used to translate",
            "# host/inventory variables to fields in the PlayContext",
            "# object. The dictionary values are tuples, to account for aliases",
            "# in variable names.",
            "",
            "MAGIC_VARIABLE_MAPPING = dict(",
            "",
            "    # base",
            "    connection=('ansible_connection', ),",
            "    module_compression=('ansible_module_compression', ),",
            "    shell=('ansible_shell_type', ),",
            "    executable=('ansible_shell_executable', ),",
            "",
            "    # connection common",
            "    remote_addr=('ansible_ssh_host', 'ansible_host'),",
            "    remote_user=('ansible_ssh_user', 'ansible_user'),",
            "    password=('ansible_ssh_pass', 'ansible_password'),",
            "    port=('ansible_ssh_port', 'ansible_port'),",
            "    pipelining=('ansible_ssh_pipelining', 'ansible_pipelining'),",
            "    timeout=('ansible_ssh_timeout', 'ansible_timeout'),",
            "    private_key_file=('ansible_ssh_private_key_file', 'ansible_private_key_file'),",
            "",
            "    # networking modules",
            "    network_os=('ansible_network_os', ),",
            "    connection_user=('ansible_connection_user',),",
            "",
            "    # ssh TODO: remove",
            "    ssh_executable=('ansible_ssh_executable', ),",
            "    ssh_common_args=('ansible_ssh_common_args', ),",
            "    sftp_extra_args=('ansible_sftp_extra_args', ),",
            "    scp_extra_args=('ansible_scp_extra_args', ),",
            "    ssh_extra_args=('ansible_ssh_extra_args', ),",
            "    ssh_transfer_method=('ansible_ssh_transfer_method', ),",
            "",
            "    # docker TODO: remove",
            "    docker_extra_args=('ansible_docker_extra_args', ),",
            "",
            "    # become",
            "    become=('ansible_become', ),",
            "    become_method=('ansible_become_method', ),",
            "    become_user=('ansible_become_user', ),",
            "    become_pass=('ansible_become_password', 'ansible_become_pass'),",
            "    become_exe=('ansible_become_exe', ),",
            "    become_flags=('ansible_become_flags', ),",
            "",
            "    # deprecated",
            "    sudo=('ansible_sudo', ),",
            "    sudo_user=('ansible_sudo_user', ),",
            "    sudo_pass=('ansible_sudo_password', 'ansible_sudo_pass'),",
            "    sudo_exe=('ansible_sudo_exe', ),",
            "    sudo_flags=('ansible_sudo_flags', ),",
            "    su=('ansible_su', ),",
            "    su_user=('ansible_su_user', ),",
            "    su_pass=('ansible_su_password', 'ansible_su_pass'),",
            "    su_exe=('ansible_su_exe', ),",
            "    su_flags=('ansible_su_flags', ),",
            ")",
            "",
            "# POPULATE SETTINGS FROM CONFIG ###",
            "config = ConfigManager()",
            "",
            "# Generate constants from config",
            "for setting in config.data.get_settings():",
            "",
            "    value = setting.value",
            "    if setting.origin == 'default' and \\",
            "       isinstance(setting.value, string_types) and \\",
            "       (setting.value.startswith('{{') and setting.value.endswith('}}')):",
            "        try:",
            "            t = Template(setting.value)",
            "            value = t.render(vars())",
            "            try:",
            "                value = literal_eval(value)",
            "            except ValueError:",
            "                pass  # not a python data structure",
            "        except:",
            "            pass  # not templatable",
            "        value = ensure_type(value, setting.name)",
            "",
            "    set_constant(setting.name, value)"
        ],
        "afterPatchFile": [
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2017, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "",
            "from ast import literal_eval",
            "from jinja2 import Template",
            "from string import ascii_letters, digits",
            "",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils.parsing.convert_bool import boolean, BOOLEANS_TRUE",
            "from ansible.module_utils.six import string_types",
            "from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value",
            "",
            "",
            "def _warning(msg):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.warning(msg)",
            "    except:",
            "        import sys",
            "        sys.stderr.write(' [WARNING] %s\\n' % (msg))",
            "",
            "",
            "def _deprecated(msg, version='2.8'):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.deprecated(msg, version=version)",
            "    except:",
            "        import sys",
            "        sys.stderr.write(' [DEPRECATED] %s, to be removed in %s\\n' % (msg, version))",
            "",
            "",
            "def mk_boolean(value):",
            "    ''' moved to module_utils'''",
            "    _deprecated('ansible.constants.mk_boolean() is deprecated.  Use ansible.module_utils.parsing.convert_bool.boolean() instead')",
            "    return boolean(value, strict=False)",
            "",
            "",
            "def get_config(parser, section, key, env_var, default_value, value_type=None, expand_relative_paths=False):",
            "    ''' kept for backwarsd compatibility, but deprecated '''",
            "    _deprecated('ansible.constants.get_config() is deprecated. There is new config API, see porting docs.')",
            "",
            "    value = None",
            "    # small reconstruction of the old code env/ini/default",
            "    value = os.environ.get(env_var, None)",
            "    if value is None:",
            "        try:",
            "            value = get_ini_config_value(parser, {'key': key, 'section': section})",
            "        except:",
            "            pass",
            "    if value is None:",
            "        value = default_value",
            "",
            "    value = ensure_type(value, value_type)",
            "",
            "    return value",
            "",
            "",
            "def set_constant(name, value, export=vars()):",
            "    ''' sets constants and returns resolved options dict '''",
            "    export[name] = value",
            "",
            "",
            "# CONSTANTS ### yes, actual ones",
            "BECOME_METHODS = ['sudo', 'su', 'pbrun', 'pfexec', 'doas', 'dzdo', 'ksu', 'runas', 'pmrun', 'enable']",
            "BECOME_ERROR_STRINGS = {",
            "    'sudo': 'Sorry, try again.',",
            "    'su': 'Authentication failure',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Permission denied',",
            "    'dzdo': '',",
            "    'ksu': 'Password incorrect',",
            "    'pmrun': 'You are not permitted to run this command',",
            "    'enable': '',",
            "}  # FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS = {",
            "    'sudo': 'sorry, a password is required to run sudo',",
            "    'su': '',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Authorization required',",
            "    'dzdo': '',",
            "    'ksu': 'No password given',",
            "    'pmrun': '',",
            "    'enable': '',",
            "}  # FIXME: deal with i18n",
            "BLACKLIST_EXTS = ('.pyc', '.pyo', '.swp', '.bak', '~', '.rpm', '.md', '.txt')",
            "BOOL_TRUE = BOOLEANS_TRUE",
            "CONTROLER_LANG = os.getenv('LANG', 'en_US.UTF-8')",
            "DEFAULT_BECOME_PASS = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS = None",
            "DEFAULT_REMOTE_PASS = None",
            "DEFAULT_SUBSET = None",
            "DEFAULT_SU_PASS = None",
            "# FIXME: expand to other plugins, but never doc fragments",
            "CONFIGURABLE_PLUGINS = ('cache', 'callback', 'connection', 'inventory', 'lookup', 'shell')",
            "# NOTE: always update the docs/docsite/Makefile to match",
            "DOCUMENTABLE_PLUGINS = CONFIGURABLE_PLUGINS + ('module', 'strategy', 'vars')",
            "IGNORE_FILES = (\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\")  # ignore during module search",
            "INTERNAL_RESULT_KEYS = ('add_host', 'add_group')",
            "LOCALHOST = ('127.0.0.1', 'localhost', '::1')",
            "MODULE_REQUIRE_ARGS = ('command', 'win_command', 'shell', 'win_shell', 'raw', 'script')",
            "MODULE_NO_JSON = ('command', 'win_command', 'shell', 'win_shell', 'raw')",
            "RESTRICTED_RESULT_KEYS = ('ansible_rsync_path', 'ansible_playbook_python')",
            "TREE_DIR = None",
            "VAULT_VERSION_MIN = 1.0",
            "VAULT_VERSION_MAX = 1.0",
            "",
            "# FIXME: remove once play_context mangling is removed",
            "# the magic variable mapping dictionary below is used to translate",
            "# host/inventory variables to fields in the PlayContext",
            "# object. The dictionary values are tuples, to account for aliases",
            "# in variable names.",
            "",
            "MAGIC_VARIABLE_MAPPING = dict(",
            "",
            "    # base",
            "    connection=('ansible_connection', ),",
            "    module_compression=('ansible_module_compression', ),",
            "    shell=('ansible_shell_type', ),",
            "    executable=('ansible_shell_executable', ),",
            "",
            "    # connection common",
            "    remote_addr=('ansible_ssh_host', 'ansible_host'),",
            "    remote_user=('ansible_ssh_user', 'ansible_user'),",
            "    password=('ansible_ssh_pass', 'ansible_password'),",
            "    port=('ansible_ssh_port', 'ansible_port'),",
            "    pipelining=('ansible_ssh_pipelining', 'ansible_pipelining'),",
            "    timeout=('ansible_ssh_timeout', 'ansible_timeout'),",
            "    private_key_file=('ansible_ssh_private_key_file', 'ansible_private_key_file'),",
            "",
            "    # networking modules",
            "    network_os=('ansible_network_os', ),",
            "    connection_user=('ansible_connection_user',),",
            "",
            "    # ssh TODO: remove",
            "    ssh_executable=('ansible_ssh_executable', ),",
            "    ssh_common_args=('ansible_ssh_common_args', ),",
            "    sftp_extra_args=('ansible_sftp_extra_args', ),",
            "    scp_extra_args=('ansible_scp_extra_args', ),",
            "    ssh_extra_args=('ansible_ssh_extra_args', ),",
            "    ssh_transfer_method=('ansible_ssh_transfer_method', ),",
            "",
            "    # docker TODO: remove",
            "    docker_extra_args=('ansible_docker_extra_args', ),",
            "",
            "    # become",
            "    become=('ansible_become', ),",
            "    become_method=('ansible_become_method', ),",
            "    become_user=('ansible_become_user', ),",
            "    become_pass=('ansible_become_password', 'ansible_become_pass'),",
            "    become_exe=('ansible_become_exe', ),",
            "    become_flags=('ansible_become_flags', ),",
            "",
            "    # deprecated",
            "    sudo=('ansible_sudo', ),",
            "    sudo_user=('ansible_sudo_user', ),",
            "    sudo_pass=('ansible_sudo_password', 'ansible_sudo_pass'),",
            "    sudo_exe=('ansible_sudo_exe', ),",
            "    sudo_flags=('ansible_sudo_flags', ),",
            "    su=('ansible_su', ),",
            "    su_user=('ansible_su_user', ),",
            "    su_pass=('ansible_su_password', 'ansible_su_pass'),",
            "    su_exe=('ansible_su_exe', ),",
            "    su_flags=('ansible_su_flags', ),",
            ")",
            "",
            "# POPULATE SETTINGS FROM CONFIG ###",
            "config = ConfigManager()",
            "",
            "# Generate constants from config",
            "for setting in config.data.get_settings():",
            "",
            "    value = setting.value",
            "    if setting.origin == 'default' and \\",
            "       isinstance(setting.value, string_types) and \\",
            "       (setting.value.startswith('{{') and setting.value.endswith('}}')):",
            "        try:",
            "            t = Template(setting.value)",
            "            value = t.render(vars())",
            "            try:",
            "                value = literal_eval(value)",
            "            except ValueError:",
            "                pass  # not a python data structure",
            "        except:",
            "            pass  # not templatable",
            "        value = ensure_type(value, setting.name)",
            "",
            "    set_constant(setting.name, value)",
            "",
            "for warn in config.WARNINGS:",
            "    _warning(warn)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "27": [
                "_deprecated"
            ]
        },
        "addLocation": [
            "lib.ansible.constants",
            "tuf.client.updater.Updater._get_target_from_targets_role"
        ]
    }
}