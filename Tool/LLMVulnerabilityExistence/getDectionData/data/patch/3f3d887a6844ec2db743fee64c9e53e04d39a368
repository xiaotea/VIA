{
    "django/contrib/auth/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.contrib.auth import authenticate"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.contrib.auth.models import User"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.contrib.auth.hashers import UNUSABLE_PASSWORD, is_password_usable, get_hasher"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from django.contrib.auth.hashers import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+    MAXIMUM_PASSWORD_LENGTH, UNUSABLE_PASSWORD,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    is_password_usable, get_hasher"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+)"
            },
            "8": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from django.contrib.auth.tokens import default_token_generator"
            },
            "9": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from django.contrib.sites.models import get_current_site"
            },
            "10": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "             'invalid': _(\"This value may contain only letters, numbers and \""
            },
            "12": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "                          \"@/./+/-/_ characters.\")})"
            },
            "13": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     password1 = forms.CharField(label=_(\"Password\"),"
            },
            "14": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        widget=forms.PasswordInput)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        widget=forms.PasswordInput, max_length=MAXIMUM_PASSWORD_LENGTH)"
            },
            "16": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     password2 = forms.CharField(label=_(\"Password confirmation\"),"
            },
            "17": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         widget=forms.PasswordInput,"
            },
            "18": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text = _(\"Enter the same password as above, for verification.\"))"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        help_text=_(\"Enter the same password as above, for verification.\"))"
            },
            "21": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     class Meta:"
            },
            "23": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         model = User"
            },
            "24": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     username/password logins."
            },
            "25": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     \"\"\""
            },
            "26": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "     username = forms.CharField(label=_(\"Username\"), max_length=30)"
            },
            "27": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password = forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    password = forms.CharField("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        label=_(\"Password\"),"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+    )"
            },
            "33": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "     error_messages = {"
            },
            "35": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         'invalid_login': _(\"Please enter a correct username and password. \""
            },
            "36": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "     error_messages = {"
            },
            "37": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "         'password_mismatch': _(\"The two password fields didn't match.\"),"
            },
            "38": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     }"
            },
            "39": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    new_password1 = forms.CharField(label=_(\"New password\"),"
            },
            "40": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    widget=forms.PasswordInput)"
            },
            "41": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    new_password2 = forms.CharField(label=_(\"New password confirmation\"),"
            },
            "42": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    widget=forms.PasswordInput)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+    new_password1 = forms.CharField("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+        label=_(\"New password\"),"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+    )"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+    new_password2 = forms.CharField("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+        label=_(\"New password confirmation\"),"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+    )"
            },
            "53": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 271,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "     def __init__(self, user, *args, **kwargs):"
            },
            "55": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "         self.user = user"
            },
            "56": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "         'password_incorrect': _(\"Your old password was entered incorrectly. \""
            },
            "57": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "                                 \"Please enter it again.\"),"
            },
            "58": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "     })"
            },
            "59": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    old_password = forms.CharField(label=_(\"Old password\"),"
            },
            "60": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   widget=forms.PasswordInput)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+    old_password = forms.CharField("
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+        label=_(\"Old password\"),"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+    )"
            },
            "66": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 306,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     def clean_old_password(self):"
            },
            "68": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         \"\"\""
            },
            "69": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "     error_messages = {"
            },
            "70": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "         'password_mismatch': _(\"The two password fields didn't match.\"),"
            },
            "71": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "     }"
            },
            "72": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password1 = forms.CharField(label=_(\"Password\"),"
            },
            "73": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                widget=forms.PasswordInput)"
            },
            "74": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password2 = forms.CharField(label=_(\"Password (again)\"),"
            },
            "75": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                widget=forms.PasswordInput)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+    password1 = forms.CharField("
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+        label=_(\"Password\"),"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+    )"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+    password2 = forms.CharField("
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        label=_(\"Password (again)\"),"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+    )"
            },
            "86": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 337,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "     def __init__(self, user, *args, **kwargs):"
            },
            "88": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "         self.user = user"
            }
        },
        "frontPatchFile": [
            "from django import forms",
            "from django.forms.util import flatatt",
            "from django.template import loader",
            "from django.utils.encoding import smart_str",
            "from django.utils.http import int_to_base36",
            "from django.utils.safestring import mark_safe",
            "from django.utils.translation import ugettext, ugettext_lazy as _",
            "",
            "from django.contrib.auth import authenticate",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.hashers import UNUSABLE_PASSWORD, is_password_usable, get_hasher",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import get_current_site",
            "",
            "UNMASKED_DIGITS_TO_SHOW = 6",
            "",
            "mask_password = lambda p: \"%s%s\" % (p[:UNMASKED_DIGITS_TO_SHOW], \"*\" * max(len(p) - UNMASKED_DIGITS_TO_SHOW, 0))",
            "",
            "",
            "class ReadOnlyPasswordHashWidget(forms.Widget):",
            "    def render(self, name, value, attrs):",
            "        encoded = value",
            "",
            "        if not is_password_usable(encoded):",
            "            return \"None\"",
            "",
            "        final_attrs = self.build_attrs(attrs)",
            "",
            "        encoded = smart_str(encoded)",
            "",
            "        if len(encoded) == 32 and '$' not in encoded:",
            "            algorithm = 'unsalted_md5'",
            "        else:",
            "            algorithm = encoded.split('$', 1)[0]",
            "",
            "        try:",
            "            hasher = get_hasher(algorithm)",
            "        except ValueError:",
            "            summary = \"<strong>Invalid password format or unknown hashing algorithm.</strong>\"",
            "        else:",
            "            summary = \"\"",
            "            for key, value in hasher.safe_summary(encoded).iteritems():",
            "                summary += \"<strong>%(key)s</strong>: %(value)s \" % {\"key\": ugettext(key), \"value\": value}",
            "",
            "        return mark_safe(\"<div%(attrs)s>%(summary)s</div>\" % {\"attrs\": flatatt(final_attrs), \"summary\": summary})",
            "",
            "",
            "class ReadOnlyPasswordHashField(forms.Field):",
            "    widget = ReadOnlyPasswordHashWidget",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault(\"required\", False)",
            "        super(ReadOnlyPasswordHashField, self).__init__(*args, **kwargs)",
            "",
            "",
            "class UserCreationForm(forms.ModelForm):",
            "    \"\"\"",
            "    A form that creates a user, with no privileges, from the given username and",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        'duplicate_username': _(\"A user with that username already exists.\"),",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    username = forms.RegexField(label=_(\"Username\"), max_length=30,",
            "        regex=r'^[\\w.@+-]+$',",
            "        help_text = _(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages = {",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password1 = forms.CharField(label=_(\"Password\"),",
            "        widget=forms.PasswordInput)",
            "    password2 = forms.CharField(label=_(\"Password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        help_text = _(\"Enter the same password as above, for verification.\"))",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "",
            "    def clean_username(self):",
            "        # Since User.username is unique, this check is redundant,",
            "        # but it sets a nicer error message than the ORM. See #13147.",
            "        username = self.cleaned_data[\"username\"]",
            "        try:",
            "            User.objects.get(username=username)",
            "        except User.DoesNotExist:",
            "            return username",
            "        raise forms.ValidationError(self.error_messages['duplicate_username'])",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get(\"password1\", \"\")",
            "        password2 = self.cleaned_data[\"password2\"]",
            "        if password1 != password2:",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        user = super(UserCreationForm, self).save(commit=False)",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            user.save()",
            "        return user",
            "",
            "",
            "class UserChangeForm(forms.ModelForm):",
            "    username = forms.RegexField(",
            "        label=_(\"Username\"), max_length=30, regex=r\"^[\\w.@+-]+$\",",
            "        help_text = _(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages = {",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password = ReadOnlyPasswordHashField(label=_(\"Password\"),",
            "        help_text=_(\"Raw passwords are not stored, so there is no way to see \"",
            "                    \"this user's password, but you can change the password \"",
            "                    \"using <a href=\\\"password/\\\">this form</a>.\"))",
            "",
            "    def clean_password(self):",
            "        return self.initial[\"password\"]",
            "",
            "    class Meta:",
            "        model = User",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(UserChangeForm, self).__init__(*args, **kwargs)",
            "        f = self.fields.get('user_permissions', None)",
            "        if f is not None:",
            "            f.queryset = f.queryset.select_related('content_type')",
            "",
            "",
            "class AuthenticationForm(forms.Form):",
            "    \"\"\"",
            "    Base class for authenticating users. Extend this to get a form that accepts",
            "    username/password logins.",
            "    \"\"\"",
            "    username = forms.CharField(label=_(\"Username\"), max_length=30)",
            "    password = forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput)",
            "",
            "    error_messages = {",
            "        'invalid_login': _(\"Please enter a correct username and password. \"",
            "                           \"Note that both fields are case-sensitive.\"),",
            "        'no_cookies': _(\"Your Web browser doesn't appear to have cookies \"",
            "                        \"enabled. Cookies are required for logging in.\"),",
            "        'inactive': _(\"This account is inactive.\"),",
            "    }",
            "",
            "    def __init__(self, request=None, *args, **kwargs):",
            "        \"\"\"",
            "        If request is passed in, the form will validate that cookies are",
            "        enabled. Note that the request (a HttpRequest object) must have set a",
            "        cookie with the key TEST_COOKIE_NAME and value TEST_COOKIE_VALUE before",
            "        running this validation.",
            "        \"\"\"",
            "        self.request = request",
            "        self.user_cache = None",
            "        super(AuthenticationForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean(self):",
            "        username = self.cleaned_data.get('username')",
            "        password = self.cleaned_data.get('password')",
            "",
            "        if username and password:",
            "            self.user_cache = authenticate(username=username,",
            "                                           password=password)",
            "            if self.user_cache is None:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['invalid_login'])",
            "            elif not self.user_cache.is_active:",
            "                raise forms.ValidationError(self.error_messages['inactive'])",
            "        self.check_for_test_cookie()",
            "        return self.cleaned_data",
            "",
            "    def check_for_test_cookie(self):",
            "        if self.request and not self.request.session.test_cookie_worked():",
            "            raise forms.ValidationError(self.error_messages['no_cookies'])",
            "",
            "    def get_user_id(self):",
            "        if self.user_cache:",
            "            return self.user_cache.id",
            "        return None",
            "",
            "    def get_user(self):",
            "        return self.user_cache",
            "",
            "",
            "class PasswordResetForm(forms.Form):",
            "    error_messages = {",
            "        'unknown': _(\"That e-mail address doesn't have an associated \"",
            "                     \"user account. Are you sure you've registered?\"),",
            "        'unusable': _(\"The user account associated with this e-mail \"",
            "                      \"address cannot reset the password.\"),",
            "    }",
            "    email = forms.EmailField(label=_(\"E-mail\"), max_length=75)",
            "",
            "    def clean_email(self):",
            "        \"\"\"",
            "        Validates that an active user exists with the given email address.",
            "        \"\"\"",
            "        email = self.cleaned_data[\"email\"]",
            "        self.users_cache = User.objects.filter(email__iexact=email,",
            "                                               is_active=True)",
            "        if not len(self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unknown'])",
            "        if any((user.password == UNUSABLE_PASSWORD)",
            "               for user in self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unusable'])",
            "        return email",
            "",
            "    def save(self, domain_override=None,",
            "             subject_template_name='registration/password_reset_subject.txt',",
            "             email_template_name='registration/password_reset_email.html',",
            "             use_https=False, token_generator=default_token_generator,",
            "             from_email=None, request=None):",
            "        \"\"\"",
            "        Generates a one-use only link for resetting password and sends to the",
            "        user.",
            "        \"\"\"",
            "        from django.core.mail import send_mail",
            "        for user in self.users_cache:",
            "            if not domain_override:",
            "                current_site = get_current_site(request)",
            "                site_name = current_site.name",
            "                domain = current_site.domain",
            "            else:",
            "                site_name = domain = domain_override",
            "            c = {",
            "                'email': user.email,",
            "                'domain': domain,",
            "                'site_name': site_name,",
            "                'uid': int_to_base36(user.id),",
            "                'user': user,",
            "                'token': token_generator.make_token(user),",
            "                'protocol': use_https and 'https' or 'http',",
            "            }",
            "            subject = loader.render_to_string(subject_template_name, c)",
            "            # Email subject *must not* contain newlines",
            "            subject = ''.join(subject.splitlines())",
            "            email = loader.render_to_string(email_template_name, c)",
            "            send_mail(subject, email, from_email, [user.email])",
            "",
            "",
            "class SetPasswordForm(forms.Form):",
            "    \"\"\"",
            "    A form that lets a user change set his/her password without entering the",
            "    old password",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    new_password1 = forms.CharField(label=_(\"New password\"),",
            "                                    widget=forms.PasswordInput)",
            "    new_password2 = forms.CharField(label=_(\"New password confirmation\"),",
            "                                    widget=forms.PasswordInput)",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(SetPasswordForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_new_password2(self):",
            "        password1 = self.cleaned_data.get('new_password1')",
            "        password2 = self.cleaned_data.get('new_password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        self.user.set_password(self.cleaned_data['new_password1'])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "",
            "class PasswordChangeForm(SetPasswordForm):",
            "    \"\"\"",
            "    A form that lets a user change his/her password by entering",
            "    their old password.",
            "    \"\"\"",
            "    error_messages = dict(SetPasswordForm.error_messages, **{",
            "        'password_incorrect': _(\"Your old password was entered incorrectly. \"",
            "                                \"Please enter it again.\"),",
            "    })",
            "    old_password = forms.CharField(label=_(\"Old password\"),",
            "                                   widget=forms.PasswordInput)",
            "",
            "    def clean_old_password(self):",
            "        \"\"\"",
            "        Validates that the old_password field is correct.",
            "        \"\"\"",
            "        old_password = self.cleaned_data[\"old_password\"]",
            "        if not self.user.check_password(old_password):",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_incorrect'])",
            "        return old_password",
            "PasswordChangeForm.base_fields.keyOrder = ['old_password', 'new_password1',",
            "                                           'new_password2']",
            "",
            "",
            "class AdminPasswordChangeForm(forms.Form):",
            "    \"\"\"",
            "    A form used to change the password of a user in the admin interface.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    password1 = forms.CharField(label=_(\"Password\"),",
            "                                widget=forms.PasswordInput)",
            "    password2 = forms.CharField(label=_(\"Password (again)\"),",
            "                                widget=forms.PasswordInput)",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(AdminPasswordChangeForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get('password1')",
            "        password2 = self.cleaned_data.get('password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        \"\"\"",
            "        Saves the new password.",
            "        \"\"\"",
            "        self.user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user"
        ],
        "afterPatchFile": [
            "from django import forms",
            "from django.forms.util import flatatt",
            "from django.template import loader",
            "from django.utils.encoding import smart_str",
            "from django.utils.http import int_to_base36",
            "from django.utils.safestring import mark_safe",
            "from django.utils.translation import ugettext, ugettext_lazy as _",
            "",
            "from django.contrib.auth import authenticate",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.hashers import (",
            "    MAXIMUM_PASSWORD_LENGTH, UNUSABLE_PASSWORD,",
            "    is_password_usable, get_hasher",
            ")",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import get_current_site",
            "",
            "UNMASKED_DIGITS_TO_SHOW = 6",
            "",
            "mask_password = lambda p: \"%s%s\" % (p[:UNMASKED_DIGITS_TO_SHOW], \"*\" * max(len(p) - UNMASKED_DIGITS_TO_SHOW, 0))",
            "",
            "",
            "class ReadOnlyPasswordHashWidget(forms.Widget):",
            "    def render(self, name, value, attrs):",
            "        encoded = value",
            "",
            "        if not is_password_usable(encoded):",
            "            return \"None\"",
            "",
            "        final_attrs = self.build_attrs(attrs)",
            "",
            "        encoded = smart_str(encoded)",
            "",
            "        if len(encoded) == 32 and '$' not in encoded:",
            "            algorithm = 'unsalted_md5'",
            "        else:",
            "            algorithm = encoded.split('$', 1)[0]",
            "",
            "        try:",
            "            hasher = get_hasher(algorithm)",
            "        except ValueError:",
            "            summary = \"<strong>Invalid password format or unknown hashing algorithm.</strong>\"",
            "        else:",
            "            summary = \"\"",
            "            for key, value in hasher.safe_summary(encoded).iteritems():",
            "                summary += \"<strong>%(key)s</strong>: %(value)s \" % {\"key\": ugettext(key), \"value\": value}",
            "",
            "        return mark_safe(\"<div%(attrs)s>%(summary)s</div>\" % {\"attrs\": flatatt(final_attrs), \"summary\": summary})",
            "",
            "",
            "class ReadOnlyPasswordHashField(forms.Field):",
            "    widget = ReadOnlyPasswordHashWidget",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault(\"required\", False)",
            "        super(ReadOnlyPasswordHashField, self).__init__(*args, **kwargs)",
            "",
            "",
            "class UserCreationForm(forms.ModelForm):",
            "    \"\"\"",
            "    A form that creates a user, with no privileges, from the given username and",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        'duplicate_username': _(\"A user with that username already exists.\"),",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    username = forms.RegexField(label=_(\"Username\"), max_length=30,",
            "        regex=r'^[\\w.@+-]+$',",
            "        help_text = _(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages = {",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password1 = forms.CharField(label=_(\"Password\"),",
            "        widget=forms.PasswordInput, max_length=MAXIMUM_PASSWORD_LENGTH)",
            "    password2 = forms.CharField(label=_(\"Password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "        help_text=_(\"Enter the same password as above, for verification.\"))",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "",
            "    def clean_username(self):",
            "        # Since User.username is unique, this check is redundant,",
            "        # but it sets a nicer error message than the ORM. See #13147.",
            "        username = self.cleaned_data[\"username\"]",
            "        try:",
            "            User.objects.get(username=username)",
            "        except User.DoesNotExist:",
            "            return username",
            "        raise forms.ValidationError(self.error_messages['duplicate_username'])",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get(\"password1\", \"\")",
            "        password2 = self.cleaned_data[\"password2\"]",
            "        if password1 != password2:",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        user = super(UserCreationForm, self).save(commit=False)",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            user.save()",
            "        return user",
            "",
            "",
            "class UserChangeForm(forms.ModelForm):",
            "    username = forms.RegexField(",
            "        label=_(\"Username\"), max_length=30, regex=r\"^[\\w.@+-]+$\",",
            "        help_text = _(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages = {",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password = ReadOnlyPasswordHashField(label=_(\"Password\"),",
            "        help_text=_(\"Raw passwords are not stored, so there is no way to see \"",
            "                    \"this user's password, but you can change the password \"",
            "                    \"using <a href=\\\"password/\\\">this form</a>.\"))",
            "",
            "    def clean_password(self):",
            "        return self.initial[\"password\"]",
            "",
            "    class Meta:",
            "        model = User",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(UserChangeForm, self).__init__(*args, **kwargs)",
            "        f = self.fields.get('user_permissions', None)",
            "        if f is not None:",
            "            f.queryset = f.queryset.select_related('content_type')",
            "",
            "",
            "class AuthenticationForm(forms.Form):",
            "    \"\"\"",
            "    Base class for authenticating users. Extend this to get a form that accepts",
            "    username/password logins.",
            "    \"\"\"",
            "    username = forms.CharField(label=_(\"Username\"), max_length=30)",
            "    password = forms.CharField(",
            "        label=_(\"Password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    error_messages = {",
            "        'invalid_login': _(\"Please enter a correct username and password. \"",
            "                           \"Note that both fields are case-sensitive.\"),",
            "        'no_cookies': _(\"Your Web browser doesn't appear to have cookies \"",
            "                        \"enabled. Cookies are required for logging in.\"),",
            "        'inactive': _(\"This account is inactive.\"),",
            "    }",
            "",
            "    def __init__(self, request=None, *args, **kwargs):",
            "        \"\"\"",
            "        If request is passed in, the form will validate that cookies are",
            "        enabled. Note that the request (a HttpRequest object) must have set a",
            "        cookie with the key TEST_COOKIE_NAME and value TEST_COOKIE_VALUE before",
            "        running this validation.",
            "        \"\"\"",
            "        self.request = request",
            "        self.user_cache = None",
            "        super(AuthenticationForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean(self):",
            "        username = self.cleaned_data.get('username')",
            "        password = self.cleaned_data.get('password')",
            "",
            "        if username and password:",
            "            self.user_cache = authenticate(username=username,",
            "                                           password=password)",
            "            if self.user_cache is None:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['invalid_login'])",
            "            elif not self.user_cache.is_active:",
            "                raise forms.ValidationError(self.error_messages['inactive'])",
            "        self.check_for_test_cookie()",
            "        return self.cleaned_data",
            "",
            "    def check_for_test_cookie(self):",
            "        if self.request and not self.request.session.test_cookie_worked():",
            "            raise forms.ValidationError(self.error_messages['no_cookies'])",
            "",
            "    def get_user_id(self):",
            "        if self.user_cache:",
            "            return self.user_cache.id",
            "        return None",
            "",
            "    def get_user(self):",
            "        return self.user_cache",
            "",
            "",
            "class PasswordResetForm(forms.Form):",
            "    error_messages = {",
            "        'unknown': _(\"That e-mail address doesn't have an associated \"",
            "                     \"user account. Are you sure you've registered?\"),",
            "        'unusable': _(\"The user account associated with this e-mail \"",
            "                      \"address cannot reset the password.\"),",
            "    }",
            "    email = forms.EmailField(label=_(\"E-mail\"), max_length=75)",
            "",
            "    def clean_email(self):",
            "        \"\"\"",
            "        Validates that an active user exists with the given email address.",
            "        \"\"\"",
            "        email = self.cleaned_data[\"email\"]",
            "        self.users_cache = User.objects.filter(email__iexact=email,",
            "                                               is_active=True)",
            "        if not len(self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unknown'])",
            "        if any((user.password == UNUSABLE_PASSWORD)",
            "               for user in self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unusable'])",
            "        return email",
            "",
            "    def save(self, domain_override=None,",
            "             subject_template_name='registration/password_reset_subject.txt',",
            "             email_template_name='registration/password_reset_email.html',",
            "             use_https=False, token_generator=default_token_generator,",
            "             from_email=None, request=None):",
            "        \"\"\"",
            "        Generates a one-use only link for resetting password and sends to the",
            "        user.",
            "        \"\"\"",
            "        from django.core.mail import send_mail",
            "        for user in self.users_cache:",
            "            if not domain_override:",
            "                current_site = get_current_site(request)",
            "                site_name = current_site.name",
            "                domain = current_site.domain",
            "            else:",
            "                site_name = domain = domain_override",
            "            c = {",
            "                'email': user.email,",
            "                'domain': domain,",
            "                'site_name': site_name,",
            "                'uid': int_to_base36(user.id),",
            "                'user': user,",
            "                'token': token_generator.make_token(user),",
            "                'protocol': use_https and 'https' or 'http',",
            "            }",
            "            subject = loader.render_to_string(subject_template_name, c)",
            "            # Email subject *must not* contain newlines",
            "            subject = ''.join(subject.splitlines())",
            "            email = loader.render_to_string(email_template_name, c)",
            "            send_mail(subject, email, from_email, [user.email])",
            "",
            "",
            "class SetPasswordForm(forms.Form):",
            "    \"\"\"",
            "    A form that lets a user change set his/her password without entering the",
            "    old password",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    new_password1 = forms.CharField(",
            "        label=_(\"New password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "    new_password2 = forms.CharField(",
            "        label=_(\"New password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(SetPasswordForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_new_password2(self):",
            "        password1 = self.cleaned_data.get('new_password1')",
            "        password2 = self.cleaned_data.get('new_password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        self.user.set_password(self.cleaned_data['new_password1'])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "",
            "class PasswordChangeForm(SetPasswordForm):",
            "    \"\"\"",
            "    A form that lets a user change his/her password by entering",
            "    their old password.",
            "    \"\"\"",
            "    error_messages = dict(SetPasswordForm.error_messages, **{",
            "        'password_incorrect': _(\"Your old password was entered incorrectly. \"",
            "                                \"Please enter it again.\"),",
            "    })",
            "    old_password = forms.CharField(",
            "        label=_(\"Old password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    def clean_old_password(self):",
            "        \"\"\"",
            "        Validates that the old_password field is correct.",
            "        \"\"\"",
            "        old_password = self.cleaned_data[\"old_password\"]",
            "        if not self.user.check_password(old_password):",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_incorrect'])",
            "        return old_password",
            "PasswordChangeForm.base_fields.keyOrder = ['old_password', 'new_password1',",
            "                                           'new_password2']",
            "",
            "",
            "class AdminPasswordChangeForm(forms.Form):",
            "    \"\"\"",
            "    A form used to change the password of a user in the admin interface.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    password1 = forms.CharField(",
            "        label=_(\"Password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "    password2 = forms.CharField(",
            "        label=_(\"Password (again)\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(AdminPasswordChangeForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get('password1')",
            "        password2 = self.cleaned_data.get('password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        \"\"\"",
            "        Saves the new password.",
            "        \"\"\"",
            "        self.user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "73": [
                "UserCreationForm"
            ],
            "76": [
                "UserCreationForm"
            ],
            "140": [
                "AuthenticationForm"
            ],
            "253": [
                "SetPasswordForm"
            ],
            "254": [
                "SetPasswordForm"
            ],
            "255": [
                "SetPasswordForm"
            ],
            "256": [
                "SetPasswordForm"
            ],
            "287": [
                "PasswordChangeForm"
            ],
            "288": [
                "PasswordChangeForm"
            ],
            "310": [
                "AdminPasswordChangeForm"
            ],
            "311": [
                "AdminPasswordChangeForm"
            ],
            "312": [
                "AdminPasswordChangeForm"
            ],
            "313": [
                "AdminPasswordChangeForm"
            ]
        },
        "addLocation": []
    },
    "django/contrib/auth/hashers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import functools"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import hashlib"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.conf import settings"
            },
            "4": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " UNUSABLE_PASSWORD = '!'  # This will never be a valid encoded hash"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+MAXIMUM_PASSWORD_LENGTH = 4096  # The maximum length a password can be to prevent DoS"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " HASHERS = None  # lazily loaded from PASSWORD_HASHERS"
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " PREFERRED_HASHER = None  # defaults to first item in PASSWORD_HASHERS"
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+def password_max_length(max_length):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    def inner(fn):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+        @functools.wraps(fn)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+        def wrapper(self, password, *args, **kwargs):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+            if len(password) > max_length:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+                raise ValueError(\"Invalid password; Must be less than or equal\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+                                 \" to %d bytes\" % max_length)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+            return fn(self, password, *args, **kwargs)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        return wrapper"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    return inner"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " def is_password_usable(encoded):"
            },
            "25": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     return (encoded is not None and encoded != UNUSABLE_PASSWORD)"
            },
            "26": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "     iterations = 10000"
            },
            "28": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "     digest = hashlib.sha256"
            },
            "29": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 218,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "31": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "     def encode(self, password, salt, iterations=None):"
            },
            "32": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         assert password"
            },
            "33": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         assert salt and '$' not in salt"
            },
            "34": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         hash = hash.encode('base64').strip()"
            },
            "35": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "         return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)"
            },
            "36": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "38": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "39": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         algorithm, iterations, salt, hash = encoded.split('$', 3)"
            },
            "40": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "41": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "         bcrypt = self._load_library()"
            },
            "42": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "         return bcrypt.gensalt(self.rounds)"
            },
            "43": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 274,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "45": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "46": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         bcrypt = self._load_library()"
            },
            "47": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "         data = bcrypt.hashpw(password, salt)"
            },
            "48": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         return \"%s$%s\" % (self.algorithm, data)"
            },
            "49": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 280,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "51": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "52": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         algorithm, data = encoded.split('$', 1)"
            },
            "53": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "54": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "     \"\"\""
            },
            "55": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "     algorithm = \"sha1\""
            },
            "56": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 305,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "58": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "59": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         assert password"
            },
            "60": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "         assert salt and '$' not in salt"
            },
            "61": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "         hash = hashlib.sha1(salt + password).hexdigest()"
            },
            "62": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "         return \"%s$%s$%s\" % (self.algorithm, salt, hash)"
            },
            "63": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 312,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "65": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "66": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "         algorithm, salt, hash = encoded.split('$', 2)"
            },
            "67": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "68": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "     \"\"\""
            },
            "69": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "     algorithm = \"md5\""
            },
            "70": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 335,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "72": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "73": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "         assert password"
            },
            "74": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "         assert salt and '$' not in salt"
            },
            "75": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "         hash = hashlib.md5(salt + password).hexdigest()"
            },
            "76": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "         return \"%s$%s$%s\" % (self.algorithm, salt, hash)"
            },
            "77": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 342,
                "PatchRowcode": " "
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "79": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "80": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "         algorithm, salt, hash = encoded.split('$', 2)"
            },
            "81": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "82": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "     def salt(self):"
            },
            "83": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "         return ''"
            },
            "84": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 373,
                "PatchRowcode": " "
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "86": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "87": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "         assert salt == ''"
            },
            "88": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "         hash = hashlib.sha1(password).hexdigest()"
            },
            "89": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "         return 'sha1$$%s' % hash"
            },
            "90": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 379,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "92": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "93": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "         encoded_2 = self.encode(password, '')"
            },
            "94": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "         return constant_time_compare(encoded, encoded_2)"
            },
            "95": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "     def salt(self):"
            },
            "96": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         return ''"
            },
            "97": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 409,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "99": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "100": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 412,
                "PatchRowcode": "         assert salt == ''"
            },
            "101": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 413,
                "PatchRowcode": "         return hashlib.md5(password).hexdigest()"
            },
            "102": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 414,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "104": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "105": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 417,
                "PatchRowcode": "         if len(encoded) == 37 and encoded.startswith('md5$$'):"
            },
            "106": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 418,
                "PatchRowcode": "             encoded = encoded[5:]"
            },
            "107": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "     def salt(self):"
            },
            "108": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "         return get_random_string(2)"
            },
            "109": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 440,
                "PatchRowcode": " "
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "111": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "112": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "         crypt = self._load_library()"
            },
            "113": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 444,
                "PatchRowcode": "         assert len(salt) == 2"
            },
            "114": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "         data = crypt.crypt(password, salt)"
            },
            "115": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "         # we don't need to store the salt, but Django used to do this"
            },
            "116": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "         return \"%s$%s$%s\" % (self.algorithm, '', data)"
            },
            "117": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 448,
                "PatchRowcode": " "
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "119": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "120": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "         crypt = self._load_library()"
            },
            "121": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "         algorithm, salt, data = encoded.split('$', 2)"
            },
            "122": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "             (_('salt'), salt),"
            },
            "123": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "             (_('hash'), mask_hash(data, show=3)),"
            },
            "124": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "         ])"
            },
            "125": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "",
            "from django.conf import settings",
            "from django.utils import importlib",
            "from django.utils.datastructures import SortedDict",
            "from django.utils.encoding import smart_str",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.crypto import (",
            "    pbkdf2, constant_time_compare, get_random_string)",
            "from django.utils.translation import ugettext_noop as _",
            "",
            "",
            "UNUSABLE_PASSWORD = '!'  # This will never be a valid encoded hash",
            "HASHERS = None  # lazily loaded from PASSWORD_HASHERS",
            "PREFERRED_HASHER = None  # defaults to first item in PASSWORD_HASHERS",
            "",
            "",
            "def is_password_usable(encoded):",
            "    return (encoded is not None and encoded != UNUSABLE_PASSWORD)",
            "",
            "",
            "def check_password(password, encoded, setter=None, preferred='default'):",
            "    \"\"\"",
            "    Returns a boolean of whether the raw password matches the three",
            "    part encoded digest.",
            "",
            "    If setter is specified, it'll be called when you need to",
            "    regenerate the password.",
            "    \"\"\"",
            "    if not password or not is_password_usable(encoded):",
            "        return False",
            "",
            "    preferred = get_hasher(preferred)",
            "    raw_password = password",
            "    password = smart_str(password)",
            "    encoded = smart_str(encoded)",
            "",
            "    # Ancient versions of Django created plain MD5 passwords and accepted",
            "    # MD5 passwords with an empty salt.",
            "    if ((len(encoded) == 32 and '$' not in encoded) or",
            "            (len(encoded) == 37 and encoded.startswith('md5$$'))):",
            "        hasher = get_hasher('unsalted_md5')",
            "    # Ancient versions of Django accepted SHA1 passwords with an empty salt.",
            "    elif len(encoded) == 46 and encoded.startswith('sha1$$'):",
            "        hasher = get_hasher('unsalted_sha1')",
            "    else:",
            "        algorithm = encoded.split('$', 1)[0]",
            "        hasher = get_hasher(algorithm)",
            "",
            "    must_update = hasher.algorithm != preferred.algorithm",
            "    is_correct = hasher.verify(password, encoded)",
            "    if setter and is_correct and must_update:",
            "        setter(raw_password)",
            "    return is_correct",
            "",
            "",
            "def make_password(password, salt=None, hasher='default'):",
            "    \"\"\"",
            "    Turn a plain-text password into a hash for database storage",
            "",
            "    Same as encode() but generates a new random salt.  If",
            "    password is None or blank then UNUSABLE_PASSWORD will be",
            "    returned which disallows logins.",
            "    \"\"\"",
            "    if not password:",
            "        return UNUSABLE_PASSWORD",
            "",
            "    hasher = get_hasher(hasher)",
            "    password = smart_str(password)",
            "",
            "    if not salt:",
            "        salt = hasher.salt()",
            "    salt = smart_str(salt)",
            "",
            "    return hasher.encode(password, salt)",
            "",
            "",
            "def load_hashers(password_hashers=None):",
            "    global HASHERS",
            "    global PREFERRED_HASHER",
            "    hashers = []",
            "    if not password_hashers:",
            "        password_hashers = settings.PASSWORD_HASHERS",
            "    for backend in password_hashers:",
            "        try:",
            "            mod_path, cls_name = backend.rsplit('.', 1)",
            "            mod = importlib.import_module(mod_path)",
            "            hasher_cls = getattr(mod, cls_name)",
            "        except (AttributeError, ImportError, ValueError):",
            "            raise ImproperlyConfigured(\"hasher not found: %s\" % backend)",
            "        hasher = hasher_cls()",
            "        if not getattr(hasher, 'algorithm'):",
            "            raise ImproperlyConfigured(\"hasher doesn't specify an \"",
            "                                       \"algorithm name: %s\" % backend)",
            "        hashers.append(hasher)",
            "    HASHERS = dict([(hasher.algorithm, hasher) for hasher in hashers])",
            "    PREFERRED_HASHER = hashers[0]",
            "",
            "",
            "def get_hasher(algorithm='default'):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    If algorithm is 'default', the default hasher will be returned.",
            "    This function will also lazy import hashers specified in your",
            "    settings file if needed.",
            "    \"\"\"",
            "    if hasattr(algorithm, 'algorithm'):",
            "        return algorithm",
            "",
            "    elif algorithm == 'default':",
            "        if PREFERRED_HASHER is None:",
            "            load_hashers()",
            "        return PREFERRED_HASHER",
            "    else:",
            "        if HASHERS is None:",
            "            load_hashers()",
            "        if algorithm not in HASHERS:",
            "            raise ValueError(\"Unknown password hashing algorithm '%s'. \"",
            "                             \"Did you specify it in the PASSWORD_HASHERS \"",
            "                             \"setting?\" % algorithm)",
            "        return HASHERS[algorithm]",
            "",
            "",
            "def mask_hash(hash, show=6, char=\"*\"):",
            "    \"\"\"",
            "    Returns the given hash, with only the first ``show`` number shown. The",
            "    rest are masked with ``char`` for security reasons.",
            "    \"\"\"",
            "    masked = hash[:show]",
            "    masked += char * len(hash[show:])",
            "    return masked",
            "",
            "",
            "class BasePasswordHasher(object):",
            "    \"\"\"",
            "    Abstract base class for password hashers",
            "",
            "    When creating your own hasher, you need to override algorithm,",
            "    verify(), encode() and safe_summary().",
            "",
            "    PasswordHasher objects are immutable.",
            "    \"\"\"",
            "    algorithm = None",
            "    library = None",
            "",
            "    def _load_library(self):",
            "        if self.library is not None:",
            "            if isinstance(self.library, (tuple, list)):",
            "                name, mod_path = self.library",
            "            else:",
            "                name = mod_path = self.library",
            "            try:",
            "                module = importlib.import_module(mod_path)",
            "            except ImportError:",
            "                raise ValueError(\"Couldn't load %s password algorithm \"",
            "                                 \"library\" % name)",
            "            return module",
            "        raise ValueError(\"Hasher '%s' doesn't specify a library attribute\" %",
            "                         self.__class__)",
            "",
            "    def salt(self):",
            "        \"\"\"",
            "        Generates a cryptographically secure nonce salt in ascii",
            "        \"\"\"",
            "        return get_random_string()",
            "",
            "    def verify(self, password, encoded):",
            "        \"\"\"",
            "        Checks if the given password is correct",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def encode(self, password, salt):",
            "        \"\"\"",
            "        Creates an encoded database value",
            "",
            "        The result is normally formatted as \"algorithm$salt$hash\" and",
            "        must be fewer than 128 characters.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def safe_summary(self, encoded):",
            "        \"\"\"",
            "        Returns a summary of safe values",
            "",
            "        The result is a dictionary and will be used where the password field",
            "        must be displayed to construct a safe representation of the password.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class PBKDF2PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the PBKDF2 algorithm (recommended)",
            "",
            "    Configured to use PBKDF2 + HMAC + SHA256 with 10000 iterations.",
            "    The result is a 64 byte binary string.  Iterations may be changed",
            "    safely but you must rename the algorithm if you change SHA256.",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha256\"",
            "    iterations = 10000",
            "    digest = hashlib.sha256",
            "",
            "    def encode(self, password, salt, iterations=None):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        if not iterations:",
            "            iterations = self.iterations",
            "        hash = pbkdf2(password, salt, iterations, digest=self.digest)",
            "        hash = hash.encode('base64').strip()",
            "        return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt, int(iterations))",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('iterations'), iterations),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
            "    \"\"\"",
            "    Alternate PBKDF2 hasher which uses SHA1, the default PRF",
            "    recommended by PKCS #5. This is compatible with other",
            "    implementations of PBKDF2, such as openssl's",
            "    PKCS5_PBKDF2_HMAC_SHA1().",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha1\"",
            "    digest = hashlib.sha1",
            "",
            "",
            "class BCryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm (recommended)",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the py-bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "    \"\"\"",
            "    algorithm = \"bcrypt\"",
            "    library = (\"py-bcrypt\", \"bcrypt\")",
            "    rounds = 12",
            "",
            "    def salt(self):",
            "        bcrypt = self._load_library()",
            "        return bcrypt.gensalt(self.rounds)",
            "",
            "    def encode(self, password, salt):",
            "        bcrypt = self._load_library()",
            "        data = bcrypt.hashpw(password, salt)",
            "        return \"%s$%s\" % (self.algorithm, data)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, data = encoded.split('$', 1)",
            "        assert algorithm == self.algorithm",
            "        bcrypt = self._load_library()",
            "        return constant_time_compare(data, bcrypt.hashpw(password, data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
            "        assert algorithm == self.algorithm",
            "        salt, checksum = data[:22], data[22:]",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('work factor'), work_factor),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('checksum'), mask_hash(checksum)),",
            "        ])",
            "",
            "",
            "class SHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The SHA1 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"sha1\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.sha1(salt + password).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class MD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The Salted MD5 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"md5\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.md5(salt + password).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Very insecure algorithm that you should *never* use; stores SHA1 hashes",
            "    with an empty salt.",
            "",
            "    This class is implemented because Django used to accept such password",
            "    hashes. Some older Django installs still have these values lingering",
            "    around so we need to handle and upgrade them properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_sha1\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        hash = hashlib.sha1(password).hexdigest()",
            "        return 'sha1$$%s' % hash",
            "",
            "    def verify(self, password, encoded):",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        assert encoded.startswith('sha1$$')",
            "        hash = encoded[6:]",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Incredibly insecure algorithm that you should *never* use; stores unsalted",
            "    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an",
            "    empty salt.",
            "",
            "    This class is implemented because Django used to store passwords this way",
            "    and to accept such password hashes. Some older Django installs still have",
            "    these values lingering around so we need to handle and upgrade them",
            "    properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_md5\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        return hashlib.md5(password).hexdigest()",
            "",
            "    def verify(self, password, encoded):",
            "        if len(encoded) == 37 and encoded.startswith('md5$$'):",
            "            encoded = encoded[5:]",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(encoded, show=3)),",
            "        ])",
            "",
            "",
            "class CryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Password hashing using UNIX crypt (not recommended)",
            "",
            "    The crypt module is not supported on all platforms.",
            "    \"\"\"",
            "    algorithm = \"crypt\"",
            "    library = \"crypt\"",
            "",
            "    def salt(self):",
            "        return get_random_string(2)",
            "",
            "    def encode(self, password, salt):",
            "        crypt = self._load_library()",
            "        assert len(salt) == 2",
            "        data = crypt.crypt(password, salt)",
            "        # we don't need to store the salt, but Django used to do this",
            "        return \"%s$%s$%s\" % (self.algorithm, '', data)",
            "",
            "    def verify(self, password, encoded):",
            "        crypt = self._load_library()",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return constant_time_compare(data, crypt.crypt(password, data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), salt),",
            "            (_('hash'), mask_hash(data, show=3)),",
            "        ])"
        ],
        "afterPatchFile": [
            "import functools",
            "import hashlib",
            "",
            "from django.conf import settings",
            "from django.utils import importlib",
            "from django.utils.datastructures import SortedDict",
            "from django.utils.encoding import smart_str",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.crypto import (",
            "    pbkdf2, constant_time_compare, get_random_string)",
            "from django.utils.translation import ugettext_noop as _",
            "",
            "",
            "UNUSABLE_PASSWORD = '!'  # This will never be a valid encoded hash",
            "MAXIMUM_PASSWORD_LENGTH = 4096  # The maximum length a password can be to prevent DoS",
            "HASHERS = None  # lazily loaded from PASSWORD_HASHERS",
            "PREFERRED_HASHER = None  # defaults to first item in PASSWORD_HASHERS",
            "",
            "",
            "def password_max_length(max_length):",
            "    def inner(fn):",
            "        @functools.wraps(fn)",
            "        def wrapper(self, password, *args, **kwargs):",
            "            if len(password) > max_length:",
            "                raise ValueError(\"Invalid password; Must be less than or equal\"",
            "                                 \" to %d bytes\" % max_length)",
            "            return fn(self, password, *args, **kwargs)",
            "        return wrapper",
            "    return inner",
            "",
            "",
            "def is_password_usable(encoded):",
            "    return (encoded is not None and encoded != UNUSABLE_PASSWORD)",
            "",
            "",
            "def check_password(password, encoded, setter=None, preferred='default'):",
            "    \"\"\"",
            "    Returns a boolean of whether the raw password matches the three",
            "    part encoded digest.",
            "",
            "    If setter is specified, it'll be called when you need to",
            "    regenerate the password.",
            "    \"\"\"",
            "    if not password or not is_password_usable(encoded):",
            "        return False",
            "",
            "    preferred = get_hasher(preferred)",
            "    raw_password = password",
            "    password = smart_str(password)",
            "    encoded = smart_str(encoded)",
            "",
            "    # Ancient versions of Django created plain MD5 passwords and accepted",
            "    # MD5 passwords with an empty salt.",
            "    if ((len(encoded) == 32 and '$' not in encoded) or",
            "            (len(encoded) == 37 and encoded.startswith('md5$$'))):",
            "        hasher = get_hasher('unsalted_md5')",
            "    # Ancient versions of Django accepted SHA1 passwords with an empty salt.",
            "    elif len(encoded) == 46 and encoded.startswith('sha1$$'):",
            "        hasher = get_hasher('unsalted_sha1')",
            "    else:",
            "        algorithm = encoded.split('$', 1)[0]",
            "        hasher = get_hasher(algorithm)",
            "",
            "    must_update = hasher.algorithm != preferred.algorithm",
            "    is_correct = hasher.verify(password, encoded)",
            "    if setter and is_correct and must_update:",
            "        setter(raw_password)",
            "    return is_correct",
            "",
            "",
            "def make_password(password, salt=None, hasher='default'):",
            "    \"\"\"",
            "    Turn a plain-text password into a hash for database storage",
            "",
            "    Same as encode() but generates a new random salt.  If",
            "    password is None or blank then UNUSABLE_PASSWORD will be",
            "    returned which disallows logins.",
            "    \"\"\"",
            "    if not password:",
            "        return UNUSABLE_PASSWORD",
            "",
            "    hasher = get_hasher(hasher)",
            "    password = smart_str(password)",
            "",
            "    if not salt:",
            "        salt = hasher.salt()",
            "    salt = smart_str(salt)",
            "",
            "    return hasher.encode(password, salt)",
            "",
            "",
            "def load_hashers(password_hashers=None):",
            "    global HASHERS",
            "    global PREFERRED_HASHER",
            "    hashers = []",
            "    if not password_hashers:",
            "        password_hashers = settings.PASSWORD_HASHERS",
            "    for backend in password_hashers:",
            "        try:",
            "            mod_path, cls_name = backend.rsplit('.', 1)",
            "            mod = importlib.import_module(mod_path)",
            "            hasher_cls = getattr(mod, cls_name)",
            "        except (AttributeError, ImportError, ValueError):",
            "            raise ImproperlyConfigured(\"hasher not found: %s\" % backend)",
            "        hasher = hasher_cls()",
            "        if not getattr(hasher, 'algorithm'):",
            "            raise ImproperlyConfigured(\"hasher doesn't specify an \"",
            "                                       \"algorithm name: %s\" % backend)",
            "        hashers.append(hasher)",
            "    HASHERS = dict([(hasher.algorithm, hasher) for hasher in hashers])",
            "    PREFERRED_HASHER = hashers[0]",
            "",
            "",
            "def get_hasher(algorithm='default'):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    If algorithm is 'default', the default hasher will be returned.",
            "    This function will also lazy import hashers specified in your",
            "    settings file if needed.",
            "    \"\"\"",
            "    if hasattr(algorithm, 'algorithm'):",
            "        return algorithm",
            "",
            "    elif algorithm == 'default':",
            "        if PREFERRED_HASHER is None:",
            "            load_hashers()",
            "        return PREFERRED_HASHER",
            "    else:",
            "        if HASHERS is None:",
            "            load_hashers()",
            "        if algorithm not in HASHERS:",
            "            raise ValueError(\"Unknown password hashing algorithm '%s'. \"",
            "                             \"Did you specify it in the PASSWORD_HASHERS \"",
            "                             \"setting?\" % algorithm)",
            "        return HASHERS[algorithm]",
            "",
            "",
            "def mask_hash(hash, show=6, char=\"*\"):",
            "    \"\"\"",
            "    Returns the given hash, with only the first ``show`` number shown. The",
            "    rest are masked with ``char`` for security reasons.",
            "    \"\"\"",
            "    masked = hash[:show]",
            "    masked += char * len(hash[show:])",
            "    return masked",
            "",
            "",
            "class BasePasswordHasher(object):",
            "    \"\"\"",
            "    Abstract base class for password hashers",
            "",
            "    When creating your own hasher, you need to override algorithm,",
            "    verify(), encode() and safe_summary().",
            "",
            "    PasswordHasher objects are immutable.",
            "    \"\"\"",
            "    algorithm = None",
            "    library = None",
            "",
            "    def _load_library(self):",
            "        if self.library is not None:",
            "            if isinstance(self.library, (tuple, list)):",
            "                name, mod_path = self.library",
            "            else:",
            "                name = mod_path = self.library",
            "            try:",
            "                module = importlib.import_module(mod_path)",
            "            except ImportError:",
            "                raise ValueError(\"Couldn't load %s password algorithm \"",
            "                                 \"library\" % name)",
            "            return module",
            "        raise ValueError(\"Hasher '%s' doesn't specify a library attribute\" %",
            "                         self.__class__)",
            "",
            "    def salt(self):",
            "        \"\"\"",
            "        Generates a cryptographically secure nonce salt in ascii",
            "        \"\"\"",
            "        return get_random_string()",
            "",
            "    def verify(self, password, encoded):",
            "        \"\"\"",
            "        Checks if the given password is correct",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def encode(self, password, salt):",
            "        \"\"\"",
            "        Creates an encoded database value",
            "",
            "        The result is normally formatted as \"algorithm$salt$hash\" and",
            "        must be fewer than 128 characters.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def safe_summary(self, encoded):",
            "        \"\"\"",
            "        Returns a summary of safe values",
            "",
            "        The result is a dictionary and will be used where the password field",
            "        must be displayed to construct a safe representation of the password.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class PBKDF2PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the PBKDF2 algorithm (recommended)",
            "",
            "    Configured to use PBKDF2 + HMAC + SHA256 with 10000 iterations.",
            "    The result is a 64 byte binary string.  Iterations may be changed",
            "    safely but you must rename the algorithm if you change SHA256.",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha256\"",
            "    iterations = 10000",
            "    digest = hashlib.sha256",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt, iterations=None):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        if not iterations:",
            "            iterations = self.iterations",
            "        hash = pbkdf2(password, salt, iterations, digest=self.digest)",
            "        hash = hash.encode('base64').strip()",
            "        return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt, int(iterations))",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('iterations'), iterations),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
            "    \"\"\"",
            "    Alternate PBKDF2 hasher which uses SHA1, the default PRF",
            "    recommended by PKCS #5. This is compatible with other",
            "    implementations of PBKDF2, such as openssl's",
            "    PKCS5_PBKDF2_HMAC_SHA1().",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha1\"",
            "    digest = hashlib.sha1",
            "",
            "",
            "class BCryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm (recommended)",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the py-bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "    \"\"\"",
            "    algorithm = \"bcrypt\"",
            "    library = (\"py-bcrypt\", \"bcrypt\")",
            "    rounds = 12",
            "",
            "    def salt(self):",
            "        bcrypt = self._load_library()",
            "        return bcrypt.gensalt(self.rounds)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        bcrypt = self._load_library()",
            "        data = bcrypt.hashpw(password, salt)",
            "        return \"%s$%s\" % (self.algorithm, data)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, data = encoded.split('$', 1)",
            "        assert algorithm == self.algorithm",
            "        bcrypt = self._load_library()",
            "        return constant_time_compare(data, bcrypt.hashpw(password, data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
            "        assert algorithm == self.algorithm",
            "        salt, checksum = data[:22], data[22:]",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('work factor'), work_factor),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('checksum'), mask_hash(checksum)),",
            "        ])",
            "",
            "",
            "class SHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The SHA1 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"sha1\"",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.sha1(salt + password).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class MD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The Salted MD5 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"md5\"",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.md5(salt + password).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Very insecure algorithm that you should *never* use; stores SHA1 hashes",
            "    with an empty salt.",
            "",
            "    This class is implemented because Django used to accept such password",
            "    hashes. Some older Django installs still have these values lingering",
            "    around so we need to handle and upgrade them properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_sha1\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        hash = hashlib.sha1(password).hexdigest()",
            "        return 'sha1$$%s' % hash",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        assert encoded.startswith('sha1$$')",
            "        hash = encoded[6:]",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Incredibly insecure algorithm that you should *never* use; stores unsalted",
            "    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an",
            "    empty salt.",
            "",
            "    This class is implemented because Django used to store passwords this way",
            "    and to accept such password hashes. Some older Django installs still have",
            "    these values lingering around so we need to handle and upgrade them",
            "    properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_md5\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        return hashlib.md5(password).hexdigest()",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        if len(encoded) == 37 and encoded.startswith('md5$$'):",
            "            encoded = encoded[5:]",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(encoded, show=3)),",
            "        ])",
            "",
            "",
            "class CryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Password hashing using UNIX crypt (not recommended)",
            "",
            "    The crypt module is not supported on all platforms.",
            "    \"\"\"",
            "    algorithm = \"crypt\"",
            "    library = \"crypt\"",
            "",
            "    def salt(self):",
            "        return get_random_string(2)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        crypt = self._load_library()",
            "        assert len(salt) == 2",
            "        data = crypt.crypt(password, salt)",
            "        # we don't need to store the salt, but Django used to do this",
            "        return \"%s$%s$%s\" % (self.algorithm, '', data)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        crypt = self._load_library()",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return constant_time_compare(data, crypt.crypt(password, data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), salt),",
            "            (_('hash'), mask_hash(data, show=3)),",
            "        ])"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2"
        ],
        "dele_reviseLocation": {
            "436": []
        },
        "addLocation": [
            "django.contrib.auth.hashers.BCryptPasswordHasher",
            "django.contrib.auth.hashers.SHA1PasswordHasher",
            "django.contrib.auth.hashers.CryptPasswordHasher.self",
            "airflow.www.views.Airflow",
            "django.contrib.auth.hashers.SHA1PasswordHasher.self",
            "django.contrib.auth.hashers.CryptPasswordHasher",
            "django.contrib.auth.hashers.UnsaltedMD5PasswordHasher",
            "django.contrib.auth.hashers.UnsaltedSHA1PasswordHasher.self",
            "django.contrib.auth.hashers.MD5PasswordHasher.self",
            "django.contrib.auth.hashers.PBKDF2PasswordHasher.self",
            "django.contrib.auth.hashers.UnsaltedMD5PasswordHasher.self",
            "django.contrib.auth.hashers.MD5PasswordHasher",
            "django.contrib.auth.hashers.UnsaltedSHA1PasswordHasher",
            "django.contrib.auth.hashers.BCryptPasswordHasher.self",
            "django.contrib.auth.hashers.PBKDF2PasswordHasher",
            "django.contrib.auth.hashers.BasePasswordHasher.self"
        ]
    },
    "django/contrib/auth/tests/hashers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from django.conf.global_settings import PASSWORD_HASHERS as default_hashers"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from django.contrib.auth.hashers import (is_password_usable,"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": "     check_password, make_password, PBKDF2PasswordHasher, load_hashers,"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    PBKDF2SHA1PasswordHasher, get_hasher, UNUSABLE_PASSWORD)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+    PBKDF2SHA1PasswordHasher, get_hasher, UNUSABLE_PASSWORD,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+    MAXIMUM_PASSWORD_LENGTH, password_max_length)"
            },
            "6": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.utils import unittest"
            },
            "7": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from django.utils.unittest import skipUnless"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.test.utils import override_settings"
            },
            "9": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         self.assertTrue(is_password_usable(encoded))"
            },
            "10": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         self.assertTrue(check_password(u'letmein', encoded))"
            },
            "11": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         self.assertFalse(check_password('letmeinz', encoded))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        # Long password"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        self.assertRaises("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+            ValueError,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+            make_password,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        )"
            },
            "18": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     def test_pkbdf2(self):"
            },
            "20": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         encoded = make_password('letmein', 'seasalt', 'pbkdf2_sha256')"
            },
            "21": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         self.assertTrue(is_password_usable(encoded))"
            },
            "22": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         self.assertTrue(check_password(u'letmein', encoded))"
            },
            "23": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         self.assertFalse(check_password('letmeinz', encoded))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        # Long password"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        self.assertRaises("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            ValueError,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            make_password,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            \"seasalt\","
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            \"pbkdf2_sha256\","
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        )"
            },
            "32": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     def test_sha1(self):"
            },
            "34": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         encoded = make_password('letmein', 'seasalt', 'sha1')"
            },
            "35": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         self.assertTrue(is_password_usable(encoded))"
            },
            "36": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         self.assertTrue(check_password(u'letmein', encoded))"
            },
            "37": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         self.assertFalse(check_password('letmeinz', encoded))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        # Long password"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        self.assertRaises("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            ValueError,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            make_password,"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            \"seasalt\","
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            \"sha1\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        )"
            },
            "46": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     def test_md5(self):"
            },
            "48": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         encoded = make_password('letmein', 'seasalt', 'md5')"
            },
            "49": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         self.assertTrue(is_password_usable(encoded))"
            },
            "50": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         self.assertTrue(check_password(u'letmein', encoded))"
            },
            "51": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         self.assertFalse(check_password('letmeinz', encoded))"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        # Long password"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        self.assertRaises("
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+            ValueError,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+            make_password,"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+            \"seasalt\","
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            \"md5\","
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        )"
            },
            "60": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     def test_unsalted_md5(self):"
            },
            "62": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         encoded = make_password('letmein', '', 'unsalted_md5')"
            },
            "63": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         self.assertTrue(is_password_usable(alt_encoded))"
            },
            "64": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         self.assertTrue(check_password(u'letmein', alt_encoded))"
            },
            "65": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         self.assertFalse(check_password('letmeinz', alt_encoded))"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        # Long password"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        self.assertRaises("
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            ValueError,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            make_password,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            \"\","
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            \"unsalted_md5\","
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        )"
            },
            "74": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "     def test_unsalted_sha1(self):"
            },
            "76": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         encoded = make_password('letmein', '', 'unsalted_sha1')"
            },
            "77": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         # Raw SHA1 isn't acceptable"
            },
            "78": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         alt_encoded = encoded[6:]"
            },
            "79": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         self.assertRaises(ValueError, check_password, 'letmein', alt_encoded)"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        # Long password"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        self.assertRaises("
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            ValueError,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            make_password,"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            \"\","
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+            \"unslated_sha1\","
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        )"
            },
            "88": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     @skipUnless(crypt, \"no crypt module to generate password.\")"
            },
            "90": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     def test_crypt(self):"
            },
            "91": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         self.assertTrue(is_password_usable(encoded))"
            },
            "92": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         self.assertTrue(check_password(u'letmein', encoded))"
            },
            "93": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         self.assertFalse(check_password('letmeinz', encoded))"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        # Long password"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        self.assertRaises("
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            ValueError,"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+            make_password,"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            \"seasalt\","
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            \"crypt\","
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        )"
            },
            "102": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     @skipUnless(bcrypt, \"py-bcrypt not installed\")"
            },
            "104": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     def test_bcrypt(self):"
            },
            "105": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         self.assertTrue(encoded.startswith('bcrypt$'))"
            },
            "106": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         self.assertTrue(check_password(u'letmein', encoded))"
            },
            "107": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         self.assertFalse(check_password('letmeinz', encoded))"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        # Long password"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        self.assertRaises("
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            ValueError,"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            make_password,"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            hasher=\"bcrypt\","
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        )"
            },
            "115": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 155,
                "PatchRowcode": " "
            },
            "116": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     def test_unusable(self):"
            },
            "117": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         encoded = make_password(None)"
            },
            "118": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "             make_password('letmein', hasher='lolcat')"
            },
            "119": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         self.assertRaises(ValueError, doit)"
            },
            "120": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+    def test_max_password_length_decorator(self):"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        @password_max_length(10)"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        def encode(s, password, salt):"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+            return True"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        self.assertTrue(encode(None, b\"1234\", b\"1234\"))"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        self.assertRaises(ValueError, encode, None, b\"1234567890A\", b\"1234\")"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "129": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     def test_low_level_pkbdf2(self):"
            },
            "130": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         hasher = PBKDF2PasswordHasher()"
            },
            "131": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         encoded = hasher.encode('letmein', 'seasalt')"
            }
        },
        "frontPatchFile": [
            "from django.conf.global_settings import PASSWORD_HASHERS as default_hashers",
            "from django.contrib.auth.hashers import (is_password_usable,",
            "    check_password, make_password, PBKDF2PasswordHasher, load_hashers,",
            "    PBKDF2SHA1PasswordHasher, get_hasher, UNUSABLE_PASSWORD)",
            "from django.utils import unittest",
            "from django.utils.unittest import skipUnless",
            "from django.test.utils import override_settings",
            "",
            "",
            "try:",
            "    import crypt",
            "except ImportError:",
            "    crypt = None",
            "",
            "try:",
            "    import bcrypt",
            "except ImportError:",
            "    bcrypt = None",
            "",
            "",
            "class TestUtilsHashPass(unittest.TestCase):",
            "    def setUp(self):",
            "        load_hashers(password_hashers=default_hashers)",
            "",
            "    def test_simple(self):",
            "        encoded = make_password('letmein')",
            "        self.assertTrue(encoded.startswith('pbkdf2_sha256$'))",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    def test_pkbdf2(self):",
            "        encoded = make_password('letmein', 'seasalt', 'pbkdf2_sha256')",
            "        self.assertEqual(encoded,",
            "'pbkdf2_sha256$10000$seasalt$FQCNpiZpTb0zub+HBsH6TOwyRxJ19FwvjbweatNmK/Y=')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    def test_sha1(self):",
            "        encoded = make_password('letmein', 'seasalt', 'sha1')",
            "        self.assertEqual(encoded,",
            "'sha1$seasalt$fec3530984afba6bade3347b7140d1a7da7da8c7')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    def test_md5(self):",
            "        encoded = make_password('letmein', 'seasalt', 'md5')",
            "        self.assertEqual(encoded,",
            "                         'md5$seasalt$f5531bef9f3687d0ccf0f617f0e25573')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    def test_unsalted_md5(self):",
            "        encoded = make_password('letmein', '', 'unsalted_md5')",
            "        self.assertEqual(encoded, '0d107d09f5bbe40cade3de5c71e9e9b7')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Alternate unsalted syntax",
            "        alt_encoded = \"md5$$%s\" % encoded",
            "        self.assertTrue(is_password_usable(alt_encoded))",
            "        self.assertTrue(check_password(u'letmein', alt_encoded))",
            "        self.assertFalse(check_password('letmeinz', alt_encoded))",
            "",
            "    def test_unsalted_sha1(self):",
            "        encoded = make_password('letmein', '', 'unsalted_sha1')",
            "        self.assertEqual(encoded, 'sha1$$b7a875fc1ea228b9061041b7cec4bd3c52ab3ce3')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Raw SHA1 isn't acceptable",
            "        alt_encoded = encoded[6:]",
            "        self.assertRaises(ValueError, check_password, 'letmein', alt_encoded)",
            "",
            "    @skipUnless(crypt, \"no crypt module to generate password.\")",
            "    def test_crypt(self):",
            "        encoded = make_password('letmein', 'ab', 'crypt')",
            "        self.assertEqual(encoded, 'crypt$$abN/qM.L/H8EQ')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    @skipUnless(bcrypt, \"py-bcrypt not installed\")",
            "    def test_bcrypt(self):",
            "        encoded = make_password('letmein', hasher='bcrypt')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(encoded.startswith('bcrypt$'))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    def test_unusable(self):",
            "        encoded = make_password(None)",
            "        self.assertFalse(is_password_usable(encoded))",
            "        self.assertFalse(check_password(None, encoded))",
            "        self.assertFalse(check_password(UNUSABLE_PASSWORD, encoded))",
            "        self.assertFalse(check_password('', encoded))",
            "        self.assertFalse(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    def test_bad_algorithm(self):",
            "        def doit():",
            "            make_password('letmein', hasher='lolcat')",
            "        self.assertRaises(ValueError, doit)",
            "",
            "    def test_low_level_pkbdf2(self):",
            "        hasher = PBKDF2PasswordHasher()",
            "        encoded = hasher.encode('letmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "'pbkdf2_sha256$10000$seasalt$FQCNpiZpTb0zub+HBsH6TOwyRxJ19FwvjbweatNmK/Y=')",
            "        self.assertTrue(hasher.verify('letmein', encoded))",
            "",
            "    def test_low_level_pbkdf2_sha1(self):",
            "        hasher = PBKDF2SHA1PasswordHasher()",
            "        encoded = hasher.encode('letmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "'pbkdf2_sha1$10000$seasalt$91JiNKgwADC8j2j86Ije/cc4vfQ=')",
            "        self.assertTrue(hasher.verify('letmein', encoded))",
            "",
            "    def test_upgrade(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('letmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter(password):",
            "                state['upgraded'] = True",
            "            self.assertTrue(check_password('letmein', encoded, setter))",
            "            self.assertTrue(state['upgraded'])",
            "",
            "    def test_no_upgrade(self):",
            "        encoded = make_password('letmein')",
            "        state = {'upgraded': False}",
            "        def setter():",
            "            state['upgraded'] = True",
            "        self.assertFalse(check_password('WRONG', encoded, setter))",
            "        self.assertFalse(state['upgraded'])",
            "",
            "    def test_no_upgrade_on_incorrect_pass(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('letmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter():",
            "                state['upgraded'] = True",
            "            self.assertFalse(check_password('WRONG', encoded, setter))",
            "            self.assertFalse(state['upgraded'])"
        ],
        "afterPatchFile": [
            "from django.conf.global_settings import PASSWORD_HASHERS as default_hashers",
            "from django.contrib.auth.hashers import (is_password_usable,",
            "    check_password, make_password, PBKDF2PasswordHasher, load_hashers,",
            "    PBKDF2SHA1PasswordHasher, get_hasher, UNUSABLE_PASSWORD,",
            "    MAXIMUM_PASSWORD_LENGTH, password_max_length)",
            "from django.utils import unittest",
            "from django.utils.unittest import skipUnless",
            "from django.test.utils import override_settings",
            "",
            "",
            "try:",
            "    import crypt",
            "except ImportError:",
            "    crypt = None",
            "",
            "try:",
            "    import bcrypt",
            "except ImportError:",
            "    bcrypt = None",
            "",
            "",
            "class TestUtilsHashPass(unittest.TestCase):",
            "    def setUp(self):",
            "        load_hashers(password_hashers=default_hashers)",
            "",
            "    def test_simple(self):",
            "        encoded = make_password('letmein')",
            "        self.assertTrue(encoded.startswith('pbkdf2_sha256$'))",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "        )",
            "",
            "    def test_pkbdf2(self):",
            "        encoded = make_password('letmein', 'seasalt', 'pbkdf2_sha256')",
            "        self.assertEqual(encoded,",
            "'pbkdf2_sha256$10000$seasalt$FQCNpiZpTb0zub+HBsH6TOwyRxJ19FwvjbweatNmK/Y=')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"pbkdf2_sha256\",",
            "        )",
            "",
            "    def test_sha1(self):",
            "        encoded = make_password('letmein', 'seasalt', 'sha1')",
            "        self.assertEqual(encoded,",
            "'sha1$seasalt$fec3530984afba6bade3347b7140d1a7da7da8c7')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"sha1\",",
            "        )",
            "",
            "    def test_md5(self):",
            "        encoded = make_password('letmein', 'seasalt', 'md5')",
            "        self.assertEqual(encoded,",
            "                         'md5$seasalt$f5531bef9f3687d0ccf0f617f0e25573')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"md5\",",
            "        )",
            "",
            "    def test_unsalted_md5(self):",
            "        encoded = make_password('letmein', '', 'unsalted_md5')",
            "        self.assertEqual(encoded, '0d107d09f5bbe40cade3de5c71e9e9b7')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Alternate unsalted syntax",
            "        alt_encoded = \"md5$$%s\" % encoded",
            "        self.assertTrue(is_password_usable(alt_encoded))",
            "        self.assertTrue(check_password(u'letmein', alt_encoded))",
            "        self.assertFalse(check_password('letmeinz', alt_encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"\",",
            "            \"unsalted_md5\",",
            "        )",
            "",
            "    def test_unsalted_sha1(self):",
            "        encoded = make_password('letmein', '', 'unsalted_sha1')",
            "        self.assertEqual(encoded, 'sha1$$b7a875fc1ea228b9061041b7cec4bd3c52ab3ce3')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Raw SHA1 isn't acceptable",
            "        alt_encoded = encoded[6:]",
            "        self.assertRaises(ValueError, check_password, 'letmein', alt_encoded)",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"\",",
            "            \"unslated_sha1\",",
            "        )",
            "",
            "    @skipUnless(crypt, \"no crypt module to generate password.\")",
            "    def test_crypt(self):",
            "        encoded = make_password('letmein', 'ab', 'crypt')",
            "        self.assertEqual(encoded, 'crypt$$abN/qM.L/H8EQ')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"crypt\",",
            "        )",
            "",
            "    @skipUnless(bcrypt, \"py-bcrypt not installed\")",
            "    def test_bcrypt(self):",
            "        encoded = make_password('letmein', hasher='bcrypt')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(encoded.startswith('bcrypt$'))",
            "        self.assertTrue(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            hasher=\"bcrypt\",",
            "        )",
            "",
            "    def test_unusable(self):",
            "        encoded = make_password(None)",
            "        self.assertFalse(is_password_usable(encoded))",
            "        self.assertFalse(check_password(None, encoded))",
            "        self.assertFalse(check_password(UNUSABLE_PASSWORD, encoded))",
            "        self.assertFalse(check_password('', encoded))",
            "        self.assertFalse(check_password(u'letmein', encoded))",
            "        self.assertFalse(check_password('letmeinz', encoded))",
            "",
            "    def test_bad_algorithm(self):",
            "        def doit():",
            "            make_password('letmein', hasher='lolcat')",
            "        self.assertRaises(ValueError, doit)",
            "",
            "    def test_max_password_length_decorator(self):",
            "        @password_max_length(10)",
            "        def encode(s, password, salt):",
            "            return True",
            "",
            "        self.assertTrue(encode(None, b\"1234\", b\"1234\"))",
            "        self.assertRaises(ValueError, encode, None, b\"1234567890A\", b\"1234\")",
            "",
            "    def test_low_level_pkbdf2(self):",
            "        hasher = PBKDF2PasswordHasher()",
            "        encoded = hasher.encode('letmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "'pbkdf2_sha256$10000$seasalt$FQCNpiZpTb0zub+HBsH6TOwyRxJ19FwvjbweatNmK/Y=')",
            "        self.assertTrue(hasher.verify('letmein', encoded))",
            "",
            "    def test_low_level_pbkdf2_sha1(self):",
            "        hasher = PBKDF2SHA1PasswordHasher()",
            "        encoded = hasher.encode('letmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "'pbkdf2_sha1$10000$seasalt$91JiNKgwADC8j2j86Ije/cc4vfQ=')",
            "        self.assertTrue(hasher.verify('letmein', encoded))",
            "",
            "    def test_upgrade(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('letmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter(password):",
            "                state['upgraded'] = True",
            "            self.assertTrue(check_password('letmein', encoded, setter))",
            "            self.assertTrue(state['upgraded'])",
            "",
            "    def test_no_upgrade(self):",
            "        encoded = make_password('letmein')",
            "        state = {'upgraded': False}",
            "        def setter():",
            "            state['upgraded'] = True",
            "        self.assertFalse(check_password('WRONG', encoded, setter))",
            "        self.assertFalse(state['upgraded'])",
            "",
            "    def test_no_upgrade_on_incorrect_pass(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('letmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter():",
            "                state['upgraded'] = True",
            "            self.assertFalse(check_password('WRONG', encoded, setter))",
            "            self.assertFalse(state['upgraded'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": []
        },
        "addLocation": []
    }
}