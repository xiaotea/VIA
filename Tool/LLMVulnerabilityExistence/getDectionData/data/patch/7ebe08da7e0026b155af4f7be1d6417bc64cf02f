{
    "lollms/server/endpoints/lollms_binding_infos.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from lollms.binding import BindingBuilder, InstallOption"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from ascii_colors import ASCIIColors"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from lollms.utilities import load_config, trace_exception, gc"
            },
            "3": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lollms.security import sanitize_path_from_endpoint"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from lollms.security import sanitize_path_from_endpoint, sanitize_path"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from pathlib import Path"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from typing import List, Any"
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import json"
            },
            "8": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     try:"
            },
            "10": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         print(f\"Reloading binding selected : {request.name}\")"
            },
            "11": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        safe_name = os.path.basename(request.name) # sanitize the file path to prevent path traversal"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        safe_name = sanitize_path(os.path.basename(request.name)) # sanitize the file path to prevent path traversal"
            },
            "13": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         lollmsElfServer.config[\"binding_name\"]=safe_name"
            },
            "14": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         if lollmsElfServer.binding:"
            },
            "15": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "             lollmsElfServer.binding.destroy_model()"
            },
            "16": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         lollmsElfServer.info(\"Unmounting binding and model\")"
            },
            "17": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         lollmsElfServer.info(\"Reinstalling binding\")"
            },
            "18": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         old_bn = lollmsElfServer.config.binding_name"
            },
            "19": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        lollmsElfServer.config.binding_name = data.name"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        lollmsElfServer.config.binding_name = sanitize_path(data.name)"
            },
            "21": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.FORCE_INSTALL, lollmsCom=lollmsElfServer)"
            },
            "22": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         lollmsElfServer.success(\"Binding installed successfully\")"
            },
            "23": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         del lollmsElfServer.binding"
            },
            "24": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         gc.collect()"
            },
            "25": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         ASCIIColors.info(\"Reinstalling binding\")"
            },
            "26": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         old_bn = lollmsElfServer.config.binding_name"
            },
            "27": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        lollmsElfServer.config.binding_name = data.name"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        lollmsElfServer.config.binding_name = sanitize_path(data.name)"
            },
            "29": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.FORCE_INSTALL, lollmsCom=lollmsElfServer)"
            },
            "30": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         lollmsElfServer.success(\"Binding reinstalled successfully\")"
            },
            "31": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         lollmsElfServer.config.binding_name = old_bn"
            },
            "32": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "             gc.collect()"
            },
            "33": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         ASCIIColors.info(\"Uninstalling binding\")"
            },
            "34": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         old_bn = lollmsElfServer.config.binding_name"
            },
            "35": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        lollmsElfServer.config.binding_name = data.name"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        lollmsElfServer.config.binding_name = sanitize_path(data.name)"
            },
            "37": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.NEVER_INSTALL, lollmsCom=lollmsElfServer)"
            },
            "38": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         lollmsElfServer.binding.uninstall()"
            },
            "39": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         ASCIIColors.green(\"Uninstalled successful\")"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "project: lollms",
            "file: lollms_binding_infos.py ",
            "author: ParisNeo",
            "description: ",
            "    This module contains a set of FastAPI routes that provide information about the Lord of Large Language and Multimodal Systems (LoLLMs) Web UI",
            "    application. These routes are specific to bindings",
            "",
            "\"\"\"",
            "from fastapi import APIRouter, Request, HTTPException",
            "from pydantic import BaseModel, Field",
            "import pkg_resources",
            "from lollms.server.elf_server import LOLLMSElfServer",
            "from lollms.binding import BindingBuilder, InstallOption",
            "from ascii_colors import ASCIIColors",
            "from lollms.utilities import load_config, trace_exception, gc",
            "from lollms.security import sanitize_path_from_endpoint",
            "from pathlib import Path",
            "from typing import List, Any",
            "import json",
            "import os",
            "# ----------------------------------- Personal files -----------------------------------------",
            "class ReloadBindingParams(BaseModel):",
            "    binding_name: str = Field(..., min_length=1, max_length=50)",
            "",
            "class BindingInstallParams(BaseModel):",
            "    name: str = Field(..., min_length=1, max_length=50)",
            "",
            "",
            "# ----------------------- Defining router and main class ------------------------------",
            "router = APIRouter()",
            "lollmsElfServer = LOLLMSElfServer.get_instance()",
            "",
            "",
            "# ----------------------------------- Listing -----------------------------------------",
            "@router.get(\"/list_bindings\")",
            "def list_bindings():",
            "    \"\"\"",
            "    List all available bindings in the Lollms server.",
            "",
            "    Returns:",
            "        List[str]: A list of binding names.",
            "    \"\"\"    ",
            "    bindings_dir = lollmsElfServer.lollms_paths.bindings_zoo_path  # replace with the actual path to the models folder",
            "    bindings=[]",
            "    for f in bindings_dir.iterdir():",
            "        if f.stem!=\"binding_template\":",
            "            card = f/\"binding_card.yaml\"",
            "            if card.exists():",
            "                try:",
            "                    bnd = load_config(card)",
            "                    bnd[\"folder\"]=f.stem",
            "                    installed = (lollmsElfServer.lollms_paths.personal_configuration_path/\"bindings\"/f.stem/f\"config.yaml\").exists()",
            "                    bnd[\"installed\"]=installed",
            "                    ui_file_path = f/\"ui.html\"",
            "                    if ui_file_path.exists():",
            "                        with ui_file_path.open(\"r\") as file:",
            "                            text_content = file.read()",
            "                            bnd[\"ui\"]=text_content",
            "                    else:",
            "                        bnd[\"ui\"]=None",
            "                    disclaimer_file_path = f/\"disclaimer.md\"",
            "                    if disclaimer_file_path.exists():",
            "                        with disclaimer_file_path.open(\"r\") as file:",
            "                            text_content = file.read()",
            "                            bnd[\"disclaimer\"]=text_content",
            "                    else:",
            "                        bnd[\"disclaimer\"]=None",
            "                    icon_file = lollmsElfServer.find_extension(lollmsElfServer.lollms_paths.bindings_zoo_path/f\"{f.name}\", \"logo\", [\".svg\",\".gif\",\".png\"])",
            "                    if icon_file is not None:",
            "                        icon_path = Path(f\"bindings/{f.name}/logo{icon_file.suffix}\")",
            "                        bnd[\"icon\"]=str(icon_path)",
            "",
            "                    bindings.append(bnd)",
            "                except Exception as ex:",
            "                    print(f\"Couldn't load backend card : {f}\\n\\t{ex}\")",
            "    return bindings",
            "",
            "# ----------------------------------- Reloading ----------------------------------------",
            "class BindingReloadRequest(BaseModel):",
            "    name: str = Field(..., min_length=1, max_length=50)",
            "",
            "@router.post(\"/reload_binding\")",
            "async def reload_binding(request: BindingReloadRequest):",
            "    \"\"\"",
            "    Reloads a binding.",
            "",
            "    :param request: The BindingReloadRequest object.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "",
            "    try:",
            "        print(f\"Reloading binding selected : {request.name}\")",
            "        safe_name = os.path.basename(request.name) # sanitize the file path to prevent path traversal",
            "        lollmsElfServer.config[\"binding_name\"]=safe_name",
            "        if lollmsElfServer.binding:",
            "            lollmsElfServer.binding.destroy_model()",
            "        lollmsElfServer.binding = None",
            "        lollmsElfServer.model = None",
            "        for per in lollmsElfServer.mounted_personalities:",
            "            if per is not None:",
            "                per.model = None",
            "        gc.collect()",
            "        lollmsElfServer.binding = BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.INSTALL_IF_NECESSARY, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.model = None",
            "        lollmsElfServer.config.save_config()",
            "        ASCIIColors.green(\"Binding loaded successfully\")",
            "        return {\"status\":True}",
            "    except Exception as ex:",
            "        ASCIIColors.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}",
            "    ",
            "",
            "# ----------------------------------- Installation/Uninstallation/Reinstallation ----------------------------------------",
            "",
            "@router.post(\"/install_binding\")",
            "def install_binding(data:BindingInstallParams):",
            "    \"\"\"Install a new binding on the server.",
            "    ",
            "    Args:",
            "        data (BindingInstallParams): Parameters required for installation.",
            "        format:",
            "            name: str : the name of the binding",
            "    ",
            "    Returns:",
            "        dict: Status of operation.",
            "    \"\"\"",
            "    sanitize_path_from_endpoint(data.name)    ",
            "    ",
            "    ASCIIColors.info(f\"- Reinstalling binding {data.name}...\")",
            "    try:",
            "        lollmsElfServer.info(\"Unmounting binding and model\")",
            "        lollmsElfServer.info(\"Reinstalling binding\")",
            "        old_bn = lollmsElfServer.config.binding_name",
            "        lollmsElfServer.config.binding_name = data.name",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.FORCE_INSTALL, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.success(\"Binding installed successfully\")",
            "        del lollmsElfServer.binding",
            "        lollmsElfServer.binding = None",
            "        lollmsElfServer.config.binding_name = old_bn",
            "        if old_bn is not None:",
            "            lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, lollmsCom=lollmsElfServer)",
            "            lollmsElfServer.model = lollmsElfServer.binding.build_model()",
            "            for per in lollmsElfServer.mounted_personalities:",
            "                if per is not None:",
            "                    per.model = lollmsElfServer.model",
            "        return {\"status\": True}",
            "    except Exception as ex:",
            "        lollmsElfServer.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}",
            "",
            "@router.post(\"/reinstall_binding\")",
            "def reinstall_binding(data:BindingInstallParams):",
            "    \"\"\"Reinstall an already installed binding on the server.",
            "    ",
            "    Args:",
            "        data (BindingInstallParams): Parameters required for reinstallation.",
            "        format:",
            "            name: str : the name of the binding",
            "    ",
            "    Returns:",
            "        dict: Status of operation.",
            "    \"\"\"    ",
            "    ASCIIColors.info(f\"- Reinstalling binding {data.name}...\")",
            "    try:",
            "        ASCIIColors.info(\"Unmounting binding and model\")",
            "        del lollmsElfServer.binding",
            "        lollmsElfServer.binding = None",
            "        gc.collect()",
            "        ASCIIColors.info(\"Reinstalling binding\")",
            "        old_bn = lollmsElfServer.config.binding_name",
            "        lollmsElfServer.config.binding_name = data.name",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.FORCE_INSTALL, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.success(\"Binding reinstalled successfully\")",
            "        lollmsElfServer.config.binding_name = old_bn",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.model = lollmsElfServer.binding.build_model()",
            "        for per in lollmsElfServer.mounted_personalities:",
            "            if per is not None:",
            "                per.model = lollmsElfServer.model",
            "        ",
            "        return {\"status\": True}",
            "    except Exception as ex:",
            "        ASCIIColors.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}",
            "",
            "@router.post(\"/unInstall_binding\")",
            "def unInstall_binding(data:BindingInstallParams):",
            "    \"\"\"Uninstall an installed binding from the server.",
            "    ",
            "    Args:",
            "        data (BindingInstallParams): Parameters required for uninstallation.",
            "        format:",
            "            name: str : the name of the binding",
            "    Returns:",
            "        dict: Status of operation.",
            "    \"\"\"    ",
            "    ASCIIColors.info(f\"- Reinstalling binding {data.name}...\")",
            "    try:",
            "        ASCIIColors.info(\"Unmounting binding and model\")",
            "        if lollmsElfServer.binding is not None:",
            "            del lollmsElfServer.binding",
            "            lollmsElfServer.binding = None",
            "            gc.collect()",
            "        ASCIIColors.info(\"Uninstalling binding\")",
            "        old_bn = lollmsElfServer.config.binding_name",
            "        lollmsElfServer.config.binding_name = data.name",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.NEVER_INSTALL, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.binding.uninstall()",
            "        ASCIIColors.green(\"Uninstalled successful\")",
            "        if old_bn!=lollmsElfServer.config.binding_name:",
            "            lollmsElfServer.config.binding_name = old_bn",
            "            lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, lollmsCom=lollmsElfServer)",
            "            lollmsElfServer.model = lollmsElfServer.binding.build_model()",
            "            for per in lollmsElfServer.mounted_personalities:",
            "                if per is not None:",
            "                    per.model = lollmsElfServer.model",
            "        else:",
            "            lollmsElfServer.config.binding_name = None",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "            ",
            "        return {\"status\": True}",
            "    except Exception as ex:",
            "        ASCIIColors.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}     ",
            "    ",
            "# ----------------------------------- Bet binding settings ----------------------------------------",
            "",
            "@router.get(\"/get_active_binding_settings\")",
            "def get_active_binding_settings():",
            "    print(\"- Retreiving binding settings\")",
            "    if lollmsElfServer.binding is not None:",
            "        if hasattr(lollmsElfServer.binding,\"binding_config\"):",
            "            return lollmsElfServer.binding.binding_config.config_template.template",
            "        else:",
            "            return {}",
            "    else:",
            "        return {}",
            "",
            "# class BindingSettingsRequest(BaseModel):",
            "#     value: list ",
            "",
            "# @router.post(\"/set_active_binding_settings\")",
            "# async def set_active_binding_settings(request: BindingSettingsRequest):",
            "@router.post(\"/set_active_binding_settings\")",
            "async def set_active_binding_settings(request: Request):",
            "    data = await request.json()",
            "    \"\"\"",
            "    Sets the active binding settings.",
            "",
            "    :param request: The BindingSettingsRequest object.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "",
            "    try:",
            "        print(\"- Setting binding settings\")",
            "        ",
            "        if lollmsElfServer.binding is not None:",
            "            if hasattr(lollmsElfServer.binding,\"binding_config\"):",
            "                lollmsElfServer.binding.binding_config.update_template(data)",
            "                lollmsElfServer.binding.binding_config.config.save_config()",
            "                lollmsElfServer.binding.settings_updated()",
            "                if lollmsElfServer.config.auto_save:",
            "                    ASCIIColors.info(\"Saving configuration\")",
            "                    lollmsElfServer.config.save_config()",
            "                return {'status':True}",
            "            else:",
            "                return {'status':False}",
            "        else:",
            "            return {'status':False}",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        lollmsElfServer.error(ex)",
            "        return {\"status\":False,\"error\":str(ex)}",
            "    ",
            "@router.get(\"/update_binding_settings\")",
            "def update_binding_settings():",
            "    if lollmsElfServer.binding:",
            "        lollmsElfServer.binding.settings_updated()",
            "        ASCIIColors.green(\"Binding setting updated successfully\")",
            "        return {\"status\":True}",
            "    else:",
            "        return {\"status\":False, 'error':\"no binding found\"}"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "project: lollms",
            "file: lollms_binding_infos.py ",
            "author: ParisNeo",
            "description: ",
            "    This module contains a set of FastAPI routes that provide information about the Lord of Large Language and Multimodal Systems (LoLLMs) Web UI",
            "    application. These routes are specific to bindings",
            "",
            "\"\"\"",
            "from fastapi import APIRouter, Request, HTTPException",
            "from pydantic import BaseModel, Field",
            "import pkg_resources",
            "from lollms.server.elf_server import LOLLMSElfServer",
            "from lollms.binding import BindingBuilder, InstallOption",
            "from ascii_colors import ASCIIColors",
            "from lollms.utilities import load_config, trace_exception, gc",
            "from lollms.security import sanitize_path_from_endpoint, sanitize_path",
            "from pathlib import Path",
            "from typing import List, Any",
            "import json",
            "import os",
            "# ----------------------------------- Personal files -----------------------------------------",
            "class ReloadBindingParams(BaseModel):",
            "    binding_name: str = Field(..., min_length=1, max_length=50)",
            "",
            "class BindingInstallParams(BaseModel):",
            "    name: str = Field(..., min_length=1, max_length=50)",
            "",
            "",
            "# ----------------------- Defining router and main class ------------------------------",
            "router = APIRouter()",
            "lollmsElfServer = LOLLMSElfServer.get_instance()",
            "",
            "",
            "# ----------------------------------- Listing -----------------------------------------",
            "@router.get(\"/list_bindings\")",
            "def list_bindings():",
            "    \"\"\"",
            "    List all available bindings in the Lollms server.",
            "",
            "    Returns:",
            "        List[str]: A list of binding names.",
            "    \"\"\"    ",
            "    bindings_dir = lollmsElfServer.lollms_paths.bindings_zoo_path  # replace with the actual path to the models folder",
            "    bindings=[]",
            "    for f in bindings_dir.iterdir():",
            "        if f.stem!=\"binding_template\":",
            "            card = f/\"binding_card.yaml\"",
            "            if card.exists():",
            "                try:",
            "                    bnd = load_config(card)",
            "                    bnd[\"folder\"]=f.stem",
            "                    installed = (lollmsElfServer.lollms_paths.personal_configuration_path/\"bindings\"/f.stem/f\"config.yaml\").exists()",
            "                    bnd[\"installed\"]=installed",
            "                    ui_file_path = f/\"ui.html\"",
            "                    if ui_file_path.exists():",
            "                        with ui_file_path.open(\"r\") as file:",
            "                            text_content = file.read()",
            "                            bnd[\"ui\"]=text_content",
            "                    else:",
            "                        bnd[\"ui\"]=None",
            "                    disclaimer_file_path = f/\"disclaimer.md\"",
            "                    if disclaimer_file_path.exists():",
            "                        with disclaimer_file_path.open(\"r\") as file:",
            "                            text_content = file.read()",
            "                            bnd[\"disclaimer\"]=text_content",
            "                    else:",
            "                        bnd[\"disclaimer\"]=None",
            "                    icon_file = lollmsElfServer.find_extension(lollmsElfServer.lollms_paths.bindings_zoo_path/f\"{f.name}\", \"logo\", [\".svg\",\".gif\",\".png\"])",
            "                    if icon_file is not None:",
            "                        icon_path = Path(f\"bindings/{f.name}/logo{icon_file.suffix}\")",
            "                        bnd[\"icon\"]=str(icon_path)",
            "",
            "                    bindings.append(bnd)",
            "                except Exception as ex:",
            "                    print(f\"Couldn't load backend card : {f}\\n\\t{ex}\")",
            "    return bindings",
            "",
            "# ----------------------------------- Reloading ----------------------------------------",
            "class BindingReloadRequest(BaseModel):",
            "    name: str = Field(..., min_length=1, max_length=50)",
            "",
            "@router.post(\"/reload_binding\")",
            "async def reload_binding(request: BindingReloadRequest):",
            "    \"\"\"",
            "    Reloads a binding.",
            "",
            "    :param request: The BindingReloadRequest object.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "",
            "    try:",
            "        print(f\"Reloading binding selected : {request.name}\")",
            "        safe_name = sanitize_path(os.path.basename(request.name)) # sanitize the file path to prevent path traversal",
            "        lollmsElfServer.config[\"binding_name\"]=safe_name",
            "        if lollmsElfServer.binding:",
            "            lollmsElfServer.binding.destroy_model()",
            "        lollmsElfServer.binding = None",
            "        lollmsElfServer.model = None",
            "        for per in lollmsElfServer.mounted_personalities:",
            "            if per is not None:",
            "                per.model = None",
            "        gc.collect()",
            "        lollmsElfServer.binding = BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.INSTALL_IF_NECESSARY, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.model = None",
            "        lollmsElfServer.config.save_config()",
            "        ASCIIColors.green(\"Binding loaded successfully\")",
            "        return {\"status\":True}",
            "    except Exception as ex:",
            "        ASCIIColors.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}",
            "    ",
            "",
            "# ----------------------------------- Installation/Uninstallation/Reinstallation ----------------------------------------",
            "",
            "@router.post(\"/install_binding\")",
            "def install_binding(data:BindingInstallParams):",
            "    \"\"\"Install a new binding on the server.",
            "    ",
            "    Args:",
            "        data (BindingInstallParams): Parameters required for installation.",
            "        format:",
            "            name: str : the name of the binding",
            "    ",
            "    Returns:",
            "        dict: Status of operation.",
            "    \"\"\"",
            "    sanitize_path_from_endpoint(data.name)    ",
            "    ",
            "    ASCIIColors.info(f\"- Reinstalling binding {data.name}...\")",
            "    try:",
            "        lollmsElfServer.info(\"Unmounting binding and model\")",
            "        lollmsElfServer.info(\"Reinstalling binding\")",
            "        old_bn = lollmsElfServer.config.binding_name",
            "        lollmsElfServer.config.binding_name = sanitize_path(data.name)",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.FORCE_INSTALL, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.success(\"Binding installed successfully\")",
            "        del lollmsElfServer.binding",
            "        lollmsElfServer.binding = None",
            "        lollmsElfServer.config.binding_name = old_bn",
            "        if old_bn is not None:",
            "            lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, lollmsCom=lollmsElfServer)",
            "            lollmsElfServer.model = lollmsElfServer.binding.build_model()",
            "            for per in lollmsElfServer.mounted_personalities:",
            "                if per is not None:",
            "                    per.model = lollmsElfServer.model",
            "        return {\"status\": True}",
            "    except Exception as ex:",
            "        lollmsElfServer.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}",
            "",
            "@router.post(\"/reinstall_binding\")",
            "def reinstall_binding(data:BindingInstallParams):",
            "    \"\"\"Reinstall an already installed binding on the server.",
            "    ",
            "    Args:",
            "        data (BindingInstallParams): Parameters required for reinstallation.",
            "        format:",
            "            name: str : the name of the binding",
            "    ",
            "    Returns:",
            "        dict: Status of operation.",
            "    \"\"\"    ",
            "    ASCIIColors.info(f\"- Reinstalling binding {data.name}...\")",
            "    try:",
            "        ASCIIColors.info(\"Unmounting binding and model\")",
            "        del lollmsElfServer.binding",
            "        lollmsElfServer.binding = None",
            "        gc.collect()",
            "        ASCIIColors.info(\"Reinstalling binding\")",
            "        old_bn = lollmsElfServer.config.binding_name",
            "        lollmsElfServer.config.binding_name = sanitize_path(data.name)",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.FORCE_INSTALL, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.success(\"Binding reinstalled successfully\")",
            "        lollmsElfServer.config.binding_name = old_bn",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.model = lollmsElfServer.binding.build_model()",
            "        for per in lollmsElfServer.mounted_personalities:",
            "            if per is not None:",
            "                per.model = lollmsElfServer.model",
            "        ",
            "        return {\"status\": True}",
            "    except Exception as ex:",
            "        ASCIIColors.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}",
            "",
            "@router.post(\"/unInstall_binding\")",
            "def unInstall_binding(data:BindingInstallParams):",
            "    \"\"\"Uninstall an installed binding from the server.",
            "    ",
            "    Args:",
            "        data (BindingInstallParams): Parameters required for uninstallation.",
            "        format:",
            "            name: str : the name of the binding",
            "    Returns:",
            "        dict: Status of operation.",
            "    \"\"\"    ",
            "    ASCIIColors.info(f\"- Reinstalling binding {data.name}...\")",
            "    try:",
            "        ASCIIColors.info(\"Unmounting binding and model\")",
            "        if lollmsElfServer.binding is not None:",
            "            del lollmsElfServer.binding",
            "            lollmsElfServer.binding = None",
            "            gc.collect()",
            "        ASCIIColors.info(\"Uninstalling binding\")",
            "        old_bn = lollmsElfServer.config.binding_name",
            "        lollmsElfServer.config.binding_name = sanitize_path(data.name)",
            "        lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, InstallOption.NEVER_INSTALL, lollmsCom=lollmsElfServer)",
            "        lollmsElfServer.binding.uninstall()",
            "        ASCIIColors.green(\"Uninstalled successful\")",
            "        if old_bn!=lollmsElfServer.config.binding_name:",
            "            lollmsElfServer.config.binding_name = old_bn",
            "            lollmsElfServer.binding =  BindingBuilder().build_binding(lollmsElfServer.config, lollmsElfServer.lollms_paths, lollmsCom=lollmsElfServer)",
            "            lollmsElfServer.model = lollmsElfServer.binding.build_model()",
            "            for per in lollmsElfServer.mounted_personalities:",
            "                if per is not None:",
            "                    per.model = lollmsElfServer.model",
            "        else:",
            "            lollmsElfServer.config.binding_name = None",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "            ",
            "        return {\"status\": True}",
            "    except Exception as ex:",
            "        ASCIIColors.error(f\"Couldn't build binding: [{ex}]\")",
            "        trace_exception(ex)",
            "        return {\"status\":False, 'error':str(ex)}     ",
            "    ",
            "# ----------------------------------- Bet binding settings ----------------------------------------",
            "",
            "@router.get(\"/get_active_binding_settings\")",
            "def get_active_binding_settings():",
            "    print(\"- Retreiving binding settings\")",
            "    if lollmsElfServer.binding is not None:",
            "        if hasattr(lollmsElfServer.binding,\"binding_config\"):",
            "            return lollmsElfServer.binding.binding_config.config_template.template",
            "        else:",
            "            return {}",
            "    else:",
            "        return {}",
            "",
            "# class BindingSettingsRequest(BaseModel):",
            "#     value: list ",
            "",
            "# @router.post(\"/set_active_binding_settings\")",
            "# async def set_active_binding_settings(request: BindingSettingsRequest):",
            "@router.post(\"/set_active_binding_settings\")",
            "async def set_active_binding_settings(request: Request):",
            "    data = await request.json()",
            "    \"\"\"",
            "    Sets the active binding settings.",
            "",
            "    :param request: The BindingSettingsRequest object.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "",
            "    try:",
            "        print(\"- Setting binding settings\")",
            "        ",
            "        if lollmsElfServer.binding is not None:",
            "            if hasattr(lollmsElfServer.binding,\"binding_config\"):",
            "                lollmsElfServer.binding.binding_config.update_template(data)",
            "                lollmsElfServer.binding.binding_config.config.save_config()",
            "                lollmsElfServer.binding.settings_updated()",
            "                if lollmsElfServer.config.auto_save:",
            "                    ASCIIColors.info(\"Saving configuration\")",
            "                    lollmsElfServer.config.save_config()",
            "                return {'status':True}",
            "            else:",
            "                return {'status':False}",
            "        else:",
            "            return {'status':False}",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        lollmsElfServer.error(ex)",
            "        return {\"status\":False,\"error\":str(ex)}",
            "    ",
            "@router.get(\"/update_binding_settings\")",
            "def update_binding_settings():",
            "    if lollmsElfServer.binding:",
            "        lollmsElfServer.binding.settings_updated()",
            "        ASCIIColors.green(\"Binding setting updated successfully\")",
            "        return {\"status\":True}",
            "    else:",
            "        return {\"status\":False, 'error':\"no binding found\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "17": [],
            "94": [
                "safe_name"
            ],
            "136": [
                "install_binding"
            ],
            "174": [
                "reinstall_binding"
            ],
            "210": [
                "unInstall_binding"
            ]
        },
        "addLocation": []
    },
    "lollms/server/endpoints/lollms_extensions_infos.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " def reinstall_extension(data: ExtensionInstallInfos):"
            },
            "1": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     if not data.name:"
            },
            "2": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         try:"
            },
            "3": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data.name=lollmsElfServer.config.extensions[-1]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            data.name=sanitize_path(lollmsElfServer.config.extensions[-1])"
            },
            "5": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         except Exception as ex:"
            },
            "6": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "             lollmsElfServer.error(ex)"
            },
            "7": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             return"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "project: lollms",
            "file: lollms_extensions_infos.py ",
            "author: ParisNeo",
            "description: ",
            "    This module contains a set of FastAPI routes that provide information about the Lord of Large Language and Multimodal Systems (LoLLMs) Web UI",
            "    application. These routes are specific to handling extensions related operations.",
            "",
            "\"\"\"",
            "from fastapi import APIRouter, Request",
            "from pydantic import BaseModel",
            "import pkg_resources",
            "from lollms.server.elf_server import LOLLMSElfServer",
            "from lollms.extension import ExtensionBuilder, InstallOption",
            "from lollms.utilities import gc",
            "from ascii_colors import ASCIIColors",
            "from lollms.utilities import load_config, trace_exception",
            "from pathlib import Path",
            "from typing import List",
            "import psutil",
            "import yaml",
            "from lollms.security import sanitize_path",
            "",
            "# --------------------- Parameter Classes -------------------------------",
            "class ExtensionInstallInfos(BaseModel):",
            "    name:str",
            "class ExtensionMountingInfos(BaseModel):",
            "    category:str",
            "    folder:str",
            "    language:str",
            "",
            "# ----------------------- Defining router and main class ------------------------------",
            "",
            "    ",
            "router = APIRouter()",
            "lollmsElfServer = LOLLMSElfServer.get_instance()",
            "",
            "# --------------------- Listing -------------------------------",
            "@router.get(\"/list_extensions_categories\")",
            "def list_extensions_categories():",
            "    extensions_categories_dir = lollmsElfServer.lollms_paths.extensions_zoo_path  # replace with the actual path to the models folder",
            "    extensions_categories = [f.stem for f in extensions_categories_dir.iterdir() if f.is_dir() and not f.name.startswith(\".\")]",
            "    return extensions_categories",
            "",
            "@router.get(\"/list_extensions\")",
            "def list_extensions():",
            "    return lollmsElfServer.config.extensions",
            "",
            "",
            "@router.get(\"/get_all_extensions\")",
            "def get_all_extensions():",
            "    ASCIIColors.yellow(\"Getting all extensions\")",
            "    extensions_folder = lollmsElfServer.lollms_paths.extensions_zoo_path",
            "    extensions = {}",
            "",
            "    for category_folder in  extensions_folder.iterdir():",
            "        cat = category_folder.stem",
            "        if category_folder.is_dir() and not category_folder.stem.startswith('.'):",
            "            extensions[category_folder.name] = []",
            "            for extensions_folder in category_folder.iterdir():",
            "                ext = extensions_folder.stem",
            "                if extensions_folder.is_dir() and not extensions_folder.stem.startswith('.'):",
            "                    extension_info = {\"folder\":extensions_folder.stem}",
            "                    config_path = extensions_folder / 'config.yaml'",
            "                    if not config_path.exists():",
            "                        continue                                    ",
            "                    try:",
            "                        with open(config_path) as config_file:",
            "                            config_data = yaml.load(config_file, Loader=yaml.FullLoader)",
            "                            extension_info['name'] = config_data.get('name',\"No Name\")",
            "                            extension_info['author'] = config_data.get('author', 'ParisNeo')",
            "                            extension_info['based_on'] = config_data.get('based_on',\"\")",
            "                            extension_info['description'] = config_data.get('description',\"\")",
            "                            extension_info['version'] = config_data.get('version', '1.0.0')",
            "                            extension_info['installed'] = (lollmsElfServer.lollms_paths.personal_configuration_path/f\"personality_{extensions_folder.stem}.yaml\").exists()",
            "                            extension_info['help'] = config_data.get('help', '')",
            "",
            "                        real_assets_path = extensions_folder/ 'assets'",
            "                        assets_path = Path(\"extensions\") / cat / ext / 'assets'",
            "                        gif_logo_path = assets_path / 'logo.gif'",
            "                        webp_logo_path = assets_path / 'logo.webp'",
            "                        png_logo_path = assets_path / 'logo.png'",
            "                        jpg_logo_path = assets_path / 'logo.jpg'",
            "                        jpeg_logo_path = assets_path / 'logo.jpeg'",
            "                        svg_logo_path = assets_path / 'logo.svg'",
            "                        bmp_logo_path = assets_path / 'logo.bmp'",
            "",
            "                        gif_logo_path_ = real_assets_path / 'logo.gif'",
            "                        webp_logo_path_ = real_assets_path / 'logo.webp'",
            "                        png_logo_path_ = real_assets_path / 'logo.png'",
            "                        jpg_logo_path_ = real_assets_path / 'logo.jpg'",
            "                        jpeg_logo_path_ = real_assets_path / 'logo.jpeg'",
            "                        svg_logo_path_ = real_assets_path / 'logo.svg'",
            "                        bmp_logo_path_ = real_assets_path / 'logo.bmp'",
            "                            ",
            "                        extension_info['has_logo'] = png_logo_path.is_file() or gif_logo_path.is_file()",
            "                        ",
            "                        if gif_logo_path_.exists():",
            "                            extension_info['avatar'] = str(gif_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif webp_logo_path_.exists():",
            "                            extension_info['avatar'] = str(webp_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif png_logo_path_.exists():",
            "                            extension_info['avatar'] = str(png_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpg_logo_path_.exists():",
            "                            extension_info['avatar'] = str(jpg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpeg_logo_path_.exists():",
            "                            extension_info['avatar'] = str(jpeg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif svg_logo_path_.exists():",
            "                            extension_info['avatar'] = str(svg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif bmp_logo_path_.exists():",
            "                            extension_info['avatar'] = str(bmp_logo_path).replace(\"\\\\\",\"/\")",
            "                        else:",
            "                            extension_info['avatar'] = \"\"",
            "                        ",
            "                        extensions[category_folder.name].append(extension_info)",
            "                    except Exception as ex:",
            "                        ASCIIColors.warning(f\"Couldn't load personality from {extensions_folder} [{ex}]\")",
            "                        trace_exception(ex)",
            "    return extensions",
            "",
            "",
            "",
            "# --------------------- Installing -------------------------------",
            "@router.post(\"/install_extension\")",
            "def install_extension(data: ExtensionInstallInfos):",
            "    if not data.name:",
            "        try:",
            "            data.name=lollmsElfServer.config.extensions[-1]",
            "        except Exception as ex:",
            "            lollmsElfServer.error(ex)",
            "            return",
            "    else:",
            "        data.name = sanitize_path(data.name)",
            "    try:",
            "        extension_path = lollmsElfServer.lollms_paths.extensions_zoo_path / data.name",
            "        ASCIIColors.info(f\"- Reinstalling extension {data.name}...\")",
            "        try:",
            "            lollmsElfServer.mounted_extensions.append(ExtensionBuilder().build_extension(extension_path,lollmsElfServer.lollms_paths, lollmsElfServer, InstallOption.FORCE_INSTALL))",
            "            return {\"status\":True}",
            "        except Exception as ex:",
            "            ASCIIColors.error(f\"Extension file not found or is corrupted ({data.name}).\\nReturned the following exception:{ex}\\nPlease verify that the personality you have selected exists or select another personality. Some updates may lead to change in personality name or category, so check the personality selection in settings to be sure.\")",
            "            trace_exception(ex)",
            "            ASCIIColors.info(\"Trying to force reinstall\")",
            "            return {\"status\":False, 'error':str(e)}",
            "",
            "    except Exception as e:",
            "        return {\"status\":False, 'error':str(e)}",
            "",
            "@router.post(\"/reinstall_extension\")",
            "def reinstall_extension(data: ExtensionInstallInfos):",
            "    if not data.name:",
            "        try:",
            "            data.name=lollmsElfServer.config.extensions[-1]",
            "        except Exception as ex:",
            "            lollmsElfServer.error(ex)",
            "            return",
            "    else:",
            "        data.name = sanitize_path(data.name)",
            "    try:",
            "        extension_path = lollmsElfServer.lollms_paths.extensions_zoo_path / data.name",
            "        ASCIIColors.info(f\"- Reinstalling extension {data.name}...\")",
            "        ASCIIColors.info(\"Unmounting extension\")",
            "        if data.name in lollmsElfServer.config.extensions:",
            "            idx = lollmsElfServer.config.extensions.index(data.name)",
            "            print(f\"index = {idx}\")",
            "            if len(lollmsElfServer.mount_extensions)>idx:",
            "                del lollmsElfServer.mounted_extensions[idx]",
            "            gc.collect()",
            "        try:",
            "            lollmsElfServer.mounted_extensions.append(ExtensionBuilder().build_extension(extension_path,lollmsElfServer.lollms_paths, lollmsElfServer, InstallOption.FORCE_INSTALL))",
            "            return {\"status\":True}",
            "        except Exception as ex:",
            "            ASCIIColors.error(f\"Extension file not found or is corrupted ({data.name}).\\nReturned the following exception:{ex}\\nPlease verify that the personality you have selected exists or select another personality. Some updates may lead to change in personality name or category, so check the personality selection in settings to be sure.\")",
            "            trace_exception(ex)",
            "            ASCIIColors.info(\"Trying to force reinstall\")",
            "            return {\"status\":False, 'error':str(e)}",
            "",
            "    except Exception as e:",
            "        return {\"status\":False, 'error':str(e)}",
            "    ",
            "",
            "# --------------------- Mounting -------------------------------",
            "",
            "",
            "@router.post(\"/mount_extension\")",
            "def mount_extension(data:ExtensionMountingInfos):",
            "    print(\"- Mounting extension\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    package_full_path = lollmsElfServer.lollms_paths.extensions_zoo_path/package_path",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        lollmsElfServer.config[\"extensions\"].append(package_path)",
            "        lollmsElfServer.mounted_extensions = lollmsElfServer.rebuild_extensions()",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        ASCIIColors.success(f\"Extension {name} mounted successfully\")",
            "        return {\"status\": True,",
            "                        \"extensions\":lollmsElfServer.config[\"extensions\"],",
            "                        }       ",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Extension not found @ {pth}\")",
            "        return {\"status\": False, \"error\":f\"Extension not found @ {pth}\"}",
            "",
            "",
            "@router.post(\"/remount_extension\")",
            "def remount_extension(data:ExtensionMountingInfos):",
            "    print(\"- Remounting extension\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    package_full_path = lollmsElfServer.lollms_paths.extensions_zoo_path/package_path",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        ASCIIColors.info(f\"Unmounting personality {package_path}\")",
            "        index = lollmsElfServer.config[\"extensions\"].index(f\"{category}/{name}\")",
            "        lollmsElfServer.config[\"extensions\"].remove(f\"{category}/{name}\")",
            "        if len(lollmsElfServer.config[\"extensions\"])>0:",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_extensions()",
            "        else:",
            "            lollmsElfServer.personalities = [\"generic/lollms\"]",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_extensions()",
            "",
            "",
            "        ASCIIColors.info(f\"Mounting personality {package_path}\")",
            "        lollmsElfServer.config[\"personalities\"].append(package_path)",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_extensions()",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]<0:",
            "            return {\"status\": False,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }     ",
            "        else:",
            "            return {\"status\": True,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Personality not found @ {pth}\")",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":f\"Personality not found @ {pth}\"} ",
            "",
            "@router.post(\"/unmount_extension\")",
            "def unmount_extension(data:ExtensionMountingInfos):",
            "    print(\"- Unmounting extension ...\")",
            "    category    = sanitize_path(data.category)",
            "    name        = sanitize_path(data.folder)",
            "    language    = sanitize_path(data.get('language',None))",
            "    try:",
            "        personality_id = f\"{category}/{name}\" if language is None else f\"{category}/{name}:{language}\"",
            "        index = lollmsElfServer.config[\"personalities\"].index(personality_id)",
            "        lollmsElfServer.config[\"extensions\"].remove(personality_id)",
            "        lollmsElfServer.mounted_extensions = lollmsElfServer.rebuild_extensions()",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        return {",
            "                    \"status\": True,",
            "                    \"extensions\":lollmsElfServer.config[\"extensions\"]",
            "                    }        ",
            "    except:",
            "        if language:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}:{language}\")",
            "        else:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}\")",
            "            ",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":\"Couldn't unmount personality\"}"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "project: lollms",
            "file: lollms_extensions_infos.py ",
            "author: ParisNeo",
            "description: ",
            "    This module contains a set of FastAPI routes that provide information about the Lord of Large Language and Multimodal Systems (LoLLMs) Web UI",
            "    application. These routes are specific to handling extensions related operations.",
            "",
            "\"\"\"",
            "from fastapi import APIRouter, Request",
            "from pydantic import BaseModel",
            "import pkg_resources",
            "from lollms.server.elf_server import LOLLMSElfServer",
            "from lollms.extension import ExtensionBuilder, InstallOption",
            "from lollms.utilities import gc",
            "from ascii_colors import ASCIIColors",
            "from lollms.utilities import load_config, trace_exception",
            "from pathlib import Path",
            "from typing import List",
            "import psutil",
            "import yaml",
            "from lollms.security import sanitize_path",
            "",
            "# --------------------- Parameter Classes -------------------------------",
            "class ExtensionInstallInfos(BaseModel):",
            "    name:str",
            "class ExtensionMountingInfos(BaseModel):",
            "    category:str",
            "    folder:str",
            "    language:str",
            "",
            "# ----------------------- Defining router and main class ------------------------------",
            "",
            "    ",
            "router = APIRouter()",
            "lollmsElfServer = LOLLMSElfServer.get_instance()",
            "",
            "# --------------------- Listing -------------------------------",
            "@router.get(\"/list_extensions_categories\")",
            "def list_extensions_categories():",
            "    extensions_categories_dir = lollmsElfServer.lollms_paths.extensions_zoo_path  # replace with the actual path to the models folder",
            "    extensions_categories = [f.stem for f in extensions_categories_dir.iterdir() if f.is_dir() and not f.name.startswith(\".\")]",
            "    return extensions_categories",
            "",
            "@router.get(\"/list_extensions\")",
            "def list_extensions():",
            "    return lollmsElfServer.config.extensions",
            "",
            "",
            "@router.get(\"/get_all_extensions\")",
            "def get_all_extensions():",
            "    ASCIIColors.yellow(\"Getting all extensions\")",
            "    extensions_folder = lollmsElfServer.lollms_paths.extensions_zoo_path",
            "    extensions = {}",
            "",
            "    for category_folder in  extensions_folder.iterdir():",
            "        cat = category_folder.stem",
            "        if category_folder.is_dir() and not category_folder.stem.startswith('.'):",
            "            extensions[category_folder.name] = []",
            "            for extensions_folder in category_folder.iterdir():",
            "                ext = extensions_folder.stem",
            "                if extensions_folder.is_dir() and not extensions_folder.stem.startswith('.'):",
            "                    extension_info = {\"folder\":extensions_folder.stem}",
            "                    config_path = extensions_folder / 'config.yaml'",
            "                    if not config_path.exists():",
            "                        continue                                    ",
            "                    try:",
            "                        with open(config_path) as config_file:",
            "                            config_data = yaml.load(config_file, Loader=yaml.FullLoader)",
            "                            extension_info['name'] = config_data.get('name',\"No Name\")",
            "                            extension_info['author'] = config_data.get('author', 'ParisNeo')",
            "                            extension_info['based_on'] = config_data.get('based_on',\"\")",
            "                            extension_info['description'] = config_data.get('description',\"\")",
            "                            extension_info['version'] = config_data.get('version', '1.0.0')",
            "                            extension_info['installed'] = (lollmsElfServer.lollms_paths.personal_configuration_path/f\"personality_{extensions_folder.stem}.yaml\").exists()",
            "                            extension_info['help'] = config_data.get('help', '')",
            "",
            "                        real_assets_path = extensions_folder/ 'assets'",
            "                        assets_path = Path(\"extensions\") / cat / ext / 'assets'",
            "                        gif_logo_path = assets_path / 'logo.gif'",
            "                        webp_logo_path = assets_path / 'logo.webp'",
            "                        png_logo_path = assets_path / 'logo.png'",
            "                        jpg_logo_path = assets_path / 'logo.jpg'",
            "                        jpeg_logo_path = assets_path / 'logo.jpeg'",
            "                        svg_logo_path = assets_path / 'logo.svg'",
            "                        bmp_logo_path = assets_path / 'logo.bmp'",
            "",
            "                        gif_logo_path_ = real_assets_path / 'logo.gif'",
            "                        webp_logo_path_ = real_assets_path / 'logo.webp'",
            "                        png_logo_path_ = real_assets_path / 'logo.png'",
            "                        jpg_logo_path_ = real_assets_path / 'logo.jpg'",
            "                        jpeg_logo_path_ = real_assets_path / 'logo.jpeg'",
            "                        svg_logo_path_ = real_assets_path / 'logo.svg'",
            "                        bmp_logo_path_ = real_assets_path / 'logo.bmp'",
            "                            ",
            "                        extension_info['has_logo'] = png_logo_path.is_file() or gif_logo_path.is_file()",
            "                        ",
            "                        if gif_logo_path_.exists():",
            "                            extension_info['avatar'] = str(gif_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif webp_logo_path_.exists():",
            "                            extension_info['avatar'] = str(webp_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif png_logo_path_.exists():",
            "                            extension_info['avatar'] = str(png_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpg_logo_path_.exists():",
            "                            extension_info['avatar'] = str(jpg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpeg_logo_path_.exists():",
            "                            extension_info['avatar'] = str(jpeg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif svg_logo_path_.exists():",
            "                            extension_info['avatar'] = str(svg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif bmp_logo_path_.exists():",
            "                            extension_info['avatar'] = str(bmp_logo_path).replace(\"\\\\\",\"/\")",
            "                        else:",
            "                            extension_info['avatar'] = \"\"",
            "                        ",
            "                        extensions[category_folder.name].append(extension_info)",
            "                    except Exception as ex:",
            "                        ASCIIColors.warning(f\"Couldn't load personality from {extensions_folder} [{ex}]\")",
            "                        trace_exception(ex)",
            "    return extensions",
            "",
            "",
            "",
            "# --------------------- Installing -------------------------------",
            "@router.post(\"/install_extension\")",
            "def install_extension(data: ExtensionInstallInfos):",
            "    if not data.name:",
            "        try:",
            "            data.name=lollmsElfServer.config.extensions[-1]",
            "        except Exception as ex:",
            "            lollmsElfServer.error(ex)",
            "            return",
            "    else:",
            "        data.name = sanitize_path(data.name)",
            "    try:",
            "        extension_path = lollmsElfServer.lollms_paths.extensions_zoo_path / data.name",
            "        ASCIIColors.info(f\"- Reinstalling extension {data.name}...\")",
            "        try:",
            "            lollmsElfServer.mounted_extensions.append(ExtensionBuilder().build_extension(extension_path,lollmsElfServer.lollms_paths, lollmsElfServer, InstallOption.FORCE_INSTALL))",
            "            return {\"status\":True}",
            "        except Exception as ex:",
            "            ASCIIColors.error(f\"Extension file not found or is corrupted ({data.name}).\\nReturned the following exception:{ex}\\nPlease verify that the personality you have selected exists or select another personality. Some updates may lead to change in personality name or category, so check the personality selection in settings to be sure.\")",
            "            trace_exception(ex)",
            "            ASCIIColors.info(\"Trying to force reinstall\")",
            "            return {\"status\":False, 'error':str(e)}",
            "",
            "    except Exception as e:",
            "        return {\"status\":False, 'error':str(e)}",
            "",
            "@router.post(\"/reinstall_extension\")",
            "def reinstall_extension(data: ExtensionInstallInfos):",
            "    if not data.name:",
            "        try:",
            "            data.name=sanitize_path(lollmsElfServer.config.extensions[-1])",
            "        except Exception as ex:",
            "            lollmsElfServer.error(ex)",
            "            return",
            "    else:",
            "        data.name = sanitize_path(data.name)",
            "    try:",
            "        extension_path = lollmsElfServer.lollms_paths.extensions_zoo_path / data.name",
            "        ASCIIColors.info(f\"- Reinstalling extension {data.name}...\")",
            "        ASCIIColors.info(\"Unmounting extension\")",
            "        if data.name in lollmsElfServer.config.extensions:",
            "            idx = lollmsElfServer.config.extensions.index(data.name)",
            "            print(f\"index = {idx}\")",
            "            if len(lollmsElfServer.mount_extensions)>idx:",
            "                del lollmsElfServer.mounted_extensions[idx]",
            "            gc.collect()",
            "        try:",
            "            lollmsElfServer.mounted_extensions.append(ExtensionBuilder().build_extension(extension_path,lollmsElfServer.lollms_paths, lollmsElfServer, InstallOption.FORCE_INSTALL))",
            "            return {\"status\":True}",
            "        except Exception as ex:",
            "            ASCIIColors.error(f\"Extension file not found or is corrupted ({data.name}).\\nReturned the following exception:{ex}\\nPlease verify that the personality you have selected exists or select another personality. Some updates may lead to change in personality name or category, so check the personality selection in settings to be sure.\")",
            "            trace_exception(ex)",
            "            ASCIIColors.info(\"Trying to force reinstall\")",
            "            return {\"status\":False, 'error':str(e)}",
            "",
            "    except Exception as e:",
            "        return {\"status\":False, 'error':str(e)}",
            "    ",
            "",
            "# --------------------- Mounting -------------------------------",
            "",
            "",
            "@router.post(\"/mount_extension\")",
            "def mount_extension(data:ExtensionMountingInfos):",
            "    print(\"- Mounting extension\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    package_full_path = lollmsElfServer.lollms_paths.extensions_zoo_path/package_path",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        lollmsElfServer.config[\"extensions\"].append(package_path)",
            "        lollmsElfServer.mounted_extensions = lollmsElfServer.rebuild_extensions()",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        ASCIIColors.success(f\"Extension {name} mounted successfully\")",
            "        return {\"status\": True,",
            "                        \"extensions\":lollmsElfServer.config[\"extensions\"],",
            "                        }       ",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Extension not found @ {pth}\")",
            "        return {\"status\": False, \"error\":f\"Extension not found @ {pth}\"}",
            "",
            "",
            "@router.post(\"/remount_extension\")",
            "def remount_extension(data:ExtensionMountingInfos):",
            "    print(\"- Remounting extension\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    package_full_path = lollmsElfServer.lollms_paths.extensions_zoo_path/package_path",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        ASCIIColors.info(f\"Unmounting personality {package_path}\")",
            "        index = lollmsElfServer.config[\"extensions\"].index(f\"{category}/{name}\")",
            "        lollmsElfServer.config[\"extensions\"].remove(f\"{category}/{name}\")",
            "        if len(lollmsElfServer.config[\"extensions\"])>0:",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_extensions()",
            "        else:",
            "            lollmsElfServer.personalities = [\"generic/lollms\"]",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_extensions()",
            "",
            "",
            "        ASCIIColors.info(f\"Mounting personality {package_path}\")",
            "        lollmsElfServer.config[\"personalities\"].append(package_path)",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_extensions()",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]<0:",
            "            return {\"status\": False,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }     ",
            "        else:",
            "            return {\"status\": True,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Personality not found @ {pth}\")",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":f\"Personality not found @ {pth}\"} ",
            "",
            "@router.post(\"/unmount_extension\")",
            "def unmount_extension(data:ExtensionMountingInfos):",
            "    print(\"- Unmounting extension ...\")",
            "    category    = sanitize_path(data.category)",
            "    name        = sanitize_path(data.folder)",
            "    language    = sanitize_path(data.get('language',None))",
            "    try:",
            "        personality_id = f\"{category}/{name}\" if language is None else f\"{category}/{name}:{language}\"",
            "        index = lollmsElfServer.config[\"personalities\"].index(personality_id)",
            "        lollmsElfServer.config[\"extensions\"].remove(personality_id)",
            "        lollmsElfServer.mounted_extensions = lollmsElfServer.rebuild_extensions()",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        return {",
            "                    \"status\": True,",
            "                    \"extensions\":lollmsElfServer.config[\"extensions\"]",
            "                    }        ",
            "    except:",
            "        if language:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}:{language}\")",
            "        else:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}\")",
            "            ",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":\"Couldn't unmount personality\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "153": [
                "reinstall_extension"
            ]
        },
        "addLocation": []
    }
}