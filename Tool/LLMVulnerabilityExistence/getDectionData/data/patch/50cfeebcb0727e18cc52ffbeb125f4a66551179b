{
    "src/werkzeug/formparser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "         self, stream: t.IO[bytes], boundary: bytes, content_length: int | None"
            },
            "1": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "     ) -> tuple[MultiDict[str, str], MultiDict[str, FileStorage]]:"
            },
            "2": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         current_part: Field | File"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        field_size: int | None = None"
            },
            "4": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         container: t.IO[bytes] | list[bytes]"
            },
            "5": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "         _write: t.Callable[[bytes], t.Any]"
            },
            "6": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 358,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "             while not isinstance(event, (Epilogue, NeedData)):"
            },
            "8": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "                 if isinstance(event, Field):"
            },
            "9": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "                     current_part = event"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+                    field_size = 0"
            },
            "11": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "                     container = []"
            },
            "12": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "                     _write = container.append"
            },
            "13": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "                 elif isinstance(event, File):"
            },
            "14": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "                     current_part = event"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+                    field_size = None"
            },
            "16": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "                     container = self.start_file_streaming(event, content_length)"
            },
            "17": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "                     _write = container.write"
            },
            "18": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "                 elif isinstance(event, Data):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+                    if self.max_form_memory_size is not None and field_size is not None:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+                        # Ensure that accumulated data events do not exceed limit."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+                        # Also checked within single event in MultipartDecoder."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+                        field_size += len(event.data)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+                        if field_size > self.max_form_memory_size:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+                            raise RequestEntityTooLarge()"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "                     _write(event.data)"
            },
            "28": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "                     if not event.more_data:"
            },
            "29": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "                         if isinstance(current_part, Field):"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import typing as t",
            "from io import BytesIO",
            "from urllib.parse import parse_qsl",
            "",
            "from ._internal import _plain_int",
            "from .datastructures import FileStorage",
            "from .datastructures import Headers",
            "from .datastructures import MultiDict",
            "from .exceptions import RequestEntityTooLarge",
            "from .http import parse_options_header",
            "from .sansio.multipart import Data",
            "from .sansio.multipart import Epilogue",
            "from .sansio.multipart import Field",
            "from .sansio.multipart import File",
            "from .sansio.multipart import MultipartDecoder",
            "from .sansio.multipart import NeedData",
            "from .wsgi import get_content_length",
            "from .wsgi import get_input_stream",
            "",
            "# there are some platforms where SpooledTemporaryFile is not available.",
            "# In that case we need to provide a fallback.",
            "try:",
            "    from tempfile import SpooledTemporaryFile",
            "except ImportError:",
            "    from tempfile import TemporaryFile",
            "",
            "    SpooledTemporaryFile = None  # type: ignore",
            "",
            "if t.TYPE_CHECKING:",
            "    import typing as te",
            "",
            "    from _typeshed.wsgi import WSGIEnvironment",
            "",
            "    t_parse_result = t.Tuple[",
            "        t.IO[bytes], MultiDict[str, str], MultiDict[str, FileStorage]",
            "    ]",
            "",
            "    class TStreamFactory(te.Protocol):",
            "        def __call__(",
            "            self,",
            "            total_content_length: int | None,",
            "            content_type: str | None,",
            "            filename: str | None,",
            "            content_length: int | None = None,",
            "        ) -> t.IO[bytes]: ...",
            "",
            "",
            "F = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])",
            "",
            "",
            "def default_stream_factory(",
            "    total_content_length: int | None,",
            "    content_type: str | None,",
            "    filename: str | None,",
            "    content_length: int | None = None,",
            ") -> t.IO[bytes]:",
            "    max_size = 1024 * 500",
            "",
            "    if SpooledTemporaryFile is not None:",
            "        return t.cast(t.IO[bytes], SpooledTemporaryFile(max_size=max_size, mode=\"rb+\"))",
            "    elif total_content_length is None or total_content_length > max_size:",
            "        return t.cast(t.IO[bytes], TemporaryFile(\"rb+\"))",
            "",
            "    return BytesIO()",
            "",
            "",
            "def parse_form_data(",
            "    environ: WSGIEnvironment,",
            "    stream_factory: TStreamFactory | None = None,",
            "    max_form_memory_size: int | None = None,",
            "    max_content_length: int | None = None,",
            "    cls: type[MultiDict[str, t.Any]] | None = None,",
            "    silent: bool = True,",
            "    *,",
            "    max_form_parts: int | None = None,",
            ") -> t_parse_result:",
            "    \"\"\"Parse the form data in the environ and return it as tuple in the form",
            "    ``(stream, form, files)``.  You should only call this method if the",
            "    transport method is `POST`, `PUT`, or `PATCH`.",
            "",
            "    If the mimetype of the data transmitted is `multipart/form-data` the",
            "    files multidict will be filled with `FileStorage` objects.  If the",
            "    mimetype is unknown the input stream is wrapped and returned as first",
            "    argument, else the stream is empty.",
            "",
            "    This is a shortcut for the common usage of :class:`FormDataParser`.",
            "",
            "    :param environ: the WSGI environment to be used for parsing.",
            "    :param stream_factory: An optional callable that returns a new read and",
            "                           writeable file descriptor.  This callable works",
            "                           the same as :meth:`Response._get_file_stream`.",
            "    :param max_form_memory_size: the maximum number of bytes to be accepted for",
            "                           in-memory stored form data.  If the data",
            "                           exceeds the value specified an",
            "                           :exc:`~exceptions.RequestEntityTooLarge`",
            "                           exception is raised.",
            "    :param max_content_length: If this is provided and the transmitted data",
            "                               is longer than this value an",
            "                               :exc:`~exceptions.RequestEntityTooLarge`",
            "                               exception is raised.",
            "    :param cls: an optional dict class to use.  If this is not specified",
            "                       or `None` the default :class:`MultiDict` is used.",
            "    :param silent: If set to False parsing errors will not be caught.",
            "    :param max_form_parts: The maximum number of multipart parts to be parsed. If this",
            "        is exceeded, a :exc:`~exceptions.RequestEntityTooLarge` exception is raised.",
            "    :return: A tuple in the form ``(stream, form, files)``.",
            "",
            "    .. versionchanged:: 3.0",
            "        The ``charset`` and ``errors`` parameters were removed.",
            "",
            "    .. versionchanged:: 2.3",
            "        Added the ``max_form_parts`` parameter.",
            "",
            "    .. versionadded:: 0.5.1",
            "       Added the ``silent`` parameter.",
            "",
            "    .. versionadded:: 0.5",
            "       Added the ``max_form_memory_size``, ``max_content_length``, and ``cls``",
            "       parameters.",
            "    \"\"\"",
            "    return FormDataParser(",
            "        stream_factory=stream_factory,",
            "        max_form_memory_size=max_form_memory_size,",
            "        max_content_length=max_content_length,",
            "        max_form_parts=max_form_parts,",
            "        silent=silent,",
            "        cls=cls,",
            "    ).parse_from_environ(environ)",
            "",
            "",
            "class FormDataParser:",
            "    \"\"\"This class implements parsing of form data for Werkzeug.  By itself",
            "    it can parse multipart and url encoded form data.  It can be subclassed",
            "    and extended but for most mimetypes it is a better idea to use the",
            "    untouched stream and expose it as separate attributes on a request",
            "    object.",
            "",
            "    :param stream_factory: An optional callable that returns a new read and",
            "                           writeable file descriptor.  This callable works",
            "                           the same as :meth:`Response._get_file_stream`.",
            "    :param max_form_memory_size: the maximum number of bytes to be accepted for",
            "                           in-memory stored form data.  If the data",
            "                           exceeds the value specified an",
            "                           :exc:`~exceptions.RequestEntityTooLarge`",
            "                           exception is raised.",
            "    :param max_content_length: If this is provided and the transmitted data",
            "                               is longer than this value an",
            "                               :exc:`~exceptions.RequestEntityTooLarge`",
            "                               exception is raised.",
            "    :param cls: an optional dict class to use.  If this is not specified",
            "                       or `None` the default :class:`MultiDict` is used.",
            "    :param silent: If set to False parsing errors will not be caught.",
            "    :param max_form_parts: The maximum number of multipart parts to be parsed. If this",
            "        is exceeded, a :exc:`~exceptions.RequestEntityTooLarge` exception is raised.",
            "",
            "    .. versionchanged:: 3.0",
            "        The ``charset`` and ``errors`` parameters were removed.",
            "",
            "    .. versionchanged:: 3.0",
            "        The ``parse_functions`` attribute and ``get_parse_func`` methods were removed.",
            "",
            "    .. versionchanged:: 2.2.3",
            "        Added the ``max_form_parts`` parameter.",
            "",
            "    .. versionadded:: 0.8",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        stream_factory: TStreamFactory | None = None,",
            "        max_form_memory_size: int | None = None,",
            "        max_content_length: int | None = None,",
            "        cls: type[MultiDict[str, t.Any]] | None = None,",
            "        silent: bool = True,",
            "        *,",
            "        max_form_parts: int | None = None,",
            "    ) -> None:",
            "        if stream_factory is None:",
            "            stream_factory = default_stream_factory",
            "",
            "        self.stream_factory = stream_factory",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_content_length = max_content_length",
            "        self.max_form_parts = max_form_parts",
            "",
            "        if cls is None:",
            "            cls = t.cast(\"type[MultiDict[str, t.Any]]\", MultiDict)",
            "",
            "        self.cls = cls",
            "        self.silent = silent",
            "",
            "    def parse_from_environ(self, environ: WSGIEnvironment) -> t_parse_result:",
            "        \"\"\"Parses the information from the environment as form data.",
            "",
            "        :param environ: the WSGI environment to be used for parsing.",
            "        :return: A tuple in the form ``(stream, form, files)``.",
            "        \"\"\"",
            "        stream = get_input_stream(environ, max_content_length=self.max_content_length)",
            "        content_length = get_content_length(environ)",
            "        mimetype, options = parse_options_header(environ.get(\"CONTENT_TYPE\"))",
            "        return self.parse(",
            "            stream,",
            "            content_length=content_length,",
            "            mimetype=mimetype,",
            "            options=options,",
            "        )",
            "",
            "    def parse(",
            "        self,",
            "        stream: t.IO[bytes],",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str] | None = None,",
            "    ) -> t_parse_result:",
            "        \"\"\"Parses the information from the given stream, mimetype,",
            "        content length and mimetype parameters.",
            "",
            "        :param stream: an input stream",
            "        :param mimetype: the mimetype of the data",
            "        :param content_length: the content length of the incoming data",
            "        :param options: optional mimetype parameters (used for",
            "                        the multipart boundary for instance)",
            "        :return: A tuple in the form ``(stream, form, files)``.",
            "",
            "        .. versionchanged:: 3.0",
            "            The invalid ``application/x-url-encoded`` content type is not",
            "            treated as ``application/x-www-form-urlencoded``.",
            "        \"\"\"",
            "        if mimetype == \"multipart/form-data\":",
            "            parse_func = self._parse_multipart",
            "        elif mimetype == \"application/x-www-form-urlencoded\":",
            "            parse_func = self._parse_urlencoded",
            "        else:",
            "            return stream, self.cls(), self.cls()",
            "",
            "        if options is None:",
            "            options = {}",
            "",
            "        try:",
            "            return parse_func(stream, mimetype, content_length, options)",
            "        except ValueError:",
            "            if not self.silent:",
            "                raise",
            "",
            "        return stream, self.cls(), self.cls()",
            "",
            "    def _parse_multipart(",
            "        self,",
            "        stream: t.IO[bytes],",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> t_parse_result:",
            "        parser = MultiPartParser(",
            "            stream_factory=self.stream_factory,",
            "            max_form_memory_size=self.max_form_memory_size,",
            "            max_form_parts=self.max_form_parts,",
            "            cls=self.cls,",
            "        )",
            "        boundary = options.get(\"boundary\", \"\").encode(\"ascii\")",
            "",
            "        if not boundary:",
            "            raise ValueError(\"Missing boundary\")",
            "",
            "        form, files = parser.parse(stream, boundary, content_length)",
            "        return stream, form, files",
            "",
            "    def _parse_urlencoded(",
            "        self,",
            "        stream: t.IO[bytes],",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> t_parse_result:",
            "        if (",
            "            self.max_form_memory_size is not None",
            "            and content_length is not None",
            "            and content_length > self.max_form_memory_size",
            "        ):",
            "            raise RequestEntityTooLarge()",
            "",
            "        items = parse_qsl(",
            "            stream.read().decode(),",
            "            keep_blank_values=True,",
            "            errors=\"werkzeug.url_quote\",",
            "        )",
            "        return stream, self.cls(items), self.cls()",
            "",
            "",
            "class MultiPartParser:",
            "    def __init__(",
            "        self,",
            "        stream_factory: TStreamFactory | None = None,",
            "        max_form_memory_size: int | None = None,",
            "        cls: type[MultiDict[str, t.Any]] | None = None,",
            "        buffer_size: int = 64 * 1024,",
            "        max_form_parts: int | None = None,",
            "    ) -> None:",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_form_parts = max_form_parts",
            "",
            "        if stream_factory is None:",
            "            stream_factory = default_stream_factory",
            "",
            "        self.stream_factory = stream_factory",
            "",
            "        if cls is None:",
            "            cls = t.cast(\"type[MultiDict[str, t.Any]]\", MultiDict)",
            "",
            "        self.cls = cls",
            "        self.buffer_size = buffer_size",
            "",
            "    def fail(self, message: str) -> te.NoReturn:",
            "        raise ValueError(message)",
            "",
            "    def get_part_charset(self, headers: Headers) -> str:",
            "        # Figure out input charset for current part",
            "        content_type = headers.get(\"content-type\")",
            "",
            "        if content_type:",
            "            parameters = parse_options_header(content_type)[1]",
            "            ct_charset = parameters.get(\"charset\", \"\").lower()",
            "",
            "            # A safe list of encodings. Modern clients should only send ASCII or UTF-8.",
            "            # This list will not be extended further.",
            "            if ct_charset in {\"ascii\", \"us-ascii\", \"utf-8\", \"iso-8859-1\"}:",
            "                return ct_charset",
            "",
            "        return \"utf-8\"",
            "",
            "    def start_file_streaming(",
            "        self, event: File, total_content_length: int | None",
            "    ) -> t.IO[bytes]:",
            "        content_type = event.headers.get(\"content-type\")",
            "",
            "        try:",
            "            content_length = _plain_int(event.headers[\"content-length\"])",
            "        except (KeyError, ValueError):",
            "            content_length = 0",
            "",
            "        container = self.stream_factory(",
            "            total_content_length=total_content_length,",
            "            filename=event.filename,",
            "            content_type=content_type,",
            "            content_length=content_length,",
            "        )",
            "        return container",
            "",
            "    def parse(",
            "        self, stream: t.IO[bytes], boundary: bytes, content_length: int | None",
            "    ) -> tuple[MultiDict[str, str], MultiDict[str, FileStorage]]:",
            "        current_part: Field | File",
            "        container: t.IO[bytes] | list[bytes]",
            "        _write: t.Callable[[bytes], t.Any]",
            "",
            "        parser = MultipartDecoder(",
            "            boundary,",
            "            max_form_memory_size=self.max_form_memory_size,",
            "            max_parts=self.max_form_parts,",
            "        )",
            "",
            "        fields = []",
            "        files = []",
            "",
            "        for data in _chunk_iter(stream.read, self.buffer_size):",
            "            parser.receive_data(data)",
            "            event = parser.next_event()",
            "            while not isinstance(event, (Epilogue, NeedData)):",
            "                if isinstance(event, Field):",
            "                    current_part = event",
            "                    container = []",
            "                    _write = container.append",
            "                elif isinstance(event, File):",
            "                    current_part = event",
            "                    container = self.start_file_streaming(event, content_length)",
            "                    _write = container.write",
            "                elif isinstance(event, Data):",
            "                    _write(event.data)",
            "                    if not event.more_data:",
            "                        if isinstance(current_part, Field):",
            "                            value = b\"\".join(container).decode(",
            "                                self.get_part_charset(current_part.headers), \"replace\"",
            "                            )",
            "                            fields.append((current_part.name, value))",
            "                        else:",
            "                            container = t.cast(t.IO[bytes], container)",
            "                            container.seek(0)",
            "                            files.append(",
            "                                (",
            "                                    current_part.name,",
            "                                    FileStorage(",
            "                                        container,",
            "                                        current_part.filename,",
            "                                        current_part.name,",
            "                                        headers=current_part.headers,",
            "                                    ),",
            "                                )",
            "                            )",
            "",
            "                event = parser.next_event()",
            "",
            "        return self.cls(fields), self.cls(files)",
            "",
            "",
            "def _chunk_iter(read: t.Callable[[int], bytes], size: int) -> t.Iterator[bytes | None]:",
            "    \"\"\"Read data in chunks for multipart/form-data parsing. Stop if no data is read.",
            "    Yield ``None`` at the end to signal end of parsing.",
            "    \"\"\"",
            "    while True:",
            "        data = read(size)",
            "",
            "        if not data:",
            "            break",
            "",
            "        yield data",
            "",
            "    yield None"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import typing as t",
            "from io import BytesIO",
            "from urllib.parse import parse_qsl",
            "",
            "from ._internal import _plain_int",
            "from .datastructures import FileStorage",
            "from .datastructures import Headers",
            "from .datastructures import MultiDict",
            "from .exceptions import RequestEntityTooLarge",
            "from .http import parse_options_header",
            "from .sansio.multipart import Data",
            "from .sansio.multipart import Epilogue",
            "from .sansio.multipart import Field",
            "from .sansio.multipart import File",
            "from .sansio.multipart import MultipartDecoder",
            "from .sansio.multipart import NeedData",
            "from .wsgi import get_content_length",
            "from .wsgi import get_input_stream",
            "",
            "# there are some platforms where SpooledTemporaryFile is not available.",
            "# In that case we need to provide a fallback.",
            "try:",
            "    from tempfile import SpooledTemporaryFile",
            "except ImportError:",
            "    from tempfile import TemporaryFile",
            "",
            "    SpooledTemporaryFile = None  # type: ignore",
            "",
            "if t.TYPE_CHECKING:",
            "    import typing as te",
            "",
            "    from _typeshed.wsgi import WSGIEnvironment",
            "",
            "    t_parse_result = t.Tuple[",
            "        t.IO[bytes], MultiDict[str, str], MultiDict[str, FileStorage]",
            "    ]",
            "",
            "    class TStreamFactory(te.Protocol):",
            "        def __call__(",
            "            self,",
            "            total_content_length: int | None,",
            "            content_type: str | None,",
            "            filename: str | None,",
            "            content_length: int | None = None,",
            "        ) -> t.IO[bytes]: ...",
            "",
            "",
            "F = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])",
            "",
            "",
            "def default_stream_factory(",
            "    total_content_length: int | None,",
            "    content_type: str | None,",
            "    filename: str | None,",
            "    content_length: int | None = None,",
            ") -> t.IO[bytes]:",
            "    max_size = 1024 * 500",
            "",
            "    if SpooledTemporaryFile is not None:",
            "        return t.cast(t.IO[bytes], SpooledTemporaryFile(max_size=max_size, mode=\"rb+\"))",
            "    elif total_content_length is None or total_content_length > max_size:",
            "        return t.cast(t.IO[bytes], TemporaryFile(\"rb+\"))",
            "",
            "    return BytesIO()",
            "",
            "",
            "def parse_form_data(",
            "    environ: WSGIEnvironment,",
            "    stream_factory: TStreamFactory | None = None,",
            "    max_form_memory_size: int | None = None,",
            "    max_content_length: int | None = None,",
            "    cls: type[MultiDict[str, t.Any]] | None = None,",
            "    silent: bool = True,",
            "    *,",
            "    max_form_parts: int | None = None,",
            ") -> t_parse_result:",
            "    \"\"\"Parse the form data in the environ and return it as tuple in the form",
            "    ``(stream, form, files)``.  You should only call this method if the",
            "    transport method is `POST`, `PUT`, or `PATCH`.",
            "",
            "    If the mimetype of the data transmitted is `multipart/form-data` the",
            "    files multidict will be filled with `FileStorage` objects.  If the",
            "    mimetype is unknown the input stream is wrapped and returned as first",
            "    argument, else the stream is empty.",
            "",
            "    This is a shortcut for the common usage of :class:`FormDataParser`.",
            "",
            "    :param environ: the WSGI environment to be used for parsing.",
            "    :param stream_factory: An optional callable that returns a new read and",
            "                           writeable file descriptor.  This callable works",
            "                           the same as :meth:`Response._get_file_stream`.",
            "    :param max_form_memory_size: the maximum number of bytes to be accepted for",
            "                           in-memory stored form data.  If the data",
            "                           exceeds the value specified an",
            "                           :exc:`~exceptions.RequestEntityTooLarge`",
            "                           exception is raised.",
            "    :param max_content_length: If this is provided and the transmitted data",
            "                               is longer than this value an",
            "                               :exc:`~exceptions.RequestEntityTooLarge`",
            "                               exception is raised.",
            "    :param cls: an optional dict class to use.  If this is not specified",
            "                       or `None` the default :class:`MultiDict` is used.",
            "    :param silent: If set to False parsing errors will not be caught.",
            "    :param max_form_parts: The maximum number of multipart parts to be parsed. If this",
            "        is exceeded, a :exc:`~exceptions.RequestEntityTooLarge` exception is raised.",
            "    :return: A tuple in the form ``(stream, form, files)``.",
            "",
            "    .. versionchanged:: 3.0",
            "        The ``charset`` and ``errors`` parameters were removed.",
            "",
            "    .. versionchanged:: 2.3",
            "        Added the ``max_form_parts`` parameter.",
            "",
            "    .. versionadded:: 0.5.1",
            "       Added the ``silent`` parameter.",
            "",
            "    .. versionadded:: 0.5",
            "       Added the ``max_form_memory_size``, ``max_content_length``, and ``cls``",
            "       parameters.",
            "    \"\"\"",
            "    return FormDataParser(",
            "        stream_factory=stream_factory,",
            "        max_form_memory_size=max_form_memory_size,",
            "        max_content_length=max_content_length,",
            "        max_form_parts=max_form_parts,",
            "        silent=silent,",
            "        cls=cls,",
            "    ).parse_from_environ(environ)",
            "",
            "",
            "class FormDataParser:",
            "    \"\"\"This class implements parsing of form data for Werkzeug.  By itself",
            "    it can parse multipart and url encoded form data.  It can be subclassed",
            "    and extended but for most mimetypes it is a better idea to use the",
            "    untouched stream and expose it as separate attributes on a request",
            "    object.",
            "",
            "    :param stream_factory: An optional callable that returns a new read and",
            "                           writeable file descriptor.  This callable works",
            "                           the same as :meth:`Response._get_file_stream`.",
            "    :param max_form_memory_size: the maximum number of bytes to be accepted for",
            "                           in-memory stored form data.  If the data",
            "                           exceeds the value specified an",
            "                           :exc:`~exceptions.RequestEntityTooLarge`",
            "                           exception is raised.",
            "    :param max_content_length: If this is provided and the transmitted data",
            "                               is longer than this value an",
            "                               :exc:`~exceptions.RequestEntityTooLarge`",
            "                               exception is raised.",
            "    :param cls: an optional dict class to use.  If this is not specified",
            "                       or `None` the default :class:`MultiDict` is used.",
            "    :param silent: If set to False parsing errors will not be caught.",
            "    :param max_form_parts: The maximum number of multipart parts to be parsed. If this",
            "        is exceeded, a :exc:`~exceptions.RequestEntityTooLarge` exception is raised.",
            "",
            "    .. versionchanged:: 3.0",
            "        The ``charset`` and ``errors`` parameters were removed.",
            "",
            "    .. versionchanged:: 3.0",
            "        The ``parse_functions`` attribute and ``get_parse_func`` methods were removed.",
            "",
            "    .. versionchanged:: 2.2.3",
            "        Added the ``max_form_parts`` parameter.",
            "",
            "    .. versionadded:: 0.8",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        stream_factory: TStreamFactory | None = None,",
            "        max_form_memory_size: int | None = None,",
            "        max_content_length: int | None = None,",
            "        cls: type[MultiDict[str, t.Any]] | None = None,",
            "        silent: bool = True,",
            "        *,",
            "        max_form_parts: int | None = None,",
            "    ) -> None:",
            "        if stream_factory is None:",
            "            stream_factory = default_stream_factory",
            "",
            "        self.stream_factory = stream_factory",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_content_length = max_content_length",
            "        self.max_form_parts = max_form_parts",
            "",
            "        if cls is None:",
            "            cls = t.cast(\"type[MultiDict[str, t.Any]]\", MultiDict)",
            "",
            "        self.cls = cls",
            "        self.silent = silent",
            "",
            "    def parse_from_environ(self, environ: WSGIEnvironment) -> t_parse_result:",
            "        \"\"\"Parses the information from the environment as form data.",
            "",
            "        :param environ: the WSGI environment to be used for parsing.",
            "        :return: A tuple in the form ``(stream, form, files)``.",
            "        \"\"\"",
            "        stream = get_input_stream(environ, max_content_length=self.max_content_length)",
            "        content_length = get_content_length(environ)",
            "        mimetype, options = parse_options_header(environ.get(\"CONTENT_TYPE\"))",
            "        return self.parse(",
            "            stream,",
            "            content_length=content_length,",
            "            mimetype=mimetype,",
            "            options=options,",
            "        )",
            "",
            "    def parse(",
            "        self,",
            "        stream: t.IO[bytes],",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str] | None = None,",
            "    ) -> t_parse_result:",
            "        \"\"\"Parses the information from the given stream, mimetype,",
            "        content length and mimetype parameters.",
            "",
            "        :param stream: an input stream",
            "        :param mimetype: the mimetype of the data",
            "        :param content_length: the content length of the incoming data",
            "        :param options: optional mimetype parameters (used for",
            "                        the multipart boundary for instance)",
            "        :return: A tuple in the form ``(stream, form, files)``.",
            "",
            "        .. versionchanged:: 3.0",
            "            The invalid ``application/x-url-encoded`` content type is not",
            "            treated as ``application/x-www-form-urlencoded``.",
            "        \"\"\"",
            "        if mimetype == \"multipart/form-data\":",
            "            parse_func = self._parse_multipart",
            "        elif mimetype == \"application/x-www-form-urlencoded\":",
            "            parse_func = self._parse_urlencoded",
            "        else:",
            "            return stream, self.cls(), self.cls()",
            "",
            "        if options is None:",
            "            options = {}",
            "",
            "        try:",
            "            return parse_func(stream, mimetype, content_length, options)",
            "        except ValueError:",
            "            if not self.silent:",
            "                raise",
            "",
            "        return stream, self.cls(), self.cls()",
            "",
            "    def _parse_multipart(",
            "        self,",
            "        stream: t.IO[bytes],",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> t_parse_result:",
            "        parser = MultiPartParser(",
            "            stream_factory=self.stream_factory,",
            "            max_form_memory_size=self.max_form_memory_size,",
            "            max_form_parts=self.max_form_parts,",
            "            cls=self.cls,",
            "        )",
            "        boundary = options.get(\"boundary\", \"\").encode(\"ascii\")",
            "",
            "        if not boundary:",
            "            raise ValueError(\"Missing boundary\")",
            "",
            "        form, files = parser.parse(stream, boundary, content_length)",
            "        return stream, form, files",
            "",
            "    def _parse_urlencoded(",
            "        self,",
            "        stream: t.IO[bytes],",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> t_parse_result:",
            "        if (",
            "            self.max_form_memory_size is not None",
            "            and content_length is not None",
            "            and content_length > self.max_form_memory_size",
            "        ):",
            "            raise RequestEntityTooLarge()",
            "",
            "        items = parse_qsl(",
            "            stream.read().decode(),",
            "            keep_blank_values=True,",
            "            errors=\"werkzeug.url_quote\",",
            "        )",
            "        return stream, self.cls(items), self.cls()",
            "",
            "",
            "class MultiPartParser:",
            "    def __init__(",
            "        self,",
            "        stream_factory: TStreamFactory | None = None,",
            "        max_form_memory_size: int | None = None,",
            "        cls: type[MultiDict[str, t.Any]] | None = None,",
            "        buffer_size: int = 64 * 1024,",
            "        max_form_parts: int | None = None,",
            "    ) -> None:",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_form_parts = max_form_parts",
            "",
            "        if stream_factory is None:",
            "            stream_factory = default_stream_factory",
            "",
            "        self.stream_factory = stream_factory",
            "",
            "        if cls is None:",
            "            cls = t.cast(\"type[MultiDict[str, t.Any]]\", MultiDict)",
            "",
            "        self.cls = cls",
            "        self.buffer_size = buffer_size",
            "",
            "    def fail(self, message: str) -> te.NoReturn:",
            "        raise ValueError(message)",
            "",
            "    def get_part_charset(self, headers: Headers) -> str:",
            "        # Figure out input charset for current part",
            "        content_type = headers.get(\"content-type\")",
            "",
            "        if content_type:",
            "            parameters = parse_options_header(content_type)[1]",
            "            ct_charset = parameters.get(\"charset\", \"\").lower()",
            "",
            "            # A safe list of encodings. Modern clients should only send ASCII or UTF-8.",
            "            # This list will not be extended further.",
            "            if ct_charset in {\"ascii\", \"us-ascii\", \"utf-8\", \"iso-8859-1\"}:",
            "                return ct_charset",
            "",
            "        return \"utf-8\"",
            "",
            "    def start_file_streaming(",
            "        self, event: File, total_content_length: int | None",
            "    ) -> t.IO[bytes]:",
            "        content_type = event.headers.get(\"content-type\")",
            "",
            "        try:",
            "            content_length = _plain_int(event.headers[\"content-length\"])",
            "        except (KeyError, ValueError):",
            "            content_length = 0",
            "",
            "        container = self.stream_factory(",
            "            total_content_length=total_content_length,",
            "            filename=event.filename,",
            "            content_type=content_type,",
            "            content_length=content_length,",
            "        )",
            "        return container",
            "",
            "    def parse(",
            "        self, stream: t.IO[bytes], boundary: bytes, content_length: int | None",
            "    ) -> tuple[MultiDict[str, str], MultiDict[str, FileStorage]]:",
            "        current_part: Field | File",
            "        field_size: int | None = None",
            "        container: t.IO[bytes] | list[bytes]",
            "        _write: t.Callable[[bytes], t.Any]",
            "",
            "        parser = MultipartDecoder(",
            "            boundary,",
            "            max_form_memory_size=self.max_form_memory_size,",
            "            max_parts=self.max_form_parts,",
            "        )",
            "",
            "        fields = []",
            "        files = []",
            "",
            "        for data in _chunk_iter(stream.read, self.buffer_size):",
            "            parser.receive_data(data)",
            "            event = parser.next_event()",
            "            while not isinstance(event, (Epilogue, NeedData)):",
            "                if isinstance(event, Field):",
            "                    current_part = event",
            "                    field_size = 0",
            "                    container = []",
            "                    _write = container.append",
            "                elif isinstance(event, File):",
            "                    current_part = event",
            "                    field_size = None",
            "                    container = self.start_file_streaming(event, content_length)",
            "                    _write = container.write",
            "                elif isinstance(event, Data):",
            "                    if self.max_form_memory_size is not None and field_size is not None:",
            "                        # Ensure that accumulated data events do not exceed limit.",
            "                        # Also checked within single event in MultipartDecoder.",
            "                        field_size += len(event.data)",
            "",
            "                        if field_size > self.max_form_memory_size:",
            "                            raise RequestEntityTooLarge()",
            "",
            "                    _write(event.data)",
            "                    if not event.more_data:",
            "                        if isinstance(current_part, Field):",
            "                            value = b\"\".join(container).decode(",
            "                                self.get_part_charset(current_part.headers), \"replace\"",
            "                            )",
            "                            fields.append((current_part.name, value))",
            "                        else:",
            "                            container = t.cast(t.IO[bytes], container)",
            "                            container.seek(0)",
            "                            files.append(",
            "                                (",
            "                                    current_part.name,",
            "                                    FileStorage(",
            "                                        container,",
            "                                        current_part.filename,",
            "                                        current_part.name,",
            "                                        headers=current_part.headers,",
            "                                    ),",
            "                                )",
            "                            )",
            "",
            "                event = parser.next_event()",
            "",
            "        return self.cls(fields), self.cls(files)",
            "",
            "",
            "def _chunk_iter(read: t.Callable[[int], bytes], size: int) -> t.Iterator[bytes | None]:",
            "    \"\"\"Read data in chunks for multipart/form-data parsing. Stop if no data is read.",
            "    Yield ``None`` at the end to signal end of parsing.",
            "    \"\"\"",
            "    while True:",
            "        data = read(size)",
            "",
            "        if not data:",
            "            break",
            "",
            "        yield data",
            "",
            "    yield None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "src/werkzeug/sansio/multipart.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "             self.max_form_memory_size is not None"
            },
            "1": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "             and len(self.buffer) + len(data) > self.max_form_memory_size"
            },
            "2": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         ):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            # Ensure that data within single event does not exceed limit."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            # Also checked across accumulated events in MultiPartParser."
            },
            "5": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "             raise RequestEntityTooLarge()"
            },
            "6": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         else:"
            },
            "7": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             self.buffer.extend(data)"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import re",
            "import typing as t",
            "from dataclasses import dataclass",
            "from enum import auto",
            "from enum import Enum",
            "",
            "from ..datastructures import Headers",
            "from ..exceptions import RequestEntityTooLarge",
            "from ..http import parse_options_header",
            "",
            "",
            "class Event:",
            "    pass",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Preamble(Event):",
            "    data: bytes",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Field(Event):",
            "    name: str",
            "    headers: Headers",
            "",
            "",
            "@dataclass(frozen=True)",
            "class File(Event):",
            "    name: str",
            "    filename: str",
            "    headers: Headers",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Data(Event):",
            "    data: bytes",
            "    more_data: bool",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Epilogue(Event):",
            "    data: bytes",
            "",
            "",
            "class NeedData(Event):",
            "    pass",
            "",
            "",
            "NEED_DATA = NeedData()",
            "",
            "",
            "class State(Enum):",
            "    PREAMBLE = auto()",
            "    PART = auto()",
            "    DATA = auto()",
            "    DATA_START = auto()",
            "    EPILOGUE = auto()",
            "    COMPLETE = auto()",
            "",
            "",
            "# Multipart line breaks MUST be CRLF (\\r\\n) by RFC-7578, except that",
            "# many implementations break this and either use CR or LF alone.",
            "LINE_BREAK = b\"(?:\\r\\n|\\n|\\r)\"",
            "BLANK_LINE_RE = re.compile(b\"(?:\\r\\n\\r\\n|\\r\\r|\\n\\n)\", re.MULTILINE)",
            "LINE_BREAK_RE = re.compile(LINE_BREAK, re.MULTILINE)",
            "# Header values can be continued via a space or tab after the linebreak, as",
            "# per RFC2231",
            "HEADER_CONTINUATION_RE = re.compile(b\"%s[ \\t]\" % LINE_BREAK, re.MULTILINE)",
            "# This must be long enough to contain any line breaks plus any",
            "# additional boundary markers (--) such that they will be found in a",
            "# subsequent search",
            "SEARCH_EXTRA_LENGTH = 8",
            "",
            "",
            "class MultipartDecoder:",
            "    \"\"\"Decodes a multipart message as bytes into Python events.",
            "",
            "    The part data is returned as available to allow the caller to save",
            "    the data from memory to disk, if desired.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        boundary: bytes,",
            "        max_form_memory_size: int | None = None,",
            "        *,",
            "        max_parts: int | None = None,",
            "    ) -> None:",
            "        self.buffer = bytearray()",
            "        self.complete = False",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_parts = max_parts",
            "        self.state = State.PREAMBLE",
            "        self.boundary = boundary",
            "",
            "        # Note in the below \\h i.e. horizontal whitespace is used",
            "        # as [^\\S\\n\\r] as \\h isn't supported in python.",
            "",
            "        # The preamble must end with a boundary where the boundary is",
            "        # prefixed by a line break, RFC2046. Except that many",
            "        # implementations including Werkzeug's tests omit the line",
            "        # break prefix. In addition the first boundary could be the",
            "        # epilogue boundary (for empty form-data) hence the matching",
            "        # group to understand if it is an epilogue boundary.",
            "        self.preamble_re = re.compile(",
            "            rb\"%s?--%s(--[^\\S\\n\\r]*%s?|[^\\S\\n\\r]*%s)\"",
            "            % (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),",
            "            re.MULTILINE,",
            "        )",
            "        # A boundary must include a line break prefix and suffix, and",
            "        # may include trailing whitespace. In addition the boundary",
            "        # could be the epilogue boundary hence the matching group to",
            "        # understand if it is an epilogue boundary.",
            "        self.boundary_re = re.compile(",
            "            rb\"%s--%s(--[^\\S\\n\\r]*%s?|[^\\S\\n\\r]*%s)\"",
            "            % (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),",
            "            re.MULTILINE,",
            "        )",
            "        self._search_position = 0",
            "        self._parts_decoded = 0",
            "",
            "    def last_newline(self, data: bytes) -> int:",
            "        try:",
            "            last_nl = data.rindex(b\"\\n\")",
            "        except ValueError:",
            "            last_nl = len(data)",
            "        try:",
            "            last_cr = data.rindex(b\"\\r\")",
            "        except ValueError:",
            "            last_cr = len(data)",
            "",
            "        return min(last_nl, last_cr)",
            "",
            "    def receive_data(self, data: bytes | None) -> None:",
            "        if data is None:",
            "            self.complete = True",
            "        elif (",
            "            self.max_form_memory_size is not None",
            "            and len(self.buffer) + len(data) > self.max_form_memory_size",
            "        ):",
            "            raise RequestEntityTooLarge()",
            "        else:",
            "            self.buffer.extend(data)",
            "",
            "    def next_event(self) -> Event:",
            "        event: Event = NEED_DATA",
            "",
            "        if self.state == State.PREAMBLE:",
            "            match = self.preamble_re.search(self.buffer, self._search_position)",
            "            if match is not None:",
            "                if match.group(1).startswith(b\"--\"):",
            "                    self.state = State.EPILOGUE",
            "                else:",
            "                    self.state = State.PART",
            "                data = bytes(self.buffer[: match.start()])",
            "                del self.buffer[: match.end()]",
            "                event = Preamble(data=data)",
            "                self._search_position = 0",
            "            else:",
            "                # Update the search start position to be equal to the",
            "                # current buffer length (already searched) minus a",
            "                # safe buffer for part of the search target.",
            "                self._search_position = max(",
            "                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH",
            "                )",
            "",
            "        elif self.state == State.PART:",
            "            match = BLANK_LINE_RE.search(self.buffer, self._search_position)",
            "            if match is not None:",
            "                headers = self._parse_headers(self.buffer[: match.start()])",
            "                # The final header ends with a single CRLF, however a",
            "                # blank line indicates the start of the",
            "                # body. Therefore the end is after the first CRLF.",
            "                headers_end = (match.start() + match.end()) // 2",
            "                del self.buffer[:headers_end]",
            "",
            "                if \"content-disposition\" not in headers:",
            "                    raise ValueError(\"Missing Content-Disposition header\")",
            "",
            "                disposition, extra = parse_options_header(",
            "                    headers[\"content-disposition\"]",
            "                )",
            "                name = t.cast(str, extra.get(\"name\"))",
            "                filename = extra.get(\"filename\")",
            "                if filename is not None:",
            "                    event = File(",
            "                        filename=filename,",
            "                        headers=headers,",
            "                        name=name,",
            "                    )",
            "                else:",
            "                    event = Field(",
            "                        headers=headers,",
            "                        name=name,",
            "                    )",
            "                self.state = State.DATA_START",
            "                self._search_position = 0",
            "                self._parts_decoded += 1",
            "",
            "                if self.max_parts is not None and self._parts_decoded > self.max_parts:",
            "                    raise RequestEntityTooLarge()",
            "            else:",
            "                # Update the search start position to be equal to the",
            "                # current buffer length (already searched) minus a",
            "                # safe buffer for part of the search target.",
            "                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)",
            "",
            "        elif self.state == State.DATA_START:",
            "            data, del_index, more_data = self._parse_data(self.buffer, start=True)",
            "            del self.buffer[:del_index]",
            "            event = Data(data=data, more_data=more_data)",
            "            if more_data:",
            "                self.state = State.DATA",
            "",
            "        elif self.state == State.DATA:",
            "            data, del_index, more_data = self._parse_data(self.buffer, start=False)",
            "            del self.buffer[:del_index]",
            "            if data or not more_data:",
            "                event = Data(data=data, more_data=more_data)",
            "",
            "        elif self.state == State.EPILOGUE and self.complete:",
            "            event = Epilogue(data=bytes(self.buffer))",
            "            del self.buffer[:]",
            "            self.state = State.COMPLETE",
            "",
            "        if self.complete and isinstance(event, NeedData):",
            "            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")",
            "",
            "        return event",
            "",
            "    def _parse_headers(self, data: bytes) -> Headers:",
            "        headers: list[tuple[str, str]] = []",
            "        # Merge the continued headers into one line",
            "        data = HEADER_CONTINUATION_RE.sub(b\" \", data)",
            "        # Now there is one header per line",
            "        for line in data.splitlines():",
            "            line = line.strip()",
            "",
            "            if line != b\"\":",
            "                name, _, value = line.decode().partition(\":\")",
            "                headers.append((name.strip(), value.strip()))",
            "        return Headers(headers)",
            "",
            "    def _parse_data(self, data: bytes, *, start: bool) -> tuple[bytes, int, bool]:",
            "        # Body parts must start with CRLF (or CR or LF)",
            "        if start:",
            "            match = LINE_BREAK_RE.match(data)",
            "            data_start = t.cast(t.Match[bytes], match).end()",
            "        else:",
            "            data_start = 0",
            "",
            "        boundary = b\"--\" + self.boundary",
            "",
            "        if self.buffer.find(boundary) == -1:",
            "            # No complete boundary in the buffer, but there may be",
            "            # a partial boundary at the end. As the boundary",
            "            # starts with either a nl or cr find the earliest and",
            "            # return up to that as data.",
            "            data_end = del_index = self.last_newline(data[data_start:]) + data_start",
            "            # If amount of data after last newline is far from",
            "            # possible length of partial boundary, we should",
            "            # assume that there is no partial boundary in the buffer",
            "            # and return all pending data.",
            "            if (len(data) - data_end) > len(b\"\\n\" + boundary):",
            "                data_end = del_index = len(data)",
            "            more_data = True",
            "        else:",
            "            match = self.boundary_re.search(data)",
            "            if match is not None:",
            "                if match.group(1).startswith(b\"--\"):",
            "                    self.state = State.EPILOGUE",
            "                else:",
            "                    self.state = State.PART",
            "                data_end = match.start()",
            "                del_index = match.end()",
            "            else:",
            "                data_end = del_index = self.last_newline(data[data_start:]) + data_start",
            "            more_data = match is None",
            "",
            "        return bytes(data[data_start:data_end]), del_index, more_data",
            "",
            "",
            "class MultipartEncoder:",
            "    def __init__(self, boundary: bytes) -> None:",
            "        self.boundary = boundary",
            "        self.state = State.PREAMBLE",
            "",
            "    def send_event(self, event: Event) -> bytes:",
            "        if isinstance(event, Preamble) and self.state == State.PREAMBLE:",
            "            self.state = State.PART",
            "            return event.data",
            "        elif isinstance(event, (Field, File)) and self.state in {",
            "            State.PREAMBLE,",
            "            State.PART,",
            "            State.DATA,",
            "        }:",
            "            data = b\"\\r\\n--\" + self.boundary + b\"\\r\\n\"",
            "            data += b'Content-Disposition: form-data; name=\"%s\"' % event.name.encode()",
            "            if isinstance(event, File):",
            "                data += b'; filename=\"%s\"' % event.filename.encode()",
            "            data += b\"\\r\\n\"",
            "            for name, value in t.cast(Field, event).headers:",
            "                if name.lower() != \"content-disposition\":",
            "                    data += f\"{name}: {value}\\r\\n\".encode()",
            "            self.state = State.DATA_START",
            "            return data",
            "        elif isinstance(event, Data) and self.state == State.DATA_START:",
            "            self.state = State.DATA",
            "            if len(event.data) > 0:",
            "                return b\"\\r\\n\" + event.data",
            "            else:",
            "                return event.data",
            "        elif isinstance(event, Data) and self.state == State.DATA:",
            "            return event.data",
            "        elif isinstance(event, Epilogue):",
            "            self.state = State.COMPLETE",
            "            return b\"\\r\\n--\" + self.boundary + b\"--\\r\\n\" + event.data",
            "        else:",
            "            raise ValueError(f\"Cannot generate {event} in state: {self.state}\")"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import re",
            "import typing as t",
            "from dataclasses import dataclass",
            "from enum import auto",
            "from enum import Enum",
            "",
            "from ..datastructures import Headers",
            "from ..exceptions import RequestEntityTooLarge",
            "from ..http import parse_options_header",
            "",
            "",
            "class Event:",
            "    pass",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Preamble(Event):",
            "    data: bytes",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Field(Event):",
            "    name: str",
            "    headers: Headers",
            "",
            "",
            "@dataclass(frozen=True)",
            "class File(Event):",
            "    name: str",
            "    filename: str",
            "    headers: Headers",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Data(Event):",
            "    data: bytes",
            "    more_data: bool",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Epilogue(Event):",
            "    data: bytes",
            "",
            "",
            "class NeedData(Event):",
            "    pass",
            "",
            "",
            "NEED_DATA = NeedData()",
            "",
            "",
            "class State(Enum):",
            "    PREAMBLE = auto()",
            "    PART = auto()",
            "    DATA = auto()",
            "    DATA_START = auto()",
            "    EPILOGUE = auto()",
            "    COMPLETE = auto()",
            "",
            "",
            "# Multipart line breaks MUST be CRLF (\\r\\n) by RFC-7578, except that",
            "# many implementations break this and either use CR or LF alone.",
            "LINE_BREAK = b\"(?:\\r\\n|\\n|\\r)\"",
            "BLANK_LINE_RE = re.compile(b\"(?:\\r\\n\\r\\n|\\r\\r|\\n\\n)\", re.MULTILINE)",
            "LINE_BREAK_RE = re.compile(LINE_BREAK, re.MULTILINE)",
            "# Header values can be continued via a space or tab after the linebreak, as",
            "# per RFC2231",
            "HEADER_CONTINUATION_RE = re.compile(b\"%s[ \\t]\" % LINE_BREAK, re.MULTILINE)",
            "# This must be long enough to contain any line breaks plus any",
            "# additional boundary markers (--) such that they will be found in a",
            "# subsequent search",
            "SEARCH_EXTRA_LENGTH = 8",
            "",
            "",
            "class MultipartDecoder:",
            "    \"\"\"Decodes a multipart message as bytes into Python events.",
            "",
            "    The part data is returned as available to allow the caller to save",
            "    the data from memory to disk, if desired.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        boundary: bytes,",
            "        max_form_memory_size: int | None = None,",
            "        *,",
            "        max_parts: int | None = None,",
            "    ) -> None:",
            "        self.buffer = bytearray()",
            "        self.complete = False",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_parts = max_parts",
            "        self.state = State.PREAMBLE",
            "        self.boundary = boundary",
            "",
            "        # Note in the below \\h i.e. horizontal whitespace is used",
            "        # as [^\\S\\n\\r] as \\h isn't supported in python.",
            "",
            "        # The preamble must end with a boundary where the boundary is",
            "        # prefixed by a line break, RFC2046. Except that many",
            "        # implementations including Werkzeug's tests omit the line",
            "        # break prefix. In addition the first boundary could be the",
            "        # epilogue boundary (for empty form-data) hence the matching",
            "        # group to understand if it is an epilogue boundary.",
            "        self.preamble_re = re.compile(",
            "            rb\"%s?--%s(--[^\\S\\n\\r]*%s?|[^\\S\\n\\r]*%s)\"",
            "            % (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),",
            "            re.MULTILINE,",
            "        )",
            "        # A boundary must include a line break prefix and suffix, and",
            "        # may include trailing whitespace. In addition the boundary",
            "        # could be the epilogue boundary hence the matching group to",
            "        # understand if it is an epilogue boundary.",
            "        self.boundary_re = re.compile(",
            "            rb\"%s--%s(--[^\\S\\n\\r]*%s?|[^\\S\\n\\r]*%s)\"",
            "            % (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),",
            "            re.MULTILINE,",
            "        )",
            "        self._search_position = 0",
            "        self._parts_decoded = 0",
            "",
            "    def last_newline(self, data: bytes) -> int:",
            "        try:",
            "            last_nl = data.rindex(b\"\\n\")",
            "        except ValueError:",
            "            last_nl = len(data)",
            "        try:",
            "            last_cr = data.rindex(b\"\\r\")",
            "        except ValueError:",
            "            last_cr = len(data)",
            "",
            "        return min(last_nl, last_cr)",
            "",
            "    def receive_data(self, data: bytes | None) -> None:",
            "        if data is None:",
            "            self.complete = True",
            "        elif (",
            "            self.max_form_memory_size is not None",
            "            and len(self.buffer) + len(data) > self.max_form_memory_size",
            "        ):",
            "            # Ensure that data within single event does not exceed limit.",
            "            # Also checked across accumulated events in MultiPartParser.",
            "            raise RequestEntityTooLarge()",
            "        else:",
            "            self.buffer.extend(data)",
            "",
            "    def next_event(self) -> Event:",
            "        event: Event = NEED_DATA",
            "",
            "        if self.state == State.PREAMBLE:",
            "            match = self.preamble_re.search(self.buffer, self._search_position)",
            "            if match is not None:",
            "                if match.group(1).startswith(b\"--\"):",
            "                    self.state = State.EPILOGUE",
            "                else:",
            "                    self.state = State.PART",
            "                data = bytes(self.buffer[: match.start()])",
            "                del self.buffer[: match.end()]",
            "                event = Preamble(data=data)",
            "                self._search_position = 0",
            "            else:",
            "                # Update the search start position to be equal to the",
            "                # current buffer length (already searched) minus a",
            "                # safe buffer for part of the search target.",
            "                self._search_position = max(",
            "                    0, len(self.buffer) - len(self.boundary) - SEARCH_EXTRA_LENGTH",
            "                )",
            "",
            "        elif self.state == State.PART:",
            "            match = BLANK_LINE_RE.search(self.buffer, self._search_position)",
            "            if match is not None:",
            "                headers = self._parse_headers(self.buffer[: match.start()])",
            "                # The final header ends with a single CRLF, however a",
            "                # blank line indicates the start of the",
            "                # body. Therefore the end is after the first CRLF.",
            "                headers_end = (match.start() + match.end()) // 2",
            "                del self.buffer[:headers_end]",
            "",
            "                if \"content-disposition\" not in headers:",
            "                    raise ValueError(\"Missing Content-Disposition header\")",
            "",
            "                disposition, extra = parse_options_header(",
            "                    headers[\"content-disposition\"]",
            "                )",
            "                name = t.cast(str, extra.get(\"name\"))",
            "                filename = extra.get(\"filename\")",
            "                if filename is not None:",
            "                    event = File(",
            "                        filename=filename,",
            "                        headers=headers,",
            "                        name=name,",
            "                    )",
            "                else:",
            "                    event = Field(",
            "                        headers=headers,",
            "                        name=name,",
            "                    )",
            "                self.state = State.DATA_START",
            "                self._search_position = 0",
            "                self._parts_decoded += 1",
            "",
            "                if self.max_parts is not None and self._parts_decoded > self.max_parts:",
            "                    raise RequestEntityTooLarge()",
            "            else:",
            "                # Update the search start position to be equal to the",
            "                # current buffer length (already searched) minus a",
            "                # safe buffer for part of the search target.",
            "                self._search_position = max(0, len(self.buffer) - SEARCH_EXTRA_LENGTH)",
            "",
            "        elif self.state == State.DATA_START:",
            "            data, del_index, more_data = self._parse_data(self.buffer, start=True)",
            "            del self.buffer[:del_index]",
            "            event = Data(data=data, more_data=more_data)",
            "            if more_data:",
            "                self.state = State.DATA",
            "",
            "        elif self.state == State.DATA:",
            "            data, del_index, more_data = self._parse_data(self.buffer, start=False)",
            "            del self.buffer[:del_index]",
            "            if data or not more_data:",
            "                event = Data(data=data, more_data=more_data)",
            "",
            "        elif self.state == State.EPILOGUE and self.complete:",
            "            event = Epilogue(data=bytes(self.buffer))",
            "            del self.buffer[:]",
            "            self.state = State.COMPLETE",
            "",
            "        if self.complete and isinstance(event, NeedData):",
            "            raise ValueError(f\"Invalid form-data cannot parse beyond {self.state}\")",
            "",
            "        return event",
            "",
            "    def _parse_headers(self, data: bytes) -> Headers:",
            "        headers: list[tuple[str, str]] = []",
            "        # Merge the continued headers into one line",
            "        data = HEADER_CONTINUATION_RE.sub(b\" \", data)",
            "        # Now there is one header per line",
            "        for line in data.splitlines():",
            "            line = line.strip()",
            "",
            "            if line != b\"\":",
            "                name, _, value = line.decode().partition(\":\")",
            "                headers.append((name.strip(), value.strip()))",
            "        return Headers(headers)",
            "",
            "    def _parse_data(self, data: bytes, *, start: bool) -> tuple[bytes, int, bool]:",
            "        # Body parts must start with CRLF (or CR or LF)",
            "        if start:",
            "            match = LINE_BREAK_RE.match(data)",
            "            data_start = t.cast(t.Match[bytes], match).end()",
            "        else:",
            "            data_start = 0",
            "",
            "        boundary = b\"--\" + self.boundary",
            "",
            "        if self.buffer.find(boundary) == -1:",
            "            # No complete boundary in the buffer, but there may be",
            "            # a partial boundary at the end. As the boundary",
            "            # starts with either a nl or cr find the earliest and",
            "            # return up to that as data.",
            "            data_end = del_index = self.last_newline(data[data_start:]) + data_start",
            "            # If amount of data after last newline is far from",
            "            # possible length of partial boundary, we should",
            "            # assume that there is no partial boundary in the buffer",
            "            # and return all pending data.",
            "            if (len(data) - data_end) > len(b\"\\n\" + boundary):",
            "                data_end = del_index = len(data)",
            "            more_data = True",
            "        else:",
            "            match = self.boundary_re.search(data)",
            "            if match is not None:",
            "                if match.group(1).startswith(b\"--\"):",
            "                    self.state = State.EPILOGUE",
            "                else:",
            "                    self.state = State.PART",
            "                data_end = match.start()",
            "                del_index = match.end()",
            "            else:",
            "                data_end = del_index = self.last_newline(data[data_start:]) + data_start",
            "            more_data = match is None",
            "",
            "        return bytes(data[data_start:data_end]), del_index, more_data",
            "",
            "",
            "class MultipartEncoder:",
            "    def __init__(self, boundary: bytes) -> None:",
            "        self.boundary = boundary",
            "        self.state = State.PREAMBLE",
            "",
            "    def send_event(self, event: Event) -> bytes:",
            "        if isinstance(event, Preamble) and self.state == State.PREAMBLE:",
            "            self.state = State.PART",
            "            return event.data",
            "        elif isinstance(event, (Field, File)) and self.state in {",
            "            State.PREAMBLE,",
            "            State.PART,",
            "            State.DATA,",
            "        }:",
            "            data = b\"\\r\\n--\" + self.boundary + b\"\\r\\n\"",
            "            data += b'Content-Disposition: form-data; name=\"%s\"' % event.name.encode()",
            "            if isinstance(event, File):",
            "                data += b'; filename=\"%s\"' % event.filename.encode()",
            "            data += b\"\\r\\n\"",
            "            for name, value in t.cast(Field, event).headers:",
            "                if name.lower() != \"content-disposition\":",
            "                    data += f\"{name}: {value}\\r\\n\".encode()",
            "            self.state = State.DATA_START",
            "            return data",
            "        elif isinstance(event, Data) and self.state == State.DATA_START:",
            "            self.state = State.DATA",
            "            if len(event.data) > 0:",
            "                return b\"\\r\\n\" + event.data",
            "            else:",
            "                return event.data",
            "        elif isinstance(event, Data) and self.state == State.DATA:",
            "            return event.data",
            "        elif isinstance(event, Epilogue):",
            "            self.state = State.COMPLETE",
            "            return b\"\\r\\n--\" + self.boundary + b\"--\\r\\n\" + event.data",
            "        else:",
            "            raise ValueError(f\"Cannot generate {event} in state: {self.state}\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "aiohttp.client_reqrep"
        ]
    }
}